// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.22/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/mathUtils ../../../../../core/maybe ../../../../../core/Quantity ../../../../../chunks/earcut ../../../../../chunks/vec2 ../../../../../chunks/vec2f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/vec4f64 ../../../../../geometry/projection ../../../../../geometry/projectionEllipsoid ../../../../../geometry/SpatialReference ../../../../../geometry/support/intersectsBase ../../support/measurementUtils ../../support/viewUtils ../../../support/ElevationProvider ../../../support/mathUtils".split(" "),
function(I,O,D,y,J,E,K,n,k,P,q,F,Q,L,t,M,R,G){function N(A,g){const a=new Float64Array(A.length*g);for(let d=0;d<A.length;++d){const b=A[d];for(let c=0;c<g;++c)a[d*g+c]=b[c]}return a}let S=function(){function A(a,d){this.positionsWorldCoords=[];this.positionsRenderCoords=[];this.positionsProjectedWorldCoords=[];this.positionsFittedRenderCoords=[];this.positionsGeographic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=
[];this.intersectingSegments=new Set;this.geodesicIntersectingSegments=new Set;this.areaCentroidWorldCoords=k.create();this.areaCentroidRenderCoords=k.create();this.geodesicAreaCentroidRenderCoords=k.create();this._length=0;this._centroidRenderCoords=k.create();this._planeWorldCoords=P.create();this._worldUp=k.create();this._worldTangent=k.create();this._frame=[k.create(),k.create(),k.create()];this._pathVersion=-1;this._hasCursorPoint=this._validMeasurement=!1;this._mode=null;this._tempU=k.create();
this._tempV=k.create();this._tempVec3=k.create();this._tempSphere={center:k.create(),radius:0};this._sceneView=a;this.unitNormalizer=d}var g=A.prototype;g.update=function(a,d,b,c,e,f,l){const u=this.unitNormalizer,p=this._sceneView.renderSpatialReference,m=this.unitNormalizer.spatialReference,h=D.isSome(d);if(this._pathVersion===a.version&&this._validMeasurement===c&&!l&&this._hasCursorPoint===h&&this._mode===f)return!1;this._pathVersion=a.version;this._validMeasurement=c;this._hasCursorPoint=h;this._resize(a.numVertices);
const x=F.getSphericalPCPF(b.spatialReference),v=q.canProjectWithoutEngine(b.spatialReference,x)&&q.canProjectToWGS84ComparableLonLat(b.spatialReference),r=this.positionsGeographic,w=this.positionsWorldCoords,B=this.positionsRenderCoords,H=this.positionsSpherical;a.forEachVertexPosition((z,C)=>{z.hasZ||(z.z=D.unwrapOr(R.getElevationAtPoint(b.elevationProvider,z,"ground"),0));q.projectPointToVector(z,w[C],m);q.projectPointToVector(z,B[C],p);v&&(q.projectPointToWGS84ComparableLonLat(z,r[C]),q.projectPointToVector(z,
H[C],x),n.normalize(H[C],H[C]))});l=this._updatePathLengths(c);this.pathLength=1<this._length?new y(u.normalizeDistance(l),"meters"):null;v?(l=this._updateGeodesicPathLengths(c,m),this.geodesicPathLength=1<this._length?new y(l,"meters"):null):this.geodesicPathLength=null;this._updateCursorSegmentLength(a,d);this._updateMode(a,f);if(!c)return this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),
!0;this._updateArea(b,u,p,m,e);v&&this._updateGeodesicArea(b);return!0};g.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,
geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,
area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}};g._resize=function(a){a<this._length&&(this.positionsWorldCoords.length=a,this.positionsRenderCoords.length=a,this.positionsProjectedWorldCoords.length=a,this.positionsFittedRenderCoords.length=
a,this.positionsGeographic.length=a,this.positionsSpherical.length=a,this.positionsStereographic.length=a,this.pathSegmentLengths.length=a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=a);for(;this._length<a;)this.positionsWorldCoords.push(k.create()),this.positionsRenderCoords.push(k.create()),this.positionsProjectedWorldCoords.push(K.create()),this.positionsFittedRenderCoords.push(k.create()),this.positionsGeographic.push(k.create()),this.positionsSpherical.push(k.create()),
this.positionsStereographic.push(K.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length};g._updatePathLengths=function(a){const d=this.positionsWorldCoords,b=this.pathSegmentLengths;let c=0;for(let e=0;e<this._length;++e){const f=b[e]=n.distance(d[e],d[(e+1)%this._length]);if(e<this._length-1||a)c+=f}return c};g._updateGeodesicPathLengths=function(a,d){const b=this.positionsGeographic,c=this.geodesicPathSegmentLengths;
let e=0;for(let f=0;f<this._length;++f){const l=c[f]=t.segmentLengthGeodesicVector(b[f],b[(f+1)%this._length],d);if(f<this._length-1||a)e+=l}return e};g._updateArea=function(a,d,b,c,e){const f=a.renderCoordsHelper;a=this.positionsWorldCoords;const l=this.positionsRenderCoords,u=this.positionsProjectedWorldCoords,p=this.positionsFittedRenderCoords;var m=this._planeWorldCoords,h=this._centroidRenderCoords;M.midpoint(l,h);f.worldUpAtPosition(h,this._worldUp);f.worldBasisAtPosition(h,0,this._worldTangent);
q.projectDirection(h,this._worldUp,b,this._worldUp,c);q.projectDirection(h,this._worldTangent,b,this._worldTangent,c);2<a.length&&t.bestFitPlane(a,m);this.fittingMode=this._selectFittingMode(m,a,this._worldUp,e);let x=0;if("horizontal"===this.fittingMode){let r=-Infinity;l.forEach((w,B)=>{w=f.getAltitude(l[B]);w>r&&(r=w,x=B)})}e=a[x];h=m;var v=this._worldTangent;"horizontal"===this.fittingMode?h=this._worldUp:"vertical"===this.fittingMode&&(h=this._tempVec3,v=this._worldUp,G.makeOrthonormal(m,this._worldUp,
h));n.copy(this._frame[2],h);G.makeOrthonormal(v,h,this._frame[0]);n.cross(this._frame[1],this._frame[0],this._frame[2]);n.negate(this._frame[1],this._frame[1]);m=this._tempVec3;h=this._tempU;v=this._tempV;for(let r=0;r<this._length;++r){const w=u[r],B=p[r];n.subtract(m,a[r],e);E.set(w,n.dot(this._frame[0],m),n.dot(this._frame[1],m));n.scale(h,this._frame[0],w[0]);n.scale(v,this._frame[1],w[1]);n.add(m,h,v);n.add(m,m,e);q.projectVectorToVector(m,c,B,b)}this.perimeterLength=0<this._length?new y(d.normalizeDistance(this._updatePerimeterLengths()),
"meters"):null;M.midpoint(p,this.areaCentroidRenderCoords);q.projectVectorToVector(this.areaCentroidRenderCoords,b,this.areaCentroidWorldCoords,c);this._updateIntersectingSegments();this.area=0===this.intersectingSegments.size?new y(d.normalizeArea(this._computeArea()),"square-meters"):null};g._updateGeodesicArea=function(a){const d=a.renderCoordsHelper,b=this.positionsSpherical,c=this.positionsStereographic,e=this._tempVec3,f=t.fitHemisphere(b,e);if(f){var l=this._tempU,u=this._tempV;G.tangentFrame(e,
l,u);for(let p=0;p<this._length;++p){const m=n.dot(b[p],l),h=n.dot(b[p],u),x=n.dot(b[p],e);E.set(c[p],m/x,h/x)}n.scale(e,e,F.getReferenceEllipsoid(a.spatialReference).radius);d.toRenderCoords(e,F.getSphericalPCPF(a.spatialReference),this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=f&&0===this.geodesicIntersectingSegments.size?new y(this._computeGeodesicArea(),"square-meters"):null}else this.geodesicArea=null};g._updatePerimeterLengths=function(){const a=
this.positionsProjectedWorldCoords,d=this.perimeterSegmentLengths;let b=0;for(let c=0;c<this._length;++c){const e=d[c]=E.distance(a[c],a[(c+1)%this._length]);b+=e}return b};g._updateIntersectingSegments=function(){const a=this.positionsProjectedWorldCoords,d=this.intersectingSegments;d.clear();for(let b=0;b<this._length;++b)for(let c=b+2;c<this._length;++c)(c+1)%this._length!==b&&L.segmentIntersects(a[b],a[(b+1)%this._length],a[c],a[(c+1)%this._length])&&(d.add(b),d.add(c))};g._computeArea=function(){const a=
this.positionsProjectedWorldCoords;var d=N(a,2);d=this.triangleIndices=new Uint32Array(J.earcut(d,[],2));let b=0;for(let c=0;c<d.length;c+=3)b+=t.triangleAreaEuclidean(a[d[c]],a[d[c+1]],a[d[c+2]]);return b};g._updateGeodesicIntersectingSegments=function(){const a=this.positionsStereographic,d=this.geodesicIntersectingSegments;d.clear();for(let b=0;b<this._length;++b)for(let c=b+2;c<this._length;++c)(c+1)%this._length!==b&&L.segmentIntersects(a[b],a[(b+1)%this._length],a[c],a[(c+1)%this._length])&&
(d.add(b),d.add(c))};g._computeGeodesicArea=function(){const a=this.positionsGeographic;var d=N(this.positionsStereographic,2);d=this.geodesicTriangleIndices=new Uint32Array(J.earcut(d,[],2));let b=0;for(let c=0;c<d.length;c+=3)b+=t.triangleAreaGeodesic(a[d[c]],a[d[c+1]],a[d[c+2]],Q.WGS84);return b};g._selectFittingMode=function(a,d,b,c){var e=d.map(l=>Math.abs(t.planePointDistance(a,l))).reduce((l,u)=>Math.max(l,u),0);t.boundingSphere(d,this._tempSphere);d=e/(2*this._tempSphere.radius);e=d<c.maxRelativeErrorAlmostCoplanar;
let f="horizontal";d<c.maxRelativeErrorCoplanar?f="oblique":e&&(f=Math.abs(n.dot(b,a))>Math.cos(O.deg2rad(c.verticalAngleThreshold))?"horizontal":"vertical");return f};g._updateCursorSegmentLength=function(a,d){const b=a.lastPoint;!a.isValidPolygon&&D.isSome(b)&&D.isSome(d)?(this.geodesicCursorSegmentLength=new y(t.segmentLengthGeodesic(b,d),"meters"),this.cursorSegmentLength=new y(this.unitNormalizer.normalizeDistance(t.segmentLengthEuclidean(b,d,this.unitNormalizer.spatialReference)),"meters")):
this.cursorSegmentLength=this.geodesicCursorSegmentLength=null};g._updateMode=function(a,d){if(0===d){this.actualMeasurementMode="euclidean";let b=0;null!=this.geodesicPathLength&&(b+=this.geodesicPathLength.value);!a.isValidPolygon&&D.isSome(this.geodesicCursorSegmentLength)&&(b+=this.geodesicCursorSegmentLength.value);1E5<b&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=1===d?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean");
this._mode=d};return A}();I.MeasurementDataManager=S;Object.defineProperty(I,"__esModule",{value:!0})});