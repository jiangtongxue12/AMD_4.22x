// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.22/esri/copyright.txt for details.
//>>built
require({
  cache: {
    "esri/core/iteratorUtils": function () { define(["exports"], function (a) { a.cache = function (w) { const c = []; return function* () { yield* c; for (const q of w) c.push(q), yield q } }; a.find = function (w, c) { for (const q of w) if (null != q && c(q)) return q }; a.isIterable = function (w) { return null != w && "function" === typeof w[Symbol.iterator] }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/chunks/boundedPlane": function () {
      define("exports ../core/has ../core/Logger ../core/mathUtils ../core/ObjectStack ./mat4 ./mat4f64 ./vec3 ./vec3f64 ../geometry/support/lineSegment ../geometry/support/plane ../geometry/support/ray ../geometry/support/vector ../geometry/support/vectorStacks".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          function v(Z = ha) { return { plane: b.create(Z.plane), origin: l.clone(Z.origin), basis1: l.clone(Z.basis1), basis2: l.clone(Z.basis2) } } function m(Z, ia, la) { const ma = aa.get(); ma.origin = Z; ma.basis1 = ia; ma.basis2 = la; ma.plane = b.wrap(0, 0, 0, 0); k(ma); return ma } function e(Z, ia = v()) { return x(Z.origin, Z.basis1, Z.basis2, ia) } function g(Z, ia) { p.copy(ia.origin, Z.origin); p.copy(ia.basis1, Z.basis1); p.copy(ia.basis2, Z.basis2); b.copy(Z.plane, ia.plane) } function x(Z, ia, la, ma = v()) {
            p.copy(ma.origin,
              Z); p.copy(ma.basis1, ia); p.copy(ma.basis2, la); k(ma); 1E-6 < Math.abs(p.dot(ma.basis1, ma.basis2) / (p.length(ma.basis1) * p.length(ma.basis2))) && fa.warn("fromValues()", "Provided basis vectors are not perpendicular"); 1E-6 < Math.abs(p.dot(ma.basis1, S(ma))) && fa.warn("fromValues()", "Basis vectors and plane normal are not perpendicular"); 1E-6 < Math.abs(-p.dot(S(ma), ma.origin) - ma.plane[3]) && fa.warn("fromValues()", "Plane offset is not consistent with plane origin"); return ma
          } function k(Z) {
            b.fromVectorsAndPoint(Z.basis2,
              Z.basis1, Z.origin, Z.plane)
          } function r(Z, ia, la) { Z !== la && e(Z, la); Z = p.scale(t.sv3d.get(), S(Z), ia); p.add(la.origin, la.origin, Z); la.plane[3] -= ia; return la } function A(Z, ia, la) { z(ia, la); r(la, N(Z, Z.origin), la); return la } function z(Z, ia = v()) { const la = (Z[2] - Z[0]) / 2, ma = (Z[3] - Z[1]) / 2; p.set(ia.origin, Z[0] + la, Z[1] + ma, 0); p.set(ia.basis1, la, 0, 0); p.set(ia.basis2, 0, ma, 0); b.fromValues(0, 0, 1, 0, ia.plane); return ia } function B(Z, ia, la) { return b.intersectRay(Z.plane, ia, la) ? Q(Z, la) : !1 } function C(Z, ia, la) {
            if (B(Z, ia, la)) return la;
            Z = D(Z, ia, t.sv3d.get()); p.add(la, ia.origin, p.scale(t.sv3d.get(), ia.direction, p.distance(ia.origin, Z) / p.length(ia.direction))); return la
          } function D(Z, ia, la) {
            const ma = ka.get(); var ra = ka.get(); Y(Z, ia, ma, ra); ra = Number.POSITIVE_INFINITY; for (const za of W) { var Aa = da(Z, za, ea.get()); const Ka = t.sv3d.get(); b.intersectLineSegment(ma, Aa, Ka) && (Aa = p.direction(t.sv3d.get(), ia.origin, Ka), Aa = Math.abs(q.acosClamped(p.dot(ia.direction, Aa))), Aa < ra && (ra = Aa, p.copy(la, Ka))) } return ra === Number.POSITIVE_INFINITY ? E(Z, ia, la) :
              la
          } function E(Z, ia, la) { if (B(Z, ia, la)) return la; const ma = ka.get(), ra = ka.get(); Y(Z, ia, ma, ra); let Aa = Number.POSITIVE_INFINITY; for (const Ka of W) { var za = da(Z, Ka, ea.get()); const Ea = t.sv3d.get(); b.intersectLineSegmentClamp(ma, za, Ea) && (za = d.distance2(ia, Ea), b.isPointInside(ra, Ea) && za < Aa && (Aa = za, p.copy(la, Ea))) } M(Z, ia.origin) < Aa && H(Z, ia.origin, la); return la } function H(Z, ia, la) {
            var ma = b.projectPoint(Z.plane, ia, t.sv3d.get()); ia = h.projectPointClamp(T(Z, Z.basis1), ma, -1, 1, t.sv3d.get()); ma = h.projectPointClamp(T(Z,
              Z.basis2), ma, -1, 1, t.sv3d.get()); p.subtract(la, p.add(t.sv3d.get(), ia, ma), Z.origin); return la
          } function J(Z, ia, la) { const { origin: ma, basis1: ra, basis2: Aa } = Z, za = p.subtract(t.sv3d.get(), ia, ma); ia = f.projectPointSignedLength(ra, za); const Ka = f.projectPointSignedLength(Aa, za); Z = f.projectPointSignedLength(S(Z), za); return p.set(la, ia, Ka, Z) } function M(Z, ia) {
            ia = J(Z, ia, t.sv3d.get()); const { basis1: la, basis2: ma } = Z; Z = p.length(la); var ra = p.length(ma); Z = Math.max(Math.abs(ia[0]) - Z, 0); ra = Math.max(Math.abs(ia[1]) - ra, 0);
            ia = ia[2]; return Z * Z + ra * ra + ia * ia
          } function F(Z, ia) { return Math.sqrt(M(Z, ia)) } function K(Z, ia) { let la = Number.NEGATIVE_INFINITY; for (const ra of W) { var ma = da(Z, ra, ea.get()); ma = h.distance2(ma, ia); ma > la && (la = ma) } return Math.sqrt(la) } function P(Z, ia) { return b.isPointInside(Z.plane, ia) && Q(Z, ia) } function L(Z, ia, la, ma) { switch (la) { case 0: p.copy(ma, Z.basis1); p.normalize(ma, ma); break; case 1: p.copy(ma, Z.basis2); p.normalize(ma, ma); break; case 2: p.copy(ma, S(Z)) }return ma } function N(Z, ia) {
            const la = -Z.plane[3]; return f.projectPointSignedLength(S(Z),
              ia) - la
          } function G(Z, ia, la, ma) { const ra = N(Z, ia); Z = p.scale(ba, S(Z), la - ra); p.add(ma, ia, Z); return ma } function I(Z, ia) { return p.exactEquals(Z.basis1, ia.basis1) && p.exactEquals(Z.basis2, ia.basis2) && p.exactEquals(Z.origin, ia.origin) } function O(Z, ia, la) {
          Z !== la && e(Z, la); y.invert(U, ia); y.transpose(U, U); p.transformMat4(la.basis1, Z.basis1, U); p.transformMat4(la.basis2, Z.basis2, U); p.transformMat4(b.normal(la.plane), b.normal(Z.plane), U); p.transformMat4(la.origin, Z.origin, ia); b.setOffsetFromPoint(la.plane, la.origin,
            la.plane); return la
          } function R(Z, ia, la, ma) { Z !== ma && e(Z, ma); y.rotate(X, y.identity(X), ia, la); p.transformMat4(ma.basis1, Z.basis1, X); p.transformMat4(ma.basis2, Z.basis2, X); k(ma); return ma } function S(Z) { return b.normal(Z.plane) } function Q(Z, ia) { const la = p.subtract(t.sv3d.get(), ia, Z.origin); ia = p.squaredLength(Z.basis1); const ma = p.squaredLength(Z.basis2), ra = p.dot(Z.basis1, la); Z = p.dot(Z.basis2, la); return 0 > -ra - ia && 0 > ra - ia && 0 > -Z - ma && 0 > Z - ma } function T(Z, ia) {
            const la = ea.get(); p.copy(la.origin, Z.origin); p.copy(la.vector,
              ia); return la
          } function da(Z, ia, la) { const { basis1: ma, basis2: ra, origin: Aa } = Z; Z = p.scale(t.sv3d.get(), ma, ia.origin[0]); const za = p.scale(t.sv3d.get(), ra, ia.origin[1]); p.add(la.origin, Z, za); p.add(la.origin, la.origin, Aa); Z = p.scale(t.sv3d.get(), ma, ia.direction[0]); ia = p.scale(t.sv3d.get(), ra, ia.direction[1]); p.scale(la.vector, p.add(Z, Z, ia), 2); return la } function Y(Z, ia, la, ma) { Z = S(Z); b.fromVectorsAndPoint(Z, ia.direction, ia.origin, la); b.fromVectorsAndPoint(b.normal(la), Z, ia.origin, ma) } const fa = c.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");
          w = function () { this.plane = b.create(); this.origin = l.create(); this.basis1 = l.create(); this.basis2 = l.create() }; const ha = { plane: b.create(), origin: l.fromValues(0, 0, 0), basis1: l.fromValues(1, 0, 0), basis2: l.fromValues(0, 1, 0) }, ka = new u.ObjectStack(b.create), ea = new u.ObjectStack(h.create), ba = l.create(), aa = new u.ObjectStack(() => ({ origin: null, basis1: null, basis2: null, plane: null })), W = [{ origin: [-1, -1], direction: [1, 0] }, { origin: [1, -1], direction: [0, 1] }, { origin: [1, 1], direction: [-1, 0] }, { origin: [-1, 1], direction: [0, -1] }],
            U = n.create(), X = n.create(); u = Object.freeze({ __proto__: null, BoundedPlaneClass: w, create: v, wrap: m, copy: e, copyWithoutVerify: g, fromValues: x, updateUnboundedPlane: k, elevate: r, setExtent: A, fromAABoundingRect: z, intersectRay: B, intersectRayClosestSilhouette: C, closestPointOnSilhouette: D, closestPoint: E, projectPoint: H, projectPointLocal: J, distance2: M, distance: F, distanceToSilhouette: K, extrusionContainsPoint: P, axisAt: L, altitudeAt: N, setAltitudeAt: G, equals: I, transform: O, rotate: R, normal: S, UP: ha }); a.BoundedPlaneClass = w;
          a.UP = ha; a.altitudeAt = N; a.axisAt = L; a.boundedPlane = u; a.closestPoint = E; a.closestPointOnSilhouette = D; a.copy = e; a.copyWithoutVerify = g; a.create = v; a.distance = F; a.distance2 = M; a.distanceToSilhouette = K; a.elevate = r; a.equals = I; a.extrusionContainsPoint = P; a.fromAABoundingRect = z; a.fromValues = x; a.intersectRay = B; a.intersectRayClosestSilhouette = C; a.normal = S; a.projectPoint = H; a.projectPointLocal = J; a.rotate = R; a.setAltitudeAt = G; a.setExtent = A; a.transform = O; a.updateUnboundedPlane = k; a.wrap = m
        })
    }, "esri/core/ObjectStack": function () {
      define(["exports",
        "./nextTick"], function (a, w) {
          let c = function () {
            function q(y) { this.allocator = y; this._items = []; this._itemsPtr = 0; this.grow() } var u = q.prototype; u.get = function () { 0 === this._itemsPtr && w.nextTick(() => this.reset()); this._itemsPtr === this._items.length && this.grow(); return this._items[this._itemsPtr++] }; u.reset = function () { this._items.length = Math.min(Math.min(3 * Math.max(8, this._itemsPtr), this._itemsPtr + 3072), this._items.length); this._itemsPtr = 0 }; u.grow = function () {
              for (let y = 0; y < Math.max(8, Math.min(this._items.length,
                1024)); y++)this._items.push(this.allocator())
            }; return q
          }(); a.ObjectStack = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/mat4f64": function () {
      define(["exports"], function (a) {
        function w() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } function c(p) { return [p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]] } function q(p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z) { return [p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z] } function u(p, l) { return new Float64Array(p, l, 16) } const y = w(), n = Object.freeze({
          __proto__: null,
          create: w, clone: c, fromValues: q, createView: u, IDENTITY: y
        }); a.IDENTITY = y; a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.mat4f64 = n
      })
    }, "esri/geometry/support/lineSegment": function () {
      define("exports ../../core/mathUtils ../../core/ObjectStack ../../chunks/vec3 ../../chunks/vec3f64 ./vectorStacks".split(" "), function (a, w, c, q, u, y) {
        function n(v) { return v ? { origin: u.clone(v.origin), vector: u.clone(v.vector) } : { origin: u.create(), vector: u.create() } } function p(v, m) { const e = t.get(); e.origin = v; e.vector = m; return e }
        function l(v, m, e = n()) { q.copy(e.origin, v); q.copy(e.vector, m); return e } function h(v, m) { m = q.subtract(y.sv3d.get(), m, v.origin); var e = q.dot(v.vector, m); const g = q.dot(v.vector, v.vector); e = w.clamp(e / g, 0, 1); v = q.subtract(y.sv3d.get(), q.scale(y.sv3d.get(), v.vector, e), m); return q.dot(v, v) } function b(v, m, e, g, x) { const { vector: k, origin: r } = v; m = q.subtract(y.sv3d.get(), m, r); m = q.dot(k, m) / q.squaredLength(k); q.scale(x, k, w.clamp(m, e, g)); return q.add(x, x, v.origin) } function d(v, m, e, g) {
          const x = v.origin; var k = q.add(y.sv3d.get(),
            x, v.vector); v = m.origin; var r = q.add(y.sv3d.get(), v, m.vector), A = y.sv3d.get(); m = y.sv3d.get(); A[0] = x[0] - v[0]; A[1] = x[1] - v[1]; A[2] = x[2] - v[2]; m[0] = r[0] - v[0]; m[1] = r[1] - v[1]; m[2] = r[2] - v[2]; if (1E-6 > Math.abs(m[0]) && 1E-6 > Math.abs(m[1]) && 1E-6 > Math.abs(m[2])) return !1; r = y.sv3d.get(); r[0] = k[0] - x[0]; r[1] = k[1] - x[1]; r[2] = k[2] - x[2]; if (1E-6 > Math.abs(r[0]) && 1E-6 > Math.abs(r[1]) && 1E-6 > Math.abs(r[2])) return !1; k = A[0] * m[0] + A[1] * m[1] + A[2] * m[2]; var z = m[0] * r[0] + m[1] * r[1] + m[2] * r[2]; const B = m[0] * m[0] + m[1] * m[1] + m[2] * m[2], C = (r[0] *
              r[0] + r[1] * r[1] + r[2] * r[2]) * B - z * z; if (1E-6 > Math.abs(C)) return !1; A = (k * z - (A[0] * r[0] + A[1] * r[1] + A[2] * r[2]) * B) / C; k = (k + z * A) / B; e && (A = w.clamp(A, 0, 1), k = w.clamp(k, 0, 1)); e = y.sv3d.get(); z = y.sv3d.get(); e[0] = x[0] + A * r[0]; e[1] = x[1] + A * r[1]; e[2] = x[2] + A * r[2]; z[0] = v[0] + k * m[0]; z[1] = v[1] + k * m[1]; z[2] = v[2] + k * m[2]; g.tA = A; g.tB = k; g.pA = e; g.pB = z; g.distance2 = q.squaredDistance(e, z); return !0
        } const f = { tA: 0, tB: 0, pA: u.create(), pB: u.create(), distance2: 0 }, t = new c.ObjectStack(() => ({ origin: null, vector: null })); a.closestLineSegmentDistance2 =
          function (v, m) { return d(v, m, !0, f) ? f.distance2 : null }; a.closestLineSegmentPoint = function (v, m, e) { return d(v, m, !0, f) ? (q.copy(e, f.pA), !0) : !1 }; a.closestRayDistance2 = function (v, m) { if (d(v, p(m.origin, m.direction), !1, f)) { const { tA: e, pB: g, distance2: x } = f; if (0 <= e && 1 >= e) return x; if (0 > e) return q.squaredDistance(v.origin, g); if (1 < e) return q.squaredDistance(q.add(y.sv3d.get(), v.origin, v.vector), g) } return null }; a.copy = function (v, m = n()) { return l(v.origin, v.vector, m) }; a.create = n; a.distance = function (v, m) {
            return Math.sqrt(h(v,
              m))
          }; a.distance2 = h; a.fromPoints = function (v, m, e = n()) { q.copy(e.origin, v); q.subtract(e.vector, m, v); return e }; a.fromValues = l; a.pointAt = function (v, m, e) { return q.add(e, v.origin, q.scale(e, v.vector, m)) }; a.projectPoint = function (v, m, e) { return b(v, m, 0, 1, e) }; a.projectPointClamp = b; a.wrap = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/vectorStacks": function () {
      define(["exports", "../../core/VectorStack"], function (a, w) {
        const c = w.VectorStack.createVec2f64(), q = w.VectorStack.createVec3f64(),
        u = w.VectorStack.createVec4f64(), y = w.VectorStack.createMat3f64(), n = w.VectorStack.createMat4f64(); w = w.VectorStack.createQuatf64(); a.sm3d = y; a.sm4d = n; a.sq4d = w; a.sv2d = c; a.sv3d = q; a.sv4d = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/VectorStack": function () {
      define("exports ../chunks/_rollupPluginBabelHelpers ./nextTick ../chunks/mat3f64 ../chunks/mat4f64 ../chunks/quatf64 ../chunks/vec2f64 ../chunks/vec3f64 ../chunks/vec4f64".split(" "), function (a, w, c, q, u, y, n, p, l) {
        let h = function () {
          function b(f,
            t, v) { this.itemByteSize = f; this.itemCreate = t; this._buffers = []; this._items = []; this._itemsPtr = 0; this._itemsPerBuffer = Math.ceil(v / this.itemByteSize) } var d = b.prototype; d.get = function () { 0 === this._itemsPtr && c.nextTick(() => this.reset()); const f = Math.floor(this._itemsPtr / this._itemsPerBuffer); for (; this._buffers.length <= f;) { const t = new ArrayBuffer(this._itemsPerBuffer * this.itemByteSize); for (let v = 0; v < this._itemsPerBuffer; ++v)this._items.push(this.itemCreate(t, v * this.itemByteSize)); this._buffers.push(t) } return this._items[this._itemsPtr++] };
          d.reset = function () { const f = 2 * (Math.floor(this._itemsPtr / this._itemsPerBuffer) + 1); for (; this._buffers.length > f;)this._buffers.pop(), this._items.length = this._buffers.length * this._itemsPerBuffer; this._itemsPtr = 0 }; b.createVec2f64 = function (f = 4096) { return new b(16, n.createView, f) }; b.createVec3f64 = function (f = 4096) { return new b(24, p.createView, f) }; b.createVec4f64 = function (f = 4096) { return new b(32, l.createView, f) }; b.createMat3f64 = function (f = 4096) { return new b(72, q.createView, f) }; b.createMat4f64 = function (f = 4096) {
            return new b(128,
              u.createView, f)
          }; b.createQuatf64 = function (f = 4096) { return new b(32, y.createView, f) }; w._createClass(b, [{ key: "test", get: function () { return { size: this._buffers.length * this._itemsPerBuffer * this.itemByteSize } } }]); return b
        }(); a.VectorStack = h; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/mat3f64": function () {
      define(["exports"], function (a) {
        function w() { return [1, 0, 0, 0, 1, 0, 0, 0, 1] } function c(n) { return [n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8]] } function q(n, p, l, h, b, d, f, t, v) {
          return [n, p, l, h, b,
            d, f, t, v]
        } function u(n, p) { return new Float64Array(n, p, 9) } const y = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, createView: u }); a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.mat3f64 = y
      })
    }, "esri/chunks/quatf64": function () {
      define(["exports"], function (a) {
        function w() { return [0, 0, 0, 1] } function c(p) { return [p[0], p[1], p[2], p[3]] } function q(p, l, h, b) { return [p, l, h, b] } function u(p, l) { return new Float64Array(p, l, 4) } const y = w(), n = Object.freeze({
          __proto__: null, create: w, clone: c, fromValues: q, createView: u,
          IDENTITY: y
        }); a.IDENTITY = y; a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.quatf64 = n
      })
    }, "esri/chunks/vec2f64": function () {
      define(["exports"], function (a) {
        function w() { return [0, 0] } function c(m) { return [m[0], m[1]] } function q(m, e) { return [m, e] } function u(m) { const e = [0, 0], g = Math.min(2, m.length); for (let x = 0; x < g; ++x)e[x] = m[x]; return e } function y(m, e) { return new Float64Array(m, e, 2) } function n() { return [0, 0] } function p() { return [1, 1] } function l() { return [1, 0] } function h() { return [0, 1] } const b = [0, 0], d = [1, 1], f =
          [1, 0], t = [0, 1], v = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, fromArray: u, createView: y, zeros: n, ones: p, unitX: l, unitY: h, ZEROS: b, ONES: d, UNIT_X: f, UNIT_Y: t }); a.ONES = d; a.UNIT_X = f; a.UNIT_Y = t; a.ZEROS = b; a.clone = c; a.create = w; a.createView = y; a.fromArray = u; a.fromValues = q; a.ones = p; a.unitX = l; a.unitY = h; a.vec2f64 = v; a.zeros = n
      })
    }, "esri/chunks/vec4f64": function () {
      define(["exports"], function (a) {
        function w() { return [0, 0, 0, 0] } function c(k) { return [k[0], k[1], k[2], k[3]] } function q(k, r, A, z) { return [k, r, A, z] } function u(k) {
          const r =
            w(), A = Math.min(4, k.length); for (let z = 0; z < A; ++z)r[z] = k[z]; return r
        } function y(k, r) { return new Float64Array(k, r, 4) } function n() { return w() } function p() { return [1, 1, 1, 1] } function l() { return [1, 0, 0, 0] } function h() { return [0, 1, 0, 0] } function b() { return [0, 0, 1, 0] } function d() { return [0, 0, 0, 1] } const f = w(), t = p(), v = l(), m = h(), e = b(), g = d(), x = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, fromArray: u, createView: y, zeros: n, ones: p, unitX: l, unitY: h, unitZ: b, unitW: d, ZEROS: f, ONES: t, UNIT_X: v, UNIT_Y: m, UNIT_Z: e, UNIT_W: g });
        a.ONES = t; a.UNIT_W = g; a.UNIT_X = v; a.UNIT_Y = m; a.UNIT_Z = e; a.ZEROS = f; a.clone = c; a.create = w; a.createView = y; a.fromArray = u; a.fromValues = q; a.ones = p; a.unitW = d; a.unitX = l; a.unitY = h; a.unitZ = b; a.vec4f64 = x; a.zeros = n
      })
    }, "esri/geometry/support/plane": function () {
      define("exports ../../core/mathUtils ../../core/maybe ../../chunks/vec3 ../../chunks/vec3f64 ../../chunks/sphere ./vectorStacks".split(" "), function (a, w, c, q, u, y, n) {
        function p(z = A) { return [z[0], z[1], z[2], z[3]] } function l(z, B = p()) { return h(z[0], z[1], z[2], z[3], B) }
        function h(z, B, C, D, E = p()) { E[0] = z; E[1] = B; E[2] = C; E[3] = D; return E } function b(z, B, C) { var D = B[0] * B[0] + B[1] * B[1] + B[2] * B[2]; D = 1E-5 < Math.abs(D - 1) && 1E-12 < D ? 1 / Math.sqrt(D) : 1; C[0] = B[0] * D; C[1] = B[1] * D; C[2] = B[2] * D; C[3] = -(C[0] * z[0] + C[1] * z[1] + C[2] * z[2]); return C } function d(z, B, C, D = p()) {
          var E = C[0] - B[0], H = C[1] - B[1], J = C[2] - B[2]; C = z[0] - B[0]; const M = z[1] - B[1], F = z[2] - B[2]; B = H * F - J * M; J = J * C - E * F; E = E * M - H * C; H = B * B + J * J + E * E; H = 1E-5 < Math.abs(H - 1) && 1E-12 < H ? 1 / Math.sqrt(H) : 1; D[0] = B * H; D[1] = J * H; D[2] = E * H; D[3] = -(D[0] * z[0] + D[1] * z[1] + D[2] *
            z[2])
        } function f(z, B, C, D, E) { if (3 > z.count) return !1; z.getVec(C, e); let H = D, J = !1; for (; H < z.count - 1 && !J;)z.getVec(H, g), H++ , J = !q.exactEquals(e, g); if (!J) return !1; H = Math.max(H, E); for (J = !1; H < z.count && !J;)z.getVec(H, x), H++ , q.subtract(k, e, g), q.normalize(k, k), q.subtract(r, g, x), q.normalize(r, r), J = !q.exactEquals(e, x) && !q.exactEquals(g, x) && .99619469809 > Math.abs(q.dot(k, r)); if (!J) return 0 === C && 1 === D && 2 === E ? !1 : f(z, B, 0, 1, 2); d(e, g, x, B); return !0 } function t(z, B, C) {
          z = q.scale(n.sv3d.get(), z, q.dot(z, B)); q.subtract(C, B, z);
          return C
        } function v(z, B) { return q.dot(z, B) + z[3] } function m(z, B, C, D, E) { const H = q.dot(z, C); if (0 === H) return !1; z = -(q.dot(z, B) + z[3]) / H; D & 1 && (z = w.clamp(z, 0, 1)); if (!(D & 4) && 0 > z || !(D & 8) && 1 < z) return !1; q.add(E, B, q.scale(E, C, z)); return !0 } const e = u.create(), g = u.create(), x = u.create(), k = u.create(), r = u.create(), A = [0, 0, 1, 0]; a.UP = A; a.clip = function (z, B) {
          const C = q.dot(z, B.ray.direction); z = -v(z, B.ray.origin); if (0 > z && 0 <= C) return !1; if (-1E-6 < C && 1E-6 > C) return 0 < z; if ((0 > z || 0 > C) && !(0 > z && 0 > C)) return !0; z /= C; 0 < C ? z < B.c1 && (B.c1 =
            z) : z > B.c0 && (B.c0 = z); return B.c0 <= B.c1
        }; a.clipInfinite = function (z, B) { const C = q.dot(z, B.ray.direction); z = -v(z, B.ray.origin); if (-1E-6 < C && 1E-6 > C) return 0 < z; z /= C; 0 < C ? z < B.c1 && (B.c1 = z) : z > B.c0 && (B.c0 = z); return B.c0 <= B.c1 }; a.copy = l; a.create = p; a.distance = function (z, B) { return Math.abs(v(z, B)) }; a.fromManyPoints = function (z, B) { return f(z, B, 0, 1, 2) }; a.fromManyPointsSampleAt = f; a.fromNormalAndOffset = function (z, B, C) { q.copy(C, z); C[3] = B; return C }; a.fromPoints = d; a.fromPositionAndNormal = b; a.fromValues = h; a.fromVectorsAndPoint =
          function (z, B, C, D) { q.cross(x, B, z); return b(C, x, D) }; a.intersectLine = function (z, B, C, D) { C = q.subtract(n.sv3d.get(), C, B); return m(z, B, C, 12, D) }; a.intersectLineSegment = function (z, B, C) { return m(z, B.origin, B.vector, 0, C) }; a.intersectLineSegmentClamp = function (z, B, C) { return m(z, B.origin, B.vector, 1, C) }; a.intersectRay = function (z, B, C) { return c.isSome(B) ? m(z, B.origin, B.direction, 8, C) : !1 }; a.isAABBFullyInside = function (z, B) {
            const C = B[0], D = B[1], E = B[2], H = B[3], J = B[4]; B = B[5]; return 0 <= z[0] * (0 < z[0] ? C : H) + z[1] * (0 < z[1] ? D : J) +
              z[2] * (0 < z[2] ? E : B) + z[3]
          }; a.isPointInside = function (z, B) { return 0 <= v(z, B) }; a.isPointOutside = function (z, B) { return 0 > v(z, B) }; a.isSphereFullyInside = function (z, B) { return 0 <= v(z, y.getCenter(B)) - B[3] }; a.isSphereFullyOutside = function (z, B) { return 0 > v(z, y.getCenter(B)) + B[3] }; a.negate = function (z, B) { B[0] = -z[0]; B[1] = -z[1]; B[2] = -z[2]; B[3] = -z[3]; return B }; a.normal = function (z) { return z }; a.projectPoint = function (z, B, C) {
            const D = q.scale(n.sv3d.get(), z, -z[3]); B = q.subtract(n.sv3d.get(), B, D); z = t(z, B, n.sv3d.get()); q.add(C,
              z, D); return C
          }; a.projectVector = t; a.setOffsetFromPoint = function (z, B, C) { z !== C && l(z, C); C[3] = -q.dot(C, B); return C }; a.signedDistance = v; a.wrap = function (z, B, C, D) { return h(z, B, C, D, n.sv4d.get()) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/sphere": function () {
      define("exports ../core/has ../core/Logger ../core/mathUtils ../core/maybe ./mat4 ./vec3 ./vec3f64 ./vec4 ./vec4f64 ../geometry/support/ray ../geometry/support/vector ../geometry/support/vectorStacks".split(" "), function (a, w, c, q, u,
        y, n, p, l, h, b, d, f) {
          function t() { return h.create() } function v(Q, T = t()) { return l.copy(T, Q) } function m(Q, T) { return h.fromValues(Q[0], Q[1], Q[2], T) } function e(Q) { return Q } function g(Q) { Q[0] = Q[1] = Q[2] = Q[3] = 0 } function x(Q) { return Q } function k(Q) { return Array.isArray(Q) ? Q[3] : Q } function r(Q) { return Array.isArray(Q) ? Q : R } function A(Q, T, da, Y) { return h.fromValues(Q, T, da, Y) } function z(Q, T, da) { Q !== da && n.copy(da, Q); da[3] = Q[3] + T; return da } function B(Q, T, da) {
            G.error("sphere.setExtent is not yet supported"); return Q ===
              da ? da : v(Q, da)
          } function C(Q, T, da) { if (u.isNone(T)) return !1; const { origin: Y, direction: fa } = T; var ha = I; ha[0] = Y[0] - Q[0]; ha[1] = Y[1] - Q[1]; ha[2] = Y[2] - Q[2]; T = fa[0] * fa[0] + fa[1] * fa[1] + fa[2] * fa[2]; const ka = 2 * (fa[0] * ha[0] + fa[1] * ha[1] + fa[2] * ha[2]); Q = ka * ka - 4 * T * (ha[0] * ha[0] + ha[1] * ha[1] + ha[2] * ha[2] - Q[3] * Q[3]); if (0 > Q) return !1; ha = Math.sqrt(Q); Q = (-ka - ha) / (2 * T); T = (-ka + ha) / (2 * T); if (0 > Q || T < Q && 0 < T) Q = T; if (0 > Q) return !1; da && (da[0] = Y[0] + fa[0] * Q, da[1] = Y[1] + fa[1] * Q, da[2] = Y[2] + fa[2] * Q); return !0 } function D(Q, T) { return C(Q, T, null) }
        function E(Q, T, da) { if (C(Q, T, da)) return da; Q = H(Q, T, f.sv3d.get()); n.add(da, T.origin, n.scale(f.sv3d.get(), T.direction, n.distance(T.origin, Q) / n.length(T.direction))); return da } function H(Q, T, da) { const Y = f.sv3d.get(), fa = f.sm4d.get(); n.cross(Y, T.origin, T.direction); const ha = k(Q); n.cross(da, Y, T.origin); n.scale(da, da, 1 / n.length(da) * ha); Q = K(Q, T.origin); T = d.angle(T.origin, da); y.identity(fa); y.rotate(fa, fa, T + Q, Y); n.transformMat4(da, da, fa); return da } function J(Q, T, da) {
          if (C(Q, T, da)) return da; b.closestPoint(T,
            r(Q), da); return M(Q, da, da)
        } function M(Q, T, da) { T = n.subtract(f.sv3d.get(), T, r(Q)); T = n.scale(f.sv3d.get(), T, Q[3] / n.length(T)); return n.add(da, T, r(Q)) } function F(Q, T) { T = n.subtract(f.sv3d.get(), T, r(Q)); T = n.squaredLength(T); return Math.sqrt(Math.abs(T - Q[3] * Q[3])) } function K(Q, T) { T = n.subtract(f.sv3d.get(), T, r(Q)); T = n.length(T); Q = k(Q); return q.acosClamped(Q / (Q + Math.abs(Q - T))) } function P(Q, T, da, Y) {
          Q = n.subtract(O, T, r(Q)); switch (da) {
            case 0: return da = q.cartesianToSpherical(Q, O)[2], n.set(Y, -Math.sin(da), Math.cos(da),
              0); case 1: return Q = q.cartesianToSpherical(Q, O), da = Q[1], Q = Q[2], T = Math.sin(da), n.set(Y, -T * Math.cos(Q), -T * Math.sin(Q), Math.cos(da)); case 2: return n.normalize(Y, Q)
          }
        } function L(Q, T) { T = n.subtract(S, T, r(Q)); return n.length(T) - Q[3] } function N(Q, T, da, Y) { const fa = L(Q, T); Q = P(Q, T, 2, S); da = n.scale(S, Q, da - fa); return n.add(Y, T, da) } const G = c.getLogger("esri.geometry.support.sphere"), I = p.create(), O = p.create(), R = p.create(), S = p.create(); w = Object.freeze({
          __proto__: null, create: t, copy: v, fromCenterAndRadius: m, wrap: e, clear: g,
          fromRadius: x, getRadius: k, getCenter: r, fromValues: A, elevate: z, setExtent: B, intersectRay: C, intersectsRay: D, intersectRayClosestSilhouette: E, closestPointOnSilhouette: H, closestPoint: J, projectPoint: M, distanceToSilhouette: F, angleToSilhouette: K, axisAt: P, altitudeAt: L, setAltitudeAt: N
        }); a.altitudeAt = L; a.angleToSilhouette = K; a.axisAt = P; a.clear = g; a.closestPoint = J; a.closestPointOnSilhouette = H; a.copy = v; a.create = t; a.distanceToSilhouette = F; a.elevate = z; a.fromCenterAndRadius = m; a.fromRadius = x; a.fromValues = A; a.getCenter =
          r; a.getRadius = k; a.intersectRay = C; a.intersectRayClosestSilhouette = E; a.intersectsRay = D; a.projectPoint = M; a.setAltitudeAt = N; a.setExtent = B; a.sphere = w; a.wrap = e
      })
    }, "esri/geometry/support/ray": function () {
      define("exports ../../core/arrayUtils ../../core/ObjectStack ../../chunks/vec3 ../../chunks/vec3f64 ./vectorStacks".split(" "), function (a, w, c, q, u, y) {
        function n(b) { return b ? { origin: u.clone(b.origin), direction: u.clone(b.direction) } : { origin: u.create(), direction: u.create() } } function p(b, d, f = n()) {
          q.copy(f.origin,
            b); q.copy(f.direction, d); return f
        } function l(b, d) { b = q.cross(y.sv3d.get(), q.normalize(y.sv3d.get(), b.direction), q.subtract(y.sv3d.get(), d, b.origin)); return q.dot(b, b) } const h = new c.ObjectStack(function () { return { origin: null, direction: null } }); a.closestPoint = function (b, d, f) { d = q.dot(b.direction, q.subtract(f, d, b.origin)); q.add(f, b.origin, q.scale(f, b.direction, d)); return f }; a.copy = function (b, d = n()) { return p(b.origin, b.direction, d) }; a.create = n; a.distance = function (b, d) { return Math.sqrt(l(b, d)) }; a.distance2 =
          l; a.equals = function (b, d) { return w.equals(b.origin, d.origin) && w.equals(b.direction, d.direction) }; a.fromPoints = function (b, d, f = n()) { q.copy(f.origin, b); q.subtract(f.direction, d, b); return f }; a.fromValues = p; a.wrap = function (b, d) { const f = h.get(); f.origin = b; f.direction = d; return f }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/vector": function () {
      define(["exports", "../../core/mathUtils", "../../chunks/vec3", "../../chunks/vec3f64"], function (a, w, c, q) {
        const u = q.create(), y = q.create();
        a.angle = function (n, p) { n = c.dot(n, p) / (c.length(n) * c.length(p)); return -w.acosClamped(n) }; a.angleAroundAxis = function (n, p, l) { c.normalize(u, n); c.normalize(y, p); n = c.dot(u, y); n = w.acosClamped(n); p = c.cross(u, u, y); return 0 > c.dot(p, l) ? 2 * Math.PI - n : n }; a.projectPoint = function (n, p, l) { p = c.dot(n, p) / c.dot(n, n); return c.scale(l, n, p) }; a.projectPointSignedLength = function (n, p) { return c.dot(n, p) / c.length(n) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/coordinateSystem": function () {
      define("exports ../../chunks/mat4 ../../chunks/vec3 ../../chunks/vec3f64 ../projectionEllipsoid ../SpatialReference ../../chunks/boundedPlane ../../chunks/sphere".split(" "),
        function (a, w, c, q, u, y, n, p) {
          function l(m) { return { operations: m, value: m.create() } } function h(m, e, g = l(m)) { g.operations = m; m.copy(e, g.value); return g } function b(m, e, g, x) { return m.operations.setAltitudeAt(m.value, e, g, x) } const d = 2 ** 50, f = q.create(), t = { operations: null, value: null }, v = q.create(); a.altitudeAt = function (m, e) { return m.operations.altitudeAt(m.value, e) }; a.axisAt = function (m, e, g, x) { return m.operations.axisAt(m.value, e, g, x) }; a.closestPoint = function (m, e, g) { return m.operations.closestPoint(m.value, e, g) };
          a.closestPointOnSilhouette = function (m, e, g) { return m.operations.closestPointOnSilhouette(m.value, e, g) }; a.coordinateSystemFromOneAxisAndNormalVector = function (m, e, g, x, k) { c.copy(g, m); c.copy(v, e); c.normalize(v, v); c.cross(x, v, g); c.cross(k, x, g) }; a.create = function (m) { const { value: e, operations: g } = m; return { operations: g, value: g.create(e) } }; a.createFromOperations = l; a.createGlobal = function (m) { return h(p.sphere, p.fromValues(0, 0, 0, u.getReferenceEllipsoid(m).radius)) }; a.createLocal = function () {
            return h(n.boundedPlane,
              n.fromValues([0, 0, 0], [d, 0, 0], [0, d, 0]))
          }; a.distanceToSilhouette = function (m, e) { return m.operations.distanceToSilhouette(m.value, e) }; a.elevate = function (m, e, g) { return m.operations.elevate(m.value, e, g.value) }; a.fromValues = h; a.intersectRay = function (m, e, g) { return m.operations.intersectRay(m.value, e, g) }; a.intersectRayClosestSilhouette = function (m, e, g) { return m.operations.intersectRayClosestSilhouette(m.value, e, g) }; a.intersectsRay = function (m, e) { return m.operations.intersectRay(m.value, e, null) }; a.normalAt = function (m,
            e, g) { return m.operations.axisAt(m.value, e, 2, g) }; a.renderSRFromViewSR = function (m, e) { return m ? u.getSphericalPCPF(e) : e.isGeographic ? y.PlateCarree : e }; a.setAltitudeAt = b; a.setAltitudeOfTransformation = function (m, e, g, x) { e !== x && w.copy(x, e); c.set(f, x[12], x[13], x[14]); b(m, f, g, f); x[12] = f[0]; x[13] = f[1]; x[14] = f[2]; return x }; a.setExtent = function (m, e, g) { m.operations.setExtent(m.value, e, g.value); return g }; a.vectorCoordinates = function (m, e, g, x, k) { k[0] = c.dot(m, e); k[1] = c.dot(m, g); k[2] = c.dot(m, x); return k }; a.wrap = function (m,
              e) { t.operations = m; t.value = e; return t }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/VoxelWasmManager": function () {
      define(["./VoxelWasmPerScene"], function (a) {
        return function () {
          function w() { this.view2WASM = new Map } w.getInstance = function () { w.instance || (w.instance = new w); return w.instance }; var c = w.prototype; c.getVoxelWasmPerSceneView = function (q) { return this.view2WASM.has(q) ? this.view2WASM.get(q) : null }; c.isUpdating = function (q, u) {
            return this.view2WASM.has(q) ? this.view2WASM.get(q).isUpdating(u) :
              !1
          }; c.addLayer = function (q, u) { this.view2WASM.has(q) || this.view2WASM.set(q, new a(q)); return this.view2WASM.get(q).addVoxelLayer(u) }; c.removeLayer = function (q, u) { this.view2WASM.has(q) && 1 > this.view2WASM.get(q).removeVoxelLayer(u) && this.view2WASM.delete(q) }; c.setLayerEnabled = function (q, u, y) { this.view2WASM.has(q) && this.view2WASM.get(q).setEnabled(u, y) }; c.setLayerSlices = function (q, u) {
            let y = !1; this.view2WASM.forEach((n, p) => {
              p.allLayerViews.filter(l => "voxel-3d" === l.type).forEach(l => {
              l.layer === q && (y = n.setSlices(l,
                u))
              })
            }); return y
          }; c.setLayerDynamicSections = function (q, u) { let y = !1; this.view2WASM.forEach((n, p) => { p.allLayerViews.filter(l => "voxel-3d" === l.type).forEach(l => { l.layer === q && (y = n.setDynamicSections(l, u)) }) }); return y }; c.setLayerCurrentVariable = function (q, u) { let y = !1; this.view2WASM.forEach((n, p) => { p.allLayerViews.filter(l => "voxel-3d" === l.type).forEach(l => { l.layer === q && (y = n.setCurrentVariable(l, u)) }) }); return y }; c.setLayerRenderMode = function (q, u) {
            let y = !1; this.view2WASM.forEach((n, p) => {
              p.allLayerViews.filter(l =>
                "voxel-3d" === l.type).forEach(l => { l.layer === q && (y = n.setRenderMode(l, u)) })
            }); return y
          }; c.setLayerStaticSections = function (q, u) { let y = !1; this.view2WASM.forEach((n, p) => { p.allLayerViews.filter(l => "voxel-3d" === l.type).forEach(l => { l.layer === q && (y = n.setStaticSections(l, u)) }) }); return y }; return w
        }()
      })
    }, "esri/layers/VoxelWasmPerScene": function () {
      define("../chunks/_rollupPluginBabelHelpers ../request ../core/Logger ../core/maybe ../core/promiseUtils ../core/reactiveUtils ../libs/vxl/VxlModule".split(" "), function (a,
        w, c, q, u, y, n) {
          const p = c.getLogger("esri.layers.VoxelWasmPerScene"); return function () {
            function l(b) {
            this._havePreparedWithAllLayers = this._halfIntTexturesAvailable = !1; this._vxl = this._renderPluginContext = null; this._moreToLoad = this._pluginIsActive = !1; this._viewportHeight = this._viewportWidth = -1; this._newLayers = []; this._layers = new Map; this._renderPass = 0; this._renderSlot = 22; this._renderTargetToRestore = this._rctx = null; this._lastFrameWasStationary = !1; this._wasmMemBlockSizes = [512, 1024, 2048, 4096, 8192, 16384, 32768,
              65536]; this._wasmMemBlocks = new Map; this._dbgFlags = new Set; this._view = b; this.initialize()
            } var h = l.prototype; h.dbg = function (b, d) { this._dbgFlags.has(b) && (4 === b ? p.error(d) : p.warn(d)) }; h.removeRenderPlugin = function () { this._pluginIsActive && this._view._stage && (this.dbg(1, "--removeRenderPlugin--"), this._view._stage.removeRenderPlugin(this)); this._pluginIsActive = !1 }; h.initialize = function () {
              this.dbg(1, "--initialize--"); for (const b of this._wasmMemBlockSizes) this._wasmMemBlocks.set(b, 0); this._readyWatchHandle =
                y.react(() => this._view.ready, b => { b && "local" === this._view.viewingMode ? (this.dbg(1, "view ready status changed to ready on a local view, calling addRenderPlugin"), this._view._stage.addRenderPlugin([this._renderSlot], this), this._pluginIsActive = !0) : (this.dbg(1, "view ready status changed, not ready or not a local view!"), this.removeRenderPlugin()) }, { initial: !0 }); this._qualityWatchHandle = y.react(() => { var b; return null == (b = this._view) ? void 0 : b.qualityProfile }, b => {
                  this.dbg(3, "qualityProfile changed to " + b);
                  this._vxl && this._vxl.set_quality(this.toWasmQuality(b))
                }, { initial: !0 }); this._timeExtentWatchHandle = y.react(() => { var b; return null == (b = this._view) ? void 0 : b.timeExtent }, () => { if (this._vxl) { var b; const d = this._getTimeArgs(null == (b = this._view) ? void 0 : b.timeExtent); this.dbg(3, "sceneView timeExtent changed to useTime\x3d" + d.useTime + " st\x3d" + d.startTime + " et\x3d" + d.endTime); this._vxl.set_scene_time_extent(d.startTime, d.endTime, d.useTime); this._renderPluginContext.requestRender() } }, { initial: !0 }); this._stationaryWatchHandle =
                  y.react(() => { var b; return null == (b = this._view) ? void 0 : b.stationary }, b => { this._vxl && b && !this._lastFrameWasStationary && this._renderPluginContext.requestRender() })
            }; h.initializeRenderContext = function (b) { this.dbg(1, "--initializeRenderContext--"); const d = b.renderContext.rctx; "webgl2" === d.webglVersion ? (this._renderPluginContext = b, this._rctx = b.renderContext.rctx, this._halfIntTexturesAvailable = !!this._rctx.capabilities.textureNorm16, this.initializeWasm(d.gl)) : this.dbg(4, "WebGL 1 context only!") }; h.uninitializeRenderContext =
              function () { this._rctx = this._renderPluginContext = null; this.dbg(1, "--uninitializeRenderContext--") }; h.restoreFramebuffer = function () { if (this._renderTargetToRestore) { var b = this._renderTargetToRestore.fbo; this._rctx ? (this._rctx.bindFramebuffer(b, !0), b = this._renderTargetToRestore.viewport, this._rctx.setViewport(b.x, b.y, b.width, b.height)) : this.dbg(4, "no context in restoreFramebuffer!") } }; h.bindPreviousDepthToSlot = function (b, d) {
                var f = !!this._renderTargetToRestore; if (!this._rctx || !f) return 0; f = this._renderTargetToRestore.fbo.depthStencilTexture;
                if (!f) return this.dbg(4, "no depth/stencil texture exists!"), 0; 0 === d ? this._rctx.bindTexture(null, b, !0) : this._rctx.bindTexture(f, b, !0); return 1
              }; h.setBlendState = function (b, d, f, t) { this._rctx ? (this._rctx.setBlendingEnabled(1 === b), this._rctx.setBlendFunction(d, f), this._rctx.setBlendEquation(t)) : this.dbg(4, "setBlendState callback has no rendering context!") }; h.setFrontFace = function (b) { this._rctx ? this._rctx.setFrontFace(b) : this.dbg(4, "setFrontFace callback has no rendering context!") }; h.setDepthStencilStateFunction =
                function (b, d, f) { this._rctx ? (this._rctx.setDepthFunction(f), this._rctx.setDepthTestEnabled(1 === b), this._rctx.setDepthWriteEnabled(1 === d), this._rctx.setStencilTestEnabled(!1), this._rctx.setStencilFunction(519, 0, 255), this._rctx.setStencilOpSeparate(1028, 7680, 7682, 7680), this._rctx.setStencilOpSeparate(1029, 7680, 7683, 7680)) : this.dbg(4, "setDepthStencilStateFunction callback has no rendering context!") }; h.setRasterizerState = function (b) {
                  if (this._rctx) switch (b) {
                    case 1: this._rctx.setFaceCullingEnabled(!1);
                      break; case 3: this._rctx.setCullFace(1029); this._rctx.setFaceCullingEnabled(!0); break; case 2: this._rctx.setCullFace(1028), this._rctx.setFaceCullingEnabled(!0)
                  } else this.dbg(4, "setRasterizerState callback has no rendering context!")
                }; h.setViewport = function (b, d, f, t) { this._rctx ? this._rctx.setViewport(b, d, f, t) : this.dbg(4, "setViewport callback has no rendering context!") }; h._syncRequestsResponses = function () {
                  this._layers.forEach((b, d) => {
                    const f = []; b.responses.forEach((e, g) => {
                      f.push(g); this.dbg(2, "responding for requestID:" +
                        g + " size:" + e.size); this._vxl.respond(d, g, e)
                    }); const t = b.responses; for (var v of f) t.delete(v); v = this._vxl.get_new_requests(d); const m = b.abortController.signal; for (const e in v) {
                    b.outstandingRequestCount += 1; 1 === b.outstandingRequestCount && b.layerView.updatingFlagChanged(); const g = v[e], x = { responseType: "array-buffer", signal: m }; this.dbg(2, "making requestID:" + e + " url:" + g.url); w(g.url, x).then(k => {
                      --b.outstandingRequestCount; 0 === b.outstandingRequestCount && b.layerView.updatingFlagChanged(); this.dbg(2, "have response for requestID:" +
                        e); let r = 0; if (0 < k.data.byteLength) { r = this._vxl._malloc(k.data.byteLength); const A = new Uint8Array(this._vxl.HEAPU8.buffer, r, k.data.byteLength), z = new Uint8Array(k.data); for (let B = 0; B < k.data.byteLength; ++B)A[B] = z[B] } t.set(+e, { type: g.type, ptr: r, size: k.data.byteLength, success: !0 })
                    }).catch(k => { --b.outstandingRequestCount; 0 === b.outstandingRequestCount && b.layerView.updatingFlagChanged(); u.isAbortError(k) || (this.dbg(4, `requestID:${e} failed, error=${k.toString()}`), t.set(+e, { type: g.type, ptr: 0, size: 0, success: !1 })) })
                    }
                  })
                };
            h.updateWasmCamera = function (b) { this._vxl.set_projection_matrix.apply(this._vxl, b.projectionMatrix); this._vxl.set_view_matrix.apply(this._vxl, b.viewMatrix); this._vxl.set_near_far(b.near, b.far) }; h.isUpdating = function (b) { return !this._vxl && this._vxlPromise ? !0 : this._layers.has(b) ? 0 < this._layers.get(b).outstandingRequestCount : !1 }; h.setEnabled = function (b, d) { this._layers.forEach((f, t) => { f.layerView === b && (this._vxl.set_enabled(t, d), this._renderPluginContext.requestRender()) }) }; h.setSlices = function (b, d) {
              return this._doMaskedUIUpdate(b,
                { mask: 2, slices: { planes: d, currentEditPlane: -1 } }, !0)
            }; h.setDynamicSections = function (b, d) { return this._doMaskedUIUpdate(b, { mask: 4, dynamicSections: { planes: d, currentEditPlane: -1 } }, !0) }; h.setStaticSections = function (b, d) { return this._doMaskedUIUpdate(b, { mask: 1, staticSections: d }, !0) }; h.setCurrentVariable = function (b, d) { return this._doMaskedUIUpdate(b, { mask: 1024, currentVariable: d }, !0) }; h.setRenderMode = function (b, d) { return this._doMaskedUIUpdate(b, { mask: 8192, renderMode: d }, !0) }; h._doMaskedUIUpdate = function (b,
              d, f) { if (!this._vxl) return !1; let t = !1; this._layers.forEach((v, m) => { v.layerView === b && (v = { str: JSON.stringify(d), byteCount: 0, ptr: 0, isReusable: !1 }, this._AllocateBlock(v) && (t = 1 === this._vxl.handle_masked_ui_update(m, v.ptr, v.byteCount) ? !0 : !1, v.isReusable || this._vxl._free(v.ptr))) }); t && f && this._renderPluginContext.requestRender(); return t }; h.addVoxelLayer = function (b) {
                if (!this._vxl) {
                  const d = { layerView: b, resolveCallback: null, rejectCallback: null }; b = new Promise((f, t) => { d.resolveCallback = f; d.rejectCallback = t });
                  this._newLayers.push(d); return b
                } b = this._addVoxelLayer(b); return 0 > b ? Promise.reject(-1) : Promise.resolve(b)
              }; h.removeVoxelLayer = function (b) {
                if (!this._vxl) { var d = this._newLayers.findIndex(t => b === t.layerView); 0 <= d && (this._newLayers[d].resolveCallback(-1), this._newLayers.splice(d, 1)); d = this._newLayers.length; 0 === d && (this.dbg(1, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()); return d } let f = -1; this._layers.forEach((t, v) => {
                t.layerView === b && (f = v, t.abortController.abort(),
                  this._vxl.remove_layer(f))
                }); 0 <= f && this._layers.delete(f); d = this._layers.size; 0 === d && (this.dbg(1, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()); return d
              }; h._getBlockSize = function (b) { for (const d of this._wasmMemBlockSizes) if (b < d) return d; return -1 }; h._AllocateBlock = function (b) {
              b.byteCount = this._vxl.lengthBytesUTF8(b.str) + 1; const d = this._getBlockSize(b.byteCount); 0 > d ? (b.isReusable = !1, b.ptr = this._vxl._malloc(b.byteCount)) : (b.isReusable = !0, b.ptr = this._wasmMemBlocks.get(d),
                0 === b.ptr && (b.ptr = this._vxl._malloc(d), this._wasmMemBlocks.set(d, b.ptr))); return 0 !== b.ptr ? (this._vxl.stringToUTF8(b.str, b.ptr, b.byteCount), !0) : !1
              }; h._getTimeArgs = function (b) { let d = -Number.MAX_VALUE, f = Number.MAX_VALUE, t = !1; q.isSome(b) && (b.isAllTime ? t = !0 : (q.isSome(b.start) && (t = !0, d = b.start.getTime() / 1E3), q.isSome(b.end) && (t = !0, f = b.end.getTime() / 1E3))); return { startTime: d, endTime: f, useTime: t } }; h._addVoxelLayer = function (b) {
                var d, f = b.layer, t = -1; t = f.getConfiguration(); if (1 > t.length) return -1; const v = {
                  str: t,
                  byteCount: 0, ptr: 0, isReusable: !1
                }; if (!this._AllocateBlock(v)) return -1; t = this._getTimeArgs(null == (d = this._view) ? void 0 : d.timeExtent); d = this._view.spatialReference.isWGS84 && f.spatialReference.isWGS84 ? 111319.49079327357 : 1; t = this._vxl.add_layer(f.serviceRoot, v.ptr, v.byteCount, d, d, t.startTime, t.endTime, t.useTime, this.toWasmQuality(this._view.qualityProfile)); v.isReusable || this._vxl._free(v.ptr); if (0 <= t) {
                  f = new AbortController; this._layers.set(t, { layerView: b, responses: new Map, outstandingRequestCount: 0, abortController: f });
                  if (!this._halfIntTexturesAvailable) { f = []; d = ""; for (const m of b.layer.variables) if ("Int16" === m.renderingFormat.type || "UInt16" === m.renderingFormat.type) f.push(m.name), m.id === b.layer.style.currentVariableId && (d = m.name); "" !== d && p.error("#addVoxelLayer_error()", b.layer, `The voxel layer '${b.layer.title}' cannot render the current variable '${d}' in this browser`); 0 < f.length && p.warn("#addVoxelLayer_warning()", b.layer, `The voxel layer '${b.layer.title}' cannot render the variables '${f.toString()}' in this browser`) } return t
                } return -1
              };
            h.prepareRender = function (b) { if (this._vxl) { var d = b.viewForward; b = b.eye; this._vxl.update_camera_pos_and_direction(b[0], b[1], b[2], d[0], d[1], d[2]); d = this._vxl.cull(); this.dbg(2, "missingResourceCount\x3d" + d); this._moreToLoad = 0 < d; this._havePreparedWithAllLayers = 0 === this._newLayers.length } }; h.render = function (b) {
              if (!this._vxl || b.pass !== this._renderPass || b.slot !== this._renderSlot) return !1; for (var d of this._newLayers) { const f = this._addVoxelLayer(d.layerView); -1 === f ? d.rejectCallback(-1) : d.resolveCallback(f) } this._newLayers =
                []; if (0 === this._layers.size) return this.dbg(4, "No voxel layers but RenderPlugin instance is being asked to render!"), !1; this._renderTargetToRestore = { fbo: this._rctx.getBoundFramebufferObject(), viewport: this._rctx.getViewport() }; this._syncRequestsResponses(); this._lastFrameWasStationary = this._view.stationary; this._vxl.begin_color_frame(!this._view.stationary || this._moreToLoad, b.scenelightingData.lightingMainDirection[0], b.scenelightingData.lightingMainDirection[1], b.scenelightingData.lightingMainDirection[2]);
              d = this._renderTargetToRestore.viewport; if (d.width !== this._viewportWidth || d.height !== this._viewportHeight) this._viewportWidth = d.width, this._viewportHeight = d.height, this._vxl.set_viewport(d.width, d.height); 0 === d.x && 0 === d.y || this.dbg(4, "Unsupported viewport parameters detected!"); this.updateWasmCamera(b.camera); this._vxl.draw(); this._renderTargetToRestore.fbo = null; b.rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()); b.rctx.externalVertexArrayObjectUpdate();
              b.rctx.externalVertexBufferUpdate(); this._rctx.externalProgramUpdate(); (this._moreToLoad || !this._havePreparedWithAllLayers && 0 < this._layers.size) && this._renderPluginContext.requestRender(); return !0
            }; h.destroy = function () {
              this.dbg(1, "--destroy--"); this.removeRenderPlugin(); this._readyWatchHandle = q.removeMaybe(this._readyWatchHandle); this._qualityWatchHandle = q.removeMaybe(this._qualityWatchHandle); this._timeExtentWatchHandle = q.removeMaybe(this._timeExtentWatchHandle); this._stationaryWatchHandle = q.removeMaybe(this._stationaryWatchHandle);
              this._vxl && (this._layers.forEach(b => { b.abortController.abort() }), this._wasmMemBlocks.forEach(b => { 0 !== b && this._vxl._free(b) }), this._vxl.uninitialize_voxel_wasm(), this._vxl = null)
            }; h.initializeWasm = function (b) {
              if (this._vxl) return Promise.resolve(); this._vxlPromise || (this._vxlPromise = n.loadVoxelWASM(b).then(d => {
                var f; this._vxl = d; this._vxlPromise = null; if (0 >= this._newLayers.length) this.dbg(1, " no voxel layers left after WASM downloaded, removing RenderPlugin and destroying"), this.destroy(); else {
                  d = this._getTimeArgs(null ==
                    (f = this._view) ? void 0 : f.timeExtent); f = this._vxl.addFunction(this.restoreFramebuffer.bind(this), "v"); var t = this._vxl.addFunction(this.setBlendState.bind(this), "viiii"), v = this._vxl.addFunction(this.setFrontFace.bind(this), "vi"), m = this._vxl.addFunction(this.setRasterizerState.bind(this), "vi"), e = this._vxl.addFunction(this.setDepthStencilStateFunction.bind(this), "viii"), g = this._vxl.addFunction(this.setViewport.bind(this), "viiii"), x = this._vxl.addFunction(this.bindPreviousDepthToSlot.bind(this), "iii"); this._vxl.initialize_voxel_wasm(f,
                      t, v, m, e, g, x, d.startTime, d.endTime, d.useTime); this._renderPluginContext && this._renderPluginContext.requestRender()
                }
              }).catch(() => { for (const d of this._newLayers) d.rejectCallback(-2); this.dbg(4, " WASM failed to download, removing RenderPlugin and destroying"); this.destroy() })); return this._vxlPromise
            }; h.pickDepth = function (b, d, f) {
              if (!this._vxl || !this._rctx || 0 === this._layers.size) return null; const t = f.viewport[3] - d; if (0 > b || b > f.viewport[2] || 0 > d || d > f.viewport[3]) return this.dbg(4, `pickDepth: outOfRange, screenXY=[${b}, ${t}], vp=[${f.viewport.toString()}]`),
                null; this._renderTargetToRestore = { fbo: this._rctx.getBoundFramebufferObject(), viewport: this._rctx.getViewport() }; d = f.viewForward; const v = f.eye; this._vxl.update_camera_pos_and_direction(v[0], v[1], v[2], d[0], d[1], d[2]); this.updateWasmCamera(f); this._vxl.begin_frame(); b = this._vxl.pick_depth(b, t); this._renderTargetToRestore.fbo = null; this._rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()); this._rctx.externalVertexArrayObjectUpdate(); this._rctx.externalVertexBufferUpdate();
              this._rctx.externalProgramUpdate(); return b.success ? b.distanceToCamera : null
            }; h.toWasmQuality = function (b) { switch (b) { case "low": return 0; case "medium": return 1; case "high": return 2 } }; a._createClass(l, [{ key: "canRender", get: function () { return !!this._vxl && "local" === this._view.viewingMode } }]); return l
          }()
      })
    }, "esri/libs/vxl/VxlModule": function () {
      define(["require", "exports", "../../assets"], function (a, w, c) {
        function q(u) { return c.getAssetUrl(`esri/libs/vxl/${u}`) } w.loadVoxelWASM = function (u) {
          return (new Promise(y =>
            (new Promise((n, p) => a(["../../chunks/vxlLayer"], n, p))).then(n => n.vxlLayer).then(({ default: n }) => { const p = n({ locateFile: q, preinitializedWebGLContext: u, onRuntimeInitialized: () => y(p) }) }))).catch(y => Promise.reject(y))
        }; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/layers/support/layerUtils": function () {
      define(["exports"], function (a) {
      a.areLabelsVisible = function (w) { return !0 === w.labelsVisible && null != w.labelingInfo && 0 < w.labelingInfo.length }; a.getLayersForScale = function (w, c) {
        const q = []; if (0 < w && c) for (let u =
          0; u < c.length; u++)if (!(0 <= c[u].parentLayerId && -1 === q.indexOf(c[u].parentLayerId) && c.some(function (y) { return y.id === c[u].parentLayerId })) && 0 <= c[u].id) { let y = !0; const n = c[u].maxScale, p = c[u].minScale; if (0 < n || 0 < p) 0 < n && 0 < p ? y = n <= w && w <= p : 0 < n ? y = n <= w : 0 < p && (y = w <= p); y && q.push(c[u].id) } return q
      }; a.isBaseLayer = function (w) { return w.parent && "esri.Basemap" === w.parent.declaredClass && -1 < w.parent.baseLayers.indexOf(w) }; a.isTiledLayer = function (w) {
        return w && "base-tile" === w.type || "tile" === w.type || "elevation" === w.type ||
          "imagery-tile" === w.type || "base-elevation" === w.type || "open-street-map" === w.type || "wcs" === w.type || "web-tile" === w.type || "wmts" === w.type || "vector-tile" === w.type
      }; a.serializeLayerDefinitions = function (w) { const c = /[:;]/, q = []; let u = !1; if (w && (w.forEach(function (y, n) { q.push([n, y]); !u && c.test(y) && (u = !0) }), 0 < q.length)) { if (u) { const y = {}; q.forEach(n => { y[n[0]] = n[1] }); w = JSON.stringify(y) } else { const y = []; q.forEach(n => { y.push(n[0] + ":" + n[1]) }); w = y.join(";") } return w } return null }; a.serializeTimeOptions = function (w) {
        if (w) {
          var c =
            []; w.forEach(function (q, u) { c.push('"' + u + '":' + JSON.stringify(q)) }); if (c.length) return "{" + c.join(",") + "}"
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/BreakpointsOwner": function () {
      define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/ArrayPool ../core/Handles ../core/watchUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "), function (a,
        w, c, q, u, y, n, p, l, h, b) {
          function d(v, m) { return m ? f[v].valueToClassName[m].split(" ") : [] } const f = {
            widthBreakpoint: {
              getValue(v) { const m = v.viewSize[0]; v = v.breakpoints; const e = this.values; return m <= v.xsmall ? e.xsmall : m <= v.small ? e.small : m <= v.medium ? e.medium : m <= v.large ? e.large : e.xlarge }, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: {
                xsmall: "esri-view-width-xsmall esri-view-width-less-than-small esri-view-width-less-than-medium esri-view-width-less-than-large esri-view-width-less-than-xlarge",
                small: "esri-view-width-small esri-view-width-greater-than-xsmall esri-view-width-less-than-medium esri-view-width-less-than-large esri-view-width-less-than-xlarge", medium: "esri-view-width-medium esri-view-width-greater-than-xsmall esri-view-width-greater-than-small esri-view-width-less-than-large esri-view-width-less-than-xlarge", large: "esri-view-width-large esri-view-width-greater-than-xsmall esri-view-width-greater-than-small esri-view-width-greater-than-medium esri-view-width-less-than-xlarge",
                xlarge: "esri-view-width-xlarge esri-view-width-greater-than-xsmall esri-view-width-greater-than-small esri-view-width-greater-than-medium esri-view-width-greater-than-large"
              }
            }, heightBreakpoint: {
              getValue(v) { const m = v.viewSize[1]; v = v.breakpoints; const e = this.values; return m <= v.xsmall ? e.xsmall : m <= v.small ? e.small : m <= v.medium ? e.medium : m <= v.large ? e.large : e.xlarge }, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: {
                xsmall: "esri-view-height-xsmall esri-view-height-less-than-small esri-view-height-less-than-medium esri-view-height-less-than-large esri-view-height-less-than-xlarge",
                small: "esri-view-height-small esri-view-height-greater-than-xsmall esri-view-height-less-than-medium esri-view-height-less-than-large esri-view-height-less-than-xlarge", medium: "esri-view-height-medium esri-view-height-greater-than-xsmall esri-view-height-greater-than-small esri-view-height-less-than-large esri-view-height-less-than-xlarge", large: "esri-view-height-large esri-view-height-greater-than-xsmall esri-view-height-greater-than-small esri-view-height-greater-than-medium esri-view-height-less-than-xlarge",
                xlarge: "esri-view-height-xlarge esri-view-height-greater-than-xsmall esri-view-height-greater-than-small esri-view-height-greater-than-medium esri-view-height-greater-than-large"
              }
            }, orientation: { getValue(v) { v = v.viewSize; const m = this.values; return v[1] >= v[0] ? m.portrait : m.landscape }, values: { portrait: "portrait", landscape: "landscape" }, valueToClassName: { portrait: "esri-view-orientation-portrait", landscape: "esri-view-orientation-landscape" } }
          }, t = { xsmall: 544, small: 768, medium: 992, large: 1200 }; a.BreakpointsOwner =
            v => {
              v = function (m) {
                function e(...x) { x = m.call(this, ...x) || this; x._breakpointsHandles = new u; x.orientation = null; x.widthBreakpoint = null; x.heightBreakpoint = null; x.breakpoints = t; return x } w._inheritsLoose(e, m); var g = e.prototype; g.initialize = function () { this._breakpointsHandles.add(y.init(this, ["breakpoints", "size"], this._updateClassNames)) }; g.destroy = function () { this.destroyed || (this._removeActiveClassNames(), this._breakpointsHandles.destroy(), this._breakpointsHandles = null) }; g._updateClassNames = function () {
                  if (this.container) {
                    var x =
                      q.acquire(), k = q.acquire(), r = !1, A; for (A in f) { const z = this[A], B = f[A].getValue({ viewSize: this.size, breakpoints: this.breakpoints }); z !== B && (r = !0, this[A] = B, d(A, z).forEach(C => k.push(C)), d(A, B).forEach(C => x.push(C))) } r && (this._applyClassNameChanges(x, k), q.release(x), q.release(k))
                  }
                }; g._applyClassNameChanges = function (x, k) { const r = this.container; r && (k.forEach(A => r.classList.remove(A)), x.forEach(A => r.classList.add(A))) }; g._removeActiveClassNames = function () {
                  const x = this.container; if (x) for (var k in f) d(k, this[k]).forEach(r =>
                    x.classList.remove(r))
                }; w._createClass(e, [{ key: "breakpoints", set: function (x) { var k = this._get("breakpoints"); if (x !== k) { k = (k = x) && k.xsmall < k.small && k.small < k.medium && k.medium < k.large; if (!k) { const r = JSON.stringify(t, null, 2); console.warn("provided breakpoints are not valid, using defaults:" + r) } x = k ? x : t; this._set("breakpoints", { ...x }) } } }]); return e
              }(v); c.__decorate([n.property()], v.prototype, "breakpoints", null); c.__decorate([n.property()], v.prototype, "orientation", void 0); c.__decorate([n.property()], v.prototype,
                "widthBreakpoint", void 0); c.__decorate([n.property()], v.prototype, "heightBreakpoint", void 0); return v = c.__decorate([b.subclass("esri.views.BreakpointsOwner")], v)
            }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/DOMContainer": function () {
      define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/domUtils ../core/scheduling ../core/watchUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./overlay/ViewOverlay ../widgets/Popup".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(m) { m && (q.empty(m), m.parentNode && m.parentNode.removeChild(m)) } const v = [0, 0]; a.DOMContainer = m => {
            m = function (e) {
              function g(...k) {
                var r = e.call(this, ...k) || this; r._freqInfo = { freq: 16, time: 750 }; r._overlayRenderTaskHandle = null; r.height = 0; r.position = null; r.resizing = !1; r.root = null; r.surface = null; r.suspended = !0; r.ui = null; r.userContent = null; r.width = 0; r.widthBreakpoint = null; r.handles.add([r.watch("cursor", A => { const z = r.surface; z && z.setAttribute("data-cursor", A) }),
                r.watch("interacting", A => { const z = r.surface; z && z.setAttribute("data-interacting", A.toString()) })]); return r
              } w._inheritsLoose(g, e); var x = g.prototype; x.initialize = function () { this.handles.add(this.watch("ui", (k, r) => this._handleUIChange(k, r))); this._wireUI(this.ui); this.handles.add([this.on("focus", () => this.notifyChange("focused")), this.on("blur", () => this.notifyChange("focused"))]) }; x.destroy = function () {
              this.destroyed || (this.ui && (this.ui.destroy(), this.ui = null), this.popup && !this.popup.destroyed && this.popup.destroy(),
                this.container = null)
              }; x.blur = function () { this.surface && this.surface.blur() }; x.focus = function () { this.surface && this.surface.focus() }; x.pageToContainer = function (k, r, A) { const z = this.position; k -= z[0]; r -= z[1]; A ? (A[0] = k, A[1] = r) : A = [k, r]; return A }; x.containerToPage = function (k, r, A) { const z = this.position; k += z[0]; r += z[1]; A ? (A[0] = k, A[1] = r) : A = [k, r]; return A }; x._handleUIChange = function (k, r) { r && (this.handles.remove("ui"), r.destroy()); k && this._wireUI(k); this._set("ui", k) }; x._wireUI = function (k) {
                this.handles.remove("ui");
                k && (k.view = this, this.handles.add([y.init(this, "root", r => { if (r) { { const A = document.createElement("div"); r.appendChild(A); r = A } } else r = null; k.container = r }), y.init(this, "popup", (r, A) => { A && k.remove(A, "popup"); r && (r.view = k.view, k.add(r, { key: "popup", position: "manual" })) })], "ui"))
              }; x._stopMeasuring = function () { this.handles.remove("measuring"); this._get("resizing") && this._set("resizing", !1) }; x._startMeasuring = function () {
                const k = this._freqInfo; k.freq = 16; k.time = 750; this.handles.add([(() => {
                  const r = () => {
                  k.freq =
                    16; k.time = 750
                  }; window.addEventListener("resize", r); return { remove() { window.removeEventListener("resize", r) } }
                })(), u.addFrameTask({ prepare: r => { const A = this._measure(), z = this._freqInfo; z.time += r.deltaTime; A && (z.freq = 16, this._get("resizing") || this._set("resizing", !0)); z.time < z.freq || (z.time = 0, this._position() || A ? z.freq = 16 : z.freq = Math.min(750, 2 * z.freq), !A && 512 <= z.freq && this._get("resizing") && this._set("resizing", !1)) } })], "measuring"); this._measure(); this._position()
              }; x._measure = function () {
                var k = this.container;
                const r = k ? k.clientWidth : 0; k = k ? k.clientHeight : 0; if (0 === r || 0 === k) return this.suspended || this._set("suspended", !0), !1; const A = this.width, z = this.height; if (r === A && k === z) return this.suspended && this._set("suspended", !1), !1; this._set("width", r); this._set("height", k); this.suspended && this._set("suspended", !1); this.emit("resize", { oldWidth: A, oldHeight: z, width: r, height: k }); return !0
              }; x._position = function () {
                var k = this.container; const r = this.position; {
                  const A = (k.ownerDocument || window.document).defaultView; k = k.getBoundingClientRect();
                  v[0] = k.left + A.pageXOffset; v[1] = k.top + A.pageYOffset
                } return r && v[0] === r[0] && v[1] === r[1] ? !1 : (this._set("position", [v[0], v[1]]), !0)
              }; x.forceDOMReadyCycle = function () { }; w._createClass(g, [{
                key: "container", set: function (k) {
                  var r = this._get("container"); if (r !== k) if (this.handles.remove("dom-size"), this._stopMeasuring(), r && (r.classList.remove("esri-view"), this._overlayRenderTaskHandle && (this._overlayRenderTaskHandle.remove(), this._overlayRenderTaskHandle = null), this.overlay.destroy(), this._set("overlay", null),
                    t(this.root), this._set("root", null), q.reparent(this.userContent, r), t(this.userContent), this._set("userContent", null)), k) {
                      k.classList.add("esri-view"); r = document.createElement("div"); r.className = "esri-view-user-storage"; q.reparent(k, r); k.appendChild(r); this._set("userContent", r); r = document.createElement("div"); r.className = "esri-view-root"; k.insertBefore(r, k.firstChild); this._set("root", r); const A = document.createElement("div"); A.className = "esri-view-surface"; A.setAttribute("role", "application"); A.tabIndex =
                        0; r.appendChild(A); this._set("surface", A); const z = new d; r.appendChild(z.surface); this._set("overlay", z); z.watch("needsRender", B => { B && !this._overlayRenderTaskHandle ? this._overlayRenderTaskHandle = u.addFrameTask({ render: () => { this.overlay.render() } }) : this._overlayRenderTaskHandle && (this._overlayRenderTaskHandle.remove(), this._overlayRenderTaskHandle = null) }); this.forceDOMReadyCycle(); this.handles.add(y.init(this, "size", B => {
                          const [C, D] = B; C >= document.body.clientWidth || D >= document.body.clientHeight ? A.classList.add("esri-view-surface--inset-outline") :
                            A.classList.remove("esri-view-surface--inset-outline")
                        }), "dom-size"); this._set("container", k); this._startMeasuring()
                  } else this._set("width", 0), this._set("height", 0), this._set("position", null), this._set("suspended", !0), this._set("surface", null), this._set("container", null)
                }
              }, { key: "focused", get: function () { const k = document.activeElement === this.surface; return document.hasFocus() && k } }, {
                key: "popup", get: function () { return this._get("popup") || new f({ view: this }) }, set: function (k) {
                  const r = this._get("popup"); r &&
                    r !== k && r.destroy(); this._set("popup", k)
                }
              }, { key: "size", get: function () { return [this.width, this.height] } }]); return g
            }(m); c.__decorate([n.property({ value: null, cast: e => q.byId(e) })], m.prototype, "container", null); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "focused", null); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "height", void 0); c.__decorate([n.property({ type: f })], m.prototype, "popup", null); c.__decorate([n.property({ type: d })], m.prototype, "overlay", void 0); c.__decorate([n.property({ readOnly: !0 })],
              m.prototype, "position", void 0); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "resizing", void 0); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "root", void 0); c.__decorate([n.property({ value: null, readOnly: !0 })], m.prototype, "size", null); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "surface", void 0); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "suspended", void 0); c.__decorate([n.property()], m.prototype, "ui", void 0); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "userContent",
                void 0); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "width", void 0); c.__decorate([n.property()], m.prototype, "widthBreakpoint", void 0); return m = c.__decorate([b.subclass("esri.views.DOMContainer")], m)
          }; a.isDOMContainer = function (m) { return m && "focus" in m }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/overlay/ViewOverlay": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/Collection ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../libs/maquette/projection ../../libs/maquette/projector ../support/WatchUpdatingTracking".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          c = function (f) {
            function t() { var m = f.apply(this, arguments) || this; m.items = new q; m._watchUpdatingTracking = new d.WatchUpdatingTracking; m._callbacks = new Map; m._projector = b.createProjector(); m._hiddenProjector = b.createProjector(); return m } a._inheritsLoose(t, f); var v = t.prototype; v.initialize = function () {
              const m = document.createElement("div"); m.className = "esri-overlay-surface"; this._set("surface", m); this._hiddenSurface = document.createElement("div"); this._hiddenSurface.setAttribute("style",
                "visibility: hidden;"); m.appendChild(this._hiddenSurface); this._watchUpdatingTracking.addOnCollectionChange(this.items, e => { for (const g of e.added) { const x = () => g.render(); this._callbacks.set(g, x); this._projector.append(this.surface, x) } for (const g of e.removed) e = this._projector.detach(this._callbacks.get(g)), this.surface.removeChild(e.domNode), this._callbacks.delete(g) })
            }; v.addItem = function (m) { this.items.add(m) }; v.removeItem = function (m) { this.items.remove(m) }; v.destroy = function () {
              this.items.removeAll();
              this._callbacks.forEach(m => this._projector.detach(m)); this._projector = this._callbacks = null; this._watchUpdatingTracking.destroy()
            }; v.render = function () { this._projector.renderNow() }; v.computeBoundingRect = function (m) {
              const e = this._hiddenSurface, g = this._hiddenProjector; let x = null; const k = () => x = m.render(); g.append(e, k); g.renderNow(); const r = { left: 0, top: 0, right: 0, bottom: 0 }; if (x && x.domNode) { const A = x.domNode.getBoundingClientRect(); r.left = A.left; r.top = A.top; r.right = A.right; r.bottom = A.bottom } for (g.detach(k); e.firstChild;)e.removeChild(e.firstChild);
              return r
            }; v.overlaps = function (m, e) { m = this.computeBoundingRect(m); e = this.computeBoundingRect(e); return Math.max(m.left, e.left) <= Math.min(m.right, e.right) && Math.max(m.top, e.top) <= Math.min(m.bottom, e.bottom) }; v.renderCanvas = function (m) { if (this.items.some(g => g.visible)) { var e = m.getContext("2d"); e.save(); e.font = `10px ${getComputedStyle(this.surface).fontFamily}`; this.items.forEach(g => { e.save(); g.renderCanvas(e); e.restore() }); e.restore() } }; a._createClass(t, [{ key: "needsRender", get: function () { return 0 < this.items.length } },
            { key: "hasVisibleItems", get: function () { return this.items.some(m => m.visible) } }]); return t
          }(c); w.__decorate([u.property({ readOnly: !0 })], c.prototype, "surface", void 0); w.__decorate([u.property({ readOnly: !0 })], c.prototype, "items", void 0); w.__decorate([u.property({ readOnly: !0 })], c.prototype, "needsRender", null); w.__decorate([u.property({ readOnly: !0 })], c.prototype, "_watchUpdatingTracking", void 0); w.__decorate([u.property({ readOnly: !0, aliasOf: "_watchUpdatingTracking.updating" })], c.prototype, "updating", void 0);
          return c = w.__decorate([l.subclass("esri.views.overlay.ViewOverlay")], c)
        })
    }, "esri/widgets/Popup": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../intl ../core/Collection ../core/events ../core/Handles ../core/Logger ../core/maybe ../core/throttle ../core/watchUtils ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Feature ./Spinner ./Widget ./Feature/support/FeatureContentMixin ./Popup/PopupViewModel ./support/Heading ./support/decorators/accessibleHandler ./support/decorators/messageBundle ./support/decorators/vmEvent ./support/jsxFactory ./support/widgetUtils ../intl/substitute".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H) {
          function J(P, L) { return void 0 === L ? `${"esri-popup"}__${P}` : `${"esri-popup"}__${P}-${L}` } const M = { buttonEnabled: !0, position: "auto", breakpoint: { width: 544 } }, F = n.getLogger("esri.widgets.Popup"), K = { closeButton: !0, featureNavigation: !0 }; c = function (P) {
            function L(G, I) {
              var O = P.call(this, G, I) || this; O._blurClose = !1; O._blurContainer = !1; O._containerNode = null; O._mainContainerNode = null; O._featureMenuNode = null; O._actionsMenuNode = null; O._focusClose = !1;
              O._focusContainer = !1; O._focusDockButton = !1; O._focusFeatureMenuButton = !1; O._focusActionsMenuButton = !1; O._focusFirstFeature = !1; O._focusFirstAction = !1; O._handles = new y; O._pointerOffsetInPx = 16; O._spinner = null; O._feature = null; O._featureMenuIntersectionObserverCallback = ([R]) => { null != R && R.isIntersecting && O.viewModel.featurePage++ }; O._featureMenuIntersectionObserver = new IntersectionObserver(O._featureMenuIntersectionObserverCallback, { root: window.document }); O._displaySpinnerThrottled = l.throttle(() => O._displaySpinner(),
                0); O.actions = null; O.alignment = "auto"; O.autoCloseEnabled = null; O.autoOpenEnabled = null; O.defaultPopupTemplateEnabled = null; O.content = null; O.collapsed = !1; O.collapseEnabled = !0; O.dockEnabled = !1; O.featureCount = null; O.featureMenuOpen = !1; O.features = null; O.goToOverride = null; O.headingLevel = 2; O.highlightEnabled = null; O.location = null; O.label = void 0; O.maxInlineActions = 3; O.messages = null; O.messagesCommon = null; O.promises = null; O.selectedFeature = null; O.selectedFeatureIndex = null; O.spinnerEnabled = !0; O.title = null; O.updateLocationEnabled =
                  null; O.view = null; O.viewModel = new r; O.visible = null; O.visibleElements = { ...K }; O._addSelectedFeatureIndexHandle(); O.own([h.watch(a._assertThisInitialized(O), "viewModel.screenLocation", () => O._positionContainer()), h.watch(a._assertThisInitialized(O), ["viewModel.active", "dockEnabled"], () => O._toggleScreenLocationEnabled()), h.watch(a._assertThisInitialized(O), "viewModel.screenLocation", (R, S) => { !!R !== !!S && O.reposition() }), h.watch(a._assertThisInitialized(O), ["viewModel.view.padding", "viewModel.view.size", "viewModel.active",
                    "viewModel.location", "alignment"], () => O.reposition()), h.watch(a._assertThisInitialized(O), "spinnerEnabled", R => O._spinnerEnabledChange(R)), h.watch(a._assertThisInitialized(O), "viewModel.view.size", (R, S) => O._updateDockEnabledForViewSize(R, S)), h.watch(a._assertThisInitialized(O), "viewModel.view", (R, S) => O._viewChange(R, S)), h.watch(a._assertThisInitialized(O), "viewModel.view.ready", (R, S) => O._viewReadyChange(R, S)), h.watch(a._assertThisInitialized(O), ["viewModel.waitingForResult", "viewModel.location"], () => { O._hideSpinner(); O._displaySpinnerThrottled() }), h.watch(a._assertThisInitialized(O), ["selectedFeatureWidget.viewModel.title", "selectedFeatureWidget.viewModel.state"], () => O._setTitleFromFeatureWidget()), h.watch(a._assertThisInitialized(O), ["selectedFeatureWidget.viewModel.content", "selectedFeatureWidget.viewModel.state"], () => O._setContentFromFeatureWidget()), h.whenFalse(a._assertThisInitialized(O), "collapsed", () => {
                    var R, S; "xsmall" === (null == (R = O.viewModel) ? void 0 : null == (S = R.view) ? void 0 : S.widthBreakpoint) &&
                      O.viewModel.active && O.collapseEnabled && O.viewModel.centerAtLocation()
                  }), h.on(a._assertThisInitialized(O), "viewModel.allActions", "change", () => O._watchActions()), h.init(a._assertThisInitialized(O), "viewModel.allActions", () => O._watchActions()), h.watch(a._assertThisInitialized(O), "viewModel.featureViewModels", () => O._featureMenuViewportScrollTop())]); return O
            } a._inheritsLoose(L, P); var N = L.prototype; N.destroy = function () {
              var G, I; this._destroySelectedFeatureWidget(); this._destroySpinner(); null == (G = this._handles) ?
                void 0 : G.destroy(); this._unobserveFeatureMenuObserver(); null == (I = this._featureMenuIntersectionObserver) ? void 0 : I.disconnect(); this._handles = null
            }; N.castVisibleElements = function (G) { return { ...K, ...G } }; N.blur = function () { const { active: G } = this.viewModel; G || F.warn("Popup can only be blurred when currently active."); this.visibleElements.closeButton ? this._blurClose = !0 : this._blurContainer = !0; this.scheduleRender() }; N.clear = function () { this.viewModel.clear() }; N.close = function () { this.visible = !1 }; N.fetchFeatures =
              function (G, I) { return this.viewModel.fetchFeatures(G, I) }; N.focus = function () { const { active: G } = this.viewModel; G || F.warn("Popup can only be focused when currently active."); this.visibleElements.closeButton ? this._focusClose = !0 : this._focusContainer = !0; this.scheduleRender() }; N.next = function () { return this.viewModel.next() }; N.open = function (G) {
                var I, O; this._handles.remove("selected-index"); const R = { collapsed: G ? !!G.collapsed : !1, actionsMenuOpen: G ? !!G.actionsMenuOpen : !1, featureMenuOpen: G ? !!G.featureMenuOpen : !1 };
                "xsmall" === (null == (I = this.viewModel) ? void 0 : null == (O = I.view) ? void 0 : O.widthBreakpoint) && (R.collapsed = !0); this.set(R); this.viewModel.open(G); this._addSelectedFeatureIndexHandle()
              }; N.previous = function () { return this.viewModel.previous() }; N.reposition = function () { this.renderNow(); this._positionContainer(); this._setCurrentAlignment() }; N.triggerAction = function (G) { this.viewModel.triggerAction(G) }; N.render = function () {
                var G, I, O, R; const { actionsMenuOpen: S, dockEnabled: Q, featureMenuVisible: T, dividedActions: da,
                  currentAlignment: Y, currentDockPosition: fa } = this, { active: ha } = this.viewModel; var { menuActions: ka } = da; ka = ha && 1 < ka.length && S; const ea = null == (G = this.selectedFeature) ? void 0 : null == (I = G.layer) ? void 0 : I.title; G = null == (O = this.selectedFeature) ? void 0 : null == (R = O.layer) ? void 0 : R.id; return D.tsx("div", {
                    class: this.classes("esri-popup", {
                      ["esri-popup--aligned-top-center"]: "top-center" === Y, ["esri-popup--aligned-bottom-center"]: "bottom-center" === Y, ["esri-popup--aligned-top-left"]: "top-left" === Y, ["esri-popup--aligned-bottom-left"]: "bottom-left" ===
                        Y, ["esri-popup--aligned-top-right"]: "top-right" === Y, ["esri-popup--aligned-bottom-right"]: "bottom-right" === Y, ["esri-popup--is-docked"]: ha && Q, ["esri-popup--shadow"]: ha && !Q, ["esri-popup--is-docked-top-left"]: "top-left" === fa, ["esri-popup--is-docked-top-center"]: "top-center" === fa, ["esri-popup--is-docked-top-right"]: "top-right" === fa, ["esri-popup--is-docked-bottom-left"]: "bottom-left" === fa, ["esri-popup--is-docked-bottom-center"]: "bottom-center" === fa, ["esri-popup--is-docked-bottom-right"]: "bottom-right" ===
                          fa, ["esri-popup--feature-menu-open"]: T, ["esri-popup--actions-menu-open"]: ka
                    }), role: "presentation", "data-layer-title": ea, "data-layer-id": G, bind: this, afterCreate: this._positionContainer, afterUpdate: this._positionContainer
                  }, ha ? [this.renderMainContainer(), this.renderPointer()] : null)
              }; N.renderLoadingIcon = function () { return D.tsx("span", { "aria-hidden": "true", class: this.classes("esri-popup__icon", "esri-icon-loading-indicator", "esri-rotating") }) }; N.renderNavigationLoading = function () {
                const { messagesCommon: G } =
                  this; return this.viewModel.pendingPromisesCount ? D.tsx("div", { key: J("loading-container"), role: "presentation", class: "esri-popup__loading-container", "aria-label": G.loading, title: G.loading }, this.renderLoadingIcon()) : null
              }; N.renderPreviousIcon = function () { const G = E.isRTL(this.container); return D.tsx("span", { "aria-hidden": "true", class: this.classes("esri-popup__icon", { ["esri-icon-right-triangle-arrow"]: G, ["esri-popup__pagination-previous-icon--rtl"]: G, ["esri-icon-left-triangle-arrow"]: !G, ["esri-popup__pagination-previous-icon"]: !G }) }) };
            N.renderPreviousButton = function () { const { messages: G } = this; return D.tsx("div", { role: "button", tabIndex: 0, bind: this, onclick: this._previous, onkeydown: this._previous, class: this.classes("esri-popup__button", "esri-popup__pagination-previous"), "aria-label": G.previous, title: G.previous }, this.renderPreviousIcon()) }; N.renderNextIcon = function () {
              const G = E.isRTL(this.container); return D.tsx("span", {
                "aria-hidden": "true", class: this.classes("esri-popup__icon", {
                  ["esri-icon-left-triangle-arrow"]: G, ["esri-popup__pagination-next-icon--rtl"]: G,
                  ["esri-icon-right-triangle-arrow"]: !G, ["esri-popup__pagination-next-icon"]: !G
                })
              })
            }; N.renderNextButton = function () { const { messages: G } = this; return D.tsx("div", { role: "button", tabIndex: 0, bind: this, onclick: this._next, onkeydown: this._next, class: this.classes("esri-popup__button", "esri-popup__pagination-next"), "aria-label": G.next, title: G.next }, this.renderNextIcon()) }; N.renderFeatureMenuButton = function () {
              const { featureMenuOpen: G, featureMenuId: I, messagesCommon: O } = this, { featureCount: R, selectedFeatureIndex: S } =
                this.viewModel; return D.tsx("div", { role: "button", tabIndex: 0, bind: this, onclick: this._toggleFeatureMenu, onkeydown: this._toggleFeatureMenu, afterCreate: this._focusFeatureMenuButtonNode, afterUpdate: this._focusFeatureMenuButtonNode, class: this.classes("esri-popup__button", "esri-popup__feature-menu-button"), "aria-haspopup": "true", "aria-controls": I, "aria-expanded": G.toString(), "aria-label": O.menu, title: O.menu }, this._getPageText(R, S))
            }; N.renderNavigationButtons = function () {
              return this.featureNavigationVisible ?
                [this.renderPreviousButton(), this.renderNavigationLoading() || this.renderFeatureMenuButton(), this.renderNextButton()] : null
            }; N.renderDockIcon = function () {
              const { dockEnabled: G } = this, I = this._wouldDockTo(); return D.tsx("span", {
                "aria-hidden": "true", class: this.classes({
                  ["esri-icon-minimize"]: G, ["esri-popup__icon--dock-icon"]: !G, ["esri-icon-dock-right"]: !G && ("top-right" === I || "bottom-right" === I), ["esri-icon-dock-left"]: !G && ("top-left" === I || "bottom-left" === I), ["esri-icon-maximize"]: !G && "top-center" === I, ["esri-icon-dock-bottom"]: !G &&
                    "bottom-center" === I
                }, "esri-popup__icon")
              })
            }; N.renderDockButton = function () {
              var G, I, O; const { dockEnabled: R, messages: S } = this, Q = null == (G = this.viewModel) ? void 0 : null == (I = G.view) ? void 0 : I.widthBreakpoint; G = R ? S.undock : S.dock; return "xsmall" !== Q && null != (O = this.dockOptions) && O.buttonEnabled ? D.tsx("div", {
                role: "button", "aria-label": G, title: G, tabIndex: 0, bind: this, onclick: this._toggleDockEnabled, onkeydown: this._toggleDockEnabled, afterCreate: this._focusDockButtonNode, afterUpdate: this._focusDockButtonNode, class: this.classes("esri-popup__button",
                  "esri-popup__button--dock")
              }, this.renderDockIcon()) : null
            }; N.renderTitle = function () {
              const { title: G } = this.viewModel, { titleId: I, collapsible: O, contentCollapsed: R, messagesCommon: S } = this; var Q = { ["esri-popup__header-container--button"]: O }; const T = D.tsx(A.Heading, { level: this.headingLevel, class: "esri-popup__header-title", innerHTML: G }); Q = O ? D.tsx("button", {
                key: `${G}--collapsible`, id: I, title: R ? S.expand : S.collapse, bind: this, enterAnimation: this._createFeatureUpdatedAnimation(), class: this.classes("esri-popup__header-container",
                  Q), "aria-expanded": R ? "false" : "true", onclick: this._toggleCollapsed
              }, T) : D.tsx("div", { key: G, id: I, bind: this, enterAnimation: this._createFeatureUpdatedAnimation(), class: this.classes("esri-popup__header-container", Q) }, T); return G ? Q : null
            }; N.renderCloseIcon = function () { return D.tsx("span", { "aria-hidden": "true", class: this.classes("esri-popup__icon", "esri-icon-close") }) }; N.renderCloseButton = function () {
              const { visibleElements: G, messagesCommon: I } = this; return G.closeButton ? D.tsx("div", {
                role: "button", tabIndex: 0, bind: this,
                onclick: this._close, onkeydown: this._close, class: "esri-popup__button", "aria-label": I.close, title: I.close, afterCreate: this._closeButtonNodeUpdated, afterUpdate: this._closeButtonNodeUpdated
              }, this.renderCloseIcon()) : null
            }; N.renderHeader = function () { return D.tsx("header", { class: "esri-popup__header" }, this.renderTitle(), D.tsx("div", { class: "esri-popup__header-buttons" }, this.renderDockButton(), this.renderCloseButton())) }; N.renderContentContainer = function () {
              const { contentId: G, hasContent: I, contentCollapsed: O } =
                this, { content: R } = this.viewModel; return I && !O ? D.tsx("article", { key: R, enterAnimation: this._createFeatureUpdatedAnimation(), id: G, class: "esri-popup__content" }, this.renderContent()) : null
            }; N.renderActionsMenuButton = function () {
              const { actionsMenuId: G, actionsMenuButtonId: I, actionsMenuOpen: O, dividedActions: R, messagesCommon: S } = this, Q = O ? S.close : S.open, { menuActions: T } = R; return T.length ? D.tsx("div", {
                key: J("actions-menu-button"), class: this.classes("esri-popup__button", "esri-popup__actions-menu-button"), role: "button",
                id: I, "aria-haspopup": "true", "aria-controls": O ? G : null, tabIndex: 0, bind: this, onclick: this._toggleActionsMenu, onkeydown: this._toggleActionsMenu, afterCreate: this._focusActionsMenuButtonNode, afterUpdate: this._focusActionsMenuButtonNode, "aria-label": Q, title: Q
              }, D.tsx("span", { "aria-hidden": "true", class: "esri-icon-handle-horizontal" })) : null
            }; N.renderMenuActions = function () {
              const { actionsMenuId: G, actionsMenuButtonId: I, actionsMenuOpen: O, dividedActions: R } = this, { menuActions: S } = R; return S.length && O ? D.tsx("ul", {
                id: G,
                role: "menu", "aria-labelledby": I, key: J("actions"), class: "esri-popup__actions", bind: this, onkeyup: this._handleActionMenuKeyup, afterCreate: this._actionsMenuNodeUpdated, afterUpdate: this._actionsMenuNodeUpdated
              }, S.toArray().map(Q => this.renderAction({ action: Q, type: "menu-item" }))) : null
            }; N.renderInlineActions = function () { const { inlineActions: G } = this.dividedActions; return !!G.length && G.toArray().map(I => this.renderAction({ action: I, type: "inline" })) }; N.renderInlineActionsContainer = function () {
              const { inlineActions: G,
                menuActions: I } = this.dividedActions, O = !!G.length, R = !!I.length; return O || R ? D.tsx("div", { key: "inline-actions-container", "data-inline-actions": O.toString(), "data-menu-actions": R.toString(), class: "esri-popup__inline-actions-container" }, this.renderInlineActions(), this.renderActionsMenuButton(), this.renderMenuActions()) : null
            }; N.renderNavigation = function () {
              return this.featureNavigationVisible ? D.tsx("section", { key: J("navigation"), class: this.classes("esri-popup__navigation") }, this.renderNavigationButtons()) :
                null
            }; N.renderFooter = function () { const { featureNavigationVisible: G, dividedActions: I } = this, { inlineActions: O, menuActions: R } = I, S = !!O.length, Q = { ["esri-popup__footer--has-pagination"]: G, ["esri-popup__footer--has-actions"]: S, ["esri-popup__footer--has-actions-menu"]: !!R.length }; return G || S ? D.tsx("div", { key: J("feature-buttons"), class: this.classes("esri-popup__footer", Q) }, this.renderInlineActionsContainer(), this.renderNavigation()) : null }; N.renderFeatureMenuContainer = function () {
              var { messages: G } = this; const { featureViewModels: I,
                isLoadingFeature: O } = this.viewModel; G = H.substitute(G.selectedFeatures, { total: I.length }); return D.tsx("section", { key: J("menu"), class: "esri-popup__feature-menu" }, D.tsx("strong", { class: "esri-popup__feature-menu-header" }, G), D.tsx("nav", { bind: this, class: "esri-popup__feature-menu-viewport", "data-node-ref": "_featureMenuViewportNode", afterCreate: E.storeNode }, this.renderFeatureMenu(), D.tsx("div", { class: "esri-popup__feature-menu-observer", bind: this, afterCreate: this._featureMenuIntersectionObserverCreated }),
                  O ? D.tsx("div", { class: "esri-popup__feature-menu-loader" }, this.renderLoadingIcon()) : null))
            }; N.renderPointer = function () { return this.dockEnabled ? null : D.tsx("div", { key: J("pointer"), class: "esri-popup__pointer", role: "presentation" }, D.tsx("div", { class: this.classes("esri-popup__pointer-direction", "esri-popup--shadow") })) }; N.renderMainContainer = function () {
              const { dockEnabled: G, currentAlignment: I, currentDockPosition: O, titleId: R, contentId: S, collapsible: Q, hasContent: T, contentCollapsed: da, visibleElements: Y } = this,
              { title: fa } = this.viewModel, ha = "bottom-left" === I || "bottom-center" === I || "bottom-right" === I || "top-left" === O || "top-center" === O || "top-right" === O, ka = "top-left" === I || "top-center" === I || "top-right" === I || "bottom-left" === O || "bottom-center" === O || "bottom-right" === O; return D.tsx("div", {
                class: this.classes("esri-popup__main-container", "esri-widget", { ["esri-popup--shadow"]: G, ["esri-popup--is-collapsible"]: Q, ["esri-popup--is-collapsed"]: da }), tabIndex: Y.closeButton ? null : -1, role: "dialog", "aria-labelledby": fa ? R : "", "aria-describedby": T &&
                  !da ? S : "", bind: this, onkeyup: this._handleMainKeyup, afterCreate: this._mainContainerNodeUpdated, afterUpdate: this._mainContainerNodeUpdated
              }, ha ? this.renderFooter() : null, ha ? this.renderFeatureMenuContainer() : null, this.renderHeader(), this.renderContentContainer(), ka ? this.renderFooter() : null, ka ? this.renderFeatureMenuContainer() : null)
            }; N.renderContent = function () { var G; const I = null == (G = this.viewModel) ? void 0 : G.content; return I ? "string" === typeof I ? D.tsx("div", { key: I, innerHTML: I }) : this.renderNodeContent(I) : null };
            N.renderActionText = function (G) { return D.tsx("span", { key: "text", class: "esri-popup__action-text" }, G) }; N.renderActionIcon = function (G) { const I = this._getActionClass(G), O = this._getActionImage(G), R = { ["esri-icon-loading-indicator"]: G.active, ["esri-rotating"]: G.active, ["esri-popup__icon"]: !!I, ["esri-popup__action-image"]: !G.active && !!O }; I && (R[I] = !G.active); return D.tsx("span", { key: "icon", "aria-hidden": "true", class: this.classes("esri-popup__icon", R), styles: this._getIconStyles(O) }) }; N.renderAction = function (G) {
              const { action: I,
                type: O } = G; G = this._getActionTitle(I); const R = { ["esri-popup__action"]: "toggle" !== I.type, ["esri-popup__action-toggle"]: "toggle" === I.type, ["esri-popup__action-toggle--on"]: "toggle" === I.type && I.value, ["esri-popup__button--disabled"]: I.disabled }, S = [this.renderActionIcon(I), this.renderActionText(G)]; G = "menu-item" === O ? D.tsx("li", {
                  key: I.uid, role: "menuitem", tabIndex: 0, title: G, "aria-label": G, class: this.classes("esri-popup__button", R), onkeyup: this._handleActionMenuItemKeyup, bind: this, "data-action-uid": I.uid,
                  onclick: this._triggerAction, onkeydown: this._triggerAction
                }, S) : D.tsx("div", { key: I.uid, role: "button", tabIndex: 0, title: G, "aria-label": G, class: this.classes("esri-popup__button", R), onkeyup: this._handleActionMenuItemKeyup, bind: this, "data-action-uid": I.uid, onclick: this._triggerAction, onkeydown: this._triggerAction }, S); return I.visible ? G : null
            }; N.renderFeatureMenuItem = function (G, I) {
              const { messages: O, messagesCommon: R } = this, { selectedFeatureIndex: S, selectedFeatureViewModel: Q } = this.viewModel; var T = G === Q; const da =
                { ["esri-popup__feature-menu-item--selected"]: T }; T = T ? D.tsx("span", { key: J(`feature-menu-selected-feature-${S}`), title: O.selectedFeature, "aria-label": O.selectedFeature, class: "esri-icon-check-mark" }) : null; G = D.tsx("span", { innerHTML: G.title || R.untitled }); return D.tsx("li", { role: "menuitem", tabIndex: -1, key: J(`feature-menu-feature-${S}`), class: this.classes(da, "esri-popup__feature-menu-item"), bind: this, "data-feature-index": I, onkeyup: this._handleFeatureMenuItemKeyup, onclick: this._selectFeature, onkeydown: this._selectFeature },
                  D.tsx("span", { class: "esri-popup__feature-menu-title" }, G, T))
            }; N.renderFeatureMenu = function () { const { featureMenuId: G } = this, { featureViewModels: I } = this.viewModel; return 1 < I.length ? D.tsx("ol", { class: "esri-popup__feature-menu-list", id: G, bind: this, afterCreate: this._featureMenuNodeUpdated, afterUpdate: this._featureMenuNodeUpdated, onkeyup: this._handleFeatureMenuKeyup, role: "menu" }, I.filter(O => !!O.graphic).map((O, R) => this.renderFeatureMenuItem(O, R))) : null }; N._getActionTitle = function (G) {
              const { messages: I, selectedFeature: O,
                messagesCommon: R } = this, { id: S } = G, Q = null == O ? void 0 : O.attributes; return (G = "zoom-to-feature" === S ? H.substitute(G.title, { messages: I }) : "remove-selected-feature" === S ? H.substitute(G.title, { messages: R }) : "zoom-to-clustered-features" === S ? H.substitute(G.title, { messages: I }) : "browse-clustered-features" === S ? H.substitute(G.title, { messages: I }) : G.title) && Q ? H.substitute(G, Q) : G
            }; N._getActionClass = function (G) {
              var { selectedFeature: I } = this; I = null == I ? void 0 : I.attributes; const { className: O, image: R } = G; return (G = R || O ? O : "esri-icon-default-action") &&
                I ? H.substitute(G, I) : G
            }; N._getActionImage = function (G) { var { selectedFeature: I } = this; I = null == I ? void 0 : I.attributes; ({ image: G } = G); return G && I ? H.substitute(G, I) : G }; N._createFeatureUpdatedAnimation = function () { return E.cssTransition("enter", "esri-popup--feature-updated") }; N._getInlineActionCount = function () { const { maxInlineActions: G, featureNavigationVisible: I } = this; if ("number" !== typeof G) return null; const O = Math.round(G); return Math.max(I ? O - 1 : O, 0) }; N._watchActions = function () {
              const { allActions: G } = this.viewModel;
              this.notifyChange("dividedActions"); this._handles.remove("actions"); G && G.forEach(I => { this._handles.add(h.watch(I, "uid active className disabled id title image visible".split(" "), () => this.scheduleRender()), "actions") })
            }; N._divideActions = function () { var { allActions: G } = this.viewModel; G = G.filter(S => S.visible); const I = this._getInlineActionCount(), O = null === I, R = 0 === I; return { inlineActions: O ? G.slice(0) : R ? new q : G.slice(0, I), menuActions: O ? new q : R ? G.slice(0) : G.slice(I) } }; N._featureMenuOpenChanged = function (G) {
              G ?
                this._focusFirstFeature = !0 : this._focusFeatureMenuButton = !0
            }; N._actionsMenuOpenChanged = function (G) { G ? this._focusFirstAction = !0 : this._focusActionsMenuButton = !0 }; N._setTitleFromFeatureWidget = function () { const { selectedFeatureWidget: G, messagesCommon: I } = this; if (G) { var O, R; this.viewModel.title = "error" === (null == (O = G.viewModel) ? void 0 : O.state) ? I.errorMessage : (null == (R = G.viewModel) ? void 0 : R.title) || "" } }; N._setContentFromFeatureWidget = function () {
              const { selectedFeatureWidget: G } = this; G && (this.viewModel.content =
                G)
            }; N._unobserveFeatureMenuObserver = function () { this._featureMenuIntersectionObserverNode && this._featureMenuIntersectionObserver.unobserve(this._featureMenuIntersectionObserverNode) }; N._featureMenuIntersectionObserverCreated = function (G) { this._unobserveFeatureMenuObserver(); this._featureMenuIntersectionObserver.observe(G); this._featureMenuIntersectionObserverNode = G }; N._handleFeatureMenuKeyup = function (G) {
            "Escape" === u.eventKey(G) && (G.stopPropagation(), this._focusFeatureMenuButton = !0, this.featureMenuOpen =
              !1, this.scheduleRender())
            }; N._handleActionMenuKeyup = function (G) { "Escape" === u.eventKey(G) && (G.stopPropagation(), this._focusActionsMenuButton = !0, this.actionsMenuOpen = !1, this.scheduleRender()) }; N._handleFeatureMenuItemKeyup = function (G) {
              const I = u.eventKey(G); var { _featureMenuNode: O } = this; const R = G.currentTarget["data-feature-index"]; if (O) {
                O = O.querySelectorAll("li"); var S = O.length; "ArrowUp" === I ? (G.stopPropagation(), O[(R - 1 + S) % S].focus()) : "ArrowDown" === I ? (G.stopPropagation(), O[(R + 1 + S) % S].focus()) : "Home" ===
                  I ? (G.stopPropagation(), O[0].focus()) : "End" === I && (G.stopPropagation(), O[O.length - 1].focus())
              }
            }; N._handleActionMenuItemKeyup = function (G) {
              const I = u.eventKey(G); var { _actionsMenuNode: O } = this; const R = G.currentTarget.dataset.actionUid; var { menuActions: S } = this.dividedActions; S = S.findIndex(T => T.uid === R); if (O) {
                O = O.querySelectorAll("li"); var Q = O.length; "ArrowUp" === I ? (G.stopPropagation(), O[(S - 1 + Q) % Q].focus()) : "ArrowDown" === I ? (G.stopPropagation(), O[(S + 1 + Q) % Q].focus()) : "Home" === I ? (G.stopPropagation(), O[0].focus()) :
                  "End" === I && (G.stopPropagation(), O[O.length - 1].focus())
              }
            }; N._handleMainKeyup = function (G) { const I = u.eventKey(G); "ArrowLeft" === I && (G.stopPropagation(), this.previous()); "ArrowRight" === I && (G.stopPropagation(), this.next()) }; N._spinnerEnabledChange = function (G) { this._destroySpinner(); G && (G = this.get("viewModel.view"), this._createSpinner(G)) }; N._hideSpinner = function () { const { _spinner: G } = this; G && (G.location = null, G.hide()) }; N._displaySpinner = function () {
              const { _spinner: G } = this; if (G) {
                var { location: I, waitingForResult: O } =
                  this.viewModel; O ? G.show({ location: I }) : G.hide()
              }
            }; N._getIconStyles = function (G) { return { "background-image": G ? `url(${G})` : "" } }; N._addSelectedFeatureIndexHandle = function () { const G = h.watch(this, "viewModel.selectedFeatureIndex", (I, O) => this._selectedFeatureIndexUpdated(I, O)); this._handles.add(G, "selected-index") }; N._selectedFeatureIndexUpdated = function (G, I) { const { featureCount: O } = this; O && G !== I && -1 !== G && (this.featureMenuOpen = this.actionsMenuOpen = !1) }; N._destroySelectedFeatureWidget = function () {
              const { _feature: G } =
                this; G && (G.viewModel = null, G && !G.destroyed && G.destroy()); this._feature = null
            }; N._isScreenLocationWithinView = function (G, I) { return -1 < G.x && -1 < G.y && G.x <= I.width && G.y <= I.height }; N._isOutsideView = function (G) { const { popupHeight: I, popupWidth: O, screenLocation: R, side: S, view: Q } = G; if (isNaN(O) || isNaN(I) || !Q || !R) return !1; G = Q.padding; return "right" === S && R.x + O / 2 > Q.width - G.right || "left" === S && R.x - O / 2 < G.left || "top" === S && R.y - I < G.top || "bottom" === S && R.y + I > Q.height - G.bottom ? !0 : !1 }; N._calculateAutoAlignment = function (G) {
              if ("auto" !==
                G) return G; const { _pointerOffsetInPx: I, _containerNode: O, _mainContainerNode: R, viewModel: S } = this, { screenLocation: Q, view: T } = S; if (p.isNone(Q) || !T || !O) return "top-center"; if (!this._isScreenLocationWithinView(Q, T)) return this._get("currentAlignment") || "top-center"; var da = (G = R ? window.getComputedStyle(R, null) : null) ? parseInt(G.getPropertyValue("max-height").replace(/[^-\d\.]/g, ""), 10) : 0, Y = G ? parseInt(G.getPropertyValue("height").replace(/[^-\d\.]/g, ""), 10) : 0; const { height: fa, width: ha } = O.getBoundingClientRect();
              G = ha + I; const ka = Math.max(fa, da, Y) + I; da = this._isOutsideView({ popupHeight: ka, popupWidth: G, screenLocation: Q, side: "right", view: T }); Y = this._isOutsideView({ popupHeight: ka, popupWidth: G, screenLocation: Q, side: "left", view: T }); const ea = this._isOutsideView({ popupHeight: ka, popupWidth: G, screenLocation: Q, side: "top", view: T }); G = this._isOutsideView({ popupHeight: ka, popupWidth: G, screenLocation: Q, side: "bottom", view: T }); return Y ? ea ? "bottom-right" : "top-right" : da ? ea ? "bottom-left" : "top-left" : ea ? G ? "top-center" : "bottom-center" :
                "top-center"
            }; N._callCurrentAlignment = function (G) { return "function" === typeof G ? G.call(this) : G }; N._getCurrentAlignment = function () { const { alignment: G, dockEnabled: I } = this; return I || !this.viewModel.active ? null : this._calculatePositionResult(this._calculateAutoAlignment(this._callCurrentAlignment(G))) }; N._setCurrentAlignment = function () { this._set("currentAlignment", this._getCurrentAlignment()) }; N._setCurrentDockPosition = function () { this._set("currentDockPosition", this._getCurrentDockPosition()) }; N._calculatePositionResult =
              function (G) { const I = ["left", "right"]; E.isRTL(this.container) && I.reverse(); return G.replace(/leading/gi, I[0]).replace(/trailing/gi, I[1]) }; N._callDockPosition = function (G) { return "function" === typeof G ? G.call(this) : G }; N._getDockPosition = function () { var G; return this._calculatePositionResult(this._calculateAutoDockPosition(this._callDockPosition(null == (G = this.dockOptions) ? void 0 : G.position))) }; N._getCurrentDockPosition = function () { return this.dockEnabled && this.viewModel.active ? this._getDockPosition() : null };
            N._wouldDockTo = function () { return this.dockEnabled ? null : this._getDockPosition() }; N._calculateAutoDockPosition = function (G) { var I; if ("auto" !== G) return G; G = null == (I = this.viewModel) ? void 0 : I.view; I = E.isRTL(this.container) ? "top-left" : "top-right"; if (!G) return I; var O = G.padding || { left: 0, right: 0, top: 0, bottom: 0 }; O = G.width - O.left - O.right; ({ breakpoints: G } = G); return G && O <= G.xsmall ? "bottom-center" : I }; N._positionContainer = function (G = this._containerNode) {
              G && (this._containerNode = G); if (G) {
                var { screenLocation: I } = this.viewModel,
                { width: O } = G.getBoundingClientRect(); if (I = this._calculatePositionStyle(I, O)) G.style.top = I.top, G.style.left = I.left, G.style.bottom = I.bottom, G.style.right = I.right
              }
            }; N._calculateFullWidth = function (G) { const { currentAlignment: I, _pointerOffsetInPx: O } = this; return "top-left" === I || "bottom-left" === I || "top-right" === I || "bottom-right" === I ? G + O : G }; N._calculateAlignmentPosition = function (G, I, O, R) {
              const { currentAlignment: S, _pointerOffsetInPx: Q } = this; R /= 2; const T = O.height - I; O = O.width - G; const { padding: da } = this.view; if ("bottom-center" ===
                S) return { top: I + Q - da.top, left: G - R - da.left }; if ("top-left" === S) return { bottom: T + Q - da.bottom, right: O + Q - da.right }; if ("bottom-left" === S) return { top: I + Q - da.top, right: O + Q - da.right }; if ("top-right" === S) return { bottom: T + Q - da.bottom, left: G + Q - da.left }; if ("bottom-right" === S) return { top: I + Q - da.top, left: G + Q - da.left }; if ("top-center" === S) return { bottom: T + Q - da.bottom, left: G - R - da.left }
            }; N._calculatePositionStyle = function (G, I) {
              const { dockEnabled: O, view: R } = this; if (R) {
                if (O) return { left: "", top: "", right: "", bottom: "" }; if (!p.isNone(G) &&
                  I && (I = this._calculateFullWidth(I), G = this._calculateAlignmentPosition(G.x, G.y, R, I))) return { top: void 0 !== G.top ? `${G.top}px` : "auto", left: void 0 !== G.left ? `${G.left}px` : "auto", bottom: void 0 !== G.bottom ? `${G.bottom}px` : "auto", right: void 0 !== G.right ? `${G.right}px` : "auto" }
              }
            }; N._viewChange = function (G, I) { G && I && (this.close(), this.clear()) }; N._viewReadyChange = function (G, I) { G ? (G = this.get("viewModel.view"), this._wireUpView(G)) : I && (this.close(), this.clear()) }; N._wireUpView = function (G) {
              this._destroySpinner(); if (G) {
                var { spinnerEnabled: I } =
                  this; I && this._createSpinner(G); this._setDockEnabledForViewSize(this.dockOptions)
              }
            }; N._dockingThresholdCrossed = function (G, I, O) { const [R, S] = G, [Q, T] = I, { width: da, height: Y } = O; return R <= da && Q > da || R > da && Q <= da || S <= Y && T > Y || S > Y && T <= Y }; N._updateDockEnabledForViewSize = function (G, I) {
              if (G && I) {
                var O = this.get("viewModel.view.padding") || { left: 0, right: 0, top: 0, bottom: 0 }, R = O.left + O.right, S = O.top + O.bottom; O = []; var Q = []; O[0] = G[0] - R; O[1] = G[1] - S; Q[0] = I[0] - R; Q[1] = I[1] - S; ({ dockOptions: G } = this); this._dockingThresholdCrossed(O,
                  Q, G.breakpoint) && this._setDockEnabledForViewSize(G); this._setCurrentDockPosition()
              }
            }; N._focusDockButtonNode = function (G) { this._focusDockButton && (this._focusDockButton = !1, G.focus()) }; N._closeButtonNodeUpdated = function (G) { this._focusClose ? (this._focusClose = !1, G.focus()) : this._blurClose && (this._blurClose = !1, G.blur()) }; N._mainContainerNodeUpdated = function (G) { this._mainContainerNode = G; this._focusContainer ? (this._focusContainer = !1, G.focus()) : this._blurContainer && (this._blurContainer = !1, G.blur()) }; N._featureMenuNodeUpdated =
              function (G) { (this._featureMenuNode = G) && this._focusFirstFeature && (this._focusFirstFeature = !1, G = G.querySelectorAll("li"), G.length && G[0].focus()) }; N._actionsMenuNodeUpdated = function (G) { (this._actionsMenuNode = G) && this._focusFirstAction && (this._focusFirstAction = !1, G = G.querySelectorAll("li"), G.length && G[0].focus()) }; N._focusFeatureMenuButtonNode = function (G) { this._focusFeatureMenuButton && (this._focusFeatureMenuButton = !1, G.focus()) }; N._focusActionsMenuButtonNode = function (G) {
              this._focusActionsMenuButton &&
                (this._focusActionsMenuButton = !1, G.focus())
              }; N._featureMenuViewportScrollTop = function () { this._featureMenuViewportNode && (this._featureMenuViewportNode.scrollTop = 0) }; N._toggleScreenLocationEnabled = function () { const { dockEnabled: G, viewModel: I } = this; I && (I.screenLocationEnabled = I.active && !G) }; N._shouldDockAtCurrentViewSize = function (G) {
                var I, O; G = G.breakpoint; const R = null == (I = this.viewModel) ? void 0 : null == (O = I.view) ? void 0 : O.ui; if (!R) return !1; const { width: S, height: Q } = R; if (isNaN(S) || isNaN(Q)) return !1; I = G.hasOwnProperty("width") &&
                  S <= G.width; O = G.hasOwnProperty("height") && Q <= G.height; return I || O
              }; N._setDockEnabledForViewSize = function (G) { G.breakpoint && (this.dockEnabled = this._shouldDockAtCurrentViewSize(G)) }; N._getPageText = function (G, I) { return this.featureNavigationVisible ? H.substitute(this.messages.pageText, { index: I + 1, total: G }) : null }; N._destroySpinner = function () { const { _spinner: G, view: I } = this; G && (I && I.ui && I.ui.remove(this._spinner, "popup-spinner"), G.destroy(), this._spinner = null) }; N._createSpinner = function (G) {
                G && (this._spinner =
                  new g({ view: G }), G.ui.add(this._spinner, { key: "popup-spinner", position: "manual" }))
              }; N._toggleCollapsed = function () { this.collapsed = !this.collapsed }; N._close = function () { this.close(); this.view && this.view.focus() }; N._toggleDockEnabled = function () { this.dockEnabled = !this.dockEnabled; this._focusDockButton = !0; this.scheduleRender() }; N._toggleFeatureMenu = function () { const G = !this.featureMenuOpen; this._featureMenuOpenChanged(G); this.actionsMenuOpen = !1; this.featureMenuOpen = G }; N._toggleActionsMenu = function () {
                const G =
                  !this.actionsMenuOpen; this._actionsMenuOpenChanged(G); this.featureMenuOpen = !1; this.actionsMenuOpen = G
              }; N._triggerAction = function (G) { const I = G.currentTarget.dataset.actionUid; var { allActions: O } = this.viewModel; G = O.findIndex(R => R.uid === I); (O = O.getItemAt(G)) && "toggle" === O.type && (O.value = !O.value); this.actionsMenuOpen = !1; this.viewModel.triggerAction(G) }; N._selectFeature = function (G) {
                G = G.currentTarget["data-feature-index"]; isNaN(G) || (this.viewModel.selectedFeatureIndex = G); this.featureMenuOpen = !1; this._focusFeatureMenuButton =
                  !0; this.scheduleRender()
              }; N._next = function () { this.next() }; N._previous = function () { this.previous() }; a._createClass(L, [{ key: "actionsMenuId", get: function () { return `${this.id}-actions-menu` } }, { key: "actionsMenuButtonId", get: function () { return `${this.id}-actions-menu-button` } }, { key: "featureMenuId", get: function () { return `${this.id}-feature-menu` } }, { key: "titleId", get: function () { return `${this.id}-popup-title` } }, { key: "contentId", get: function () { return `${this.id}-popup-content` } }, {
                key: "hasContent", get: function () {
                  var G,
                  I, O, R, S, Q, T; return !!(this.selectedFeatureWidget ? (null == (G = this.selectedFeatureWidget) ? 0 : null == (I = G.viewModel) ? 0 : I.waitingForContent) || "error" === (null == (O = this.selectedFeatureWidget) ? void 0 : null == (R = O.viewModel) ? void 0 : R.state) || (null == (S = this.selectedFeatureWidget) ? 0 : null == (Q = S.viewModel) ? 0 : Q.content) : null == (T = this.viewModel) ? 0 : T.content)
                }
              }, { key: "featureNavigationVisible", get: function () { return this.viewModel.active && 1 < this.viewModel.featureCount && this.visibleElements.featureNavigation } }, {
                key: "collapsible",
                get: function () { return !!(this.collapseEnabled && this.viewModel.title && this.hasContent) }
              }, { key: "featureMenuVisible", get: function () { return this.featureNavigationVisible && this.featureMenuOpen } }, { key: "contentCollapsed", get: function () { return this.collapsible && !this.featureMenuVisible && this.collapsed } }, { key: "dividedActions", get: function () { return this._divideActions() } }, {
                key: "actionsMenuOpen", get: function () { return this.viewModel.active ? this._get("actionsMenuOpen") : !1 }, set: function (G) {
                  this._set("actionsMenuOpen",
                    !!G)
                }
              }, { key: "currentAlignment", get: function () { return this._getCurrentAlignment() } }, { key: "currentDockPosition", get: function () { return this._getCurrentDockPosition() } }, {
                key: "dockOptions", get: function () { return this._get("dockOptions") || M }, set: function (G) {
                  var I = { ...M }; const O = this.get("viewModel.view.breakpoints"); var R = {}; O && (R.width = O.xsmall, R.height = O.xsmall); G = { ...I, ...G }; I = { ...I.breakpoint, ...R }; ({ breakpoint: R } = G); !0 === R ? G.breakpoint = I : "object" === typeof R && (G.breakpoint = { ...I, ...R }); this._set("dockOptions",
                    G); this._setCurrentDockPosition(); this.reposition()
                }
              }, { key: "selectedFeatureWidget", get: function () { const { _feature: G, visibleElements: I, headingLevel: O } = this, { selectedFeatureViewModel: R } = this.viewModel, S = { ...I, title: !1 }; if (!R) return null; G ? (G.viewModel = R, G.visibleElements = S) : this._feature = new e({ headingLevel: O + 1, viewModel: R, visibleElements: S }); return this._feature } }]); return L
          }(k.FeatureContentMixin(x)); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "actionsMenuId", null); w.__decorate([v.property({ readOnly: !0 })],
            c.prototype, "actionsMenuButtonId", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "featureMenuId", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "titleId", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "contentId", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "hasContent", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "featureNavigationVisible", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "collapsible", null); w.__decorate([v.property({ readOnly: !0 })],
              c.prototype, "featureMenuVisible", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "contentCollapsed", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "dividedActions", null); w.__decorate([b.aliasOf("viewModel.actions")], c.prototype, "actions", void 0); w.__decorate([v.property()], c.prototype, "actionsMenuOpen", null); w.__decorate([v.property()], c.prototype, "alignment", void 0); w.__decorate([b.aliasOf("viewModel.autoCloseEnabled")], c.prototype, "autoCloseEnabled", void 0); w.__decorate([b.aliasOf("viewModel.autoOpenEnabled")],
                c.prototype, "autoOpenEnabled", void 0); w.__decorate([b.aliasOf("viewModel.defaultPopupTemplateEnabled")], c.prototype, "defaultPopupTemplateEnabled", void 0); w.__decorate([b.aliasOf("viewModel.content")], c.prototype, "content", void 0); w.__decorate([v.property()], c.prototype, "collapsed", void 0); w.__decorate([v.property()], c.prototype, "collapseEnabled", void 0); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "currentAlignment", null); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "currentDockPosition",
                  null); w.__decorate([v.property()], c.prototype, "dockOptions", null); w.__decorate([v.property()], c.prototype, "dockEnabled", void 0); w.__decorate([b.aliasOf("viewModel.featureCount")], c.prototype, "featureCount", void 0); w.__decorate([v.property()], c.prototype, "featureMenuOpen", void 0); w.__decorate([b.aliasOf("viewModel.features")], c.prototype, "features", void 0); w.__decorate([b.aliasOf("viewModel.goToOverride")], c.prototype, "goToOverride", void 0); w.__decorate([v.property()], c.prototype, "headingLevel", void 0);
          w.__decorate([b.aliasOf("viewModel.highlightEnabled")], c.prototype, "highlightEnabled", void 0); w.__decorate([b.aliasOf("viewModel.location")], c.prototype, "location", void 0); w.__decorate([v.property({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], c.prototype, "label", void 0); w.__decorate([v.property()], c.prototype, "maxInlineActions", void 0); w.__decorate([v.property(), B.messageBundle("esri/widgets/Popup/t9n/Popup")], c.prototype, "messages", void 0); w.__decorate([v.property(), B.messageBundle("esri/t9n/common")],
            c.prototype, "messagesCommon", void 0); w.__decorate([b.aliasOf("viewModel.promises")], c.prototype, "promises", void 0); w.__decorate([b.aliasOf("viewModel.selectedFeature")], c.prototype, "selectedFeature", void 0); w.__decorate([b.aliasOf("viewModel.selectedFeatureIndex")], c.prototype, "selectedFeatureIndex", void 0); w.__decorate([v.property({ readOnly: !0 })], c.prototype, "selectedFeatureWidget", null); w.__decorate([v.property()], c.prototype, "spinnerEnabled", void 0); w.__decorate([b.aliasOf("viewModel.title")],
              c.prototype, "title", void 0); w.__decorate([b.aliasOf("viewModel.updateLocationEnabled")], c.prototype, "updateLocationEnabled", void 0); w.__decorate([b.aliasOf("viewModel.view")], c.prototype, "view", void 0); w.__decorate([v.property({ type: r }), C.vmEvent(["triggerAction", "trigger-action"])], c.prototype, "viewModel", void 0); w.__decorate([b.aliasOf("viewModel.visible")], c.prototype, "visible", void 0); w.__decorate([v.property()], c.prototype, "visibleElements", void 0); w.__decorate([t.cast("visibleElements")], c.prototype,
                "castVisibleElements", null); w.__decorate([z.accessibleHandler()], c.prototype, "_close", null); w.__decorate([z.accessibleHandler()], c.prototype, "_toggleDockEnabled", null); w.__decorate([z.accessibleHandler()], c.prototype, "_toggleFeatureMenu", null); w.__decorate([z.accessibleHandler()], c.prototype, "_toggleActionsMenu", null); w.__decorate([z.accessibleHandler()], c.prototype, "_triggerAction", null); w.__decorate([z.accessibleHandler()], c.prototype, "_selectFeature", null); w.__decorate([z.accessibleHandler()],
                  c.prototype, "_next", null); w.__decorate([z.accessibleHandler()], c.prototype, "_previous", null); return c = w.__decorate([m.subclass("esri.widgets.Popup")], c)
        })
    }, "esri/core/throttle": function () {
      define(["exports"], function (a) {
        function w(c, q, u, y) {
          let n = null, p = 1E3; "number" === typeof q ? (p = q, y = u) : (n = null != q ? q : null, p = u); let l = 0, h; const b = () => { l = 0; c.apply(y, h) }; q = (...d) => { n && n.apply(y, d); h = d; p ? l || (l = setTimeout(b, p)) : b() }; q.remove = () => { l && (clearTimeout(l), l = 0) }; q.forceUpdate = () => { l && (clearTimeout(l), b()) }; q.hasPendingUpdates =
            () => !!l; return q
        } a.default = w; a.throttle = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Feature": function () {
      define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../intl ../core/watchUtils ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./Feature/FeatureAttachments ./Feature/FeatureContent ./Feature/FeatureExpression ./Feature/FeatureFields ./Feature/FeatureMedia ./Feature/FeatureViewModel ./Feature/support/FeatureContentMixin ./support/Heading ./support/widgetUtils ./support/decorators/messageBundle ../core/Logger ./support/jsxFactory ../intl/substitute".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          const D = { title: !0, content: !0, lastEditedInfo: !0 }; q = function (E) {
            function H(M, F) { M = E.call(this, M, F) || this; M._contentWidgets = []; M.graphic = null; M.defaultPopupTemplateEnabled = !1; M.headingLevel = 2; M.label = void 0; M.messages = null; M.messagesCommon = null; M.messagesURIUtils = null; M.spatialReference = null; M.title = null; M.visibleElements = { ...D }; M.map = null; M.view = null; M.viewModel = new g; return M } w._inheritsLoose(H, E); var J = H.prototype; J.initialize = function () {
              this.own(u.init(this,
                "viewModel.contentViewModels", () => this._setupContentWidgets()))
            }; J.loadDependencies = function () { return new Promise((M, F) => a(["../chunks/calcite-notice"], M, F)) }; J.destroy = function () { this._destroyContentWidgets() }; J.castVisibleElements = function (M) { return { ...D, ...M } }; J.render = function () {
              var { state: M } = this.viewModel; M = B.tsx("div", { class: "esri-feature__size-container", key: "container" }, this.renderTitle(), "error" === M ? this.renderError() : "loading" === M ? this.renderLoading() : this.renderContentContainer()); return B.tsx("div",
                { class: this.classes("esri-feature", "esri-widget") }, M)
            }; J.setActiveMedia = function (M, F) { this.viewModel.setActiveMedia(M, F) }; J.nextMedia = function (M) { this.viewModel.nextMedia(M) }; J.previousMedia = function (M) { this.viewModel.previousMedia(M) }; J.renderError = function () {
              const { messagesCommon: M, messages: F, visibleElements: K } = this; return B.tsx("calcite-notice", { active: !0, color: "red", icon: "exclamation-mark-circle", scale: "s" }, K.title ? B.tsx("div", { key: "error-title", slot: "title" }, M.errorMessage) : null, B.tsx("div",
                { key: "error-message", slot: "message" }, F.loadingError))
            }; J.renderLoading = function () { return B.tsx("div", { key: "loading-container", class: "esri-feature__loading-container" }, B.tsx("span", { class: this.classes("esri-icon-loading-indicator esri-rotating", "esri-feature__loading-spinner") })) }; J.renderContentContainer = function () { const { visibleElements: M } = this; return M.content ? B.tsx("div", { class: "esri-feature__main-container" }, [this.renderContent(), this.renderLastEditInfo()]) : null }; J.renderTitle = function () {
              const { visibleElements: M,
                title: F } = this; return M.title ? B.tsx(k.Heading, { level: this.headingLevel, class: "esri-feature__title", innerHTML: F }) : null
            }; J.renderContent = function () { var M = this.viewModel.content; return M ? Array.isArray(M) ? M.length ? B.tsx("div", { key: "content-content-elements" }, M.map(this.renderContentElement, this)) : null : "string" === typeof M ? (M = this._contentWidgets[0], !M || M.destroyed ? null : B.tsx("div", { key: "content-content" }, M.render())) : this.renderNodeContent(M) : null }; J.renderContentElement = function (M, F) {
              const { visibleElements: K } =
                this; if ("boolean" !== typeof K.content && !K.content[M.type]) return null; switch (M.type) { case "attachments": return this.renderAttachments(F); case "custom": return this.renderCustom(M, F); case "fields": return this.renderFields(F); case "media": return this.renderMedia(F); case "text": return this.renderText(M, F); case "expression": return this.renderExpression(F); default: return null }
            }; J.renderAttachments = function (M) {
              const F = this._contentWidgets[M]; if (!F || F.destroyed) return null; const { state: K, attachmentInfos: P } =
                F.viewModel; return "loading" === K || 0 < P.length ? B.tsx("div", { key: this._buildKey("attachments-element", M), class: this.classes("esri-feature__content-element") }, F.render()) : null
            }; J.renderExpression = function (M) { const F = this._contentWidgets[M]; return !F || F.destroyed ? null : B.tsx("div", { key: this._buildKey("expression-element", M), class: "esri-feature__content-element" }, F.render()) }; J.renderCustom = function (M, F) {
              ({ creator: M } = M); const K = this._contentWidgets[F]; return !K || K.destroyed ? null : M ? B.tsx("div", {
                key: this._buildKey("custom-element",
                  F), class: "esri-feature__content-element"
              }, K.render()) : null
            }; J.renderFields = function (M) { const F = this._contentWidgets[M]; return !F || F.destroyed ? null : B.tsx("div", { key: this._buildKey("fields-element", M), class: "esri-feature__content-element" }, F.render()) }; J.renderMedia = function (M) { const F = this._contentWidgets[M]; return !F || F.destroyed ? null : B.tsx("div", { key: this._buildKey("media-element", M), class: "esri-feature__content-element" }, F.render()) }; J.renderLastEditInfo = function () {
              const { visibleElements: M, messages: F } =
                this; var { lastEditInfo: K } = this.viewModel; if (!K || !M.lastEditedInfo) return null; const { date: P, user: L } = K; K = C.substitute("edit" === K.type ? L ? F.lastEditedByUser : F.lastEdited : L ? F.lastCreatedByUser : F.lastCreated, { date: P, user: L }); return B.tsx("div", { key: "edit-info-element", class: this.classes("esri-feature__last-edited-info", "esri-feature__content-element") }, K)
            }; J.renderText = function (M, F) {
              const K = this._contentWidgets[F]; return !K || K.destroyed ? null : M.text ? B.tsx("div", {
                key: this._buildKey("text-element", F), class: this.classes("esri-feature__content-element",
                  "esri-feature__text")
              }, K.render()) : null
            }; J._buildKey = function (M, ...F) { const K = this.get("viewModel.graphic.uid") || "0"; F = F.join("-"); return `${M}__${K}-${F}` }; J._destroyContentWidget = function (M) { M && (M.viewModel = null, !M.destroyed && M.destroy()) }; J._destroyContentWidgets = function () { this._contentWidgets.forEach(M => this._destroyContentWidget(M)); this._contentWidgets = [] }; J._setupContentWidgets = function () {
              this._destroyContentWidgets(); const { headingLevel: M, visibleElements: F } = this; var K = this.get("viewModel.content");
              const { contentViewModels: P } = this.viewModel; Array.isArray(K) ? K.forEach((L, N) => {
              "attachments" === L.type && (this._contentWidgets[N] = new f({ displayType: L.displayType, headingLevel: F.title ? M + 1 : M, viewModel: P[N] })); "fields" === L.type && (this._contentWidgets[N] = new m({ viewModel: P[N] })); "media" === L.type && (this._contentWidgets[N] = new e({ viewModel: P[N] })); "text" === L.type && (this._contentWidgets[N] = new t({ viewModel: P[N] })); "custom" === L.type && (this._contentWidgets[N] = new t({ viewModel: P[N] })); "expression" === L.type &&
                (this._contentWidgets[N] = new v({ viewModel: P[N] }))
              }, this) : (K = P[0]) && !K.destroyed && (this._contentWidgets[0] = new t({ viewModel: K })); this.scheduleRender()
            }; return H
          }(x.FeatureContentMixin(d)); c.__decorate([y.aliasOf("viewModel.graphic")], q.prototype, "graphic", void 0); c.__decorate([y.aliasOf("viewModel.defaultPopupTemplateEnabled")], q.prototype, "defaultPopupTemplateEnabled", void 0); c.__decorate([h.property()], q.prototype, "headingLevel", void 0); c.__decorate([h.property({
            aliasOf: {
              source: "messages.widgetLabel",
              overridable: !0
            }
          })], q.prototype, "label", void 0); c.__decorate([h.property(), A.messageBundle("esri/widgets/Feature/t9n/Feature")], q.prototype, "messages", void 0); c.__decorate([h.property(), A.messageBundle("esri/t9n/common")], q.prototype, "messagesCommon", void 0); c.__decorate([h.property(), A.messageBundle("esri/widgets/support/t9n/uriUtils")], q.prototype, "messagesURIUtils", void 0); c.__decorate([y.aliasOf("viewModel.spatialReference")], q.prototype, "spatialReference", void 0); c.__decorate([y.aliasOf("viewModel.title")],
            q.prototype, "title", void 0); c.__decorate([h.property()], q.prototype, "visibleElements", void 0); c.__decorate([l.cast("visibleElements")], q.prototype, "castVisibleElements", null); c.__decorate([y.aliasOf("viewModel.map")], q.prototype, "map", void 0); c.__decorate([y.aliasOf("viewModel.view")], q.prototype, "view", void 0); c.__decorate([h.property({ type: g })], q.prototype, "viewModel", void 0); return q = c.__decorate([b.subclass("esri.widgets.Feature")], q)
        })
    }, "esri/widgets/Feature/FeatureAttachments": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/watchUtils ../../core/accessorSupport/decorators/aliasOf ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/subclass ../Attachments ../Widget ./FeatureAttachments/FeatureAttachmentsViewModel ./support/FeatureElementInfo ../support/widgetUtils ../../core/Logger ../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          u = function (e) {
            function g(k, r) { k = e.call(this, k, r) || this; k._featureElementInfo = null; k.attachmentsWidget = new h; k.description = null; k.displayType = null; k.graphic = null; k.headingLevel = 2; k.title = null; k.viewModel = new d; return k } a._inheritsLoose(g, e); var x = g.prototype; x.initialize = function () {
            this._featureElementInfo = new f; c.init(this, ["viewModel.description", "viewModel.title", "headingLevel"], () => this._setupFeatureElementInfo()); c.init(this, "viewModel.graphic", k => this.attachmentsWidget.graphic =
              k)
            }; x.destroy = function () { this.attachmentsWidget.destroy(); this._featureElementInfo.destroy() }; x.render = function () { var k; const { attachmentsWidget: r } = this; return m.tsx("div", { class: "esri-feature-attachments" }, null == (k = this._featureElementInfo) ? void 0 : k.render(), null == r ? void 0 : r.render()) }; x._setupFeatureElementInfo = function () { const { description: k, title: r, headingLevel: A } = this; this._featureElementInfo.set({ description: k, title: r, headingLevel: A }) }; return g
          }(b); w.__decorate([p.property({ readOnly: !0 })], u.prototype,
            "attachmentsWidget", void 0); w.__decorate([q.aliasOf("viewModel.description")], u.prototype, "description", void 0); w.__decorate([q.aliasOf("attachmentsWidget.displayType")], u.prototype, "displayType", void 0); w.__decorate([q.aliasOf("viewModel.graphic")], u.prototype, "graphic", void 0); w.__decorate([p.property()], u.prototype, "headingLevel", void 0); w.__decorate([q.aliasOf("viewModel.title")], u.prototype, "title", void 0); w.__decorate([p.property({ type: d })], u.prototype, "viewModel", void 0); return u = w.__decorate([l.subclass("esri.widgets.Feature.FeatureAttachments")],
              u)
        })
    }, "esri/widgets/Attachments": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Error ../core/unitFormatUtils ../core/watchUtils ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./Attachments/AttachmentsViewModel ./Attachments/support/attachmentUtils ./support/widgetUtils ./support/decorators/messageBundle ../core/Logger ./support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
          const x = { addButton: !0, addSubmitButton: !0, cancelAddButton: !0, cancelUpdateButton: !0, deleteButton: !0, errorMessage: !0, progressBar: !0, updateButton: !0 }, k = window.CSS; n = function (r) {
            function A(B, C) {
              B = r.call(this, B, C) || this; B.abilities = null; B.displayType = "auto"; B.graphic = null; B.label = void 0; B.messages = null; B.messagesUnits = null; B.selectedFile = null; B.submitting = !1; B.viewModel = new f; B.visibleElements = { ...x }; B._supportsImageOrientation = k && k.supports && k.supports("image-orientation",
                "from-image"); B._addAttachmentForm = null; B._updateAttachmentForm = null; return B
            } a._inheritsLoose(A, r); var z = A.prototype; z.initialize = function () { this.own(u.on(this, "viewModel.attachmentInfos", "change", () => this.scheduleRender()), u.init(this, "viewModel.mode", () => this._modeChanged())) }; z.castVisibleElements = function (B) { return { ...x, ...B } }; z.addAttachment = function () {
              const { _addAttachmentForm: B, viewModel: C } = this; this._set("submitting", !0); this._set("error", null); return C.addAttachment(B).then(D => {
                this._set("submitting",
                  !1); this._set("error", null); C.mode = "view"; return D
              }).catch(D => { this._set("submitting", !1); this._set("error", new c("attachments:add-attachment", this.messages.addErrorMessage, D)); throw D; })
            }; z.deleteAttachment = function (B) {
              const { viewModel: C } = this; this._set("submitting", !0); this._set("error", null); return C.deleteAttachment(B).then(D => { this._set("submitting", !1); this._set("error", null); C.mode = "view"; return D }).catch(D => {
                this._set("submitting", !1); this._set("error", new c("attachments:delete-attachment",
                  this.messages.deleteErrorMessage, D)); throw D;
              })
            }; z.updateAttachment = function () { const { viewModel: B } = this, { _updateAttachmentForm: C } = this; this._set("submitting", !0); this._set("error", null); return B.updateAttachment(C).then(D => { this._set("submitting", !1); this._set("error", null); B.mode = "view"; return D }).catch(D => { this._set("submitting", !1); this._set("error", new c("attachments:update-attachment", this.messages.updateErrorMessage, D)); throw D; }) }; z.render = function () {
              const { submitting: B, viewModel: C } = this, { state: D } =
                C; return g.tsx("div", { class: this.classes("esri-attachments", "esri-widget") }, B ? this.renderProgressBar() : null, "loading" === D ? this.renderLoading() : this.renderAttachments(), this.renderErrorMessage())
            }; z.renderErrorMessage = function () { const { error: B, visibleElements: C } = this; return B && C.errorMessage ? g.tsx("div", { key: "error-message", class: "esri-attachments__error-message" }, B.message) : null }; z.renderAttachments = function () {
              const { mode: B, activeAttachmentInfo: C } = this.viewModel; return "add" === B ? this.renderAddForm() :
                "edit" === B ? this.renderDetailsForm(C) : this.renderAttachmentContainer()
            }; z.renderLoading = function () { return g.tsx("div", { class: "esri-attachments__loader-container", key: "loader" }, g.tsx("div", { class: "esri-attachments__loader" })) }; z.renderProgressBar = function () { return this.visibleElements.progressBar ? g.tsx("div", { class: "esri-attachments__progress-bar", key: "progress-bar" }) : null }; z.renderAddForm = function () {
              const { submitting: B, selectedFile: C } = this; var D = B || !C, E = this.visibleElements.cancelAddButton ? g.tsx("button",
                { type: "button", bind: this, disabled: B, onclick: this._cancelForm, class: this.classes("esri-button", "esri-button--tertiary", "esri-button--small", "esri-button--half", B && "esri-button--disabled") }, this.messages.cancel) : null; D = this.visibleElements.addSubmitButton ? g.tsx("button", { type: "submit", disabled: D, class: this.classes("esri-button", "esri-button--secondary", "esri-button--small", "esri-button--half", { ["esri-button--disabled"]: D }) }, this.messages.add) : null; const H = C ? g.tsx("span", { key: "file-name", class: "esri-attachments__file-name" },
                  C.name) : null; E = g.tsx("form", { bind: this, afterCreate: v.storeNode, afterRemoved: v.discardNode, "data-node-ref": "_addAttachmentForm", onsubmit: this._submitAddAttachment }, g.tsx("fieldset", { class: "esri-attachments__file-fieldset" }, H, g.tsx("label", { class: this.classes("esri-attachments__file-label", "esri-button", "esri-button--secondary") }, C ? this.messages.changeFile : this.messages.selectFile, g.tsx("input", { class: "esri-attachments__file-input", type: "file", name: "attachment", bind: this, onchange: this._handleFileInputChange }))),
                    D, E); return g.tsx("div", { key: "add-form-container", class: "esri-attachments__form-node" }, E)
            }; z.renderDetailsForm = function (B) {
              const { visibleElements: C, viewModel: D, selectedFile: E, submitting: H } = this, { contentType: J, size: M, url: F } = B; var { abilities: K } = D, P = H || !E, L = K.editing && K.operations.delete && C.deleteButton ? g.tsx("button", {
                key: "delete-button", type: "button", disabled: H, bind: this, onclick: O => this._submitDeleteAttachment(O, B), class: this.classes("esri-button", "esri-button--small", "esri-button--tertiary", "esri-attachments__delete-button",
                  { ["esri-button--disabled"]: H })
              }, this.messages.delete) : null; P = K.editing && K.operations.update && C.updateButton ? g.tsx("button", { disabled: P, key: "update-button", type: "submit", class: this.classes("esri-button", "esri-button--small", "esri-button--third", { ["esri-button--disabled"]: P }) }, this.messages.update) : null; const N = this.visibleElements.cancelUpdateButton ? g.tsx("button", {
                disabled: H, key: "cancel-button", type: "button", bind: this, onclick: this._cancelForm, class: this.classes("esri-button", "esri-button--small",
                  "esri-button--tertiary", "esri-button--third", { ["esri-button--disabled"]: H })
              }, this.messages.cancel) : null; var G = E ? g.tsx("span", { key: "file-name", class: "esri-attachments__file-name" }, E.name) : null; K = K.editing && K.operations.update ? g.tsx("fieldset", { key: "file", class: "esri-attachments__file-fieldset" }, G, g.tsx("label", { class: this.classes("esri-attachments__file-label", "esri-button", "esri-button--secondary") }, this.messages.changeFile, g.tsx("input", {
                class: "esri-attachments__file-input", type: "file", name: "attachment",
                bind: this, onchange: this._handleFileInputChange
              }))) : null; G = g.tsx("fieldset", { key: "size", class: "esri-attachments__metadata-fieldset" }, g.tsx("label", null, q.formatFileSize(this.messagesUnits, M))); const I = g.tsx("fieldset", { key: "content-type", class: "esri-attachments__metadata-fieldset" }, g.tsx("label", null, J)); L = g.tsx("form", { bind: this, afterCreate: v.storeNode, afterRemoved: v.discardNode, "data-node-ref": "_updateAttachmentForm", onsubmit: this._submitUpdateAttachment }, g.tsx("div", { class: "esri-attachments__metadata" },
                G, I), K, g.tsx("div", { class: "esri-attachments__actions" }, L, N, P)); return g.tsx("div", { key: "edit-form-container", class: "esri-attachments__form-node" }, g.tsx("a", { class: "esri-attachments__item-link", href: F, rel: "noreferrer", target: "_blank" }, this.renderImageMask({ attachmentInfo: B, size: 400 }), g.tsx("div", { class: "esri-attachments__item-link-overlay" }, g.tsx("span", { class: "esri-attachments__item-link-overlay-icon" }, g.tsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32" }, g.tsx("path",
                  { d: "M28 13h1v16H3V3h16v1H4v24h24zm-5-9h4.293L15.646 15.638l.707.707L28 4.707V9h1V3h-6z" }), g.tsx("path", { fill: "none", d: "M0 0h32v32H0z" }))))), L)
            }; z.renderImageMask = function ({ attachmentInfo: B, size: C }) {
              var { supportsResizeAttachments: D } = this.viewModel; const { contentType: E, name: H, url: J } = B, M = D && t.isSupportedImage(E); B = (B = this._getCSSTransform(B, M)) ? { transform: B, "image-orientation": "none" } : {}; const F = -1 === J.indexOf("?") ? "?" : "\x26"; C = M ? `${J}${F}w=${C}` : t.getIconPath(E); D = { ["esri-attachments__image--resizable"]: D };
              return g.tsx("div", { class: this.classes({ ["esri-attachments__item-mask--icon"]: !M }, "esri-attachments__item-mask") }, g.tsx("img", { styles: B, alt: H, src: C, class: this.classes(D, "esri-attachments__image") }))
            }; z.renderAttachmentInfo = function ({ attachmentInfo: B, displayType: C }) {
              var { viewModel: D } = this; ({ abilities: D } = D); const { name: E, url: H } = B; C = this.renderImageMask({ attachmentInfo: B, size: "list" === C ? 48 : 400 }); var J = D.editing ? g.tsx("span", {
                "aria-hidden": "true", class: this.classes("esri-attachments__item-chevron-icon",
                  v.isRTL(this.container) ? "esri-icon-left" : "esri-icon-right")
              }) : null; J = g.tsx("label", { class: "esri-attachments__label" }, g.tsx("span", { class: "esri-attachments__filename" }, E || this.messages.noTitle), J); C = [C, J]; D = D.editing ? g.tsx("button", { key: "details-button", bind: this, class: "esri-attachments__item-button", title: this.messages.attachmentDetails, "aria-label": this.messages.attachmentDetails, "data-attachment-info-id": B.id, onclick: () => this._startEditAttachment(B), type: "button" }, C) : g.tsx("a", {
                key: "details-link",
                class: "esri-attachments__item-button", href: H, target: "_blank"
              }, C); return g.tsx("li", { class: "esri-attachments__item", key: B }, D)
            }; z.renderAttachmentContainer = function () {
              const { effectiveDisplayType: B, viewModel: C, visibleElements: D } = this, { attachmentInfos: E, abilities: H } = C; var J = E && E.length; const M = { ["esri-attachments__container--list"]: "preview" !== B, ["esri-attachments__container--preview"]: "preview" === B }, F = H.editing && H.operations.add && D.addButton ? g.tsx("button", {
                bind: this, onclick: () => this._startAddAttachment(),
                class: this.classes("esri-button", "esri-button--tertiary", "esri-attachments__add-attachment-button"), type: "button"
              }, g.tsx("span", { "aria-hidden": "true", class: this.classes("esri-attachments__item-add-icon", "esri-icon-plus") }), this.messages.add) : null; J = J ? g.tsx("ul", { class: "esri-attachments__items" }, E.toArray().map(K => this.renderAttachmentInfo({ attachmentInfo: K, displayType: B }))) : g.tsx("div", { class: "esri-widget__content--empty" }, this.messages.noAttachments); return g.tsx("div", {
                key: "attachments-container",
                class: this.classes("esri-attachments__container", M)
              }, J, F)
            }; z._modeChanged = function () { this._set("error", null); this._set("selectedFile", null) }; z._handleFileInputChange = function (B) { B = (B = B.target) && B.files && B.files.item(0); this._set("selectedFile", B) }; z._submitDeleteAttachment = function (B, C) { B.preventDefault(); this.deleteAttachment(C) }; z._submitAddAttachment = function (B) { B.preventDefault(); this.addAttachment() }; z._submitUpdateAttachment = function (B) { B.preventDefault(); this.updateAttachment() }; z._startEditAttachment =
              function (B) { const { viewModel: C } = this; C.activeAttachmentInfo = B; C.mode = "edit" }; z._startAddAttachment = function () { this.viewModel.mode = "add" }; z._cancelForm = function (B) { B.preventDefault(); this.viewModel.mode = "view" }; z._getCSSTransform = function (B, C) { ({ orientationInfo: B } = B); return !this._supportsImageOrientation && C && B ? [B.rotation ? `rotate(${B.rotation}deg)` : "", B.mirrored ? "scaleX(-1)" : ""].join(" ") : "" }; a._createClass(A, [{
                key: "effectiveDisplayType", get: function () {
                  return "auto" === this.displayType ? this.viewModel.supportsResizeAttachments ?
                    "preview" : "list" : this.displayType
                }
              }]); return A
          }(d); w.__decorate([y.aliasOf("viewModel.abilities")], n.prototype, "abilities", void 0); w.__decorate([h.property()], n.prototype, "displayType", void 0); w.__decorate([h.property({ readOnly: !0 })], n.prototype, "effectiveDisplayType", null); w.__decorate([y.aliasOf("viewModel.graphic")], n.prototype, "graphic", void 0); w.__decorate([h.property({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], n.prototype, "label", void 0); w.__decorate([h.property(), m.messageBundle("esri/widgets/Attachments/t9n/Attachments")],
            n.prototype, "messages", void 0); w.__decorate([h.property(), m.messageBundle("esri/core/t9n/Units")], n.prototype, "messagesUnits", void 0); w.__decorate([h.property({ readOnly: !0 })], n.prototype, "selectedFile", void 0); w.__decorate([h.property({ readOnly: !0 })], n.prototype, "submitting", void 0); w.__decorate([h.property({ readOnly: !0 })], n.prototype, "error", void 0); w.__decorate([h.property({ type: f })], n.prototype, "viewModel", void 0); w.__decorate([h.property()], n.prototype, "visibleElements", void 0); w.__decorate([l.cast("visibleElements")],
              n.prototype, "castVisibleElements", null); return n = w.__decorate([b.subclass("esri.widgets.Attachments")], n)
        })
    }, "esri/core/unitFormatUtils": function () {
      define(["exports", "./mathUtils", "./string", "./unitUtils", "../intl/number"], function (a, w, c, q, u) {
        function y(l, h, b) { return l.units[h][b] } function n(l, h, b, d = 2, f = "abbr") { return `${u.formatNumber(h, { minimumFractionDigits: d, maximumFractionDigits: d })} ${y(l, b, f)}` } const p = ["B", "kB", "MB", "GB", "TB"]; a.formatAngleDegrees = function (l, h, b = 2) {
          l = q.convertUnit(l, h, "degrees");
          return u.formatNumber(l, { style: "unit", unitDisplay: "narrow", unit: "degree", maximumFractionDigits: b, minimumFractionDigits: b })
        }; a.formatDMS = function (l, h, b = 2) { l = q.convertUnit(l, h, "degrees"); h = l - Math.floor(l); l -= h; h *= 60; let d = h - Math.floor(h); h -= d; d *= 60; return `${l.toFixed()}\u00b0 ${h.toFixed()}' ${d.toFixed(b)}"` }; a.formatDecimal = n; a.formatFileSize = function (l, h) {
          let b = 0 === h ? 0 : Math.floor(Math.log(h) / Math.log(1024)); b = w.clamp(b, 0, p.length - 1); h = u.formatNumber(h / 1024 ** b, { maximumFractionDigits: 2 }); return c.replace(l.units.bytes[p[b]],
            { fileSize: h })
        }; a.formatImperialArea = function (l, h, b, d = 2, f = "abbr") { const t = q.preferredImperialAreaUnit(h, b); return n(l, q.convertUnit(h, b, t), t, d, f) }; a.formatImperialLength = function (l, h, b, d = 2, f = "abbr") { const t = q.preferredImperialLengthUnit(h, b); return n(l, q.convertUnit(h, b, t), t, d, f) }; a.formatImperialVerticalLength = function (l, h, b, d = 2, f = "abbr") { const t = q.preferredImperialVerticalLengthUnit(h, b); return n(l, q.convertUnit(h, b, t), t, d, f) }; a.formatMetricArea = function (l, h, b, d = 2, f = "abbr") {
          const t = q.preferredMetricAreaUnit(h,
            b); return n(l, q.convertUnit(h, b, t), t, d, f)
        }; a.formatMetricLength = function (l, h, b, d = 2, f = "abbr") { const t = q.preferredMetricLengthUnit(h, b); return n(l, q.convertUnit(h, b, t), t, d, f) }; a.formatMetricVerticalLength = function (l, h, b, d = 2, f = "abbr") { const t = q.preferredMetricVerticalLengthUnit(h, b); return n(l, q.convertUnit(h, b, t), t, d, f) }; a.unitName = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Attachments/AttachmentsViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Graphic ../../core/Collection ../../core/Error ../../core/HandleOwner ../../core/maybe ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ../../rest/query/support/AttachmentInfo ../../rest/support/AttachmentQuery ../Feature/support/featureUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = { editing: !1, operations: { add: !0, update: !0, delete: !0 } }, g = q.ofType(t); q = function (x) {
            function k(A) { var z = x.call(this, A) || this; z._getAttachmentsPromise = null; z._attachmentLayer = null; z.abilities = { ...e }; z.activeAttachmentInfo = null; z.attachmentInfos = new g; z.graphic = null; z.mode = "view"; z.handles.add([p.init(a._assertThisInitialized(z), "graphic", () => z._graphicChanged())]); return z } a._inheritsLoose(k, x); var r = k.prototype; r.destroy = function () {
            this.graphic = this._attachmentLayer =
              null
            }; r.castAbilities = function (A) { return { ...e, ...A } }; r.getAttachments = function () {
              var A = a._asyncToGenerator(function* () {
                const { _attachmentLayer: z, attachmentInfos: B } = this; if (!z || "function" !== typeof z.queryAttachments) throw new u("invalid-layer", "getAttachments(): A valid layer is required."); const C = this._getFeatureId(); var D = new v({ objectIds: [C], returnMetadata: !0 }); const E = []; this._getAttachmentsPromise = D = z.queryAttachments(D).then(H => H[C] || E).catch(() => E); this.notifyChange("state"); D = yield D; B.removeAll();
                D.length && B.addMany(D); this._getAttachmentsPromise = null; this.notifyChange("state"); return D
              }); return function () { return A.apply(this, arguments) }
            }(); r.addAttachment = function () {
              var A = a._asyncToGenerator(function* (z) {
                const { _attachmentLayer: B, attachmentInfos: C, graphic: D, abilities: E } = this; if (!z) throw new u("invalid-attachment", "addAttachment(): An attachment is required.", { attachment: z }); if (!E.operations.add) throw new u("invalid-abilities", "addAttachment(): add abilities are required."); if (!B || "function" !==
                  typeof B.addAttachment) throw new u("invalid-layer", "addAttachment(): A valid layer is required."); z = yield B.addAttachment(D, z).then(H => this._queryAttachment(H.objectId)); C.add(z); return z
              }); return function (z) { return A.apply(this, arguments) }
            }(); r.deleteAttachment = function () {
              var A = a._asyncToGenerator(function* (z) {
                const { _attachmentLayer: B, attachmentInfos: C, graphic: D, abilities: E } = this; if (!z) throw new u("invalid-attachment-info", "deleteAttachment(): An attachmentInfo is required.", { attachmentInfo: z });
                if (!E.operations.delete) throw new u("invalid-abilities", "deleteAttachment(): delete abilities are required."); if (!B || "function" !== typeof B.deleteAttachments) throw new u("invalid-layer", "deleteAttachment(): A valid layer is required."); const H = yield B.deleteAttachments(D, [z.id]).then(() => z); C.remove(H); return H
              }); return function (z) { return A.apply(this, arguments) }
            }(); r.updateAttachment = function () {
              var A = a._asyncToGenerator(function* (z, B = this.activeAttachmentInfo) {
                const { _attachmentLayer: C, attachmentInfos: D,
                  graphic: E, abilities: H } = this; if (!z) throw new u("invalid-attachment", "updateAttachment(): An attachment is required.", { attachment: z }); if (!B) throw new u("invalid-attachment-info", "updateAttachment(): An attachmentInfo is required.", { attachmentInfo: B }); if (!H.operations.update) throw new u("invalid-abilities", "updateAttachment(): Update abilities are required."); const J = D.findIndex(M => M === B); if (!C || "function" !== typeof C.updateAttachment) throw new u("invalid-layer", "updateAttachment(): A valid layer is required.");
                z = yield C.updateAttachment(E, B.id, z).then(M => this._queryAttachment(M.objectId)); D.splice(J, 1, z); return z
              }); return function (z) { return A.apply(this, arguments) }
            }(); r._queryAttachment = function () {
              var A = a._asyncToGenerator(function* (z) { if (!z) throw new u("invalid-attachment-id", "Could not query attachment."); const { _attachmentLayer: B } = this, C = this._getFeatureId(); z = new v({ objectIds: [C], attachmentsWhere: `AttachmentId=${z}`, returnMetadata: !0 }); return B.queryAttachments(z).then(D => D[C][0]) }); return function (z) {
                return A.apply(this,
                  arguments)
              }
            }(); r._getFeatureId = function () { const { _attachmentLayer: A, graphic: z } = this; if (!A || !z) return null; const { objectIdField: B } = A, { attributes: C } = z; return C && C[B] }; r._graphicChanged = function () { this.graphic && (this._setAttachmentLayer(), this.getAttachments().catch(() => { })) }; r._setAttachmentLayer = function () { var { graphic: A } = this; this._attachmentLayer = (A = m.getSourceLayer(A)) ? "scene" === A.type && n.isSome(A.associatedLayer) ? A.associatedLayer : A : null }; a._createClass(k, [{
              key: "state", get: function () {
                return this._getAttachmentsPromise ?
                  "loading" : this.graphic ? "ready" : "disabled"
              }
            }, { key: "supportsResizeAttachments", get: function () { return this.get("graphic.layer.capabilities.operations.supportsResizeAttachments") || !1 } }]); return k
          }(y.HandleOwner); w.__decorate([l.property()], q.prototype, "abilities", void 0); w.__decorate([d.cast("abilities")], q.prototype, "castAbilities", null); w.__decorate([l.property()], q.prototype, "activeAttachmentInfo", void 0); w.__decorate([l.property({ readOnly: !0, type: g })], q.prototype, "attachmentInfos", void 0); w.__decorate([l.property({ type: c })],
            q.prototype, "graphic", void 0); w.__decorate([l.property()], q.prototype, "mode", void 0); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "state", null); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "supportsResizeAttachments", null); return q = w.__decorate([f.subclass("esri.widgets.Attachments.AttachmentsViewModel")], q)
        })
    }, "esri/widgets/Feature/support/featureUtils": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../intl ../../../core/Logger ../../../core/maybe ../../../core/string ../../../intl/date ../../../intl/number ../../../layers/support/fieldUtils ../../../popup/support/FieldInfoFormat ../../../support/arcadeOnDemand".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d() { d = w._asyncToGenerator(function* (ea, ba) { return "function" === typeof ea ? ea.call(null, ba) : ea }); return d.apply(this, arguments) } function f(ea) { return ea ? S.test(ea) : !1 } function t(ea, ba) { if (!f(ba) || !ea) return null; const aa = ba.replace(S, "").toLowerCase(); let W; ea.some(U => U.name.toLowerCase() === aa ? (W = U, !0) : !1); return W } function v(ea, ba) { return (ba = m(ba, ea)) ? ba.name : ea } function m(ea, ba) { return ea && "function" === typeof ea.getField ? ea.getField(ba) : null } function e({ formattedAttributes: ea,
            template: ba, fieldInfoMap: aa }) { return `${y.replace(y.replace(ba, W => { { const U = aa.get(W.toLowerCase()); W = `{${U && U.fieldName || W}}` } return W }), ea).replace(I, "")}`.trim() } function g(ea, ba, aa = !1) { const W = ba[ea]; "string" === typeof W && (aa = (aa ? encodeURIComponent(W) : W).replace(R, "%27"), ba[ea] = aa) } function x(ea, ba = !1) { const aa = { ...ea }; Object.keys(aa).forEach(W => g(W, aa, ba)); return aa } function k(ea, ba) { return ea.replace(O, (aa, W, U) => (aa = m(ba, U)) ? `{${aa.name}}` : W) } function r(ea, ba, aa) {
              return (ea = k(ea, aa)) ? ea.replace(da,
                (W, U, X) => { U = `${U || X}`.trim(); return y.replace(W, x(ba, U && "{" !== U[0])) }) : ea
            } function A(ea, ba) {
              var aa = ba.fieldName, W = z(ba.fieldInfos, aa), U = null == W ? void 0 : W.clone(); W = ba.preventPlacesFormatting; ba = ba.layer; aa = m(ba, aa); if (U && "date" === (null == aa ? void 0 : aa.type)) {
                aa = U.format || new h; aa.dateFormat = aa.dateFormat || "short-date-short-time"; var X; if (!(X = "feature" === (null == ba ? void 0 : ba.type) && ba.datesInUnknownTimezone)) { if (X = !(null == ba || !ba.layer)) X = ba.layer, X = "map-image" === (null == X ? void 0 : X.type); X = X && ba.layer.datesInUnknownTimezone } aa.dateTimeFormatOptions =
                  X ? { timeZone: "UTC" } : null; U.format = aa
              } U = U && U.format; "string" !== typeof ea || !U || null != U.dateFormat || null == U.places && null == U.digitSeparator || (ba = Number(ea), isNaN(ba) || (ea = ba)); return "string" === typeof ea || null == ea || null == U ? D(ea) : W ? p.formatNumber(ea, { ...p.convertNumberFormatToIntlOptions(U), minimumFractionDigits: 0, maximumFractionDigits: 20 }) : U.format(ea)
            } function z(ea, ba) { if (ea && ea.length && ba) { var aa = ba.toLowerCase(), W = void 0; ea.some(U => U.fieldName && U.fieldName.toLowerCase() === aa ? (W = U, !0) : !1); return W } } function B({ fieldName: ea,
              graphic: ba, layer: aa }) { if (P(ea) || !aa || "function" !== typeof aa.getFeatureType) return null; const { typeIdField: W } = aa; return W && ea === W ? (ea = aa.getFeatureType(ba)) ? ea.name : null : null } function C({ fieldName: ea, value: ba, graphic: aa, layer: W }) { return P(ea) || !W || "function" !== typeof W.getFieldDomain ? null : (ea = W.getFieldDomain(ea, { feature: aa })) && "coded-value" === ea.type ? ea.getName(ba) : null } function D(ea) { return "string" === typeof ea ? ea.replace(Q, '\x3cbr class\x3d"esri-text-new-line" /\x3e') : ea } function E(ea) {
                const { value: ba,
                  fieldName: aa, fieldInfos: W, fieldInfoMap: U, layer: X, graphic: Z } = ea; return null == ba ? "" : (ea = C({ fieldName: aa, value: ba, graphic: Z, layer: X })) || (ea = B({ fieldName: aa, graphic: Z, layer: X })) ? ea : U.get(aa.toLowerCase()) ? A(ba, { fieldInfos: W, fieldName: aa, layer: X }) : (ea = X && X.fieldsIndex) && ea.isDateField(aa) ? n.formatDate(ba, fa) : D(ba)
              } function H(ea, ba) { return J.apply(this, arguments) } function J() {
                J = w._asyncToGenerator(function* (ea, ba) {
                  var aa, W; const { layer: U, graphic: X, outFields: Z, objectIds: ia, returnGeometry: la, spatialReference: ma } =
                    ea; ea = ia[0]; if ("number" !== typeof ea && "string" !== typeof ea) return G.warn("Could not query required fields for the specified feature. The feature's ID is invalid.", { layer: U, graphic: X, objectId: ea, requiredFields: Z }), null; if (null == (aa = U.capabilities) || null == (W = aa.operations) || !W.supportsQuery) return G.warn("The specified layer cannot be queried. The following fields will not be available.", { layer: U, graphic: X, requiredFields: Z, returnGeometry: la }), null; aa = U.createQuery(); aa.objectIds = ia; aa.outFields = null !=
                      Z && Z.length ? Z : [U.objectIdField]; aa.returnGeometry = !!la; aa.returnZ = !!la; aa.returnM = !!la; aa.outSpatialReference = ma; return (yield U.queryFeatures(aa, ba)).features[0]
                }); return J.apply(this, arguments)
              } function M(ea) { return F.apply(this, arguments) } function F() { F = w._asyncToGenerator(function* (ea) { var ba; if (null == (ba = ea.expressionInfos) || !ba.length) return !1; ba = yield b.loadArcade(); ({ arcadeUtils: { hasGeometryFunctions: ba } } = ba); return ba(ea) }); return F.apply(this, arguments) } function K() {
                K = w._asyncToGenerator(function* ({ graphic: ea,
                  popupTemplate: ba, layer: aa, spatialReference: W }, U) {
                    if (aa && ba && ("function" === typeof aa.load && (yield aa.load(U)), ea.attributes)) {
                      var X = ea.attributes[aa.objectIdField]; if (null != X) {
                        X = [X]; var Z = yield ba.getRequiredFields(aa.fieldsIndex), ia = l.featureHasFields(Z, ea); Z = ia ? [] : Z; ba = ba.returnGeometry || (yield M(ba)); if (!ia || ba) if (aa = yield H({ layer: aa, graphic: ea, outFields: Z, objectIds: X, returnGeometry: ba, spatialReference: W }, U)) aa.geometry && (ea.geometry = aa.geometry), aa.attributes && (ea.attributes = {
                          ...ea.attributes,
                          ...aa.attributes
                        })
                      }
                    }
                }); return K.apply(this, arguments)
              } function P(ea = "") { return ea ? -1 !== ea.indexOf("relationships/") : !1 } function L({ attributes: ea, graphic: ba, relatedInfo: aa }) { ea && ba && aa && Object.keys(ba.attributes).forEach(W => { var U = { layerId: aa.relation.id.toString(), fieldName: W }; ea[U ? `${"relationships/"}${U.layerId}/${U.fieldName}` : ""] = ba.attributes[W] }) } function N(ea, ba) {
              ea && ba && (ba.relatedFeatures && ba.relatedFeatures && ba.relatedFeatures.forEach(aa => L({ attributes: ea, graphic: aa, relatedInfo: ba })), ba.relatedStatsFeatures &&
                ba.relatedStatsFeatures && ba.relatedStatsFeatures.forEach(aa => L({ attributes: ea, graphic: aa, relatedInfo: ba })))
              } const G = q.getLogger("esri.widgets.Feature.support.featureUtils"), I = /href=(""|'')/gi, O = /(\{([^\{\r\n]+)\})/g, R = /'/g, S = /^\s*expression\//i, Q = /(\n)/gi, T = /[\u00A0-\u9999<>&]/gim, da = /href\s*=\s*(?:"([^"]+)"|'([^']+)')/gi, Y = /^(?:mailto:|tel:)/, fa = n.convertDateFormatToIntlOptions("short-date-short-time"), ha = ea => {
                if (!ea) return !1; ea = ea.toUpperCase(); return -1 < ea.indexOf("CURRENT_TIMESTAMP") || -1 < ea.indexOf("CURRENT_DATE") ||
                  -1 < ea.indexOf("CURRENT_TIME")
              }, ka = ({ layer: ea, method: ba, query: aa, definitionExpression: W }) => { var U, X; null != (U = ea.capabilities) && null != (X = U.query) && X.supportsCacheHint && "attachments" !== ba && (ea = u.isSome(aa.where) && aa.where, ba = u.isSome(aa.geometry) && aa.geometry, ha(W) || ha(ea) || "extent" === (null == ba ? void 0 : ba.type) || "tile" === aa.resultType || (aa.cacheHint = !0)) }; a.applyTextFormattingHTML = D; a.createfieldInfoMap = function (ea, ba) {
                const aa = new Map; ea && ea.forEach(W => {
                  const U = v(W.fieldName, ba); W.fieldName = U; aa.set(U.toLowerCase(),
                    W)
                }); return aa
              }; a.fixTokens = k; a.formatAttributes = function ({ fieldInfos: ea, attributes: ba, layer: aa, graphic: W, fieldInfoMap: U, relatedInfos: X }) { const Z = {}; null == X ? void 0 : X.forEach(ia => N(Z, ia)); Object.keys(ba).forEach(ia => { Z[ia] = E({ fieldName: ia, fieldInfos: ea, fieldInfoMap: U, layer: aa, value: ba[ia], graphic: W }) }); return Z }; a.formatEditInfo = function (ea, ba) {
                const { creatorField: aa, creationDateField: W, editorField: U, editDateField: X } = ea; if (ba) {
                  ea = ba[X]; if ("number" === typeof ea) return ba = ba[U], {
                    type: "edit", date: n.formatDate(ea,
                      fa), user: ba
                  }; ea = ba[W]; return "number" === typeof ea ? (ba = ba[aa], { type: "create", date: n.formatDate(ea, fa), user: ba }) : null
                }
              }; a.formatValueToFieldInfo = A; a.getAllFieldInfos = function (ea) { const ba = []; if (!ea) return ba; const { fieldInfos: aa, content: W } = ea; aa && ba.push(...aa); if (!W || !Array.isArray(W)) return ba; W.forEach(U => { "fields" === U.type && (U = U && U.fieldInfos) && ba.push(...U) }); return ba }; a.getFieldInfo = z; a.getFieldInfoLabel = function (ea, ba) {
                return (ba = t(ba, null == ea ? void 0 : ea.fieldName)) ? ba.title || null : ea ? ea.label ||
                  ea.fieldName : null
              }; a.getFixedFieldName = v; a.getFixedFieldNames = function (ea, ba) { return ea && ea.map(aa => v(aa, ba)) }; a.getSourceLayer = function (ea) { if (!u.isNone(ea)) return ea.get("sourceLayer") || ea.get("layer") }; a.graphicCallback = function (ea, ba) { return d.apply(this, arguments) }; a.htmlEntities = function (ea) { return ea.replace(T, ba => `&#${ba.charCodeAt(0)};`) }; a.isExpressionField = f; a.isRelatedField = P; a.preLayerQueryCallback = ({ query: ea, layer: ba, method: aa }) => { ka({ layer: ba, method: aa, query: ea, definitionExpression: `${ba.definitionExpression} ${ba.serviceDefinitionExpression}` }) };
          a.preRequestCallback = ({ queryPayload: ea, layer: ba, method: aa }) => { ka({ layer: ba, method: aa, query: ea, definitionExpression: `${ba.definitionExpression} ${ba.serviceDefinitionExpression}` }) }; a.queryUpdatedFeature = function (ea, ba) { return K.apply(this, arguments) }; a.shouldOpenInNewTab = function (ea = "") { if (ea) return !Y.test(ea.trim().toLowerCase()) }; a.substituteAttributes = e; a.substituteFieldsInLinksAndAttributes = function ({ attributes: ea, globalAttributes: ba, layer: aa, text: W, expressionAttributes: U, fieldInfoMap: X }) {
            return W ?
              e({ formattedAttributes: ba, template: r(W, { ...ba, ...U, ...ea }, aa), fieldInfoMap: X }) : ""
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/widgets/Attachments/support/attachmentUtils": function () {
      define(["exports", "../../../assets"], function (a, w) {
      a.getIconPath = function (c) {
        const q = w.getAssetUrl("esri/themes/base/images/files/"); return c ? "text/plain" === c ? `${q}text-32.svg` : "application/pdf" === c ? `${q}pdf-32.svg` : "text/csv" === c ? `${q}csv-32.svg` : "application/gpx+xml" === c ? `${q}gpx-32.svg` : "application/x-dwf" ===
          c ? `${q}cad-32.svg` : "application/postscript" === c || "application/json" === c || "text/xml" === c || "model/vrml" === c ? `${q}code-32.svg` : "application/x-zip-compressed" === c || "application/x-7z-compressed" === c || "application/x-gzip" === c || "application/x-tar" === c || "application/x-gtar" === c || "application/x-bzip2" === c || "application/gzip" === c || "application/x-compress" === c || "application/x-apple-diskimage" === c || "application/x-rar-compressed" === c || "application/zip" === c ? `${q}zip-32.svg` : -1 !== c.indexOf("image/") ? `${q}image-32.svg` :
            -1 !== c.indexOf("audio/") ? `${q}sound-32.svg` : -1 !== c.indexOf("video/") ? `${q}video-32.svg` : -1 !== c.indexOf("msexcel") || -1 !== c.indexOf("ms-excel") || -1 !== c.indexOf("spreadsheetml") ? `${q}excel-32.svg` : -1 !== c.indexOf("msword") || -1 !== c.indexOf("ms-word") || -1 !== c.indexOf("wordprocessingml") ? `${q}word-32.svg` : -1 !== c.indexOf("powerpoint") || -1 !== c.indexOf("presentationml") ? `${q}report-32.svg` : `${q}generic-32.svg` : `${q}generic-32.svg`
      }; a.isSupportedImage = function (c) {
        c = c.toLowerCase(); return "image/bmp" === c || "image/emf" ===
          c || "image/exif" === c || "image/gif" === c || "image/x-icon" === c || "image/jpeg" === c || "image/png" === c || "image/tiff" === c || "image/x-wmf" === c
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Feature/FeatureAttachments/FeatureAttachmentsViewModel": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../Attachments/AttachmentsViewModel".split(" "),
        function (a, w, c, q, u, y, n, p) { q = function (l) { function h(b) { b = l.call(this, b) || this; b.description = null; b.title = null; return b } a._inheritsLoose(h, l); return h }(p); w.__decorate([c.property()], q.prototype, "description", void 0); w.__decorate([c.property()], q.prototype, "title", void 0); return q = w.__decorate([n.subclass("esri.widgets.Feature.FeatureAttachments.FeatureAttachmentsViewModel")], q) })
    }, "esri/widgets/Feature/support/FeatureElementInfo": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../Widget ../../support/Heading ../../support/widgetUtils ../../../core/Logger ../../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          q = function (f) {
            function t(m, e) { m = f.call(this, m, e) || this; m.description = null; m.headingLevel = 2; m.title = null; return m } a._inheritsLoose(t, f); var v = t.prototype; v.render = function () { return d.tsx("div", { class: "esri-feature-element-info" }, this.renderTitle(), this.renderDescription()) }; v.renderTitle = function () { const { title: m } = this; return m ? d.tsx(l.Heading, { level: this.headingLevel, class: "esri-feature-element-info__title" }, m) : null }; v.renderDescription = function () {
              const { description: m } =
                this; return m ? d.tsx("div", { key: "description", class: "esri-feature-element-info__description" }, m) : null
            }; return t
          }(p); w.__decorate([c.property()], q.prototype, "description", void 0); w.__decorate([c.property()], q.prototype, "headingLevel", void 0); w.__decorate([c.property()], q.prototype, "title", void 0); return q = w.__decorate([n.subclass("esri.widgets.Feature.support.FeatureElementInfo")], q)
        })
    }, "esri/widgets/support/Heading": function () {
      define("exports ../../core/mathUtils ./widgetUtils ../../core/has ../../core/Logger ./jsxFactory".split(" "),
        function (a, w, c, q, u, y) { const n = { heading: "esri-widget__heading" }; a.CSS = n; a.Heading = function (p, l) { const h = `h${w.clamp(Math.ceil(p.level), 1, 6)}`; delete p.level; return y.tsx(h, { ...p, class: c.classes(n.heading, p.class) }, l) }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/widgets/Feature/FeatureContent": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/aliasOf ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/subclass ../Widget ./FeatureContent/FeatureContentViewModel ./support/featureUtils ../support/widget ../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          q = function (t) {
            function v(e, g) { e = t.call(this, e, g) || this; e.creator = null; e.graphic = null; e.viewModel = null; e._addTargetToAnchors = x => { Array.from(x.querySelectorAll("a")).forEach(k => { b.shouldOpenInNewTab(k.href) && !k.hasAttribute("target") && k.setAttribute("target", "_blank") }) }; return e } a._inheritsLoose(v, t); var m = v.prototype; m.renderLoading = function () { return f.tsx("div", { class: "esri-feature-content__loader-container", key: "loader" }, f.tsx("div", { class: "esri-feature-content__loader" })) };
            m.renderCreated = function () { var e; const g = null == (e = this.viewModel) ? void 0 : e.created; return g ? g instanceof HTMLElement ? f.tsx("div", { key: g, bind: g, afterCreate: this._attachToNode }) : d.isWidget(g) ? f.tsx("div", { key: g }, !g.destroyed && g.render()) : f.tsx("div", { key: g, innerHTML: g, afterCreate: this._addTargetToAnchors }) : null }; m.render = function () { var e; const g = null == (e = this.viewModel) ? void 0 : e.state; return f.tsx("div", { class: "esri-feature-content" }, "loading" === g ? this.renderLoading() : this.renderCreated()) }; m._attachToNode =
              function (e) { e.appendChild(this) }; return v
          }(l); w.__decorate([c.aliasOf("viewModel.creator")], q.prototype, "creator", void 0); w.__decorate([c.aliasOf("viewModel.graphic")], q.prototype, "graphic", void 0); w.__decorate([n.property({ type: h })], q.prototype, "viewModel", void 0); return q = w.__decorate([p.subclass("esri.widgets.Feature.FeatureContent")], q)
        })
    }, "esri/widgets/Feature/FeatureContent/FeatureContentViewModel": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/Accessor ../../../core/HandleOwner ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../support/featureUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          q = function (f) {
            function t(m) { var e = f.call(this, m) || this; e._loadingPromise = null; e.created = null; e.creator = null; e.destroyer = null; e.graphic = null; e.handles.add(y.init(a._assertThisInitialized(e), "creator", g => { e._destroyContent(); e._createContent(g) })); return e } a._inheritsLoose(t, f); var v = t.prototype; v.destroy = function () { this._destroyContent() }; v._destroyContent = function () {
              const { created: m, graphic: e, destroyer: g } = this; m && (d.graphicCallback(g, { graphic: e }).catch(() => null),
                this._set("created", null))
            }; v._createContent = function () { var m = a._asyncToGenerator(function* (e) { var { graphic: g } = this; this._loadingPromise = e = d.graphicCallback(e, { graphic: g }).catch(() => null); this.notifyChange("state"); g = yield e; e === this._loadingPromise && (this._loadingPromise = null, this.notifyChange("state"), this._set("created", g)) }); return function (e) { return m.apply(this, arguments) } }(); a._createClass(t, [{ key: "state", get: function () { return this._loadingPromise ? "loading" : "ready" } }]); return t
          }(u.HandleOwnerMixin(q));
          w.__decorate([n.property({ readOnly: !0 })], q.prototype, "created", void 0); w.__decorate([n.property()], q.prototype, "creator", void 0); w.__decorate([n.property()], q.prototype, "destroyer", void 0); w.__decorate([n.property({ type: c })], q.prototype, "graphic", void 0); w.__decorate([n.property({ readOnly: !0 })], q.prototype, "state", null); return q = w.__decorate([b.subclass("esri.widgets.Feature.FeatureContent.FeatureContentViewModel")], q)
        })
    }, "esri/widgets/Feature/FeatureExpression": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../Widget ./FeatureContent ./FeatureFields ./FeatureMedia ./FeatureExpression/FeatureExpressionViewModel ../support/widgetUtils ../../core/Logger ../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          u = function (e) {
            function g(k, r) { k = e.call(this, k, r) || this; k.viewModel = new f; return k } a._inheritsLoose(g, e); var x = g.prototype; x.initialize = function () { c.init(this, "viewModel.contentElementViewModel", () => this._setupExpressionWidget()) }; x.destroy = function () { var k; null == (k = this._contentWidget) ? void 0 : k.destroy(); this._contentWidget = null }; x.renderLoading = function () {
              return m.tsx("div", { key: "loading-container", class: "esri-feature__loading-container" }, m.tsx("span", {
                class: this.classes("esri-icon-loading-indicator esri-rotating",
                  "esri-feature__loading-spinner")
              }))
            }; x.render = function () { var k; const { state: r } = this.viewModel; return m.tsx("div", { class: "esri-feature-expression" }, "loading" === r ? this.renderLoading() : "disabled" === r ? null : null == (k = this._contentWidget) ? void 0 : k.render()) }; x._setupExpressionWidget = function () {
              var k; const { contentElementViewModel: r, contentElement: A } = this.viewModel, z = null == A ? void 0 : A.type; null == (k = this._contentWidget) ? void 0 : k.destroy(); this._contentWidget = null; this._contentWidget = r ? "fields" === z ? new b({ viewModel: r }) :
                "media" === z ? new d({ viewModel: r }) : "text" === z ? new h({ viewModel: r }) : null : null; this.scheduleRender()
            }; return g
          }(l); w.__decorate([q.property({ type: f })], u.prototype, "viewModel", void 0); return u = w.__decorate([p.subclass("esri.widgets.Feature.FeatureExpression")], u)
        })
    }, "esri/widgets/Feature/FeatureFields": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/watchUtils ../../core/accessorSupport/decorators/aliasOf ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/subclass ../Widget ./FeatureFields/FeatureFieldsViewModel ./support/FeatureElementInfo ../support/uriUtils ../support/widgetUtils ../support/decorators/messageBundle ../../core/Logger ../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          u = function (g) {
            function x(r, A) { r = g.call(this, r, A) || this; r._featureElementInfo = null; r.attributes = null; r.description = null; r.expressionInfos = null; r.fieldInfos = null; r.title = null; r.viewModel = new b; r.messages = null; r.messagesURIUtils = null; return r } a._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this._featureElementInfo = new d; c.init(this, ["viewModel.description", "viewModel.title"], () => this._setupFeatureElementInfo()) }; k.destroy = function () { this._featureElementInfo.destroy() };
            k.renderFieldInfo = function (r, A) {
              var { attributes: z } = this.viewModel; const B = r.fieldName, C = r.label || B; z = z ? null == z[B] ? "" : z[B] : ""; r = !(!r.format || !r.format.dateFormat); z = "number" !== typeof z || r ? f.autoLink(this.messagesURIUtils, z) : this._forceLTR(z); r = { ["esri-feature-fields__field-data--date"]: r }; return e.tsx("tr", { key: `fields-element-info-row-${B}-${A}` }, e.tsx("th", { key: `fields-element-info-row-header-${B}-${A}`, class: "esri-feature-fields__field-header", innerHTML: C }), e.tsx("td", {
                key: `fields-element-info-row-data-${B}-${A}`,
                class: this.classes("esri-feature-fields__field-data", r), innerHTML: z
              }))
            }; k.renderFields = function () { const { formattedFieldInfos: r } = this.viewModel; return null != r && r.length ? e.tsx("table", { class: "esri-widget__table", summary: this.messages.fieldsSummary }, e.tsx("tbody", null, r.map((A, z) => this.renderFieldInfo(A, z)))) : null }; k.render = function () { var r; return e.tsx("div", { class: "esri-feature-fields" }, null == (r = this._featureElementInfo) ? void 0 : r.render(), this.renderFields()) }; k._setupFeatureElementInfo = function () {
              const { description: r,
                title: A } = this; this._featureElementInfo.set({ description: r, title: A })
            }; k._forceLTR = function (r) { return `&lrm;${r}` }; return x
          }(h); w.__decorate([q.aliasOf("viewModel.attributes")], u.prototype, "attributes", void 0); w.__decorate([q.aliasOf("viewModel.description")], u.prototype, "description", void 0); w.__decorate([q.aliasOf("viewModel.expressionInfos")], u.prototype, "expressionInfos", void 0); w.__decorate([q.aliasOf("viewModel.fieldInfos")], u.prototype, "fieldInfos", void 0); w.__decorate([q.aliasOf("viewModel.title")],
            u.prototype, "title", void 0); w.__decorate([p.property({ type: b })], u.prototype, "viewModel", void 0); w.__decorate([p.property(), v.messageBundle("esri/widgets/Feature/t9n/Feature")], u.prototype, "messages", void 0); w.__decorate([p.property(), v.messageBundle("esri/widgets/support/t9n/uriUtils")], u.prototype, "messagesURIUtils", void 0); return u = w.__decorate([l.subclass("esri.widgets.Feature.FeatureFields")], u)
        })
    }, "esri/widgets/Feature/FeatureFields/FeatureFieldsViewModel": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../popup/ExpressionInfo ../../../popup/FieldInfo ../support/featureUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          c = function (d) { function f(t) { t = d.call(this, t) || this; t.attributes = null; t.expressionInfos = null; t.description = null; t.fieldInfos = null; t.title = null; return t } a._inheritsLoose(f, d); a._createClass(f, [{ key: "formattedFieldInfos", get: function () { const { expressionInfos: t, fieldInfos: v } = this, m = []; null == v ? void 0 : v.forEach(e => { if (!e.hasOwnProperty("visible") || e.visible) e = e.clone(), e.label = b.getFieldInfoLabel(e, t), m.push(e) }); return m } }]); return f }(c); w.__decorate([q.property()], c.prototype,
            "attributes", void 0); w.__decorate([q.property({ type: [l] })], c.prototype, "expressionInfos", void 0); w.__decorate([q.property()], c.prototype, "description", void 0); w.__decorate([q.property({ type: [h] })], c.prototype, "fieldInfos", void 0); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "formattedFieldInfos", null); w.__decorate([q.property()], c.prototype, "title", void 0); return c = w.__decorate([p.subclass("esri.widgets.Feature.FeatureFields.FeatureFieldsViewModel")], c)
        })
    }, "esri/widgets/support/uriUtils": function () {
      define(["exports",
        "../../core/string"], function (a, w) {
          function c(u) { let y = null; q.some(n => { n.pattern.test(u) && (y = n); return !!y }); return y } const q = [{ pattern: /^\s*(https?:\/\/([^\s]+))\s*$/i, target: "_blank", label: "{messages.view}" }, { pattern: /^\s*(tel:([^\s]+))\s*$/i, label: "{hierPart}" }, { pattern: /^\s*(mailto:([^\s]+))\s*$/i, label: "{hierPart}" }, { pattern: /^\s*(arcgis-appstudio-player:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "App Studio Player" }, {
            pattern: /^\s*(arcgis-collector:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}",
            appName: "Collector"
          }, { pattern: /^\s*(arcgis-explorer:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Explorer" }, { pattern: /^\s*(arcgis-navigator:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Navigator" }, { pattern: /^\s*(arcgis-survey123:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Survey123" }, { pattern: /^\s*(arcgis-trek2there:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Trek2There" }, {
            pattern: /^\s*(arcgis-workforce:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}",
            appName: "Workforce"
          }, { pattern: /^\s*(iform:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "iForm" }, { pattern: /^\s*(flow:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "FlowFinity" }, { pattern: /^\s*(lfmobile:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Laserfische" }, { pattern: /^\s*(mspbi:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Microsoft Power Bi" }]; a.autoLink = function (u, y) {
            if ("string" !== typeof y || !y) return y; const n = c(y); if (!n) return y; const p = y.match(n.pattern);
            u = w.replace(w.replace(n.label, { messages: u, hierPart: p && p[2] }), { appName: n.appName }); return y.replace(n.pattern, `<a${n.target ? ` target="${n.target}"` : ""} href="$1"${"_blank" === n.target ? ' rel\x3d"noreferrer"' : ""}>${u}</a>`)
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/widgets/Feature/FeatureMedia": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/events ../../core/watchUtils ../../core/accessorSupport/decorators/aliasOf ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/subclass ../Widget ./FeatureMedia/FeatureMediaViewModel ./support/FeatureElementInfo ./support/featureUtils ../support/chartUtils ../support/widgetUtils ../support/decorators/messageBundle ../../core/Logger ../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
          y = function (k) {
            function r(z, B) {
              var C = k.call(this, z, B) || this; C._refreshTimer = null; C._refreshIntervalInfo = null; C._featureElementInfo = null; C.attributes = null; C.activeMediaInfoIndex = null; C.description = null; C.fieldInfoMap = null; C.layer = null; C.mediaInfos = null; C.popupTemplate = null; C.relatedInfos = null; C.title = null; C.viewModel = new d; C.messages = null; C._getChartDependencies = function () {
                var D = a._asyncToGenerator(function* (E) {
                  const H = yield v.loadChartsModule(); var { viewModel: J } =
                    a._assertThisInitialized(C); J && ({ activeMediaInfo: J } = J, C._renderChart({ chartDiv: E, mediaInfo: J, chartsModule: H }))
                }); return function (E) { return D.apply(this, arguments) }
              }(); return C
            } a._inheritsLoose(r, k); var A = r.prototype; A.initialize = function () { this._featureElementInfo = new f; this.own(q.init(this, ["viewModel.activeMediaInfo", "viewModel.activeMediaInfoIndex"], () => this._setupMediaRefreshTimer()), q.init(this, ["viewModel.description", "viewModel.title"], () => this._setupFeatureElementInfo())) }; A.destroy = function () {
              this._clearMediaRefreshTimer();
              this._featureElementInfo.destroy()
            }; A.render = function () { var z; return x.tsx("div", { bind: this, class: "esri-feature-media", onkeyup: this._handleMediaKeyup }, null == (z = this._featureElementInfo) ? void 0 : z.render(), this.renderMedia()) }; A.renderMedia = function () { const { formattedMediaInfoCount: z } = this.viewModel; return z ? x.tsx("div", { key: "media-element-container", class: "esri-feature-media__container" }, this.renderMediaPageButton("previous"), this.renderMediaInfo(), this.renderMediaPageButton("next")) : null }; A.renderImageMediaInfo =
              function (z) { var { _refreshIntervalInfo: B } = this; const { activeMediaInfoIndex: C, formattedMediaInfoCount: D } = this.viewModel, { value: E, refreshInterval: H, altText: J, title: M, type: F } = z, { sourceURL: K, linkURL: P } = E; z = t.shouldOpenInNewTab(P) ? "_blank" : "_self"; const L = "_blank" === z ? "noreferrer" : ""; B = H ? B : null; B = x.tsx("img", { alt: J || M, key: `media-${F}-${C}-${D}-${B ? B.timestamp : 0}`, src: B ? B.sourceURL : K }); return (z = P ? x.tsx("a", { title: M, href: P, rel: L, target: z }, B) : null) ? z : B }; A.renderChartMediaInfo = function (z) {
                const { activeMediaInfoIndex: B,
                  formattedMediaInfoCount: C } = this.viewModel; return x.tsx("div", { key: `media-${z.type}-${B}-${C}`, bind: this, class: "esri-feature-media__chart", afterCreate: this._getChartDependencies })
              }; A.renderMediaInfoType = function () { const { activeMediaInfo: z } = this.viewModel; return z ? "image" === z.type ? this.renderImageMediaInfo(z) : -1 !== z.type.indexOf("chart") ? this.renderChartMediaInfo(z) : null : null }; A.renderMediaInfo = function () {
                var { activeMediaInfo: z } = this.viewModel; if (!z) return null; const B = z.title ? x.tsx("div", {
                  key: "media-title",
                  class: "esri-feature-media__item-title", innerHTML: z.title
                }) : null; z = z.caption ? x.tsx("div", { key: "media-caption", class: "esri-feature-media__item-caption", innerHTML: z.caption }) : null; return x.tsx("div", { key: "media-container", class: "esri-feature-media__item-container" }, x.tsx("div", { key: "media-item-container", class: "esri-feature-media__item" }, this.renderMediaInfoType()), B, z)
              }; A.renderMediaPageButton = function (z) {
                if (2 > this.viewModel.formattedMediaInfoCount) return null; const B = (z = "previous" === z) ? this.messages.previous :
                  this.messages.next, C = z ? this.classes("esri-feature-media__button", "esri-feature-media__previous") : this.classes("esri-feature-media__button", "esri-feature-media__next"), D = z ? this.classes("esri-feature-media__icon", "esri-feature-media__previous-icon", "esri-icon-left-triangle-arrow") : this.classes("esri-feature-media__icon", "esri-feature-media__next-icon", "esri-icon-right-triangle-arrow"), E = z ? this.classes("esri-feature-media__icon", "esri-feature-media__previous-icon--rtl", "esri-icon-right-triangle-arrow") :
                    this.classes("esri-feature-media__icon", "esri-feature-media__next-icon--rtl", "esri-icon-left-triangle-arrow"); return x.tsx("button", { type: "button", key: z ? "media-previous" : "media-next", title: B, "aria-label": B, tabIndex: 0, class: C, bind: this, onclick: z ? this._previous : this._next }, x.tsx("span", { "aria-hidden": "true", class: D }), x.tsx("span", { "aria-hidden": "true", class: E }))
              }; A._setupFeatureElementInfo = function () { const { description: z, title: B } = this; this._featureElementInfo.set({ description: z, title: B }) }; A._next = function () { this.viewModel.next() };
            A._previous = function () { this.viewModel.previous() }; A._handleMediaKeyup = function (z) { const B = c.eventKey(z); "ArrowLeft" === B && (z.stopPropagation(), this.viewModel.previous()); "ArrowRight" === B && (z.stopPropagation(), this.viewModel.next()) }; A._renderChart = function (z) {
              const { chartsModule: B, chartDiv: C, mediaInfo: D } = z, { value: E, type: H } = D, { am4core: J } = B, M = v.getColorSet(J); m.isDarkTheme() && J.useTheme(B.am4themes_dark); J.useTheme(B.am4themes_animated); J.useTheme(function (F) { F instanceof J.ColorSet && M && (F.list = M) });
              z = "pie-chart" === H ? this._createPieChart(z) : this._createXYChart(z); C.setAttribute("aria-label", D.altText || D.title); z.data = E.series.map(F => ({ tooltip: F.tooltip, value: F.value })).filter(F => "pie-chart" === H ? 0 < F.value : !0)
            }; A._customizeChartTooltip = function (z, B) { z.label.wrap = !0; z.label.maxWidth = 200; z.autoTextColor = !1; z.getFillFromObject = !1; z.label.fill = B.color("#ffffff"); z.background.fill = B.color({ r: 0, g: 0, b: 0, a: .7 }) }; A._createPieChart = function (z) {
              const { chartDiv: B, chartsModule: C } = z, { am4core: D, am4charts: E } =
                C; z = D.create(B, E.PieChart); z.rtl = m.isRTL(this.container); const H = z.series.push(new E.PieSeries); H.labels.template.disabled = !0; H.ticks.template.disabled = !0; H.dataFields.value = "value"; H.dataFields.category = "tooltip"; this._customizeChartTooltip(H.tooltip, D); return z
            }; A._getMinSeriesValue = function (z) { let B = 0; z.forEach(C => B = Math.min(C.value, B)); return B }; A._createColumnChart = function (z, B) {
              const { chartsModule: C, mediaInfo: D } = B; ({ value: B } = D); const { am4core: E, am4charts: H } = C, J = z.xAxes.push(new H.CategoryAxis);
              J.dataFields.category = "tooltip"; J.renderer.labels.template.disabled = !0; this._customizeChartTooltip(J.tooltip, E); J.tooltip.events.on("sizechanged", () => { J.tooltip.dy = -J.tooltip.contentHeight }); var M = z.yAxes.push(new H.ValueAxis); const F = M.renderer.labels.template; M.renderer.minLabelPosition = .05; M.renderer.maxLabelPosition = .95; M.min = this._getMinSeriesValue(B.series); this._customizeChartTooltip(M.tooltip, E); F.wrap = !0; M = z.series.push(new H.ColumnSeries); M.dataFields.valueY = "value"; M.dataFields.categoryX =
                "tooltip"; z.cursor = new H.XYCursor; 15 < B.series.length && (z.scrollbarX = new E.Scrollbar)
            }; A._createBarChart = function (z, B) {
              const { chartsModule: C, mediaInfo: D } = B; ({ value: B } = D); const { am4core: E, am4charts: H } = C, J = z.yAxes.push(new H.CategoryAxis); J.dataFields.category = "tooltip"; J.renderer.inversed = !0; J.renderer.labels.template.disabled = !0; this._customizeChartTooltip(J.tooltip, E); J.tooltip.events.on("sizechanged", () => { J.tooltip.dx = J.tooltip.contentWidth }); var M = z.xAxes.push(new H.ValueAxis); const F = M.renderer.labels.template;
              M.renderer.minLabelPosition = .05; M.renderer.maxLabelPosition = .95; M.min = this._getMinSeriesValue(B.series); this._customizeChartTooltip(M.tooltip, E); F.wrap = !0; M = z.series.push(new H.ColumnSeries); M.dataFields.valueX = "value"; M.dataFields.categoryY = "tooltip"; z.cursor = new H.XYCursor; 15 < B.series.length && (z.scrollbarY = new E.Scrollbar)
            }; A._createLineChart = function (z, B) {
              const { chartsModule: C, mediaInfo: D } = B; ({ value: B } = D); const { am4core: E, am4charts: H } = C, J = z.xAxes.push(new H.CategoryAxis); J.dataFields.category =
                "tooltip"; J.renderer.labels.template.disabled = !0; this._customizeChartTooltip(J.tooltip, E); J.tooltip.events.on("sizechanged", () => { J.tooltip.dy = -J.tooltip.contentHeight }); var M = z.yAxes.push(new H.ValueAxis); const F = M.renderer.labels.template; M.renderer.minLabelPosition = .05; M.renderer.maxLabelPosition = .95; M.min = this._getMinSeriesValue(B.series); this._customizeChartTooltip(M.tooltip, E); F.wrap = !0; M = z.series.push(new H.LineSeries); M.dataFields.categoryX = "tooltip"; M.dataFields.valueY = "value"; z.cursor = new H.XYCursor;
              15 < B.series.length && (z.scrollbarX = new E.Scrollbar)
            }; A._createXYChart = function (z) { const { chartDiv: B, chartsModule: C, mediaInfo: D } = z, { type: E } = D, { am4core: H, am4charts: J } = C, M = H.create(B, J.XYChart); M.rtl = m.isRTL(this.container); "column-chart" === E && this._createColumnChart(M, z); "bar-chart" === E && this._createBarChart(M, z); "line-chart" === E && this._createLineChart(M, z); return M }; A._clearMediaRefreshTimer = function () { const { _refreshTimer: z } = this; z && (clearTimeout(z), this._refreshTimer = null) }; A._updateMediaInfoTimestamp =
              function (z) { const B = Date.now(); this._refreshIntervalInfo = { timestamp: B, sourceURL: this._getImageSource(z, B) }; this.scheduleRender() }; A._setupMediaRefreshTimer = function () { this._clearMediaRefreshTimer(); const { activeMediaInfo: z } = this.viewModel; z && "image" === z.type && z.refreshInterval && this._setRefreshTimeout(z) }; A._setRefreshTimeout = function (z) {
                const { refreshInterval: B, value: C } = z; B && (z = 6E4 * B, this._updateMediaInfoTimestamp(C.sourceURL), this._refreshTimer = setInterval(() => { this._updateMediaInfoTimestamp(C.sourceURL) },
                  z))
              }; A._getImageSource = function (z, B) { const C = -1 !== z.indexOf("?") ? "\x26" : "?", [D, E = ""] = z.split("#"); return `${D}${C}timestamp=${B}${E ? "#" : ""}${E}` }; return r
          }(b); w.__decorate([u.aliasOf("viewModel.attributes")], y.prototype, "attributes", void 0); w.__decorate([u.aliasOf("viewModel.activeMediaInfoIndex")], y.prototype, "activeMediaInfoIndex", void 0); w.__decorate([u.aliasOf("viewModel.description")], y.prototype, "description", void 0); w.__decorate([u.aliasOf("viewModel.fieldInfoMap")], y.prototype, "fieldInfoMap",
            void 0); w.__decorate([u.aliasOf("viewModel.layer")], y.prototype, "layer", void 0); w.__decorate([u.aliasOf("viewModel.mediaInfos")], y.prototype, "mediaInfos", void 0); w.__decorate([u.aliasOf("viewModel.popupTemplate")], y.prototype, "popupTemplate", void 0); w.__decorate([u.aliasOf("viewModel.relatedInfos")], y.prototype, "relatedInfos", void 0); w.__decorate([u.aliasOf("viewModel.title")], y.prototype, "title", void 0); w.__decorate([l.property({ type: d })], y.prototype, "viewModel", void 0); w.__decorate([l.property(),
            e.messageBundle("esri/widgets/Feature/t9n/Feature")], y.prototype, "messages", void 0); return y = w.__decorate([h.subclass("esri.widgets.Feature.FeatureMedia")], y)
        })
    }, "esri/widgets/Feature/FeatureMedia/FeatureMediaViewModel": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../popup/FieldInfo ../../../popup/content/support/ChartMediaInfoValueSeries ../support/featureUtils ../support/relatedFeatureUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          c = function (f) {
            function t(m) { m = f.call(this, m) || this; m.activeMediaInfoIndex = 0; m.attributes = null; m.description = null; m.fieldInfoMap = null; m.formattedAttributes = null; m.expressionAttributes = null; m.layer = null; m.mediaInfos = null; m.popupTemplate = null; m.relatedInfos = null; m.title = null; return m } a._inheritsLoose(t, f); var v = t.prototype; v.setActiveMedia = function (m) { this._setContentElementMedia(m) }; v.next = function () { this._pageContentElementMedia(1) }; v.previous = function () { this._pageContentElementMedia(-1) };
            v._setContentElementMedia = function (m) { const { formattedMediaInfoCount: e } = this; this.activeMediaInfoIndex = (m + e) % e }; v._pageContentElementMedia = function (m) { const { activeMediaInfoIndex: e } = this; this._setContentElementMedia(e + m) }; v._formatMediaInfos = function () {
              const { attributes: m, mediaInfos: e, formattedAttributes: g, expressionAttributes: x, fieldInfoMap: k, layer: r } = this; return null == e ? void 0 : e.map(A => {
                A = null == A ? void 0 : A.clone(); if (!A) return null; A.title = b.substituteFieldsInLinksAndAttributes({
                  attributes: m, fieldInfoMap: k,
                  globalAttributes: g, expressionAttributes: x, layer: r, text: A.title
                }); A.caption = b.substituteFieldsInLinksAndAttributes({ attributes: m, fieldInfoMap: k, globalAttributes: g, expressionAttributes: x, layer: r, text: A.caption }); A.altText = b.substituteFieldsInLinksAndAttributes({ attributes: m, fieldInfoMap: k, globalAttributes: g, expressionAttributes: x, layer: r, text: A.altText }); if ("image" === A.type) { var { value: z } = A; this._setImageValue({ value: z, formattedAttributes: g, layer: r }); return A.value.sourceURL ? A : void 0 } return "pie-chart" ===
                  A.type || "line-chart" === A.type || "column-chart" === A.type || "bar-chart" === A.type ? ({ value: z } = A, this._setChartValue({ value: z, chartType: A.type, attributes: m, formattedAttributes: g, layer: r }), A) : null
              }).filter(Boolean)
            }; v._setImageValue = function (m) {
              const { fieldInfoMap: e } = this, { value: g, formattedAttributes: x, layer: k } = m, { linkURL: r, sourceURL: A } = g; A && (m = b.fixTokens(A, k), g.sourceURL = b.substituteAttributes({ formattedAttributes: x, template: m, fieldInfoMap: e })); r && (m = b.fixTokens(r, k), g.linkURL = b.substituteAttributes({
                formattedAttributes: x,
                template: m, fieldInfoMap: e
              }))
            }; v._setChartValue = function (m) {
              const { value: e, attributes: g, formattedAttributes: x, chartType: k, layer: r } = m, { popupTemplate: A, relatedInfos: z } = this, { fields: B, normalizeField: C } = e; e.fields = b.getFixedFieldNames(B, r); C && (e.normalizeField = b.getFixedFieldName(C, r)); if (B.some(E => !!(null != x[E] || b.isRelatedField(E) && z.size))) {
                var D = null == A ? void 0 : A.fieldInfos; B.forEach(E => {
                  b.isRelatedField(E) ? e.series = [...e.series, ...this._getRelatedChartInfos({
                    fieldInfos: D, fieldName: E, formattedAttributes: x,
                    chartType: k, value: e
                  })] : (E = this._getChartOption({ value: e, attributes: g, chartType: k, formattedAttributes: x, fieldName: E, fieldInfos: D }), e.series.push(E))
                })
              }
            }; v._getRelatedChartInfos = function (m) {
              var e; const { fieldInfos: g, fieldName: x, formattedAttributes: k, chartType: r, value: A } = m, z = []; m = d.getRelatedFieldInfo(x); const { layerId: B, fieldName: C } = m; m = null == (e = this.relatedInfos) ? void 0 : e.get(B.toString()); if (!m) return z; const { relatedFeatures: D, relation: E } = m; if (!E || !D) return z; ({ cardinality: e } = E); D.forEach(H => {
                const { attributes: J } =
                  H; J && Object.keys(J).forEach(M => { M === C && z.push(this._getChartOption({ value: A, attributes: J, formattedAttributes: k, fieldName: x, chartType: r, relatedFieldName: M, fieldInfos: g })) })
              }); return "one-to-many" === e || "many-to-many" === e ? z : [z[0]]
            }; v._getTooltip = function ({ label: m, value: e, chartType: g }) { return "pie-chart" === g ? m : `${m}: ${e}` }; v._getChartOption = function (m) {
              const { value: e, attributes: g, formattedAttributes: x, fieldName: k, relatedFieldName: r, fieldInfos: A, chartType: z } = m; var { layer: B } = this; const { normalizeField: C,
                tooltipField: D } = e; var E = C ? b.isRelatedField(C) ? g[d.getRelatedFieldInfo(C).fieldName] : g[C] : null; m = r && void 0 !== g[r] ? g[r] : void 0 !== g[k] ? g[k] : x[k]; const H = void 0 === m ? null : m && E ? m / E : m; m = new h({ value: H }); if (b.isRelatedField(k)) {
                  var J = d.getRelatedFieldInfo(k); var M = d.getRelatedFieldInfo(D); M = M ? M.fieldName : null; B = b.formatValueToFieldInfo(H, { fieldInfos: A, fieldName: r, layer: B, preventPlacesFormatting: !!E }); J = J ? J.label || J.fieldName : r; m.tooltip = this._getTooltip({ label: M && void 0 !== g[M] ? g[M] : J, value: B, chartType: z });
                  return m
                } E = b.getFieldInfo(A, k); B = b.getFixedFieldName(k, B); E = D && void 0 !== x[D] ? x[D] : b.getFieldInfoLabel(E || new l({ fieldName: B }), null == (J = this.popupTemplate) ? void 0 : J.expressionInfos); m.tooltip = this._getTooltip({ label: E, value: x[B], chartType: z }); return m
            }; a._createClass(t, [{ key: "activeMediaInfo", get: function () { return this.formattedMediaInfos[this.activeMediaInfoIndex] || null } }, { key: "formattedMediaInfos", get: function () { return this._formatMediaInfos() || [] } }, { key: "formattedMediaInfoCount", get: function () { return this.formattedMediaInfos.length } }]);
            return t
          }(c); w.__decorate([q.property()], c.prototype, "activeMediaInfoIndex", void 0); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "activeMediaInfo", null); w.__decorate([q.property()], c.prototype, "attributes", void 0); w.__decorate([q.property()], c.prototype, "description", void 0); w.__decorate([q.property()], c.prototype, "fieldInfoMap", void 0); w.__decorate([q.property()], c.prototype, "formattedAttributes", void 0); w.__decorate([q.property()], c.prototype, "expressionAttributes", void 0); w.__decorate([q.property({ readOnly: !0 })],
            c.prototype, "formattedMediaInfos", null); w.__decorate([q.property()], c.prototype, "layer", void 0); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "formattedMediaInfoCount", null); w.__decorate([q.property()], c.prototype, "mediaInfos", void 0); w.__decorate([q.property()], c.prototype, "popupTemplate", void 0); w.__decorate([q.property()], c.prototype, "relatedInfos", void 0); w.__decorate([q.property()], c.prototype, "title", void 0); return c = w.__decorate([p.subclass("esri.widgets.Feature.FeatureMedia.FeatureMediaViewModel")],
              c)
        })
    }, "esri/widgets/Feature/support/relatedFeatureUtils": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../request ../../../core/Error ../../../core/Logger ../../../core/promiseUtils ../../../layers/support/fieldUtils ../../../rest/support/Query ../../../rest/support/RelationshipQuery ../../../rest/support/StatisticDefinition ../../../tasks/QueryTask ./featureUtils".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d) {
        function f(z, B) {
          if (!B.relationships) return null; let C = null;
          ({ relationships: B } = B); B.some(D => D.id === parseInt(z, 10) ? (C = D, !0) : !1); return C
        } function t({ originRelationship: z, relationships: B, layerId: C }) { let D; B && B.some(E => { `${E.relatedTableId}` === C && E.id === z.id && (D = E); return !!D }); return D } function v(z, B) { B = B.toLowerCase(); for (const C in z) if (C.toLowerCase() === B) return z[C]; return null } function m(z, B, C, D) {
          const E = new l; E.outFields = ["*"]; E.relationshipId = "number" === typeof B.id ? B.id : parseInt(B.id, 10); E.objectIds = [z.attributes[C.objectIdField]]; return C.queryRelatedFeatures(E,
            D)
        } function e(z, B, C) { let D = 0; const E = []; for (; D < B.length;)E.push(`${z} IN (${B.slice(D, C + D)})`), D += C; return E.join(" OR ") } function g(z, B, C, D) { return x.apply(this, arguments) } function x() {
          x = w._asyncToGenerator(function* (z, B, C, D) {
            var E = C.layerId.toString(); const { layerInfo: H, queryTask: J, relation: M, relatedFields: F, outStatistics: K } = B; E = t({ originRelationship: M, relationships: H.relationships, layerId: E }); if (E.relationshipTableId && E.keyFieldInRelationshipTable) {
              C = (yield m(z, E, C, D))[z.attributes[C.objectIdField]];
              if (!C) return null; const P = C.features.map(L => L.attributes[H.objectIdField]); if (0 < (null == K ? void 0 : K.length) && H.supportsStatistics) return B = new p, B.where = e(H.objectIdField, P, 1E3), B.outFields = F, B.outStatistics = K, B = { features: Promise.resolve(C), statsFeatures: J.execute(B) }, y.eachAlways(B)
            } return (E = null == E ? void 0 : E.keyField) ? (C = n.isNumericField(k(H.fields, E)), z = v(z.attributes, M.keyField), E = C ? `${E}=${z}` : `${E}='${z}'`, z = J.execute(new p({ where: E, outFields: B.relatedFields }), D), B = B.outStatistics && 0 < B.outStatistics.length &&
              H.supportsStatistics ? J.execute(new p({ where: E, outFields: B.relatedFields, outStatistics: B.outStatistics }), D) : null, D = { features: z }, B && (D.statsFeatures = B), y.eachAlways(D)) : null
          }); return x.apply(this, arguments)
        } function k(z, B) { if (null != z) { B = B.toLowerCase(); for (const C of z) if (C && C.name.toLowerCase() === B) return C } return null } const r = u.getLogger("esri.widgets.Feature.support.relatedFeatureUtils"), A = new Map; a.createRelatedInfo = function (z, B) {
          if (z = f(z, B)) {
            var C = `${B.url}/${z.relatedTableId}`; B = new b({
              url: C,
              sourceSpatialReference: B.spatialReference
            }); return { url: C, queryTask: B, relation: z, relatedFields: [], outStatistics: [] }
          }
        }; a.getDestinationRelation = t; a.getRelatedFieldInfo = function (z) { if (!d.isRelatedField(z)) return null; const [B, C] = z.split("/").slice(1); return { layerId: B, fieldName: C } }; a.queryLayerInfos = function ({ relatedInfos: z, layer: B }, C) {
          const D = {}; z.forEach((E, H) => {
            ({ relation: E } = E); if (!E) throw H = new q("relation-required", "A relation is required on a layer to retrieve related records."), r.error(H), H; ({ relatedTableId: E } =
              E); if ("number" !== typeof E) throw H = new q("A related table ID is required on a layer to retrieve related records."), r.error(H), H; E = `${B.url}/${E}`; const J = A.get(E), M = J ? J : c(E, { query: { f: "json" }, signal: C && C.signal }); J || A.set(E, M); D[H] = M
          }); return y.eachAlways(D)
        }; a.queryRelatedFeatures = function ({ graphic: z, relatedInfos: B, layer: C }, D) { const E = {}; B.forEach((H, J) => { H.layerInfo && (E[J] = g(z, H, C, D)) }); return y.eachAlways(E) }; a.setRelatedFeatures = function (z, B) {
          if (B && z) {
            var { features: C, statsFeatures: D } = z; z = C && C.value;
            B.relatedFeatures = z ? z.features : []; z = D && D.value; B.relatedStatsFeatures = z ? z.features : []
          }
        }; a.updateRelatedInfo = function ({ relatedInfo: z, fieldName: B, fieldInfo: C }) { z.relatedFields.push(B); C.statisticType && (B = new h({ statisticType: C.statisticType, onStatisticField: B, outStatisticFieldName: B }), z.outStatistics.push(B)) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/support/chartUtils": function () {
      define("require exports ../../chunks/_rollupPluginBabelHelpers ../../intl ../../core/has ../../intl/locale".split(" "),
        function (a, w, c, q, u, y) {
          function n(f) { if (!f) return "en-us"; if (h.has(f.toLowerCase())) return f.toLowerCase(); { f = f.split("-")[0].toLowerCase(); let v = null; for (t of h.keys()) if (t.startsWith(f)) { v = t; break } var t = v } return t || "en-us" } function p() {
            p = c._asyncToGenerator(function* (f = y.getLocale()) {
              f = n(f); if (b && f === d) return b; b = (new Promise((t, v) => a(["../../chunks/index"], t, v))).then(t => t.index); d = f; try {
                const [t, v] = yield Promise.all([b, h.get(d)()]); d === f && (t.am4core.options.defaultLocale = v.default); t.am4core.options.suppressWarnings =
                  !0; t.am4core.options.autoDispose = !0
              } catch{ return d = b = null } return b
            }); return p.apply(this, arguments)
          } q = "#ffffff #858585 #ffbebe #ffebbe #ffebaf #ffffbe #e9ffbe #d3ffbe #beffe8 #bee8ff #bed2ff #e8beff #ffbee8 #ebebeb #707070 #ff7f7f #ffa77f #ffd37f #ffff73 #d1ff73 #a3ff73 #73ffdf #73dfff #73b2ff #df73ff #ff73df #d6d6d6 #5c5c5c #ff0000 #ff5500 #ffaa00 #ffff00 #aaff00 #55ff00 #00ffc5 #00c5ff #0070ff #c500ff #ff00c5 #c2c2c2 #474747 #e60000 #e64c00 #e69800 #e6e600 #98e600 #4ce600 #00e6a9 #00a9e6 #005ce6 #a900e6 #e600a9 #adadad #242424 #a80000 #a83800 #a87000 #a8a800 #70a800 #38a800 #00a884 #0084a8 #004da8 #8400a8 #a80084 #999999 #1a1a1a #730000 #732600 #734c00 #737300 #4c7300 #267300 #00734c #004c73 #002673 #4c0073 #73004".split(" ");
          var l = [{ name: "default", colors: [].concat(q.slice(30, 39), q.slice(28, 30).reverse()) }, { name: "cat-dark", colors: "#ed5151 #149ece #a7c636 #9e559c #fc921f #ffde3e #f789d8 #b7814a #3caf99 #6b6bd6 #b54779 #7f7f7f".split(" ") }, { name: "tropical-bliss", colors: "#fce138 #ff9399 #fcd27e #f1983c #a553b7 #b1a9d0 #6ecffc #4c81cd #fc6f84 #fc3e5a #6af689 #48885c".split(" ") }, { name: "desert-blooms", colors: "#102432 #144d59 #ffc730 #ed9310 #a64f1b #661510 #d9351a #b31515 #4a0932 #8c213f #18382e #2c6954".split(" ") }, {
            name: "under-the-sea",
            colors: "#bf9727 #607100 #00734c #704489 #01acca #024e76 #f09100 #ea311f #c6004b #7570b3 #666666 #333333".split(" ")
          }, { name: "vibrant-rainbow", colors: "#fffb00 #f5cb11 #9fd40c #46e39c #32b8a6 #7ff2fa #ac08cc #dd33ff #eb7200 #e8a784 #bf2e2e #6c7000".split(" ") }, { name: "ocean-bay", colors: "#191921 #11495c #78b1c2 #454f4b #8f8f82 #9be0c0 #87b051 #f7ec88 #ebdcc1 #dbb658 #c43541 #75351e".split(" ") }, { name: "prairie-summer", colors: "#332424 #751555 #d47013 #d68989 #211173 #82aad6 #7bfaeb #6ec9a8 #6b6408 #eada40 #ccc54a #1fc235".split(" ") },
          { name: "pastel-chalk", colors: "#fffd99 #f5e6a4 #c1d48c #b8e3d0 #a0b8b5 #cbf7fa #d791f2 #dfc1eb #f2b983 #e8c4b2 #bf8e8e #94995c".split(" ") }, { name: "seq-yellow-orange-red-bright", colors: "#910000 #b1260b #c0370f #e05919 #ef6a1d #ff7b22 #ffa143 #ffb454 #ffda74 #ffed85".split(" ") }, { name: "seq-reds-bright", colors: "#57453b #7b4238 #9f4036 #c23d33 #d7483c #ec5244 #f3696c #f9816c #ffc4ae #fff0dc".split(" ") }, { name: "seq-purples-bright", colors: "#4e465c #5a4a78 #695291 #775baa #8663c3 #946bdc #aa89e8 #c1a6f3 #d7c4ff #e6e1ff".split(" ") },
          { name: "seq-blues-bright", colors: "#404d54 #435c6c #48799d #4b88b6 #4d96ce #50a5e7 #74bbed #98d0f3 #bce6f9 #e6faff".split(" ") }, { name: "seq-greens-bright", colors: "#39544c #386757 #368165 #359b73 #33b581 #4bc392 #64d2a2 #7ce0b3 #cbf6d9 #f4ffea".split(" ") }, { name: "seq-browns-bright", colors: "#524834 #715b38 #8f6e3c #ae8140 #cc9444 #eba748 #eeb664 #f0c47f #f9e0b7 #fff8eb".split(" ") }]; const h = new Map([["ar", () => (new Promise((f, t) => a(["../../chunks/ar2"], f, t))).then(f => f.ar)], ["bg-bg", () => (new Promise((f,
            t) => a(["../../chunks/bg_BG"], f, t))).then(f => f.bg_BG)], ["bs-ba", () => (new Promise((f, t) => a(["../../chunks/bs_BA"], f, t))).then(f => f.bs_BA)], ["ca-es", () => (new Promise((f, t) => a(["../../chunks/ca_ES"], f, t))).then(f => f.ca_ES)], ["cs-cz", () => (new Promise((f, t) => a(["../../chunks/cs_CZ"], f, t))).then(f => f.cs_CZ)], ["da-dk", () => (new Promise((f, t) => a(["../../chunks/da_DK"], f, t))).then(f => f.da_DK)], ["de-de", () => (new Promise((f, t) => a(["../../chunks/de_DE"], f, t))).then(f => f.de_DE)], ["de-ch", () => (new Promise((f, t) =>
              a(["../../chunks/de_CH"], f, t))).then(f => f.de_CH)], ["el-gr", () => (new Promise((f, t) => a(["../../chunks/el_GR"], f, t))).then(f => f.el_GR)], ["en-us", () => (new Promise((f, t) => a(["../../chunks/en_US"], f, t))).then(f => f.en_US)], ["en-ca", () => (new Promise((f, t) => a(["../../chunks/en_CA"], f, t))).then(f => f.en_CA)], ["es-es", () => (new Promise((f, t) => a(["../../chunks/es_ES"], f, t))).then(f => f.es_ES)], ["et-ee", () => (new Promise((f, t) => a(["../../chunks/et_EE"], f, t))).then(f => f.et_EE)], ["fi-fi", () => (new Promise((f, t) => a(["../../chunks/fi_FI"],
                f, t))).then(f => f.fi_FI)], ["fr-fr", () => (new Promise((f, t) => a(["../../chunks/fr_FR"], f, t))).then(f => f.fr_FR)], ["he-il", () => (new Promise((f, t) => a(["../../chunks/he_IL"], f, t))).then(f => f.he_IL)], ["hr-hr", () => (new Promise((f, t) => a(["../../chunks/hr_HR"], f, t))).then(f => f.hr_HR)], ["hu-hu", () => (new Promise((f, t) => a(["../../chunks/hu_HU"], f, t))).then(f => f.hu_HU)], ["id-id", () => (new Promise((f, t) => a(["../../chunks/id_ID"], f, t))).then(f => f.id_ID)], ["it-it", () => (new Promise((f, t) => a(["../../chunks/it_IT"], f, t))).then(f =>
                  f.it_IT)], ["ja-jp", () => (new Promise((f, t) => a(["../../chunks/ja_JP"], f, t))).then(f => f.ja_JP)], ["ko-kr", () => (new Promise((f, t) => a(["../../chunks/ko_KR"], f, t))).then(f => f.ko_KR)], ["lt-lt", () => (new Promise((f, t) => a(["../../chunks/lt_LT"], f, t))).then(f => f.lt_LT)], ["lv-lv", () => (new Promise((f, t) => a(["../../chunks/lv_LV"], f, t))).then(f => f.lv_LV)], ["nb-no", () => (new Promise((f, t) => a(["../../chunks/nb_NO"], f, t))).then(f => f.nb_NO)], ["nl-nl", () => (new Promise((f, t) => a(["../../chunks/nl_NL"], f, t))).then(f => f.nl_NL)],
          ["pl-pl", () => (new Promise((f, t) => a(["../../chunks/pl_PL"], f, t))).then(f => f.pl_PL)], ["pt-br", () => (new Promise((f, t) => a(["../../chunks/pt_BR"], f, t))).then(f => f.pt_BR)], ["pt-pt", () => (new Promise((f, t) => a(["../../chunks/pt_PT"], f, t))).then(f => f.pt_PT)], ["ro-ro", () => (new Promise((f, t) => a(["../../chunks/ro_RO"], f, t))).then(f => f.ro_RO)], ["ru-ru", () => (new Promise((f, t) => a(["../../chunks/ru_RU"], f, t))).then(f => f.ru_RU)], ["sk-sk", () => (new Promise((f, t) => a(["../../chunks/sk_SK"], f, t))).then(f => f.sk_SK)], ["sl-sl",
            () => (new Promise((f, t) => a(["../../chunks/sl_SL"], f, t))).then(f => f.sl_SL)], ["sr-rs", () => (new Promise((f, t) => a(["../../chunks/sr_RS"], f, t))).then(f => f.sr_RS)], ["sv-se", () => (new Promise((f, t) => a(["../../chunks/sv_SE"], f, t))).then(f => f.sv_SE)], ["th-th", () => (new Promise((f, t) => a(["../../chunks/th_TH"], f, t))).then(f => f.th_TH)], ["tr-tr", () => (new Promise((f, t) => a(["../../chunks/tr_TR"], f, t))).then(f => f.tr_TR)], ["uk-ua", () => (new Promise((f, t) => a(["../../chunks/uk_UA"], f, t))).then(f => f.uk_UA)], ["vi-vn", () =>
              (new Promise((f, t) => a(["../../chunks/vi_VN"], f, t))).then(f => f.vi_VN)], ["zh-cn", () => (new Promise((f, t) => a(["../../chunks/zh_Hans"], f, t))).then(f => f.zh_Hans)], ["zh-hk", () => (new Promise((f, t) => a(["../../chunks/zh_Hant"], f, t))).then(f => f.zh_Hant)], ["zh-tw", () => (new Promise((f, t) => a(["../../chunks/zh_Hant"], f, t))).then(f => f.zh_Hant)]]); let b, d; w.getChartLocale = n; w.getColorSet = function (f, t = "default") { const v = l.find(m => m.name === t); return v ? v.colors.map(m => f.color(m)) : null }; w.loadChartsModule = function () {
                return p.apply(this,
                  arguments)
              }; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/widgets/Feature/FeatureExpression/FeatureExpressionViewModel": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../chunks/languageUtils ../../../core/Accessor ../../../core/HandleOwner ../../../core/throttle ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../popup/content/AttachmentsContent ../../../popup/content/Content ../../../popup/content/CustomContent ../../../popup/content/ExpressionContent ../../../popup/content/FieldsContent ../../../popup/content/MediaContent ../../../popup/content/TextContent ../../../popup/ElementExpressionInfo ../FeatureContent/FeatureContentViewModel ../FeatureFields/FeatureFieldsViewModel ../FeatureMedia/FeatureMediaViewModel ../support/arcadeFeatureUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          u = function (D) {
            function E(H) {
              var J = D.call(this, H) || this; J._abortController = null; J.expressionInfo = null; J.graphic = null; J.contentElement = null; J.contentElementViewModel = null; J.interceptor = null; J.view = null; J._cancelQuery = () => { const { _abortController: M } = a._assertThisInitialized(J); M && M.abort(); J._abortController = null }; J._createVM = () => {
                var M, F; const K = null == (M = J.contentElement) ? void 0 : M.type; null == (F = J.contentElementViewModel) ? void 0 : F.destroy();
                M = "fields" === K ? new z : "media" === K ? new B : "text" === K ? new A : null; J._set("contentElementViewModel", M)
              }; J._compile = a._asyncToGenerator(function* () { J._cancelQuery(); const M = new AbortController; J._abortController = M; yield J._compileExpression(); J._abortController === M && (J._abortController = null) }); J._compileThrottled = n.throttle(J._compile, 1, a._assertThisInitialized(J)); J._compileExpression = a._asyncToGenerator(function* () {
                const { expressionInfo: M, graphic: F, interceptor: K, spatialReference: P, map: L, view: N, _abortController: G } =
                  a._assertThisInitialized(J); if (M && F && P && L && N) { var I = yield C.loadArcadeUtils(); if (G === J._abortController) if ((I = yield C.createCompiledExpression({ arcadeUtils: I, expressionInfo: M, graphic: F, interceptor: K, map: L, spatialReference: P, view: N })) && "esri.arcade.Dictionary" === I.declaredClass) { I = yield q.castAsJsonAsync(I, G.signal); var O = null == I ? void 0 : I.type; I = "media" === O ? x.fromJSON(I) : "text" === O ? k.fromJSON(I) : "fields" === O ? g.fromJSON(I) : null; J._set("contentElement", I) } else J._set("contentElement", null) } else J._set("contentElement",
                    null)
              }); J.handles.add([p.init(a._assertThisInitialized(J), ["expressionInfo", "graphic", "map", "spatialReference", "view"], J._compileThrottled), p.init(a._assertThisInitialized(J), "contentElement", J._createVM)]); return J
            } a._inheritsLoose(E, D); E.prototype.destroy = function () { var H; this._cancelQuery(); null == (H = this.contentElementViewModel) ? void 0 : H.destroy(); this._set("contentElementViewModel", null); this._set("contentElement", null) }; a._createClass(E, [{
              key: "spatialReference", get: function () {
                var H; return (null ==
                  (H = this.view) ? void 0 : H.spatialReference) || null
              }, set: function (H) { void 0 === H ? this._clearOverride("spatialReference") : this._override("spatialReference", H) }
            }, { key: "state", get: function () { const { _abortController: H, contentElement: J, contentElementViewModel: M } = this; return H ? "loading" : J || M ? "ready" : "disabled" } }, { key: "map", get: function () { var H; return (null == (H = this.view) ? void 0 : H.map) || null }, set: function (H) { void 0 === H ? this._clearOverride("map") : this._override("map", H) } }]); return E
          }(y.HandleOwnerMixin(u)); w.__decorate([l.property()],
            u.prototype, "_abortController", void 0); w.__decorate([l.property({ type: r })], u.prototype, "expressionInfo", void 0); w.__decorate([l.property({ type: c })], u.prototype, "graphic", void 0); w.__decorate([l.property({ readOnly: !0 })], u.prototype, "contentElement", void 0); w.__decorate([l.property({ readOnly: !0 })], u.prototype, "contentElementViewModel", void 0); w.__decorate([l.property()], u.prototype, "interceptor", void 0); w.__decorate([l.property()], u.prototype, "spatialReference", null); w.__decorate([l.property({ readOnly: !0 })],
              u.prototype, "state", null); w.__decorate([l.property()], u.prototype, "map", null); w.__decorate([l.property()], u.prototype, "view", void 0); return u = w.__decorate([f.subclass("esri.widgets.Feature.FeatureExpression.FeatureExpressionViewModel")], u)
        })
    }, "esri/chunks/languageUtils": function () {
      define("exports ../arcade/FunctionWrapper ../arcade/ImmutableArray ../arcade/ImmutablePathArray ../arcade/ImmutablePointArray ../core/promiseUtils ../geometry/Extent ../geometry/Geometry ../geometry/Multipoint ../geometry/Point ../geometry/Polygon ../geometry/Polyline ./datetime ../core/maybe ../core/number ../geometry/support/coordsUtils ../intl/locale".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          function g(na, xa, Qa) { return "" === xa || null === xa || void 0 === xa || xa === Qa || xa === Qa ? na : na = na.split(xa).join(Qa) } function x(na) { return na instanceof Ha || na instanceof w || na instanceof Oa } function k(na) { return A(na) || B(na) || M(na) || z(na) || null === na || na === Ca || "number" === typeof na ? !0 : !1 } function r(na, xa) { return void 0 === na ? xa : na } function A(na) { return "string" === typeof na || na instanceof String } function z(na) { return "boolean" === typeof na } function B(na) {
            return "number" ===
              typeof na
          } function C(na) { return "number" === typeof na && isFinite(na) && Math.floor(na) === na } function D(na) { return na instanceof Array } function E(na) { return !0 === (na && na.declaredRootClass && "esri.arcade.featureset.support.FeatureSet" === na.declaredRootClass) } function H(na) { return !0 === (na && na.declaredRootClass && "esri.arcade.featureSetCollection" === na.declaredRootClass) } function J(na) { return na instanceof c } function M(na) { return na instanceof Date } function F(na, xa, Qa) {
            if (na.length < xa || na.length > Qa) throw Error("Function called with wrong number of Parameters");
          } function K(na) { return 0 > na ? -Math.round(-na) : Math.round(na) } function P() { let na = (new Date).getTime(); return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (xa) { const Qa = (na + 16 * Math.random()) % 16 | 0; na = Math.floor(na / 16); return ("x" === xa ? Qa : Qa & 3 | 8).toString(16) }) } function L(na, xa) { if (!1 === isNaN(na)) { if (void 0 === xa || null === xa || "" === xa) return na.toString(); xa = g(xa, "\u2030", ""); xa = g(xa, "\u00a4", ""); return v.format(na, { pattern: xa }) } return na.toString() } function N(na, xa) {
            na = f.DateTime.fromJSDate(na);
            return void 0 === xa || null === xa || "" === xa ? na.toISO({ suppressMilliseconds: !0 }) : na.toFormat(G(xa), { locale: e.getLocale(), numberingSystem: "latn" })
          } function G(na) {
            na = na.replace(/LTS|LT|LL?L?L?|l{1,4}/g, "[$\x26]"); let xa = ""; const Qa = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g; for (const Wa of na.match(Qa)) switch (Wa) {
              case "D": xa += "d"; break; case "DD": xa +=
                "dd"; break; case "DDD": xa += "o"; break; case "d": xa += "c"; break; case "ddd": xa += "ccc"; break; case "dddd": xa += "cccc"; break; case "M": xa += "L"; break; case "MM": xa += "LL"; break; case "MMM": xa += "LLL"; break; case "MMMM": xa += "LLLL"; break; case "YY": xa += "yy"; break; case "Y": case "YYYY": xa += "yyyy"; break; case "Q": xa += "q"; break; case "Z": xa += "ZZ"; break; case "ZZ": xa += "ZZZ"; break; case "S": xa += "'S'"; break; case "SS": xa += "'SS'"; break; case "SSS": xa += "u"; break; case "A": case "a": xa += "a"; break; case "m": case "mm": case "h": case "hh": case "H": case "HH": case "s": case "ss": case "X": case "x": xa +=
                  Wa; break; default: xa = 2 <= Wa.length && "[" === Wa.slice(0, 1) && "]" === Wa.slice(-1) ? xa + `'${Wa.slice(1, -1)}'` : xa + `'${Wa}'`
            }return xa
          } function I(na, xa, Qa) { switch (Qa) { case "\x3e": return na > xa; case "\x3c": return na < xa; case "\x3e\x3d": return na >= xa; case "\x3c\x3d": return na <= xa }return !1 } function O(na, xa, Qa) {
            if (null === na) { if (null === xa || xa === Ca) return I(null, null, Qa); if (B(xa)) return I(0, xa, Qa); if (A(xa) || z(xa)) return I(0, Y(xa), Qa); if (M(xa)) return I(0, xa.getTime(), Qa) } if (na === Ca) {
              if (null === xa || xa === Ca) return I(null,
                null, Qa); if (B(xa)) return I(0, xa, Qa); if (A(xa) || z(xa)) return I(0, Y(xa), Qa); if (M(xa)) return I(0, xa.getTime(), Qa)
            } else if (B(na)) { if (B(xa)) return I(na, xa, Qa); if (z(xa)) return I(na, Y(xa), Qa); if (null === xa || xa === Ca) return I(na, 0, Qa); if (A(xa)) return I(na, Y(xa), Qa); if (M(xa)) return I(na, xa.getTime(), Qa) } else if (A(na)) { if (A(xa)) return I(S(na), S(xa), Qa); if (M(xa)) return I(Y(na), xa.getTime(), Qa); if (B(xa)) return I(Y(na), xa, Qa); if (null === xa || xa === Ca) return I(Y(na), 0, Qa); if (z(xa)) return I(Y(na), Y(xa), Qa) } else if (M(na)) {
              if (M(xa)) return I(na,
                xa, Qa); if (null === xa || xa === Ca) return I(na.getTime(), 0, Qa); if (B(xa)) return I(na.getTime(), xa, Qa); if (z(xa) || A(xa)) return I(na.getTime(), Y(xa), Qa)
            } else if (z(na)) { if (z(xa)) return I(na, xa, Qa); if (B(xa)) return I(Y(na), Y(xa), Qa); if (M(xa)) return I(Y(na), xa.getTime(), Qa); if (null === xa || xa === Ca) return I(Y(na), 0, Qa); if (A(xa)) return I(Y(na), Y(xa), Qa) } return !R(na, xa) || "\x3c\x3d" !== Qa && "\x3e\x3d" !== Qa ? !1 : !0
          } function R(na, xa) {
            if (na === xa || null === na && xa === Ca || null === xa && na === Ca) return !0; if (M(na) && M(xa)) return na.getTime() ===
              xa.getTime(); if (na instanceof q || na instanceof u) return na.equalityTest(xa); if (na instanceof h && xa instanceof h) { const Qa = na.cache._arcadeCacheId, Wa = xa.cache._arcadeCacheId; if (void 0 !== Qa && null !== Qa) return Qa === Wa } return void 0 !== na && void 0 !== xa && null !== na && null !== xa && "object" === typeof na && "object" === typeof xa && (na._arcadeCacheId === xa._arcadeCacheId && void 0 !== na._arcadeCacheId && null !== na._arcadeCacheId || na._underlyingGraphic === xa._underlyingGraphic && void 0 !== na._underlyingGraphic && null !== na._underlyingGraphic) ?
                !0 : !1
          } function S(na, xa) { if (A(na)) return na; if (null === na) return ""; if (B(na)) return L(na, xa); if (z(na)) return na.toString(); if (M(na)) return N(na, xa); if (na instanceof p) return JSON.stringify(na.toJSON()); if (D(na)) { xa = []; for (var Qa = 0; Qa < na.length; Qa++)xa[Qa] = da(na[Qa]); return "[" + xa.join(",") + "]" } if (na instanceof c) { xa = []; for (Qa = 0; Qa < na.length(); Qa++)xa[Qa] = da(na.get(Qa)); return "[" + xa.join(",") + "]" } return null !== na && "object" === typeof na && void 0 !== na.castToText ? na.castToText() : x(na) ? "object, Function" : "" }
          function Q(na) { const xa = []; if (!1 === D(na)) return null; if (na instanceof c) { for (var Qa = 0; Qa < na.length(); Qa++)xa[Qa] = Y(na.get(Qa)); return xa } for (Qa = 0; Qa < na.length; Qa++)xa[Qa] = Y(na[Qa]); return xa } function T(na, xa) {
            if (A(na)) return na; if (null === na) return ""; if (B(na)) return L(na, xa); if (z(na)) return na.toString(); if (M(na)) return N(na, xa); if (na instanceof p) return na instanceof n ? '{"xmin":' + na.xmin.toString() + ',"ymin":' + na.ymin.toString() + "," + (na.hasZ ? '"zmin":' + na.zmin.toString() + "," : "") + (na.hasM ? '"mmin":' +
              na.mmin.toString() + "," : "") + '"xmax":' + na.xmax.toString() + ',"ymax":' + na.ymax.toString() + "," + (na.hasZ ? '"zmax":' + na.zmax.toString() + "," : "") + (na.hasM ? '"mmax":' + na.mmax.toString() + "," : "") + '"spatialReference":' + ia(na.spatialReference) + "}" : ia(na.toJSON(), (Wa, Ra) => Wa.key === Ra.key ? 0 : "spatialReference" === Wa.key ? 1 : "spatialReference" === Ra.key || Wa.key < Ra.key ? -1 : Wa.key > Ra.key ? 1 : 0); if (D(na)) { xa = []; for (var Qa = 0; Qa < na.length; Qa++)xa[Qa] = da(na[Qa]); return "[" + xa.join(",") + "]" } if (na instanceof c) {
                xa = []; for (Qa = 0; Qa < na.length(); Qa++)xa[Qa] =
                  da(na.get(Qa)); return "[" + xa.join(",") + "]"
              } return null !== na && "object" === typeof na && void 0 !== na.castToText ? na.castToText() : x(na) ? "object, Function" : ""
          } function da(na) { return null === na ? "null" : z(na) || B(na) || A(na) ? JSON.stringify(na) : na instanceof p || na instanceof c || na instanceof Array ? T(na) : na instanceof Date ? JSON.stringify(N(na, "")) : null !== na && "object" === typeof na && void 0 !== na.castToText ? na.castToText() : "null" } function Y(na, xa) {
            return B(na) ? na : null === na || "" === na ? 0 : M(na) ? NaN : z(na) ? na ? 1 : 0 : D(na) || "" ===
              na || void 0 === na ? NaN : void 0 !== xa && A(na) ? (xa = g(xa, "\u2030", ""), xa = g(xa, "\u00a4", ""), v.parse(na, { pattern: xa })) : na === Ca ? 0 : Number(na)
          } function fa(na) { return M(na) ? na : A(na) && (na = ka(na)) ? na.toJSDate() : null } function ha(na) { return M(na) ? f.DateTime.fromJSDate(na) : A(na) ? ka(na) : null } function ka(na) { const xa = / (\d\d)/; let Qa = f.DateTime.fromISO(na); return Qa.isValid || xa.test(na) && (na = na.replace(xa, "T$1"), Qa = f.DateTime.fromISO(na), Qa.isValid) ? Qa : null } function ea(na) {
            return z(na) ? na : A(na) ? (na = na.toLowerCase(), "true" ===
              na ? !0 : !1) : B(na) ? 0 === na || isNaN(na) ? !1 : !0 : !1
          } function ba(na, xa) { if (t.isNone(na)) return null; if (null === na.spatialReference || void 0 === na.spatialReference) na.spatialReference = xa; return na } function aa(na) {
            if (null === na) return null; if (na instanceof h) return "NaN" === na.x || null === na.x || isNaN(na.x) ? null : na; if (na instanceof b) { if (0 === na.rings.length) return null; for (const xa of na.rings) if (0 < xa.length) return na; return null } if (na instanceof d) {
              if (0 === na.paths.length) return null; for (const xa of na.paths) if (0 < xa.length) return na;
              return null
            } return na instanceof l ? 0 === na.points.length ? null : na : na instanceof n ? "NaN" === na.xmin || null === na.xmin || isNaN(na.xmin) ? null : na : null
          } function W(na, xa) { if (!na || !na.domain) return xa; let Qa = null; if ("string" === na.field.type || "esriFieldTypeString" === na.field.type) xa = S(xa); else { if (null === xa || void 0 === xa) return null; if ("" === xa) return xa; xa = Y(xa) } for (let Wa = 0; Wa < na.domain.codedValues.length; Wa++) { const Ra = na.domain.codedValues[Wa]; Ra.code === xa && (Qa = Ra) } return null === Qa ? xa : Qa.name } function U(na, xa) {
            if (!na ||
              !na.domain) return xa; let Qa = null; xa = S(xa); for (let Wa = 0; Wa < na.domain.codedValues.length; Wa++) { const Ra = na.domain.codedValues[Wa]; Ra.name === xa && (Qa = Ra) } return null === Qa ? xa : Qa.code
          } function X(na, xa, Qa = null, Wa) {
            if (!xa || !xa.fields) return null; let Ra = null; for (let Sa = 0; Sa < xa.fields.length; Sa++) { const Va = xa.fields[Sa]; Va.name.toLowerCase() === na.toString().toLowerCase() && (Ra = Va) } if (null === Ra) throw Error("Field not found"); let ta, Fa; Wa || (Wa = Qa && xa.typeIdField && Qa._field(xa.typeIdField)); null != Wa && xa.types.some(function (Sa) {
              return Sa.id ===
                Wa ? ((ta = Sa.domains && Sa.domains[Ra.name]) && "inherited" === ta.type && (ta = Z(Ra.name, xa), Fa = !0), !0) : !1
            }); Fa || ta || (ta = Z(na, xa)); return { field: Ra, domain: ta }
          } function Z(na, xa) { let Qa; xa.fields.some(function (Wa) { Wa.name.toLowerCase() === na.toLowerCase() && (Qa = Wa.domain); return !!Qa }); return Qa } function ia(na, xa) {
            xa || (xa = {}); "function" === typeof xa && (xa = { cmp: xa }); const Qa = "boolean" === typeof xa.cycles ? xa.cycles : !1, Wa = xa.cmp && function (ta) {
              return function (Fa) {
                return function (Sa, Va) {
                  return ta({ key: Sa, value: Fa[Sa] }, {
                    key: Va,
                    value: Fa[Va]
                  })
                }
              }
            }(xa.cmp), Ra = []; return function Sa(Fa) {
            Fa && Fa.toJSON && "function" === typeof Fa.toJSON && (Fa = Fa.toJSON()); if (void 0 !== Fa) {
              if ("number" === typeof Fa) return isFinite(Fa) ? "" + Fa : "null"; if ("object" !== typeof Fa) return JSON.stringify(Fa); var Va; if (Array.isArray(Fa)) { var Ya = "["; for (Va = 0; Va < Fa.length; Va++)Va && (Ya += ","), Ya += Sa(Fa[Va]) || "null"; return Ya + "]" } if (null === Fa) return "null"; if (-1 !== Ra.indexOf(Fa)) {
                if (Qa) return JSON.stringify("__cycle__"); throw new TypeError("Converting circular structure to JSON");
              } var bb = Ra.push(Fa) - 1, hb = Object.keys(Fa).sort(Wa && Wa(Fa)); Ya = ""; for (Va = 0; Va < hb.length; Va++) { const ib = hb[Va], mb = Sa(Fa[ib]); mb && (Ya && (Ya += ","), Ya += JSON.stringify(ib) + ":" + mb) } Ra.splice(bb, 1); return "{" + Ya + "}"
            }
            }(na)
          } function la(na) { if (null === na) return null; const xa = []; for (const Qa of na) Qa && (Qa.declaredClass && "esri.arcade.Feature" === Qa.declaredClass || "FeatureSetReader" === Qa.type) ? xa.push(Qa.geometry()) : xa.push(Qa); return xa } function ma(na, xa) {
            if (xa instanceof h) na.push(xa.hasZ ? xa.hasM ? [xa.x, xa.y, xa.z,
            xa.m] : [xa.x, xa.y, xa.z] : [xa.x, xa.y]); else throw Error("Invalid Argument");
          } function ra(na, xa) {
            if (D(na) || J(na)) {
              let Qa = !1, Wa = !1, Ra = []; if (D(na)) { for (const ta of na) ma(Ra, ta); 0 < Ra.length && (xa = na[0].spatialReference, Qa = na[0].hasZ, Wa = na[0].hasM) } else if (na instanceof u) Ra = na._elements, 0 < Ra.length && (Qa = na._hasZ, Wa = na._hasM, xa = na.get(0).spatialReference); else if (J(na)) { for (const ta of na.toArray()) ma(Ra, ta); 0 < Ra.length && (xa = na.get(0).spatialReference, Qa = !0 === na.get(0).hasZ, Wa = !0 === na.get(0).hasM) } else throw Error("Invalid Argument");
              if (0 === Ra.length) return null; !1 === m.isClockwise(Ra, Wa, Qa) && (Ra = Ra.slice(0).reverse()); return new b({ rings: [Ra], spatialReference: xa, hasZ: Qa, hasM: Wa })
            } return na
          } function Aa(na, xa) {
            if (D(na) || J(na)) {
              let Qa = !1, Wa = !1, Ra = []; if (D(na)) { for (const ta of na) ma(Ra, ta); 0 < Ra.length && (xa = na[0].spatialReference, Qa = !0 === na[0].hasZ, Wa = !0 === na[0].hasM) } else if (na instanceof u) Ra = na._elements, 0 < Ra.length && (Qa = na._hasZ, Wa = na._hasM, xa = na.get(0).spatialReference); else if (J(na)) {
                for (const ta of na.toArray()) ma(Ra, ta); 0 < Ra.length &&
                  (xa = na.get(0).spatialReference, Qa = !0 === na.get(0).hasZ, Wa = !0 === na.get(0).hasM)
              } return 0 === Ra.length ? null : new d({ paths: [Ra], spatialReference: xa, hasZ: Qa, hasM: Wa })
            } return na
          } function za(na, xa) {
            if (D(na) || J(na)) {
              let Qa = !1, Wa = !1, Ra = []; if (D(na)) { for (const ta of na) ma(Ra, ta); 0 < Ra.length && (xa = na[0].spatialReference, Qa = !0 === na[0].hasZ, Wa = !0 === na[0].hasM) } else if (na instanceof u) Ra = na._elements, 0 < Ra.length && (Qa = na._hasZ, Wa = na._hasM, xa = na.get(0).spatialReference); else if (J(na)) {
                for (const ta of na.toArray()) ma(Ra,
                  ta); 0 < Ra.length && (xa = na.get(0).spatialReference, Qa = !0 === na.get(0).hasZ, Wa = !0 === na.get(0).hasM)
              } return 0 === Ra.length ? null : new l({ points: Ra, spatialReference: xa, hasZ: Qa, hasM: Wa })
            } return na
          } function Ka(na, xa = !1) {
            const Qa = []; if (null === na) return Qa; if (!0 === D(na)) { for (var Wa = 0; Wa < na.length; Wa++) { var Ra = S(na[Wa]); "" === Ra && !0 !== xa || Qa.push(Ra) } return Qa } if (na instanceof c) { for (Wa = 0; Wa < na.length(); Wa++)Ra = S(na.get(Wa)), "" === Ra && !0 !== xa || Qa.push(Ra); return Qa } return k(na) ? (na = S(na), "" === na && !0 !== xa || Qa.push(na),
              Qa) : []
          } function Ea(na) { qa++; return 0 === qa % 100 ? (qa = 0, y.create(xa => { setTimeout(() => { xa(na) }, 0) })) : na } function Ua(na, xa, Qa) { switch (Qa) { case "\x26": return na & xa; case "|": return na | xa; case "^": return na ^ xa; case "\x3c\x3c": return na << xa; case "\x3e\x3e": return na >> xa; case "\x3e\x3e\x3e": return na >>> xa } } function Na(na, xa = null) {
            if (null != na) {
              if (z(na) || B(na) || A(na)) return na; if (na instanceof p) return !0 === (null == xa ? void 0 : xa.keepGeometryType) ? na : na.toJSON(); if (na instanceof c) return na.toArray().map(Qa => Na(Qa,
                xa)); if (na instanceof Array) return na.map(Qa => Na(Qa, xa)); if (na instanceof Date) return na; if (null !== na && "object" === typeof na && void 0 !== na.castAsJson) return na.castAsJson(xa)
            } return null
          } function ya(na, xa, Qa, Wa, Ra) { return pa(na, xa, Qa).then(ta => { Ra[Wa] = ta }) } function pa(na, xa = null, Qa = null) {
          na instanceof c && (na = na.toArray()); if (null != na) {
            if (k(na) || na instanceof p || na instanceof Date) return y.resolve(Na(na, Qa)); if (na instanceof Array) {
              const Wa = [], Ra = []; for (const ta of na) null === ta || k(ta) || ta instanceof
                p || ta instanceof Date ? Ra.push(Na(ta, Qa)) : (Ra.push(null), Wa.push(ya(ta, xa, Qa, Ra.length - 1, Ra))); return 0 < Wa.length ? y.all(Wa).then(() => Ra) : y.resolve(Ra)
            } if (null !== na && "object" === typeof na && void 0 !== na.castAsJsonAsync) return na.castAsJsonAsync(xa, Qa)
          } return y.resolve(null)
          } let wa = function (na) { this.value = na }, Ia = function (na) { this.value = na }, Ha = function (na) { this.fn = na }, Oa = function (na, xa) { this.paramCount = xa; this.fn = na }; const Ba = Ha, sa = Oa, Ca = { type: "VOID" }, Ja = { type: "BREAK" }, ca = { type: "CONTINUE" }; let qa = 0; const Da =
            Object.freeze({
              __proto__: null, ReturnResultE: wa, ImplicitResultE: Ia, NativeFunctionE: Ha, SizzleFunctionE: Oa, NativeFunction: Ba, ImplicitResult: Ia, ReturnResult: wa, SizzleFunction: sa, voidOperation: Ca, breakResult: Ja, continueResult: ca, multiReplace: g, isFunctionParameter: x, isSimpleType: k, defaultUndefined: r, isString: A, isBoolean: z, isNumber: B, isInteger: C, isArray: D, isFeatureSet: E, isFeatureSetCollection: H, isImmutableArray: J, isDate: M, pcCheck: F, absRound: K, generateUUID: P, formatNumber: L, formatDate: N, standardiseDateFormat: G,
              greaterThanLessThan: O, equalityTest: R, toString: S, toNumberArray: Q, toStringExplicit: T, toNumber: Y, toDate: fa, toDateTime: ha, toBoolean: ea, fixSpatialReference: ba, fixNullGeometry: aa, getDomainValue: W, getDomainCode: U, getDomain: X, stableStringify: ia, autoCastFeatureToGeometry: la, autoCastArrayOfPointsToPolygon: ra, autoCastArrayOfPointsToPolyline: Aa, autoCastArrayOfPointsToMultiPoint: za, toStringArray: Ka, tick: Ea, binaryOperator: Ua, castAsJson: Na, castAsJsonAsync: pa
            }); a.ImplicitResult = Ia; a.ImplicitResultE = Ia; a.NativeFunction =
              Ba; a.NativeFunctionE = Ha; a.ReturnResult = wa; a.ReturnResultE = wa; a.SizzleFunction = sa; a.SizzleFunctionE = Oa; a.absRound = K; a.autoCastArrayOfPointsToMultiPoint = za; a.autoCastArrayOfPointsToPolygon = ra; a.autoCastArrayOfPointsToPolyline = Aa; a.autoCastFeatureToGeometry = la; a.binaryOperator = Ua; a.breakResult = Ja; a.castAsJson = Na; a.castAsJsonAsync = pa; a.continueResult = ca; a.defaultUndefined = r; a.equalityTest = R; a.fixNullGeometry = aa; a.fixSpatialReference = ba; a.formatDate = N; a.formatNumber = L; a.generateUUID = P; a.getDomain = X; a.getDomainCode =
                U; a.getDomainValue = W; a.greaterThanLessThan = O; a.isArray = D; a.isBoolean = z; a.isDate = M; a.isFeatureSet = E; a.isFeatureSetCollection = H; a.isFunctionParameter = x; a.isImmutableArray = J; a.isInteger = C; a.isNumber = B; a.isSimpleType = k; a.isString = A; a.lc = Da; a.multiReplace = g; a.pcCheck = F; a.stableStringify = ia; a.standardiseDateFormat = G; a.tick = Ea; a.toBoolean = ea; a.toDate = fa; a.toDateTime = ha; a.toNumber = Y; a.toNumberArray = Q; a.toString = S; a.toStringArray = Ka; a.toStringExplicit = T; a.voidOperation = Ca
        })
    }, "esri/arcade/FunctionWrapper": function () {
      define(function () {
        return function (a,
          w) { this.context = this.definition = null; this.definition = a; this.context = w }
      })
    }, "esri/arcade/ImmutableArray": function () { define(function () { return function () { function a(c = []) { this._elements = c } var w = a.prototype; w.length = function () { return this._elements.length }; w.get = function (c) { return this._elements[c] }; w.toArray = function () { const c = []; for (let q = 0; q < this.length(); q++)c.push(this.get(q)); return c }; return a }() }) }, "esri/arcade/ImmutablePathArray": function () {
      define(["../chunks/_rollupPluginBabelHelpers", "./ImmutableArray",
        "./ImmutablePointArray"], function (a, w, c) {
          return function (q) {
            function u(n, p, l, h, b) { n = q.call(this, n) || this; n._lazyPath = []; n._hasZ = !1; n._hasM = !1; n._hasZ = l; n._hasM = h; n._spRef = p; n._cacheId = b; return n } a._inheritsLoose(u, q); var y = u.prototype; y.get = function (n) { if (void 0 === this._lazyPath[n]) { const p = this._elements[n]; if (void 0 === p) return; this._lazyPath[n] = new c(p, this._spRef, this._hasZ, this._hasM, this._cacheId, n) } return this._lazyPath[n] }; y.equalityTest = function (n) {
              return n === this ? !0 : null === n || !1 === n instanceof
                u ? !1 : n.getUniqueHash() === this.getUniqueHash()
            }; y.getUniqueHash = function () { return this._cacheId.toString() }; return u
          }(w)
        })
    }, "esri/arcade/ImmutablePointArray": function () {
      define(["../chunks/_rollupPluginBabelHelpers", "./ImmutableArray", "../geometry/Point"], function (a, w, c) {
        return function (q) {
          function u(n, p, l, h, b, d) { n = q.call(this, n) || this; n._lazyPt = []; n._hasZ = !1; n._hasM = !1; n._spRef = p; n._hasZ = l; n._hasM = h; n._cacheId = b; n._partId = d; return n } a._inheritsLoose(u, q); var y = u.prototype; y.get = function (n) {
            if (void 0 ===
              this._lazyPt[n]) { const p = this._elements[n]; if (void 0 === p) return; const l = this._hasZ, h = this._hasM; let b = null; b = l && !h ? new c(p[0], p[1], p[2], void 0, this._spRef) : h && !l ? new c(p[0], p[1], void 0, p[2], this._spRef) : l && h ? new c(p[0], p[1], p[2], p[3], this._spRef) : new c(p[0], p[1], this._spRef); b.cache._arcadeCacheId = this._cacheId.toString() + "-" + this._partId.toString() + "-" + n.toString(); this._lazyPt[n] = b } return this._lazyPt[n]
          }; y.equalityTest = function (n) {
            return n === this ? !0 : null === n || !1 === n instanceof u ? !1 : n.getUniqueHash() ===
              this.getUniqueHash()
          }; y.getUniqueHash = function () { return this._cacheId.toString() + "-" + this._partId.toString() }; return u
        }(w)
      })
    }, "esri/chunks/datetime": function () {
      define(["exports"], function (a) {
        function w(V) { return "undefined" === typeof V } function c(V) { return "number" === typeof V } function q(V) { return "number" === typeof V && 0 === V % 1 } function u() { try { return "undefined" !== typeof Intl && !!Intl.RelativeTimeFormat } catch (V) { return !1 } } function y(V, ja, va) {
          if (0 !== V.length) return V.reduce((Ga, Pa) => {
            Pa = [ja(Pa), Pa]; return Ga ?
              va(Ga[0], Pa[0]) === Ga[0] ? Ga : Pa : Pa
          }, null)[1]
        } function n(V, ja) { return ja.reduce((va, Ga) => { va[Ga] = V[Ga]; return va }, {}) } function p(V, ja) { return Object.prototype.hasOwnProperty.call(V, ja) } function l(V, ja, va) { return q(V) && V >= ja && V <= va } function h(V, ja = 2) { const va = 0 > V ? "-" : ""; V = va ? -1 * V : V; ja = V.toString().length < ja ? ("0".repeat(ja) + V).slice(-ja) : V.toString(); return `${va}${ja}` } function b(V) { if (!w(V) && null !== V && "" !== V) return parseInt(V, 10) } function d(V) { if (!w(V) && null !== V && "" !== V) return parseFloat(V) } function f(V) {
          if (!w(V) &&
            null !== V && "" !== V) return V = 1E3 * parseFloat("0." + V), Math.floor(V)
        } function t(V, ja, va = !1) { ja = 10 ** ja; return (va ? Math.trunc : Math.round)(V * ja) / ja } function v(V) { return 0 === V % 4 && (0 !== V % 100 || 0 === V % 400) } function m(V, ja) { var va = ja - 1; va = va - 12 * Math.floor(va / 12) + 1; return 2 === va ? v(V + (ja - va) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][va - 1] } function e(V) {
          let ja = Date.UTC(V.year, V.month - 1, V.day, V.hour, V.minute, V.second, V.millisecond); 100 > V.year && 0 <= V.year && (ja = new Date(ja), ja.setUTCFullYear(ja.getUTCFullYear() -
            1900)); return +ja
        } function g(V) { var ja = V - 1; ja = (ja + Math.floor(ja / 4) - Math.floor(ja / 100) + Math.floor(ja / 400)) % 7; return 4 === (V + Math.floor(V / 4) - Math.floor(V / 100) + Math.floor(V / 400)) % 7 || 3 === ja ? 53 : 52 } function x(V) { return 99 < V ? V : 60 < V ? 1900 + V : 2E3 + V } function k(V, ja, va, Ga = null) {
          V = new Date(V); const Pa = { hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" }; Ga && (Pa.timeZone = Ga); return (ja = (new Intl.DateTimeFormat(va, { timeZoneName: ja, ...Pa })).formatToParts(V).find(Ta => "timezonename" ===
            Ta.type.toLowerCase())) ? ja.value : null
        } function r(V, ja) { V = parseInt(V, 10); Number.isNaN(V) && (V = 0); ja = parseInt(ja, 10) || 0; ja = 0 > V || Object.is(V, -0) ? -ja : ja; return 60 * V + ja } function A(V) { const ja = Number(V); if ("boolean" === typeof V || "" === V || Number.isNaN(ja)) throw new gb(`Invalid unit value ${V}`); return ja } function z(V, ja) { const va = {}; for (const Ga in V) if (p(V, Ga)) { const Pa = V[Ga]; void 0 !== Pa && null !== Pa && (va[ja(Ga)] = A(Pa)) } return va } function B(V, ja) {
          const va = Math.trunc(Math.abs(V / 60)), Ga = Math.trunc(Math.abs(V %
            60)); V = 0 <= V ? "+" : "-"; switch (ja) { case "short": return `${V}${h(va, 2)}:${h(Ga, 2)}`; case "narrow": return `${V}${va}${0 < Ga ? `:${Ga}` : ""}`; case "techie": return `${V}${h(va, 2)}${h(Ga, 2)}`; default: throw new RangeError(`Value format ${ja} is out of range for property format`); }
        } function C(V) { return n(V, ["hour", "minute", "second", "millisecond"]) } function D(V) {
          switch (V) {
            case "narrow": return [...Pd]; case "short": return [...Xc]; case "long": return [...Qd]; case "numeric": return "1 2 3 4 5 6 7 8 9 10 11 12".split(" "); case "2-digit": return "01 02 03 04 05 06 07 08 09 10 11 12".split(" ");
            default: return null
          }
        } function E(V) { switch (V) { case "narrow": return [...Rd]; case "short": return [...Yc]; case "long": return [...Zc]; case "numeric": return "1234567".split(""); default: return null } } function H(V) { switch (V) { case "narrow": return [...Sd]; case "short": return [...Td]; case "long": return [...$c]; default: return null } } function J(V, ja, va = "always", Ga = !1) {
          const Pa = {
            years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute",
              "min."], seconds: ["second", "sec."]
          }; var Ta = -1 === ["hours", "minutes", "seconds"].indexOf(V); if ("auto" === va && Ta) switch (va = "days" === V, ja) { case 1: return va ? "tomorrow" : `next ${Pa[V][0]}`; case -1: return va ? "yesterday" : `last ${Pa[V][0]}`; case 0: return va ? "today" : `this ${Pa[V][0]}` }va = Object.is(ja, -0) || 0 > ja; ja = Math.abs(ja); Ta = 1 === ja; const $a = Pa[V]; V = Ga ? Ta ? $a[1] : $a[2] || $a[1] : Ta ? Pa[V][0] : V; return va ? `${ja} ${V} ago` : `in ${ja} ${V}`
        } function M(V, ja) {
          let va = ""; for (const Ga of V) va = Ga.literal ? va + Ga.val : va + ja(Ga.val);
          return va
        } function F(V, ja) { if (w(V) || null === V) return ja; if (V instanceof dc) return V; if ("string" === typeof V) { const va = V.toLowerCase(); return "local" === va || "system" === va ? ja : "utc" === va || "gmt" === va ? Eb.utcInstance : Ob.isValidSpecifier(va) ? Ob.create(V) : Eb.parseSpecifier(va) || new ad(V) } return c(V) ? Eb.instance(V) : "object" === typeof V && V.offset && "number" === typeof V.offset ? V : new ad(V) } function K(V, ja = {}) { const va = JSON.stringify([V, ja]); let Ga = Hc[va]; Ga || (Ga = new Intl.DateTimeFormat(V, ja), Hc[va] = Ga); return Ga } function P(V,
          ja = {}) { const va = JSON.stringify([V, ja]); let Ga = Ic[va]; Ga || (Ga = new Intl.NumberFormat(V, ja), Ic[va] = Ga); return Ga } function L(V, ja = {}) { const { base: va, ...Ga } = ja, Pa = JSON.stringify([V, Ga]); let Ta = hc[Pa]; Ta || (Ta = new Intl.RelativeTimeFormat(V, ja), hc[Pa] = Ta); return Ta } function N(V) { const ja = []; for (let va = 1; 12 >= va; va++) { const Ga = ua.utc(2016, va, 1); ja.push(V(Ga)) } return ja } function G(V) { const ja = []; for (let va = 1; 7 >= va; va++) { const Ga = ua.utc(2016, 11, 13 + va); ja.push(V(Ga)) } return ja } function I(V, ja, va, Ga, Pa) {
            V = V.listingMode(va);
            return "error" === V ? null : "en" === V ? Ga(ja) : Pa(ja)
          } function O(...V) { V = V.reduce((ja, va) => ja + va.source, ""); return RegExp(`^${V}$`) } function R(...V) { return ja => V.reduce(([va, Ga, Pa], Ta) => { const [$a, ab, eb] = Ta(ja, Pa); return [{ ...va, ...$a }, Ga || ab, eb] }, [{}, null, 1]).slice(0, 2) } function S(V, ...ja) { if (null == V) return [null, null]; for (const [va, Ga] of ja) if (ja = va.exec(V)) return Ga(ja); return [null, null] } function Q(...V) {
            return (ja, va) => {
              const Ga = {}; let Pa; for (Pa = 0; Pa < V.length; Pa++)Ga[V[Pa]] = b(ja[va + Pa]); return [Ga, null, va +
                Pa]
            }
          } function T(V, ja, va) { V = V[ja]; return w(V) ? va : b(V) } function da(V, ja) { return [{ year: T(V, ja), month: T(V, ja + 1, 1), day: T(V, ja + 2, 1) }, null, ja + 3] } function Y(V, ja) { return [{ hours: T(V, ja, 0), minutes: T(V, ja + 1, 0), seconds: T(V, ja + 2, 0), milliseconds: f(V[ja + 3]) }, null, ja + 4] } function fa(V, ja) { const va = !V[ja] && !V[ja + 1]; V = r(V[ja + 1], V[ja + 2]); return [{}, va ? null : Eb.instance(V), ja + 3] } function ha(V, ja) { return [{}, V[ja] ? Ob.create(V[ja]) : null, ja + 1] } function ka(V) {
            const [ja, va, Ga, Pa, Ta, $a, ab, eb, nb] = V, jb = "-" === ja[0]; V = eb && "-" === eb[0];
            const lb = (qb, Fb = !1) => void 0 !== qb && (Fb || qb && jb) ? -qb : qb; return [{ years: lb(d(va)), months: lb(d(Ga)), weeks: lb(d(Pa)), days: lb(d(Ta)), hours: lb(d($a)), minutes: lb(d(ab)), seconds: lb(d(eb), "-0" === eb), milliseconds: lb(f(nb), V) }]
          } function ea(V, ja, va, Ga, Pa, Ta, $a) { ja = { year: 2 === ja.length ? x(b(ja)) : b(ja), month: Xc.indexOf(va) + 1, day: b(Ga), hour: b(Pa), minute: b(Ta) }; $a && (ja.second = b($a)); V && (ja.weekday = 3 < V.length ? Zc.indexOf(V) + 1 : Yc.indexOf(V) + 1); return ja } function ba(V) {
            const [, ja, va, Ga, Pa, Ta, $a, ab, eb, nb, jb, lb] = V; V = ea(ja,
              Pa, Ga, va, Ta, $a, ab); let qb; qb = eb ? Ud[eb] : nb ? 0 : r(jb, lb); return [V, new Eb(qb)]
          } function aa(V) { const [, ja, va, Ga, Pa, Ta, $a, ab] = V; return [ea(ja, Pa, Ga, va, Ta, $a, ab), Eb.utcInstance] } function W(V) { const [, ja, va, Ga, Pa, Ta, $a, ab] = V; return [ea(ja, ab, va, Ga, Pa, Ta, $a), Eb.utcInstance] } function U(V, ja, va = !1) { V = { values: va ? ja.values : { ...V.values, ...ja.values || {} }, loc: V.loc.clone(ja.loc), conversionAccuracy: ja.conversionAccuracy || V.conversionAccuracy }; return new pb(V) } function X(V, ja, va, Ga, Pa) {
            V = V[Pa][va]; var Ta = ja[va] / V; Ta =
              Math.sign(Ta) !== Math.sign(Ga[Pa]) && 0 !== Ga[Pa] && 1 >= Math.abs(Ta) ? 0 > Ta ? Math.floor(Ta) : Math.ceil(Ta) : Math.trunc(Ta); Ga[Pa] += Ta; ja[va] -= Ta * V
          } function Z(V, ja) { Vd.reduce((va, Ga) => { if (w(ja[Ga])) return va; va && X(V, ja, va, ja, Ga); return Ga }, null) } function ia(V, ja) { V = ja.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf() - V.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(); return Math.floor(pb.fromMillis(V).as("days")) } function la(V, ja, va) {
            var Ga = [["years", (ab, eb) => eb.year - ab.year], ["quarters", (ab, eb) => eb.quarter -
              ab.quarter], ["months", (ab, eb) => eb.month - ab.month + 12 * (eb.year - ab.year)], ["weeks", (ab, eb) => { ab = ia(ab, eb); return (ab - ab % 7) / 7 }], ["days", ia]]; const Pa = {}; let Ta, $a; for (const [ab, eb] of Ga) 0 <= va.indexOf(ab) && (Ta = ab, Ga = eb(V, ja), $a = V.plus({ [ab]: Ga }), $a > ja ? (V = V.plus({ [ab]: Ga - 1 }), --Ga) : V = $a, Pa[ab] = Ga); return [V, Pa, $a, Ta]
          } function ma(V, ja, va, Ga) {
            let [Pa, Ta, $a, ab] = la(V, ja, va); V = ja - Pa; va = va.filter(eb => 0 <= ["hours", "minutes", "seconds", "milliseconds"].indexOf(eb)); 0 === va.length && ($a < ja && ($a = Pa.plus({ [ab]: 1 })), $a !==
              Pa && (Ta[ab] = (Ta[ab] || 0) + V / ($a - Pa))); ja = pb.fromObject(Ta, Ga); return 0 < va.length ? pb.fromMillis(V, Ga).shiftTo(...va).plus(ja) : ja
          } function ra({ numberingSystem: V }, ja = "") { return new RegExp(`${Jc[V || "latn"]}${ja}`) } function Aa(V, ja = va => va) {
            return {
              regex: V, deser: ([va]) => {
                {
                  let Ga = parseInt(va, 10); if (isNaN(Ga)) {
                    Ga = ""; for (let Pa = 0; Pa < va.length; Pa++) { const Ta = va.charCodeAt(Pa); if (-1 !== va[Pa].search(Jc.hanidec)) Ga += Wd.indexOf(va[Pa]); else for (const $a in bd) { const [ab, eb] = bd[$a]; Ta >= ab && Ta <= eb && (Ga += Ta - ab) } } va =
                      parseInt(Ga, 10)
                  } else va = Ga
                } return ja(va)
              }
            }
          } function za(V) { return V.replace(/\./g, "\\.?").replace(Kc, cd) } function Ka(V, ja) { return null === V ? null : { regex: RegExp(V.map(za).join("|")), deser: ([va]) => V.findIndex(Ga => va.replace(/\./g, "").replace(Kc, " ").toLowerCase() === Ga.replace(/\./g, "").replace(Kc, " ").toLowerCase()) + ja } } function Ea(V, ja) { return { regex: V, deser: ([, va, Ga]) => r(va, Ga), groups: ja } } function Ua(V) { return { regex: V, deser: ([ja]) => ja } } function Na(V, ja) {
            const va = ra(ja), Ga = ra(ja, "{2}"), Pa = ra(ja, "{3}"),
            Ta = ra(ja, "{4}"), $a = ra(ja, "{6}"), ab = ra(ja, "{1,2}"), eb = ra(ja, "{1,3}"), nb = ra(ja, "{1,6}"), jb = ra(ja, "{1,9}"), lb = ra(ja, "{2,4}"), qb = ra(ja, "{4,6}"), Fb = Sb => ({ regex: RegExp(Sb.val.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$\x26")), deser: ([ec]) => ec, literal: !0 }), Lb = (Sb => {
              if (V.literal) return Fb(Sb); switch (Sb.val) {
                case "G": return Ka(ja.eras("short", !1), 0); case "GG": return Ka(ja.eras("long", !1), 0); case "y": return Aa(nb); case "yy": return Aa(lb, x); case "yyyy": return Aa(Ta); case "yyyyy": return Aa(qb); case "yyyyyy": return Aa($a);
                case "M": return Aa(ab); case "MM": return Aa(Ga); case "MMM": return Ka(ja.months("short", !0, !1), 1); case "MMMM": return Ka(ja.months("long", !0, !1), 1); case "L": return Aa(ab); case "LL": return Aa(Ga); case "LLL": return Ka(ja.months("short", !1, !1), 1); case "LLLL": return Ka(ja.months("long", !1, !1), 1); case "d": return Aa(ab); case "dd": return Aa(Ga); case "o": return Aa(eb); case "ooo": return Aa(Pa); case "HH": return Aa(Ga); case "H": return Aa(ab); case "hh": return Aa(Ga); case "h": return Aa(ab); case "mm": return Aa(Ga);
                case "m": return Aa(ab); case "q": return Aa(ab); case "qq": return Aa(Ga); case "s": return Aa(ab); case "ss": return Aa(Ga); case "S": return Aa(eb); case "SSS": return Aa(Pa); case "u": return Ua(jb); case "uu": return Ua(ab); case "uuu": return Aa(va); case "a": return Ka(ja.meridiems(), 0); case "kkkk": return Aa(Ta); case "kk": return Aa(lb, x); case "W": return Aa(ab); case "WW": return Aa(Ga); case "E": case "c": return Aa(va); case "EEE": return Ka(ja.weekdays("short", !1, !1), 1); case "EEEE": return Ka(ja.weekdays("long", !1, !1),
                  1); case "ccc": return Ka(ja.weekdays("short", !0, !1), 1); case "cccc": return Ka(ja.weekdays("long", !0, !1), 1); case "Z": case "ZZ": return Ea(new RegExp(`([+-]${ab.source})(?::(${Ga.source}))?`), 2); case "ZZZ": return Ea(new RegExp(`([+-]${ab.source})(${Ga.source})?`), 2); case "z": return Ua(/[a-z_+-/]{1,256}?/i); default: return Fb(Sb)
              }
            })(V) || { invalidReason: "missing Intl.DateTimeFormat.formatToParts support" }; Lb.token = V; return Lb
          } function ya(V) {
            return [`^${V.map(ja => ja.regex).reduce((ja, va) => `${ja}(${va.source})`,
              "")}$`, V]
          } function pa(V, ja, va) { if (V = V.match(ja)) { ja = {}; let Ga = 1; for (const Pa in va) if (p(va, Pa)) { const Ta = va[Pa], $a = Ta.groups ? Ta.groups + 1 : 1; !Ta.literal && Ta.token && (ja[Ta.token.val[0]] = Ta.deser(V.slice(Ga, Ga + $a))); Ga += $a } return [V, ja] } return [V, {}] } function wa(V) {
            const ja = Ga => {
              switch (Ga) {
                case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": case "H": return "hour"; case "d": return "day"; case "o": return "ordinal"; case "L": case "M": return "month"; case "y": return "year"; case "E": case "c": return "weekday";
                case "W": return "weekNumber"; case "k": return "weekYear"; case "q": return "quarter"; default: return null
              }
            }; let va; va = w(V.Z) ? w(V.z) ? null : Ob.create(V.z) : new Eb(V.Z); w(V.q) || (V.M = 3 * (V.q - 1) + 1); w(V.h) || (12 > V.h && 1 === V.a ? V.h += 12 : 12 === V.h && 0 === V.a && (V.h = 0)); 0 === V.G && V.y && (V.y = -V.y); w(V.u) || (V.S = f(V.u)); return [Object.keys(V).reduce((Ga, Pa) => { const Ta = ja(Pa); Ta && (Ga[Ta] = V[Pa]); return Ga }, {}), va]
          } function Ia() { ic || (ic = ua.fromMillis(1555555555555)); return ic } function Ha(V, ja) {
            if (V.literal) return V; const va = Gb.macroTokenToFormatOpts(V.val);
            if (!va) return V; ja = Gb.create(ja, va).formatDateTimeParts(Ia()).map(Ga => { { const { type: Ta, value: $a } = Ga; if ("literal" === Ta) Ga = { literal: !0, val: $a }; else { Ga = va[Ta]; var Pa = dd[Ta]; "object" === typeof Pa && (Pa = Pa[Ga]); Ga = Pa ? { literal: !1, val: Pa } : void 0 } } return Ga }); return ja.includes(void 0) ? V : ja
          } function Oa(V, ja) { return Array.prototype.concat(...V.map(va => Ha(va, ja))) } function Ba(V, ja, va) {
            va = Oa(Gb.parseFormat(va), V); var Ga = va.map(Ta => Na(Ta, V)); const Pa = Ga.find(Ta => Ta.invalidReason); if (Pa) return {
              input: ja, tokens: va,
              invalidReason: Pa.invalidReason
            }; { const [Ta, $a] = ya(Ga); Ga = RegExp(Ta, "i"); const [ab, eb] = pa(ja, Ga, $a), [nb, jb] = eb ? wa(eb) : [null, null]; if (p(eb, "a") && p(eb, "H")) throw new cb("Can't include meridiem when specifying 24-hour format"); return { input: ja, tokens: va, regex: Ga, rawMatches: ab, matches: eb, result: nb, zone: jb } }
          } function sa(V, ja) { return new Mb("unit out of range", `you specified ${ja} (of type ${typeof ja}) as a ${V}, which is invalid`) } function Ca(V, ja, va) {
            V = (new Date(Date.UTC(V, ja - 1, va))).getUTCDay(); return 0 ===
              V ? 7 : V
          } function Ja(V, ja) { V = v(V) ? jc : kc; const va = V.findIndex(Ga => Ga < ja); return { month: va + 1, day: ja - V[va] } } function ca(V) { const { year: ja, month: va, day: Ga } = V; var Pa = Ga + (v(ja) ? jc : kc)[va - 1]; const Ta = Ca(ja, va, Ga); Pa = Math.floor((Pa - Ta + 10) / 7); let $a; 1 > Pa ? ($a = ja - 1, Pa = g($a)) : Pa > g(ja) ? ($a = ja + 1, Pa = 1) : $a = ja; return { weekYear: $a, weekNumber: Pa, weekday: Ta, ...C(V) } } function qa(V) {
            const { weekYear: ja, weekNumber: va, weekday: Ga } = V; var Pa = Ca(ja, 1, 4), Ta = v(ja) ? 366 : 365; Pa = 7 * va + Ga - Pa - 3; 1 > Pa ? (Ta = ja - 1, Pa += v(Ta) ? 366 : 365) : Pa > Ta ? (Ta = ja +
              1, Pa -= v(ja) ? 366 : 365) : Ta = ja; const { month: $a, day: ab } = Ja(Ta, Pa); return { year: Ta, month: $a, day: ab, ...C(V) }
          } function Da(V) { const { year: ja, month: va, day: Ga } = V; var Pa = Ga + (v(ja) ? jc : kc)[va - 1]; return { year: ja, ordinal: Pa, ...C(V) } } function na(V) { const { year: ja, ordinal: va } = V, { month: Ga, day: Pa } = Ja(ja, va); return { year: ja, month: Ga, day: Pa, ...C(V) } } function xa(V) { const ja = q(V.year), va = l(V.month, 1, 12), Ga = l(V.day, 1, m(V.year, V.month)); return ja ? va ? Ga ? !1 : sa("day", V.day) : sa("month", V.month) : sa("year", V.year) } function Qa(V) {
            const { hour: ja,
              minute: va, second: Ga, millisecond: Pa } = V; V = l(ja, 0, 23) || 24 === ja && 0 === va && 0 === Ga && 0 === Pa; const Ta = l(va, 0, 59), $a = l(Ga, 0, 59), ab = l(Pa, 0, 999); return V ? Ta ? $a ? ab ? !1 : sa("millisecond", Pa) : sa("second", Ga) : sa("minute", va) : sa("hour", ja)
          } function Wa(V) { return new Mb("unsupported zone", `the zone "${V.name}" is not supported`) } function Ra(V) { null === V.weekData && (V.weekData = ca(V.c)); return V.weekData } function ta(V, ja) { V = { ts: V.ts, zone: V.zone, c: V.c, o: V.o, loc: V.loc, invalid: V.invalid }; return new ua({ ...V, ...ja, old: V }) } function Fa(V,
            ja, va) { let Ga = V - 6E4 * ja; const Pa = va.offset(Ga); if (ja === Pa) return [Ga, ja]; Ga -= 6E4 * (Pa - ja); ja = va.offset(Ga); return Pa === ja ? [Ga, Pa] : [V - 6E4 * Math.min(Pa, ja), Math.max(Pa, ja)] } function Sa(V, ja) { V = new Date(V + 6E4 * ja); return { year: V.getUTCFullYear(), month: V.getUTCMonth() + 1, day: V.getUTCDate(), hour: V.getUTCHours(), minute: V.getUTCMinutes(), second: V.getUTCSeconds(), millisecond: V.getUTCMilliseconds() } } function Va(V, ja, va) { return Fa(e(V), ja, va) } function Ya(V, ja) {
              const va = V.o; var Ga = V.c.year + Math.trunc(ja.years); const Pa =
                V.c.month + Math.trunc(ja.months) + 3 * Math.trunc(ja.quarters); Ga = { ...V.c, year: Ga, month: Pa, day: Math.min(V.c.day, m(Ga, Pa)) + Math.trunc(ja.days) + 7 * Math.trunc(ja.weeks) }; ja = pb.fromObject({ years: ja.years - Math.trunc(ja.years), quarters: ja.quarters - Math.trunc(ja.quarters), months: ja.months - Math.trunc(ja.months), weeks: ja.weeks - Math.trunc(ja.weeks), days: ja.days - Math.trunc(ja.days), hours: ja.hours, minutes: ja.minutes, seconds: ja.seconds, milliseconds: ja.milliseconds }).as("milliseconds"); Ga = e(Ga); let [Ta, $a] = Fa(Ga, va,
                  V.zone); 0 !== ja && (Ta += ja, $a = V.zone.offset(Ta)); return { ts: Ta, o: $a }
            } function bb(V, ja, va, Ga, Pa) { const { setZone: Ta, zone: $a } = va; return V && 0 !== Object.keys(V).length ? (V = ua.fromObject(V, { ...va, zone: ja || $a }), Ta ? V : V.setZone($a)) : ua.invalid(new Mb("unparsable", `the input "${Pa}" can't be parsed as ${Ga}`)) } function hb(V, ja, va = !0) { return V.isValid ? Gb.create(vb.create("en-US"), { allowZ: va, forceSimple: !0 }).formatDateTimeFromString(V, ja) : null } function ib(V, { suppressSeconds: ja = !1, suppressMilliseconds: va = !1, includeOffset: Ga,
              includePrefix: Pa = !1, includeZone: Ta = !1, spaceZone: $a = !1, format: ab = "extended" }) { let eb = "basic" === ab ? "HHmm" : "HH:mm"; ja && 0 === V.second && 0 === V.millisecond || (eb += "basic" === ab ? "ss" : ":ss", va && 0 === V.millisecond || (eb += ".SSS")); (Ta || Ga) && $a && (eb += " "); Ta ? eb += "z" : Ga && (eb += "basic" === ab ? "ZZZ" : "ZZ"); V = hb(V, eb); Pa && (V = "T" + V); return V } function mb(V) {
                const ja = {
                  year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter",
                  second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal"
                }[V.toLowerCase()]; if (!ja) throw new fb(V); return ja
              } function tb(V, ja) {
                const va = F(ja.zone, zb.defaultZone); ja = vb.fromObject(ja); const Ga = zb.now(); var Pa; if (w(V.year)) V = Ga; else {
                  for (const Ta of lc) w(V[Ta]) && (V[Ta] = oa[Ta]); if (Pa = xa(V) || Qa(V)) return ua.invalid(Pa);
                  Pa = va.offset(Ga);[V, Pa] = Va(V, Pa, va)
                } return new ua({ ts: V, zone: va, loc: ja, o: Pa })
              } function rb(V, ja, va) {
                const Ga = w(va.round) ? !0 : va.round, Pa = ($a, ab) => { $a = t($a, Ga || va.calendary ? 0 : 2, !0); return ja.loc.clone(va).relFormatter(va).format($a, ab) }, Ta = $a => va.calendary ? ja.hasSame(V, $a) ? 0 : ja.startOf($a).diff(V.startOf($a), $a).get($a) : ja.diff(V, $a).get($a); if (va.unit) return Pa(Ta(va.unit), va.unit); for (const $a of va.units) { const ab = Ta($a); if (1 <= Math.abs(ab)) return Pa(ab, $a) } return Pa(V > ja ? -0 : 0, va.units[va.units.length -
                  1])
              } function ob(V) { let ja = {}; 0 < V.length && "object" === typeof V[V.length - 1] ? (ja = V[V.length - 1], V = Array.from(V).slice(0, V.length - 1)) : V = Array.from(V); return [ja, V] } function wb(V) { if (ua.isDateTime(V)) return V; if (V && V.valueOf && c(V.valueOf())) return ua.fromJSDate(V); if (V && "object" === typeof V) return ua.fromObject(V); throw new gb(`Unknown datetime argument: ${V}, of type ${typeof V}`); } class db extends Error { } class La extends db { constructor(V) { super(`Invalid DateTime: ${V.toMessage()}`) } } class Ma extends db { constructor(V) { super(`Invalid Interval: ${V.toMessage()}`) } }
        class Za extends db { constructor(V) { super(`Invalid Duration: ${V.toMessage()}`) } } class cb extends db { } class fb extends db { constructor(V) { super(`Invalid unit ${V}`) } } class gb extends db { } class kb extends db { constructor() { super("Zone is an abstract class") } } const Bb = { year: "numeric", month: "numeric", day: "numeric" }, fc = { year: "numeric", month: "short", day: "numeric" }, mc = { year: "numeric", month: "short", day: "numeric", weekday: "short" }, $b = { year: "numeric", month: "long", day: "numeric" }, ac = {
          year: "numeric", month: "long",
          day: "numeric", weekday: "long"
        }, Vb = { hour: "numeric", minute: "numeric" }, gc = { hour: "numeric", minute: "numeric", second: "numeric" }, nc = { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" }, Ab = { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "long" }, oc = { hour: "numeric", minute: "numeric", hourCycle: "h23" }, xb = { hour: "numeric", minute: "numeric", second: "numeric", hourCycle: "h23" }, Nb = { hour: "numeric", minute: "numeric", second: "numeric", hourCycle: "h23", timeZoneName: "short" }, pc = {
          hour: "numeric",
          minute: "numeric", second: "numeric", hourCycle: "h23", timeZoneName: "long"
        }, qc = { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric" }, ed = { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }, fd = { year: "numeric", month: "short", day: "numeric", hour: "numeric", minute: "numeric" }, gd = { year: "numeric", month: "short", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }, Xd = {
          year: "numeric", month: "short", day: "numeric", weekday: "short", hour: "numeric",
          minute: "numeric"
        }, hd = { year: "numeric", month: "long", day: "numeric", hour: "numeric", minute: "numeric", timeZoneName: "short" }, id = { year: "numeric", month: "long", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" }, jd = { year: "numeric", month: "long", day: "numeric", weekday: "long", hour: "numeric", minute: "numeric", timeZoneName: "long" }, kd = { year: "numeric", month: "long", day: "numeric", weekday: "long", hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "long" }, ld = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z0-9_+-]{1,256}(\/[A-Za-z0-9_+-]{1,256})?)?/,
          Qd = "January February March April May June July August September October November December".split(" "), Xc = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), Pd = "JFMAMJJASOND".split(""), Zc = "Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(" "), Yc = "Mon Tue Wed Thu Fri Sat Sun".split(" "), Rd = "MTWTFSS".split(""), md = ["AM", "PM"], $c = ["Before Christ", "Anno Domini"], Td = ["BC", "AD"], Sd = ["B", "A"], Yd = {
            D: Bb, DD: fc, DDD: $b, DDDD: ac, t: Vb, tt: gc, ttt: nc, tttt: Ab, T: oc, TT: xb, TTT: Nb, TTTT: pc, f: qc, ff: fd,
            fff: hd, ffff: jd, F: ed, FF: gd, FFF: id, FFFF: kd
          }; class Gb {
            static create(V, ja = {}) { return new Gb(V, ja) } static parseFormat(V) { let ja = null, va = "", Ga = !1; const Pa = []; for (let Ta = 0; Ta < V.length; Ta++) { const $a = V.charAt(Ta); "'" === $a ? (0 < va.length && Pa.push({ literal: Ga, val: va }), ja = null, va = "", Ga = !Ga) : Ga ? va += $a : $a === ja ? va += $a : (0 < va.length && Pa.push({ literal: !1, val: va }), ja = va = $a) } 0 < va.length && Pa.push({ literal: Ga, val: va }); return Pa } static macroTokenToFormatOpts(V) { return Yd[V] } constructor(V, ja) {
            this.opts = ja; this.loc = V; this.systemLoc =
              null
            } formatWithSystemDefault(V, ja) { null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem()); return this.systemLoc.dtFormatter(V, { ...this.opts, ...ja }).format() } formatDateTime(V, ja = {}) { return this.loc.dtFormatter(V, { ...this.opts, ...ja }).format() } formatDateTimeParts(V, ja = {}) { return this.loc.dtFormatter(V, { ...this.opts, ...ja }).formatToParts() } resolvedOptions(V, ja = {}) { return this.loc.dtFormatter(V, { ...this.opts, ...ja }).resolvedOptions() } num(V, ja = 0) {
              if (this.opts.forceSimple) return h(V, ja); const va =
                { ...this.opts }; 0 < ja && (va.padTo = ja); return this.loc.numberFormatter(va).format(V)
            } formatDateTimeFromString(V, ja) {
              const va = "en" === this.loc.listingMode(), Ga = this.loc.outputCalendar && "gregory" !== this.loc.outputCalendar, Pa = (jb, lb) => this.loc.extract(V, jb, lb), Ta = jb => V.isOffsetFixed && 0 === V.offset && jb.allowZ ? "Z" : V.isValid ? V.zone.formatOffset(V.ts, jb.format) : "", $a = (jb, lb) => va ? D(jb)[V.month - 1] : Pa(lb ? { month: jb } : { month: jb, day: "numeric" }, "month"), ab = (jb, lb) => va ? E(jb)[V.weekday - 1] : Pa(lb ? { weekday: jb } : {
                weekday: jb,
                month: "long", day: "numeric"
              }, "weekday"), eb = jb => { const lb = Gb.macroTokenToFormatOpts(jb); return lb ? this.formatWithSystemDefault(V, lb) : jb }, nb = jb => va ? H(jb)[0 > V.year ? 0 : 1] : Pa({ era: jb }, "era"); return M(Gb.parseFormat(ja), jb => {
                switch (jb) {
                  case "S": return this.num(V.millisecond); case "u": case "SSS": return this.num(V.millisecond, 3); case "s": return this.num(V.second); case "ss": return this.num(V.second, 2); case "uu": return this.num(Math.floor(V.millisecond / 10), 2); case "uuu": return this.num(Math.floor(V.millisecond /
                    100)); case "m": return this.num(V.minute); case "mm": return this.num(V.minute, 2); case "h": return this.num(0 === V.hour % 12 ? 12 : V.hour % 12); case "hh": return this.num(0 === V.hour % 12 ? 12 : V.hour % 12, 2); case "H": return this.num(V.hour); case "HH": return this.num(V.hour, 2); case "Z": return Ta({ format: "narrow", allowZ: this.opts.allowZ }); case "ZZ": return Ta({ format: "short", allowZ: this.opts.allowZ }); case "ZZZ": return Ta({ format: "techie", allowZ: this.opts.allowZ }); case "ZZZZ": return V.zone.offsetName(V.ts, {
                      format: "short",
                      locale: this.loc.locale
                    }); case "ZZZZZ": return V.zone.offsetName(V.ts, { format: "long", locale: this.loc.locale }); case "z": return V.zoneName; case "a": return va ? md[12 > V.hour ? 0 : 1] : Pa({ hour: "numeric", hourCycle: "h12" }, "dayperiod"); case "d": return Ga ? Pa({ day: "numeric" }, "day") : this.num(V.day); case "dd": return Ga ? Pa({ day: "2-digit" }, "day") : this.num(V.day, 2); case "c": return this.num(V.weekday); case "ccc": return ab("short", !0); case "cccc": return ab("long", !0); case "ccccc": return ab("narrow", !0); case "E": return this.num(V.weekday);
                  case "EEE": return ab("short", !1); case "EEEE": return ab("long", !1); case "EEEEE": return ab("narrow", !1); case "L": return Ga ? Pa({ month: "numeric", day: "numeric" }, "month") : this.num(V.month); case "LL": return Ga ? Pa({ month: "2-digit", day: "numeric" }, "month") : this.num(V.month, 2); case "LLL": return $a("short", !0); case "LLLL": return $a("long", !0); case "LLLLL": return $a("narrow", !0); case "M": return Ga ? Pa({ month: "numeric" }, "month") : this.num(V.month); case "MM": return Ga ? Pa({ month: "2-digit" }, "month") : this.num(V.month,
                    2); case "MMM": return $a("short", !1); case "MMMM": return $a("long", !1); case "MMMMM": return $a("narrow", !1); case "y": return Ga ? Pa({ year: "numeric" }, "year") : this.num(V.year); case "yy": return Ga ? Pa({ year: "2-digit" }, "year") : this.num(V.year.toString().slice(-2), 2); case "yyyy": return Ga ? Pa({ year: "numeric" }, "year") : this.num(V.year, 4); case "yyyyyy": return Ga ? Pa({ year: "numeric" }, "year") : this.num(V.year, 6); case "G": return nb("short"); case "GG": return nb("long"); case "GGGGG": return nb("narrow"); case "kk": return this.num(V.weekYear.toString().slice(-2),
                      2); case "kkkk": return this.num(V.weekYear, 4); case "W": return this.num(V.weekNumber); case "WW": return this.num(V.weekNumber, 2); case "o": return this.num(V.ordinal); case "ooo": return this.num(V.ordinal, 3); case "q": return this.num(V.quarter); case "qq": return this.num(V.quarter, 2); case "X": return this.num(Math.floor(V.ts / 1E3)); case "x": return this.num(V.ts); default: return eb(jb)
                }
              })
            } formatDurationFromString(V, ja) {
              const va = Pa => {
                switch (Pa[0]) {
                  case "S": return "millisecond"; case "s": return "second"; case "m": return "minute";
                  case "h": return "hour"; case "d": return "day"; case "M": return "month"; case "y": return "year"; default: return null
                }
              }; ja = Gb.parseFormat(ja); const Ga = ja.reduce((Pa, { literal: Ta, val: $a }) => Ta ? Pa : Pa.concat($a), []); V = V.shiftTo(...Ga.map(va).filter(Pa => Pa)); return M(ja, (Pa => Ta => { const $a = va(Ta); return $a ? this.num(Pa.get($a), Ta.length) : Ta })(V))
            }
        } class Mb { constructor(V, ja) { this.reason = V; this.explanation = ja } toMessage() { return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason } } class dc {
          get type() {
            throw new kb;
          } get name() { throw new kb; } get isUniversal() { throw new kb; } offsetName(V, ja) { throw new kb; } formatOffset(V, ja) { throw new kb; } offset(V) { throw new kb; } equals(V) { throw new kb; } get isValid() { throw new kb; }
        } let Lc = null; class nd extends dc {
          static get instance() { null === Lc && (Lc = new nd); return Lc } get type() { return "system" } get name() { return (new Intl.DateTimeFormat).resolvedOptions().timeZone } get isUniversal() { return !1 } offsetName(V, { format: ja, locale: va }) { return k(V, ja, va) } formatOffset(V, ja) {
            return B(this.offset(V),
              ja)
          } offset(V) { return -(new Date(V)).getTimezoneOffset() } equals(V) { return "system" === V.type } get isValid() { return !0 }
        } const od = RegExp(`^${ld.source}$`); let rc = {}; const pd = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }; let sc = {}; class Ob extends dc {
          static create(V) { sc[V] || (sc[V] = new Ob(V)); return sc[V] } static resetCache() { sc = {}; rc = {} } static isValidSpecifier(V) { return !(!V || !V.match(od)) } static isValidZone(V) { if (!V) return !1; try { return (new Intl.DateTimeFormat("en-US", { timeZone: V })).format(), !0 } catch (ja) { return !1 } } constructor(V) {
            super();
            this.zoneName = V; this.valid = Ob.isValidZone(V)
          } get type() { return "iana" } get name() { return this.zoneName } get isUniversal() { return !1 } offsetName(V, { format: ja, locale: va }) { return k(V, ja, va, this.name) } formatOffset(V, ja) { return B(this.offset(V), ja) } offset(V) {
            V = new Date(V); if (isNaN(V)) return NaN; var ja = this.name; rc[ja] || (rc[ja] = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: ja, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" })); ja = rc[ja]; if (ja.formatToParts) {
              ja =
              ja.formatToParts(V); var va = []; for (let nb = 0; nb < ja.length; nb++) { const { type: jb, value: lb } = ja[nb], qb = pd[jb]; w(qb) || (va[qb] = parseInt(lb, 10)) } ja = va
            } else { { ja = ja.format(V).replace(/\u200E/g, ""); ja = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(ja); const [, nb, jb, lb, qb, Fb, Lb] = ja; ja = [lb, nb, jb, qb, Fb, Lb] } } const [Ga, Pa, Ta, $a, ab, eb] = ja; ja = e({ year: Ga, month: Pa, day: Ta, hour: 24 === $a ? 0 : $a, minute: ab, second: eb, millisecond: 0 }); V = +V; va = V % 1E3; return (ja - (V - (0 <= va ? va : 1E3 + va))) / 6E4
          } equals(V) { return "iana" === V.type && V.name === this.name } get isValid() { return this.valid }
        }
        let Mc = null; class Eb extends dc {
          static get utcInstance() { null === Mc && (Mc = new Eb(0)); return Mc } static instance(V) { return 0 === V ? Eb.utcInstance : new Eb(V) } static parseSpecifier(V) { return V && (V = V.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i)) ? new Eb(r(V[1], V[2])) : null } constructor(V) { super(); this.fixed = V } get type() { return "fixed" } get name() { return 0 === this.fixed ? "UTC" : `UTC${B(this.fixed, "narrow")}` } offsetName() { return this.name } formatOffset(V, ja) { return B(this.fixed, ja) } get isUniversal() { return !0 } offset() { return this.fixed } equals(V) {
            return "fixed" ===
              V.type && V.fixed === this.fixed
          } get isValid() { return !0 }
        } class ad extends dc { constructor(V) { super(); this.zoneName = V } get type() { return "invalid" } get name() { return this.zoneName } get isUniversal() { return !1 } offsetName() { return null } formatOffset() { return "" } offset() { return NaN } equals() { return !1 } get isValid() { return !1 } } let qd = () => Date.now(), tc = "system", uc = null, rd = null, sd = null, td; class zb {
          static get now() { return qd } static set now(V) { qd = V } static set defaultZone(V) { tc = V } static get defaultZone() { return F(tc, nd.instance) } static get defaultLocale() { return uc } static set defaultLocale(V) {
            uc =
            V
          } static get defaultNumberingSystem() { return rd } static set defaultNumberingSystem(V) { rd = V } static get defaultOutputCalendar() { return sd } static set defaultOutputCalendar(V) { sd = V } static get throwOnInvalid() { return td } static set throwOnInvalid(V) { td = V } static resetCaches() { vb.resetCache(); Ob.resetCache() }
        } let Hc = {}, Ic = {}, hc = {}, vc = null; class ud {
          constructor(V, ja, va) { this.padTo = va.padTo || 0; this.floor = va.floor || !1; ja || (ja = { useGrouping: !1 }, 0 < va.padTo && (ja.minimumIntegerDigits = va.padTo), this.inf = P(V, ja)) } format(V) {
            if (this.inf) return this.inf.format(this.floor ?
              Math.floor(V) : V); V = this.floor ? Math.floor(V) : t(V, 3); return h(V, this.padTo)
          }
        } class vd { constructor(V, ja, va) { this.opts = va; if (V.zone.isUniversal) { var Ga = V.offset / 60 * -1; Ga = 0 <= Ga ? `Etc/GMT+${Ga}` : `Etc/GMT${Ga}`; 0 !== V.offset && Ob.create(Ga).valid ? this.dt = V : (Ga = "UTC", this.dt = va.timeZoneName ? V : 0 === V.offset ? V : ua.fromMillis(V.ts + 6E4 * V.offset)) } else "system" === V.zone.type ? this.dt = V : (this.dt = V, Ga = V.zone.name); V = { ...this.opts }; Ga && (V.timeZone = Ga); this.dtf = K(ja, V) } format() { return this.dtf.format(this.dt.toJSDate()) } formatToParts() { return this.dtf.formatToParts(this.dt.toJSDate()) } resolvedOptions() { return this.dtf.resolvedOptions() } }
        class Zd { constructor(V, ja, va) { this.opts = { style: "long", ...va }; !ja && u() && (this.rtf = L(V, va)) } format(V, ja) { return this.rtf ? this.rtf.format(V, ja) : J(ja, V, this.opts.numeric, "long" !== this.opts.style) } formatToParts(V, ja) { return this.rtf ? this.rtf.formatToParts(V, ja) : [] } } class vb {
          static fromOpts(V) { return vb.create(V.locale, V.numberingSystem, V.outputCalendar, V.defaultToEN) } static create(V, ja, va, Ga = !1) {
            V = V || zb.defaultLocale; var Pa; (Pa = V) || (Ga ? Ga = "en-US" : (vc || (vc = (new Intl.DateTimeFormat).resolvedOptions().locale),
              Ga = vc), Pa = Ga); return new vb(Pa, ja || zb.defaultNumberingSystem, va || zb.defaultOutputCalendar, V)
          } static resetCache() { vc = null; Hc = {}; Ic = {}; hc = {} } static fromObject({ locale: V, numberingSystem: ja, outputCalendar: va } = {}) { return vb.create(V, ja, va) } constructor(V, ja, va, Ga) {
            var Pa = V.indexOf("-u-"); if (-1 === Pa) V = [V]; else { let eb; Pa = V.substring(0, Pa); try { eb = K(V).resolvedOptions() } catch (lb) { eb = K(Pa).resolvedOptions() } const { numberingSystem: nb, calendar: jb } = eb; V = [Pa, nb, jb] } const [Ta, $a, ab] = V; this.locale = Ta; this.numberingSystem =
              ja || $a || null; this.outputCalendar = va || ab || null; ja = this.locale; va = this.numberingSystem; if ((V = this.outputCalendar) || va) ja += "-u", V && (ja += `-ca-${V}`), va && (ja += `-nu-${va}`); this.intl = ja; this.weekdaysCache = { format: {}, standalone: {} }; this.monthsCache = { format: {}, standalone: {} }; this.meridiemCache = null; this.eraCache = {}; this.specifiedLocale = Ga; this.fastNumbersCached = null
          } get fastNumbers() {
            if (null == this.fastNumbersCached) {
              var V = this.numberingSystem && "latn" !== this.numberingSystem ? !1 : "latn" === this.numberingSystem ||
                !this.locale || this.locale.startsWith("en") || "latn" === (new Intl.DateTimeFormat(this.intl)).resolvedOptions().numberingSystem; this.fastNumbersCached = V
            } return this.fastNumbersCached
          } listingMode(V) { V = this.isEnglish(); const ja = (null === this.numberingSystem || "latn" === this.numberingSystem) && (null === this.outputCalendar || "gregory" === this.outputCalendar); return V && ja ? "en" : "intl" } clone(V) {
            return V && 0 !== Object.getOwnPropertyNames(V).length ? vb.create(V.locale || this.specifiedLocale, V.numberingSystem || this.numberingSystem,
              V.outputCalendar || this.outputCalendar, V.defaultToEN || !1) : this
          } redefaultToEN(V = {}) { return this.clone({ ...V, defaultToEN: !0 }) } redefaultToSystem(V = {}) { return this.clone({ ...V, defaultToEN: !1 }) } months(V, ja = !1, va = !0) { return I(this, V, va, D, () => { const Ga = ja ? { month: V, day: "numeric" } : { month: V }, Pa = ja ? "format" : "standalone"; this.monthsCache[Pa][V] || (this.monthsCache[Pa][V] = N(Ta => this.extract(Ta, Ga, "month"))); return this.monthsCache[Pa][V] }) } weekdays(V, ja = !1, va = !0) {
            return I(this, V, va, E, () => {
              const Ga = ja ? {
                weekday: V,
                year: "numeric", month: "long", day: "numeric"
              } : { weekday: V }, Pa = ja ? "format" : "standalone"; this.weekdaysCache[Pa][V] || (this.weekdaysCache[Pa][V] = G(Ta => this.extract(Ta, Ga, "weekday"))); return this.weekdaysCache[Pa][V]
            })
          } meridiems(V = !0) { return I(this, void 0, V, () => md, () => { if (!this.meridiemCache) { const ja = { hour: "numeric", hourCycle: "h12" }; this.meridiemCache = [ua.utc(2016, 11, 13, 9), ua.utc(2016, 11, 13, 19)].map(va => this.extract(va, ja, "dayperiod")) } return this.meridiemCache }) } eras(V, ja = !0) {
            return I(this, V, ja, H, () => {
              const va =
                { era: V }; this.eraCache[V] || (this.eraCache[V] = [ua.utc(-40, 1, 1), ua.utc(2017, 1, 1)].map(Ga => this.extract(Ga, va, "era"))); return this.eraCache[V]
            })
          } extract(V, ja, va) { return (V = this.dtFormatter(V, ja).formatToParts().find(Ga => Ga.type.toLowerCase() === va)) ? V.value : null } numberFormatter(V = {}) { return new ud(this.intl, V.forceSimple || this.fastNumbers, V) } dtFormatter(V, ja = {}) { return new vd(V, this.intl, ja) } relFormatter(V = {}) { return new Zd(this.intl, this.isEnglish(), V) } isEnglish() {
            return "en" === this.locale || "en-us" === this.locale.toLowerCase() ||
              (new Intl.DateTimeFormat(this.intl)).resolvedOptions().locale.startsWith("en-us")
          } equals(V) { return this.locale === V.locale && this.numberingSystem === V.numberingSystem && this.outputCalendar === V.outputCalendar }
        } const wd = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, Nc = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, xd = RegExp(`${Nc.source}${wd.source}?`), Oc = RegExp(`(?:T${xd.source})?`), $d = Q("weekYear", "weekNumber", "weekDay"), ae = Q("year", "ordinal"), yd = RegExp(`${Nc.source} ?(?:${wd.source}|(${ld.source}))?`), be =
          RegExp(`(?: ${yd.source})?`), ce = RegExp(`^T?${Nc.source}$`), de = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/, Ud = { GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 }, ee = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/,
          fe = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, ge = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, he = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/, ie = O(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Oc), je = O(/(\d{4})-?W(\d\d)(?:-?(\d))?/, Oc),
          ke = O(/(\d{4})-?(\d{3})/, Oc), le = O(xd), me = R(da, Y, fa), ne = R($d, Y, fa), oe = R(ae, Y, fa), pe = R(Y, fa), qe = R(Y), re = O(/(\d{4})-(\d\d)-(\d\d)/, be), se = O(yd), te = R(da, Y, fa, ha), ue = R(Y, fa, ha), zd = { weeks: { days: 7, hours: 168, minutes: 10080, seconds: 604800, milliseconds: 6048E5 }, days: { hours: 24, minutes: 1440, seconds: 86400, milliseconds: 864E5 }, hours: { minutes: 60, seconds: 3600, milliseconds: 36E5 }, minutes: { seconds: 60, milliseconds: 6E4 }, seconds: { milliseconds: 1E3 } }, ve = {
            years: {
              quarters: 4, months: 12, weeks: 52, days: 365, hours: 8760, minutes: 525600,
              seconds: 31536E3, milliseconds: 31536E6
            }, quarters: { months: 3, weeks: 13, days: 91, hours: 2184, minutes: 131040, seconds: 7862400, milliseconds: 78624E5 }, months: { weeks: 4, days: 30, hours: 720, minutes: 43200, seconds: 2592E3, milliseconds: 2592E6 }, ...zd
          }, we = {
            years: { quarters: 4, months: 12, weeks: 52.1775, days: 365.2425, hours: 8765.82, minutes: 525949.2, seconds: 31556952, milliseconds: 31556952E3 }, quarters: { months: 3, weeks: 13.044375, days: 91.310625, hours: 2191.455, minutes: 131487.3, seconds: 7889238, milliseconds: 7889238E3 }, months: {
              weeks: 30.436875 /
                7, days: 30.436875, hours: 730.485, minutes: 43829.1, seconds: 2629746, milliseconds: 2629746E3
            }, ...zd
          }, bc = "years quarters months weeks days hours minutes seconds milliseconds".split(" "), Vd = bc.slice(0).reverse(); class pb {
            constructor(V) { const ja = "longterm" === V.conversionAccuracy || !1; this.values = V.values; this.loc = V.loc || vb.create(); this.conversionAccuracy = ja ? "longterm" : "casual"; this.invalid = V.invalid || null; this.matrix = ja ? we : ve; this.isLuxonDuration = !0 } static fromMillis(V, ja) {
              return pb.fromObject({ milliseconds: V },
                ja)
            } static fromObject(V, ja = {}) { if (null == V || "object" !== typeof V) throw new gb(`Duration.fromObject: argument expected to be an object, got ${null === V ? "null" : typeof V}`); return new pb({ values: z(V, pb.normalizeUnit), loc: vb.fromObject(ja), conversionAccuracy: ja.conversionAccuracy }) } static fromDurationLike(V) { if (c(V)) return pb.fromMillis(V); if (pb.isDuration(V)) return V; if ("object" === typeof V) return pb.fromObject(V); throw new gb(`Unknown duration argument ${V} of type ${typeof V}`); } static fromISO(V, ja) {
              const [va] =
                S(V, [de, ka]); return va ? pb.fromObject(va, ja) : pb.invalid("unparsable", `the input "${V}" can't be parsed as ISO 8601`)
            } static fromISOTime(V, ja) { const [va] = S(V, [ce, qe]); return va ? pb.fromObject(va, ja) : pb.invalid("unparsable", `the input "${V}" can't be parsed as ISO 8601`) } static invalid(V, ja = null) { if (!V) throw new gb("need to specify a reason the Duration is invalid"); V = V instanceof Mb ? V : new Mb(V, ja); if (zb.throwOnInvalid) throw new Za(V); return new pb({ invalid: V }) } static normalizeUnit(V) {
              const ja = {
                year: "years",
                years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds"
              }[V ? V.toLowerCase() : V]; if (!ja) throw new fb(V); return ja
            } static isDuration(V) { return V && V.isLuxonDuration || !1 } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() {
              return this.isValid ? this.loc.numberingSystem :
                null
            } toFormat(V, ja = {}) { ja = { ...ja, floor: !1 !== ja.round && !1 !== ja.floor }; return this.isValid ? Gb.create(this.loc, ja).formatDurationFromString(this, V) : "Invalid Duration" } toObject() { return this.isValid ? { ...this.values } : {} } toISO() {
              if (!this.isValid) return null; let V = "P"; 0 !== this.years && (V += this.years + "Y"); if (0 !== this.months || 0 !== this.quarters) V += this.months + 3 * this.quarters + "M"; 0 !== this.weeks && (V += this.weeks + "W"); 0 !== this.days && (V += this.days + "D"); if (0 !== this.hours || 0 !== this.minutes || 0 !== this.seconds || 0 !== this.milliseconds) V +=
                "T"; 0 !== this.hours && (V += this.hours + "H"); 0 !== this.minutes && (V += this.minutes + "M"); if (0 !== this.seconds || 0 !== this.milliseconds) V += t(this.seconds + this.milliseconds / 1E3, 3) + "S"; "P" === V && (V += "T0S"); return V
            } toISOTime(V = {}) {
              if (!this.isValid) return null; var ja = this.toMillis(); if (0 > ja || 864E5 <= ja) return null; V = { suppressMilliseconds: !1, suppressSeconds: !1, includePrefix: !1, format: "extended", ...V }; ja = this.shiftTo("hours", "minutes", "seconds", "milliseconds"); let va = "basic" === V.format ? "hhmm" : "hh:mm"; V.suppressSeconds &&
                0 === ja.seconds && 0 === ja.milliseconds || (va += "basic" === V.format ? "ss" : ":ss", V.suppressMilliseconds && 0 === ja.milliseconds || (va += ".SSS")); ja = ja.toFormat(va); V.includePrefix && (ja = "T" + ja); return ja
            } toJSON() { return this.toISO() } toString() { return this.toISO() } toMillis() { return this.as("milliseconds") } valueOf() { return this.toMillis() } plus(V) {
              if (!this.isValid) return this; V = pb.fromDurationLike(V); const ja = {}; for (const va of bc) if (p(V.values, va) || p(this.values, va)) ja[va] = V.get(va) + this.get(va); return U(this, { values: ja },
                !0)
            } minus(V) { if (!this.isValid) return this; V = pb.fromDurationLike(V); return this.plus(V.negate()) } mapUnits(V) { if (!this.isValid) return this; const ja = {}; for (const va of Object.keys(this.values)) ja[va] = A(V(this.values[va], va)); return U(this, { values: ja }, !0) } get(V) { return this[pb.normalizeUnit(V)] } set(V) { if (!this.isValid) return this; V = { ...this.values, ...z(V, pb.normalizeUnit) }; return U(this, { values: V }) } reconfigure({ locale: V, numberingSystem: ja, conversionAccuracy: va } = {}) {
              V = { loc: this.loc.clone({ locale: V, numberingSystem: ja }) };
              va && (V.conversionAccuracy = va); return U(this, V)
            } as(V) { return this.isValid ? this.shiftTo(V).get(V) : NaN } normalize() { if (!this.isValid) return this; const V = this.toObject(); Z(this.matrix, V); return U(this, { values: V }, !0) } shiftTo(...V) {
              if (!this.isValid || 0 === V.length) return this; V = V.map(Ta => pb.normalizeUnit(Ta)); const ja = {}, va = {}, Ga = this.toObject(); let Pa; for (const Ta of bc) if (0 <= V.indexOf(Ta)) {
                Pa = Ta; let $a = 0; for (const eb in va) $a += this.matrix[eb][Ta] * va[eb], va[eb] = 0; c(Ga[Ta]) && ($a += Ga[Ta]); const ab = Math.trunc($a);
                ja[Ta] = ab; va[Ta] = $a - ab; for (const eb in Ga) bc.indexOf(eb) > bc.indexOf(Ta) && X(this.matrix, Ga, eb, ja, Ta)
              } else c(Ga[Ta]) && (va[Ta] = Ga[Ta]); for (const Ta in va) 0 !== va[Ta] && (ja[Pa] += Ta === Pa ? va[Ta] : va[Ta] / this.matrix[Pa][Ta]); return U(this, { values: ja }, !0).normalize()
            } negate() { if (!this.isValid) return this; const V = {}; for (const ja of Object.keys(this.values)) V[ja] = -this.values[ja]; return U(this, { values: V }, !0) } get years() { return this.isValid ? this.values.years || 0 : NaN } get quarters() {
              return this.isValid ? this.values.quarters ||
                0 : NaN
            } get months() { return this.isValid ? this.values.months || 0 : NaN } get weeks() { return this.isValid ? this.values.weeks || 0 : NaN } get days() { return this.isValid ? this.values.days || 0 : NaN } get hours() { return this.isValid ? this.values.hours || 0 : NaN } get minutes() { return this.isValid ? this.values.minutes || 0 : NaN } get seconds() { return this.isValid ? this.values.seconds || 0 : NaN } get milliseconds() { return this.isValid ? this.values.milliseconds || 0 : NaN } get isValid() { return null === this.invalid } get invalidReason() {
              return this.invalid ?
                this.invalid.reason : null
            } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } equals(V) { if (!this.isValid || !V.isValid || !this.loc.equals(V.loc)) return !1; for (const Ga of bc) { var ja = this.values[Ga]; var va = V.values[Ga]; ja = void 0 === ja || 0 === ja ? void 0 === va || 0 === va : ja === va; if (!ja) return !1 } return !0 }
        } class yb {
          constructor(V) { this.s = V.start; this.e = V.end; this.invalid = V.invalid || null; this.isLuxonInterval = !0 } static invalid(V, ja = null) {
            if (!V) throw new gb("need to specify a reason the Interval is invalid");
            V = V instanceof Mb ? V : new Mb(V, ja); if (zb.throwOnInvalid) throw new Ma(V); return new yb({ invalid: V })
          } static fromDateTimes(V, ja) { V = wb(V); ja = wb(ja); var va = V && V.isValid ? ja && ja.isValid ? ja < V ? yb.invalid("end before start", `The end of an interval must be after its start, but you had start=${V.toISO()} and end=${ja.toISO()}`) : null : yb.invalid("missing or invalid end") : yb.invalid("missing or invalid start"); return null == va ? new yb({ start: V, end: ja }) : va } static after(V, ja) {
            ja = pb.fromDurationLike(ja); V = wb(V); return yb.fromDateTimes(V,
              V.plus(ja))
          } static before(V, ja) { ja = pb.fromDurationLike(ja); V = wb(V); return yb.fromDateTimes(V.minus(ja), V) } static fromISO(V, ja) {
            const [va, Ga] = (V || "").split("/", 2); if (va && Ga) { let $a; try { var Pa = ua.fromISO(va, ja); $a = Pa.isValid } catch (eb) { $a = !1 } let ab; try { var Ta = ua.fromISO(Ga, ja); ab = Ta.isValid } catch (eb) { ab = !1 } if ($a && ab) return yb.fromDateTimes(Pa, Ta); if ($a) { if (Ta = pb.fromISO(Ga, ja), Ta.isValid) return yb.after(Pa, Ta) } else if (ab && (Pa = pb.fromISO(va, ja), Pa.isValid)) return yb.before(Ta, Pa) } return yb.invalid("unparsable",
              `the input "${V}" can't be parsed as ISO 8601`)
          } static isInterval(V) { return V && V.isLuxonInterval || !1 } get start() { return this.isValid ? this.s : null } get end() { return this.isValid ? this.e : null } get isValid() { return null === this.invalidReason } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } length(V = "milliseconds") { return this.isValid ? this.toDuration(...[V]).get(V) : NaN } count(V = "milliseconds") {
            if (!this.isValid) return NaN;
            const ja = this.start.startOf(V), va = this.end.startOf(V); return Math.floor(va.diff(ja, V).get(V)) + 1
          } hasSame(V) { return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, V) : !1 } isEmpty() { return this.s.valueOf() === this.e.valueOf() } isAfter(V) { return this.isValid ? this.s > V : !1 } isBefore(V) { return this.isValid ? this.e <= V : !1 } contains(V) { return this.isValid ? this.s <= V && this.e > V : !1 } set({ start: V, end: ja } = {}) { return this.isValid ? yb.fromDateTimes(V || this.s, ja || this.e) : this } splitAt(...V) {
            if (!this.isValid) return [];
            V = V.map(wb).filter(Ta => this.contains(Ta)).sort(); const ja = []; let { s: va } = this, Ga = 0; for (; va < this.e;) { var Pa = V[Ga] || this.e; Pa = +Pa > +this.e ? this.e : Pa; ja.push(yb.fromDateTimes(va, Pa)); va = Pa; Ga += 1 } return ja
          } splitBy(V) { V = pb.fromDurationLike(V); if (!this.isValid || !V.isValid || 0 === V.as("milliseconds")) return []; let { s: ja } = this, va = 1; const Ga = []; for (; ja < this.e;) { var Pa = this.start.plus(V.mapUnits(Ta => Ta * va)); Pa = +Pa > +this.e ? this.e : Pa; Ga.push(yb.fromDateTimes(ja, Pa)); ja = Pa; va += 1 } return Ga } divideEqually(V) {
            return this.isValid ?
              this.splitBy(this.length() / V).slice(0, V) : []
          } overlaps(V) { return this.e > V.s && this.s < V.e } abutsStart(V) { return this.isValid ? +this.e === +V.s : !1 } abutsEnd(V) { return this.isValid ? +V.e === +this.s : !1 } engulfs(V) { return this.isValid ? this.s <= V.s && this.e >= V.e : !1 } equals(V) { return this.isValid && V.isValid ? this.s.equals(V.s) && this.e.equals(V.e) : !1 } intersection(V) { if (!this.isValid) return this; const ja = this.s > V.s ? this.s : V.s; V = this.e < V.e ? this.e : V.e; return ja >= V ? null : yb.fromDateTimes(ja, V) } union(V) {
            return this.isValid ? yb.fromDateTimes(this.s <
              V.s ? this.s : V.s, this.e > V.e ? this.e : V.e) : this
          } static merge(V) { const [ja, va] = V.sort((Ga, Pa) => Ga.s - Pa.s).reduce(([Ga, Pa], Ta) => Pa ? Pa.overlaps(Ta) || Pa.abutsStart(Ta) ? [Ga, Pa.union(Ta)] : [Ga.concat([Pa]), Ta] : [Ga, Ta], [[], null]); va && ja.push(va); return ja } static xor(V) {
            let ja = null, va = 0; const Ga = []; V = V.map(Pa => [{ time: Pa.s, type: "s" }, { time: Pa.e, type: "e" }]); V = Array.prototype.concat(...V).sort((Pa, Ta) => Pa.time - Ta.time); for (const Pa of V) va += "s" === Pa.type ? 1 : -1, 1 === va ? ja = Pa.time : (ja && +ja !== +Pa.time && Ga.push(yb.fromDateTimes(ja,
              Pa.time)), ja = null); return yb.merge(Ga)
          } difference(...V) { return yb.xor([this].concat(V)).map(ja => this.intersection(ja)).filter(ja => ja && !ja.isEmpty()) } toString() { return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : "Invalid Interval" } toISO(V) { return this.isValid ? `${this.s.toISO(V)}/${this.e.toISO(V)}` : "Invalid Interval" } toISODate() { return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : "Invalid Interval" } toISOTime(V) {
            return this.isValid ? `${this.s.toISOTime(V)}/${this.e.toISOTime(V)}` :
              "Invalid Interval"
          } toFormat(V, { separator: ja = " \u2013 " } = {}) { return this.isValid ? `${this.s.toFormat(V)}${ja}${this.e.toFormat(V)}` : "Invalid Interval" } toDuration(V, ja) { return this.isValid ? this.e.diff(this.s, V, ja) : pb.invalid(this.invalidReason) } mapEndpoints(V) { return yb.fromDateTimes(V(this.s), V(this.e)) }
        } class wc {
          static hasDST(V = zb.defaultZone) { const ja = ua.now().setZone(V).set({ month: 12 }); return !V.isUniversal && ja.offset !== ja.set({ month: 6 }).offset } static isValidIANAZone(V) {
            return Ob.isValidSpecifier(V) &&
              Ob.isValidZone(V)
          } static normalizeZone(V) { return F(V, zb.defaultZone) } static months(V = "long", { locale: ja = null, numberingSystem: va = null, locObj: Ga = null, outputCalendar: Pa = "gregory" } = {}) { return (Ga || vb.create(ja, va, Pa)).months(V) } static monthsFormat(V = "long", { locale: ja = null, numberingSystem: va = null, locObj: Ga = null, outputCalendar: Pa = "gregory" } = {}) { return (Ga || vb.create(ja, va, Pa)).months(V, !0) } static weekdays(V = "long", { locale: ja = null, numberingSystem: va = null, locObj: Ga = null } = {}) { return (Ga || vb.create(ja, va, null)).weekdays(V) } static weekdaysFormat(V =
            "long", { locale: ja = null, numberingSystem: va = null, locObj: Ga = null } = {}) { return (Ga || vb.create(ja, va, null)).weekdays(V, !0) } static meridiems({ locale: V = null } = {}) { return vb.create(V).meridiems() } static eras(V = "short", { locale: ja = null } = {}) { return vb.create(ja, null, "gregory").eras(V) } static features() { return { relative: u() } }
        } const Jc = {
          arab: "[\u0660-\u0669]", arabext: "[\u06f0-\u06f9]", bali: "[\u1b50-\u1b59]", beng: "[\u09e6-\u09ef]", deva: "[\u0966-\u096f]", fullwide: "[\uff10-\uff19]", gujr: "[\u0ae6-\u0aef]", hanidec: "[\u3007|\u4e00|\u4e8c|\u4e09|\u56db|\u4e94|\u516d|\u4e03|\u516b|\u4e5d]",
          khmr: "[\u17e0-\u17e9]", knda: "[\u0ce6-\u0cef]", laoo: "[\u0ed0-\u0ed9]", limb: "[\u1946-\u194f]", mlym: "[\u0d66-\u0d6f]", mong: "[\u1810-\u1819]", mymr: "[\u1040-\u1049]", orya: "[\u0b66-\u0b6f]", tamldec: "[\u0be6-\u0bef]", telu: "[\u0c66-\u0c6f]", thai: "[\u0e50-\u0e59]", tibt: "[\u0f20-\u0f29]", latn: "\\d"
        }, bd = {
          arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430,
            3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881]
        }, Wd = Jc.hanidec.replace(/[\[|\]]/g, "").split(""), cd = `( |${String.fromCharCode(160)})`, Kc = new RegExp(cd, "g"), dd = {
          year: { "2-digit": "yy", numeric: "yyyyy" }, month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" }, day: { numeric: "d", "2-digit": "dd" }, weekday: { short: "EEE", long: "EEEE" }, dayperiod: "a", dayPeriod: "a", hour: { numeric: "h", "2-digit": "hh" }, minute: { numeric: "m", "2-digit": "mm" },
          second: { numeric: "s", "2-digit": "ss" }
        }; let ic = null; const kc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], jc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], oa = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, xc = { weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, Pb = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, lc = "year month day hour minute second millisecond".split(" "), Xa = "weekYear weekNumber weekday hour minute second millisecond".split(" "), Pc = "year ordinal hour minute second millisecond".split(" ");
        class ua {
          constructor(V) {
            const ja = V.zone || zb.defaultZone; let va = V.invalid || (Number.isNaN(V.ts) ? new Mb("invalid input") : null) || (ja.isValid ? null : Wa(ja)); this.ts = w(V.ts) ? zb.now() : V.ts; let Ga = null; var Pa = null; va || (V.old && V.old.ts === this.ts && V.old.zone.equals(ja) ? [Ga, Pa] = [V.old.c, V.old.o] : (Pa = ja.offset(this.ts), Ga = Sa(this.ts, Pa), Ga = (va = Number.isNaN(Ga.year) ? new Mb("invalid input") : null) ? null : Ga, Pa = va ? null : Pa)); this._zone = ja; this.loc = V.loc || vb.create(); this.invalid = va; this.weekData = null; this.c = Ga; this.o =
              Pa; this.isLuxonDateTime = !0
          } static now() { return new ua({}) } static local() { const [V, ja] = ob(arguments), [va, Ga, Pa, Ta, $a, ab, eb] = ja; return tb({ year: va, month: Ga, day: Pa, hour: Ta, minute: $a, second: ab, millisecond: eb }, V) } static utc() { const [V, ja] = ob(arguments), [va, Ga, Pa, Ta, $a, ab, eb] = ja; V.zone = Eb.utcInstance; return tb({ year: va, month: Ga, day: Pa, hour: Ta, minute: $a, second: ab, millisecond: eb }, V) } static fromJSDate(V, ja = {}) {
            V = "[object Date]" === Object.prototype.toString.call(V) ? V.valueOf() : NaN; if (Number.isNaN(V)) return ua.invalid("invalid input");
            const va = F(ja.zone, zb.defaultZone); return va.isValid ? new ua({ ts: V, zone: va, loc: vb.fromObject(ja) }) : ua.invalid(Wa(va))
          } static fromMillis(V, ja = {}) { if (c(V)) return -864E13 > V || 864E13 < V ? ua.invalid("Timestamp out of range") : new ua({ ts: V, zone: F(ja.zone, zb.defaultZone), loc: vb.fromObject(ja) }); throw new gb(`fromMillis requires a numerical input, but received a ${typeof V} with value ${V}`); } static fromSeconds(V, ja = {}) {
            if (c(V)) return new ua({ ts: 1E3 * V, zone: F(ja.zone, zb.defaultZone), loc: vb.fromObject(ja) }); throw new gb("fromSeconds requires a numerical input");
          } static fromObject(V, ja = {}) {
            V = V || {}; var va = F(ja.zone, zb.defaultZone); if (!va.isValid) return ua.invalid(Wa(va)); var Ga = zb.now(); const Pa = va.offset(Ga), Ta = z(V, mb); var $a = !w(Ta.ordinal), ab = !w(Ta.year), eb = !w(Ta.month) || !w(Ta.day); ab = ab || eb; var nb = Ta.weekYear || Ta.weekNumber; ja = vb.fromObject(ja); if ((ab || $a) && nb) throw new cb("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (eb && $a) throw new cb("Can't mix ordinal dates with month/day"); eb = nb || Ta.weekday && !ab; let jb = Sa(Ga, Pa); eb ? (Ga =
              Xa, nb = xc, jb = ca(jb)) : $a ? (Ga = Pc, nb = Pb, jb = Da(jb)) : (Ga = lc, nb = oa); let lb = !1; for (var qb of Ga) w(Ta[qb]) ? Ta[qb] = lb ? nb[qb] : jb[qb] : lb = !0; eb ? (qb = q(Ta.weekYear), Ga = l(Ta.weekNumber, 1, g(Ta.weekYear)), nb = l(Ta.weekday, 1, 7), qb = qb ? Ga ? nb ? !1 : sa("weekday", Ta.weekday) : sa("week", Ta.week) : sa("weekYear", Ta.weekYear)) : $a ? (qb = q(Ta.year), Ga = l(Ta.ordinal, 1, v(Ta.year) ? 366 : 365), qb = qb ? Ga ? !1 : sa("ordinal", Ta.ordinal) : sa("year", Ta.year)) : qb = xa(Ta); if (qb = qb || Qa(Ta)) return ua.invalid(qb); $a = eb ? qa(Ta) : $a ? na(Ta) : Ta; const [Fb, Lb] = Va($a,
                Pa, va); va = new ua({ ts: Fb, zone: va, o: Lb, loc: ja }); return Ta.weekday && ab && V.weekday !== va.weekday ? ua.invalid("mismatched weekday", `you can't specify both a weekday of ${Ta.weekday} and a date of ${va.toISO()}`) : va
          } static fromISO(V, ja = {}) { const [va, Ga] = S(V, [ie, me], [je, ne], [ke, oe], [le, pe]); return bb(va, Ga, ja, "ISO 8601", V) } static fromRFC2822(V, ja = {}) { const [va, Ga] = S(V.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim(), [ee, ba]); return bb(va, Ga, ja, "RFC 2822", V) } static fromHTTP(V, ja = {}) {
            const [va,
              Ga] = S(V, [fe, aa], [ge, aa], [he, W]); return bb(va, Ga, ja, "HTTP", ja)
          } static fromFormat(V, ja, va = {}) { if (w(V) || w(ja)) throw new gb("fromFormat requires an input string and a format"); const { locale: Ga = null, numberingSystem: Pa = null } = va; var Ta = vb.fromOpts({ locale: Ga, numberingSystem: Pa, defaultToEN: !0 }); { const { result: nb, zone: jb, invalidReason: lb } = Ba(Ta, V, ja); Ta = [nb, jb, lb] } const [$a, ab, eb] = Ta; return eb ? ua.invalid(eb) : bb($a, ab, va, `format ${ja}`, V) } static fromString(V, ja, va = {}) { return ua.fromFormat(V, ja, va) } static fromSQL(V,
            ja = {}) { const [va, Ga] = S(V, [re, te], [se, ue]); return bb(va, Ga, ja, "SQL", V) } static invalid(V, ja = null) { if (!V) throw new gb("need to specify a reason the DateTime is invalid"); V = V instanceof Mb ? V : new Mb(V, ja); if (zb.throwOnInvalid) throw new La(V); return new ua({ invalid: V }) } static isDateTime(V) { return V && V.isLuxonDateTime || !1 } get(V) { return this[V] } get isValid() { return null === this.invalid } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() {
              return this.invalid ? this.invalid.explanation :
                null
            } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } get outputCalendar() { return this.isValid ? this.loc.outputCalendar : null } get zone() { return this._zone } get zoneName() { return this.isValid ? this.zone.name : null } get year() { return this.isValid ? this.c.year : NaN } get quarter() { return this.isValid ? Math.ceil(this.c.month / 3) : NaN } get month() { return this.isValid ? this.c.month : NaN } get day() { return this.isValid ? this.c.day : NaN } get hour() {
              return this.isValid ?
                this.c.hour : NaN
            } get minute() { return this.isValid ? this.c.minute : NaN } get second() { return this.isValid ? this.c.second : NaN } get millisecond() { return this.isValid ? this.c.millisecond : NaN } get weekYear() { return this.isValid ? Ra(this).weekYear : NaN } get weekNumber() { return this.isValid ? Ra(this).weekNumber : NaN } get weekday() { return this.isValid ? Ra(this).weekday : NaN } get ordinal() { return this.isValid ? Da(this.c).ordinal : NaN } get monthShort() { return this.isValid ? wc.months("short", { locObj: this.loc })[this.month - 1] : null } get monthLong() {
              return this.isValid ?
                wc.months("long", { locObj: this.loc })[this.month - 1] : null
            } get weekdayShort() { return this.isValid ? wc.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null } get weekdayLong() { return this.isValid ? wc.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null } get offset() { return this.isValid ? +this.o : NaN } get offsetNameShort() { return this.isValid ? this.zone.offsetName(this.ts, { format: "short", locale: this.locale }) : null } get offsetNameLong() {
              return this.isValid ? this.zone.offsetName(this.ts, { format: "long", locale: this.locale }) :
                null
            } get isOffsetFixed() { return this.isValid ? this.zone.isUniversal : null } get isInDST() { return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1 }).offset || this.offset > this.set({ month: 5 }).offset } get isInLeapYear() { return v(this.year) } get daysInMonth() { return m(this.year, this.month) } get daysInYear() { return this.isValid ? v(this.year) ? 366 : 365 : NaN } get weeksInWeekYear() { return this.isValid ? g(this.weekYear) : NaN } resolvedLocaleOptions(V = {}) {
              const { locale: ja, numberingSystem: va, calendar: Ga } = Gb.create(this.loc.clone(V),
                V).resolvedOptions(this); return { locale: ja, numberingSystem: va, outputCalendar: Ga }
            } toUTC(V = 0, ja = {}) { return this.setZone(Eb.instance(V), ja) } toLocal() { return this.setZone(zb.defaultZone) } setZone(V, { keepLocalTime: ja = !1, keepCalendarTime: va = !1 } = {}) { V = F(V, zb.defaultZone); if (V.equals(this.zone)) return this; if (V.isValid) { let Ga = this.ts; if (ja || va) ja = V.offset(this.ts), va = this.toObject(), [Ga] = Va(va, ja, V); return ta(this, { ts: Ga, zone: V }) } return ua.invalid(Wa(V)) } reconfigure({ locale: V, numberingSystem: ja, outputCalendar: va } =
              {}) { V = this.loc.clone({ locale: V, numberingSystem: ja, outputCalendar: va }); return ta(this, { loc: V }) } setLocale(V) { return this.reconfigure({ locale: V }) } set(V) {
                if (!this.isValid) return this; V = z(V, mb); var ja = !w(V.weekYear) || !w(V.weekNumber) || !w(V.weekday); const va = !w(V.ordinal), Ga = !w(V.year), Pa = !w(V.month) || !w(V.day), Ta = V.weekYear || V.weekNumber; if ((Ga || Pa || va) && Ta) throw new cb("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (Pa && va) throw new cb("Can't mix ordinal dates with month/day");
                ja ? ja = qa({ ...ca(this.c), ...V }) : w(V.ordinal) ? (ja = { ...this.toObject(), ...V }, w(V.day) && (ja.day = Math.min(m(ja.year, ja.month), ja.day))) : ja = na({ ...Da(this.c), ...V }); const [$a, ab] = Va(ja, this.o, this.zone); return ta(this, { ts: $a, o: ab })
              } plus(V) { if (!this.isValid) return this; V = pb.fromDurationLike(V); return ta(this, Ya(this, V)) } minus(V) { if (!this.isValid) return this; V = pb.fromDurationLike(V).negate(); return ta(this, Ya(this, V)) } startOf(V) {
                if (!this.isValid) return this; const ja = {}; V = pb.normalizeUnit(V); switch (V) {
                  case "years": ja.month =
                    1; case "quarters": case "months": ja.day = 1; case "weeks": case "days": ja.hour = 0; case "hours": ja.minute = 0; case "minutes": ja.second = 0; case "seconds": ja.millisecond = 0
                }"weeks" === V && (ja.weekday = 1); "quarters" === V && (ja.month = 3 * (Math.ceil(this.month / 3) - 1) + 1); return this.set(ja)
              } endOf(V) { return this.isValid ? this.plus({ [V]: 1 }).startOf(V).minus(1) : this } toFormat(V, ja = {}) { return this.isValid ? Gb.create(this.loc.redefaultToEN(ja)).formatDateTimeFromString(this, V) : "Invalid DateTime" } toLocaleString(V = Bb, ja = {}) {
                return this.isValid ?
                  Gb.create(this.loc.clone(ja), V).formatDateTime(this) : "Invalid DateTime"
              } toLocaleParts(V = {}) { return this.isValid ? Gb.create(this.loc.clone(V), V).formatDateTimeParts(this) : [] } toISO(V = {}) { return this.isValid ? `${this.toISODate(V)}T${this.toISOTime(V)}` : null } toISODate({ format: V = "extended" } = {}) { V = "basic" === V ? "yyyyMMdd" : "yyyy-MM-dd"; 9999 < this.year && (V = "+" + V); return hb(this, V) } toISOWeekDate() { return hb(this, "kkkk-'W'WW-c") } toISOTime({ suppressMilliseconds: V = !1, suppressSeconds: ja = !1, includeOffset: va = !0, includePrefix: Ga =
                !1, format: Pa = "extended" } = {}) { return ib(this, { suppressSeconds: ja, suppressMilliseconds: V, includeOffset: va, includePrefix: Ga, format: Pa }) } toRFC2822() { return hb(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1) } toHTTP() { return hb(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'") } toSQLDate() { return hb(this, "yyyy-MM-dd") } toSQLTime({ includeOffset: V = !0, includeZone: ja = !1 } = {}) { return ib(this, { includeOffset: V, includeZone: ja, spaceZone: !0 }) } toSQL(V = {}) { return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(V)}` : null } toString() {
                  return this.isValid ?
                    this.toISO() : "Invalid DateTime"
                } valueOf() { return this.toMillis() } toMillis() { return this.isValid ? this.ts : NaN } toSeconds() { return this.isValid ? this.ts / 1E3 : NaN } toJSON() { return this.toISO() } toBSON() { return this.toJSDate() } toObject(V = {}) { if (!this.isValid) return {}; const ja = { ...this.c }; V.includeConfig && (ja.outputCalendar = this.outputCalendar, ja.numberingSystem = this.loc.numberingSystem, ja.locale = this.loc.locale); return ja } toJSDate() { return new Date(this.isValid ? this.ts : NaN) } diff(V, ja = "milliseconds", va = {}) {
                  if (!this.isValid ||
                    !V.isValid) return pb.invalid("created by diffing an invalid DateTime"); va = { locale: this.locale, numberingSystem: this.numberingSystem, ...va }; const Ga = (Array.isArray(ja) ? ja : [ja]).map(pb.normalizeUnit); ja = V.valueOf() > this.valueOf(); V = ma(ja ? this : V, ja ? V : this, Ga, va); return ja ? V.negate() : V
                } diffNow(V = "milliseconds", ja = {}) { return this.diff(ua.now(), V, ja) } until(V) { return this.isValid ? yb.fromDateTimes(this, V) : this } hasSame(V, ja) {
                  if (!this.isValid) return !1; const va = V.valueOf(); V = this.setZone(V.zone, { keepLocalTime: !0 });
                  return V.startOf(ja) <= va && va <= V.endOf(ja)
                } equals(V) { return this.isValid && V.isValid && this.valueOf() === V.valueOf() && this.zone.equals(V.zone) && this.loc.equals(V.loc) } toRelative(V = {}) { if (!this.isValid) return null; const ja = V.base || ua.fromObject({}, { zone: this.zone }), va = V.padding ? this < ja ? -V.padding : V.padding : 0; let Ga = "years months days hours minutes seconds".split(" "), Pa = V.unit; Array.isArray(V.unit) && (Ga = V.unit, Pa = void 0); return rb(ja, this.plus(va), { ...V, numeric: "always", units: Ga, unit: Pa }) } toRelativeCalendar(V =
                  {}) { return this.isValid ? rb(V.base || ua.fromObject({}, { zone: this.zone }), this, { ...V, numeric: "auto", units: ["years", "months", "days"], calendary: !0 }) : null } static min(...V) { if (!V.every(ua.isDateTime)) throw new gb("min requires all arguments be DateTimes"); return y(V, ja => ja.valueOf(), Math.min) } static max(...V) { if (!V.every(ua.isDateTime)) throw new gb("max requires all arguments be DateTimes"); return y(V, ja => ja.valueOf(), Math.max) } static fromFormatExplain(V, ja, va = {}) {
                    const { locale: Ga = null, numberingSystem: Pa =
                      null } = va; va = vb.fromOpts({ locale: Ga, numberingSystem: Pa, defaultToEN: !0 }); return Ba(va, V, ja)
                  } static fromStringExplain(V, ja, va = {}) { return ua.fromFormatExplain(V, ja, va) } static get DATE_SHORT() { return Bb } static get DATE_MED() { return fc } static get DATE_MED_WITH_WEEKDAY() { return mc } static get DATE_FULL() { return $b } static get DATE_HUGE() { return ac } static get TIME_SIMPLE() { return Vb } static get TIME_WITH_SECONDS() { return gc } static get TIME_WITH_SHORT_OFFSET() { return nc } static get TIME_WITH_LONG_OFFSET() { return Ab } static get TIME_24_SIMPLE() { return oc } static get TIME_24_WITH_SECONDS() { return xb } static get TIME_24_WITH_SHORT_OFFSET() { return Nb } static get TIME_24_WITH_LONG_OFFSET() { return pc } static get DATETIME_SHORT() { return qc } static get DATETIME_SHORT_WITH_SECONDS() { return ed } static get DATETIME_MED() { return fd } static get DATETIME_MED_WITH_SECONDS() { return gd } static get DATETIME_MED_WITH_WEEKDAY() { return Xd } static get DATETIME_FULL() { return hd } static get DATETIME_FULL_WITH_SECONDS() { return id } static get DATETIME_HUGE() { return jd } static get DATETIME_HUGE_WITH_SECONDS() { return kd }
        }
        a.DateTime = ua
      })
    }, "esri/core/number": function () {
      define(["exports", "./string", "../intl/locale"], function (a, w, c) {
        function q(d) { d || (d = c.getLocale()); let f = d in l; if (!f) { const e = d.split("-"); 1 < e.length && e[0] in l && (d = e[0], f = !0); f || (d = "en") } const [t, v, m = "#,##0.###"] = l[d]; return { decimal: t, group: v, pattern: m } } function u(d, f, t) {
          t = t || {}; !0 === t.places && (t.places = 0); Infinity === t.places && (t.places = 6); f = f.split("."); var v = "string" === typeof t.places && t.places.indexOf(","), m = t.places; v ? m = t.places.substring(v + 1) : 0 <=
            m || (m = (f[1] || []).length); 0 > t.round || (d = Number(d.toFixed(Number(m)))); d = String(Math.abs(d)).split("."); const e = d[1] || ""; f[1] || t.places ? (v && (t.places = t.places.substring(0, v)), v = void 0 !== t.places ? t.places : f[1] && f[1].lastIndexOf("0") + 1, v > e.length && (d[1] = e.padEnd(Number(v), "0")), m < e.length && (d[1] = e.substr(0, Number(m)))) : d[1] && d.pop(); m = f[0].replace(",", ""); v = m.indexOf("0"); -1 !== v && (v = m.length - v, v > d[0].length && (d[0] = d[0].padStart(v, "0")), -1 === m.indexOf("#") && (d[0] = d[0].substr(d[0].length - v))); m = f[0].lastIndexOf(",");
          let g, x; -1 !== m && (g = f[0].length - m - 1, f = f[0].substr(0, m), m = f.lastIndexOf(","), -1 !== m && (x = f.length - m - 1)); f = []; for (m = d[0]; m;)v = m.length - g, f.push(0 < v ? m.substr(v) : m), m = 0 < v ? m.slice(0, v) : "", x && (g = x, x = void 0); d[0] = f.reverse().join(t.group || ","); return d.join(t.decimal || ".")
        } function y(d) {
          d = d || {}; var f = q(d.locale); const t = d.pattern || f.pattern, v = f.group, m = f.decimal; let e = 1; if (-1 !== t.indexOf("%")) e /= 100; else if (-1 !== t.indexOf("\u2030")) e /= 1E3; else if (-1 !== t.indexOf("\u00a4")) throw Error("currency notation not supported");
          f = t.split(";"); 1 === f.length && f.push("-" + f[0]); return {
            regexp: b(f, function (g) {
              g = "(?:" + w.escapeRegExpString(g, ".") + ")"; return g.replace(h, function (x) {
                const k = { signed: !1, separator: d.strict ? v : [v, ""], fractional: d.fractional, decimal: m, exponent: !1 }; x = x.split("."); let r = d.places; 1 === x.length && 1 !== e && (x[1] = "###"); 1 === x.length || 0 === r ? k.fractional = !1 : (void 0 === r && (r = d.pattern ? x[1].lastIndexOf("0") + 1 : Infinity), r && null == d.fractional && (k.fractional = !0), !d.places && r < x[1].length && (r += "," + x[1].length), k.places = r);
                x = x[0].split(","); 1 < x.length && (k.groupSize = x.pop().length, 1 < x.length && (k.groupSize2 = x.pop().length)); return "(" + n(k) + ")"
              })
            }, !0).replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: v, decimal: m, factor: e
          }
        } function n(d) {
          d = d || {}; "places" in d || (d.places = Infinity); "string" !== typeof d.decimal && (d.decimal = "."); "fractional" in d && !/^0/.test(String(d.places)) || (d.fractional = [!0, !1]); "exponent" in d || (d.exponent = [!0, !1]); "eSigned" in d || (d.eSigned = [!0, !1]); var f = p(d); const t = b(d.fractional, function (m) {
            let e = ""; m && 0 !== d.places &&
              (e = "\\" + d.decimal, e = Infinity === d.places ? "(?:" + e + "\\d+)?" : e + ("\\d{" + d.places + "}")); return e
          }, !0), v = b(d.exponent, function (m) { return m ? "([eE]" + p({ signed: d.eSigned }) + ")" : "" }); f += t; t && (f = "(?:(?:" + f + ")|(?:" + t + "))"); return f + v
        } function p(d) {
          d = d || {}; "signed" in d || (d.signed = [!0, !1]); "separator" in d ? "groupSize" in d || (d.groupSize = 3) : d.separator = ""; const f = b(d.signed, function (v) { return v ? "[-+]" : "" }, !0), t = b(d.separator, function (v) {
            if (!v) return "(?:\\d+)"; v = w.escapeRegExpString(v); " " === v ? v = "\\s" : "\u00a0" === v &&
              (v = "\\s\\xa0"); const m = d.groupSize, e = d.groupSize2; return e ? (v = "(?:0|[1-9]\\d{0," + (e - 1) + "}(?:[" + v + "]\\d{" + e + "})*[" + v + "]\\d{" + m + "})", 0 < m - e ? "(?:" + v + "|(?:0|[1-9]\\d{0," + (m - 1) + "}))" : v) : "(?:0|[1-9]\\d{0," + (m - 1) + "}(?:[" + v + "]\\d{" + m + "})*)"
          }, !0); return f + t
        } const l = {
          ar: [".", ","], bg: [",", "\u00a0"], bs: [",", "."], ca: [",", "."], cs: [",", "\u00a0"], da: [",", "."], de: [",", "."], "de-ch": [".", "\u2019"], el: [",", "."], en: [".", ","], "en-au": [".", ","], es: [",", "."], "es-mx": [".", ","], et: [",", "\u00a0"], fi: [",", "\u00a0"], fr: [",", "\u202f"],
          "fr-ch": [",", "\u202f"], he: [".", ","], hi: [".", ",", "#,##,##0.###"], hr: [",", "."], hu: [",", "\u00a0"], id: [",", "."], it: [",", "."], "it-ch": [".", "\u2019"], ja: [".", ","], ko: [".", ","], lt: [",", "\u00a0"], lv: [",", "\u00a0"], mk: [",", "."], nb: [",", "\u00a0"], nl: [",", "."], pl: [",", "\u00a0"], pt: [",", "."], "pt-pt": [",", "\u00a0"], ro: [",", "."], ru: [",", "\u00a0"], sk: [",", "\u00a0"], sl: [",", "."], sr: [",", "."], sv: [",", "\u00a0"], th: [".", ","], tr: [",", "."], uk: [",", "\u00a0"], vi: [",", "."], zh: [".", ","]
        }, h = /[#0,]*[#0](?:\.0*#*)?/, b = function (d,
          f, t) { if (!(d instanceof Array)) return f(d); const v = []; for (let m = 0; m < d.length; m++)v.push(f(d[m])); d = v.join("|"); return "(" + (t ? "?:" : "") + d + ")" }; a._parseInfo = y; a.format = function (d, f) {
            f = { ...f }; var t = q(f.locale); f.customs = t; var v = f.pattern || t.pattern; if (isNaN(d) || Infinity === Math.abs(d)) return null; {
              f = f || {}; t = f.customs.group; const e = f.customs.decimal; v = v.split(";"); var m = v[0]; v = v[0 > d ? 1 : 0] || "-" + m; if (-1 !== v.indexOf("%")) d *= 100; else if (-1 !== v.indexOf("\u2030")) d *= 1E3; else {
                if (-1 !== v.indexOf("\u00a4")) throw Error("currency notation not supported");
                if (-1 !== v.indexOf("E")) throw Error("exponential notation not supported");
              } const g = h; m = m.match(g); if (!m) throw Error("unable to find a number expression in pattern: " + v); !1 === f.fractional && (f.places = 0); d = v.replace(g, u(d, m[0], { decimal: e, group: t, places: f.places, round: f.round }))
            } return d
          }; a.getCustoms = q; a.parse = function (d, f) {
            f = y(f); d = (new RegExp("^" + f.regexp + "$")).exec(d); if (!d) return NaN; let t = d[1]; if (!d[1]) { if (!d[2]) return NaN; t = d[2]; f.factor *= -1 } t = t.replace(new RegExp("[" + f.group + "\\s\\xa0]", "g"), "").replace(f.decimal,
              "."); return Number(t) * f.factor
          }; a.regexp = function (d) { return y(d).regexp }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Feature/support/arcadeFeatureUtils": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Logger ../../../core/promiseUtils ../../../layers/FeatureLayer ./featureUtils".split(" "), function (a, w, c, q, u, y, n) {
        function p(x) {
          return `<ul class="esri-widget__list">${x.map(k => `<li>${"string" === typeof k ? n.applyTextFormattingHTML(n.htmlEntities(k)) :
            k}</li>`).join("")}</ul>`
        } function l(x) { return `<table class="esri-widget__table">${x.keys().map(k => { var r = x.field(k); r = "string" === typeof r ? n.applyTextFormattingHTML(n.htmlEntities(r)) : r; return `<tr><th>${k}</th><td>${r}</td></tr>` }).join("")}</table>` } function h({ aggregatedFeatures: x, arcadeUtils: k, featureSetVars: r, context: A, viewInfo: z, map: B, graphic: C, interceptor: D }) {
          r.forEach(E => {
            E = E.toLowerCase(); var H = { map: B, spatialReference: z.sr, interceptor: D }; "$map" === E && (A.vars[E] = k.convertMapToFeatureSetCollection(H));
            "$layer" === E && (A.vars[E] = k.convertFeatureLayerToFeatureSet({ layer: C.sourceLayer, spatialReference: z.sr, interceptor: D })); "$datastore" === E && (A.vars[E] = k.convertServiceUrlToWorkspace({ url: C.sourceLayer.url, spatialReference: z.sr, interceptor: D })); if ("$aggregatedfeatures" === E) {
              H = C.layer; const { fields: J, objectIdField: M, geometryType: F, spatialReference: K, displayField: P } = H; H = new y({
                fields: J, objectIdField: M, geometryType: F, spatialReference: K, displayField: P, ..."feature" === H.type ? {
                  templates: H.templates, typeIdField: H.typeIdField,
                  types: H.types
                } : null, source: x
              }); A.vars[E] = k.convertFeatureLayerToFeatureSet({ layer: H, spatialReference: z.sr, interceptor: D })
            }
          })
        } function b() { return new Promise((x, k) => a(["../../../support/arcadeUtils"], x, k)) } function d(x) { return f.apply(this, arguments) } function f() {
          f = c._asyncToGenerator(function* ({ graphic: x, view: k }) {
            const { isAggregate: r, layer: A } = x; if (!r || !A || "2d" !== (null == k ? void 0 : k.type)) return []; k = yield k.whenLayerView(A); if (!k.createQuery || !k.queryFeatures) return []; const z = k.createQuery(); z.aggregateIds =
              [x.getObjectId()]; ({ features: x } = yield k.queryFeatures(z)); return x
          }); return f.apply(this, arguments)
        } function t(x) { return v.apply(this, arguments) } function v() {
          v = c._asyncToGenerator(function* ({ expressionInfo: x, arcadeUtils: k, interceptor: r, spatialReference: A, map: z, graphic: B, view: C }) {
            if (!x || !x.expression) return null; const D = k.createSyntaxTree(x.expression), E = e.filter(J => k.hasVariable(D, J));[C] = yield u.all([d({ graphic: B, view: C }), k.loadScriptDependencies(D, !0, E)]); const H = k.getViewInfo({ spatialReference: A });
            A = k.createExecContext(B, H); A.interceptor = r; A.useAsync = !0; h({ aggregatedFeatures: C, arcadeUtils: k, featureSetVars: E, context: A, viewInfo: H, map: z, graphic: B, interceptor: r }); r = k.createFunction(D, A); return k.executeAsyncFunction(r, A).catch(J => g.error("arcade-execution-error", { error: J, graphic: B, expressionInfo: x }))
          }); return v.apply(this, arguments)
        } function m() {
          m = c._asyncToGenerator(function* ({ expressionInfos: x, spatialReference: k, graphic: r, interceptor: A, map: z, view: B }) {
            if (!x || !x.length) return {}; const C = yield b(),
              D = {}; for (const E of x) D[`expression/${E.name}`] = t({ expressionInfo: E, arcadeUtils: C, interceptor: A, spatialReference: k, map: z, graphic: r, view: B }); x = yield u.eachAlways(D); k = {}; for (const E in x) r = x[E].value, r = "string" === typeof r ? n.applyTextFormattingHTML(n.htmlEntities(r)) : Array.isArray(r) ? p(r) : "esri.arcade.Dictionary" === (null == r ? void 0 : r.declaredClass) ? l(r) : r, k[E] = r; return k
          }); return m.apply(this, arguments)
        } const e = ["$datastore", "$map", "$layer", "$aggregatedfeatures"], g = q.getLogger("esri.widgets.Feature.support.arcadeFeatureUtils");
        w.createCompiledExpression = t; w.createCompiledExpressions = function (x) { return m.apply(this, arguments) }; w.loadArcadeUtils = b; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Feature/FeatureViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Graphic ../../arcade/featureset/support/FeatureSetQueryInterceptor ../../core/Accessor ../../core/Handles ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/throttle ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ../../popup/content/TextContent ./FeatureAttachments/FeatureAttachmentsViewModel ./FeatureContent/FeatureContentViewModel ./FeatureExpression/FeatureExpressionViewModel ./FeatureFields/FeatureFieldsViewModel ./FeatureMedia/FeatureMediaViewModel ./support/arcadeFeatureUtils ./support/featureUtils ./support/relatedFeatureUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          var D; const E = n.getLogger("esri.widgets.FeatureViewModel"), H = { attachmentsContent: !0, customContent: !0, expressionContent: !0, fieldsContent: !0, mediaContent: !0, textContent: !0 }; u = D = function (J) {
            function M(K) {
              var P = J.call(this, K) || this; P._handles = new y; P._error = null; P._featureAbortController = null; P.graphicChangedThrottled = h.throttle(P.graphicChanged, 1, a._assertThisInitialized(P)); P._expressionAttributes = null; P._graphicExpressionAttributes = null; P.abilities =
                { ...H }; P.content = null; P.contentViewModels = []; P.defaultPopupTemplateEnabled = !1; P.formattedAttributes = null; P.lastEditInfo = null; P.relatedInfos = new Map; P.title = ""; P.view = null; P._isAllowedContentType = L => { const { abilities: N } = a._assertThisInitialized(P); return "attachments" === L.type && N.attachmentsContent || "custom" === L.type && N.customContent || "fields" === L.type && N.fieldsContent || "media" === L.type && N.mediaContent || "text" === L.type && N.textContent || "expression" === L.type && N.expressionContent }; P._handles.add(b.init(a._assertThisInitialized(P),
                  ["graphic", "_effectivePopupTemplate", "abilities"], () => P.graphicChangedThrottled())); return P
            } a._inheritsLoose(M, J); var F = M.prototype; F.destroy = function () { this._clear(); this._cancelFeatureQuery(); this._error = null; this._handles.destroy(); this.graphic = this._handles = null; this._destroyContentViewModels(); this.relatedInfos.clear() }; F.castAbilities = function (K) { return { ...H, ...K } }; F.setActiveMedia = function (K, P) { K = this.contentViewModels[K]; K instanceof A && K.setActiveMedia(P) }; F.nextMedia = function (K) {
              K = this.contentViewModels[K];
              K instanceof A && K.next()
            }; F.previousMedia = function (K) { K = this.contentViewModels[K]; K instanceof A && K.previous() }; F._clear = function () { this._set("title", ""); this._set("content", null); this._set("formattedAttributes", null) }; F.graphicChanged = function () {
              var K = a._asyncToGenerator(function* () {
                this._cancelFeatureQuery(); this._error = null; this._clear(); const { graphic: P } = this; if (P) {
                  var L = new AbortController; this._featureAbortController = L; try { yield this._queryFeature({ signal: L.signal }) } catch (N) {
                    l.isAbortError(N) ||
                    (this._error = N, E.error("error", "The popupTemplate could not be displayed for this feature.", { error: N, graphic: P, popupTemplate: this._effectivePopupTemplate }))
                  } this._featureAbortController === L && (this._featureAbortController = null)
                }
              }); return function () { return K.apply(this, arguments) }
            }(); F._cancelFeatureQuery = function () { const { _featureAbortController: K } = this; K && K.abort(); this._featureAbortController = null }; F._compileContentElement = function (K, P) {
              if ("attachments" === K.type) return this._compileAttachments(K,
                P); if ("custom" === K.type) return this._compileCustom(K, P); if ("fields" === K.type) return this._compileFields(K, P); if ("media" === K.type) return this._compileMedia(K, P); if ("text" === K.type) return this._compileText(K, P); if ("expression" === K.type) return this._compileExpression(K, P)
            }; F._compileContent = function (K) {
              this._destroyContentViewModels(); if (this.graphic) return Array.isArray(K) ? K.filter(this._isAllowedContentType).map((P, L) => this._compileContentElement(P, L)) : "string" === typeof K ? this._compileText(new e({ text: K }),
                0).text : K
            }; F._destroyContentViewModels = function () { var K; null == (K = this._handles) ? void 0 : K.remove("content-view-models"); this.contentViewModels.forEach(P => P && !P.destroyed && P.destroy()); this._set("contentViewModels", []) }; F._setExpressionContentVM = function (K, P) {
              const { formattedAttributes: L } = this, { contentElement: N, contentElementViewModel: G } = K; K = null == N ? void 0 : N.type; G && K && ("fields" === K && (this._createFieldsFormattedAttributes({ contentElement: N, contentElementIndex: P, formattedAttributes: L }), G.set(this._createFieldsVMParams(N,
                P))), "media" === K && (this._createMediaFormattedAttributes({ contentElement: N, contentElementIndex: P, formattedAttributes: L }), G.set(this._createMediaVMParams(N, P))), "text" === K && G.set(this._createTextVMParams(N)))
            }; F._compileExpression = function (K, P) {
              const { expressionInfo: L } = K, { graphic: N, map: G, spatialReference: I, view: O } = this, R = new k({ expressionInfo: L, graphic: N, interceptor: D.interceptor, map: G, spatialReference: I, view: O }); this.contentViewModels[P] = R; this._handles.add(b.init(R, "contentElementViewModel", () => this._setExpressionContentVM(R,
                P)), "content-view-models"); return K
            }; F._compileAttachments = function (K, P) { const { graphic: L } = this, { description: N, title: G } = K; this.contentViewModels[P] = new g({ graphic: L, ...this._compileTitleAndDesc({ title: G, description: N }) }); return K }; F._compileCustom = function (K, P) { const { graphic: L } = this, { creator: N, destroyer: G } = K; this.contentViewModels[P] = new x({ graphic: L, creator: N, destroyer: G }); return K }; F._compileTitleAndDesc = function ({ title: K, description: P }) {
              const { _fieldInfoMap: L, _sourceLayer: N, graphic: G, formattedAttributes: I,
                _expressionAttributes: O } = this, { attributes: R } = G, S = I.global; return { title: B.substituteFieldsInLinksAndAttributes({ attributes: R, fieldInfoMap: L, globalAttributes: S, expressionAttributes: O, layer: N, text: K }), description: B.substituteFieldsInLinksAndAttributes({ attributes: R, fieldInfoMap: L, globalAttributes: S, expressionAttributes: O, layer: N, text: P }) }
            }; F._createFieldsVMParams = function (K, P) {
              const { _effectivePopupTemplate: L, formattedAttributes: N } = this, G = { ...N.global, ...N.content[P] }; P = (null == K ? void 0 : K.fieldInfos) ||
                (null == L ? void 0 : L.fieldInfos); P = null == P ? void 0 : P.filter(({ fieldName: S }) => B.isExpressionField(S) || B.isRelatedField(S) || G.hasOwnProperty(S)); const I = null == L ? void 0 : L.expressionInfos, { description: O, title: R } = K; return { attributes: G, expressionInfos: I, fieldInfos: P, ...this._compileTitleAndDesc({ title: R, description: O }) }
            }; F._compileFields = function (K, P) { const L = K.clone(); K = new r(this._createFieldsVMParams(K, P)); this.contentViewModels[P] = K; L.fieldInfos = K.formattedFieldInfos.slice(0); return L }; F._createMediaVMParams =
              function (K, P) { const { graphic: L, _fieldInfoMap: N, formattedAttributes: G, _effectivePopupTemplate: I, relatedInfos: O, _sourceLayer: R, _expressionAttributes: S } = this, { attributes: Q } = L, { description: T, mediaInfos: da, title: Y } = K; return { activeMediaInfoIndex: K.activeMediaInfoIndex || 0, attributes: Q, layer: R, fieldInfoMap: N, formattedAttributes: { ...G.global, ...G.content[P] }, expressionAttributes: S, mediaInfos: da, popupTemplate: I, relatedInfos: O, ...this._compileTitleAndDesc({ title: Y, description: T }) } }; F._compileMedia = function (K,
                P) { const L = K.clone(); K = new A(this._createMediaVMParams(K, P)); L.mediaInfos = K.formattedMediaInfos.slice(0); this.contentViewModels[P] = K; return L }; F._createTextVMParams = function (K) { const { graphic: P, _fieldInfoMap: L, _sourceLayer: N, _expressionAttributes: G } = this; if (K && K.text) { const { attributes: I } = P; K.text = B.substituteFieldsInLinksAndAttributes({ attributes: I, fieldInfoMap: L, globalAttributes: this.formattedAttributes.global, expressionAttributes: G, layer: N, text: K.text }) } return { graphic: P, creator: K.text } }; F._compileText =
                  function (K, P) { K = K.clone(); this.contentViewModels[P] = new x(this._createTextVMParams(K)); return K }; F._compileLastEditInfo = function () { const { _effectivePopupTemplate: K, _sourceLayer: P, graphic: L } = this; if (K) { var { lastEditInfoEnabled: N } = K, G = null == P ? void 0 : P.editFieldsInfo; if (N && G) return B.formatEditInfo(G, L.attributes) } }; F._compileTitle = function (K) {
                    const { _fieldInfoMap: P, _sourceLayer: L, graphic: N, _expressionAttributes: G } = this, { attributes: I } = N; return B.substituteFieldsInLinksAndAttributes({
                      attributes: I, fieldInfoMap: P,
                      globalAttributes: this.formattedAttributes.global, expressionAttributes: G, layer: L, text: K
                    })
                  }; F._getTitle = function () { var K = a._asyncToGenerator(function* () { const { _effectivePopupTemplate: P, graphic: L } = this; return B.graphicCallback(null == P ? void 0 : P.title, { graphic: L }) }); return function () { return K.apply(this, arguments) } }(); F._getContent = function () {
                    var K = a._asyncToGenerator(function* () { const { _effectivePopupTemplate: P, graphic: L } = this; return B.graphicCallback(null == P ? void 0 : P.content, { graphic: L }) }); return function () {
                      return K.apply(this,
                        arguments)
                    }
                  }(); F._queryFeature = function () {
                    var K = a._asyncToGenerator(function* (P) {
                      const { _featureAbortController: L, _sourceLayer: N, graphic: G, _effectivePopupTemplate: I, spatialReference: O, map: R, view: S } = this, { content: { value: Q }, title: { value: T } } = yield l.eachAlways({ content: this._getContent(), title: this._getTitle() }); L === this._featureAbortController && G && (yield B.queryUpdatedFeature({ graphic: G, popupTemplate: I, layer: N, spatialReference: O }, P), { expressionAttributes: { value: P } } = yield l.eachAlways({
                        checkForRelatedFeatures: this._checkForRelatedFeatures(P),
                        expressionAttributes: z.createCompiledExpressions({ expressionInfos: null == I ? void 0 : I.expressionInfos, spatialReference: O, graphic: G, map: R, interceptor: D.interceptor, view: S })
                      }), L === this._featureAbortController && G && (this._expressionAttributes = P, this._graphicExpressionAttributes = { ...G.attributes, ...P }, this._set("formattedAttributes", this._createFormattedAttributes(Q)), this._set("title", this._compileTitle(T)), this._set("lastEditInfo", this._compileLastEditInfo() || null), this._set("content", this._compileContent(Q) ||
                        null)))
                    }); return function (P) { return K.apply(this, arguments) }
                  }(); F._createMediaFormattedAttributes = function ({ contentElement: K, contentElementIndex: P, formattedAttributes: L }) { const { _effectivePopupTemplate: N, graphic: G, relatedInfos: I, _sourceLayer: O, _fieldInfoMap: R, _graphicExpressionAttributes: S } = this; L.content[P] = B.formatAttributes({ fieldInfos: null == N ? void 0 : N.fieldInfos, graphic: G, attributes: { ...S, ...K.attributes }, layer: O, fieldInfoMap: R, relatedInfos: I }) }; F._createFieldsFormattedAttributes = function ({ contentElement: K,
                    contentElementIndex: P, formattedAttributes: L }) { if (K.fieldInfos) { const { graphic: N, relatedInfos: G, _sourceLayer: I, _fieldInfoMap: O, _graphicExpressionAttributes: R } = this; L.content[P] = B.formatAttributes({ fieldInfos: K.fieldInfos, graphic: N, attributes: { ...R, ...K.attributes }, layer: I, fieldInfoMap: O, relatedInfos: G }) } }; F._createFormattedAttributes = function (K) {
                      const { _effectivePopupTemplate: P, graphic: L, relatedInfos: N, _sourceLayer: G, _fieldInfoMap: I, _graphicExpressionAttributes: O } = this, R = {
                        global: B.formatAttributes({
                          fieldInfos: null ==
                            P ? void 0 : P.fieldInfos, graphic: L, attributes: O, layer: G, fieldInfoMap: I, relatedInfos: N
                        }), content: []
                      }; Array.isArray(K) && K.forEach((S, Q) => { "fields" === S.type && this._createFieldsFormattedAttributes({ contentElement: S, contentElementIndex: Q, formattedAttributes: R }); "media" === S.type && this._createMediaFormattedAttributes({ contentElement: S, contentElementIndex: Q, formattedAttributes: R }) }); return R
                    }; F._checkForRelatedFeatures = function (K) {
                      const { graphic: P, _effectivePopupTemplate: L } = this; return this._queryRelatedInfos(P,
                        B.getAllFieldInfos(L), K)
                    }; F._queryRelatedInfos = function () {
                      var K = a._asyncToGenerator(function* (P, L, N) {
                        const { relatedInfos: G, _sourceLayer: I } = this; G.clear(); const O = p.isSome(I.associatedLayer) ? yield I.associatedLayer.load(N) : I; if (O) {
                          var R = L.filter(T => T && B.isRelatedField(T.fieldName)); if (R && R.length) {
                            L.forEach(T => this._configureRelatedInfo(T, O)); var S = yield C.queryLayerInfos({ relatedInfos: G, layer: O }, N); Object.keys(S).forEach(T => {
                              var da; const Y = G.get(T.toString()); T = null == (da = S[T]) ? void 0 : da.value; Y &&
                                T && (Y.layerInfo = T.data)
                            }); var Q = yield C.queryRelatedFeatures({ graphic: P, relatedInfos: G, layer: O }, N); Object.keys(Q).forEach(T => { var da; C.setRelatedFeatures(null == (da = Q[T]) ? void 0 : da.value, G.get(T.toString())) })
                          }
                        }
                      }); return function (P, L, N) { return K.apply(this, arguments) }
                    }(); F._configureRelatedInfo = function (K, P) {
                      const { relatedInfos: L } = this, N = C.getRelatedFieldInfo(K.fieldName); if (N) {
                        var { layerId: G, fieldName: I } = N; G && (P = L.get(G.toString()) || C.createRelatedInfo(G, P)) && (C.updateRelatedInfo({
                          relatedInfo: P, fieldName: I,
                          fieldInfo: K
                        }), this.relatedInfos.set(G, P))
                      }
                    }; a._createClass(M, [{ key: "_effectivePopupTemplate", get: function () { return p.isSome(this.graphic) ? this.graphic.getEffectivePopupTemplate(this.defaultPopupTemplateEnabled) : null } }, { key: "_fieldInfoMap", get: function () { return B.createfieldInfoMap(B.getAllFieldInfos(this._effectivePopupTemplate), this._sourceLayer) } }, { key: "_sourceLayer", get: function () { return B.getSourceLayer(this.graphic) } }, {
                      key: "state", get: function () {
                        return this.graphic ? this._error ? "error" : this.waitingForContent ?
                          "loading" : "ready" : "disabled"
                      }
                    }, { key: "graphic", set: function (K) { this._set("graphic", K ? K.clone() : null) } }, { key: "spatialReference", get: function () { return this.get("view.spatialReference") || null }, set: function (K) { void 0 === K ? this._clearOverride("spatialReference") : this._override("spatialReference", K) } }, { key: "map", get: function () { return this.get("view.map") || null }, set: function (K) { void 0 === K ? this._clearOverride("map") : this._override("map", K) } }, { key: "waitingForContent", get: function () { return !!this._featureAbortController } }]);
            return M
          }(u); u.interceptor = new q.FeatureSetQueryInterceptor(B.preLayerQueryCallback, B.preRequestCallback); w.__decorate([d.property()], u.prototype, "_error", void 0); w.__decorate([d.property()], u.prototype, "_featureAbortController", void 0); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "_effectivePopupTemplate", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "_fieldInfoMap", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "_sourceLayer", null); w.__decorate([d.property()], u.prototype,
            "abilities", void 0); w.__decorate([v.cast("abilities")], u.prototype, "castAbilities", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "content", void 0); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "contentViewModels", void 0); w.__decorate([d.property({ type: Boolean })], u.prototype, "defaultPopupTemplateEnabled", void 0); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "state", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "formattedAttributes", void 0); w.__decorate([d.property({
              type: c,
              value: null
            })], u.prototype, "graphic", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "lastEditInfo", void 0); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "relatedInfos", void 0); w.__decorate([d.property()], u.prototype, "spatialReference", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "title", void 0); w.__decorate([d.property()], u.prototype, "map", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "waitingForContent", null); w.__decorate([d.property()], u.prototype, "view",
              void 0); return u = D = w.__decorate([m.subclass("esri.widgets.FeatureViewModel")], u)
        })
    }, "esri/arcade/featureset/support/FeatureSetQueryInterceptor": function () { define(["exports"], function (a) { a.FeatureSetQueryInterceptor = function (w, c) { this.preLayerQueryCallback = w; this.preRequestCallback = c; this.preLayerQueryCallback || (this.preLayerQueryCallback = q => { }); this.preRequestCallback || (this.preLayerQueryCallback = q => { }) }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/widgets/Feature/support/FeatureContentMixin": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Logger ../../../core/accessorSupport/ensureType ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/set ../../../core/accessorSupport/decorators/subclass ../../support/widget ../../support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
        a.FeatureContentMixin = d => {
          d = function (f) { function t() { var v = f.apply(this, arguments) || this; v.renderNodeContent = m => h.isWidget(m) && !m.destroyed ? b.tsx("div", { key: m }, m.render()) : m instanceof HTMLElement ? b.tsx("div", { key: m, bind: m, afterCreate: v._attachToNode }) : h.hasDomNode(m) ? b.tsx("div", { key: m, bind: m.domNode, afterCreate: v._attachToNode }) : null; return v } w._inheritsLoose(t, f); t.prototype._attachToNode = function (v) { v.appendChild(this) }; return t }(d); return d = c.__decorate([l.subclass("esri.widgets.Feature.ContentMixin")],
            d)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/widgets/Spinner": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/promiseUtils ../core/watchUtils ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./Spinner/SpinnerViewModel ./support/widgetUtils ../core/Logger ./support/jsxFactory".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          n = function (e) {
            function g(k, r) { k = e.call(this, k, r) || this; k._animationDelay = 500; k._animationPromise = null; k.location = null; k.view = null; k.viewModel = new f; k.visible = !1; return k } a._inheritsLoose(g, e); var x = g.prototype; x.initialize = function () { this.own([u.watch(this, "visible", k => this._visibleChange(k))]) }; x.destroy = function () { this._animationPromise = null }; x.show = function (k) {
              const { location: r, promise: A } = k; r && (this.viewModel.location = r); this.visible = !0; k = () => this.hide();
              A && A.catch(() => { }).then(k)
            }; x.hide = function () { this.visible = !1 }; x.render = function () { var { visible: k } = this, { screenLocation: r } = this.viewModel; r = !!r; k = { ["esri-spinner--start"]: k && r, ["esri-spinner--finish"]: !k && r }; r = this._getPositionStyles(); return m.tsx("div", { class: this.classes("esri-spinner", k), styles: r }) }; x._visibleChange = function (k) {
              if (k) this.viewModel.screenLocationEnabled = !0; else {
                var r = q.after(this._animationDelay); this._animationPromise = r; r.catch(() => { }).then(() => {
                this._animationPromise === r && (this.viewModel.screenLocationEnabled =
                  !1, this._animationPromise = null)
                })
              }
            }; x._getPositionStyles = function () { const { screenLocation: k, view: r } = this.viewModel; if (!r || c.isNone(k)) return {}; const { padding: A } = r; return { left: `${k.x - A.left}px`, top: `${k.y - A.top}px` } }; return g
          }(d); w.__decorate([y.aliasOf("viewModel.location")], n.prototype, "location", void 0); w.__decorate([y.aliasOf("viewModel.view")], n.prototype, "view", void 0); w.__decorate([h.property({ type: f })], n.prototype, "viewModel", void 0); w.__decorate([y.aliasOf("viewModel.visible")], n.prototype,
            "visible", void 0); return n = w.__decorate([b.subclass("esri.widgets.Spinner")], n)
        })
    }, "esri/widgets/Spinner/SpinnerViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/AnchorElementViewModel".split(" "), function (a, w, c, q, u, y, n, p) {
        q = function (l) {
          function h(b) {
            b = l.call(this, b) || this; b.visible =
              !1; return b
          } a._inheritsLoose(h, l); return h
        }(p); w.__decorate([c.property()], q.prototype, "visible", void 0); return q = w.__decorate([n.subclass("esri.widgets.CompassViewModel")], q)
      })
    }, "esri/widgets/support/AnchorElementViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Evented ../../core/Handles ../../core/maybe ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          c = function (d) {
            function f(v) { var m = d.call(this, v) || this; m._anchorHandles = new q; m.location = null; m.screenLocation = null; m.screenLocationEnabled = !1; m.view = null; m._anchorHandles.add([y.watch(a._assertThisInitialized(m), ["screenLocationEnabled", "location", "view.size", "view.stationary"], () => m._updateScreenPointAndHandle()), y.watch(a._assertThisInitialized(m), ["view", "view.ready"], () => m._wireUpView())]); return m } a._inheritsLoose(f, d); var t = f.prototype; t.destroy = function () {
            this.view =
              null; this._anchorHandles && this._anchorHandles.destroy(); this._viewpointHandle = this._anchorHandles = null
            }; t._wireUpView = function () { this._anchorHandles.remove("view"); this._viewpointHandle = null; if (this.get("view.ready")) { this._setScreenLocation(); var { view: v } = this; v = y.pausable(v, "3d" === v.type ? "camera" : "viewpoint", () => this._viewpointChange()); this._anchorHandles.add(v, "view"); this._viewpointHandle = v; this._toggleWatchingViewpoint() } }; t._viewpointChange = function () { this._setScreenLocation(); this.emit("view-change") };
            t._updateScreenPointAndHandle = function () { this._setScreenLocation(); this._toggleWatchingViewpoint() }; t._toggleWatchingViewpoint = function () { const { _viewpointHandle: v, location: m, screenLocationEnabled: e } = this; v && (m && e ? v.resume() : v.pause()) }; t._setScreenLocation = function () { const { location: v, view: m, screenLocationEnabled: e } = this; var g = this.get("view.ready"); g = e && g && u.isSome(v) ? m.toScreen(v) : null; this._set("screenLocation", g) }; return f
          }(c.EventedAccessor); w.__decorate([n.property()], c.prototype, "location",
            void 0); w.__decorate([n.property({ readOnly: !0 })], c.prototype, "screenLocation", void 0); w.__decorate([n.property()], c.prototype, "screenLocationEnabled", void 0); w.__decorate([n.property()], c.prototype, "view", void 0); return c = w.__decorate([b.subclass("esri.widgets.support.AnchorElementViewModel")], c)
        })
    }, "esri/widgets/Popup/PopupViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../Graphic ../../symbols ../../core/Collection ../../core/Error ../../core/Handles ../../core/Logger ../../core/maybe ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../geometry/support/webMercatorUtils ../../layers/Layer ../../support/actions/ActionBase ../../support/actions/ActionButton ../../support/actions/ActionToggle ../../symbols/support/symbolUtils ../../views/input/InputManager ../../views/support/layerViewUtils ../Feature/FeatureViewModel ./actions ./actionUtils ../support/AnchorElementViewModel ../support/GoTo ../../geometry/Point ../../symbols/SimpleFillSymbol".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F) {
          const K = y.ofType({ key: "type", defaultKeyValue: "button", base: x, typeMap: { button: k, toggle: r } }), P = l.getLogger("esri.widgets.Popup.PopupViewModel"); c = function (L) {
            function N(I) {
              I = L.call(this, I) || this; I._handles = new p; I._pendingPromises = new Set; I._fetchFeaturesController = null; I._selectedClusterFeature = null; I.featurePage = null; I.actions = new K; I.defaultPopupTemplateEnabled = !1; I.autoCloseEnabled = !1; I.autoOpenEnabled = !0; I.browseClusterEnabled =
                !1; I.content = null; I.featuresPerPage = 20; I.featureViewModelAbilities = null; I.featureViewModels = []; I.highlightEnabled = !0; I.includeDefaultActions = !0; I.selectedClusterBoundaryFeature = new q({ symbol: new F({ outline: { width: 1.5, color: "cyan" }, style: "none" }) }); I.title = null; I.updateLocationEnabled = !1; I.view = null; I.visible = !1; I.zoomFactor = 4; I.zoomToLocation = null; return I
            } a._inheritsLoose(N, L); var G = N.prototype; G.initialize = function () {
              this._handles.add([b.init(this, ["autoOpenEnabled", "view"], () => this._autoOpenEnabledChange()),
              this.on("view-change", () => this._autoClose()), b.watch(this, ["highlightEnabled", "selectedFeature", "visible", "view"], () => this._highlightFeature()), b.watch(this, "view.animation.state", I => this._animationStateChange(I)), b.watch(this, "location", I => this._locationChange(I)), b.watch(this, "selectedFeature", I => this._selectedFeatureChange(I)), b.watch(this, ["selectedFeatureIndex", "featureCount", "featuresPerPage"], () => this._selectedFeatureIndexChange()), b.watch(this, ["featurePage", "selectedFeatureIndex", "featureCount",
                "featuresPerPage, featureViewModels"], () => this._setGraphicOnFeatureViewModels()), b.watch(this, "featureViewModels", () => this._featureViewModelsChange()), this.on("trigger-action", I => E.triggerAction({ event: I, view: this.view })), b.whenFalse(this, "waitingForResult", () => this._waitingForResultChange(), !0), b.watch(this, ["features", "view", "view.map", "view.spatialReference"], () => this._updateFeatureVMs()), b.watch(this, ["view.scale"], this._viewScaleChange), b.whenFalse(this, "visible", () => this.browseClusterEnabled =
                  !1), b.watch(this, "browseClusterEnabled", I => I ? this.enableClusterBrowsing() : this.disableClusterBrowsing())])
            }; G.destroy = function () { this._cancelFetchingFeatures(); this._handles.destroy(); this._handles = null; this._pendingPromises.clear(); this.browseClusterEnabled = !1; this.view = null }; G.centerAtLocation = function () {
              var { view: I } = this; const O = E.getSelectedTarget(this); return O ? this.callGoTo({ target: { target: O, scale: I.scale } }) : (I = new n("center-at-location:invalid-target-or-view", "Cannot center at a location without a target and view.",
                { target: O, view: I }), P.error(I), Promise.reject(I))
            }; G.clear = function () { this.set({ promises: [], features: [], content: null, title: null, location: null }) }; G.fetchFeatures = function (I, O) { const { view: R } = this; return R && I ? R.fetchPopupFeatures(I, { event: O && O.event, defaultPopupTemplateEnabled: this.defaultPopupTemplateEnabled, signal: O && O.signal }) : (I = new n("fetch-features:invalid-screenpoint-or-view", "Cannot fetch features without a screenPoint and view.", { screenPoint: I, view: R }), P.error(I), Promise.reject(I)) }; G.open =
              function (I) { I = { updateLocationEnabled: !1, promises: [], fetchFeatures: !1, ...I, visible: !0 }; const { fetchFeatures: O } = I; delete I.fetchFeatures; O && this._setFetchFeaturesPromises(I.location); this.set(I) }; G.triggerAction = function (I) { (I = this.allActions.getItemAt(I)) && !I.disabled && this.emit("trigger-action", { action: I }) }; G.next = function () { this.selectedFeatureIndex += 1; return this }; G.previous = function () { --this.selectedFeatureIndex; return this }; G.disableClusterBrowsing = function () {
                E.removeClusteredFeaturesForBrowsing(this);
                this._clearBrowsedClusterGraphics()
              }; G.enableClusterBrowsing = function () { var I = a._asyncToGenerator(function* () { yield E.displayClusterExtent(this); yield E.browseAggregateFeatures(this) }); return function () { return I.apply(this, arguments) } }(); G._animationStateChange = function (I) { this.zoomToLocation || (D.zoomToFeature.disabled = "waiting-for-target" === I) }; G._clearBrowsedClusterGraphics = function () {
                var I; const O = null == (I = this.view) ? void 0 : I.graphics; O && (O.remove(this.selectedClusterBoundaryFeature), O.remove(this._selectedClusterFeature));
                this._selectedClusterFeature = null; this.selectedClusterBoundaryFeature.geometry = null
              }; G._viewScaleChange = function () { var I; if (null != (I = this.selectedFeature) && I.isAggregate || this.browseClusterEnabled) this.visible = this.browseClusterEnabled = !1 }; G._locationChange = function (I) { const { selectedFeature: O, updateLocationEnabled: R } = this; R && I && (!O || O.geometry) && this.centerAtLocation() }; G._selectedFeatureIndexChange = function () {
              this.featurePage = 1 < this.featureCount ? Math.floor(this.selectedFeatureIndex / this.featuresPerPage) +
                1 : null
              }; G._featureViewModelsChange = function () { this.featurePage = 1 < this.featureCount ? 1 : null }; G._setGraphicOnFeatureViewModels = function () { const { features: I, featureCount: O, featurePage: R, featuresPerPage: S, featureViewModels: Q } = this; if (null !== R) { var T = ((R - 1) * S + O) % O; Q.slice(T, T + S).forEach((da, Y) => { da && !da.graphic && (da.graphic = I[T + Y]) }) } }; G._selectedFeatureChange = function () {
                var I = a._asyncToGenerator(function* (O) {
                  if (O) {
                    var { location: R, updateLocationEnabled: S, view: Q } = this; this.browseClusterEnabled ? (this._selectedClusterFeature &&
                      (Q.graphics.remove(this._selectedClusterFeature), this._selectedClusterFeature = null), O.isAggregate || (O.symbol = yield A.getDisplayedSymbol(O), this._selectedClusterFeature = O, Q.graphics.add(this._selectedClusterFeature))) : !S && R || !O.geometry ? S && !O.geometry && this.centerAtLocation().then(() => { this.location = Q.center.clone() }) : this.location = h.unwrap(this._getPointFromGeometry(O.geometry))
                  }
                }); return function (O) { return I.apply(this, arguments) }
              }(); G._waitingForResultChange = function () {
              !this.featureCount && this.promises &&
                (this.visible = !1)
              }; G._setFetchFeaturesPromises = function (I) { return this._fetchFeaturesWithController(this._getScreenPoint(I || this.location)).then(O => { const { clientOnlyGraphics: R, promisesPerLayerView: S } = O; O = Promise.resolve(R); const Q = S.map(T => T.promise); this.promises = [O, ...Q] }) }; G._destroyFeatureVMs = function () { this.featureViewModels.forEach(I => I && !I.destroyed && I.destroy()); this._set("featureViewModels", []) }; G._updateFeatureVMs = function () {
                const { selectedFeature: I, features: O, featureViewModels: R } = this;
                null != I && I.isAggregate || (this.browseClusterEnabled = !1); this._destroyFeatureVMs(); if (O && O.length) {
                  var S = R.slice(0), Q = []; O.forEach((T, da) => {
                    if (T) {
                      var Y = null; S.some((ka, ea) => { ka && ka.graphic === T && (Y = ka, S.splice(ea, 1)); return !!Y }); if (Y) Q[da] = Y; else {
                        var fa, ha; const ka = new C({ abilities: this.featureViewModelAbilities, defaultPopupTemplateEnabled: this.defaultPopupTemplateEnabled, spatialReference: null == (fa = this.view) ? void 0 : fa.spatialReference, graphic: T === I ? T : null, map: null == (ha = this.view) ? void 0 : ha.map, view: this.view });
                        Q[da] = ka
                      }
                    }
                  }); S.forEach(T => T && !T.destroyed && T.destroy()); this._set("featureViewModels", Q)
                }
              }; G._getScreenPoint = function (I) { const { view: O } = this; return O && I && "function" === typeof O.toScreen ? O.toScreen(I) : null }; G._autoOpenEnabledChange = function () { const { _handles: I, autoOpenEnabled: O } = this; I.remove("auto-fetch-features"); if (O && this.view) { const R = this.view.on("click", S => { "mouse" === S.pointerType && 0 !== S.button || this._fetchFeaturesAndOpen(S) }, z.ViewEventPriorities.WIDGET); I.add(R, "auto-fetch-features") } }; G._cancelFetchingFeatures =
                function () { const I = this._fetchFeaturesController; I && I.abort(); this._fetchFeaturesController = null; this.notifyChange("waitingForResult") }; G._fetchFeaturesWithController = function (I, O) { this._cancelFetchingFeatures(); const R = new AbortController, { signal: S } = R; this._fetchFeaturesController = R; this.notifyChange("waitingForResult"); I = this.fetchFeatures(I, { signal: S, event: O }); I.catch(() => { }).then(() => { this._fetchFeaturesController = null; this.notifyChange("waitingForResult") }); return I }; G._fetchFeaturesAndOpen =
                  function (I) { const { screenPoint: O, mapPoint: R } = I, { view: S } = this; this._fetchFeaturesWithController(O, I).then(Q => { const { clientOnlyGraphics: T, promisesPerLayerView: da, location: Y } = Q, fa = [Promise.resolve(T), ...da.map(ha => ha.promise)]; S.popup.open({ location: Y || R, promises: fa }); return Q }) }; G._updatePendingPromises = function (I) { I && this._pendingPromises.has(I) && (this._pendingPromises.delete(I), this.notifyChange("pendingPromisesCount")) }; G._autoClose = function () { this.autoCloseEnabled && (this.visible = !1) }; G._getPointFromGeometry =
                    function (I) { return h.isNone(I) ? null : "point" === I.type ? I : "extent" === I.type ? I.center : "polygon" === I.type ? I.centroid : "multipoint" === I.type || "polyline" === I.type ? I.extent.center : null }; G._getLayerView = function () { var I = a._asyncToGenerator(function* (O, R) { yield O.when(); return O.whenLayerView(R) }); return function (O, R) { return I.apply(this, arguments) } }(); G._highlightFeature = function () {
                      var I = a._asyncToGenerator(function* () {
                        this._handles.remove("highlight"); const { selectedFeature: O, highlightEnabled: R, view: S, visible: Q } =
                          this; if (O && S && R && Q) { var { layer: T, sourceLayer: da } = O; if ("map-notes" === (null == da ? void 0 : da.type) || "subtype-group" === (null == da ? void 0 : da.type)) T = da; if (T && T instanceof g) { var Y = this._getLayerView(S, T); this._highlightPromise = Y; var fa = yield Y; if (fa && B.highlightsSupported(fa) && this._highlightPromise === Y && this.selectedFeature && this.highlightEnabled && this.visible) { Y = "objectIdField" in T && T.objectIdField; var ha = O.attributes; fa = fa.highlight(ha && Y && ha[Y] || O); this._handles.add(fa, "highlight") } } }
                      }); return function () {
                        return I.apply(this,
                          arguments)
                      }
                    }(); G._updateFeatures = function (I) { const { features: O } = this; I && I.length && (O.length ? (I = I.filter(R => -1 === O.indexOf(R)), this.features = O.concat(I)) : this.features = I) }; a._createClass(N, [{ key: "isLoadingFeature", get: function () { return this.featureViewModels.some(I => I.waitingForContent) } }, { key: "active", get: function () { return !(!this.visible || this.waitingForResult) } }, {
                      key: "allActions", get: function () {
                        const I = this._get("allActions") || new K; I.removeAll(); const { actions: O, defaultActions: R, defaultPopupTemplateEnabled: S,
                          includeDefaultActions: Q, selectedFeature: T } = this; var da = Q ? R.concat(O) : O; const Y = T && ("function" === typeof T.getEffectivePopupTemplate && T.getEffectivePopupTemplate(S) || T.popupTemplate), fa = Y && Y.actions; (da = Y && Y.overwriteActions ? fa : fa ? fa.concat(da) : da) && da.filter(Boolean).forEach(ha => I.add(ha)); return I
                      }
                    }, {
                      key: "defaultActions", get: function () {
                        var I; const O = this._get("defaultActions") || new K; O.removeAll(); O.addMany(null != (I = this.selectedFeature) && I.isAggregate ? [D.zoomToClusteredFeatures.clone(), D.browseClusteredFeatures.clone()] :
                          [D.zoomToFeature.clone()]); return O
                      }
                    }, { key: "featureCount", get: function () { return this.features.length } }, { key: "features", get: function () { return this._get("features") || [] }, set: function (I) { I = I || []; this._set("features", I); const { pendingPromisesCount: O, promiseCount: R, selectedFeatureIndex: S } = this, Q = R && I.length; Q && O && -1 === S ? this.selectedFeatureIndex = 0 : Q && -1 !== S || (this.selectedFeatureIndex = I.length ? 0 : -1) } }, {
                      key: "location", get: function () { return this._get("location") || null }, set: function (I) {
                        const O = this.get("view.spatialReference.isWebMercator");
                        I && I.get("spatialReference.isWGS84") && O && (I = e.geographicToWebMercator(I)); this._set("location", I)
                      }
                    }, { key: "pendingPromisesCount", get: function () { return this._pendingPromises.size } }, { key: "waitingForResult", get: function () { return !(!(this._fetchFeaturesController || 0 < this.pendingPromisesCount) || 0 !== this.featureCount) } }, { key: "promiseCount", get: function () { return this.promises.length } }, {
                      key: "promises", get: function () { return this._get("promises") || [] }, set: function (I) {
                        this._pendingPromises.clear(); this.features =
                          []; Array.isArray(I) && I.length ? (this._set("promises", I), I = I.slice(0), I.forEach(O => { this._pendingPromises.add(O); O.then(R => { this._pendingPromises.has(O) && this._updateFeatures(R); this._updatePendingPromises(O) }, () => this._updatePendingPromises(O)) })) : this._set("promises", []); this.notifyChange("pendingPromisesCount")
                      }
                    }, { key: "selectedFeature", get: function () { const { features: I, selectedFeatureIndex: O } = this; return -1 === O ? null : I[O] || null } }, {
                      key: "selectedFeatureIndex", get: function () {
                        const I = this._get("selectedFeatureIndex");
                        return "number" === typeof I ? I : -1
                      }, set: function (I) { const { featureCount: O } = this; I = isNaN(I) || -1 > I || !O ? -1 : (I + O) % O; this._set("selectedFeatureIndex", I) }
                    }, { key: "selectedFeatureViewModel", get: function () { return this.featureViewModels[this.selectedFeatureIndex] || null } }, { key: "state", get: function () { return this.get("view.ready") ? "ready" : "disabled" } }]); return N
          }(J.GoToMixin(H)); w.__decorate([d.property()], c.prototype, "featurePage", void 0); w.__decorate([d.property()], c.prototype, "isLoadingFeature", null); w.__decorate([d.property({ type: K })],
            c.prototype, "actions", void 0); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "active", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "allActions", null); w.__decorate([d.property({ type: Boolean })], c.prototype, "defaultPopupTemplateEnabled", void 0); w.__decorate([d.property()], c.prototype, "autoCloseEnabled", void 0); w.__decorate([d.property()], c.prototype, "autoOpenEnabled", void 0); w.__decorate([d.property()], c.prototype, "browseClusterEnabled", void 0); w.__decorate([d.property()], c.prototype,
              "content", void 0); w.__decorate([d.property({ type: K, readOnly: !0 })], c.prototype, "defaultActions", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "featureCount", null); w.__decorate([d.property()], c.prototype, "features", null); w.__decorate([d.property()], c.prototype, "featuresPerPage", void 0); w.__decorate([d.property()], c.prototype, "featureViewModelAbilities", void 0); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "featureViewModels", void 0); w.__decorate([d.property()], c.prototype, "highlightEnabled",
                void 0); w.__decorate([d.property()], c.prototype, "includeDefaultActions", void 0); w.__decorate([d.property({ type: M })], c.prototype, "location", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "pendingPromisesCount", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "selectedClusterBoundaryFeature", void 0); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "waitingForResult", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "promiseCount", null); w.__decorate([d.property()],
                  c.prototype, "promises", null); w.__decorate([d.property({ value: null, readOnly: !0 })], c.prototype, "selectedFeature", null); w.__decorate([d.property({ value: -1 })], c.prototype, "selectedFeatureIndex", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "selectedFeatureViewModel", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "state", null); w.__decorate([d.property()], c.prototype, "title", void 0); w.__decorate([d.property()], c.prototype, "updateLocationEnabled", void 0); w.__decorate([d.property()],
                    c.prototype, "view", void 0); w.__decorate([d.property()], c.prototype, "visible", void 0); w.__decorate([d.property()], c.prototype, "zoomFactor", void 0); w.__decorate([d.property()], c.prototype, "zoomToLocation", void 0); w.__decorate([d.property()], c.prototype, "centerAtLocation", null); return c = w.__decorate([m.subclass("esri.widgets.Popup.PopupViewModel")], c)
        })
    }, "esri/symbols/support/symbolUtils": function () {
      define("require exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/maybe ../../support/arcadeOnDemand ./utils".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(t, v) { return l.apply(this, arguments) } function l() {
            l = c._asyncToGenerator(function* (t, v) {
              switch (t.type) {
                case "web-style": var { previewWebStyleSymbol: m } = yield new Promise((e, g) => a(["./previewWebStyleSymbol"], e, g)); return m(t, p, v); case "label-3d": case "line-3d": case "mesh-3d": case "point-3d": case "polygon-3d": return { previewSymbol3D: m } = yield new Promise((e, g) => a(["./previewSymbol3D"], e, g)), m(t, v); case "simple-marker": case "simple-line": case "simple-fill": case "picture-marker": case "picture-fill": case "text": return { previewSymbol2D: m } =
                  yield new Promise((e, g) => a(["./previewSymbol2D"], e, g)), m(t, v); case "cim": return { previewCIMSymbol: m } = yield new Promise((e, g) => a(["./previewCIMSymbol"], e, g)), m(t, v)
              }
            }); return l.apply(this, arguments)
          } function h(t) { return t && "opacity" in t ? t.opacity * h(t.parent) : 1 } function b() {
            b = c._asyncToGenerator(function* (t, v) {
              var m, e; if (t) {
                var g = t.sourceLayer; g = null != (m = u.isSome(v) && null != (e = v.useSourceLayer) && e ? g : t.layer) ? m : g; m = h(g); if (u.isSome(t.symbol) && (!u.isSome(v) || !0 !== v.ignoreGraphicSymbol)) return t = "web-style" ===
                  t.symbol.type ? yield t.symbol.fetchSymbol(u.isSome(v) ? v.abortOptions : null) : t.symbol.clone(), n.applyColorToSymbol(t, null, m), t; var x = u.isSome(v) && v.renderer || g && "renderer" in g && g.renderer; if (e = x && "getSymbolAsync" in x ? yield x.getSymbolAsync(t, v) : null) {
                    e = "web-style" === e.type ? yield e.fetchSymbol(u.isSome(v) ? v.abortOptions : null) : e.clone(); if (!("visualVariables" in x && x.visualVariables && x.visualVariables.length)) return n.applyColorToSymbol(e, null, m), e; "arcadeRequiredForVisualVariables" in x && x.arcadeRequiredForVisualVariables &&
                      (u.isNone(v) || u.isNone(v.arcade)) && (v = { ...u.unwrap(v) }, v.arcade = yield y.loadArcade()); g = yield new Promise((C, D) => a(["../../renderers/visualVariables/support/visualVariableUtils"], C, D)); var k = [], r = [], A = [], z = []; for (var B of x.visualVariables) switch (B.type) { case "color": k.push(B); break; case "opacity": r.push(B); break; case "rotation": z.push(B); break; case "size": B.target || A.push(B) }B = (B = !!k.length && k[k.length - 1]) ? g.getColor(B, t, v) : null; r = (r = !!r.length && r[r.length - 1]) ? g.getOpacity(r, t, v) : null; null != m && (r =
                        null != r ? r * m : m); n.applyColorToSymbol(e, B, r); A.length && (m = g.getAllSizes(A, t, v), yield n.applySizesToSymbol(e, m)); for (const C of z) n.applyRotationToSymbol(e, g.getRotationAngle(C, t, v), C.axis); return e
                  }
              }
            }); return b.apply(this, arguments)
          } function d() {
            d = c._asyncToGenerator(function* (t, v) {
              var m; if (t) {
                var e = h(t.layer || t.sourceLayer); if (u.isSome(t.symbol) && (!u.isSome(v) || !0 !== v.ignoreGraphicSymbol)) return t = "web-style" === t.symbol.type ? yield t.symbol.fetchSymbol(u.isSome(v) ? v.abortOptions : null) : t.symbol.clone(),
                  n.getColorFromSymbol(t, e); var g = u.isSome(v) && v.renderer || t.get("layer.renderer") || t.get("sourceLayer.renderer"), x = yield g.getSymbolAsync(t, v); if (x) {
                    x = "web-style" === x.type ? yield x.fetchSymbol(u.isSome(v) ? v.abortOptions : null) : x.clone(); x = n.getColorFromSymbol(x, e); if (!("visualVariables" in g) || "visualVariables" in g && !g.visualVariables || "visualVariables" in g && (null == (m = g.visualVariables) || !m.length)) return x; g.arcadeRequiredForVisualVariables && (u.isNone(v) || u.isNone(v.arcade)) && (v = { ...u.unwrap(v) }, v.arcade =
                      yield y.loadArcade()); m = yield new Promise((A, z) => a(["../../renderers/visualVariables/support/visualVariableUtils"], A, z)); var k = [], r = []; for (const A of g.visualVariables) switch (A.type) { case "color": k.push(A); break; case "opacity": r.push(A) }g = (g = 0 < k.length ? k[k.length - 1] : null) ? m.getColor(g, t, v) : x; t = (x = 0 < r.length ? r[r.length - 1] : null) ? m.getOpacity(x, t, v) : null; null != e && (t = null != t ? t * e : e); return g ? n.applyOpacityToColor(g, t) : null
                  }
              }
            }); return d.apply(this, arguments)
          } let f = null; w.getDisplayedColor = function (t, v) {
            return d.apply(this,
              arguments)
          }; w.getDisplayedSymbol = function (t, v) { return b.apply(this, arguments) }; w.renderColorRampPreviewHTML = function (t, v = {}) {
            var m = "horizontal" === v.align; const { width: e = m ? 75 : 24, height: g = m ? 24 : 75, gradient: x = !0 } = v; var k = window.devicePixelRatio, r = e * k, A = g * k; k = document.createElement("canvas"); k.width = r; k.height = A; k.style.width = `${e}px`; k.style.height = `${g}px`; const z = k.getContext("2d"); var B = m ? r : 0, C = m ? 0 : A; if (x) {
              const D = z.createLinearGradient(0, 0, B, C); m = t.length; const E = 1 === m ? 0 : 1 / (m - 1); t.forEach((H, J) =>
                D.addColorStop(J * E, H.toString())); z.fillStyle = D; z.fillRect(0, 0, r, A)
            } else { r = m ? r / t.length : r; A = m ? A : A / t.length; C = B = 0; for (const D of t) z.fillStyle = D.toString(), z.fillRect(B, C, r, A), B = m ? B + r : 0, C = m ? 0 : C + A } t = document.createElement("div"); t.style.width = `${e}px`; t.style.height = `${g}px`; t.style.filter = n.getCSSFilterFromEffectList(null == v ? void 0 : v.effectList); t.appendChild(k); return t
          }; w.renderDotDensityPreviewHTML = function (t, v, m) {
            const { backgroundColor: e, outline: g, dotSize: x } = t; m = m && m.swatchSize || 22; const k = Math.round(m *
              m / x ** 2 * .8), r = window.devicePixelRatio; t = document.createElement("canvas"); const A = m * r; t.width = A; t.height = A; t.style.width = `${t.width / r}px`; t.style.height = `${t.height / r}px`; const z = t.getContext("2d"); e && (z.fillStyle = e.toCss(!0), z.fillRect(0, 0, A, A), z.fill()); z.fillStyle = v.toCss(!0); if (f && f.length / 2 === k) for (v = 0; v < 2 * k; v += 2)z.fillRect(f[v], f[v + 1], x * r, x * r), z.fill(); else for (f = [], v = 0; v < 2 * k; v += 2) {
                const B = Math.floor(Math.random() * (A - 0 + 1)), C = Math.floor(Math.random() * (A - 0 + 1)); f.push(B, C); z.fillRect(B, C, x * r, x * r);
                z.fill()
              } g && (g.color && (z.strokeStyle = g.color.toCss(!0)), z.lineWidth = g.width, z.strokeRect(0, 0, A, A)); m = new Image(m, m); m.src = t.toDataURL(); return m
          }; w.renderPreviewHTML = p; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/symbols/support/utils": function () {
      define("require exports ../../chunks/_rollupPluginBabelHelpers ../../Color ../../symbols ../../core/asyncUtils ../../core/has ../../core/maybe ../../core/screenUtils ../../chunks/vec3f64 ../../layers/effects/jsonUtils ./gfxUtils ./Symbol3DMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(F) { F = F.symbolLayers; if (!F) return null; let K = null; F.forEach(P => { if ("object" !== P.type || null == P.resource.href) K = "water" === P.type ? p.unwrap(P.color) : p.isSome(P.material) ? p.unwrap(P.material.color) : null }); return K ? new q(K) : null } function v(F, K) { if (null == K) return F; F = F.toRgba(); F[3] *= K; return new q(F) } function m(F, K, P) {
            if (F = F.symbolLayers) {
              var L = N => { N = p.isSome(N) ? N : null; K = K || N || null != P && M; return v(K, P) }; F.forEach(N => {
                if ("object" !== N.type || null == N.resource.href ||
                  K) if ("water" === N.type) N.color = L(N.color); else { var G = p.isSome(N.material) ? N.material.color : null; G = L(G); p.isNone(N.material) ? N.material = new f.default({ color: G }) : N.material.color = G; null != P && "outline" in N && p.isSome(N.outline) && p.isSome(N.outline.color) && (N.outline.color = v(N.outline.color, P)) }
              })
            }
          } function e(F, K) { return g.apply(this, arguments) } function g() {
            g = c._asyncToGenerator(function* (F, K) {
            (F = F.symbolLayers) && (yield y.forEach(F, function () {
              var P = c._asyncToGenerator(function* (L) { return x(L, K) }); return function (L) {
                return P.apply(this,
                  arguments)
              }
            }()))
            }); return g.apply(this, arguments)
          } function x(F, K) { return k.apply(this, arguments) } function k() { k = c._asyncToGenerator(function* (F, K) { switch (F.type) { case "extrude": F.size = "number" === typeof K[2] ? K[2] : 0; break; case "icon": case "line": case "text": K = r(K); p.isSome(K) && (F.size = K); break; case "path": { const P = B(K, h.ONES, [F.width, void 0, F.height]); F.width = E(K[0], F.width, 1, P); F.height = E(K[2], F.height, 1, P) } break; case "object": yield A(F, K) } }); return k.apply(this, arguments) } function r(F) {
            for (const K of F) if ("number" ===
              typeof K) return K; return null
          } function A(F, K) { return z.apply(this, arguments) } function z() { z = c._asyncToGenerator(function* (F, K) { const { resourceSize: P, symbolSize: L } = yield C(F), N = B(K, P, L); F.width = E(K[0], L[0], P[0], N); F.depth = E(K[1], L[1], P[1], N); F.height = E(K[2], L[2], P[2], N) }); return z.apply(this, arguments) } function B(F, K, P) { for (let L = 0; 3 > L; L++) { const N = F[L]; switch (N) { case "symbol-value": return null != P[L] ? P[L] / K[L] : 1; case "proportional": break; default: if (N && K[L]) return N / K[L] } } return 1 } function C(F) {
            return D.apply(this,
              arguments)
          } function D() { D = c._asyncToGenerator(function* (F) { const K = yield (yield new Promise((O, R) => a(["./symbolLayerUtils"], O, R))).computeObjectLayerResourceSize(F, 10), { width: P, height: L, depth: N } = F; F = [P, N, L]; let G = 1; for (var I = 0; 3 > I; I++)if (null != F[I]) { G = F[I] / K[I]; break } for (I = 0; 3 > I; I++)null == F[I] && (F[I] = K[I] * G); return { resourceSize: K, symbolSize: F } }); return D.apply(this, arguments) } function E(F, K, P, L) { switch (F) { case "proportional": return P * L; case "symbol-value": return null != K ? K : P; default: return F } } function H() {
            H =
            c._asyncToGenerator(function* (F, K) { if (F && K) { if (u.isSymbol3D(F)) return e(F, K); if (u.isSymbol2D(F) && (K = r(K), !p.isNone(K))) switch (F.type) { case "simple-marker": F.size = K; break; case "picture-marker": { const P = F.width / F.height; 1 < P ? (F.width = K, F.height = K * P) : (F.width = K * P, F.height = K); break } case "simple-line": F.width = K; break; case "text": F.font.size = K } } }); return H.apply(this, arguments)
          } const J = /\/resource\/(.*?)\.svg$/, M = new q("white"); w.applyColorToSymbol = function (F, K, P) {
            if (F && (K || null != P)) if (K && (K = new q(K)), u.isSymbol3D(F)) m(F,
              K, P); else if (u.isSymbol2D(F)) { if (K = K || F.color) F.color = v(K, P); null != P && "outline" in F && F.outline && F.outline.color && (F.outline.color = v(F.outline.color, P)) }
          }; w.applyOpacityToColor = v; w.applyRotationToSymbol = function (F, K, P) { F && null != K && (u.isSymbol3D(F) ? (F = F.symbolLayers) && F.forEach(L => { if (L && "object" === L.type) switch (P) { case "tilt": L.tilt = K; break; case "roll": L.roll = K; break; default: L.heading = K } }) : !u.isSymbol2D(F) || "simple-marker" !== F.type && "picture-marker" !== F.type && "text" !== F.type || (F.angle = K)) }; w.applySizesToSymbol =
            function (F, K) { return H.apply(this, arguments) }; w.getCSSFilterFromEffectList = function (F) { if (!F) return null; F = F.effects.filter(K => "bloom" !== K.type).map(K => K.toJSON()); return b.effectFunctionsFromJSON(F) }; w.getColorFromSymbol = function (F, K) { if (!F) return null; let P = null; u.isSymbol3D(F) ? P = t(F) : u.isSymbol2D(F) && (P = F.color ? new q(F.color) : null); return P ? v(P, K) : null }; w.getIconHref = function (F, K) {
              K = K.resource.href; return !n("esri-canvas-svg-support") && F.styleOrigin && J.test(K) ? K.replace(J, "/resource/png/$1.png") :
                K
            }; w.getSymbolOutlineSize = function (F) { if (!F) return 0; if (u.isSymbol3D(F)) { { const K = F.symbolLayers && F.symbolLayers.length; K ? (F = F.symbolLayers.getItemAt(K - 1), F = "outline" in F ? p.get(F, "outline", "size") : void 0) : F = void 0 } return p.isSome(F) ? F : 0 } return (F = d.getStroke(F)) && l.px2pt(F.width) || 0 }; w.isVolumetricSymbol = function (F) {
              if (p.isNone(F) || !("symbolLayers" in F) || p.isNone(F.symbolLayers)) return !1; switch (F.type) {
                case "point-3d": return F.symbolLayers.some(K => "object" === K.type); case "line-3d": return F.symbolLayers.some(K =>
                  "path" === K.type); case "polygon-3d": return F.symbolLayers.some(K => "object" === K.type || "extrude" === K.type); default: return !1
              }
            }; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/symbols/support/gfxUtils": function () {
      define("exports ../../assets ../../Color ../../request ../../core/ItemCache ../../core/screenUtils ./cimSymbolUtils".split(" "), function (a, w, c, q, u, y, n) {
        function p(f) {
          if (!f) return null; let t; switch (f.type) {
            case "simple-fill": case "picture-fill": case "simple-marker": t = p(f.outline); break;
            case "simple-line": { const v = y.pt2px(f.width); "none" !== f.style && 0 !== v && (t = { color: f.color, style: d(f.style), width: v, cap: f.cap, join: "miter" === f.join ? y.pt2px(f.miterLimit) : f.join }); break } default: t = null
          }return t
        } const l = { left: "start", center: "middle", right: "end", justify: "start" }, h = { top: "text-before-edge", middle: "central", baseline: "alphabetic", bottom: "text-after-edge" }, b = new u(1E3), d = function () { const f = {}; return function (t) { if (f[t]) return f[t]; const v = t.replace(/-/g, ""); return f[t] = v } }(); c = new c([128, 128,
          128]); a.defaultThematicColor = c; a.dekebabifyLineStyle = d; a.getFill = function (f) {
            const t = f.style; let v = null; if (f) switch (f.type) {
              case "simple-marker": "cross" !== t && "x" !== t && (v = f.color); break; case "simple-fill": "solid" === t ? v = f.color : "none" !== t && (v = { type: "pattern", x: 0, y: 0, src: w.getAssetUrl(`esri/symbols/patterns/${t}.png`), width: 5, height: 5 }); break; case "picture-fill": v = { type: "pattern", src: f.url, width: y.pt2px(f.width) * f.xscale, height: y.pt2px(f.height) * f.yscale, x: y.pt2px(f.xoffset), y: y.pt2px(f.yoffset) }; break;
              case "text": v = f.color; break; case "cim": v = n.getCIMSymbolColor(f)
            }return v
          }; a.getPatternUrlWithColor = function (f, t) { const v = f + "-" + t; return void 0 !== b.get(v) ? Promise.resolve(b.get(v)) : q(f, { responseType: "image" }).then(m => { m = m.data; const e = m.naturalWidth, g = m.naturalHeight, x = document.createElement("canvas"); x.width = e; x.height = g; const k = x.getContext("2d"); k.fillStyle = t; k.fillRect(0, 0, e, g); k.globalCompositeOperation = "destination-in"; k.drawImage(m, 0, 0); m = x.toDataURL(); b.put(v, m); return m }) }; a.getSVGAlign = function (f) {
            return f =
              (f = f.horizontalAlignment) && l[f.toLowerCase()] || "middle"
          }; a.getSVGBaseline = function (f) { return (f = f.verticalAlignment) && h[f.toLowerCase()] || "alphabetic" }; a.getSVGBaselineShift = function (f) { return "bottom" === f.verticalAlignment ? "super" : null }; a.getStroke = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/ItemCache": function () {
      define(["./MemCache"], function (a) {
        return function () {
          function w(q, u) {
          this._storage = new a.MemCacheStorage; this._storage.maxSize = q; u && this._storage.registerRemoveFunc("",
            u)
          } var c = w.prototype; c.put = function (q, u) { this._storage.put(q, u, 1, 1) }; c.pop = function (q) { return this._storage.pop(q) }; c.get = function (q) { return this._storage.get(q) }; c.clear = function () { this._storage.clearAll() }; c.destroy = function () { this._storage.destroy() }; return w
        }()
      })
    }, "esri/symbols/support/cimSymbolUtils": function () {
      define(["exports", "../../Color", "../cim/utils"], function (a, w, c) {
        function q(d) {
          d = c.toCIMSymbolJSON(d); if ("CIMTextSymbol" === d.type) return d.height; let f = 0; if (d.symbolLayers) for (const t of d.symbolLayers) c.isCIMMarker(t) &&
            t.size > f ? f = t.size : c.isCIMStroke(t) && t.width > f ? f = t.width : c.isCIMFill(t); return f
        } function u(d, f, t, v) {
          if ("CIMTextSymbol" === d.type) d.height *= f; else {
            if (t && d.effects) for (const m of d.effects) p(m, f); if (d.symbolLayers) for (const m of d.symbolLayers) switch (m.type) {
              case "CIMPictureMarker": case "CIMVectorMarker": y(m, f, v); break; case "CIMPictureStroke": case "CIMSolidStroke": null != v && v.preserveOutlineWidth || (m.width *= f); break; case "CIMPictureFill": m.height *= f; m.offsetX *= f; m.offsetY *= f; break; case "CIMHatchFill": u(m.lineSymbol,
                f, !0, { ...v, preserveOutlineWidth: !1 }), m.offsetX *= f, m.offsetY *= f, m.separation *= f
            }
          }
        } function y(d, f, t) { d.markerPlacement && n(d.markerPlacement, f); d.offsetX *= f; d.offsetY *= f; d.anchorPoint && "Absolute" === d.anchorPointUnits && (d.anchorPoint = { x: d.anchorPoint.x * f, y: d.anchorPoint.y * f }); d.size *= f; if ("CIMVectorMarker" === d.type && d.markerGraphics) for (const v of d.markerGraphics) d.scaleSymbolsProportionally || u(v.symbol, f, !0, t) } function n(d, f) {
          c.isCIMMarkerStrokePlacement(d) && (d.offset *= f); switch (d.type) {
            case "CIMMarkerPlacementAlongLineRandomSize": case "CIMMarkerPlacementAlongLineSameSize": d.customEndingOffset *=
              f; d.offsetAlongLine *= f; if (d.placementTemplate && d.placementTemplate.length) { var t = d.placementTemplate.map(v => v * f); d.placementTemplate = t } break; case "CIMMarkerPlacementAlongLineVariableSize": d.maxRandomOffset *= f; d.placementTemplate && d.placementTemplate.length && (t = d.placementTemplate.map(v => v * f), d.placementTemplate = t); break; case "CIMMarkerPlacementOnLine": d.startPointOffset *= f; break; case "CIMMarkerPlacementAtExtremities": d.offsetAlongLine *= f; break; case "CIMMarkerPlacementAtRatioPositions": d.beginPosition *=
                f; d.endPosition *= f; break; case "CIMMarkerPlacementPolygonCenter": d.offsetX *= f; d.offsetY *= f; break; case "CIMMarkerPlacementInsidePolygon": d.offsetX *= f, d.offsetY *= f, d.stepX *= f, d.stepY *= f
          }
        } function p(d, f) {
          switch (d.type) {
            case "CIMGeometricEffectArrow": case "CIMGeometricEffectDonut": d.width *= f; break; case "CIMGeometricEffectBuffer": d.size *= f; break; case "CIMGeometricEffectCut": d.beginCut *= f; d.endCut *= f; d.middleCut *= f; break; case "CIMGeometricEffectDashes": d.customEndingOffset *= f; d.offsetAlongLine *= f; if (d.dashTemplate &&
              d.dashTemplate.length) { const t = d.dashTemplate.map(v => v * f); d.dashTemplate = t } break; case "CIMGeometricEffectExtension": case "CIMGeometricEffectJog": case "CIMGeometricEffectRadial": d.length *= f; break; case "CIMGeometricEffectMove": d.offsetX *= f; d.offsetY *= f; break; case "CIMGeometricEffectOffset": case "CIMGeometricEffectOffsetTangent": d.offset *= f; break; case "CIMGeometricEffectRegularPolygon": d.radius *= f; break; case "CIMGeometricEffectTaperedPolygon": d.fromWidth *= f; d.length *= f; d.toWidth *= f; break; case "CIMGeometricEffectWave": d.amplitude *=
                f, d.period *= f
          }
        } function l(d, f) { let t; t = "CIMTextSymbol" === d.type ? d.symbol : d; d = "CIMPolygonSymbol" === d.type; if (t.symbolLayers) for (const v of t.symbolLayers) if (!(v.colorLocked || d && (c.isCIMStroke(v) || c.isCIMMarker(v) && v.markerPlacement && c.isCIMMarkerStrokePlacement(v.markerPlacement)))) switch (v.type) { case "CIMVectorMarker": v.markerGraphics.forEach(m => { l(m.symbol, f) }); break; case "CIMSolidStroke": case "CIMSolidFill": h(f, v.color); break; case "CIMHatchFill": l(v.lineSymbol, f) } } function h(d, f) {
          for (const t of d) if (t.join(".") ===
            f.join(".")) return; d.push(f)
        } function b(d, f) { var t = "CIMTextSymbol" === d.type ? d.symbol : d; d = "CIMPolygonSymbol" === d.type ? !0 : !1; if (t.symbolLayers) for (const v of t.symbolLayers) if (!(v.colorLocked || d && (c.isCIMStroke(v) || c.isCIMMarker(v) && v.markerPlacement && c.isCIMMarkerStrokePlacement(v.markerPlacement)))) switch (t = f.toArray(0), v.type) { case "CIMVectorMarker": v.markerGraphics.forEach(m => { b(m.symbol, f) }); break; case "CIMSolidStroke": case "CIMSolidFill": v.color = t; break; case "CIMHatchFill": b(v.lineSymbol, f) } }
        a.applyCIMSymbolColor = function (d, f) { f instanceof w || (f = new w(f)); d = c.toCIMSymbolJSON(d); b(d, f) }; a.applyCIMSymbolRotation = function (d, f, t = !1) { d = c.toCIMSymbolJSON(d); t && 0 !== f && (f = 360 - f); if ("CIMTextSymbol" === d.type) d.angle = f; else if ("CIMPointSymbol" === d.type && d.symbolLayers) { t = f - (d.angle || 0); for (const v of d.symbolLayers) if (c.isCIMMarker(v)) { let m = v.rotation || 0; m = v.rotateClockwise ? m - t : m + t; v.rotation = m } d.angle = f } }; a.getCIMSymbolColor = function (d) {
          d = c.toCIMSymbolJSON(d); const f = []; l(d, f); return f.length ?
            new w(c.fromCIMColor(f[0])) : null
        }; a.getCIMSymbolRotation = function (d, f = !1) { d = c.toCIMSymbolJSON(d); return "CIMTextSymbol" === d.type || "CIMPointSymbol" === d.type ? f && 0 !== d.angle ? 360 - d.angle : d.angle || 0 : 0 }; a.getCIMSymbolSize = q; a.scaleCIMMarker = y; a.scaleCIMSymbolTo = function (d, f, t) {
          const v = c.toCIMSymbolJSON(d); d = q(d); if (0 === d) if ("CIMTextSymbol" === v.type) v.height = f; else {
            if (v.symbolLayers) for (const m of v.symbolLayers) switch (m.type) {
              case "CIMPictureMarker": case "CIMVectorMarker": m.size = f; break; case "CIMPictureStroke": case "CIMSolidStroke": m.width =
                f
            }
          } else u(v, f / d, !1, t)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/symbols/cim/utils": function () {
      define(["exports"], function (a) {
        function w(c, q) { "string" !== typeof c && (c = String(c)); switch (q) { case "LowerCase": return c.toLowerCase(); case "Allcaps": return c.toUpperCase(); default: return c } } a._adjustTextCase = w; a.colorToArray = function (c) { return [c.r, c.g, c.b, c.a] }; a.createLabelOverrideFunction = function (c, q, u) {
          const y = h => {
            let b = h.length; for (; b--;)if (-1 === " /-,\n".indexOf(h.charAt(b))) return !1;
            return !0
          }, n = []; var p = 0; let l = -1; do l = q.indexOf("[", p), l >= p && (l > p && (p = q.substr(p, l - p), n.push([p, null, y(p)])), p = l + 1, l = q.indexOf("]", p), l >= p && (l > p && (p = q.substr(p, l - p), (p = c[p]) && n.push([null, p, !1])), p = l + 1)); while (-1 !== l); p < q.length - 1 && (c = q.substr(p), n.push([c, null, y(c)])); return h => { let b = "", d = null; for (const f of n) { const [t, v, m] = f; if (t) m ? d = t : (d && (b += d, d = null), b += t); else { const e = h.attributes[v]; e && (d && (b += d, d = null), b += e) } } return w(b, u) }
        }; a.evaluateValueOrFunction = function (c, q, u, y) {
          return "function" ===
            typeof c ? c(q, u, y) : c
        }; a.fromCIMColor = function (c) { return c ? { r: c[0], g: c[1], b: c[2], a: c[3] / 255 } : { r: 0, g: 0, b: 0, a: 0 } }; a.getValue = c => isNaN(c) || !c ? 0 : c; a.isCIMFill = function (c) { return "CIMGradientFill" === c.type || "CIMHatchFill" === c.type || "CIMPictureFill" === c.type || "CIMSolidFill" === c.type || "CIMWaterFill" === c.type }; a.isCIMMarker = function (c) {
          return "CIMVectorMarker" === c.type || "CIMPictureMarker" === c.type || "CIMBarChartMarker" === c.type || "CIMCharacterMarker" === c.type || "CIMPieChartMarker" === c.type || "CIMStackedBarChartMarker" ===
            c.type
        }; a.isCIMMarkerStrokePlacement = function (c) { return "CIMMarkerPlacementAlongLineRandomSize" === c.type || "CIMMarkerPlacementAlongLineSameSize" === c.type || "CIMMarkerPlacementAlongLineVariableSize" === c.type || "CIMMarkerPlacementAtExtremities" === c.type || "CIMMarkerPlacementAtMeasuredUnits" === c.type || "CIMMarkerPlacementAtRatioPositions" === c.type || "CIMMarkerPlacementOnLine" === c.type || "CIMMarkerPlacementOnVertices" === c.type }; a.isCIMStroke = function (c) {
          return "CIMGradientStroke" === c.type || "CIMPictureStroke" ===
            c.type || "CIMSolidStroke" === c.type
        }; a.resampleHermite = function (c, q, u, y, n, p, l = !0) {
          const h = q / n; u /= p; const b = Math.ceil(h / 2), d = Math.ceil(u / 2); for (let v = 0; v < p; v++)for (let m = 0; m < n; m++) {
            const e = 4 * (m + (l ? p - v - 1 : v) * n); var f = 0; let g = 0, x = 0, k = 0, r = 0, A = 0, z = 0; const B = (v + .5) * u; for (let C = Math.floor(v * u); C < (v + 1) * u; C++) {
              var t = Math.abs(B - (C + .5)) / d; const D = (m + .5) * h; t *= t; for (let E = Math.floor(m * h); E < (m + 1) * h; E++) {
                let H = Math.abs(D - (E + .5)) / b; f = Math.sqrt(t + H * H); -1 <= f && 1 >= f && (f = 2 * f * f * f - 3 * f * f + 1, 0 < f && (H = 4 * (E + C * q), z += f * c[H + 3], x +=
                  f, 255 > c[H + 3] && (f = f * c[H + 3] / 250), k += f * c[H], r += f * c[H + 1], A += f * c[H + 2], g += f))
              }
            } y[e] = k / g; y[e + 1] = r / g; y[e + 2] = A / g; y[e + 3] = z / x
          }
        }; a.toCIMSymbolJSON = function (c) { var q; return null == (q = c.data) ? void 0 : q.symbol }; a.toKebabCase = c => c && c.toLowerCase().replace(/\s+/g, "-"); Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/support/layerViewUtils": function () {
      define(["exports", "../../core/maybe"], function (a, w) {
      a.extractSafeScaleBounds = function (c) {
        let { minScale: q, maxScale: u } = c; return {
          minScale: q || 0, maxScale: u ||
            0
        }
      }; a.highlightsSupported = function (c) { return c && "function" === typeof c.highlight }; a.occludeesSupported = function (c) { return c && "function" === typeof c.maskOccludee }; a.scaleBoundsPredicate = function (c, q, u) { return w.isNone(c) || c > u && (0 === q || c < q) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Popup/actions": function () {
      define(["exports", "../../support/actions/ActionButton"], function (a, w) {
        const c = new w({ id: "zoom-to-feature", title: "{messages.zoom}", className: "esri-icon-zoom-in-magnifying-glass" }),
        q = new w({ id: "remove-selected-feature", title: "{messages.remove}", className: "esri-icon-trash" }), u = new w({ id: "zoom-to-clustered-features", title: "{messages.zoom}", className: "esri-icon-zoom-in-magnifying-glass" }); w = new w({ id: "browse-clustered-features", title: "{messages.browseClusteredFeatures}", className: "esri-icon-table" }); a.all = [c, q, w, u]; a.browseClusteredFeatures = w; a.removeSelectedFeature = q; a.zoomToClusteredFeatures = u; a.zoomToFeature = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/widgets/Popup/actionUtils": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/Logger ../../core/promiseUtils ./actions".split(" "),
        function (a, w, c, q, u, y) {
          function n(m) { const { selectedFeature: e, location: g, view: x } = m; return x ? "3d" === x.type ? e || g : m.get("selectedFeature.geometry") || g : null } function p(m, e) {
            if ("3d" !== (null == e ? void 0 : e.type) || !m || "esri.Graphic" !== m.declaredClass) return !0; if ((e = e.getViewForGraphic(m)) && "whenGraphicBounds" in e) {
              let g = !1; e.whenGraphicBounds(m, { useViewElevation: !0 }).then(x => { g = !x || !x.boundingBox || x.boundingBox[0] === x.boundingBox[3] && x.boundingBox[1] === x.boundingBox[4] && x.boundingBox[2] === x.boundingBox[5] }).catch(() => { const x = new c("zoom-to:invalid-graphic", "Could not zoom to the location of the graphic.", { graphic: m }); v.error(x) }); return g
            } return !0
          } function l(m) { return h.apply(this, arguments) } function h() {
            h = w._asyncToGenerator(function* (m) {
              const { location: e, selectedFeature: g, view: x, zoomFactor: k } = m, r = n(m); if (!r) return m = new c("zoom-to:invalid-target-or-view", "Cannot zoom to location without a target and view.", { target: r, view: x }), v.error(m), Promise.reject(m); const A = x.scale / k, z = m.get("selectedFeature.geometry") ||
                e, B = z && "point" === z.type && p(g, x); y.zoomToFeature.active = !0; y.zoomToFeature.disabled = !0; try { yield m.view.goTo({ target: r, scale: B ? A : void 0 }) } finally { y.zoomToFeature.active = !1, y.zoomToFeature.disabled = !1, m.zoomToLocation = null, B && (m.location = z) }
            }); return h.apply(this, arguments)
          } function b(m) { return d.apply(this, arguments) } function d() {
            d = w._asyncToGenerator(function* (m) {
              const { selectedFeature: e, view: g } = m; if ("2d" !== (null == g ? void 0 : g.type)) throw m = new c("zoomToCluster:invalid-view", "View must be 2d MapView.",
                { view: g }), v.error(m), m; if (!e.isAggregate) throw m = new c("zoomToCluster:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.", { selectedFeature: e }), v.error(m), m; m = yield g.whenLayerView(e.sourceLayer); const x = m.createQuery(); x.aggregateIds = [e.getObjectId()]; y.zoomToClusteredFeatures.active = !0; y.zoomToClusteredFeatures.disabled = !0; ({ extent: m } = yield m.queryExtent(x)); yield g.goTo({ target: m }); y.zoomToClusteredFeatures.active = !1; y.zoomToClusteredFeatures.disabled = !1
            }); return d.apply(this,
              arguments)
          } function f() {
            f = w._asyncToGenerator(function* (m) {
              const { selectedFeature: e, view: g } = m; if ("2d" !== (null == g ? void 0 : g.type)) throw m = new c("displayClusterExtent:invalid-view", "View must be 2d MapView.", { view: g }), v.error(m), m; if (!e.isAggregate) throw m = new c("zoomToCluster:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.", { selectedFeature: e }), v.error(m), m; var x = yield g.whenLayerView(e.sourceLayer); const k = x.createQuery(); k.aggregateIds = [e.getObjectId()]; ({ extent: x } =
                yield x.queryExtent(k)); m.selectedClusterBoundaryFeature.geometry = x; g.graphics.add(m.selectedClusterBoundaryFeature)
            }); return f.apply(this, arguments)
          } function t() {
            t = w._asyncToGenerator(function* (m) {
              const { selectedFeature: e, view: g } = m; if ("2d" !== (null == g ? void 0 : g.type)) throw m = new c("browseAggregateFeatures:invalid-view", "View must be 2d MapView.", { view: g }), v.error(m), m; if (!e.isAggregate) throw m = new c("browseAggregateFeatures:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.",
                { selectedFeature: e }), v.error(m), m; m = yield g.whenLayerView(e.sourceLayer); const x = m.createQuery(); x.aggregateIds = [e.getObjectId()]; y.browseClusteredFeatures.active = !0; y.browseClusteredFeatures.disabled = !0; ({ features: m } = yield m.queryFeatures(x)); y.browseClusteredFeatures.active = !1; y.browseClusteredFeatures.disabled = !1; g.popup.open({ features: [e].concat(m), featureMenuOpen: !0 })
            }); return t.apply(this, arguments)
          } const v = q.getLogger("esri.widgets.Popup.PopupViewModel"); a.browseAggregateFeatures = function (m) {
            return t.apply(this,
              arguments)
          }; a.displayClusterExtent = function (m) { return f.apply(this, arguments) }; a.getSelectedTarget = n; a.isZoomScreenSize = p; a.removeClusteredFeaturesForBrowsing = function (m) { m.features = m.features.filter(e => e.isAggregate) }; a.triggerAction = function (m) {
            const { event: e, view: g } = m; ({ action: m } = e); var x = g && g.popup; if (!m) return Promise.reject(new c("trigger-action:missing-arguments", "Event has no action")); if (!x) return Promise.reject(new c("trigger-action:missing-arguments", "view.popup is missing")); const { disabled: k,
              id: r } = m; if (!r) return Promise.reject(new c("trigger-action:invalid-action", "action.id is missing")); if (k) return Promise.reject(new c("trigger-action:invalid-action", "Action is disabled")); if (r === y.zoomToFeature.id) return l(x.viewModel).catch(u.throwIfNotAbortError); if (r === y.zoomToClusteredFeatures.id) return b(x.viewModel); if (r === y.browseClusteredFeatures.id) return x.featureMenuOpen = !x.featureMenuOpen, x.viewModel.browseClusterEnabled = !x.viewModel.browseClusterEnabled, Promise.resolve(); x.viewModel.browseClusterEnabled =
                !1; if (r === y.removeSelectedFeature.id) { x.close(); ({ selectedFeature: m } = x); if (!m) return Promise.reject(new c(`trigger-action:${y.removeSelectedFeature.id}`, "selectedFeature is required", { selectedFeature: m })); ({ sourceLayer: x } = m); x ? x.remove(m) : g.graphics.remove(m) } return Promise.resolve()
          }; a.zoomToClusterExtent = b; a.zoomToLocation = l; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/widgets/support/GoTo": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p) {
        a.GoToMixin = l => { l = function (h) { function b(...d) { d = h.call(this, ...d) || this; d.goToOverride = null; d.view = null; return d } w._inheritsLoose(b, h); b.prototype.callGoTo = function (d) { const { view: f } = this; return this.goToOverride ? this.goToOverride(f, d) : f.goTo(d.target, d.options) }; return b }(l); c.__decorate([q.property()], l.prototype, "goToOverride", void 0); c.__decorate([q.property()], l.prototype, "view", void 0); return l = c.__decorate([p.subclass("esri.widgets.support.GoTo")], l) }; Object.defineProperty(a,
          "__esModule", { value: !0 })
        })
    }, "esri/views/GroundView": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/Collection ../core/Handles ../core/watchUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./support/GroundViewElevationSampler".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d) {
        c = function (f) {
          function t(m) {
            m = f.call(this, m) || this; m.handles = new u;
            m.view = null; m.layerViews = new q; return m
          } a._inheritsLoose(t, f); var v = t.prototype; v.initialize = function () { this.handles.add(y.when(this, "view.map.ground", m => m.load())); this.handles.add(this.layerViews.on("after-changes", () => this.layerViewsAfterChangesHandler())) }; v.destroy = function () { this._set("view", null); this.handles && (this.handles.destroy(), this.handles = null) }; v.layerViewsAfterChangesHandler = function () {
            this.handles.remove("updating"); this.handles.add(this.layerViews.map(m => m.watch("updating", () =>
              this.updateUpdating(), !0)).toArray(), "updating"); this.updateUpdating()
          }; v.updateUpdating = function () { this.notifyChange("updating") }; a._createClass(t, [{ key: "elevationSampler", get: function () { return this.view && "2d" !== this.view.type && this.view.ready && this.view.basemapTerrain && this.view.basemapTerrain.ready ? new d({ view: this.view }) : null } }, { key: "updating", get: function () { return this.suspended ? !1 : this.layerViews.some(m => m.updating) } }, { key: "suspended", get: function () { return !this.view || this.view.suspended } }]);
          return t
        }(c); w.__decorate([n.property({ readOnly: !0 })], c.prototype, "elevationSampler", null); w.__decorate([n.property({ type: Boolean, readOnly: !0 })], c.prototype, "updating", null); w.__decorate([n.property({ constructOnly: !0 })], c.prototype, "view", void 0); w.__decorate([n.property({ type: q, readOnly: !0 })], c.prototype, "layerViews", void 0); w.__decorate([n.property({ readOnly: !0 })], c.prototype, "suspended", null); return c = w.__decorate([b.subclass("esri.views.GroundView")], c)
      })
    }, "esri/views/support/GroundViewElevationSampler": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Evented ../../core/Logger ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../geometry/support/aaBoundingRect ../../geometry/support/contains ../../geometry/support/webMercatorUtils ../../layers/support/ElevationSampler ../3d/support/ElevationProvider ../3d/terrain/TerrainConst".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = q.getLogger("esri.views.support.GroundViewElevationSampler"); c = function (g) {
            function x(r) { r = g.call(this, r) || this; r.demResolution = { min: -1, max: -1 }; r.noDataValue = m.ELEVATION_NODATA_VALUE; return r } a._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this.view.basemapTerrain.on("elevation-change", () => this.emit("changed", {})) }; k.elevationAt = function (r) {
              var A = r.spatialReference; const z = this.spatialReference; return f.canProject(A, z) ? u.isNone(this.extent) ||
                !d.extentContainsPoint(this.extent, r) ? (A = u.isSome(this.extent) ? `${this.extent.xmin}, ${this.extent.ymin}, ${this.extent.xmax}, ${this.extent.ymax}` : null, e.warn("#elevationAt()", `Point used to sample elevation (${r.x}, ${r.y}) is outside of the sampler extent (${A})`), this.noDataValue) : v.getElevationAtPoint(this.view.elevationProvider, r) : (e.error(`Cannot sample elevation at a location with spatial reference (${A ? A.wkid : "unknown"}) different from the view (${z.wkid})`), null)
            }; k.queryElevation = function (r) {
              return t.updateGeometryElevation(r.clone(),
                this)
            }; a._createClass(x, [{ key: "extent", get: function () { const r = this.view.basemapTerrain; return u.isSome(r.extent) && r.spatialReference ? b.toExtent(r.extent, r.spatialReference) : null } }]); return x
          }(c.EventedAccessor); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "demResolution", void 0); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "extent", null); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "noDataValue", void 0); w.__decorate([y.property({ readOnly: !0, aliasOf: "view.basemapTerrain.spatialReference" })],
            c.prototype, "spatialReference", void 0); w.__decorate([y.property({ constructOnly: !0 })], c.prototype, "view", void 0); return c = w.__decorate([h.subclass("esri.views.support.GroundViewElevationSampler")], c)
        })
    }, "esri/layers/support/ElevationSampler": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../geometry ../../core/has ../../core/Logger ../../core/maybe ../../core/unitUtils ../../geometry/support/aaBoundingRect ../../geometry/support/contains ../../geometry/support/webMercatorUtils ../../geometry/Point".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(g, x) {
            const k = f(g, x.spatialReference); if (!k) return null; switch (g.type) {
              case "point": g.z = y.unwrapOr(x.elevationAt(k), 0); break; case "polyline": m.spatialReference = k.spatialReference; var r = g.hasM && !g.hasZ; for (var A = 0; A < g.paths.length; A++) { var z = g.paths[A], B = k.paths[A]; for (let C = 0; C < z.length; C++) { const D = z[C], E = B[C]; m.x = E[0]; m.y = E[1]; r && (D[3] = D[2]); D[2] = y.unwrapOr(x.elevationAt(m), 0) } } g.hasZ = !0; break; case "multipoint": m.spatialReference = k.spatialReference; r = g.hasM &&
                !g.hasZ; for (A = 0; A < g.points.length; A++)z = g.points[A], B = k.points[A], m.x = B[0], m.y = B[1], r && (z[3] = z[2]), z[2] = y.unwrapOr(x.elevationAt(m), 0); g.hasZ = !0
            }return g
          } function f(g, x) { if (y.isNone(g)) return null; const k = g.spatialReference; if (k.equals(x)) return g; (g = h.project(g, x)) || t.error(`Cannot project geometry spatial reference (wkid:${k.wkid}) to elevation sampler spatial reference (wkid:${x.wkid})`); return g } const t = u.getLogger("esri.layers.support.ElevationSampler"); c = function () {
            function g() { } var x = g.prototype;
            x.queryElevation = function (k) { return d(k.clone(), this) }; x.on = function () { return e }; x.projectIfRequired = function (k, r) { return f(k, r) }; return g
          }(); let v = function (g) {
            function x(r, A, z) { var B = g.call(this) || this; B.tile = r; B.noDataValue = z; B.extent = p.toExtent(r.tile.extent, A.spatialReference); z = n.getMetersPerUnitForSR(A.spatialReference); r = A.lodAt(r.tile.level).resolution * z; B.demResolution = { min: r, max: r }; return B } w._inheritsLoose(x, g); var k = x.prototype; k.contains = function (r) {
              r = this.projectIfRequired(r, this.spatialReference);
              return l.extentContainsPoint(this.extent, r)
            }; k.elevationAt = function (r) { var A = this.projectIfRequired(r, this.spatialReference); return y.isNone(A) ? null : this.contains(r) ? this.tile.sample(A.x, A.y) : (A = this.extent, t.warn("#elevationAt()", `Point used to sample elevation (${r.x}, ${r.y}) is outside of the sampler extent (${`${A.xmin}, ${A.ymin}, ${A.xmax}, ${A.ymax}`})`), this.noDataValue) }; w._createClass(x, [{ key: "spatialReference", get: function () { return this.extent.spatialReference } }]); return x
          }(c); q = function (g) {
            function x(k,
              r, A) {
                var z = g.call(this) || this; let B; "number" === typeof r ? (z.noDataValue = r, B = null) : (B = r, z.noDataValue = A); z.samplers = B ? k.map(C => new v(C, B, z.noDataValue)) : k; if (k = z.samplers[0]) { z.extent = k.extent.clone(); const { min: C, max: D } = k.demResolution; z.demResolution = { min: C, max: D }; for (k = 1; k < z.samplers.length; k++)r = z.samplers[k], z.extent.union(r.extent), z.demResolution.min = Math.min(z.demResolution.min, r.demResolution.min), z.demResolution.max = Math.max(z.demResolution.max, r.demResolution.max) } else z.extent = p.toExtent(p.create(),
                  B.spatialReference), z.demResolution = { min: 0, max: 0 }; return z
            } w._inheritsLoose(x, g); x.prototype.elevationAt = function (k) { const r = this.projectIfRequired(k, this.spatialReference); if (!r) return null; for (const A of this.samplers) if (A.contains(r)) return A.elevationAt(r); t.warn("#elevationAt()", `Point used to sample elevation (${k.x}, ${k.y}) is outside of the sampler`); return this.noDataValue }; w._createClass(x, [{ key: "spatialReference", get: function () { return this.extent.spatialReference } }]); return x
          }(c); const m =
            new b, e = { remove() { } }; a.ElevationSamplerBase = c; a.MultiTileElevationSampler = q; a.TileElevationSampler = v; a.updateGeometryElevation = d; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/ElevationProvider": function () {
      define(["exports", "../../../core/maybe", "../../../layers/graphics/dehydratedFeatureUtils"], function (a, w, c) {
        function q(u) { return "array" in u } a.SamplePosition = function (u, y = null, n = 0) { this.array = u; this.spatialReference = y; this.offset = n }; a.getElevationAtPoint = function (u, y, n =
          "ground") { if (c.isDehydratedPoint(y)) return u.getElevation(y.x, y.y, y.z || 0, y.spatialReference, n); if (q(y)) { let p = y.offset; return u.getElevation(y.array[p++], y.array[p++], y.array[p] || 0, w.unwrapOr(y.spatialReference, u.spatialReference), n) } return u.getElevation(y[0], y[1], y[2] || 0, u.spatialReference, n) }; a.isSamplePosition = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/graphics/dehydratedFeatureUtils": function () {
      define(["exports"], function (a) {
      a.isDehydratedPoint = function (w) {
        return "point" ===
          w.type
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TerrainConst": function () {
      define(["exports", "../../../core/mathUtils", "../../../geometry/support/aaBoundingRect", "./TilingScheme"], function (a, w, c, q) {
        w = w.clampFloat32(w.NUMBER_MAX_FLOAT32 / 10); const u = c.create(); q.WebMercatorAuxiliarySphere.getExtent(0, 0, 0, u); c = c.create([-180, -90, 180, 90]); a.DEFAULT_TILE_BACKGROUND = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA2JJREFUeNrs3d1O20AQgFFvRJInQLQBhHj/h0JVW34El1yQ2F73DVq3jTys55zrqUBbPrErZUSZ+vcOsto4AjK76Lqu1vr8+G3mPzjc3D/+eJj/Bcz/cd75R80fbu79BsAVCAQAAgABgABAACAAEAAIAAQAAgABQPOKfQAy83Ho+HnnHzXv49B4A4AAQAAgABAACAAEAAIAAYAAQAAgABAANM4+AKnZB4ifd/5R8/YB8AYAAYAAQAAgABAACAAEAAIAAYAAQAAgAGicfQBSsw8QP+/8o+btA+ANAAIAAYAAQAAgABAACAAEAAIAAYAAQADQOPsApGYfIH7e+UfN2wfAGwAEAAIAAYAAQAAgABAACAAEAAIAAXA201QdggAggH0AUrMPED8/jsPL03fns/y8fQC8AUAAIAAQAAgABAACAAGAAEAAIAAQAAgAGmcfgNTsA8TP2weImrcPgDcACAAEAAIAAYAAQAAgABAACAAEAAIAAUDj7AOQmn2A+Hn7AFHz9gHwBgABgABAACAAEAAIAAQAAgABgABgNS4cAf9pu9u3O1+m/n2aplKK/0j+TX86/tVP5+eZ3+729gFIfwWyDxA7bx8gat4+ANkJAAGAAEAAIAAQAAgABAACAAGAAEAAIABonn0AUrMPED9vHyBq3j4A3gAgABAACAAEAAIAAYAAQAAgABAA51VrdQgCAAHAsuwDkJp9gPj5vj+9vvx0PsvP2wfAGwAEAAIAAYAAQAAgABAACAAEAAIAAYAAoHH2AUjNPkD8vH2AqHn7AHgDgABAACAAEAAIAAQAAgABgABAACAAEAA0zj4AqdkHiJ+3DxA1bx8AbwAQACQ0DL0AyKuOowBwBYKUSikCIHUBAsAVCAQAAgABgABAALBy9gFIzT5A/Lx9gKj5y6trVyC8AUAAIAAQAAgAVq90Pg5N5gA2AsAVCAQAAgABgABAALB29gFIzT5A/Lx9gKj5q6+3rkB4A4AAQAAgABAACADWzB/IIHsCAsAVCARAlKlWhyAAEAAIABZjH4DU7APEz5+OH2+vT85n+fkvhztXILwBQAAgABAACAAEAGtWigBIHcBGALgCgQBAACAAyPMO9nHosxuHodZx5vB2t691HIdh/nx/Os7/Zsz/fvgXAAAA//8DAF1P1hM2ICMfAAAAAElFTkSuQmCC";
        a.ELEVATION_DESIRED_MAX_UPSCALING_DISTANCE = 4; a.ELEVATION_NODATA_VALUE = w; a.GEOGRAPHIC_WORLD_EXTENT = c; a.GEOMETRY_VERTEX_STRIDE = 5; a.MAX_MEMORY_LOD_BIAS = 2.5; a.MAX_PATCH_TESSELATION = 512; a.MAX_ROOT_TILES = 64; a.PROGRESSIVE_LOADING_MODULO = 4; a.TILE_LOADING_DEBUGLOG = !1; a.TOO_MANY_ROOT_TILES_AFTER_CHANGE_ERROR = "Cannot extend surface to encompass all layers because it would result in too many root tiles."; a.TOO_MANY_ROOT_TILES_FOR_LAYER_ERROR = "Surface extent is too large for tile resolution at level 0."; a.WEBMERCATOR_WORLD_EXTENT =
          u; a.getElevationDesiredResolutionLevel = y => 4 > y ? 3 : 4; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TilingScheme": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../core/Error ../../../core/mathUtils ../../../core/maybe ../../../core/unitUtils ../../../geometry/Extent ../../../geometry/projection ../../../geometry/SpatialReference ../../../geometry/support/aaBoundingRect ../../../geometry/support/spatialReferenceUtils ../../../geometry/support/webMercatorUtils ../../../layers/support/TileInfo".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          let f = function () {
            function v(e) {
              var g = v.checkUnsupported(e); if (q.isSome(g)) throw g; e = q.unwrap(e); this.spatialReference = e.spatialReference; this._isWebMercator = this.spatialReference.isWebMercator; this._isGCS = n.canProjectToWGS84ComparableLonLat(this.spatialReference) || h.isMars(this.spatialReference) || h.isMoon(this.spatialReference); this.origin = [e.origin.x, e.origin.y]; this.pixelSize = e.size[0]; this.dpi = e.dpi; var x = e.lods.reduce(function (A, z, B) {
              z.level < A.min && (A.min = z.level,
                A.minIndex = B); A.max = Math.max(A.max, z.level); return A
              }, { min: Infinity, minIndex: 0, max: -Infinity }), k = e.lods[x.minIndex]; const r = 2 ** k.level; g = k.resolution * r; k = k.scale * r; this.levels = Array(x.max + 1); for (x = 0; x < this.levels.length; x++)this.levels[x] = { resolution: g, scale: k, tileSize: [g * e.size[0], g * e.size[1]] }, g /= 2, k /= 2
            } var m = v.prototype; m.clone = function () { return new v(this.toTileInfo()) }; m.toTileInfo = function () {
              return new d({
                dpi: this.dpi, origin: { x: this.origin[0], y: this.origin[1], spatialReference: this.spatialReference },
                size: [this.pixelSize, this.pixelSize], spatialReference: this.spatialReference, lods: this.levels.map((e, g) => ({ level: g, scale: e.scale, resolution: e.resolution }))
              })
            }; m.getExtent = function (e, g, x, k) { var r = this.levels[e]; e = r.tileSize[0]; r = r.tileSize[1]; k[0] = this.origin[0] + x * e; k[2] = k[0] + e; k[3] = this.origin[1] - g * r; k[1] = k[3] - r }; m.convertExtentToRadians = function (e, g) {
              this._isWebMercator ? (g[0] = b.x2lon(e[0]), g[1] = b.y2lat(e[1]), g[2] = b.x2lon(e[2]), g[3] = b.y2lat(e[3])) : this._isGCS && (g[0] = c.deg2rad(e[0]), g[1] = c.deg2rad(e[1]),
                g[2] = c.deg2rad(e[2]), g[3] = c.deg2rad(e[3]))
            }; m.getExtentGeometry = function (e, g, x, k = new y) { this.getExtent(e, g, x, t); k.spatialReference = this.spatialReference; k.xmin = t[0]; k.ymin = t[1]; k.xmax = t[2]; k.ymax = t[3]; k.zmin = void 0; k.zmax = void 0; return k }; m.ensureMaxLod = function (e) { if (null == e) return !1; for (var g = !1; this.levels.length <= e;) { g = this.levels[this.levels.length - 1]; const x = g.resolution / 2; this.levels.push({ resolution: x, scale: g.scale / 2, tileSize: [x * this.pixelSize, x * this.pixelSize] }); g = !0 } return g }; m.capMaxLod =
              function (e) { this.levels.length > e + 1 && (this.levels.length = e + 1) }; m.getMaxLod = function () { return this.levels.length - 1 }; m.scaleAtLevel = function (e) { return this.levels[0].scale / 2 ** e }; m.levelAtScale = function (e) { const g = this.levels[0].scale; return e >= g ? 0 : Math.log(g / e) * Math.LOG2E }; m.resolutionAtLevel = function (e) { return this.levels[0].resolution / 2 ** e }; m.compatibleWith = function (e) {
                if (!(e instanceof v)) { if (v.checkUnsupported(e)) return !1; e = new v(e) } if (!e.spatialReference.equals(this.spatialReference) || e.pixelSize !==
                  this.pixelSize) return !1; const g = Math.min(this.levels.length, e.levels.length) - 1, x = this.levels[g].resolution; let k = .5 * x; if (!c.floatEqualAbsolute(e.origin[0], this.origin[0], k) || !c.floatEqualAbsolute(e.origin[1], this.origin[1], k)) return !1; k = .5 * x / 2 ** g / this.pixelSize * 12; return c.floatEqualAbsolute(x, e.levels[g].resolution, k)
              }; m.rootTilesInExtent = function (e, g = null, x = Infinity) {
                const k = [], r = this.levels[0].tileSize; if (q.isNone(e) || 0 === r[0] || 0 === r[1]) return k; v.computeRowColExtent(e, r, this.origin, t); e = t[1];
                let A = t[3], z = t[0], B = t[2]; var C = B - z; const D = A - e; C * D > x && (x = Math.floor(Math.sqrt(x)), D > x && (e = e + Math.floor(.5 * D) - Math.floor(.5 * x), A = e + x), C > x && (z = z + Math.floor(.5 * C) - Math.floor(.5 * x), B = z + x)); for (x = e; x < A; x++)for (C = z; C < B; C++)k.push([0, x, C]); q.isSome(g) && (g[0] = this.origin[0] + z * r[0], g[1] = this.origin[1] - A * r[1], g[2] = this.origin[0] + B * r[0], g[3] = this.origin[1] - e * r[1]); return k
              }; v.computeRowColExtent = function (e, g, x, k) {
                const r = .001 * (e[2] - e[0] + (e[3] - e[1])); k[0] = Math.max(0, Math.floor((e[0] + r - x[0]) / g[0])); k[2] = Math.max(0,
                  Math.ceil((e[2] - r - x[0]) / g[0])); k[1] = Math.max(0, Math.floor((x[1] - e[3] + r) / g[1])); k[3] = Math.max(0, Math.ceil((x[1] - e[1] - r) / g[1]))
              }; v.isPowerOfTwo = function (e) { e = e.lods; const g = e[0].resolution * 2 ** e[0].level; return !e.some(function (x) { return !c.floatEqualRelative(x.resolution, g / 2 ** x.level) }) }; v.hasGapInLevels = function (e) { e = e.lods.map(function (g) { return g.level }); e.sort(function (g, x) { return g - x }); for (let g = 1; g < e.length; g++)if (e[g] !== e[0] + g) return !0; return !1 }; v.tileSizeSupported = function (e) {
                const g = e.size[1];
                return g === e.size[0] && 0 === (g & g - 1) && 128 <= g && 512 >= g
              }; v.hasOriginPerLODs = function (e) { const g = e.origin; return e.lods.some(x => null != x.origin && (x.origin[0] !== g.x || x.origin[1] !== g.y)) }; v.checkUnsupported = function (e) {
                return q.isNone(e) ? new w("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information") : 1 > e.lods.length ? new w("tilingscheme:generic", "Tiling scheme must have at least one level") : v.isPowerOfTwo(e) ? v.hasGapInLevels(e) ? new w("tilingscheme:gaps", "Tiling scheme levels must not have gaps between min and max level") :
                  v.tileSizeSupported(e) ? v.hasOriginPerLODs(e) ? new w("tilingscheme:multiple-origin", "Tiling scheme levels must not have their own origin") : null : new w("tilingscheme:tile-size", "Tiles must be square and size must be one of [128, 256, 512]") : new w("tilingscheme:power-of-two", "Tiling scheme must be power of two")
              }; v.fromExtent = function (e, g) {
                const x = e[2] - e[0], k = e[3] - e[1], r = u.getMetersPerUnitForSR(g), A = 1.2 * Math.max(x, k); e = new v(new d({
                  size: [256, 256], origin: { x: e[0] - .5 * (A - x), y: e[3] + .5 * (A - k) }, lods: [{
                    level: 0,
                    resolution: A / 256, scale: 1 / (256 / 96 * .0254 / (A * r))
                  }], spatialReference: g
                })); e.ensureMaxLod(20); return e
              }; v.makeWebMercatorAuxiliarySphere = function (e) { const g = new v(v.WebMercatorAuxiliarySphereTileInfo); g.ensureMaxLod(e); return g }; v.makeGCSWithTileSize = function (e, g = 256, x = 16) { const k = 256 / g; e = new v(new d({ size: [g, g], origin: { x: -180, y: 90, spatialReference: e }, spatialReference: e, lods: [{ level: 0, resolution: .703125 * k, scale: 2.95497598570834E8 * k }] })); e.ensureMaxLod(x); return e }; a._createClass(v, [{
                key: "test", get: function () {
                  return {
                    isWebMercator: this._isWebMercator,
                    isGCS: this._isGCS
                  }
                }
              }]); return v
          }(); f.WebMercatorAuxiliarySphereTileInfo = new d({ size: [256, 256], origin: { x: -2.0037508342787E7, y: 2.0037508342787E7, spatialReference: p.WebMercator }, spatialReference: p.WebMercator, lods: [{ level: 0, resolution: 156543.03392800014, scale: 5.91657527591555E8 }] }); f.WebMercatorAuxiliarySphere = f.makeWebMercatorAuxiliarySphere(19); const t = l.create(); return f
        })
    }, "esri/layers/support/TileInfo": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/maybe ../../core/unitUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../geometry/Point ../../geometry/SpatialReference ../../geometry/support/aaBoundingRect ../../geometry/support/spatialReferenceUtils ../../geometry/support/webMercatorUtils ./LOD".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
          var k; c = new c.JSONMap({ PNG: "png", PNG8: "png8", PNG24: "png24", PNG32: "png32", JPEG: "jpg", JPG: "jpg", DIB: "dib", TIFF: "tiff", EMF: "emf", PS: "ps", PDF: "pdf", GIF: "gif", SVG: "svg", SVGZ: "svgz", Mixed: "mixed", MIXED: "mixed", LERC: "lerc", LERC2D: "lerc2d", RAW: "raw", pbf: "pbf" }); q = k = function (r) {
            function A(B) { B = r.call(this, B) || this; B.dpi = 96; B.format = null; B.origin = null; B.minScale = 0; B.maxScale = 0; B.size = null; B.spatialReference = null; return B } a._inheritsLoose(A, r); A.create = function (B =
              {}) {
                const { resolutionFactor: C = 1, scales: D, size: E = 256, spatialReference: H = v.WebMercator, numLODs: J = 24 } = B; if (!e.isValid(H)) { B = []; if (D) for (var M = 0; M < D.length; M++) { var F = D[M]; B.push({ level: M, scale: F, resolution: F }) } else for (M = 5E-4, F = J - 1; 0 <= F; F--)B.unshift({ level: F, scale: M, resolution: M }), M *= 2; return new k({ dpi: 96, lods: B, origin: new t(0, 0, H), size: [E, E], spatialReference: H }) } M = e.getInfo(H); B = B.origin ? new t({ x: B.origin.x, y: B.origin.y, spatialReference: H }) : M ? new t({ x: M.origin[0], y: M.origin[1], spatialReference: H }) :
                  new t({ x: 0, y: 0, spatialReference: H }); M = 1 / (39.37 * y.getMetersPerUnitForSR(H) * 96); F = []; if (D) for (var K = 0; K < D.length; K++) { var P = D[K]; F.push({ level: K, scale: P, resolution: P * M }) } else { var L = e.isGeographic(H) ? 512 / E * 5.916575275917094E8 : 256 / E * 5.91657527591555E8; K = Math.ceil(J / C); F.push({ level: 0, scale: L, resolution: L * M }); for (P = 1; P < K; P++)L /= 2 ** C, F.push({ level: P, scale: L, resolution: L * M }) } return new k({ dpi: 96, lods: F, origin: B, size: [E, E], spatialReference: H })
            }; var z = A.prototype; z.readOrigin = function (B, C) {
              return t.fromJSON({
                spatialReference: C.spatialReference,
                ...B
              })
            }; z.readSize = function (B, C) { return [C.cols, C.rows] }; z.writeSize = function (B, C) { C.cols = B[0]; C.rows = B[1] }; z.zoomToScale = function (B) { const C = this.scales; if (0 >= B) return C[0]; if (B >= C.length - 1) return C[C.length - 1]; { const D = Math.floor(B); return C[D] / (C[D] / C[D + 1]) ** (B - D) } }; z.scaleToZoom = function (B) { const C = this.scales, D = C.length - 1; let E = 0; for (; E < D; E++) { const H = C[E], J = C[E + 1]; if (H <= B) break; if (J === B) return E + 1; if (H > B && J < B) return E + Math.log(H / B) / Math.log(H / J) } return E }; z.snapScale = function (B, C = .95) {
              B = this.scaleToZoom(B);
              return B % Math.floor(B) >= C ? this.zoomToScale(Math.ceil(B)) : this.zoomToScale(Math.floor(B))
            }; z.tileAt = function (B, C, D, E) {
              var H = this.lodAt(B); if (!H) return null; let J; if ("number" === typeof C) J = C, C = D; else { if (e.equals(C.spatialReference, this.spatialReference)) J = C.x, C = C.y; else { E = g.project(C, this.spatialReference); if (u.isNone(E)) return null; J = E.x; C = E.y } E = D } D = H.resolution * this.size[0]; H = H.resolution * this.size[1]; E || (E = { id: null, level: 0, row: 0, col: 0, extent: m.create() }); E.level = B; E.row = Math.floor((this.origin.y -
                C) / H + .001); E.col = Math.floor((J - this.origin.x) / D + .001); this.updateTileInfo(E); return E
            }; z.updateTileInfo = function (B, C = 0) { var D = this.lodAt(B.level); D || 1 !== C || (C = this.lods[this.lods.length - 1], C.level < B.level && (D = C)); if (D) { var E = B.level - D.level; C = D.resolution * this.size[0] / 2 ** E; D = D.resolution * this.size[1] / 2 ** E; B.id = `${B.level}/${B.row}/${B.col}`; B.extent || (B.extent = m.create()); B.extent[0] = this.origin.x + B.col * C; B.extent[1] = this.origin.y - (B.row + 1) * D; B.extent[2] = B.extent[0] + C; B.extent[3] = B.extent[1] + D } };
            z.upsampleTile = function (B) { const C = this._upsampleLevels[B.level]; if (!C || -1 === C.parentLevel) return !1; B.level = C.parentLevel; B.row = Math.floor(B.row / C.factor + .001); B.col = Math.floor(B.col / C.factor + .001); this.updateTileInfo(B); return !0 }; z.getTileBounds = function (B, C) { var { resolution: D } = this.lodAt(C.level); const E = D * this.size[0]; D *= this.size[1]; B[0] = this.origin.x + C.col * E; B[1] = this.origin.y - (C.row + 1) * D; B[2] = B[0] + E; B[3] = B[1] + D; return B }; z.lodAt = function (B) { return this._levelToLOD && this._levelToLOD[B] || null };
            z.clone = function () { return k.fromJSON(this.write({})) }; z._initializeUpsampleLevels = function () { const B = this.lods; this._upsampleLevels = []; let C = null; for (let D = 0; D < B.length; D++) { const E = B[D]; this._upsampleLevels[E.level] = { parentLevel: C ? C.level : -1, factor: C ? C.resolution / E.resolution : 0 }; C = E } }; a._createClass(A, [{ key: "isWrappable", get: function () { const { spatialReference: B, origin: C } = this; if (B && C) { const D = e.getInfo(B); return B.isWrappable && Math.abs(D.origin[0] - C.x) <= D.dx } return !1 } }, {
              key: "lods", set: function (B) {
                let C =
                  0, D = 0; const E = []; this._levelToLOD = {}; B && (C = -Infinity, D = Infinity, B.forEach(H => { E.push(H.scale); C = H.scale > C ? H.scale : C; D = H.scale < D ? H.scale : D; this._levelToLOD[H.level] = H })); this._set("scales", E); this._set("minScale", C); this._set("maxScale", D); this._set("lods", B); this._initializeUpsampleLevels()
              }
            }]); return A
          }(q.JSONSupport); w.__decorate([n.property({ type: Number, json: { write: !0 } })], q.prototype, "compressionQuality", void 0); w.__decorate([n.property({ type: Number, json: { write: !0 } })], q.prototype, "dpi", void 0);
          w.__decorate([n.property({ type: String, json: { read: c.read, write: c.write, origins: { "web-scene": { read: !1, write: !1 } } } })], q.prototype, "format", void 0); w.__decorate([n.property({ readOnly: !0 })], q.prototype, "isWrappable", null); w.__decorate([n.property({ type: t, json: { write: !0 } })], q.prototype, "origin", void 0); w.__decorate([b.reader("origin")], q.prototype, "readOrigin", null); w.__decorate([n.property({ type: [x], value: null, json: { write: !0 } })], q.prototype, "lods", null); w.__decorate([n.property({ readOnly: !0 })], q.prototype,
            "minScale", void 0); w.__decorate([n.property({ readOnly: !0 })], q.prototype, "maxScale", void 0); w.__decorate([n.property({ readOnly: !0 })], q.prototype, "scales", void 0); w.__decorate([n.property({ cast: r => Array.isArray(r) ? r : "number" === typeof r ? [r, r] : [256, 256] })], q.prototype, "size", void 0); w.__decorate([b.reader("size", ["rows", "cols"])], q.prototype, "readSize", null); w.__decorate([f.writer("size", { cols: { type: h.Integer }, rows: { type: h.Integer } })], q.prototype, "writeSize", null); w.__decorate([n.property({ type: v, json: { write: !0 } })],
              q.prototype, "spatialReference", void 0); return q = k = w.__decorate([d.subclass("esri.layers.support.TileInfo")], q)
        })
    }, "esri/layers/support/LOD": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p) {
        var l; c = l = function (h) {
          function b(d) {
            d = h.call(this,
              d) || this; d.cols = null; d.level = 0; d.levelValue = null; d.origin = null; d.resolution = 0; d.rows = null; d.scale = 0; return d
          } a._inheritsLoose(b, h); b.prototype.clone = function () { return new l({ cols: this.cols, level: this.level, levelValue: this.levelValue, resolution: this.resolution, rows: this.rows, scale: this.scale }) }; return b
        }(c.JSONSupport); w.__decorate([q.property({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], c.prototype, "cols", void 0); w.__decorate([q.property({
          type: n.Integer,
          json: { write: !0 }
        })], c.prototype, "level", void 0); w.__decorate([q.property({ type: String, json: { write: !0 } })], c.prototype, "levelValue", void 0); w.__decorate([q.property({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], c.prototype, "origin", void 0); w.__decorate([q.property({ type: Number, json: { write: !0 } })], c.prototype, "resolution", void 0); w.__decorate([q.property({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], c.prototype,
          "rows", void 0); w.__decorate([q.property({ type: Number, json: { write: !0 } })], c.prototype, "scale", void 0); return c = l = w.__decorate([p.subclass("esri.layers.support.LOD")], c)
      })
    }, "esri/views/PopupView": function () {
      define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/arrayUtils ../core/maybe ../core/promiseUtils ../core/Logger ../core/accessorSupport/ensureType ../core/has ../core/accessorSupport/set ../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p,
        l, h, b) {
        a.PopupView = d => {
          d = function (f) {
            function t() { return f.apply(this, arguments) || this } w._inheritsLoose(t, f); var v = t.prototype; v.fetchPopupFeatures = function () {
              var m = w._asyncToGenerator(function* (e, g) {
                yield this.when(); const { location: x, queryArea: k, layerViewsAndGraphics: r, clientOnlyGraphics: A } = yield this._prepareFetchPopupFeatures(e, g); e = Promise.resolve(A); g = this._queryLayerPopupFeatures(k, r, g); const z = g.map(B => B.promise); e = y.eachAlwaysValues([e, ...z]).then(q.flatten); return {
                  location: x, clientOnlyGraphics: A,
                  allGraphicsPromise: e, promisesPerLayerView: g
                }
              }); return function (e, g) { return m.apply(this, arguments) }
            }(); v._queryLayerPopupFeatures = function (m, e, g) { return e.map(({ layerView: x, graphics: k }) => { k = { clientGraphics: k, event: u.isSome(g) ? g.event : null, signal: u.isSome(g) ? g.signal : null, defaultPopupTemplateEnabled: u.isSome(g) ? !!g.defaultPopupTemplateEnabled : !1 }; k = x.fetchPopupFeatures(m, k); return { layerView: x, promise: k } }) }; v._isValidPopupGraphic = function (m, e) { return m && !!m.getEffectivePopupTemplate(u.isSome(e) && e.defaultPopupTemplateEnabled) };
            v._prepareFetchPopupFeatures = function () { var m = w._asyncToGenerator(function* (e, g) { const { clientGraphics: x, queryArea: k, location: r } = yield this._popupHitTestGraphics(e, g); e = this._getFetchPopupLayerViews(); const { layerViewsAndGraphics: A, clientOnlyGraphics: z } = this._graphicsPerFetchPopupLayerView(x, e); return { clientOnlyGraphics: z, layerViewsAndGraphics: A, queryArea: k, location: r } }); return function (e, g) { return m.apply(this, arguments) } }(); v._popupHitTestGraphics = function () {
              var m = w._asyncToGenerator(function* (e,
                g) { const { results: x, mapPoint: k } = yield this.popupHitTest(e); e = x.filter(A => this._isValidPopupGraphic(A.graphic, g)); const r = e.length ? e[0].mapPoint : null; return { clientGraphics: e.map(A => A.graphic), queryArea: k, location: k || r } }); return function (e, g) { return m.apply(this, arguments) }
            }(); v._getFetchPopupLayerViews = function () {
              const m = []; this.allLayerViews.forEach(e => { this._isValidPopupLayerView(e) && m.push(e) }); u.isSome(this.graphicsView) && this._isValidPopupLayerView(this.graphicsView) && m.push(this.graphicsView);
              return m.reverse()
            }; v._isValidPopupLayerView = function (m) { return u.isSome(m) && (!("layer" in m) || !m.suspended) && "fetchPopupFeatures" in m }; v._graphicsPerFetchPopupLayerView = function (m, e) { const g = [], x = new Map; e = e.map(k => { const r = []; "layer" in k ? x.set(k.layer, r) : x.set(k.graphics, r); return { layerView: k, graphics: r } }); for (const k of m) (m = x.get(k.layer) || x.get(k.sourceLayer) || null) ? m.push(k) : g.push(k); return { layerViewsAndGraphics: e, clientOnlyGraphics: g } }; return t
          }(d); return d = c.__decorate([b.subclass("esri.views.PopupView")],
            d)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layerViewModuleImportUtils": function () {
      define(["require", "exports", "../../core/Error", "../../core/maybe"], function (a, w, c, q) {
        const u = l => Object.freeze({ __proto__: null, default: l }), y = () => new Promise((l, h) => a(["./layers/TileLayerView3D"], b => l(u(b)), h)), n = () => new Promise((l, h) => a(["./layers/ElevationLayerView3D"], b => l(u(b)), h)), p = {
          analysis: () => new Promise((l, h) => a(["./layers/AnalysisLayerView3D"], b => l(u(b)), h)), "base-dynamic": () => new Promise((l,
            h) => a(["./layers/BaseDynamicLayerView3D"], b => l(u(b)), h)), "base-elevation": n, "base-tile": y, "bing-maps": y, "building-scene": () => new Promise((l, h) => a(["./layers/BuildingSceneLayerView3D"], b => l(u(b)), h)), csv: () => new Promise((l, h) => a(["./layers/CSVLayerView3D"], b => l(u(b)), h)), elevation: n, feature: () => new Promise((l, h) => a(["./layers/FeatureLayerView3D"], b => l(u(b)), h)), geojson: () => new Promise((l, h) => a(["./layers/GeoJSONLayerView3D"], b => l(u(b)), h)), graphics: () => new Promise((l, h) => a(["./layers/GraphicsLayerView3D"],
              b => l(u(b)), h)), group: () => new Promise((l, h) => a(["../layers/GroupLayerView"], b => l(u(b)), h)), imagery: () => new Promise((l, h) => a(["./layers/ImageryLayerView3D"], b => l(u(b)), h)), "integrated-mesh": () => new Promise((l, h) => a(["./layers/IntegratedMeshLayerView3D"], b => l(u(b)), h)), "map-image": () => new Promise((l, h) => a(["./layers/MapImageLayerView3D"], b => l(u(b)), h)), "ogc-feature": () => new Promise((l, h) => a(["./layers/OGCFeatureLayerView3D"], b => l(u(b)), h)), "open-street-map": y, "point-cloud": () => new Promise((l, h) => a(["./layers/PointCloudLayerView3D"],
                b => l(u(b)), h)), voxel: () => new Promise((l, h) => a(["./layers/VoxelLayerView3D"], b => l(u(b)), h)), scene: l => null == l.profile || "mesh-pyramids" === l.profile ? new Promise((h, b) => a(["./layers/SceneLayerView3D"], d => h(u(d)), b)) : new Promise((h, b) => a(["./layers/SceneLayerGraphicsView3D"], d => h(u(d)), b)), stream: () => new Promise((l, h) => a(["./layers/StreamLayerView3D"], b => l(u(b)), h)), tile: y, "imagery-tile": () => new Promise((l, h) => a(["./layers/ImageryTileLayerView3D"], b => l(u(b)), h)), "vector-tile": () => new Promise((l, h) => a(["./layers/VectorTileLayerView3D"],
                  b => l(u(b)), h)), wcs: () => new Promise((l, h) => a(["./layers/ImageryTileLayerView3D"], b => l(u(b)), h)), "web-tile": y, wfs: () => new Promise((l, h) => a(["./layers/WFSLayerView3D"], b => l(u(b)), h)), wms: () => new Promise((l, h) => a(["./layers/WMSLayerView3D"], b => l(u(b)), h)), wmts: () => new Promise((l, h) => a(["./layers/WMTSLayerView3D"], b => l(u(b)), h)), "geo-rss": null, kml: null, "map-notes": null, route: null, "subtype-group": null, unknown: null, unsupported: null
        }; w.layerView3DImporter = {
          hasLayerViewModule: l => q.isSome(p[l.type]), importLayerView: l => { var h = p[l.type]; if (!q.isSome(h)) throw l = l.declaredClass ? l.declaredClass.slice(l.declaredClass.lastIndexOf(".") + 1) : "Unknown", h = l.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), l = new c(`${h}:view-not-supported`, `${l} is not supported in 3D`), l; return h(l) }
        }; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/analysis/AnalysisViewManager3D": function () {
      define("require ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Collection ../../../core/Error ../../../core/HandleOwner ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../core/scheduling ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          const t = m => Object.freeze({ __proto__: null, default: m }), v = p.getLogger("esri.views.3d.analysis.AnalysisViewManager3D"); q = function (m) {
            function e(x) { x = m.call(this, x) || this; x._allAnalysisViews = new u; x._creatingViewCount = 0; x._items = new Map; x._scheduledUpdateHandle = null; x._analysisModules = { "area-measurement": { module: null }, "direct-line-measurement": { module: null }, "line-of-sight": { module: null }, slice: { module: null } }; return x } w._inheritsLoose(e, m); var g = e.prototype; g.destroy =
              function () { this.detach() }; g.attach = function () { this.handles.add(this._connectOwner(this.view), "analyses-owner-handles") }; g.detach = function () { this.handles.remove("analyses-owner-handles"); this._update(); this._creatingViewCount = 0 }; g.whenAnalysisView = function (x) { const k = this._items.get(x); return l.isNone(k) || 1 === k.state.list ? (x = new y("AnalysisViewManager:no-analysisview-for-analysis", "The analysis has not been added to the scene.", { analysis: x }), Promise.reject(x)) : k.createAnalysisViewTask.promise }; g._connectOwner =
                function (x) { return this._connectAnalysesCollection(x.analyses) }; g._connectAnalysesCollection = function (x) { for (const A of x) this._addAnalysis(A); const k = x.on("after-add", A => this._addAnalysis(A.item)), r = x.on("after-remove", A => this._removeAnalysis(A.item)); return { remove: () => { k.remove(); r.remove(); for (const A of x) this._removeAnalysis(A) } } }; g._addAnalysis = function (x) {
                  const k = this._items.get(x); if (null == k) {
                    const r = { state: { view: 0, list: 0 }, analysis: x, view: null, createAnalysisViewTask: null }; this._items.set(x,
                      r); r.createAnalysisViewTask = h.createTask(A => this._createAnalysisViewPromise(r, A))
                  } else k.state.list = 0
                }; g._removeAnalysis = function (x) { x = this._items.get(x); null == x ? v.error("Trying to remove analysis which was not added") : (x.state.list = 1, this._scheduleUpdate()) }; g._scheduleUpdate = function () { l.isSome(this._scheduledUpdateHandle) || (this._scheduledUpdateHandle = b.schedule(() => this._update())) }; g._update = function () {
                this._scheduledUpdateHandle = l.removeMaybe(this._scheduledUpdateHandle); this._items.forEach(x => { if (1 === x.state.list) switch (this._items.delete(x.analysis), x.state.view) { case 0: x.createAnalysisViewTask = l.abortMaybe(x.createAnalysisViewTask); break; case 1: l.isSome(x.view) && (this._allAnalysisViews.remove(x.view), x.view = l.destroyMaybe(x.view), x.createAnalysisViewTask = null) } })
                }; g._createAnalysisViewPromise = function () {
                  var x = w._asyncToGenerator(function* (k, r) {
                    var A = k.analysis; const z = A.type, B = this._analysisModules[z]; this._creatingViewCount += 1; if (l.isNone(B.module)) try { B.module = yield this._loadAnalysisModule(z) } catch (C) {
                      throw --this._creatingViewCount,
                      C;
                    } if (h.isAborted(r)) throw --this._creatingViewCount, h.createAbortError("AnalysisView creation aborted"); A = new B.module.default({ analysis: A, view: this.view }); try { yield A.when() } catch (C) { throw --this._creatingViewCount, C; } if (h.isAborted(r)) throw --this._creatingViewCount, A.destroy(), h.createAbortError("AnalysisView creation aborted"); k.view = A; k.state.view = 1; this._allAnalysisViews.add(A); --this._creatingViewCount; return A
                  }); return function (k, r) { return x.apply(this, arguments) }
                }(); g._loadAnalysisModule = function (x) {
                  switch (x) {
                    case "area-measurement": return new Promise((k,
                      r) => a(["./AreaMeasurement/AreaMeasurementView3D"], A => k(t(A)), r)); case "direct-line-measurement": return new Promise((k, r) => a(["./DirectLineMeasurement/DirectLineMeasurementView3D"], A => k(t(A)), r)); case "line-of-sight": return new Promise((k, r) => a(["./LineOfSight/LineOfSightView3D"], A => k(t(A)), r)); case "slice": return new Promise((k, r) => a(["./Slice/SliceView3D"], A => k(t(A)), r)); default: return null
                  }
                }; w._createClass(e, [{
                  key: "updating", get: function () {
                    return !this.view.ready || 0 !== this._creatingViewCount || this._allAnalysisViews.some(x =>
                      x.updating)
                  }
                }, { key: "testInfo", get: function () { return { allAnalysisViews: this._allAnalysisViews } } }]); return e
          }(n.HandleOwnerMixin(q)); c.__decorate([d.property()], q.prototype, "updating", null); c.__decorate([d.property({ constructOnly: !0 })], q.prototype, "view", void 0); c.__decorate([d.property()], q.prototype, "_allAnalysisViews", void 0); c.__decorate([d.property()], q.prototype, "_creatingViewCount", void 0); return q = c.__decorate([f.subclass("esri.views.3d.analysis.AnalysisViewManager3D")], q)
        })
    }, "esri/views/3d/constraints/Constraints": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./AltitudeConstraint ./ClipDistanceConstraint ./TiltConstraint".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        a.Constraints = function (f) { function t() { var v = f.apply(this, arguments) || this; v.tilt = new d.default; v.altitude = new h.default; v.clipDistance = new b.default; return v } w._inheritsLoose(t, f); return t }(q); c.__decorate([u.property({ type: d.default })], a.Constraints.prototype, "tilt", void 0); c.__decorate([u.property({ type: h.default })], a.Constraints.prototype, "altitude", void 0); c.__decorate([u.property({ type: b.default })], a.Constraints.prototype, "clipDistance", void 0); a.Constraints =
          c.__decorate([l.subclass("esri.views.3d.constraints.Constraints")], a.Constraints); a.default = a.Constraints; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/constraints/AltitudeConstraint": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/deprecate ../../../core/Logger ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../state/Constraints".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        a.AltitudeConstraint = function (f) {
          function t() { var v = f.apply(this, arguments) || this; v.min = d.earthAltitudeConstraint.min; v.max = d.earthAltitudeConstraint.max; return v } w._inheritsLoose(t, f); w._createClass(t, [{
            key: "mode", get: function () { u.deprecated(y.getLogger(this.declaredClass), "esri.views.SceneView.constraints.altitude.mode is deprecated. The altitude constraint no longer applies to local scenes and does not have an automatic mode anymore.", { version: "4.6" }); return "manual" },
            set: function (v) { u.deprecated(y.getLogger(this.declaredClass), "esri.views.SceneView.constraints.altitude.mode is deprecated. The altitude constraint no longer applies to local scenes and does not have an automatic mode anymore.", { version: "4.6" }) }
          }]); return t
        }(q); c.__decorate([n.property({ type: Number })], a.AltitudeConstraint.prototype, "min", void 0); c.__decorate([n.property({ type: Number })], a.AltitudeConstraint.prototype, "max", void 0); a.AltitudeConstraint = c.__decorate([b.subclass("esri.views.3d.constraints.AltitudeConstraint")],
          a.AltitudeConstraint); a.default = a.AltitudeConstraint; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/Constraints": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Logger ../../../core/mathUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/support/Ellipsoid ../support/mathUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          const t = u.getLogger("esri.views.3d.state.Constraints"); a.Constraints = function (g) {
            function x(r) { r = g.call(this, r) || this; r.collision = new e; r.distance = Infinity; r.minimumPoiDistance = 4; return r } w._inheritsLoose(x, g); var k = x.prototype; k.clampAltitude = function (r) { return this.altitude ? y.clamp(r, this.altitude.min, this.altitude.max) : r }; k.clampTilt = function (r, A) { if (!this.tilt) return A; r = this.tilt(r); return y.clamp(A, r.min, r.max) }; k.clampDistance = function (r) {
              return Math.min(r,
                this.distance)
            }; k.createDefaultTilt = function () { return 2 === this.mode ? this.createDefaultTiltLocal() : this.createDefaultTiltGlobal() }; k.createConstantMaxTilt = function (r) { return (A, z = m) => { z.min = v.min; z.max = r; return z } }; k.createDefaultTiltLocal = function () { const r = this.collision.enabled ? f.makePiecewiseLinearFunction([[4E3, v.max], [1E4, y.deg2rad(88)], [6E6, y.deg2rad(88)]]) : () => v.max; return (A, z = m) => { z.min = v.min; z.max = r(A); return z } }; k.createDefaultTiltGlobal = function () {
              const r = this.collision.enabled ? f.makePiecewiseLinearFunction([[4E3,
                v.max], [5E4, y.deg2rad(88)], [6E6, y.deg2rad(88)], [2E7, v.min]]) : f.makePiecewiseLinearFunction([[3E5, v.max], [3E6, y.deg2rad(88)], [6E6, y.deg2rad(88)], [2E7, v.min]]); return (A, z = m) => { z.min = v.min; z.max = r(A); return z }
            }; w._createClass(x, [{ key: "altitude", get: function () { return 2 === this.mode ? null : this._get("altitude") || null }, set: function (r) { 2 === this.mode ? t.warn("Altitude constraint is ignored in local scenes") : this._set("altitude", r) } }]); return x
          }(q); c.__decorate([n.property()], a.Constraints.prototype, "altitude",
            null); c.__decorate([n.property({ readOnly: !0 })], a.Constraints.prototype, "collision", void 0); c.__decorate([n.property()], a.Constraints.prototype, "distance", void 0); c.__decorate([n.property({ readOnly: !0 })], a.Constraints.prototype, "minimumPoiDistance", void 0); c.__decorate([n.property()], a.Constraints.prototype, "tilt", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.Constraints.prototype, "mode", void 0); a.Constraints = c.__decorate([b.subclass("esri.views.3d.state.Constraints")], a.Constraints); u = {
              min: -2E5,
              max: 4 * d.earth.radius
            }; const v = { min: y.deg2rad(.5), max: y.deg2rad(179.5) }, m = { min: 0, max: 0 }; let e = function (g) { function x() { var k = g.apply(this, arguments) || this; k.enabled = !0; k.elevationMargin = 5; return k } w._inheritsLoose(x, g); return x }(q); c.__decorate([n.property({ type: Boolean })], e.prototype, "enabled", void 0); c.__decorate([n.property({ type: Number })], e.prototype, "elevationMargin", void 0); e = c.__decorate([b.subclass("esri.views.3d.state.Constraints.CollisionConstraint")], e); c = a.Constraints; a.TiltDefault = v; a.default =
              c; a.earthAltitudeConstraint = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/constraints/ClipDistanceConstraint": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/decorators/cast ../../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p, l) {
      a.ClipDistanceConstraint =
        function (h) {
          function b() { var f = h.apply(this, arguments) || this; f.mode = "auto"; return f } w._inheritsLoose(b, h); var d = b.prototype; d.castNear = function (f) { return Math.max(1E-8, f) }; d.castFar = function (f) { return Math.max(1E-8, f) }; d.autoUpdate = function (f, t) { "auto" === this.mode && (this._get("near") !== f && this._set("near", f), this._get("far") !== t && this._set("far", t)) }; w._createClass(b, [{
            key: "near", get: function () { return this._get("near") }, set: function (f) {
              this._set("near", f); f >= this._get("far") && (this.far = f + 1E-9); this.mode =
                "manual"
            }
          }, { key: "far", get: function () { return this._get("far") }, set: function (f) { this._set("far", f); f <= this._get("near") && (this.near = f - 1E-9); this.mode = "manual" } }]); return b
        }(q); c.__decorate([u.property({ type: Number, value: 1E-8 })], a.ClipDistanceConstraint.prototype, "near", null); c.__decorate([p.cast("near")], a.ClipDistanceConstraint.prototype, "castNear", null); c.__decorate([u.property({ type: Number, value: 1E-8 })], a.ClipDistanceConstraint.prototype, "far", null); c.__decorate([p.cast("far")], a.ClipDistanceConstraint.prototype,
          "castFar", null); c.__decorate([u.property({ type: ["auto", "manual"] })], a.ClipDistanceConstraint.prototype, "mode", void 0); a.ClipDistanceConstraint = c.__decorate([l.subclass("esri.views.3d.constraints.ClipDistanceConstraint")], a.ClipDistanceConstraint); a.default = a.ClipDistanceConstraint; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/constraints/TiltConstraint": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/mathUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/decorators/cast ../../../core/accessorSupport/decorators/subclass ../state/Constraints".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          var d = u.rad2deg(b.TiltDefault.min), f = u.rad2deg(b.TiltDefault.max); a.TiltConstraint = function (t) { function v() { var e = t.apply(this, arguments) || this; e.mode = "auto"; return e } w._inheritsLoose(v, t); var m = v.prototype; m.castMax = function (e) { return u.clamp(e, d, f) }; m.autoUpdate = function (e) { "auto" === this.mode && this._get("max") !== e && this._set("max", e) }; w._createClass(v, [{ key: "max", get: function () { return this._get("max") }, set: function (e) { this._set("max", e); this.mode = "manual" } }]); return v }(q);
          c.__decorate([y.property({ type: ["auto", "manual"] })], a.TiltConstraint.prototype, "mode", void 0); c.__decorate([y.property({ type: Number, value: f })], a.TiltConstraint.prototype, "max", null); c.__decorate([l.cast("max")], a.TiltConstraint.prototype, "castMax", null); a.TiltConstraint = c.__decorate([h.subclass("esri.views.3d.constraints.TiltConstraint")], a.TiltConstraint); a.default = a.TiltConstraint; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/environment/SceneViewEnvironment": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/lang ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/decorators/cast ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/ensureType ./SceneViewAtmosphere ./SceneViewLighting ./SunnyWeather ./weather ../../../webscene/Environment ../../../webscene/Lighting".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          var t; d = t = function (v) {
            function m(g) { g = v.call(this, g) || this; g.atmosphere = new p.default; g.weather = new h; return g } a._inheritsLoose(m, v); m.fromWebsceneEnvironment = function (g) { g = g.cloneConstructProperties(); return new t({ ...g, lighting: l.SceneViewLighting.fromWebsceneLighting(g.lighting) }) }; var e = m.prototype; e.castLighting = function (g) { return this.convertLighting(g) }; e.applyLighting = function (g) { this.lighting = this.convertLighting(g) }; e.convertLighting = function (g) {
              return g ?
                g instanceof l.SceneViewLighting ? g : g instanceof f ? this.lighting ? this.lighting.cloneWithWebsceneLighting(g) : l.SceneViewLighting.fromWebsceneLighting(g) : n.ensureType(l.SceneViewLighting, g) : new l.SceneViewLighting
            }; e.clone = function () { return new t({ lighting: this.lighting.clone(), atmosphere: this.atmosphere.clone(), weather: this.weather.clone(), atmosphereEnabled: this.atmosphereEnabled, starsEnabled: this.starsEnabled, background: c.clone(this.background) }) }; e.cloneWithWebsceneEnvironment = function (g) {
              return new t({
                atmosphere: this.atmosphere.clone(),
                weather: this.weather.clone(), atmosphereEnabled: this.atmosphereEnabled, starsEnabled: this.starsEnabled, background: c.clone(this.background), ...g.cloneConstructProperties(), lighting: null != this.lighting ? this.lighting.cloneWithWebsceneLighting(g.lighting) : l.SceneViewLighting.fromWebsceneLighting(g.lighting)
              })
            }; return m
          }(d); w.__decorate([q.property({ type: p.default, json: { read: !1 }, nonNullable: !0 })], d.prototype, "atmosphere", void 0); w.__decorate([q.property({ types: b.weatherTypes, nonNullable: !0, json: { write: !1 } })],
            d.prototype, "weather", void 0); w.__decorate([q.property()], d.prototype, "lighting", void 0); w.__decorate([u.cast("lighting")], d.prototype, "castLighting", null); return d = t = w.__decorate([y.subclass("esri.views.3d.environment.SceneViewEnvironment")], d)
        })
    }, "esri/views/3d/environment/SceneViewAtmosphere": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          var h; a.SceneViewAtmosphere = h = function (b) { function d() { return b.apply(this, arguments) || this } w._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ quality: this.quality }) }; w._createClass(d, [{ key: "quality", set: function (f) { -1 !== ["low", "high"].indexOf(f) && this._set("quality", f) } }]); return d }(q); c.__decorate([u.property({ type: ["low", "high"], value: "low" })], a.SceneViewAtmosphere.prototype, "quality", null); a.SceneViewAtmosphere = h = c.__decorate([l.subclass("esri.views.3d.environment.SceneViewAtmosphere")],
            a.SceneViewAtmosphere); a.default = a.SceneViewAtmosphere; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/environment/SceneViewLighting": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Evented ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../webscene/Lighting".split(" "), function (a,
        w, c, q, u, y, n, p, l, h) {
          function b({ hours: t, minutes: v, seconds: m }) { return Math.round(t + v / 60 + m / 3600) } var d; a.SceneViewLighting = d = function (t) {
            function v(e) { e = t.call(this, e) || this; e.positionTimezoneInfo = { hours: 0, minutes: 0, seconds: 0, autoUpdated: !0 }; e.cameraTrackingEnabled = !0; e.ambientOcclusionEnabled = !1; e.waterReflectionEnabled = !1; var g = (new Date).getFullYear(); g = new Date("March 15, " + g + " 12:00:00 UTC"); e._set("defaultDate", g); e._set("date", g); return e } w._inheritsLoose(v, t); v.fromWebsceneLighting = function (e) { return new d({ ...e.cloneConstructProperties() }) };
            var m = v.prototype; m.autoUpdate = function (e, g) { const x = b(this.positionTimezoneInfo); this.positionTimezoneInfo.hours = g.hours; this.positionTimezoneInfo.minutes = g.minutes; this.positionTimezoneInfo.seconds = g.seconds; g = null; null != e && (this.positionTimezoneInfo.autoUpdated = !0, g = this.date && this.date.getTime(), this._set("date", new Date(e.getTime()))); const k = b(this.positionTimezoneInfo); x !== k && (f.target = this, f.timezoneOffset = k, this.emit("timezone-will-change", f)); if (null != e) return g !== e.getTime() }; m.clone = function () {
              const e =
                this._get("date") === this._get("defaultDate"), g = new d({ ...this.cloneConstructProperties(), defaultDate: this.defaultDate, cameraTrackingEnabled: this.cameraTrackingEnabled, ambientOcclusionEnabled: this.ambientOcclusionEnabled, waterReflectionEnabled: this.waterReflectionEnabled }); e && g._set("date", g._get("defaultDate")); g.positionTimezoneInfo.autoUpdated = this.positionTimezoneInfo.autoUpdated; g.positionTimezoneInfo.hours = this.positionTimezoneInfo.hours; g.positionTimezoneInfo.minutes = this.positionTimezoneInfo.minutes;
              g.positionTimezoneInfo.seconds = this.positionTimezoneInfo.seconds; return g
            }; m.cloneWithWebsceneLighting = function (e) { const g = this.clone(); null != e.date && (g.date = e.date); g.directShadowsEnabled = e.directShadowsEnabled; g.displayUTCOffset = e.displayUTCOffset; return g }; w._createClass(v, [{
              key: "defaultDate", get: function () { return new Date(this._get("defaultDate").getTime()) }, set: function (e) {
                const g = this._get("date") === this._get("defaultDate"); e = new Date(e.getTime()); this._set("defaultDate", e); g && this._set("date",
                  e)
              }
            }, { key: "date", set: function (e) { null != e && (this.positionTimezoneInfo.autoUpdated = !1, this._set("date", new Date(e.getTime()))) } }]); return v
          }(q.EventedMixin(h)); c.__decorate([u.property({ type: Boolean })], a.SceneViewLighting.prototype, "cameraTrackingEnabled", void 0); c.__decorate([u.property({ type: Boolean })], a.SceneViewLighting.prototype, "ambientOcclusionEnabled", void 0); c.__decorate([u.property({ type: Boolean })], a.SceneViewLighting.prototype, "waterReflectionEnabled", void 0); c.__decorate([u.property({ type: Date })],
            a.SceneViewLighting.prototype, "defaultDate", null); c.__decorate([u.property({ type: Date })], a.SceneViewLighting.prototype, "date", null); a.SceneViewLighting = d = c.__decorate([l.subclass("esri.views.3d.environment.SceneViewLighting")], a.SceneViewLighting); const f = { target: null, timezoneOffset: 0 }; c = a.SceneViewLighting; a.calculateTimezoneOffset = b; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/webscene/Lighting": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          var b; c = b = function (d) {
            function f(v) { v = d.call(this, v) || this; v.date = null; v.directShadowsEnabled = !1; v.displayUTCOffset = null; return v } a._inheritsLoose(f, d); var t = f.prototype; t.readDate = function (v, m) { return null != m.datetime && new Date(m.datetime) || null }; t.writeDate = function (v, m, e) { m[e] = v.getTime() }; t.readDirectShadowsEnabled = function (v, m) { return !!m.directShadows }; t.writedirectShadowsEnabled = function (v, m, e) { v && (m[e] = v) }; t.writeDisplayUTCOffset = function (v, m) {
            null != v && (m.displayUTCOffset =
              v)
            }; t.clone = function () { return new b(this.cloneConstructProperties()) }; t.cloneConstructProperties = function () { const v = { directShadowsEnabled: this.directShadowsEnabled, displayUTCOffset: null != this.displayUTCOffset ? this.displayUTCOffset : null }; null != this.date && (v.date = new Date(this.date.getTime())); return v }; return f
          }(c.JSONSupport); w.__decorate([q.property({ type: Date, json: { type: Number, write: { target: "datetime" } } })], c.prototype, "date", void 0); w.__decorate([p.reader("date", ["datetime"])], c.prototype, "readDate",
            null); w.__decorate([h.writer("date")], c.prototype, "writeDate", null); w.__decorate([q.property({ type: Boolean, json: { default: !1, write: { target: "directShadows" } } })], c.prototype, "directShadowsEnabled", void 0); w.__decorate([p.reader("directShadowsEnabled", ["directShadows"])], c.prototype, "readDirectShadowsEnabled", null); w.__decorate([h.writer("directShadowsEnabled")], c.prototype, "writedirectShadowsEnabled", null); w.__decorate([q.property({ type: Number, json: { write: !0 } })], c.prototype, "displayUTCOffset", void 0);
          w.__decorate([h.writer("displayUTCOffset")], c.prototype, "writeDisplayUTCOffset", null); return c = b = w.__decorate([l.subclass("esri.webscene.Lighting")], c)
        })
    }, "esri/views/3d/environment/SunnyWeather": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          var h; c = h = function (b) { function d(f) { f = b.call(this, f) || this; f.type = "sunny"; f.cloudCover = .5; return f } a._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ cloudCover: this.cloudCover }) }; return d }(c.JSONSupport); w.__decorate([p.enumeration({ sunny: "sunny" })], c.prototype, "type", void 0); w.__decorate([q.property({ type: Number, nonNullable: !0, range: { min: 0, max: 1 } })], c.prototype, "cloudCover", void 0); return c = h = w.__decorate([l.subclass("esri.views.3d.environment.SunnyWeather")],
            c)
        })
    }, "esri/views/3d/environment/weather": function () { define(["exports", "./CloudyWeather", "./FoggyWeather", "./RainyWeather", "./SunnyWeather"], function (a, w, c, q, u) { w = { key: "type", base: null, typeMap: { sunny: u, cloudy: w, rainy: q, foggy: c } }; a.weatherEquals = function (y, n) { if (y.type !== n.type) return !1; switch (y.type) { case "sunny": case "rainy": case "cloudy": return y.cloudCover === n.cloudCover; case "foggy": return y.fogStrength === n.fogStrength } }; a.weatherTypes = w; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/environment/CloudyWeather": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) { var h; c = h = function (b) { function d(f) { f = b.call(this, f) || this; f.type = "cloudy"; f.cloudCover = .5; return f } a._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ cloudCover: this.cloudCover }) }; return d }(c); w.__decorate([p.enumeration({ cloudy: "cloudy" })], c.prototype, "type", void 0); w.__decorate([q.property({ type: Number, nonNullable: !0, range: { min: 0, max: 1 } })], c.prototype, "cloudCover", void 0); return c = h = w.__decorate([l.subclass("esri.views.3d.environment.CloudyWeather")], c) })
    },
    "esri/views/3d/environment/FoggyWeather": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p, l) {
        var h; c = h = function (b) {
          function d(f) {
            f = b.call(this, f) || this; f.type = "foggy";
            f.fogStrength = .5; return f
          } a._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ fogStrength: this.fogStrength }) }; return d
        }(c); w.__decorate([p.enumeration({ foggy: "foggy" })], c.prototype, "type", void 0); w.__decorate([q.property({ type: Number, nonNullable: !0, range: { min: 0, max: 1 } })], c.prototype, "fogStrength", void 0); return c = h = w.__decorate([l.subclass("esri.views.3d.environment.FoggyWeather")], c)
      })
    }, "esri/views/3d/environment/RainyWeather": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) { var h; c = h = function (b) { function d(f) { f = b.call(this, f) || this; f.type = "rainy"; f.cloudCover = .5; return f } a._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ cloudCover: this.cloudCover }) }; return d }(c); w.__decorate([p.enumeration({ rainy: "rainy" })], c.prototype, "type", void 0); w.__decorate([q.property({ type: Number, nonNullable: !0, range: { min: 0, max: 1 } })], c.prototype, "cloudCover", void 0); return c = h = w.__decorate([l.subclass("esri.views.3d.environment.RainyWeather")], c) })
    },
    "esri/webscene/Environment": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./Lighting ./background/utils".split(" "), function (a, w, c, q, u, y, n, p, l) {
        var h; y = (b, d, f) => ({ enabled: !f || !f.isPresentation }); c = h = function (b) {
          function d(t) {
            t = b.call(this, t) || this; t.lighting = new p; t.background = null; t.atmosphereEnabled = !0; t.starsEnabled =
              !0; return t
          } a._inheritsLoose(d, b); var f = d.prototype; f.clone = function () { return new h(this.cloneConstructProperties()) }; f.cloneConstructProperties = function () { return { lighting: p.prototype.clone.call(this.lighting), background: q.clone(this.background), atmosphereEnabled: this.atmosphereEnabled, starsEnabled: this.starsEnabled } }; return d
        }(c.JSONSupport); w.__decorate([u.property({ type: p, json: { write: !0 } })], c.prototype, "lighting", void 0); w.__decorate([u.property(l.backgroundProperty)], c.prototype, "background",
          void 0); w.__decorate([u.property({ type: Boolean, nonNullable: !0, json: { write: { overridePolicy: y } } })], c.prototype, "atmosphereEnabled", void 0); w.__decorate([u.property({ type: Boolean, nonNullable: !0, json: { write: { overridePolicy: y } } })], c.prototype, "starsEnabled", void 0); return c = h = w.__decorate([n.subclass("esri.webscene.Environment")], c)
      })
    }, "esri/webscene/background/utils": function () {
      define(["exports", "./Background", "./ColorBackground"], function (a, w, c) {
        w = { base: w, key: "type", typeMap: { color: c } }; w = {
          types: w, json: {
            read: function (q) {
              return (u,
                y, n) => { if (!u) return u; for (const p in q.typeMap) if (u.type === p) return y = new q.typeMap[p], y.read(u, n), y }
            }(w), write: { overridePolicy: (q, u, y) => ({ enabled: !y || !y.isPresentation }) }
          }
        }; a.backgroundProperty = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/webscene/background/Background": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p) { c = function (l) { function h(b) { return l.call(this, b) || this } a._inheritsLoose(h, l); h.prototype.clone = function () { }; return h }(c.JSONSupport); w.__decorate([q.property({ readOnly: !0, json: { read: !1 } })], c.prototype, "type", void 0); return c = w.__decorate([p.subclass("esri.webscene.background.Background")], c) })
    }, "esri/webscene/background/ColorBackground": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ../../symbols/support/materialUtils ./Background".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          var d; u = { ...h.colorAndTransparencyProperty, nonNullable: !0 }; b = d = function (f) { function t(m) { m = f.call(this, m) || this; m.type = "color"; m.color = new c([0, 0, 0, 1]); return m } a._inheritsLoose(t, f); var v = t.prototype; v.clone = function () { return new d(this.cloneProperties()) }; v.cloneProperties = function () { return { color: this.color.clone() } }; return t }(b); w.__decorate([p.enumeration({ color: "color" }, { readOnly: !0 })], b.prototype, "type", void 0); w.__decorate([q.property(u)], b.prototype, "color",
            void 0); return b = d = w.__decorate([l.subclass("esri.webscene.background.ColorBackground")], b)
        })
    }, "esri/views/3d/environment/SceneViewEnvironmentManager": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/Evented ../../../core/Handles ../../../core/maybe ../../../core/promiseUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4f64 ../../../geometry/projection ../../../geometry/support/spatialReferenceUtils ./EnvironmentRenderer ../support/earthUtils ../support/sunUtils ../webgl-engine/lighting/Lightsources ../../../webscene/background/ColorBackground".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B) {
        a.SceneViewEnvironmentManager = function (F) {
          function K() {
            var L = F.call(this) || this; L._referencePointUpdateDelay = 200; L._referencePointUpdateInterval = 3E3; L._referencePointUpdateDistThreshold = 1E6; L._referencePosUpdateQuery = null; L._referencePosMapCoordsRequested = null; L._viewHandles = new y; L._preserveAbsoluteDateTime = !1; L._trackingEnabled = !1; L._referencePosResetPreserveAbsoluteTime = !1; L._referencePosUpdateTimer = null; L._referencePosMapCoords = null; L._mainLight =
              new z.MainLight; L._ambientLight = new z.AmbientLight; L._moonLight = new z.FillLight; L.disableQueries = !1; L._disableWeather = !1; L._renderer = null; L._referencePosWGS84Comparable = null; L._resetReferencePosition(); return L
          } w._inheritsLoose(K, F); var P = K.prototype; P.destroy = function () { this.disconnectView(); this._viewHandles.destroy() }; P.connectView = function (L) {
          this._renderer || (this._renderer = new k.EnvironmentRenderer({ view: L }), this._viewHandles.add([L.watch("environment.lighting.date", N => this._lightingDateHandler(N),
            !0), L.watch("stationary", () => this._interactingStationaryHandler()), L.watch(["environment.lighting.directShadowsEnabled", "environment.lighting.ambientOcclusionEnabled", "environment.lighting.waterReflectionEnabled", "environment.background.color"], () => this._updateRenderParamsHandler(), !0), L.watch("spatialReference", () => this._resetReferencePosition(!0), !0), L.watch("environment.weather.type", () => this._updateLightParams(), !0), this.watch("weatherEnabled", () => this._updateLightParams(), !0), l.init(L, "viewingMode",
              () => this._resetReferencePosition(!0), !0), l.init(L, "environment.lighting.cameraTrackingEnabled", N => this._updateCameraTracking(N), !0), l.init(L, "state.camera", () => this._cameraHandler(), !0), this.watch("disableQueries", () => this._cameraHandler())]), this._updateRenderParamsHandler(), this._updateLightParams(), this._cameraHandler(), this.notifyChange("updating"))
          }; P.disconnectView = function () { this._viewHandles.removeAll(); this._resetReferencePosition(); this._renderer = n.destroyMaybe(this._renderer) }; P._updateCameraTracking =
            function (L) { if (this._trackingEnabled = L) this._cameraHandler(); else if (L = this._view.environment.lighting) L.positionTimezoneInfo.autoUpdated = !1 }; P._lightingDateHandler = function (L) {
              if (L) {
                var N = this._view.environment.lighting; if (!N.positionTimezoneInfo.autoUpdated) {
                this._preserveAbsoluteDateTime = !0; if (!g.canProjectToWGS84ComparableLonLat(this._view.spatialReference)) {
                  var G = this._view.camera.position; if (!this._referencePosMapCoords || !this._referencePosMapCoords.equals(G)) {
                    this._requestReferencePositionUpdate(G);
                    return
                  }
                } this._preupdateTracking(L); n.isSome(this._referencePosWGS84Comparable) && (G = r.positionToTimezoneInfo(this._referencePosWGS84Comparable, H), n.isSome(G) && (N.autoUpdate(null, G), this._trackingEnabled && (N.positionTimezoneInfo.autoUpdated = !0)))
                } this._updateLightParams(L)
              }
            }; P._preupdateTracking = function (L) { !this._trackingEnabled && this._view.environment.lighting.cameraTrackingEnabled && this._cameraHandler(L) }; P._cameraHandler = function (L = null) {
              var N = this._view; N.ready && (N = N.stateManager.camera) && (this._cameraHandlerClientSide(N,
                L) || this._cameraHandlerServerSide(N))
            }; P._cameraHandlerClientSide = function (L, N) {
              const G = x.isEarth(this._view.spatialReference); if (G && !g.canProjectToWGS84ComparableLonLat(this._view.spatialReference)) return !1; L = L.position; n.isNone(this._referencePosWGS84Comparable) && (this._referencePosWGS84Comparable = m.create()); G ? g.projectPointToWGS84ComparableLonLat(L, this._referencePosWGS84Comparable) : v.set(this._referencePosWGS84Comparable, L.longitude, L.latitude, L.z); this.notifyChange("referencePositionWGS84Comparable");
              this._autoUpdateTimezone(this._referencePosWGS84Comparable, N) || this._updateLightParams(N); return !0
            }; P._cameraHandlerServerSide = function (L) { L = L.position; (!this._referencePosMapCoords || this._referencePosMapCoordsRequested || this._exceedsReferencePosDistThreshold(L)) && this._requestReferencePositionUpdate(L, !0); this._view.mapCoordsHelper && this._referencePosWGS84Comparable && (this._referencePosWGS84Comparable[2] = L.z * this._view.mapCoordsHelper.unitInMeters, this._referencePosChanged()) }; P._interactingStationaryHandler =
              function () { this._view.stationary && this._executePendingReferencePositionUpdate() }; P._updateLightParams = function (L) {
                var N = this._view, G = N.environment.lighting, I = L || G.date; L = N._stage; var O = this._referencePosWGS84Comparable; G = n.isSome(O) ? C : D; n.isSome(O) && A.computeColorAndIntensity(I, O, N.state.viewingMode, C, this.weatherEnabled ? N.environment.weather.type : "disabled"); N = this._mainLight; I = G.direct; v.scale(N.intensity, I.color, I.intensity * Math.PI); v.copy(N.direction, I.directionToLightSource); O = this._ambientLight;
                v.scale(O.intensity, G.ambient.color, G.ambient.intensity); const R = this._moonLight; v.lerp(R.intensity, J, M, G.globalFactor); v.scale(R.intensity, R.intensity, (1 - .5 * G.globalFactor) * (1 - .4 * G.noonFactor * (1 - G.globalFactor))); v.copy(R.direction, I.directionToLightSource); L.renderView.updateLightSources([N, O, R], 1 - G.noonFactor, G.globalFactor); this._updateRenderParamsHandler()
              }; P._autoUpdateTimezone = function (L, N = null) {
                if (!this._view.environment.lighting.cameraTrackingEnabled || n.isNone(L)) return !1; const G = E; G.setTime((N ||
                  this._view.environment.lighting.date).getTime()); L = r.positionToTimezoneInfo(L, H); if (n.isNone(L)) return !1; var I = this._view.environment.lighting.positionTimezoneInfo; if (!I.autoUpdated) I = L; else if (I.hours === L.hours && I.minutes === L.minutes && I.seconds === L.seconds) return !1; const O = G.getUTCHours() - (L.hours - I.hours), R = G.getUTCMinutes() - (L.minutes - I.minutes); I = G.getUTCSeconds() - (L.seconds - I.seconds); G.setUTCHours(O); G.setUTCMinutes(R); G.setUTCSeconds(I); return N ? !1 : this._view.environment.lighting.autoUpdate(G,
                    L)
              }; P._updateRenderParamsHandler = function () {
                const L = this._view._stage; if (L) {
                  var N = n.mapOr(this._referencePosWGS84Comparable, !0, I => A.computeShadowsEnabled(I[2], this._view.state.viewingMode)), G = this._view.environment.background; G = G instanceof B ? { type: "color", color: e.fromArray(q.toUnitRGBA(G.color)) } : { type: "color", color: e.fromValues(0, 0, 0, 1) }; L.renderView.setRenderParameters({
                    shadowMap: this._view.environment.lighting.directShadowsEnabled && N, ssao: this._view.environment.lighting.ambientOcclusionEnabled,
                    waterReflectionEnabled: this._view.environment.lighting.waterReflectionEnabled, background: G
                  })
                }
              }; P._resetReferencePosition = function (L = !1) { this._cancelReferencePosUpdates(); this._referencePosWGS84Comparable = this._referencePosResetPreserveAbsoluteTime = this._referencePosMapCoordsRequested = this._referencePosMapCoords = null; this.notifyChange("updating"); L && this._cameraHandler() }; P._requestReferencePositionUpdate = function (L, N = !1) {
                if (!this.disableQueries && (this._referencePosMapCoordsRequested ? this._referencePosMapCoordsRequested.copy(L) :
                  this._referencePosMapCoordsRequested = L.clone(), this._referencePosResetPreserveAbsoluteTime = !!N, !this._referencePosUpdateQuery && !this._referencePosUpdateTimer && this._view.stationary)) {
                    const G = this._referencePosUpdateQuery = p.after(this._referencePointUpdateDelay).then(() => { if (this._referencePosUpdateQuery === G) return this._doReferencePositionUpdateQuery(() => this._referencePosUpdateQuery !== G) }).catch(O => { "mapcoordshelper:missing-geometry-service" === O.name && (this.disableQueries = !0) }).then(() => {
                    this._referencePosUpdateQuery ===
                      G && (this._referencePosUpdateQuery = null, this._referencePosUpdateTimer || this._executePendingReferencePositionUpdate(), this.notifyChange("updating"))
                    }), I = this._referencePosUpdateTimer = p.after(this._referencePointUpdateInterval).then(() => { this._referencePosUpdateTimer === I && (this._referencePosUpdateTimer = null, this._referencePosUpdateQuery || this._executePendingReferencePositionUpdate()) }); this.notifyChange("updating")
                }
              }; P._doReferencePositionUpdateQuery = function () {
                var L = w._asyncToGenerator(function* (N) {
                this._referencePosResetPreserveAbsoluteTime &&
                  (this._preserveAbsoluteDateTime = !1); this._referencePosMapCoords ? this._referencePosMapCoords.copy(this._referencePosMapCoordsRequested) : this._referencePosMapCoords = this._referencePosMapCoordsRequested.clone(); this._referencePosMapCoordsRequested = this._referencePosResetPreserveAbsoluteTime = null; const G = yield this._view.mapCoordsHelper.toGeographic(this._referencePosMapCoords); N() || isNaN(G[0]) || isNaN(G[1]) || (N = this._referencePosMapCoords.z * this._view.mapCoordsHelper.unitInMeters, this._referencePosWGS84Comparable ?
                    (this._referencePosWGS84Comparable[0] = G[0], this._referencePosWGS84Comparable[1] = G[1], this._referencePosWGS84Comparable[2] = N) : this._referencePosWGS84Comparable = [G[0], G[1], N], this._referencePosChanged())
                }); return function (N) { return L.apply(this, arguments) }
              }(); P._executePendingReferencePositionUpdate = function () { const L = this._referencePosMapCoordsRequested; L && this._requestReferencePositionUpdate(L, this._referencePosResetPreserveAbsoluteTime) }; P._referencePosChanged = function () {
                this._preserveAbsoluteDateTime ?
                this._updateLightParams() : this._autoUpdateTimezone(this._referencePosWGS84Comparable) || this._updateLightParams(); this.notifyChange("referencePositionWGS84Comparable")
              }; P._exceedsReferencePosDistThreshold = function (L) { return this._referencePosMapCoords ? (L = this._referencePosMapCoords.distance(L), this._view.mapCoordsHelper && (L *= this._view.mapCoordsHelper.unitInMeters), L > this._referencePointUpdateDistThreshold) : !0 }; P._cancelReferencePosUpdates = function () {
                const L = !!this._referencePosUpdateQuery; this._referencePosUpdateTimer =
                  this._referencePosUpdateQuery = null; return L
              }; w._createClass(K, [{ key: "_view", get: function () { var L; return null == (L = this._renderer) ? void 0 : L.view } }, { key: "updating", get: function () { var L; return !!(!this.disableQueries && (this._referencePosUpdateQuery || this._referencePosMapCoordsRequested) || null != (L = this._renderer) && L.updating) } }, {
                key: "weatherEnabled", get: function () {
                  var L, N, G; return (null == (L = this._view) ? void 0 : L.environment.atmosphereEnabled) && !this._disableWeather && 1 === (null == (N = this._view) ? void 0 : null ==
                    (G = N.state) ? void 0 : G.viewingMode) && x.isEarth(this._view.spatialReference)
                }
              }, { key: "referencePositionWGS84Comparable", get: function () { return this._referencePosWGS84Comparable } }, {
                key: "test", get: function () {
                  const L = this; return {
                    get renderer() { return L._renderer }, set referencePointUpdateInterval(N) { L._referencePointUpdateInterval = N }, set referencePointUpdateDistThreshold(N) { L._referencePointUpdateDistThreshold = N }, set referencePosUpdateTimer(N) { L._referencePosUpdateTimer = N }, set referencePointUpdateDelay(N) {
                    L._referencePointUpdateDelay =
                      N
                    }, set disableWeather(N) { L._disableWeather = N }
                  }
                }
              }]); return K
        }(u.EventedAccessor); c.__decorate([h.property({ type: Boolean, readOnly: !0 })], a.SceneViewEnvironmentManager.prototype, "updating", null); c.__decorate([h.property()], a.SceneViewEnvironmentManager.prototype, "disableQueries", void 0); c.__decorate([h.property()], a.SceneViewEnvironmentManager.prototype, "_disableWeather", void 0); c.__decorate([h.property()], a.SceneViewEnvironmentManager.prototype, "weatherEnabled", null); c.__decorate([h.property()], a.SceneViewEnvironmentManager.prototype,
          "referencePositionWGS84Comparable", null); c.__decorate([h.property()], a.SceneViewEnvironmentManager.prototype, "_renderer", void 0); c.__decorate([h.property()], a.SceneViewEnvironmentManager.prototype, "_referencePosWGS84Comparable", void 0); a.SceneViewEnvironmentManager = c.__decorate([t.subclass("esri.views.3d.environment.SceneViewEnvironmentManager")], a.SceneViewEnvironmentManager); const C = new A.ColorAndIntensity, D = new A.ColorAndIntensity, E = new Date, H = { hours: 0, minutes: 0, seconds: 0 }, J = m.fromValues(.22, .22,
            .33), M = m.fromValues(.22, .22, .22); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/environment/EnvironmentRenderer": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/has ../../../core/Handles ../../../core/lang ../../../core/mathUtils ../../../core/maybe ../../../core/reactiveUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec3 ../../../geometry/projectionEllipsoid ../../../geometry/support/spatialReferenceUtils ./ChapmanAtmosphere ./CloudsComposition ./CloudsGenerator ./Fog ./PanoramicAtmosphere ./SimpleAtmosphere ./Stars".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B) {
          const C = [12, 13]; a.EnvironmentRenderer = function (D) {
            function E(J) { J = D.call(this, J) || this; J._handles = new y; J._context = null; J._pendingAtmosphere = null; J._atmosphere = null; J._stars = null; J._clouds = null; J._cloudComposition = null; J._fog = null; return J } w._inheritsLoose(E, D); var H = E.prototype; H.initialize = function () { this.view._stage.addRenderPlugin(C, this) }; H.destroy = function () {
            this._pendingAtmosphere = l.destroyMaybe(this._pendingAtmosphere); this.uninitializeRenderContext();
              this._handles = l.destroyMaybe(this._handles); this.view && null != this.view._stage && (this.view._stage.removeRenderPlugin(this), this._set("view", null))
            }; H.initializeRenderContext = function (J = null) {
            this._context = J; this._handles.add([b.when(this.view, "basemapTerrain", () => this._updateBasemapTerrain(), !0), h.react(() => ({ viewingMode: this.view.viewingMode, atmosphereEnabled: this.view.environment.atmosphereEnabled, atmosphereQuality: this.view.environment.atmosphere.quality }), () => this._updateAtmosphere(), h.syncAndInitial),
            h.react(() => this._starsCreationParameters, M => this._createOrDestroyStars(M), { sync: !0, initial: !0, equals: n.equalsShallow }), h.react(() => this._cloudsCreationParameters, M => this._createOrDestroyClouds(M), { sync: !0, initial: !0, equals: n.equalsShallow }), h.react(() => this._fogCreationParameters, M => this._createOrDestroyFog(M), { sync: !0, initial: !0, equals: n.equalsShallow }), h.react(() => this._weatherUpdateParameters, M => { this._updateWeather(M); this._updateFog(M) }, h.syncAndInitial)])
            }; H.uninitializeRenderContext = function () {
            this._stars =
              l.destroyMaybe(this._stars); this._atmosphere = l.destroyMaybe(this._atmosphere); this._clouds = l.destroyMaybe(this._clouds); this._cloudComposition = l.destroyMaybe(this._cloudComposition); this._fog = l.destroyMaybe(this._fog)
            }; H.render = function (J) {
              if (0 !== J.pass) return !1; let M = !1; switch (J.slot) {
                case 12: l.isSome(this._stars) && this._stars.render(J) && (M = !0); l.isSome(this._atmosphere) && this._atmosphere.canRender && (this._atmosphere.render(J) && (M = !0), l.isSome(this._clouds) && l.isSome(this._clouds.cubeMap) && !this._clouds.running &&
                  l.isSome(this._cloudComposition) && ("sunny" !== this.view.environment.weather.type || 0 !== this.view.environment.weather.cloudCover) && (this._cloudComposition.render(J, this._clouds.cubeMap, l.isSome(this.view.animation), this._clouds.coverage, this._clouds.absorption) && (M = !0), this._cloudComposition.isFading() && this._setNeedsRender())); break; case 13: if (l.isSome(this._atmosphere) && this._atmosphere.canRender) {
                    const F = this.weatherEnabled ? this.view.environment.weather.type : "disabled"; this._atmosphere.renderHaze(J,
                      "rainy" === F) && (M = !0); l.isSome(this._fog) && ("foggy" === F || "realistic" !== this._selectAtmosphereType()) && this._fog.render(J, "foggy" === F, "rainy" === F) && (M = !0)
                  } break; default: return !1
              }return M
            }; H._createOrDestroyClouds = function (J) {
            this._clouds = l.destroyMaybe(this._clouds); this._cloudComposition = l.destroyMaybe(this._cloudComposition); l.applySome(J, ({ view: M, viewingMode: F, rctx: K, radius: P }) => {
            this._clouds = new k.CloudsGenerator({ rctx: K, view: M, requestRender: () => this._setNeedsRender() }); this._cloudComposition = new x.CloudsComposition(K,
              F, P, v.length(M.state.camera.eye) - P)
            }); this._setNeedsRender()
            }; H._updateWeather = function (J) { if (!l.isNone(J) && !l.isNone(this._clouds)) { var M = k.cloudPresets[J.type].median; for (const F in k.cloudPresets[J.type]) if ("raymarchingStepType" === F) this._clouds[F] = k.cloudPresets[J.type][F]; else if ("median" !== F) { const K = k.cloudPresets[J.type][F], P = p.lerp(K[0], K[1], M); this._clouds[F] = .5 > J.presetAdjustment ? p.lerp(K[0], P, 2 * J.presetAdjustment) : p.lerp(P, K[1], 2 * (J.presetAdjustment - .5)) } } }; H._setNeedsRender = function () {
              l.isSome(this._context) &&
              this._context.requestRender()
            }; H._createOrDestroyStars = function ({ view: J, starsEnabled: M }) { M && l.isNone(this._stars) ? (this._stars = new B.Stars({ view: J, requestRender: () => this._setNeedsRender() }), this._setNeedsRender()) : !M && l.isSome(this._stars) && (this._stars.destroy(), this._stars = null, this._setNeedsRender()) }; H._updateFog = function (J) { l.isNone(this._fog) || l.isNone(J) || (this._fog.strength = "foggy" === J.type ? p.lerp(3E-5, .005, J.presetAdjustment ** 3) : 4E-6) }; H._createOrDestroyFog = function (J) {
            this.weatherEnabled &&
              l.isNone(this._fog) ? (l.applySome(J, ({ view: M, context: F }) => { this._fog = new r.Fog(F, M) }), this._updateFog(this._weatherUpdateParameters), this._setNeedsRender()) : l.isSome(this._fog) && (this._fog.destroy(), this._fog = null, this._setNeedsRender())
            }; H._updateAtmosphere = function () {
              var J = this._selectAtmosphereType(); if (this.atmosphereType !== J) if (l.isSome(this._pendingAtmosphere) && (this._pendingAtmosphere !== this._atmosphere && this._pendingAtmosphere.destroy(), this._pendingAtmosphere = null), J = this._getAtmosphereClass()) {
                var M =
                  new J(this.view); l.isSome(this._context) && M.initializeRenderContext(this._context); l.isNone(this._atmosphere) && (this._atmosphere = M, this._setNeedsRender()); this._pendingAtmosphere = M; M.when().then(() => { l.isSome(this._atmosphere) && this._pendingAtmosphere && this._pendingAtmosphere !== this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = this._pendingAtmosphere); this._pendingAtmosphere = null; this._setNeedsRender(); this._updateBasemapTerrain() }).catch(() => {
                  this._pendingAtmosphere === M && (this._pendingAtmosphere =
                    null)
                  })
              } else l.isSome(this._atmosphere) && (this._atmosphere.destroy(), this._atmosphere = null, this._setNeedsRender()), this._updateBasemapTerrain()
            }; H._getAtmosphereClass = function () { switch (this._selectAtmosphereType()) { case "none": return null; case "realistic": return g.ChapmanAtmosphere; case "panoramic": return A.PanoramicAtmosphere; case "simple": return z } }; H._selectAtmosphereType = function () {
              const J = this.view.get("environment.atmosphereEnabled"), M = this.view.get("environment.atmosphere.quality"), F = this.view.viewingMode;
              return !J || null == M || e.isMoon(this.view.spatialReference) ? "none" : "local" === F ? "panoramic" : "high" === M && l.isSome(this._context) && g.ChapmanAtmosphere.isSupported(this._context) && e.isEarth(this.view.spatialReference) ? "realistic" : "simple"
            }; H._updateBasemapTerrain = function () { this.view.basemapTerrain && (this.view.basemapTerrain.velvetOverground = l.isSome(this._atmosphere) && "simple" === this.atmosphereType) }; w._createClass(E, [{
              key: "atmosphereType", get: function () {
                return l.isSome(this._pendingAtmosphere) ? this._pendingAtmosphere.type :
                  l.isSome(this._atmosphere) ? this._atmosphere.type : "none"
              }
            }, { key: "canRender", get: function () { var J; return !(null == (J = this.view.basemapTerrain) || !J.renderer.canRender) || "global" !== this.view.viewingMode } }, { key: "needsLinearDepth", get: function () { return "realistic" === this._selectAtmosphereType() } }, { key: "updating", get: function () { return l.isSome(this._pendingAtmosphere) || l.isSome(this._stars) && this._stars.updating || l.isSome(this._clouds) && this._clouds.running } }, {
              key: "weatherEnabled", get: function () {
                var J; return !(null ==
                  (J = this.view.environmentManager) || !J.weatherEnabled)
              }
            }, { key: "_cloudsCreationParameters", get: function () { return this.weatherEnabled ? { view: this.view, viewingMode: this.view.state.viewingMode, rctx: l.isSome(this._context) ? this._context.renderContext.rctx : null, radius: m.getReferenceEllipsoid(this.view.spatialReference).radius } : null } }, {
              key: "_weatherUpdateParameters", get: function () {
                const J = this.weatherEnabled ? this.view.environment.weather : null; return l.isNone(J) ? null : {
                  type: J.type, presetAdjustment: "foggy" ===
                    J.type ? J.fogStrength : J.cloudCover
                }
              }
            }, { key: "_starsCreationParameters", get: function () { var J, M, F; return { view: this.view, starsEnabled: null != (J = null == (M = this.view) ? void 0 : null == (F = M.environment) ? void 0 : F.starsEnabled) ? J : !1 } } }, { key: "_fogCreationParameters", get: function () { return !this.weatherEnabled || l.isNone(this._context) ? null : { view: this.view, context: this._context } } }, { key: "test", get: function () { return { atmosphere: this._atmosphere, clouds: this._clouds, selectAtmosphereType: () => this._selectAtmosphereType() } } }]);
            return E
          }(q); c.__decorate([d.property({ constructOnly: !0 })], a.EnvironmentRenderer.prototype, "view", void 0); c.__decorate([d.property({ type: Boolean, readOnly: !0 })], a.EnvironmentRenderer.prototype, "updating", null); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_pendingAtmosphere", void 0); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_stars", void 0); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_clouds", void 0); c.__decorate([d.property()], a.EnvironmentRenderer.prototype,
            "_cloudComposition", void 0); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_fog", void 0); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "weatherEnabled", null); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_cloudsCreationParameters", null); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_weatherUpdateParameters", null); c.__decorate([d.property()], a.EnvironmentRenderer.prototype, "_starsCreationParameters", null); c.__decorate([d.property()], a.EnvironmentRenderer.prototype,
              "_fogCreationParameters", null); a.EnvironmentRenderer = c.__decorate([t.subclass("esri.views.3d.environment.EnvironmentRenderer")], a.EnvironmentRenderer); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/environment/ChapmanAtmosphere": function () {
      define("exports ../../../core/Handles ../../../core/mathUtils ../../../core/maybe ../../../core/watchUtils ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec2 ../../../chunks/vec2f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4f64 ../../../geometry/support/Ellipsoid ./atmosphereUtils ./ChapmanAtmosphereTechnique ../webgl-engine/lib/DefaultVertexBufferLayouts ../webgl-engine/lib/glUtil3D".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          let g = function () {
            function x(r) {
            this._view = r; this.type = "realistic"; this.canRender = !0; this._cameraPosition = b.create(); this._projectionInverse = n.create(); this._viewInverse = n.create(); this._heightParameters = d.create(); this._betasRayleigh = b.create(); this._betasCombined = b.create(); this._scaleHeight = 0; this._radii = l.create(); this._nearFar = l.create(); this._lowerElevationBoundRadius = this._altitudeFade = this._innerFadeDistance = this._cAtmosphere = this._cameraHeightSq =
              this._cameraHeight = 0; this._lowerBoundEarthRadius = f.earth.radius; this._hazeStrength = 1; this._darkenHaze = !1; this._updateRadius(f.earth.radius)
            } var k = x.prototype; k.destroy = function () { this._atmosphereTechnique = q.releaseMaybe(this._atmosphereTechnique); this._atmosphereHazeTechnique = q.releaseMaybe(this._atmosphereHazeTechnique); this._vao = q.disposeMaybe(this._vao); this._handles = q.destroyMaybe(this._handles) }; k.when = function () { return Promise.resolve() }; k.initializeRenderContext = function (r) {
              const A = r.renderContext.rctx;
              this._handles = new w; q.isSome(this._view.basemapTerrain.rootTiles) && this._updateElevation({ spatialReference: this._view.basemapTerrain.spatialReference, tile: this._view.basemapTerrain.rootTiles[0], extent: this._view.basemapTerrain.rootTiles[0].extent, context: "ground" }); this._handles.add(u.on(this._view, "basemapTerrain", "elevation-change", B => this._updateElevation(B), () => this._updateElevation())); this._handles.add(u.on(this._view, "basemapTerrain", "elevation-bounds-change", () => this._updateVisibleElevationBounds()));
              const z = new v.ChapmanAtmosphereTechniqueConfiguration; z.haze = !1; this._atmosphereTechnique = r.shaderTechniqueRep.acquire(v.ChapmanAtmosphereTechnique, z); z.haze = !0; this._atmosphereHazeTechnique = r.shaderTechniqueRep.acquire(v.ChapmanAtmosphereTechnique, z); this._vao = e.createQuadVAO(A, m.Pos2Tex); this._scaleHeight = t.rayLeighScaleHeight * t.atmosphereHeight; h.set(this._betasRayleigh, t.betaRayleigh[0], t.betaRayleigh[1], t.betaRayleigh[2]); h.set(this._betasCombined, t.betaRayleigh[0] + t.betaOzone[0], t.betaRayleigh[1] +
                t.betaOzone[1], t.betaRayleigh[2] + t.betaOzone[2])
            }; k.render = function (r) { return this._render(r, this._atmosphereTechnique, r.offscreenRenderingHelper.depthTexture) }; k.renderHaze = function (r, A) { this._darkenHaze = A; return this._render(r, this._atmosphereHazeTechnique, r.offscreenRenderingHelper.linearDepthTexture) }; k._render = function (r, A, z) {
              this._update(r.camera); const B = r.rctx, C = r.offscreenRenderingHelper; B.useProgram(A.program); A.bindPipelineState(B); C.renderDepthDetached(() => {
                A.program.bindTexture(z, "depthTex");
                this._renderCommon(A.program, r)
              }); return !0
            }; k._renderCommon = function (r, A) {
              if (q.isNone(this._vao)) return !1; const z = A.rctx; A.scenelightingData.setLightDirectionUniform(r); r.setUniform4fv("heightParameters", this._heightParameters); r.setUniform3fv("cameraPosition", this._cameraPosition); r.setUniformMatrix4fv("projectionInverse", this._projectionInverse); r.setUniformMatrix4fv("viewInverse", this._viewInverse); r.setUniform2fv("nearFar", this._nearFar); r.setUniform2fv("radii", this._radii); r.setUniform1f("scaleHeight",
                this._scaleHeight); r.setUniform1f("betaMie", t.betaMie); r.setUniform3fv("betaRayleigh", this._betasRayleigh); r.setUniform3fv("betaCombined", this._betasCombined); r.setUniform1f("innerFadeDistance", this._innerFadeDistance); r.setUniform1f("altitudeFade", this._altitudeFade); r.setUniform1f("hazeStrength", this._hazeStrength); z.bindVAO(this._vao); r.assertCompatibleVertexAttributeLocations(this._vao); z.drawArrays(5, 0, 4); return !0
            }; k._adjustRadiusForTesselation = function (r) { return r * Math.cos(Math.PI / 16 / 16) }; k._updateElevation =
              function (r) { r = r ? r.tile : q.unwrapOr(this._view.basemapTerrain.rootTiles, [null])[0]; q.isNone(r) || 0 !== r.level || (r = this._adjustRadiusForTesselation(f.earth.radius + r.elevationBounds[0]), r !== this._lowerElevationBoundRadius && (this._lowerElevationBoundRadius = r, this._lowerBoundEarthRadius = -1, this._updateVisibleElevationBounds())) }; k._updateVisibleElevationBounds = function () {
                const r = this._adjustRadiusForTesselation(f.earth.radius + this._view.basemapTerrain.elevationBounds.min); (0 > this._lowerBoundEarthRadius ||
                  r < this._lowerBoundEarthRadius) && this._updateRadius(r)
              }; k._updateRadius = function (r) { this._lowerBoundEarthRadius = r; p.set(this._radii, r, r + t.atmosphereHeight); this._innerFadeDistance = 2 * Math.sqrt((2 * r - t.innerAtmosphereDepth) * t.innerAtmosphereDepth) }; k._update = function (r) {
                q.isNone(r) || (this._cameraHeight = h.length(r.eye), this._cameraHeightSq = this._cameraHeight * this._cameraHeight, this._cAtmosphere = this._cameraHeightSq - this._radii[1] * this._radii[1], this._heightParameters = d.fromValues(this._cameraHeight, this._cameraHeightSq,
                  this._cAtmosphere, Math.min(1, Math.max(0, (this._cameraHeight - this._radii[0]) / t.atmosphereHeight))), h.copy(this._cameraPosition, r.eye), y.invert(this._projectionInverse, r.projectionMatrix), y.invert(this._viewInverse, r.viewMatrix), p.set(this._nearFar, r.near, r.far), this._altitudeFade = t.computeInnerAltitudeFade(this._cameraHeight - this._lowerBoundEarthRadius), this._hazeStrength = this._darkenHaze ? c.lerp(.6, 1, c.smoothstep(9500, 10500, this._cameraHeight - f.earth.radius)) : 1)
              }; x.isSupported = function (r) { return r.renderContext.rctx.capabilities.depthTexture };
            return x
          }(); a.ChapmanAtmosphere = g; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/vec2": function () {
      define(["exports", "./common"], function (a, w) {
        function c(O, R) { O[0] = R[0]; O[1] = R[1]; return O } function q(O, R, S) { O[0] = R; O[1] = S; return O } function u(O, R, S) { O[0] = R[0] + S[0]; O[1] = R[1] + S[1]; return O } function y(O, R, S) { O[0] = R[0] - S[0]; O[1] = R[1] - S[1]; return O } function n(O, R, S) { O[0] = R[0] * S[0]; O[1] = R[1] * S[1]; return O } function p(O, R, S) { O[0] = R[0] / S[0]; O[1] = R[1] / S[1]; return O } function l(O, R) {
        O[0] = Math.ceil(R[0]);
          O[1] = Math.ceil(R[1]); return O
        } function h(O, R) { O[0] = Math.floor(R[0]); O[1] = Math.floor(R[1]); return O } function b(O, R, S) { O[0] = Math.min(R[0], S[0]); O[1] = Math.min(R[1], S[1]); return O } function d(O, R, S) { O[0] = Math.max(R[0], S[0]); O[1] = Math.max(R[1], S[1]); return O } function f(O, R) { O[0] = Math.round(R[0]); O[1] = Math.round(R[1]); return O } function t(O, R, S) { O[0] = R[0] * S; O[1] = R[1] * S; return O } function v(O, R, S, Q) { O[0] = R[0] + S[0] * Q; O[1] = R[1] + S[1] * Q; return O } function m(O, R) {
          const S = R[0] - O[0]; O = R[1] - O[1]; return Math.sqrt(S *
            S + O * O)
        } function e(O, R) { const S = R[0] - O[0]; O = R[1] - O[1]; return S * S + O * O } function g(O) { const R = O[0]; O = O[1]; return Math.sqrt(R * R + O * O) } function x(O) { const R = O[0]; O = O[1]; return R * R + O * O } function k(O, R) { O[0] = -R[0]; O[1] = -R[1]; return O } function r(O, R) { O[0] = 1 / R[0]; O[1] = 1 / R[1]; return O } function A(O, R) { var S = R[0]; const Q = R[1]; S = S * S + Q * Q; 0 < S && (S = 1 / Math.sqrt(S), O[0] = R[0] * S, O[1] = R[1] * S); return O } function z(O, R) { return O[0] * R[0] + O[1] * R[1] } function B(O, R, S) { R = R[0] * S[1] - R[1] * S[0]; O[0] = O[1] = 0; O[2] = R; return O } function C(O,
          R, S, Q) { const T = R[0]; R = R[1]; O[0] = T + Q * (S[0] - T); O[1] = R + Q * (S[1] - R); return O } function D(O, R) { R = R || 1; const S = 2 * w.RANDOM() * Math.PI; O[0] = Math.cos(S) * R; O[1] = Math.sin(S) * R; return O } function E(O, R, S) { const Q = R[0]; R = R[1]; O[0] = S[0] * Q + S[2] * R; O[1] = S[1] * Q + S[3] * R; return O } function H(O, R, S) { const Q = R[0]; R = R[1]; O[0] = S[0] * Q + S[2] * R + S[4]; O[1] = S[1] * Q + S[3] * R + S[5]; return O } function J(O, R, S) { const Q = R[0]; R = R[1]; O[0] = S[0] * Q + S[3] * R + S[6]; O[1] = S[1] * Q + S[4] * R + S[7]; return O } function M(O, R, S) {
            const Q = R[0]; R = R[1]; O[0] = S[0] * Q + S[4] *
              R + S[12]; O[1] = S[1] * Q + S[5] * R + S[13]; return O
          } function F(O, R, S, Q) { const T = R[0] - S[0]; R = R[1] - S[1]; const da = Math.sin(Q); Q = Math.cos(Q); O[0] = T * Q - R * da + S[0]; O[1] = T * da + R * Q + S[1]; return O } function K(O, R) { var S = O[0]; O = O[1]; const Q = R[0]; R = R[1]; let T = S * S + O * O; 0 < T && (T = 1 / Math.sqrt(T)); let da = Q * Q + R * R; 0 < da && (da = 1 / Math.sqrt(da)); S = (S * Q + O * R) * T * da; return 1 < S ? 0 : -1 > S ? Math.PI : Math.acos(S) } function P(O) { return "vec2(" + O[0] + ", " + O[1] + ")" } function L(O, R) { return O[0] === R[0] && O[1] === R[1] } function N(O, R) {
            const S = O[0]; O = O[1]; const Q =
              R[0]; R = R[1]; return Math.abs(S - Q) <= w.EPSILON * Math.max(1, Math.abs(S), Math.abs(Q)) && Math.abs(O - R) <= w.EPSILON * Math.max(1, Math.abs(O), Math.abs(R))
          } function G(O, R, S, Q, T) { let da = R[0] - S[0]; S = R[1] - S[1]; T = (Q[0] * da + Q[1] * S) * (T - 1); da = Q[0] * T; S = Q[1] * T; O[0] = R[0] + da; O[1] = R[1] + S; return O } const I = Object.freeze({
            __proto__: null, copy: c, set: q, add: u, subtract: y, multiply: n, divide: p, ceil: l, floor: h, min: b, max: d, round: f, scale: t, scaleAndAdd: v, distance: m, squaredDistance: e, length: g, squaredLength: x, negate: k, inverse: r, normalize: A,
            dot: z, cross: B, lerp: C, random: D, transformMat2: E, transformMat2d: H, transformMat3: J, transformMat4: M, rotate: F, angle: K, str: P, exactEquals: L, equals: N, projectAndScale: G, len: g, sub: y, mul: n, div: p, dist: m, sqrDist: e, sqrLen: x
          }); a.add = u; a.angle = K; a.ceil = l; a.copy = c; a.cross = B; a.dist = m; a.distance = m; a.div = p; a.divide = p; a.dot = z; a.equals = N; a.exactEquals = L; a.floor = h; a.inverse = r; a.len = g; a.length = g; a.lerp = C; a.max = d; a.min = b; a.mul = n; a.multiply = n; a.negate = k; a.normalize = A; a.projectAndScale = G; a.random = D; a.rotate = F; a.round = f; a.scale =
            t; a.scaleAndAdd = v; a.set = q; a.sqrDist = e; a.sqrLen = x; a.squaredDistance = e; a.squaredLength = x; a.str = P; a.sub = y; a.subtract = y; a.transformMat2 = E; a.transformMat2d = H; a.transformMat3 = J; a.transformMat4 = M; a.vec2 = I
      })
    }, "esri/views/3d/environment/atmosphereUtils": function () {
      define(["exports", "../../../chunks/vec3f64"], function (a, w) {
        const c = w.fromValues(5.802E-6, 1.3558E-5, 3.31E-5); w = w.fromValues(1.95E-6, 5.643E-6, 2.55E-7); a.atmosphereHeight = 1E5; a.betaMie = 3.996E-6; a.betaOzone = w; a.betaRayleigh = c; a.computeInnerAltitudeFade =
          function (q) { return Math.min(1, Math.max(0, (q - 1E5) / 9E5)) }; a.innerAtmosphereDepth = 1E4; a.rayLeighScaleHeight = .085; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/environment/ChapmanAtmosphereTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../chunks/ChapmanAtmosphere.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          n = function (d) {
            function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build({ haze: this.configuration.haze }); return new h.Program(v.rctx, m, l.Default3D) }; t.initializePipeline = function () {
              return this.configuration.haze ? b.makePipelineState({ blending: b.separateBlendingParams(1, 0, 769, 1), colorWrite: b.defaultColorWriteParams }) : b.makePipelineState({
                blending: b.separateBlendingParams(770, 1,
                  771, 771), depthTest: { func: 515 }, colorWrite: b.defaultColorWriteParams
              })
            }; return f
          }(n.ShaderTechnique); n.shader = new y.ReloadableShaderModule(u.ChapmanAtmosphereShader, () => new Promise((d, f) => a(["./ChapmanAtmosphere.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.haze = !1; return t } c._inheritsLoose(f, d); return f }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter()], u.prototype, "haze", void 0); w.ChapmanAtmosphereTechnique = n; w.ChapmanAtmosphereTechniqueConfiguration = u;
          Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/ChapmanAtmosphere.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "), function (a, w, c, q, u, y) {
        function n(l) {
          const h =
            new y.ShaderBuilder; h.attributes.add("position", "vec2"); h.include(w.TextureCoordinateAttribute, { attributeTextureCoordinates: 1 }); h.varyings.add("worldRay", "vec3"); h.varyings.add("eyeDir", "vec3"); h.vertex.uniforms.add("projectionInverse", "mat4"); h.vertex.uniforms.add("viewInverse", "mat4"); h.vertex.code.add(u.glsl`void main(void) {
vec3 posViewNear = (projectionInverse * vec4(position, -1, 1)).xyz;
eyeDir = posViewNear;
worldRay = (viewInverse * vec4(posViewNear, 0)).xyz;
forwardTextureCoordinates();
gl_Position = vec4(position, 1, 1);
}`); h.fragment.uniforms.add("lightingMainDirection", "vec3").add("radii", "vec2").add("scaleHeight", "float").add("cameraPosition", "vec3").add("nearFar", "vec2").add("heightParameters", "vec4").add("innerFadeDistance", "float").add("altitudeFade", "float").add("depthTex", "sampler2D").add("betaRayleigh", "vec3").add("betaCombined", "vec3").add("betaMie", "float").add("hazeStrength", "float"); h.include(q.Gamma); l.haze && h.fragment.include(c.ReadLinearDepth); h.fragment.code.add(u.glsl`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {
float a = dot(dir, dir);
float b = 2.0 * dot(dir, start);
float c = planet ? heightParameters[1] - radius * radius : heightParameters[2];
float d = (b * b) - 4.0 * a * c;
if (d < 0.0) {
return vec2(1e5, -1e5);
}
return vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));
}`); h.fragment.code.add(u.glsl`float chapmanApproximation(float X, float h, float cosZenith) {
float c = sqrt(X + h);
float cExpH = c * exp(-h);
if (cosZenith >= 0.0) {
return cExpH / (c * cosZenith + 1.0);
} else {
float x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
float c0 = sqrt(x0);
return 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);
}
}`); h.fragment.code.add(u.glsl`float getOpticalDepth(vec3 position, vec3 dir, float h) {
return scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));
}`); h.fragment.code.add(u.glsl`
    const int STEPS = 6;

    float getGlow(float dist, float radius, float intensity) {
      return pow(radius / max(dist, 1e-6), intensity);
    }

    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {
      float reducedPlanetRadius = radii[0] - 20000.0;
      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);
      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);
      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;
      bool insideAtmosphere = heightParameters[0] < radii[1];

      if (!(hitsAtmosphere || insideAtmosphere)) {
        return vec3(0);
      }

      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;

      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;

      if (heightParameters[0] < reducedPlanetRadius) {
        // Long light rays from the night side of the planet lead to numerical instability
        // Do not render the atmosphere in such cases
        if (dot(rayDir, normalize(cameraPos)) < -0.025) {
          return vec3(0);
        }
        start = rayPlanetIntersect.y;
      }

      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;
      float maxEnd = end;

      ${l.haze ? u.glsl`if (terrainDepth != -1.0) { end = terrainDepth; }` : ""}

      vec3 samplePoint = cameraPos + rayDir * end;
      float multiplier = hitsPlanet ? -1.0 : 1.0;

      vec3 scattering = vec3(0);
      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;
      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);
      float stepSize = (end - start) / float(STEPS);
      for (int i = 0; i < STEPS; i++) {
        samplePoint -= stepSize * rayDir;
        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;
        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);

        if (i > 0) {
          scattering *= ${l.haze ? u.glsl`` : " mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * "} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));
        }

        if (dot(normalize(samplePoint), lightDir) > -0.3) {

          float scale = exp(-scaleFract);
          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);

          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);
          ${l.haze ? "" : u.glsl`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}
        }

        lastOpticalDepth = opticalDepth;

      }

      float mu = dot(rayDir, lightDir);
      float mumu = 1.0 + mu * mu;

      float phaseRayleigh = 0.05968310365 * mumu;

      ${l.haze ? u.glsl`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;` : u.glsl`
            const float g = 0.8;
            const float gg = g * g;
            float phaseMie = end == maxEnd ? 0.11936620731 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;
            phaseMie += getGlow(1.0 - mu, 5e-5, 3.0) * smoothstep(0.01, 0.1, length(scattering));
            phaseMie = clamp(phaseMie, 0.0, 128.0);
            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}
    }

    vec3 tonemapACES(vec3 x) {
      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
    }

    vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {
      vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);
      if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {
        return fragColor;
      }

      float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));
      vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);
      float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;
      if (relDist > 1.0) {
        return surfaceColor;
      }

      return mix(gl_FragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));
    }

    void main() {
      vec3 rayDir = normalize(worldRay);
      float terrainDepth = -1.0;
      ${l.haze ? u.glsl`
          vec4 depthSample = texture2D(depthTex, vuv0).rgba;
          if (depthSample != vec4(0)) {
            vec3 cameraSpaceRay = normalize(eyeDir);
            cameraSpaceRay /= cameraSpaceRay.z;
            cameraSpaceRay *= -linearDepthFromTexture(depthTex, vuv0, nearFar);
            terrainDepth = max(0.0, length(cameraSpaceRay));
          }`: u.glsl`
          float depthSample = texture2D(depthTex, vuv0).r;
          if (depthSample != 1.0) {
            gl_FragColor = vec4(0);
            return;
          }`}

      ${l.haze ? u.glsl`
            vec3 col = vec3(0);
            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);
            if(depthSample != vec4(0)){
              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);
            }
            float alpha = 1.0 - fadeOut;`: u.glsl`
            vec3 col = getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);;
            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}
      col = tonemapACES(col);
      gl_FragColor = delinearizeGamma(vec4(col, alpha));
      ${l.haze ? "" : u.glsl`
          if (depthSample == 1.0) {
            gl_FragColor = applyUndergroundAtmosphere(rayDir, lightingMainDirection, gl_FragColor);
          }`}
    }
  `); return h
        } const p = Object.freeze({ __proto__: null, build: n }); a.ChapmanAtmosphereShader = p; a.build = n
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.TextureCoordinateAttribute = function (c, q) {
      1 === q.attributeTextureCoordinates && (c.attributes.add("uv0", "vec2"), c.varyings.add("vuv0", "vec2"), c.vertex.code.add(w.glsl`void forwardTextureCoordinates() {
vuv0 = uv0;
}`)); 2 === q.attributeTextureCoordinates && (c.attributes.add("uv0", "vec2"), c.varyings.add("vuv0", "vec2"), c.attributes.add("uvRegion", "vec4"), c.varyings.add("vuvRegion", "vec4"), c.vertex.code.add(w.glsl`void forwardTextureCoordinates() {
vuv0 = uv0;
vuvRegion = uvRegion;
}`)); 0 === q.attributeTextureCoordinates && c.vertex.code.add(w.glsl`void forwardTextureCoordinates() {}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderModules/interfaces": function () {
      define(["exports"], function (a) {
        function w(c, ...q) { let u = ""; for (let y = 0; y < q.length; y++)u += c[y] + q[y]; return u += c[c.length - 1] } (function (c) { c.int = function (q) { return Math.round(q).toString() }; c.float = function (q) { return q.toPrecision(8) } })(w || (w = {})); a.glsl = w; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl": function () {
      define(["exports", "../util/RgbaFloatEncoding.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.ReadLinearDepth = function (q) {
        q.include(w.RgbaFloatEncoding); q.code.add(c.glsl`float linearDepthFromFloat(float depth, vec2 nearFar) {
return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);
}
float linearDepthFromTexture(sampler2D depthTex, vec2 uv, vec2 nearFar) {
return linearDepthFromFloat(rgba2float(texture2D(depthTex, uv)), nearFar);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.RgbaFloatEncoding = function (c) {
        c.code.add(w.glsl`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.Gamma = function (c) {
        c.fragment.code.add(w.glsl`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderModules/ShaderBuilder": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../core/Logger"], function (a, w, c) {
        const q = c.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder"); c = function () {
          function f() { this.includedModules = new Map } f.prototype.include = function (t, v) {
            this.includedModules.has(t) ? this.includedModules.get(t) !== v && q.error("Trying to include shader module multiple times with different sets of options.") :
            (this.includedModules.set(t, v), t(this.builder, v))
          }; return f
        }(); let u = function (f) {
          function t() { var v = f.apply(this, arguments) || this; v.vertex = new p; v.fragment = new p; v.attributes = new l; v.varyings = new h; v.extensions = new b; v.constants = new d; return v } w._inheritsLoose(t, f); t.prototype.generateSource = function (v) {
            const m = this.extensions.generateSource(v), e = this.attributes.generateSource(v), g = this.varyings.generateSource(); var x = "vertex" === v ? this.vertex : this.fragment; const k = x.uniforms.generateSource(), r = x.code.generateSource();
            v = "vertex" === v ? "precision highp float;\nprecision highp sampler2D;" : "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif"; x = this.constants.generateSource().concat(x.constants.generateSource()); return `\n${m.join("\n")}\n\n${v}\n\n${x.join("\n")}\n\n${k.join("\n")}\n\n${e.join("\n")}\n\n${g.join("\n")}\n\n${r.join("\n")}`
          }; w._createClass(t, [{ key: "fragmentUniforms", get: function () { return this.fragment.uniforms } },
          { key: "builder", get: function () { return this } }]); return t
        }(c), y = function () { function f() { this._entries = new Map } var t = f.prototype; t.add = function (v, m, e) { this._entries.set(`${v}_${m}_${e}`, { name: v, type: m, arraySize: e }); return this }; t.generateSource = function () { return Array.from(this._entries.values()).map(v => { var m = v.arraySize; return `uniform ${v.type} ${v.name}${m ? `[${m}]` : ""};` }) }; w._createClass(f, [{ key: "entries", get: function () { return Array.from(this._entries.values()) } }]); return f }(), n = function () {
          function f() {
          this._entries =
            []
          } var t = f.prototype; t.add = function (v) { this._entries.push(v) }; t.generateSource = function () { return this._entries }; return f
        }(), p = function (f) { function t() { var v = f.apply(this, arguments) || this; v.uniforms = new y; v.code = new n; v.constants = new d; return v } w._inheritsLoose(t, f); w._createClass(t, [{ key: "builder", get: function () { return this } }]); return t }(c), l = function () {
          function f() { this._entries = [] } var t = f.prototype; t.add = function (v, m) { this._entries.push([v, m]) }; t.generateSource = function (v) {
            return "fragment" === v ?
              [] : this._entries.map(m => `attribute ${m[1]} ${m[0]};`)
          }; return f
        }(), h = function () { function f() { this._entries = [] } var t = f.prototype; t.add = function (v, m) { this._entries.push([v, m]) }; t.generateSource = function () { return this._entries.map(v => `varying ${v[1]} ${v[0]};`) }; return f }(), b = function () {
          function f() { this._entries = new Set } var t = f.prototype; t.add = function (v) { this._entries.add(v) }; t.generateSource = function (v) {
            const m = "vertex" === v ? f.ALLOWLIST_VERTEX : f.ALLOWLIST_FRAGMENT; return Array.from(this._entries).filter(e =>
              m.includes(e)).map(e => `#extension ${e} : enable`)
          }; return f
        }(); b.ALLOWLIST_FRAGMENT = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives"]; b.ALLOWLIST_VERTEX = []; let d = function () {
          function f() { this._entries = [] } var t = f.prototype; t.add = function (v, m, e) {
            let g = "ERROR_CONSTRUCTOR_STRING"; switch (m) {
              case "float": g = f.numberToFloatStr(e); break; case "int": g = f.numberToIntStr(e); break; case "bool": g = e.toString(); break; case "vec2": g = `vec2(${f.numberToFloatStr(e[0])},                            ${f.numberToFloatStr(e[1])})`;
                break; case "vec3": g = `vec3(${f.numberToFloatStr(e[0])},                            ${f.numberToFloatStr(e[1])},                            ${f.numberToFloatStr(e[2])})`; break; case "vec4": g = `vec4(${f.numberToFloatStr(e[0])},                            ${f.numberToFloatStr(e[1])},                            ${f.numberToFloatStr(e[2])},                            ${f.numberToFloatStr(e[3])})`; break; case "ivec2": g = `ivec2(${f.numberToIntStr(e[0])},                             ${f.numberToIntStr(e[1])})`;
                break; case "ivec3": g = `ivec3(${f.numberToIntStr(e[0])},                             ${f.numberToIntStr(e[1])},                             ${f.numberToIntStr(e[2])})`; break; case "ivec4": g = `ivec4(${f.numberToIntStr(e[0])},                             ${f.numberToIntStr(e[1])},                             ${f.numberToIntStr(e[2])},                             ${f.numberToIntStr(e[3])})`; break; case "mat2": case "mat3": case "mat4": g = `${m}(${Array.prototype.map.call(e, x => f.numberToFloatStr(x)).join(", ")})`
            }this._entries.push(`const ${m} ${v} = ${g};`);
            return this
          }; f.numberToIntStr = function (v) { return v.toFixed(0) }; f.numberToFloatStr = function (v) { return Number.isInteger(v) ? v.toFixed(1) : v.toString() }; t.generateSource = function () { return Array.from(this._entries) }; return f
        }(); a.Code = n; a.Includes = c; a.ShaderBuilder = u; a.Stage = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y,
            n) { this._module = y; this._loadModule = n } var u = q.prototype; u.get = function () { return this._module }; u.reload = function () { var y = w._asyncToGenerator(function* () { return this._module = yield this._loadModule() }); return function () { return y.apply(this, arguments) } }(); return q
        }(); a.ReloadableShaderModule = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../core/maybe"],
        function (a, w, c) {
          let q = function () {
            function u(n, p, l = () => this.dispose()) { this.release = l; p && (this._config = p.snapshot()); this._program = this.initializeProgram(n); this._pipeline = this.initializePipeline(n) } var y = u.prototype; y.dispose = function () { this._program = c.disposeMaybe(this._program); this._pipeline = this._config = null }; y.reload = function (n) { c.disposeMaybe(this._program); this._program = this.initializeProgram(n) }; y.bindPass = function (n, p) { }; y.bindMaterial = function (n, p) { }; y.bindDraw = function (n) { }; y.bindPipelineState =
              function (n, p = null, l) { n.setPipelineState(this.getPipelineState(p, l)) }; y.ensureAttributeLocations = function (n) { this.program.assertCompatibleVertexAttributeLocations(n) }; y.getPipelineState = function (n, p) { return this._pipeline }; w._createClass(u, [{ key: "program", get: function () { return this._program } }, { key: "key", get: function () { return this._config.key } }, { key: "configuration", get: function () { return this._config } }, { key: "primitiveType", get: function () { return 4 } }]); return u
          }(); a.ShaderTechnique = q; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q() { this._key = ""; this._keyDirty = !1; this._parameterBits = this._parameterBits ? this._parameterBits.map(() => 0) : []; this._parameterNames || (this._parameterNames = []) } q.prototype.snapshot = function () { const u = this._parameterNames, y = { key: this.key }; for (const n of u) y[n] = this[n]; return y };
          w._createClass(q, [{ key: "key", get: function () { this._keyDirty && (this._keyDirty = !1, this._key = String.fromCharCode.apply(String, this._parameterBits)); return this._key } }]); return q
        }(); a.ShaderTechniqueConfiguration = c; a.parameter = function (q = {}) {
          return (u, y) => {
            var n, p; u._parameterNames = null != (n = u._parameterNames) ? n : []; u._parameterNames.push(y); const l = u._parameterNames.length - 1; n = Math.ceil(Math.log2(q.count || 2)); const h = null != (p = u._parameterBits) ? p : [0]; let b = 0; for (; 16 < h[b] + n;)b++ , b >= h.length && h.push(0); u._parameterBits =
              h; const d = h[b], f = (1 << n) - 1 << d; h[b] += n; Object.defineProperty(u, y, { get() { return this[l] }, set(t) { if (this[l] !== t && (this[l] = t, this._keyDirty = !0, this._parameterBits[b] = this._parameterBits[b] & ~f | +t << d & f, "number" !== typeof t && "boolean" !== typeof t)) throw "Configuration value for " + y + " must be boolean or number, got " + typeof t; } })
          }
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations": function () {
      define(["exports"], function (a) {
        const w = new Map([["position",
          0], ["normal", 1], ["uv0", 2], ["color", 3], ["size", 4], ["tangent", 4], ["auxpos1", 5], ["symbolColor", 5], ["auxpos2", 6], ["featureAttribute", 6], ["instanceFeatureAttribute", 6], ["instanceColor", 7], ["model", 8], ["modelNormal", 12], ["modelOriginHi", 11], ["modelOriginLo", 15]]); a.Default3D = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/Program": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/PooledArray ../../../webgl/checkWebGLError ../../../webgl/Program".split(" "),
        function (a, w, c, q, u, y) {
          y = function (n) {
            function p(h, b, d) { h = n.call(this, h, b.generateSource("vertex"), b.generateSource("fragment"), d) || this; h._textures = new Map; h._freeTextureUnits = new q({ deallocator: null }); h._fragmentUniforms = u.webglDebugEnabled() ? b.fragmentUniforms.entries : null; return h } w._inheritsLoose(p, n); var l = p.prototype; l.stop = function () { this._textures.clear(); this._freeTextureUnits.clear() }; l.bindTexture = function (h, b) {
              if (c.isNone(h) || null == h.glName) {
                if (h = this._textures.get(b)) this._context.bindTexture(null,
                  h.unit), this._freeTextureUnit(h), this._textures.delete(b); return null
              } let d = this._textures.get(b); null == d ? (d = this._allocTextureUnit(h), this._textures.set(b, d)) : d.texture = h; this._context.useProgram(this); this.setUniform1i(b, d.unit); this._context.bindTexture(h, d.unit); return d.unit
            }; l.rebindTextures = function () {
              this._context.useProgram(this); this._textures.forEach((h, b) => { this._context.bindTexture(h.texture, h.unit); this.setUniform1i(b, h.unit) }); c.isSome(this._fragmentUniforms) && this._fragmentUniforms.forEach(h => { if (("sampler2D" === h.type || "samplerCube" === h.type) && !this._textures.has(h.name)) throw Error(`Texture sampler ${h.name} has no bound texture`); })
            }; l._allocTextureUnit = function (h) { return { texture: h, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() } }; l._freeTextureUnit = function (h) { this._freeTextureUnits.push(h.unit) }; return p
          }(y.Program); a.Program = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/checkWebGLError": function () {
      define(["exports",
        "../../core/Error", "../../core/has", "../../core/Logger"], function (a, w, c, q) {
          function u(p, l) {
            switch (l) {
              case p.INVALID_ENUM: return "Invalid Enum. An unacceptable value has been specified for an enumerated argument."; case p.INVALID_VALUE: return "Invalid Value. A numeric argument is out of range."; case p.INVALID_OPERATION: return "Invalid Operation. The specified command is not allowed for the current state."; case p.INVALID_FRAMEBUFFER_OPERATION: return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
              case p.OUT_OF_MEMORY: return "Out of memory. Not enough memory is left to execute the command."; case p.CONTEXT_LOST_WEBGL: return "WebGL context has been lost"; default: return "Unknown error"
            }
          } const y = q.getLogger("esri/views/webgl"), n = !!c("enable-feature:webgl-debug"); a.checkWebGLError = function (p) { if (n) { const l = p.getError(); l && (p = u(p, l), y.error(new w("webgl-error", "WebGL error occured", { message: p, stack: Error().stack }))) } }; a.hasFeatureFlagWebGLDebug = n; a.webglDebugEnabled = function () { return n }; a.webglValidateShadersEnabled =
            function () { return n }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/Program": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/maybe ./checkWebGLError ./enums ./ShaderTranspiler".split(" "), function (a, w, c, q, u, y, n) {
        function p(d, f) { if (q.isNone(d) || d.length !== f.length) return !0; for (let t = 0; t < d.length; ++t)if (d[t] !== f[t]) return !0; return !1 } function l(d, f, t) {
          const v = "webgl2" === d.webglVersion ? n.transpileShader(t, f) : t, m = d.gl, e = m.createShader(f);
          m.shaderSource(e, v); m.compileShader(e); u.webglValidateShadersEnabled() && !m.getShaderParameter(e, m.COMPILE_STATUS) && (console.error("Compile error in ".concat(35633 === f ? "vertex" : "fragment", " shader")), console.error(m.getShaderInfoLog(e)), console.error(h(v)), "webgl2" === d.webglVersion && (console.log("Shader source before transpilation:"), console.log(t))); return e
        } function h(d) { let f = 2; return d.replace(/\n/g, () => { var t = f++; t = 1E3 <= t ? t.toString() : ("  " + t).slice(-3); return "\n" + t + ":" }) } function b(d, f) {
          for (let t =
            0; t < d.length; ++t)f[t] = d[t]
        } c = function () {
          function d(t, v, m, e) {
          this._context = t; this._locations = e; this._nameToUniformLocation = {}; this._nameToUniform1 = {}; this._nameToUniform1v = {}; this._nameToUniform2 = {}; this._nameToUniform3 = {}; this._nameToUniform4 = {}; this._nameToUniformMatrix3 = {}; this._nameToUniformMatrix4 = {}; t || console.error("RenderingContext isn't initialized!"); 0 === v.length && console.error("Shaders source should not be empty!"); this._vShader = l(this._context, 35633, v); this._fShader = l(this._context, 35632,
            m); this._vShader && this._fShader || console.error("Error loading shaders!"); this._context.instanceCounter.increment(y.ResourceType.VertexShader, this); this._context.instanceCounter.increment(y.ResourceType.FragmentShader, this)
          } var f = d.prototype; f.dispose = function () {
            const t = this._context.gl; this._vShader && (t.deleteShader(this._vShader), this._vShader = null, this._context.instanceCounter.decrement(y.ResourceType.VertexShader, this)); this._fShader && (t.deleteShader(this._fShader), this._fShader = null, this._context.instanceCounter.decrement(y.ResourceType.FragmentShader,
              this)); this._glName && (t.deleteProgram(this._glName), this._glName = null, this._context.instanceCounter.decrement(y.ResourceType.Program, this))
          }; f._getUniformLocation = function (t) { void 0 === this._nameToUniformLocation[t] && (this._nameToUniformLocation[t] = this._context.gl.getUniformLocation(this.glName, t)); return this._nameToUniformLocation[t] }; f.hasUniform = function (t) { return null !== this._getUniformLocation(t) }; f.setUniform1i = function (t, v) {
            const m = this._nameToUniform1[t]; if (void 0 === m || v !== m) this._context.useProgram(this),
              this._context.gl.uniform1i(this._getUniformLocation(t), v), this._nameToUniform1[t] = v
          }; f.setUniform1iv = function (t, v) { const m = this._nameToUniform1v[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform1iv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform1v[t] = Array.from(v) : b(v, m)) }; f.setUniform2iv = function (t, v) {
            const m = this._nameToUniform2[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform2iv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform2[t] =
              Array.from(v) : b(v, m))
          }; f.setUniform3iv = function (t, v) { const m = this._nameToUniform3[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform3iv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform3[t] = Array.from(v) : b(v, m)) }; f.setUniform4iv = function (t, v) { const m = this._nameToUniform4[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform4iv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform4[t] = Array.from(v) : b(v, m)) }; f.setUniform1f = function (t, v) {
            const m = this._nameToUniform1[t];
            if (void 0 === m || v !== m) this._context.useProgram(this), this._context.gl.uniform1f(this._getUniformLocation(t), v), this._nameToUniform1[t] = v
          }; f.setUniform1fv = function (t, v) { const m = this._nameToUniform1v[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform1fv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform1v[t] = Array.from(v) : b(v, m)) }; f.setUniform2f = function (t, v, m) {
            const e = this._nameToUniform2[t]; if (void 0 === e || v !== e[0] || m !== e[1]) this._context.useProgram(this), this._context.gl.uniform2f(this._getUniformLocation(t),
              v, m), void 0 === e ? this._nameToUniform2[t] = [v, m] : (e[0] = v, e[1] = m)
          }; f.setUniform2fv = function (t, v) { const m = this._nameToUniform2[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform2fv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform2[t] = Array.from(v) : b(v, m)) }; f.setUniform3f = function (t, v, m, e) {
            const g = this._nameToUniform3[t]; if (void 0 === g || v !== g[0] || m !== g[1] || e !== g[2]) this._context.useProgram(this), this._context.gl.uniform3f(this._getUniformLocation(t), v, m, e), void 0 === g ? this._nameToUniform3[t] =
              [v, m, e] : (g[0] = v, g[1] = m, g[2] = e)
          }; f.setUniform3fv = function (t, v) { const m = this._nameToUniform3[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform3fv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform3[t] = Array.from(v) : b(v, m)) }; f.setUniform4f = function (t, v, m, e, g) {
            const x = this._nameToUniform4[t]; if (void 0 === x || v !== x[0] || m !== x[1] || e !== x[2] || g !== x[3]) this._context.useProgram(this), this._context.gl.uniform4f(this._getUniformLocation(t), v, m, e, g), void 0 === x ? this._nameToUniform4[t] =
              [v, m, e, g] : (x[0] = v, x[1] = m, x[2] = e, x[3] = g)
          }; f.setUniform4fv = function (t, v) { const m = this._nameToUniform4[t]; p(m, v) && (this._context.useProgram(this), this._context.gl.uniform4fv(this._getUniformLocation(t), v), void 0 === m ? this._nameToUniform4[t] = Array.from(v) : b(v, m)) }; f.setUniformMatrix3fv = function (t, v, m = !1, e = !1) {
            const g = this._nameToUniformMatrix3[t]; e = e ? g !== v : q.isNone(g) ? !0 : 9 !== g.length ? p(g, v) : 9 !== g.length || g[0] !== v[0] || g[1] !== v[1] || g[2] !== v[2] || g[3] !== v[3] || g[4] !== v[4] || g[5] !== v[5] || g[6] !== v[6] || g[7] !==
              v[7] || g[8] !== v[8]; e && (this._context.useProgram(this), this._context.gl.uniformMatrix3fv(this._getUniformLocation(t), m, v), void 0 === g ? this._nameToUniformMatrix3[t] = Array.from(v) : b(v, g))
          }; f.setUniformMatrix4fv = function (t, v, m = !1) {
            const e = this._nameToUniformMatrix4[t]; var g = q.isNone(e) ? !0 : 16 !== e.length ? p(e, v) : 16 !== e.length || e[0] !== v[0] || e[1] !== v[1] || e[2] !== v[2] || e[3] !== v[3] || e[4] !== v[4] || e[5] !== v[5] || e[6] !== v[6] || e[7] !== v[7] || e[8] !== v[8] || e[9] !== v[9] || e[10] !== v[10] || e[11] !== v[11] || e[12] !== v[12] || e[13] !==
              v[13] || e[14] !== v[14] || e[15] !== v[15]; g && (this._context.useProgram(this), this._context.gl.uniformMatrix4fv(this._getUniformLocation(t), m, v), void 0 === e ? this._nameToUniformMatrix4[t] = Array.from(v) : b(v, e))
          }; f.assertCompatibleVertexAttributeLocations = function (t) { t.locations !== this._locations && console.error("VertexAttributeLocations are incompatible") }; f.stop = function () { }; w._createClass(d, [{
            key: "glName", get: function () {
              if (q.isSome(this._glName)) return this._glName; if (q.isNone(this._vShader)) return null; const t =
                this._context.gl, v = t.createProgram(); t.attachShader(v, this._vShader); t.attachShader(v, this._fShader); this._locations.forEach((m, e) => t.bindAttribLocation(v, m, e)); t.linkProgram(v); u.webglValidateShadersEnabled() && !t.getProgramParameter(v, t.LINK_STATUS) && console.error("Could not link shader\n" + `validated: ${t.getProgramParameter(v, t.VALIDATE_STATUS)}` + `, gl error ${t.getError()}` + `, vertex: ${t.getShaderParameter(this._vShader, t.COMPILE_STATUS)}` + `, fragment: ${t.getShaderParameter(this._fShader, t.COMPILE_STATUS)}` +
                  `, info log: ${t.getProgramInfoLog(v)}`); this._glName = v; this._context.instanceCounter.increment(y.ResourceType.Program, this); return v
            }
          }]); return d
        }(); a.Program = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/enums": function () {
      define(["exports"], function (a) {
      a.ResourceType = void 0; var w = a.ResourceType || (a.ResourceType = {}); w[w.Texture = 0] = "Texture"; w[w.Buffer = 1] = "Buffer"; w[w.VAO = 2] = "VAO"; w[w.VertexShader = 3] = "VertexShader"; w[w.FragmentShader = 4] = "FragmentShader"; w[w.Program = 5] = "Program";
        w[w.Framebuffer = 6] = "Framebuffer"; w[w.Renderbuffer = 7] = "Renderbuffer"; w[w.COUNT = 8] = "COUNT"; a.BASE_TEXTURE_UNIT = 33984; a.DepthStencilAttachment = 33306; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/ShaderTranspiler": function () {
      define(["exports", "../../core/maybe", "./reservedWordsGLSL3", "../../chunks/builtins"], function (a, w, c, q) {
        function u() {
          function m(I) { I.length && J.push({ type: d[C], data: I, position: K, line: M, column: F }) } function e() {
            H = H.length ? [] : H; if ("/" === E && "*" === D) return K = B + z -
              1, C = 0, E = D, z + 1; if ("/" === E && "/" === D) return K = B + z - 1, C = 1, E = D, z + 1; if ("#" === D) return C = 2, K = B + z, z; if (/\s/.test(D)) return C = 9, K = B + z, z; P = /\d/.test(D); L = /[^\w_]/.test(D); K = B + z; C = P ? 4 : L ? 3 : 9999; return z
          } function g() { if (("\r" === D || "\n" === D) && "\\" !== E) return m(H.join("")), C = 999, z; H.push(D); E = D; return z + 1 } function x() {
            if ("." === E && /\d/.test(D)) return C = 5, z; if ("/" === E && "*" === D) return C = 0, z; if ("/" === E && "/" === D) return C = 1, z; if ("." === D && H.length) { for (; k(H);); C = 5; return z } if (";" === D || ")" === D || "(" === D) {
              if (H.length) for (; k(H););
              m(D); C = 999; return z + 1
            } var I = 2 === H.length && "\x3d" !== D; if (/[\w_\d\s]/.test(D) || I) { for (; k(H);); C = 999; return z } H.push(D); E = D; return z + 1
          } function k(I) { var O = 0; do { var R = q.operators.indexOf(I.slice(0, I.length + O).join("")); var S = q.operators[R]; if (-1 === R) { if (0 < O-- + I.length) continue; S = I.slice(0, 1).join("") } m(S); K += S.length; H = H.slice(S.length); return H.length } while (1) } function r() {
            if ("." === D || /[eE]/.test(D)) return H.push(D), C = 5, E = D, z + 1; if ("x" === D && 1 === H.length && "0" === H[0]) return C = 11, H.push(D), E = D, z + 1; if (/[^\d]/.test(D)) return m(H.join("")),
              C = 999, z; H.push(D); E = D; return z + 1
          } function A() { "f" === D && (H.push(D), E = D, z += 1); if (/[eE]/.test(D) || "-" === D && /[eE]/.test(E)) return H.push(D), E = D, z + 1; if (/[^\d]/.test(D)) return m(H.join("")), C = 999, z; H.push(D); E = D; return z + 1 } var z = 0, B = 0, C = 999, D, E, H = [], J = [], M = 1, F = 0, K = 0, P = !1, L = !1, N = "", G; return function (I) {
            J = []; if (null !== I) {
              I = I.replace ? I.replace(/\r\n/g, "\n") : I; z = 0; N += I; for (G = N.length; D = N[z], z < G;) {
                I = z; switch (C) {
                  case 0: "/" === D && "*" === E ? (H.push(D), m(H.join("")), C = 999) : (H.push(D), E = D); z += 1; break; case 1: z = g(); break;
                  case 2: z = g(); break; case 3: z = x(); break; case 4: z = r(); break; case 11: /[^a-fA-F0-9]/.test(D) ? (m(H.join("")), C = 999) : (H.push(D), E = D, z += 1); break; case 5: z = A(); break; case 9999: if (/[^\d\w_]/.test(D)) { var O = H.join(""); C = -1 < q.literals.indexOf(O) ? 8 : -1 < q.builtins.indexOf(O) ? 7 : 6; m(H.join("")); C = 999 } else H.push(D), E = D, z += 1; break; case 9: /[^\s]/g.test(D) ? (m(H.join("")), C = 999) : (H.push(D), E = D, z += 1); break; case 999: z = e()
                }if (I !== z) switch (N[I]) { case "\n": F = 0; ++M; break; default: ++F }
              } B += z; N = N.slice(z); return J
            } H.length && m(H.join(""));
            C = 10; m("(eof)"); return J
          }
        } function y(m) { return m.map(e => "eof" !== e.type ? e.data : "").join("") } function n(m, e = "100", g = "300 es") { const x = /^\s*#version\s+([0-9]+(\s+[a-zA-Z]+)?)\s*/; for (const k of m) if ("preprocessor" === k.type) { const r = x.exec(k.data); if (r) { m = r[1].replace(/\s\s+/g, " "); if (m === g) return m; if (m === e) return k.data = "#version " + g, e; throw Error("unknown glsl version: " + m); } } m.splice(0, 0, { type: "preprocessor", data: "#version " + g }, { type: "whitespace", data: "\n" }); return null } function p(m, e, g, x) {
          x = x || g;
          for (const k of m) if ("ident" === k.type && k.data === g) return x in e ? e[x]++ : e[x] = 0, p(m, e, x + "_" + e[x], x); return g
        } function l(m, e, g = "afterVersion") {
          const x = { data: "\n", type: "whitespace" }, k = A => A < m.length ? /[^\r\n]$/.test(m[A].data) : !1; let r = function (A) {
            let z = -1, B = 0, C = -1; for (let E = 0; E < A.length; E++) {
              var D = A[E]; "preprocessor" === D.type && (D.data.match(/#(if|ifdef|ifndef)\s+.+/) ? ++B : D.data.match(/#endif\s*.*/) && --B); ("afterVersion" === g || "afterPrecision" === g) && "preprocessor" === D.type && /^#version/.test(D.data) && (C = Math.max(C,
                E)); if ("afterPrecision" === g && "keyword" === D.type && "precision" === D.data) { a: { for (D = E; D < A.length; D++) { const H = A[D]; if ("operator" === H.type && ";" === H.data) break a } D = null } if (null === D) throw Error("precision statement not followed by any semicolons!"); C = Math.max(C, D) } z < C && 0 === B && (z = E)
            } return z + 1
          }(m); k(r - 1) && m.splice(r++, 0, x); for (const A of e) m.splice(r++, 0, A); k(r - 1) && k(r) && m.splice(r, 0, x)
        } function h(m, e, g, x = "lowp") {
          l(m, [{ type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: x }, {
            type: "whitespace",
            data: " "
          }, { type: "keyword", data: g }, { type: "whitespace", data: " " }, { type: "ident", data: e }, { type: "operator", data: ";" }], "afterPrecision")
        } function b(m, e, g, x, k = "lowp") {
          l(m, [{ type: "keyword", data: "layout" }, { type: "operator", data: "(" }, { type: "keyword", data: "location" }, { type: "whitespace", data: " " }, { type: "operator", data: "\x3d" }, { type: "whitespace", data: " " }, { type: "integer", data: x.toString() }, { type: "operator", data: ")" }, { type: "whitespace", data: " " }, { type: "keyword", data: "out" }, { type: "whitespace", data: " " }, {
            type: "keyword",
            data: k
          }, { type: "whitespace", data: " " }, { type: "keyword", data: g }, { type: "whitespace", data: " " }, { type: "ident", data: e }, { type: "operator", data: ";" }], "afterPrecision")
        } var d = "block-comment line-comment preprocessor operator integer float ident builtin keyword whitespace eof integer".split(" "); const f = ["GL_OES_standard_derivatives", "GL_EXT_frag_depth", "GL_EXT_draw_buffers", "GL_EXT_shader_texture_lod"], t = { enableCache: !1 }, v = new Map; a.test = t; a.transpileShader = function (m, e) {
          var g = t.enableCache ? v.get(m) : null; if (w.isSome(g)) return g;
          g = u(); var x = []; x = x.concat(g(m)); g = x = x.concat(g(null)); if ("300 es" === n(g, "100", "300 es")) throw Error("shader is already glsl 300 es"); var k = x = null; const r = {}, A = {}; for (let D = 0; D < g.length; ++D) {
            const E = g[D]; switch (E.type) {
              case "keyword": 35633 === e && "attribute" === E.data ? E.data = "in" : "varying" === E.data && (E.data = 35633 === e ? "out" : "in"); break; case "builtin": /^texture(2D|Cube)(Proj)?(Lod|Grad)?(EXT)?$/.test(E.data.trim()) && (E.data = E.data.replace(/(2D|Cube|EXT)/g, "")); 35632 === e && "gl_FragColor" === E.data && (x || (x =
                p(g, r, "fragColor"), h(g, x, "vec4")), E.data = x); if (35632 === e && "gl_FragData" === E.data) { { var z = void 0; let H = void 0; var B = g; var C = D + 1; let J = -1; for (; C < B.length; C++) { const M = B[C]; if ("operator" === M.type && ("[" === M.data && (H = C), "]" === M.data)) { z = C; break } "integer" === M.type && (J = parseInt(M.data, 10)) } H && z && B.splice(H, z - H + 1); B = J } z = p(g, r, "fragData"); b(g, z, "vec4", B, "mediump"); E.data = z } else 35632 === e && "gl_FragDepthEXT" === E.data && (k || (k = p(g, r, "gl_FragDepth")), E.data = k); break; case "ident": if (0 <= c.indexOf(E.data)) {
                  if (B = 35633 ===
                    e) a: { for (B = D - 1; 0 <= B; B--)if (z = g[B], "whitespace" !== z.type && "block-comment" !== z.type) if ("keyword" === z.type) { if ("attribute" === z.data || "in" === z.data) { B = !0; break a } } else break; B = !1 } if (B) throw Error("attribute in vertex shader uses a name that is a reserved word in glsl 300 es"); E.data in A || (A[E.data] = p(g, r, E.data)); E.data = A[E.data]
                }
            }
          } for (e = g.length - 1; 0 <= e; --e)x = g[e], "preprocessor" === x.type && ((k = x.data.match(/#extension\s+(.*):/)) && k[1] && 0 <= f.indexOf(k[1].trim()) && (k = g[e + 1], g.splice(e, k && "whitespace" ===
            k.type ? 2 : 1)), (k = x.data.match(/#ifdef\s+(.*)/)) && k[1] && 0 <= f.indexOf(k[1].trim()) && (x.data = "#if 1"), (k = x.data.match(/#ifndef\s+(.*)/)) && k[1] && 0 <= f.indexOf(k[1].trim()) && (x.data = "#if 0")); g = y(g); t.enableCache && v.set(m, g); return g
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/reservedWordsGLSL3": function () { define(function () { return "layout centroid smooth case mat2x2 mat2x3 mat2x4 mat3x2 mat3x3 mat3x4 mat4x2 mat4x3 mat4x4 uint uvec2 uvec3 uvec4 samplerCubeShadow sampler2DArray sampler2DArrayShadow isampler2D isampler3D isamplerCube isampler2DArray usampler2D usampler3D usamplerCube usampler2DArray coherent restrict readonly writeonly resource atomic_uint noperspective patch sample subroutine common partition active filter image1D image2D image3D imageCube iimage1D iimage2D iimage3D iimageCube uimage1D uimage2D uimage3D uimageCube image1DArray image2DArray iimage1DArray iimage2DArray uimage1DArray uimage2DArray image1DShadow image2DShadow image1DArrayShadow image2DArrayShadow imageBuffer iimageBuffer uimageBuffer sampler1DArray sampler1DArrayShadow isampler1D isampler1DArray usampler1D usampler1DArray isampler2DRect usampler2DRect samplerBuffer isamplerBuffer usamplerBuffer sampler2DMS isampler2DMS usampler2DMS sampler2DMSArray isampler2DMSArray usampler2DMSArray trunc round roundEven isnan isinf floatBitsToInt floatBitsToUint intBitsToFloat uintBitsToFloat packSnorm2x16 unpackSnorm2x16 packUnorm2x16 unpackUnorm2x16 packHalf2x16 unpackHalf2x16 outerProduct transpose determinant inverse texture textureSize textureProj textureLod textureOffset texelFetch texelFetchOffset textureProjOffset textureLodOffset textureProjLod textureProjLodOffset textureGrad textureGradOffset textureProjGrad textureProjGradOffset".split(" ") }) },
    "esri/chunks/builtins": function () {
      define(["exports"], function (a) {
        var w = { exports: {} }; (function (u) { (function (y) { y = y(); void 0 !== y && (u.exports = y) })(function () { return "precision highp mediump lowp attribute const uniform varying break continue do for while if else in out inout float int void bool true false discard return mat2 mat3 mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow struct asm class union enum typedef template this packed goto switch default inline noinline volatile public static extern external interface long short double half fixed unsigned input output hvec2 hvec3 hvec4 dvec2 dvec3 dvec4 fvec2 fvec3 fvec4 sampler2DRect sampler3DRect sampler2DRectShadow sizeof cast namespace using".split(" ") }) })(w);
        w = w.exports; var c = { exports: {} }; (function (u) { (function (y) { y = y(); void 0 !== y && (u.exports = y) })(function () { "use strict;"; return "\x3c\x3c\x3d \x3e\x3e\x3d ++ -- \x3c\x3c \x3e\x3e \x3c\x3d \x3e\x3d \x3d\x3d !\x3d \x26\x26 || +\x3d -\x3d *\x3d /\x3d %\x3d \x26\x3d ^^ ^\x3d |\x3d ( ) [ ] . ! ~ * / % + - \x3c \x3e \x26 ^ | ? : \x3d , ; { }".split(" ") }) })(c); c = c.exports; var q = { exports: {} }; (function (u) { (function (y) { y = y(); void 0 !== y && (u.exports = y) })(function () { return "abs acos all any asin atan ceil clamp cos cross dFdx dFdy degrees distance dot equal exp exp2 faceforward floor fract gl_BackColor gl_BackLightModelProduct gl_BackLightProduct gl_BackMaterial gl_BackSecondaryColor gl_ClipPlane gl_ClipVertex gl_Color gl_DepthRange gl_DepthRangeParameters gl_EyePlaneQ gl_EyePlaneR gl_EyePlaneS gl_EyePlaneT gl_Fog gl_FogCoord gl_FogFragCoord gl_FogParameters gl_FragColor gl_FragCoord gl_FragData gl_FragDepth gl_FragDepthEXT gl_FrontColor gl_FrontFacing gl_FrontLightModelProduct gl_FrontLightProduct gl_FrontMaterial gl_FrontSecondaryColor gl_LightModel gl_LightModelParameters gl_LightModelProducts gl_LightProducts gl_LightSource gl_LightSourceParameters gl_MaterialParameters gl_MaxClipPlanes gl_MaxCombinedTextureImageUnits gl_MaxDrawBuffers gl_MaxFragmentUniformComponents gl_MaxLights gl_MaxTextureCoords gl_MaxTextureImageUnits gl_MaxTextureUnits gl_MaxVaryingFloats gl_MaxVertexAttribs gl_MaxVertexTextureImageUnits gl_MaxVertexUniformComponents gl_ModelViewMatrix gl_ModelViewMatrixInverse gl_ModelViewMatrixInverseTranspose gl_ModelViewMatrixTranspose gl_ModelViewProjectionMatrix gl_ModelViewProjectionMatrixInverse gl_ModelViewProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixTranspose gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_Normal gl_NormalMatrix gl_NormalScale gl_ObjectPlaneQ gl_ObjectPlaneR gl_ObjectPlaneS gl_ObjectPlaneT gl_Point gl_PointCoord gl_PointParameters gl_PointSize gl_Position gl_ProjectionMatrix gl_ProjectionMatrixInverse gl_ProjectionMatrixInverseTranspose gl_ProjectionMatrixTranspose gl_SecondaryColor gl_TexCoord gl_TextureEnvColor gl_TextureMatrix gl_TextureMatrixInverse gl_TextureMatrixInverseTranspose gl_TextureMatrixTranspose gl_Vertex greaterThan greaterThanEqual inversesqrt length lessThan lessThanEqual log log2 matrixCompMult max min mix mod normalize not notEqual pow radians reflect refract sign sin smoothstep sqrt step tan texture2D texture2DLod texture2DProj texture2DProjLod textureCube textureCubeLod texture2DLodEXT texture2DProjLodEXT textureCubeLodEXT texture2DGradEXT texture2DProjGradEXT textureCubeGradEXT".split(" ") }) })(q);
        a.builtins = q.exports; a.literals = w; a.operators = c
      })
    }, "esri/views/webgl/renderState": function () {
      define(["exports"], function (a) {
        function w(F) { return A.intern(F) } function c(F) { return z.intern(F) } function q(F) { return B.intern(F) } function u(F) { return C.intern(F) } function y(F) { return D.intern(F) } function n(F) { return E.intern(F) } function p(F) { return H.intern(F) } function l(F) { return J.intern(F) } function h(F) { return "[" + F.join(",") + "]" } function b(F) {
          return F ? h([F.srcRgb, F.srcAlpha, F.dstRgb, F.dstAlpha, F.opRgb,
          F.opAlpha, F.color.r, F.color.g, F.color.b, F.color.a]) : null
        } function d(F) { return F ? h([F.face, F.mode]) : null } function f(F) { return F ? h([F.factor, F.units]) : null } function t(F) { return F ? h([F.func]) : null } function v(F) { return F ? h([F.function.func, F.function.ref, F.function.mask, F.operation.fail, F.operation.zFail, F.operation.zPass]) : null } function m(F) { return F ? h([F.zNear, F.zFar]) : null } function e(F) { return F ? h([F.r, F.g, F.b, F.a]) : null } function g(F) { return F ? h([F.mask]) : null } const x = { face: 1029, mode: 2305 }, k = {
          face: 1028,
          mode: 2305
        }; var r = function () { function F(K, P) { this.makeKey = K; this.makeRef = P; this.interns = new Map } F.prototype.intern = function (K) { if (!K) return null; const P = this.makeKey(K), L = this.interns; L.has(P) || L.set(P, this.makeRef(K)); return L.get(P) }; return F }(); const A = new r(b, F => ({ __tag: "Blending", ...F })), z = new r(d, F => ({ __tag: "Culling", ...F })), B = new r(f, F => ({ __tag: "PolygonOffset", ...F })), C = new r(t, F => ({ __tag: "DepthTest", ...F })), D = new r(v, F => ({ __tag: "StencilTest", ...F })), E = new r(m, F => ({ __tag: "DepthWrite", ...F })),
          H = new r(e, F => ({ __tag: "ColorWrite", ...F })), J = new r(g, F => ({ __tag: "StencilWrite", ...F })), M = new r(function (F) { return F ? h([b(F.blending), d(F.culling), f(F.polygonOffset), t(F.depthTest), v(F.stencilTest), m(F.depthWrite), e(F.colorWrite), g(F.stencilWrite)]) : null }, F => ({ blending: w(F.blending), culling: c(F.culling), polygonOffset: q(F.polygonOffset), depthTest: u(F.depthTest), stencilTest: y(F.stencilTest), depthWrite: n(F.depthWrite), colorWrite: p(F.colorWrite), stencilWrite: l(F.stencilWrite) })); r = function () {
            function F(P) {
            this._stencilWriteInvalid =
              this._colorWriteInvalid = this._depthWriteInvalid = this._stencilTestInvalid = this._depthTestInvalid = this._polygonOffsetInvalid = this._cullingInvalid = this._blendingInvalid = this._pipelineInvalid = !0; this._stateSetters = P
            } var K = F.prototype; K.setPipeline = function (P) {
              if (this._pipelineInvalid || P !== this._pipeline) this.setBlending(P.blending), this.setCulling(P.culling), this.setPolygonOffset(P.polygonOffset), this.setDepthTest(P.depthTest), this.setStencilTest(P.stencilTest), this.setDepthWrite(P.depthWrite), this.setColorWrite(P.colorWrite),
                this.setStencilWrite(P.stencilWrite), this._pipeline = P; this._pipelineInvalid = !1
            }; K.invalidateBlending = function () { this._pipelineInvalid = this._blendingInvalid = !0 }; K.invalidateCulling = function () { this._pipelineInvalid = this._cullingInvalid = !0 }; K.invalidatePolygonOffset = function () { this._pipelineInvalid = this._polygonOffsetInvalid = !0 }; K.invalidateDepthTest = function () { this._pipelineInvalid = this._depthTestInvalid = !0 }; K.invalidateStencilTest = function () { this._pipelineInvalid = this._stencilTestInvalid = !0 }; K.invalidateDepthWrite =
              function () { this._pipelineInvalid = this._depthWriteInvalid = !0 }; K.invalidateColorWrite = function () { this._pipelineInvalid = this._colorWriteInvalid = !0 }; K.invalidateStencilWrite = function () { this._pipelineInvalid = this._stencilTestInvalid = !0 }; K.setBlending = function (P) { this._blending = this.setSubState(P, this._blending, this._blendingInvalid, this._stateSetters.setBlending); this._blendingInvalid = !1 }; K.setCulling = function (P) {
              this._culling = this.setSubState(P, this._culling, this._cullingInvalid, this._stateSetters.setCulling);
                this._cullingInvalid = !1
              }; K.setPolygonOffset = function (P) { this._polygonOffset = this.setSubState(P, this._polygonOffset, this._polygonOffsetInvalid, this._stateSetters.setPolygonOffset); this._polygonOffsetInvalid = !1 }; K.setDepthTest = function (P) { this._depthTest = this.setSubState(P, this._depthTest, this._depthTestInvalid, this._stateSetters.setDepthTest); this._depthTestInvalid = !1 }; K.setStencilTest = function (P) {
              this._stencilTest = this.setSubState(P, this._stencilTest, this._stencilTestInvalid, this._stateSetters.setStencilTest);
                this._stencilTestInvalid = !1
              }; K.setDepthWrite = function (P) { this._depthWrite = this.setSubState(P, this._depthWrite, this._depthWriteInvalid, this._stateSetters.setDepthWrite); this._depthWriteInvalid = !1 }; K.setColorWrite = function (P) { this._colorWrite = this.setSubState(P, this._colorWrite, this._colorWriteInvalid, this._stateSetters.setColorWrite); this._colorWriteInvalid = !1 }; K.setStencilWrite = function (P) {
              this._stencilWrite = this.setSubState(P, this._stencilWrite, this._stencilWriteInvalid, this._stateSetters.setStencilWrite);
                this._stencilTestInvalid = !1
              }; K.setSubState = function (P, L, N, G) { if (N || P !== L) G(P), this._pipelineInvalid = !0; return P }; return F
          }(); a.StateTracker = r; a.backFaceCullingParams = x; a.cullingParams = F => 2 === F ? x : 1 === F ? k : null; a.defaultColorWriteParams = { r: !0, g: !0, b: !0, a: !0 }; a.defaultDepthWriteParams = { zNear: 0, zFar: 1 }; a.frontFaceCullingParams = k; a.makeBlending = w; a.makeColorWrite = p; a.makeCulling = c; a.makeDepthTest = u; a.makeDepthWrite = n; a.makePipelineState = function (F) { return M.intern(F) }; a.makePolygonOffset = q; a.makeStencilTest =
            y; a.makeStencilWrite = l; a.separateBlendingParams = function (F, K, P, L, N = 32774, G = 32774, I = [0, 0, 0, 0]) { return { srcRgb: F, srcAlpha: K, dstRgb: P, dstAlpha: L, opRgb: N, opAlpha: G, color: { r: I[0], g: I[1], b: I[2], a: I[3] } } }; a.simpleBlendingParams = function (F, K, P = 32774, L = [0, 0, 0, 0]) { return { srcRgb: F, srcAlpha: F, dstRgb: K, dstAlpha: K, opRgb: P, opAlpha: P, color: { r: L[0], g: L[1], b: L[2], a: L[3] } } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/DefaultVertexBufferLayouts": function () {
      define(["exports"], function (a) {
      a.Pos2 =
        [{ name: "position", count: 2, type: 5126, offset: 0, stride: 8, normalized: !1 }]; a.Pos2Tex = [{ name: "position", count: 2, type: 5126, offset: 0, stride: 16, normalized: !1 }, { name: "uv0", count: 2, type: 5126, offset: 8, stride: 16, normalized: !1 }]; a.Pos3 = [{ name: "position", count: 3, type: 5126, offset: 0, stride: 12, normalized: !1 }]; a.Pos3Col = [{ name: "position", count: 3, type: 5126, offset: 0, stride: 16, normalized: !1 }, { name: "color", count: 4, type: 5121, offset: 12, stride: 16, normalized: !1 }]; a.Pos3NormalTex = [{
          name: "position", count: 3, type: 5126, offset: 0,
          stride: 32, normalized: !1
        }, { name: "normal", count: 3, type: 5126, offset: 12, stride: 32, normalized: !1 }, { name: "uv0", count: 2, type: 5126, offset: 24, stride: 32, normalized: !1 }]; a.Pos3Tex = [{ name: "position", count: 3, type: 5126, offset: 0, stride: 20, normalized: !1 }, { name: "uv0", count: 2, type: 5126, offset: 12, stride: 20, normalized: !1 }]; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/glUtil3D": function () {
      define("exports ./DefaultVertexAttributeLocations ./DefaultVertexBufferLayouts ../../../webgl/BufferObject ../../../webgl/Texture ../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y) {
        a.createColorTexture = function (n, p, l = 4) { const h = new Uint8Array(l * l * 4); for (let b = 0; b < h.length; b += 4)h[b + 0] = 255 * p[0], h[b + 1] = 255 * p[1], h[b + 2] = 255 * p[2], h[b + 3] = 255 * p[3]; return new u(n, { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: l, height: l }, h) }; a.createEmptyDepthTexture = function (n) { return new u(n, { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: 1, height: 1 }, new Uint8Array([255, 255, 255, 255])) }; a.createEmptyTexture = function (n, p = 4) {
          return new u(n,
            { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: p, height: p })
        }; a.createQuadVAO = function (n, p = c.Pos2, l = w.Default3D, h = -1, b = 1) { let d = null; switch (p) { case c.Pos2Tex: d = new Float32Array([h, h, 0, 0, b, h, 1, 0, h, b, 0, 1, b, b, 1, 1]); break; default: d = new Float32Array([h, h, b, h, h, b, b, b]) }return new y(n, l, { geometry: p }, { geometry: q.createVertex(n, 35044, d) }) }; a.createScreenSizeTriangleVAO = function (n, p = c.Pos2, l = w.Default3D) {
          const h = new Float32Array([-1, -1, 3, -1, -1, 3]); return new y(n, l, { geometry: p }, {
            geometry: q.createVertex(n,
              35044, h)
          })
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/BufferObject": function () {
      define(["../../chunks/_rollupPluginBabelHelpers", "../../core/Logger", "../../core/typedArrayUtil", "./checkWebGLError", "./enums"], function (a, w, c, q, u) {
        const y = w.getLogger("esri.views.webgl.BufferObject"); return function () {
          function n(l, h, b, d, f) {
          this._context = l; this.bufferType = h; this.usage = b; this._glName = null; this._size = -1; this._indexType = void 0; l.instanceCounter.increment(u.ResourceType.Buffer, this);
            this._glName = this._context.gl.createBuffer(); q.checkWebGLError(this._context.gl); d && this.setData(d, f)
          } n.createIndex = function (l, h, b, d) { return new n(l, 34963, h, b, d) }; n.createVertex = function (l, h, b) { return new n(l, 34962, h, b) }; var p = n.prototype; p.dispose = function () { var l; null != (l = this._context) && l.gl ? (this._glName && (this._context.gl.deleteBuffer(this._glName), this._glName = null), this._context.instanceCounter.decrement(u.ResourceType.Buffer, this), this._context = null) : this._glName && y.warn("Leaked WebGL buffer object") };
          p.setData = function (l, h) {
            if (l) {
              if ("number" === typeof l) { if (0 > l && y.error("Buffer size cannot be negative!"), this._size = l, 34963 === this.bufferType && h) switch (this._indexType = h, this._size = l, h) { case 5123: l *= 2; break; case 5125: l *= 4 } } else h = l.byteLength, c.isUint16Array(l) && (h /= 2, this._indexType = 5123), c.isUint32Array(l) && (h /= 4, this._indexType = 5125), this._size = h; h = this._context.getBoundVAO(); this._context.bindVAO(null); this._context.bindBuffer(this); var b = this._context.gl; b.bufferData(this.bufferType, l, this.usage);
              q.checkWebGLError(b); this._context.bindVAO(h)
            }
          }; p.setSubData = function (l, h = 0, b = 0, d = l.byteLength) {
            if (l) {
            (0 > h || h >= this._size) && y.error("offset is out of range!"); var f = h, t = b, v = d, m = l.byteLength; c.isUint16Array(l) ? (m /= 2, f *= 2, t *= 2, v *= 2) : c.isUint32Array(l) && (m /= 4, f *= 4, t *= 4, v *= 4); void 0 === d && (d = m - 1); b >= d && y.error("end must be bigger than start!"); h + b - d > this._size && y.error("An attempt to write beyond the end of the buffer!"); h = this._context.getBoundVAO(); this._context.bindVAO(null); this._context.bindBuffer(this);
              b = this._context.gl; d = ArrayBuffer.isView(l) ? l.buffer : l; l = 0 === t && v === l.byteLength ? d : d.slice(t, v); b.bufferSubData(this.bufferType, f, l); q.checkWebGLError(b); this._context.bindVAO(h)
            }
          }; p.setSubDataFromView = function (l, h, b, d) {
            if (l) {
            (0 > h || h >= this._size) && y.error("offset is out of range!"); b >= d && y.error("end must be bigger than start!"); h + b - d > this._size && y.error("An attempt to write beyond the end of the buffer!"); var f = this._context.getBoundVAO(); this._context.bindVAO(null); this._context.bindBuffer(this);
              var t = this._context.gl; b = 0 === b && d === l.length ? l : l.subarray(b, d); t.bufferSubData(this.bufferType, h * l.BYTES_PER_ELEMENT, b); q.checkWebGLError(t); this._context.bindVAO(f)
            }
          }; a._createClass(n, [{ key: "glName", get: function () { return this._glName } }, { key: "size", get: function () { return this._size } }, { key: "indexType", get: function () { return this._indexType } }, { key: "byteSize", get: function () { return 34962 === this.bufferType ? this._size : 5125 === this._indexType ? 4 * this._size : 2 * this._size } }]); return n
        }()
      })
    }, "esri/views/webgl/Texture": function () {//jj
      define("../../chunks/_rollupPluginBabelHelpers ../../core/mathUtils ../../core/maybe ./checkWebGLError ./enums ./capabilities/isWebGL2Context".split(" "),
        function (a, w, c, q, u, y) {
          let n = function () {
            function p(h, b, d = null) { this._context = h; this.type = "texture"; this._glName = null; this._descriptor = void 0; this._wrapModeDirty = this._samplingModeDirty = !1; h.instanceCounter.increment(u.ResourceType.Texture, this); this._descriptor = { target: 3553, samplingMode: 9729, wrapMode: 10497, flipped: !1, hasMipmap: !1, isOpaque: !1, unpackAlignment: 4, preMultiplyAlpha: !1, ...b }; 34067 === this._descriptor.target ? this.setDataCubeMap(d) : this.setData(d) } var l = p.prototype; l.dispose = function () {
              this._context.gl &&
              this._glName && (this._context.unbindTextureAllUnits(this), this._context.gl.deleteTexture(this._glName), this._glName = null, this._context.instanceCounter.decrement(u.ResourceType.Texture, this))
            }; l.release = function () { this.dispose() }; l.resize = function (h, b) { const d = this._descriptor; if (d.width !== h || d.height !== b) d.width = h, d.height = b, 34067 === this._descriptor.target ? this.setDataCubeMap(null) : this.setData(null) }; 
            l.setDataCubeMap = function (h = null) { for (let b = 34069; 34074 >= b; b++)this.setData(h, b) }; l.setData = function (h,
              b = 3553) {
                if (this._context && this._context.gl) {
                  var d = this._context.gl; this._glName || (this._glName = d.createTexture()); void 0 === h && (h = null); null === h && (this._descriptor.width = this._descriptor.width || 4, this._descriptor.height = this._descriptor.height || 4); 
                  var f = this._context.bindTexture(this, p.TEXTURE_UNIT_FOR_UPDATES), t = this._descriptor; 
                  p._validateTexture(this._context, t); 
                  d.pixelStorei(d.UNPACK_ALIGNMENT, t.unpackAlignment); 
                  d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, t.flipped ? 1 : 0); 
                  d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    t.preMultiplyAlpha ? 1 : 0); var v = t.pixelFormat, m = t.internalFormat ? t.internalFormat : this._deriveInternalFormat(v, t.dataType); 
                    if (h instanceof ImageData || h instanceof HTMLImageElement || h instanceof HTMLCanvasElement || h instanceof HTMLVideoElement) { 
                      var e = h.width, g = h.height; 
                      h instanceof HTMLVideoElement && (e = h.videoWidth, g = h.videoHeight); 
                      d.texImage2D(b, 0, m, v, t.dataType, h);
                       q.checkWebGLError(d); 
                      t.hasMipmap && this.generateMipmap(); 
                      void 0 === t.width && (t.width = e); void 0 === t.height && (t.height = g) 
                    }
                    else {
                    null != t.width &&
                      null != t.height || console.error("Width and height must be specified!"); d.DEPTH24_STENCIL8 && m === d.DEPTH_STENCIL && (m = d.DEPTH24_STENCIL8); e = t.width; g = t.height; var x = h; if (c.isSome(x) && "type" in x && "compressed" === x.type) for (v = Math.round(Math.log(Math.max(e, g)) / Math.LN2) + 1, t.hasMipmap = t.hasMipmap && v === h.levels.length, v = 0; ; ++v) { d.compressedTexImage2D(b, v, m, e, g, 0, h.levels[Math.min(v, h.levels.length - 1)]); if (1 === e && 1 === g || !t.hasMipmap) break; e = Math.max(1, e >> 1); g = Math.max(1, g >> 1) } else if (c.isSome(h)) d.texImage2D(b,
                        0, m, e, g, 0, v, t.dataType, h), q.checkWebGLError(d), t.hasMipmap && this.generateMipmap(); else for (h = 0; ; ++h) { d.texImage2D(b, h, m, e, g, 0, v, t.dataType, null); q.checkWebGLError(d); if (1 === e && 1 === g || !t.hasMipmap) break; e = Math.max(1, e >> 1); g = Math.max(1, g >> 1) }
                    } p._applySamplingMode(d, this._descriptor); p._applyWrapMode(d, this._descriptor); p._applyAnisotropicFilteringParameters(this._context, this._descriptor); q.checkWebGLError(d); this._context.bindTexture(f, p.TEXTURE_UNIT_FOR_UPDATES)
                }
            }; l.updateData = function (h, b, d, f, t,
              v, m = 3553) {
                v || console.error("An attempt to use uninitialized data!"); this._glName || console.error("An attempt to update uninitialized texture!"); const e = this._context.gl, g = this._descriptor, x = this._context.bindTexture(this, p.TEXTURE_UNIT_FOR_UPDATES); (0 > b || 0 > d || f > g.width || t > g.height || b + f > g.width || d + t > g.height) && console.error("An attempt to update out of bounds of the texture!"); e.pixelStorei(e.UNPACK_ALIGNMENT, g.unpackAlignment); e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, g.flipped ? 1 : 0); e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  g.preMultiplyAlpha ? 1 : 0); v instanceof ImageData || v instanceof HTMLImageElement || v instanceof HTMLCanvasElement || v instanceof HTMLVideoElement ? e.texSubImage2D(m, h, b, d, g.pixelFormat, g.dataType, v) : e.texSubImage2D(m, h, b, d, f, t, g.pixelFormat, g.dataType, v); this._context.bindTexture(x, p.TEXTURE_UNIT_FOR_UPDATES)
            }; l.generateMipmap = function () {
              const h = this._descriptor; h.hasMipmap || (this._samplingModeDirty = h.hasMipmap = !0, p._validateTexture(this._context, h)); 9729 === h.samplingMode ? (this._samplingModeDirty = !0, h.samplingMode =
                9985) : 9728 === h.samplingMode && (this._samplingModeDirty = !0, h.samplingMode = 9984); const b = this._context.bindTexture(this, p.TEXTURE_UNIT_FOR_UPDATES); this._context.gl.generateMipmap(h.target); this._context.bindTexture(b, p.TEXTURE_UNIT_FOR_UPDATES)
            }; l.setSamplingMode = function (h) { h !== this._descriptor.samplingMode && (this._descriptor.samplingMode = h, this._samplingModeDirty = !0) }; l.setWrapMode = function (h) {
            h !== this._descriptor.wrapMode && (this._descriptor.wrapMode = h, p._validateTexture(this._context, this._descriptor),
              this._wrapModeDirty = !0)
            }; l.applyChanges = function () { const h = this._context.gl, b = this._descriptor; this._samplingModeDirty && (p._applySamplingMode(h, b), this._samplingModeDirty = !1); this._wrapModeDirty && (p._applyWrapMode(h, b), this._wrapModeDirty = !1) }; l._deriveInternalFormat = function (h, b) { if ("webgl" === this._context.webglVersion) return h; switch (b) { case 5126: switch (h) { case 6408: return 34836; case 6407: return 34837; default: throw Error("Unable to derive format"); }default: return h } }; p._validateTexture = function (h,
              b) { (0 > b.width || 0 > b.height) && console.error("Negative dimension parameters are not allowed!"); const d = w.isPowerOfTwo(b.width) && w.isPowerOfTwo(b.height); y(h.gl) || d || ("number" === typeof b.wrapMode ? 33071 !== b.wrapMode && console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!") : (33071 !== b.wrapMode.s || 33071 !== b.wrapMode.t) && console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"), b.hasMipmap && console.error("Mipmapping requires power-of-two textures!")) }; p._applySamplingMode =
                function (h, b) { let d = b.samplingMode, f = b.samplingMode; if (9985 === d || 9987 === d) d = 9729, b.hasMipmap || (f = 9729); else if (9984 === d || 9986 === d) d = 9728, b.hasMipmap || (f = 9728); h.texParameteri(b.target, h.TEXTURE_MAG_FILTER, d); h.texParameteri(b.target, h.TEXTURE_MIN_FILTER, f) }; p._applyWrapMode = function (h, b) {
                  "number" === typeof b.wrapMode ? (h.texParameteri(b.target, h.TEXTURE_WRAP_S, b.wrapMode), h.texParameteri(b.target, h.TEXTURE_WRAP_T, b.wrapMode)) : (h.texParameteri(b.target, h.TEXTURE_WRAP_S, b.wrapMode.s), h.texParameteri(b.target,
                    h.TEXTURE_WRAP_T, b.wrapMode.t))
                }; p._applyAnisotropicFilteringParameters = function (h, b) { var d; const f = h.capabilities.textureFilterAnisotropic; f && h.gl.texParameterf(b.target, f.TEXTURE_MAX_ANISOTROPY, null != (d = b.maxAnisotropy) ? d : 1) }; a._createClass(p, [{ key: "glName", get: function () { return this._glName } }, { key: "descriptor", get: function () { return this._descriptor } }, { key: "isDirty", get: function () { return this._samplingModeDirty || this._wrapModeDirty } }]); return p
          }(); n.TEXTURE_UNIT_FOR_UPDATES = 0; return n
        })
    }, "esri/views/webgl/capabilities/isWebGL2Context": function () {
      define(function () {
        return function (a) {
          return window.WebGL2RenderingContext &&
            a instanceof window.WebGL2RenderingContext
        }
      })
    }, "esri/views/webgl/VertexArrayObject": function () {
      define(["../../chunks/_rollupPluginBabelHelpers", "../../core/Logger", "../../core/maybe", "./enums", "./Util"], function (a, w, c, q, u) {
        const y = w.getLogger("esri.views.webgl.VertexArrayObject"); return function () {
          function n(l, h, b, d, f = null) { this._context = l; this._locations = h; this._layout = b; this._buffers = d; this._indexBuffer = f; this._glName = null; this._initialized = !1; l.instanceCounter.increment(q.ResourceType.VAO, this) }
          var p = n.prototype; p.dispose = function (l = !0) {
            if (this._context) {
              if (this._glName) { var h, b; const d = null == (h = this._context) ? void 0 : null == (b = h.capabilities) ? void 0 : b.vao; d ? (d.deleteVertexArray(this._glName), this._glName = null) : y.warn("Leaked WebGL VAO") } this._context.getBoundVAO() === this && this._context.bindVAO(null); if (l) { for (const d in this._buffers) this._buffers[d].dispose(), delete this._buffers[d]; this._indexBuffer = c.disposeMaybe(this._indexBuffer) } this._context.instanceCounter.decrement(q.ResourceType.VAO,
                this); this._context = null
            } else (this._glName || l && 0 < Object.getOwnPropertyNames(this._buffers).length) && y.warn("Leaked WebGL VAO")
          }; p.initialize = function () { if (!this._initialized) { var l = this._context.capabilities.vao; if (l) { const h = l.createVertexArray(); l.bindVertexArray(h); this._bindLayout(); l.bindVertexArray(null); this._glName = h } this._initialized = !0 } }; p.bind = function () { this.initialize(); const l = this._context.capabilities.vao; l ? l.bindVertexArray(this.glName) : (this._context.bindVAO(null), this._bindLayout()) };
          p._bindLayout = function () { const { _buffers: l, _layout: h, _indexBuffer: b } = this; l || y.error("Vertex buffer dictionary is empty!"); const d = this._context.gl; for (const f in l) { const t = l[f]; t || y.error("Vertex buffer is uninitialized!"); const v = h[f]; v || y.error("Vertex element descriptor is empty!"); u.bindVertexBufferLayout(this._context, this._locations, t, v) } c.isSome(b) && (this._context.capabilities.vao ? d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, b.glName) : this._context.bindBuffer(b)) }; p.unbind = function () {
            this.initialize();
            const l = this._context.capabilities.vao; l ? l.bindVertexArray(null) : this._unbindLayout()
          }; p._unbindLayout = function () { const { _buffers: l, _layout: h } = this; l || y.error("Vertex buffer dictionary is empty!"); for (const b in l) { const d = l[b]; d || y.error("Vertex buffer is uninitialized!"); u.unbindVertexBufferLayout(this._context, this._locations, d, h[b]) } c.isSome(this._indexBuffer) && this._context.unbindBuffer(this._indexBuffer.bufferType) }; a._createClass(n, [{ key: "glName", get: function () { return this._glName } }, {
            key: "vertexBuffers",
            get: function () { return this._buffers }
          }, { key: "indexBuffer", get: function () { return this._indexBuffer } }, { key: "size", get: function () { return Object.keys(this._buffers).reduce((l, h) => l + this._buffers[h].size, c.isSome(this._indexBuffer) ? this._indexBuffer.size : 0) } }, { key: "layout", get: function () { return this._layout } }, { key: "locations", get: function () { return this._locations } }]); return n
        }()
      })
    }, "esri/views/webgl/Util": function () {
      define(["exports", "../../core/has", "../../core/maybe"], function (a, w, c) {
        function q(n) { return n[0].stride }
        function u(n) { switch (n) { case 6406: case 6409: case 36168: return 1; case 6410: case 32854: case 33325: case 32854: case 33189: return 2; case 6407: case 6402: return 3; case 6408: case 34041: case 33326: case 35898: case 33327: case 34041: return 4; case 33328: case 34842: return 8; case 34837: return 12; case 34836: return 16; case 33776: case 33777: return .5; case 33778: case 33779: return 1; case 37488: case 37489: case 37492: case 37493: case 37494: case 37495: return .5; case 37490: case 37491: case 37496: case 37497: return 1 }return 0 }
        function y(n) { if (c.isNone(n)) return 0; if ("descriptor" in n) return n.glName ? y(n.descriptor) : 0; const p = n.internalFormat || "pixelFormat" in n && n.pixelFormat; if (!p) return 0; const l = "hasMipmap" in n && n.hasMipmap ? 1.3 : 1; n = n.width * n.height; return u(p) * n * l } a.bindVertexBufferLayout = function (n, p, l, h, b) {
          const d = n.gl, f = n.capabilities.instancing; n.bindBuffer(l); for (const t of h) if (n = p.get(t.name), void 0 === n && console.error(`There is no location for vertex attribute '${t.name}' defined.`), t.baseInstance && !t.divisor &&
            console.error(`Vertex attribute '${t.name}' uses baseInstanceOffset without divisor.`), l = (b ? b : 0 + t.baseInstance ? t.baseInstance : 0) * t.stride, 4 >= t.count) d.vertexAttribPointer(n, t.count, t.type, t.normalized, t.stride, t.offset + l), d.enableVertexAttribArray(n), 0 < t.divisor && f && f.vertexAttribDivisor(n, t.divisor); else if (9 === t.count) for (h = 0; 3 > h; h++)d.vertexAttribPointer(n + h, 3, t.type, t.normalized, t.stride, t.offset + 12 * h + l), d.enableVertexAttribArray(n + h), 0 < t.divisor && f && f.vertexAttribDivisor(n + h, t.divisor); else if (16 ===
              t.count) for (h = 0; 4 > h; h++)d.vertexAttribPointer(n + h, 4, t.type, t.normalized, t.stride, t.offset + 16 * h + l), d.enableVertexAttribArray(n + h), 0 < t.divisor && f && f.vertexAttribDivisor(n + h, t.divisor); else console.error("Unsupported vertex attribute element count: " + t.count)
        }; a.getBytesPerElementFormat = u; a.getGpuMemoryUsage = y; a.getStride = q; a.unbindVertexBufferLayout = function (n, p, l, h) {
          const b = n.gl, d = n.capabilities.instancing; n.bindBuffer(l); for (const f of h) if (l = p.get(f.name), 4 >= f.count) b.disableVertexAttribArray(l),
            f.divisor && 0 < f.divisor && d && d.vertexAttribDivisor(l, 0); else if (9 === f.count) for (h = 0; 3 > h; h++)b.disableVertexAttribArray(l + h), f.divisor && 0 < f.divisor && d && d.vertexAttribDivisor(l + h, 0); else if (16 === f.count) for (h = 0; 4 > h; h++)b.disableVertexAttribArray(l + h), f.divisor && 0 < f.divisor && d && d.vertexAttribDivisor(l + h, 0); else console.error("Unsupported vertex attribute element count: " + f.count); n.unbindBuffer(34962)
        }; a.vertexCount = function (n, p) { return n.vertexBuffers[p].size / q(n.layout[p]) }; Object.defineProperty(a, "__esModule",
          { value: !0 })
      })
    }, "esri/views/3d/environment/CloudsComposition": function () {
      define("exports ../../../core/mathUtils ../../../core/maybe ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/support/axisAngle ./CloudsCompositionTechnique ../webgl-engine/lib/glUtil3D".split(" "), function (a, w, c, q, u, y, n, p, l, h) {
        var b; (function (k) { k[k.FINISHED = 0] = "FINISHED"; k[k.CHANGE_ANCHOR = 1] = "CHANGE_ANCHOR"; k[k.FADE_IN = 2] = "FADE_IN" })(b || (b = {})); var d; (function (k) {
        k[k.FINISHED =
          0] = "FINISHED"; k[k.FADE_OUT = 1] = "FADE_OUT"; k[k.FADE_IN = 2] = "FADE_IN"
        })(d || (d = {})); var f; (function (k) { k[k.FINISHED = 0] = "FINISHED"; k[k.CROSS_FADE = 1] = "CROSS_FADE" })(f || (f = {})); var t; (function (k) { k[k.FINISHED = 0] = "FINISHED"; k[k.HEIGHT_FADE = 1] = "HEIGHT_FADE" })(t || (t = {})); let v = function () {
          function k(A, z, B, C) {
          this._viewingMode = z; this._inverseProjectionMatrix = u.create(); this._inverseViewMatrix = u.create(); this._cameraPositionLastFrame = n.create(); this._technique = new l.CloudsCompositionTechnique({ rctx: A, viewingMode: this._viewingMode },
            null); this._vao = h.createQuadVAO(A); this._setDefaultParallax(B, C)
          } var r = k.prototype; r.destroy = function () { this._technique = c.releaseMaybe(this._technique); this._vao = c.disposeMaybe(this._vao) }; r.render = function (A, z, B, C, D) {
            const E = A.camera; if (c.isNone(this._vao) || c.isNone(E)) return !1; const H = A.rctx, J = this._technique.program; H.useProgram(J); this._technique.bindPipelineState(H); this._isCameraAnimating = B; A.scenelightingData.setLightDirectionUniform(J); A.scenelightingData.setUniforms(J); q.invert(this._inverseProjectionMatrix,
              E.projectionMatrix); q.invert(this._inverseViewMatrix, E.viewMatrix); J.setUniformMatrix4fv("inverseProjectionMatrix", this._inverseProjectionMatrix); J.setUniformMatrix4fv("inverseViewMatrix", this._inverseViewMatrix); J.bindTexture(z.colorTexture, "cubeMap"); J.setUniform2fv("cloudVariables", [C, D]); this._setParallaxParams(E.eye); this._bindParallaxParams(J, A.camera); H.bindVAO(this._vao); J.assertCompatibleVertexAttributeLocations(this._vao); H.drawArrays(5, 0, 4); return !0
          }; r.isFading = function () {
            return this._crossFadeParams.crossFadeStage !==
              f.FINISHED || this._fadeInOutParams.fadeInOutStage !== d.FINISHED || this._fadeInParams.fadeInStage !== b.FINISHED || this._fadeInOutHeightParams.fadeHeightStage !== t.FINISHED
          }; r._setDefaultParallax = function (A, z) {
          this._parallaxParams = { anchorPointClouds: n.create(), radius: A, cloudsHeight: 1E5, radiusCurvatureCorrectionFactor: 0, transform: u.create() }; this._parallaxParamsNew = { anchorPointClouds: n.create(), radius: A, cloudsHeight: 1E5, radiusCurvatureCorrectionFactor: 0, transform: u.create() }; this._crossFadeParams = {
            crossFadeStage: f.FINISHED,
            crossFadeFactor: 0, distanceThresholdFactor: .3
          }; this._fadeInOutParams = { fadeInOutStage: d.FINISHED, fadeInOutFactor: 0, distanceThresholdFactor: .6 }; this._fadeInParams = { fadeInStage: b.FINISHED, fadeInFactor: 0, distanceThresholdFactor: 2 }; this._fadeInOutHeightParams = { fadeHeightStage: t.FINISHED, fadeHeightFactor: 1E4 < z ? 1 : 0, heightThresholdFactor: 1E4 }
          }; r._isCameraPositionFinal = function (A) { return y.equals(this._cameraPositionLastFrame, A) }; r._setFadeInStage = function (A) {
            A = this._isCameraPositionFinal(A); this._fadeInParams.fadeInStage ===
              b.FINISHED && (this._fadeInParams.fadeInFactor = 1, y.copy(this._parallaxParams.anchorPointClouds, g), this._fadeInParams.fadeInStage = b.CHANGE_ANCHOR, this._crossFadeParams.crossFadeStage = f.FINISHED, this._fadeInOutParams.fadeInOutStage = d.FINISHED); this._fadeInParams.fadeInStage === b.CHANGE_ANCHOR && A && (y.copy(this._parallaxParams.anchorPointClouds, g), this._fadeInParams.fadeInStage = b.FADE_IN, this._startTime = performance.now()); 0 < this._fadeInParams.fadeInFactor && this._fadeInParams.fadeInStage === b.FADE_IN && (this._fadeInParams.fadeInFactor =
                1 - (performance.now() - this._startTime) / 500); 0 >= this._fadeInParams.fadeInFactor && this._fadeInParams.fadeInStage === b.FADE_IN && (this._fadeInParams.fadeInStage = b.FINISHED, this._fadeInParams.fadeInFactor = 0)
          }; r._setCrossFadingStage = function () {
            this._crossFadeParams.crossFadeStage === f.FINISHED && (y.copy(this._parallaxParamsNew.anchorPointClouds, g), this._startTime = performance.now(), this._crossFadeParams.crossFadeFactor = 0, this._crossFadeParams.crossFadeStage = f.CROSS_FADE); 1 > this._crossFadeParams.crossFadeFactor &&
              this._crossFadeParams.crossFadeStage === f.CROSS_FADE && (this._crossFadeParams.crossFadeFactor = (performance.now() - this._startTime) / 500); 1 <= this._crossFadeParams.crossFadeFactor && this._crossFadeParams.crossFadeStage === f.CROSS_FADE && (this._crossFadeParams.crossFadeStage = f.FINISHED, this._crossFadeParams.crossFadeFactor = 1, y.copy(this._parallaxParams.anchorPointClouds, this._parallaxParamsNew.anchorPointClouds))
          }; r._setFadeInOutStage = function (A) {
            this._fadeInOutParams.fadeInOutStage === d.FINISHED && (this._startTime =
              performance.now(), this._fadeInOutParams.fadeInOutFactor = 0, this._fadeInOutParams.fadeInOutStage = d.FADE_OUT); 1 > this._fadeInOutParams.fadeInOutFactor && this._fadeInOutParams.fadeInOutStage === d.FADE_OUT && (this._fadeInOutParams.fadeInOutFactor = (performance.now() - this._startTime) / 250); 1 <= this._fadeInOutParams.fadeInOutFactor && this._fadeInOutParams.fadeInOutStage === d.FADE_OUT && (this._fadeInOutParams.fadeInOutFactor = 1, y.copy(this._parallaxParams.anchorPointClouds, g)); 1 <= this._fadeInOutParams.fadeInOutFactor &&
                this._fadeInOutParams.fadeInOutStage === d.FADE_OUT && this._isCameraPositionFinal(A) && (this._startTime = performance.now(), this._fadeInOutParams.fadeInOutFactor = 1, this._fadeInOutParams.fadeInOutStage = d.FADE_IN, this._crossFadeParams.crossFadeStage = f.FINISHED, this._crossFadeParams.crossFadeFactor = 0); 0 < this._fadeInOutParams.fadeInOutFactor && this._fadeInOutParams.fadeInOutStage === d.FADE_IN && (this._fadeInOutParams.fadeInOutFactor = 1 - (performance.now() - this._startTime) / 500); 0 >= this._fadeInOutParams.fadeInOutFactor &&
                  this._fadeInOutParams.fadeInOutStage === d.FADE_IN && (this._fadeInOutParams.fadeInOutStage = d.FINISHED, this._fadeInOutParams.fadeInOutFactor = 0)
          }; r._setFadeInOutHeight = function (A) {
            const z = performance.now(); this._startTimeHeightFade = this._fadeInOutHeightParams.fadeHeightStage === t.FINISHED ? z : this._startTimeHeightFade; this._fadeInOutHeightParams.fadeHeightFactor = A ? this._fadeInOutHeightParams.fadeHeightFactor + (z - this._startTimeHeightFade) / 500 : this._fadeInOutHeightParams.fadeHeightFactor - (z - this._startTimeHeightFade) /
              500; this._startTimeHeightFade = z; this._fadeInOutHeightParams.fadeHeightFactor = w.clamp(this._fadeInOutHeightParams.fadeHeightFactor, 0, 1); this._fadeInOutHeightParams.fadeHeightStage = t.HEIGHT_FADE
          }; r._setParallaxParams = function (A) {
            y.normalize(g, A); y.scale(g, g, this._parallaxParams.radius); 0 === this._parallaxParams.anchorPointClouds[0] && 0 === this._parallaxParams.anchorPointClouds[1] && 0 === this._parallaxParams.anchorPointClouds[2] && y.copy(this._parallaxParams.anchorPointClouds, g); var z = y.length(y.subtract(x,
              this._parallaxParams.anchorPointClouds, g)); let B = !0; z > this._fadeInParams.distanceThresholdFactor * this._parallaxParams.cloudsHeight || this._fadeInParams.fadeInStage !== b.FINISHED ? this._setFadeInStage(A) : z > this._fadeInOutParams.distanceThresholdFactor * this._parallaxParams.cloudsHeight || this._fadeInOutParams.fadeInOutStage !== d.FINISHED ? this._setFadeInOutStage(A) : z > this._crossFadeParams.distanceThresholdFactor * this._parallaxParams.cloudsHeight && !this._isCameraAnimating || this._crossFadeParams.crossFadeStage !==
                f.FINISHED ? this._setCrossFadingStage() : B = !1; z = y.length(A); const C = z - this._parallaxParams.radius; (C > 1.7 * this._fadeInOutHeightParams.heightThresholdFactor || C < -1 * this._fadeInOutHeightParams.heightThresholdFactor) && 1 > this._fadeInOutHeightParams.fadeHeightFactor ? this._fadeInOutHeightParams.fadeHeightFactor = 1 : (C > this._fadeInOutHeightParams.heightThresholdFactor || C < -.35 * this._fadeInOutHeightParams.heightThresholdFactor) && 1 > this._fadeInOutHeightParams.fadeHeightFactor ? this._setFadeInOutHeight(!0) : C < this._fadeInOutHeightParams.heightThresholdFactor &&
                  C > -.35 * this._fadeInOutHeightParams.heightThresholdFactor && 0 < this._fadeInOutHeightParams.fadeHeightFactor ? this._setFadeInOutHeight(!1) : this._fadeInOutHeightParams.fadeHeightStage = t.FINISHED; this._parallaxParams.radiusCurvatureCorrectionFactor = .84 * Math.sqrt(Math.max(z * z - this._parallaxParams.radius * this._parallaxParams.radius, 0)) / z; p.fromPoints(m, this._parallaxParams.anchorPointClouds, e); this._parallaxParams.transform = u.create(); q.rotate(this._parallaxParams.transform, this._parallaxParams.transform,
                    e[3], p.axis(e)); B && (p.fromPoints(m, this._parallaxParamsNew.anchorPointClouds, e), this._parallaxParamsNew.transform = u.create(), q.rotate(this._parallaxParamsNew.transform, this._parallaxParamsNew.transform, e[3], p.axis(e))); y.copy(this._cameraPositionLastFrame, A)
          }; r._bindParallaxParams = function (A, z) {
            A.setUniform1f("cloudsHeight", this._parallaxParams.cloudsHeight); A.setUniformMatrix4fv("rotationMatrixClouds", this._parallaxParams.transform); A.setUniformMatrix4fv("rotationMatrixCloudsCrossFade", this._parallaxParamsNew.transform);
            A.setUniform3fv("anchorPosition", this._parallaxParams.anchorPointClouds); A.setUniform3fv("anchorPositionCrossFade", this._parallaxParamsNew.anchorPointClouds); this._fadeInOutParams.fadeInOutStage !== d.FINISHED ? A.setUniform1f("totalFadeInOut", this._fadeInOutHeightParams.fadeHeightFactor + Math.max(w.clamp(this._fadeInOutParams.fadeInOutFactor, 0, 1))) : A.setUniform1f("totalFadeInOut", this._fadeInOutHeightParams.fadeHeightFactor + Math.max(w.clamp(this._fadeInParams.fadeInFactor, 0, 1))); A.setUniform1f("radiusCurvatureCorrectionFactor",
              this._parallaxParams.radiusCurvatureCorrectionFactor); A.setUniform1i("crossFade", this._crossFadeParams.crossFadeStage); A.setUniform1f("crossFadeAnchorFactor", w.clamp(this._crossFadeParams.crossFadeFactor, 0, 1)); A.setUniform1f("radius", this._parallaxParams.radius); A.setUniform3fv("cameraPosition", z.eye)
          }; return k
        }(); const m = n.fromValues(0, 0, 1), e = p.create(), g = n.create(), x = n.create(); a.CloudsComposition = v; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/axisAngle": function () {
      define("exports ../../chunks/quat ../../chunks/quatf64 ../../chunks/vec3 ./vector ./vectorStacks".split(" "),
        function (a, w, c, q, u, y) {
          function n(f = h) { return [f[0], f[1], f[2], f[3]] } function p(f, t, v, m, e = n()) { e[0] = f; e[1] = t; e[2] = v; e[3] = m; return e } function l(f, t) { f[3] = t; return f } const h = [0, 0, 1, 0], b = c.create(), d = c.create(); a.UP = h; a.angle = function (f) { return f[3] }; a.axis = function (f) { return f }; a.compose = function (f, t, v = n()) { w.setAxisAngle(b, f, f[3]); w.setAxisAngle(d, t, t[3]); w.multiply(b, d, b); return l(v, w.getAxisAngle(v, b)) }; a.copy = function (f, t = n()) { return p(f[0], f[1], f[2], f[3], t) }; a.create = n; a.fromAxisAndAngle = function (f,
            t, v = n()) { q.copy(v, f); v[3] = t; return v }; a.fromPoints = function (f, t, v = n()) { q.cross(v, f, t); q.normalize(v, v); v[3] = u.angle(f, t); return v }; a.fromValues = p; a.setAngle = l; a.wrap = function (f, t, v, m) { return p(f, t, v, m, y.sv4d.get()) }; a.wrapAxisAngle = function (f, t) { return p(f[0], f[1], f[2], t, y.sv4d.get()) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/quat": function () {
      define("exports ./mat3f64 ./quatf64 ./vec3f64 ./common ./vec3 ./vec4".split(" "), function (a, w, c, q, u, y, n) {
        function p(T) {
        T[0] = 0; T[1] = 0;
          T[2] = 0; T[3] = 1; return T
        } function l(T, da, Y) { Y *= .5; const fa = Math.sin(Y); T[0] = fa * da[0]; T[1] = fa * da[1]; T[2] = fa * da[2]; T[3] = Math.cos(Y); return T } function h(T, da) { const Y = 2 * Math.acos(da[3]), fa = Math.sin(Y / 2); fa > u.EPSILON ? (T[0] = da[0] / fa, T[1] = da[1] / fa, T[2] = da[2] / fa) : (T[0] = 1, T[1] = 0, T[2] = 0); return Y } function b(T, da, Y) { const fa = da[0], ha = da[1], ka = da[2]; da = da[3]; const ea = Y[0], ba = Y[1], aa = Y[2]; Y = Y[3]; T[0] = fa * Y + da * ea + ha * aa - ka * ba; T[1] = ha * Y + da * ba + ka * ea - fa * aa; T[2] = ka * Y + da * aa + fa * ba - ha * ea; T[3] = da * Y - fa * ea - ha * ba - ka * aa; return T }
        function d(T, da, Y) { Y *= .5; const fa = da[0], ha = da[1], ka = da[2]; da = da[3]; const ea = Math.sin(Y); Y = Math.cos(Y); T[0] = fa * Y + da * ea; T[1] = ha * Y + ka * ea; T[2] = ka * Y - ha * ea; T[3] = da * Y - fa * ea; return T } function f(T, da, Y) { Y *= .5; const fa = da[0], ha = da[1], ka = da[2]; da = da[3]; const ea = Math.sin(Y); Y = Math.cos(Y); T[0] = fa * Y - ka * ea; T[1] = ha * Y + da * ea; T[2] = ka * Y + fa * ea; T[3] = da * Y - ha * ea; return T } function t(T, da, Y) {
          Y *= .5; const fa = da[0], ha = da[1], ka = da[2]; da = da[3]; const ea = Math.sin(Y); Y = Math.cos(Y); T[0] = fa * Y + ha * ea; T[1] = ha * Y - fa * ea; T[2] = ka * Y + da * ea; T[3] =
            da * Y - ka * ea; return T
        } function v(T, da) { const Y = da[0], fa = da[1]; da = da[2]; T[0] = Y; T[1] = fa; T[2] = da; T[3] = Math.sqrt(Math.abs(1 - Y * Y - fa * fa - da * da)); return T } function m(T, da, Y, fa) { const ha = da[0], ka = da[1], ea = da[2]; da = da[3]; let ba = Y[0], aa = Y[1], W = Y[2]; Y = Y[3]; let U; let X; var Z = ha * ba + ka * aa + ea * W + da * Y; 0 > Z && (Z = -Z, ba = -ba, aa = -aa, W = -W, Y = -Y); 1 - Z > u.EPSILON ? (U = Math.acos(Z), X = Math.sin(U), Z = Math.sin((1 - fa) * U) / X, fa = Math.sin(fa * U) / X) : Z = 1 - fa; T[0] = Z * ha + fa * ba; T[1] = Z * ka + fa * aa; T[2] = Z * ea + fa * W; T[3] = Z * da + fa * Y; return T } function e(T) {
          var da =
            u.RANDOM(); const Y = u.RANDOM(), fa = u.RANDOM(), ha = Math.sqrt(1 - da); da = Math.sqrt(da); T[0] = ha * Math.sin(2 * Math.PI * Y); T[1] = ha * Math.cos(2 * Math.PI * Y); T[2] = da * Math.sin(2 * Math.PI * fa); T[3] = da * Math.cos(2 * Math.PI * fa); return T
        } function g(T, da) { const Y = da[0], fa = da[1], ha = da[2]; da = da[3]; var ka = Y * Y + fa * fa + ha * ha + da * da; ka = ka ? 1 / ka : 0; T[0] = -Y * ka; T[1] = -fa * ka; T[2] = -ha * ka; T[3] = da * ka; return T } function x(T, da) { T[0] = -da[0]; T[1] = -da[1]; T[2] = -da[2]; T[3] = da[3]; return T } function k(T, da) {
          var Y = da[0] + da[4] + da[8]; if (0 < Y) Y = Math.sqrt(Y +
            1), T[3] = .5 * Y, Y = .5 / Y, T[0] = (da[5] - da[7]) * Y, T[1] = (da[6] - da[2]) * Y, T[2] = (da[1] - da[3]) * Y; else { let fa = 0; da[4] > da[0] && (fa = 1); da[8] > da[3 * fa + fa] && (fa = 2); const ha = (fa + 1) % 3, ka = (fa + 2) % 3; Y = Math.sqrt(da[3 * fa + fa] - da[3 * ha + ha] - da[3 * ka + ka] + 1); T[fa] = .5 * Y; Y = .5 / Y; T[3] = (da[3 * ha + ka] - da[3 * ka + ha]) * Y; T[ha] = (da[3 * ha + fa] + da[3 * fa + ha]) * Y; T[ka] = (da[3 * ka + fa] + da[3 * fa + ka]) * Y } return T
        } function r(T, da, Y, fa) {
          var ha = .5 * Math.PI / 180; da *= ha; Y *= ha; fa *= ha; ha = Math.sin(da); da = Math.cos(da); const ka = Math.sin(Y); Y = Math.cos(Y); const ea = Math.sin(fa);
          fa = Math.cos(fa); T[0] = ha * Y * fa - da * ka * ea; T[1] = da * ka * fa + ha * Y * ea; T[2] = da * Y * ea - ha * ka * fa; T[3] = da * Y * fa + ha * ka * ea; return T
        } function A(T) { return "quat(" + T[0] + ", " + T[1] + ", " + T[2] + ", " + T[3] + ")" } function z(T, da, Y) { const fa = y.dot(da, Y); if (-.999999 > fa) return y.cross(G, I, da), 1E-6 > y.len(G) && y.cross(G, O, da), y.normalize(G, G), l(T, G, Math.PI), T; if (.999999 < fa) return T[0] = 0, T[1] = 0, T[2] = 0, T[3] = 1, T; y.cross(G, da, Y); T[0] = G[0]; T[1] = G[1]; T[2] = G[2]; T[3] = 1 + fa; return L(T, T) } function B(T, da, Y, fa, ha, ka) {
          m(R, da, ha, ka); m(S, Y, fa, ka); m(T,
            R, S, 2 * ka * (1 - ka)); return T
        } function C(T, da, Y, fa) { const ha = Q; ha[0] = Y[0]; ha[3] = Y[1]; ha[6] = Y[2]; ha[1] = fa[0]; ha[4] = fa[1]; ha[7] = fa[2]; ha[2] = -da[0]; ha[5] = -da[1]; ha[8] = -da[2]; return L(T, k(T, ha)) } const D = n.copy, E = n.set, H = n.add, J = n.scale, M = n.dot, F = n.lerp, K = n.length, P = n.squaredLength, L = n.normalize, N = n.exactEquals; n = n.equals; const G = q.create(), I = q.fromValues(1, 0, 0), O = q.fromValues(0, 1, 0), R = c.create(), S = c.create(), Q = w.create(); w = Object.freeze({
          __proto__: null, identity: p, setAxisAngle: l, getAxisAngle: h, multiply: b,
          rotateX: d, rotateY: f, rotateZ: t, calculateW: v, slerp: m, random: e, invert: g, conjugate: x, fromMat3: k, fromEuler: r, str: A, copy: D, set: E, add: H, mul: b, scale: J, dot: M, lerp: F, length: K, len: K, squaredLength: P, sqrLen: P, normalize: L, exactEquals: N, equals: n, rotationTo: z, sqlerp: B, setAxes: C
        }); a.add = H; a.calculateW = v; a.conjugate = x; a.copy = D; a.dot = M; a.equals = n; a.exactEquals = N; a.fromEuler = r; a.fromMat3 = k; a.getAxisAngle = h; a.identity = p; a.invert = g; a.len = K; a.length = K; a.lerp = F; a.mul = b; a.multiply = b; a.normalize = L; a.quat = w; a.random = e; a.rotateX =
          d; a.rotateY = f; a.rotateZ = t; a.rotationTo = z; a.scale = J; a.set = E; a.setAxes = C; a.setAxisAngle = l; a.slerp = m; a.sqlerp = B; a.sqrLen = P; a.squaredLength = P; a.str = A
      })
    }, "esri/views/3d/environment/CloudsCompositionTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/CloudsComposition.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          y = function (h) { function b() { return h.apply(this, arguments) || this } c._inheritsLoose(b, h); var d = b.prototype; d.initializeProgram = function (f) { const t = b.shader.get().build(); return new p.Program(f.rctx, t, n.Default3D) }; d.initializePipeline = function () { return l.makePipelineState({ blending: l.simpleBlendingParams(1, 770), depthTest: { func: 515 }, colorWrite: l.defaultColorWriteParams }) }; return b }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(q.CloudsCompositionShader, () => new Promise((h,
            b) => a(["./CloudsComposition.glsl"], h, b))); w.CloudsCompositionTechnique = y; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/CloudsComposition.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateMainLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p) {
          function l() {
            const b = new p.ShaderBuilder; b.attributes.add("position", "vec2"); b.varyings.add("worldRay", "vec3"); b.vertex.uniforms.add("inverseProjectionMatrix", "mat4"); b.vertex.uniforms.add("inverseViewMatrix", "mat4"); b.vertex.code.add(n.glsl`void main(void) {
vec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1.0, 1.0)).xyz;
worldRay = (inverseViewMatrix * vec4(posViewNear, 0.0)).xyz;
gl_Position = vec4(position, 1.0, 1.0);
}`); b.fragment.uniforms.add("lightingMainDirection", "vec3").add("cubeMap", "samplerCube"); b.fragment.include(u.ColorConversion); b.fragment.include(y.RgbaFloatEncoding); b.include(c.EvaluateMainLighting); b.include(w.EvaluateAmbientLighting, { pbrMode: 0, lightingSphericalHarmonicsOrder: 2 }); b.include(q.CloudsParallaxShading); b.fragment.code.add(n.glsl`void main() {
vec4 cloudsColor = crossFade == 0 ? renderCloud(normalize(worldRay)) : renderCloudCrossFade(normalize(worldRay));
gl_FragColor = vec4((1.0 - totalFadeInOut) * cloudsColor.rgb, cloudsColor.a);
}`); return b
          } const h = Object.freeze({ __proto__: null, build: l }); a.CloudsCompositionShader = h; a.build = l
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.EvaluateAmbientLighting = function (c, q) {
        c = c.fragment; const u = void 0 !== q.lightingSphericalHarmonicsOrder ? q.lightingSphericalHarmonicsOrder : 2; 0 === u ? (c.uniforms.add("lightingAmbientSH0", "vec3"), c.code.add(w.glsl`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === u ? (c.uniforms.add("lightingAmbientSH_R", "vec4"), c.uniforms.add("lightingAmbientSH_G", "vec4"), c.uniforms.add("lightingAmbientSH_B", "vec4"), c.code.add(w.glsl`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === u && (c.uniforms.add("lightingAmbientSH0", "vec3"), c.uniforms.add("lightingAmbientSH_R1", "vec4"), c.uniforms.add("lightingAmbientSH_G1", "vec4"), c.uniforms.add("lightingAmbientSH_B1", "vec4"), c.uniforms.add("lightingAmbientSH_R2", "vec4"), c.uniforms.add("lightingAmbientSH_G2", "vec4"), c.uniforms.add("lightingAmbientSH_B2", "vec4"), c.code.add(w.glsl`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), 1 !== q.pbrMode && 2 !== q.pbrMode || c.code.add(w.glsl`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateMainLighting.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.EvaluateMainLighting = function (c) {
        c = c.fragment; c.uniforms.add("lightingMainDirection", "vec3"); c.uniforms.add("lightingMainIntensity", "vec3"); c.uniforms.add("lightingFixedFactor", "float"); c.code.add(w.glsl`vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {
float dotVal = clamp(dot(normal_global, lightingMainDirection), 0.0, 1.0);
dotVal = mix(dotVal, 1.0, lightingFixedFactor);
return lightingMainIntensity * ((1.0 - shadowing) * dotVal);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl": function () {
      define(["exports", "../shading/PiUtils.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.CloudsParallaxShading = function (q) {
        q.fragment.uniforms.add("anchorPosition", "vec3").add("anchorPositionCrossFade", "vec3").add("fadeInOutFactor", "float").add("cloudsHeight", "float").add("rotationMatrixClouds", "mat4").add("rotationMatrixCloudsCrossFade", "mat4").add("radiusCurvatureCorrectionFactor",
          "float").add("radius", "float").add("cameraPosition", "vec3").add("totalFadeInOut", "float").add("crossFade", "int").add("crossFadeAnchorFactor", "float").add("cloudVariables", "vec2"); q.include(w.PiUtils); q.fragment.code.add(c.glsl`vec3 intersectWithCloudLayer(vec3 dir, vec3 camPos, vec3 spherePos, float radiusReduction)
{
vec3 dirAnchor = normalize(spherePos);
vec3 sphereOriginOffset = dirAnchor * radiusReduction;
float radiusClouds = radius + cloudsHeight - radiusReduction;
float B = 2.0 * dot(camPos - sphereOriginOffset, dir);
float C = dot(camPos - sphereOriginOffset, camPos - sphereOriginOffset) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = camPos + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`); q.fragment.code.add(c.glsl`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`); q.fragment.code.add(c.glsl`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`); q.fragment.code.add(c.glsl`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
const float GAMMA_SRGB = 2.1;
const float INV_GAMMA_SRGB = 0.4761904;
vec3 calculateCloudColor(vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(lightingMainDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(lightingMainDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((lightingMainIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA_SRGB)), vec3(INV_GAMMA_SRGB));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * pow(dirDotLight, RIM_SCATTERING_FACTOR) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`); q.fragment.code.add(c.glsl`vec4 getCloudData(vec3 rayDir)
{
vec4 cloudData = textureCube(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
return mix(vec4(vec3(clamp(1.0 - cloudVariables.y, 0.6, 1.0)), 0.0), cloudData, smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(mu)));
}`); q.fragment.code.add(c.glsl`vec4 renderCloud(vec3 worldRay)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition, 0.0);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(normalize(-worldRay), cloudData), totalTransmittance);
}`); q.fragment.code.add(c.glsl`vec4 renderCloudCrossFade(vec3 worldRay)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition, 0.0);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected);
vec4 cloudColor = vec4(calculateCloudColor(normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade, 0.0);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.PiUtils = function (c) {
        c.vertex.code.add(w.glsl`const float PI = 3.141592653589793;`); c.fragment.code.add(w.glsl`const float PI = 3.141592653589793;
const float LIGHT_NORMALIZATION = 1.0 / PI;
const float INV_PI = 0.3183098861837907;
const float HALF_PI = 1.570796326794897;`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.ColorConversion = function (c) {
        c.code.add(w.glsl`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/environment/CloudsGenerator": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/has ../../../core/mathUtils ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/mat3 ../../../chunks/mat3f64 ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3f32 ../../../geometry/projectionEllipsoid ./CloudsTechnique ./NoiseTextureAtlas ../webgl-engine/lib/glUtil3D ../../support/Scheduler ../../webgl/FramebufferObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A) {
        a.CloudsGenerator = function (D) {
          function E(J) {
            J = D.call(this, J) || this; J._frameTask = null; J._techniques = []; J._techniqueConfiguration = new g.CloudsTechniqueConfiguration; J._cubeMapSize = u("esri-mobile") ? 1024 : 2048; J._viewMat3 = f.create(); J._eye = m.zeros(); J._didRenderFaces = !1; J._raymarchingStepType = 0; J._cloudRadius = 0; J._viewMatrix = v.create(); const M = C.sunny; J.coverage = y.lerp(M.coverage[1], M.coverage[0], .5); J.density = y.lerp(M.density[1], M.density[0], .5); J.absorption =
              y.lerp(M.absorption[1], M.absorption[0], .5); J.cloudSize = y.lerp(M.cloudSize[1], M.cloudSize[0], .5); J.detailSize = y.lerp(M.detailSize[1], M.detailSize[0], .5); J.smoothness = y.lerp(M.smoothness[1], M.smoothness[0], .5); J.cloudHeight = y.lerp(M.cloudHeight[1], M.cloudHeight[0], .5); J.raymarchingStepType = M.raymarchingStepType; return J
          } w._inheritsLoose(E, D); var H = E.prototype; H._getTechnique = function (J) {
            const M = this._techniques[J]; if (M) return M; this._techniqueConfiguration.steps = J; this._techniques[J] = new g.CloudsTechnique({
              rctx: this.rctx,
              viewingMode: this.view.state.viewingMode
            }, this._techniqueConfiguration); return this._techniques[J]
          }; H.initialize = function () { this._vao = k.createQuadVAO(this.rctx); this._cloudRadius = .5 * e.getReferenceEllipsoid(this.view.spatialReference).radius; this.resetRenderFlags(); this._frameTask = this.view.resourceController.scheduler.registerTask(r.TaskPriority.CLOUDS_GENERATOR, this) }; H.destroy = function () {
          this._frameTask = n.removeMaybe(this._frameTask); this._techniques.forEach(J => n.releaseMaybe(J)); this._techniques =
            null; this._frameBufferCube = n.disposeMaybe(this._frameBufferCube); this._vao = n.disposeMaybe(this._vao); this._noiseTexture = n.destroyMaybe(this._noiseTexture)
          }; H._ensureNoiseTexture = function () { n.isNone(this._noiseTexture) && (this._noiseTexture = new x.NoiseTextureAtlas(this.rctx, this.view), this._noiseTexture.render(this.rctx)); return this._noiseTexture }; H.resetRenderFlags = function () { this._didRenderFaces = !1 }; H.remap = function (J, M, F, K, P) { return K + (J - M) * (P - K) / (F - M) }; H.runTask = function (J) {
            if (0 === this.coverage ||
              n.isNone(this._vao)) this._didRenderFaces = !0; else {
                var M = this._ensureNoiseTexture().textureAtlas; if (n.isNone(M)) this._didRenderFaces = !0; else {
                  var F = this.rctx.getViewport(); this.rctx.setViewport(0, 0, this._cubeMapSize, this._cubeMapSize); this.rctx.bindFramebuffer(this.frameBufferCube, !1, 34069); var K = this._getTechnique(this._raymarchingStepType), P = K.program; this.rctx.useProgram(P); P.bindTexture(M, "cloudShapeTexture"); P.setUniform1f("cloudRadius", this._cloudRadius); P.setUniform1f("halfCubeMapSize", .5 * this._cubeMapSize);
                  P.setUniform1f("power", this._power); P.setUniform1f("sigmaE", this._sigmaE); P.setUniform1f("density", this._density); P.setUniform1f("cloudSize", this._cloudSize); P.setUniform1f("detailSize", this._detailSize); P.setUniform1f("smoothness", this._smoothness); P.setUniform1f("cloudHeight", this._cloudHeight); P.setUniform1f("coverage", this._coverage); this.rctx.bindVAO(this._vao); P.assertCompatibleVertexAttributeLocations(this._vao); K.bindPipelineState(this.rctx); for (M = 0; 5 > M; M++)t.targetTo(this._viewMatrix, this._eye,
                    z[M], B[M]), d.fromMat4(this._viewMat3, this._viewMatrix), P.setUniformMatrix3fv("viewMatrix", this._viewMat3), this.frameBufferCube.framebufferTexture2D(this.frameBufferCube.colorAttachment.glName, this.rctx.gl, 36064, 34069 + M), this.rctx.gl.drawArrays(this.rctx.gl.TRIANGLE_STRIP, 0, 4), this.rctx.gl.flush(); this.rctx.setViewport(F.x, F.y, F.width, F.height); this.requestRender(); this._didRenderFaces = !0; J.madeProgress()
                }
            }
          }; w._createClass(E, [{
            key: "coverage", get: function () { return this._coverage }, set: function (J) {
            this._coverage =
              J; this.resetRenderFlags()
            }
          }, { key: "density", set: function (J) { this._density = this.remap(J, 0, 1, 0, .3); this.resetRenderFlags() } }, { key: "cloudSize", set: function (J) { this._cloudSize = this.remap(Math.max(.01, 1 - J), 0, 1, 0, .02); this.resetRenderFlags() } }, { key: "detailSize", set: function (J) { this._detailSize = this.remap(Math.max(.01, 1 - J), 0, 1, 0, .2); this.resetRenderFlags() } }, { key: "smoothness", set: function (J) { this._smoothness = this.remap(1 - J, 0, 1, 0, .5); this.resetRenderFlags() } }, {
            key: "absorption", get: function () {
              return this._sigmaE -
                1
            }, set: function (J) { this._sigmaE = 1 + J; this._power = this.remap(J, 0, 1, 35, 120); this.resetRenderFlags() }
          }, { key: "cloudHeight", get: function () { return this._cloudHeight }, set: function (J) { this._cloudHeight = this.remap(J, 0, 1, 0, 1500); this.resetRenderFlags() } }, { key: "raymarchingStepType", set: function (J) { this._raymarchingStepType = J; this.resetRenderFlags() } }, {
            key: "frameBufferCube", get: function () {
              n.isNone(this._frameBufferCube) && (this._frameBufferCube = new A(this.rctx, { colorTarget: 2, width: this._cubeMapSize, height: this._cubeMapSize },
                { target: 34067, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9729, hasMipmap: !1, width: this._cubeMapSize, height: this._cubeMapSize })); return this._frameBufferCube
            }
          }, { key: "cubeMap", get: function () { return this._frameBufferCube } }, { key: "running", get: function () { return !this._didRenderFaces } }, {
            key: "test", get: function () {
              return {
                coverage: this._coverage, density: this.remap(this._density, 0, .3, 0, 1), absorption: this._sigmaE - 1, cloudSize: 1 - this.remap(this._cloudSize, 0, .02, 0, 1), detailSize: 1 - this.remap(this._detailSize,
                  0, .2, 0, 1), smoothness: 1 - this.remap(this._smoothness, 0, .5, 0, 1), cloudHeight: this.remap(this._cloudHeight, 0, 1500, 0, 1)
              }
            }
          }]); return E
        }(q); c.__decorate([p.property({ constructOnly: !0 })], a.CloudsGenerator.prototype, "rctx", void 0); c.__decorate([p.property({ constructOnly: !0 })], a.CloudsGenerator.prototype, "view", void 0); c.__decorate([p.property({ constructOnly: !0 })], a.CloudsGenerator.prototype, "requestRender", void 0); c.__decorate([p.property()], a.CloudsGenerator.prototype, "_frameTask", void 0); c.__decorate([p.property()],
          a.CloudsGenerator.prototype, "_didRenderFaces", void 0); c.__decorate([p.property({ readOnly: !0 })], a.CloudsGenerator.prototype, "running", null); a.CloudsGenerator = c.__decorate([b.subclass("esri.views.3d.environment.CloudsGenerator")], a.CloudsGenerator); const z = [m.fromValues(1, 0, 0), m.fromValues(-1, 0, 0), m.fromValues(0, 1, 0), m.fromValues(0, -1, 0), m.fromValues(0, 0, 1)], B = [m.fromValues(0, 1, 0), m.fromValues(0, 1, 0), m.fromValues(0, 0, -1), m.fromValues(0, 0, 1), m.fromValues(0, 1, 0)]; c = function (D, E, H, J, M, F, K, P, L = .5) {
          this.coverage =
            D; this.density = E; this.absorption = H; this.cloudSize = J; this.detailSize = M; this.smoothness = F; this.cloudHeight = K; this.raymarchingStepType = P; this.median = L
          }; const C = { sunny: new c([.1, .7], [.02, .02], [0, 0], [.86, .86], [.8, .8], [.5, .5], [.05, .05], 0), cloudy: new c([.24, .7], [.135, .2], [0, 0], [.5, .5], [.65, .7], [.3, .3], [1, 1], 2), rainy: new c([.5, .9], [.2, .5], [.3, .6], [.4, .4], [.7, .7], [.5, .5], [1, 1], 2), foggy: new c([.8, .8], [.5, .5], [0, 0], [.85, .85], [.75, .75], [.8, .8], [.3, .3], 1) }; a.cloudPresets = C; Object.defineProperty(a, "__esModule",
            { value: !0 })
        })
    }, "esri/chunks/mat3": function () {
      define(["exports", "./common"], function (a, w) {
        function c(L, N) { L[0] = N[0]; L[1] = N[1]; L[2] = N[2]; L[3] = N[4]; L[4] = N[5]; L[5] = N[6]; L[6] = N[8]; L[7] = N[9]; L[8] = N[10]; return L } function q(L, N) { L[0] = N[0]; L[1] = N[1]; L[2] = N[2]; L[3] = N[3]; L[4] = N[4]; L[5] = N[5]; L[6] = N[6]; L[7] = N[7]; L[8] = N[8]; return L } function u(L, N, G, I, O, R, S, Q, T, da) { L[0] = N; L[1] = G; L[2] = I; L[3] = O; L[4] = R; L[5] = S; L[6] = Q; L[7] = T; L[8] = da; return L } function y(L) {
        L[0] = 1; L[1] = 0; L[2] = 0; L[3] = 0; L[4] = 1; L[5] = 0; L[6] = 0; L[7] = 0; L[8] =
          1; return L
        } function n(L, N) { if (L === N) { const G = N[1], I = N[2], O = N[5]; L[1] = N[3]; L[2] = N[6]; L[3] = G; L[5] = N[7]; L[6] = I; L[7] = O } else L[0] = N[0], L[1] = N[3], L[2] = N[6], L[3] = N[1], L[4] = N[4], L[5] = N[7], L[6] = N[2], L[7] = N[5], L[8] = N[8]; return L } function p(L, N) {
          const G = N[0], I = N[1], O = N[2], R = N[3], S = N[4], Q = N[5], T = N[6], da = N[7]; N = N[8]; const Y = N * S - Q * da, fa = -N * R + Q * T, ha = da * R - S * T; let ka = G * Y + I * fa + O * ha; if (!ka) return null; ka = 1 / ka; L[0] = Y * ka; L[1] = (-N * I + O * da) * ka; L[2] = (Q * I - O * S) * ka; L[3] = fa * ka; L[4] = (N * G - O * T) * ka; L[5] = (-Q * G + O * R) * ka; L[6] = ha * ka;
          L[7] = (-da * G + I * T) * ka; L[8] = (S * G - I * R) * ka; return L
        } function l(L, N) { const G = N[0], I = N[1], O = N[2], R = N[3], S = N[4], Q = N[5], T = N[6], da = N[7]; N = N[8]; L[0] = S * N - Q * da; L[1] = O * da - I * N; L[2] = I * Q - O * S; L[3] = Q * T - R * N; L[4] = G * N - O * T; L[5] = O * R - G * Q; L[6] = R * da - S * T; L[7] = I * T - G * da; L[8] = G * S - I * R; return L } function h(L) { const N = L[3], G = L[4], I = L[5], O = L[6], R = L[7], S = L[8]; return L[0] * (S * G - I * R) + L[1] * (-S * N + I * O) + L[2] * (R * N - G * O) } function b(L, N, G) {
          const I = N[0], O = N[1], R = N[2], S = N[3], Q = N[4], T = N[5], da = N[6], Y = N[7]; N = N[8]; const fa = G[0], ha = G[1], ka = G[2], ea = G[3],
            ba = G[4], aa = G[5], W = G[6], U = G[7]; G = G[8]; L[0] = fa * I + ha * S + ka * da; L[1] = fa * O + ha * Q + ka * Y; L[2] = fa * R + ha * T + ka * N; L[3] = ea * I + ba * S + aa * da; L[4] = ea * O + ba * Q + aa * Y; L[5] = ea * R + ba * T + aa * N; L[6] = W * I + U * S + G * da; L[7] = W * O + U * Q + G * Y; L[8] = W * R + U * T + G * N; return L
        } function d(L, N, G) { const I = N[0], O = N[1], R = N[2], S = N[3], Q = N[4], T = N[5], da = N[6], Y = N[7]; N = N[8]; const fa = G[0]; G = G[1]; L[0] = I; L[1] = O; L[2] = R; L[3] = S; L[4] = Q; L[5] = T; L[6] = fa * I + G * S + da; L[7] = fa * O + G * Q + Y; L[8] = fa * R + G * T + N; return L } function f(L, N, G) {
          const I = N[0], O = N[1], R = N[2], S = N[3], Q = N[4], T = N[5], da = N[6],
          Y = N[7]; N = N[8]; const fa = Math.sin(G); G = Math.cos(G); L[0] = G * I + fa * S; L[1] = G * O + fa * Q; L[2] = G * R + fa * T; L[3] = G * S - fa * I; L[4] = G * Q - fa * O; L[5] = G * T - fa * R; L[6] = da; L[7] = Y; L[8] = N; return L
        } function t(L, N, G) { const I = G[0], O = G[1]; G = G[2]; L[0] = I * N[0]; L[1] = I * N[1]; L[2] = I * N[2]; L[3] = O * N[3]; L[4] = O * N[4]; L[5] = O * N[5]; L[6] = G * N[6]; L[7] = G * N[7]; L[8] = G * N[8]; return L } function v(L, N, G) { const I = G[0]; G = G[1]; L[0] = I * N[0]; L[1] = I * N[1]; L[2] = I * N[2]; L[3] = G * N[3]; L[4] = G * N[4]; L[5] = G * N[5]; return L } function m(L, N) {
        L[0] = 1; L[1] = 0; L[2] = 0; L[3] = 0; L[4] = 1; L[5] =
          0; L[6] = N[0]; L[7] = N[1]; L[8] = 1; return L
        } function e(L, N) { const G = Math.sin(N); N = Math.cos(N); L[0] = N; L[1] = G; L[2] = 0; L[3] = -G; L[4] = N; L[5] = 0; L[6] = 0; L[7] = 0; L[8] = 1; return L } function g(L, N) { L[0] = N[0]; L[1] = 0; L[2] = 0; L[3] = 0; L[4] = N[1]; L[5] = 0; L[6] = 0; L[7] = 0; L[8] = 1; return L } function x(L, N) { L[0] = N[0]; L[1] = N[1]; L[2] = 0; L[3] = N[2]; L[4] = N[3]; L[5] = 0; L[6] = N[4]; L[7] = N[5]; L[8] = 1; return L } function k(L, N) {
          var G = N[0], I = N[1], O = N[2]; N = N[3]; var R = G + G, S = I + I; const Q = O + O; G *= R; const T = I * R; I *= S; const da = O * R, Y = O * S; O *= Q; R *= N; S *= N; N *= Q; L[0] =
            1 - I - O; L[3] = T - N; L[6] = da + S; L[1] = T + N; L[4] = 1 - G - O; L[7] = Y - R; L[2] = da - S; L[5] = Y + R; L[8] = 1 - G - I; return L
        } function r(L, N) { const G = N[0], I = N[1], O = N[2], R = N[4], S = N[5], Q = N[6], T = N[8], da = N[9]; N = N[10]; const Y = N * S - Q * da, fa = -N * R + Q * T, ha = da * R - S * T; var ka = G * Y + I * fa + O * ha; if (!ka) return null; ka = 1 / ka; L[0] = Y * ka; L[1] = (-N * I + O * da) * ka; L[2] = (Q * I - O * S) * ka; L[3] = fa * ka; L[4] = (N * G - O * T) * ka; L[5] = (-Q * G + O * R) * ka; L[6] = ha * ka; L[7] = (-da * G + I * T) * ka; L[8] = (S * G - I * R) * ka; return L } function A(L, N) {
          const G = N[0], I = N[1], O = N[2], R = N[3], S = N[4], Q = N[5], T = N[6], da = N[7];
          var Y = N[8], fa = N[9], ha = N[10], ka = N[11]; const ea = N[12], ba = N[13], aa = N[14]; N = N[15]; const W = G * Q - I * S, U = G * T - O * S, X = G * da - R * S, Z = I * T - O * Q, ia = I * da - R * Q, la = O * da - R * T, ma = Y * ba - fa * ea, ra = Y * aa - ha * ea; Y = Y * N - ka * ea; const Aa = fa * aa - ha * ba; fa = fa * N - ka * ba; ha = ha * N - ka * aa; ka = W * ha - U * fa + X * Aa + Z * Y - ia * ra + la * ma; if (!ka) return null; ka = 1 / ka; L[0] = (Q * ha - T * fa + da * Aa) * ka; L[1] = (T * Y - S * ha - da * ra) * ka; L[2] = (S * fa - Q * Y + da * ma) * ka; L[3] = (O * fa - I * ha - R * Aa) * ka; L[4] = (G * ha - O * Y + R * ra) * ka; L[5] = (I * Y - G * fa - R * ma) * ka; L[6] = (ba * la - aa * ia + N * Z) * ka; L[7] = (aa * X - ea * la - N * U) * ka; L[8] =
            (ea * ia - ba * X + N * W) * ka; return L
        } function z(L, N, G) { L[0] = 2 / N; L[1] = 0; L[2] = 0; L[3] = 0; L[4] = -2 / G; L[5] = 0; L[6] = -1; L[7] = 1; L[8] = 1; return L } function B(L) { return "mat3(" + L[0] + ", " + L[1] + ", " + L[2] + ", " + L[3] + ", " + L[4] + ", " + L[5] + ", " + L[6] + ", " + L[7] + ", " + L[8] + ")" } function C(L) { return Math.sqrt(L[0] ** 2 + L[1] ** 2 + L[2] ** 2 + L[3] ** 2 + L[4] ** 2 + L[5] ** 2 + L[6] ** 2 + L[7] ** 2 + L[8] ** 2) } function D(L, N, G) { L[0] = N[0] + G[0]; L[1] = N[1] + G[1]; L[2] = N[2] + G[2]; L[3] = N[3] + G[3]; L[4] = N[4] + G[4]; L[5] = N[5] + G[5]; L[6] = N[6] + G[6]; L[7] = N[7] + G[7]; L[8] = N[8] + G[8]; return L }
        function E(L, N, G) { L[0] = N[0] - G[0]; L[1] = N[1] - G[1]; L[2] = N[2] - G[2]; L[3] = N[3] - G[3]; L[4] = N[4] - G[4]; L[5] = N[5] - G[5]; L[6] = N[6] - G[6]; L[7] = N[7] - G[7]; L[8] = N[8] - G[8]; return L } function H(L, N, G) { L[0] = N[0] * G; L[1] = N[1] * G; L[2] = N[2] * G; L[3] = N[3] * G; L[4] = N[4] * G; L[5] = N[5] * G; L[6] = N[6] * G; L[7] = N[7] * G; L[8] = N[8] * G; return L } function J(L, N, G, I) { L[0] = N[0] + G[0] * I; L[1] = N[1] + G[1] * I; L[2] = N[2] + G[2] * I; L[3] = N[3] + G[3] * I; L[4] = N[4] + G[4] * I; L[5] = N[5] + G[5] * I; L[6] = N[6] + G[6] * I; L[7] = N[7] + G[7] * I; L[8] = N[8] + G[8] * I; return L } function M(L, N) {
          return L[0] ===
            N[0] && L[1] === N[1] && L[2] === N[2] && L[3] === N[3] && L[4] === N[4] && L[5] === N[5] && L[6] === N[6] && L[7] === N[7] && L[8] === N[8]
        } function F(L, N) {
          const G = L[0], I = L[1], O = L[2], R = L[3], S = L[4], Q = L[5], T = L[6], da = L[7]; L = L[8]; const Y = N[0], fa = N[1], ha = N[2], ka = N[3], ea = N[4], ba = N[5], aa = N[6], W = N[7]; N = N[8]; return Math.abs(G - Y) <= w.EPSILON * Math.max(1, Math.abs(G), Math.abs(Y)) && Math.abs(I - fa) <= w.EPSILON * Math.max(1, Math.abs(I), Math.abs(fa)) && Math.abs(O - ha) <= w.EPSILON * Math.max(1, Math.abs(O), Math.abs(ha)) && Math.abs(R - ka) <= w.EPSILON * Math.max(1,
            Math.abs(R), Math.abs(ka)) && Math.abs(S - ea) <= w.EPSILON * Math.max(1, Math.abs(S), Math.abs(ea)) && Math.abs(Q - ba) <= w.EPSILON * Math.max(1, Math.abs(Q), Math.abs(ba)) && Math.abs(T - aa) <= w.EPSILON * Math.max(1, Math.abs(T), Math.abs(aa)) && Math.abs(da - W) <= w.EPSILON * Math.max(1, Math.abs(da), Math.abs(W)) && Math.abs(L - N) <= w.EPSILON * Math.max(1, Math.abs(L), Math.abs(N))
        } function K(L) {
          const N = w.EPSILON, G = L[0], I = L[1], O = L[2], R = L[3], S = L[4], Q = L[5], T = L[6], da = L[7]; L = L[8]; return Math.abs(1 - (G * G + R * R + T * T)) <= N && Math.abs(1 - (I * I + S * S + da * da)) <=
            N && Math.abs(1 - (O * O + Q * Q + L * L)) <= N
        } const P = Object.freeze({ __proto__: null, fromMat4: c, copy: q, set: u, identity: y, transpose: n, invert: p, adjoint: l, determinant: h, multiply: b, translate: d, rotate: f, scale: t, scaleByVec2: v, fromTranslation: m, fromRotation: e, fromScaling: g, fromMat2d: x, fromQuat: k, normalFromMat4Legacy: r, normalFromMat4: A, projection: z, str: B, frob: C, add: D, subtract: E, multiplyScalar: H, multiplyScalarAndAdd: J, exactEquals: M, equals: F, isOrthoNormal: K, mul: b, sub: E }); a.add = D; a.adjoint = l; a.copy = q; a.determinant = h; a.equals =
          F; a.exactEquals = M; a.frob = C; a.fromMat2d = x; a.fromMat4 = c; a.fromQuat = k; a.fromRotation = e; a.fromScaling = g; a.fromTranslation = m; a.identity = y; a.invert = p; a.isOrthoNormal = K; a.mat3 = P; a.mul = b; a.multiply = b; a.multiplyScalar = H; a.multiplyScalarAndAdd = J; a.normalFromMat4 = A; a.normalFromMat4Legacy = r; a.projection = z; a.rotate = f; a.scale = t; a.scaleByVec2 = v; a.set = u; a.str = B; a.sub = E; a.subtract = E; a.translate = d; a.transpose = n
      })
    }, "esri/chunks/vec3f32": function () {
      define(["exports"], function (a) {
        function w() { return new Float32Array(3) }
        function c(e) { const g = new Float32Array(3); g[0] = e[0]; g[1] = e[1]; g[2] = e[2]; return g } function q(e, g, x) { const k = new Float32Array(3); k[0] = e; k[1] = g; k[2] = x; return k } function u(e, g) { return new Float32Array(e, g, 3) } function y() { return w() } function n() { return q(1, 1, 1) } function p() { return q(1, 0, 0) } function l() { return q(0, 1, 0) } function h() { return q(0, 0, 1) } const b = w(), d = n(), f = p(), t = l(), v = h(), m = Object.freeze({
          __proto__: null, create: w, clone: c, fromValues: q, createView: u, zeros: y, ones: n, unitX: p, unitY: l, unitZ: h, ZEROS: b,
          ONES: d, UNIT_X: f, UNIT_Y: t, UNIT_Z: v
        }); a.ONES = d; a.UNIT_X = f; a.UNIT_Y = t; a.UNIT_Z = v; a.ZEROS = b; a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.ones = n; a.unitX = p; a.unitY = l; a.unitZ = h; a.vec3f32 = m; a.zeros = y
      })
    }, "esri/views/3d/environment/CloudsTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../chunks/Clouds.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          n = function (d) { function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build({ steps: this.configuration.steps }); return new h.Program(v.rctx, m, l.Default3D) }; t.initializePipeline = function () { return b.makePipelineState({ blending: b.separateBlendingParams(1, 1, 0, 0), depthTest: { func: 515 }, colorWrite: b.defaultColorWriteParams }) }; return f }(n.ShaderTechnique); n.shader = new y.ReloadableShaderModule(u.CloudsShader,
            () => new Promise((d, f) => a(["./Clouds.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.steps = 0; return t } c._inheritsLoose(f, d); return f }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter({ count: 3 })], u.prototype, "steps", void 0); w.CloudsTechnique = n; w.CloudsTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/Clouds.glsl": function () {
      define(["exports", "../views/3d/environment/NoiseTextureAtlas", "../views/3d/webgl-engine/core/shaderModules/interfaces",
        "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c, q) {
          function u(n) {
            const p = new q.ShaderBuilder; p.attributes.add("position", "vec3"); p.fragment.uniforms.add("cloudRadius", "float").add("halfCubeMapSize", "float").add("power", "float").add("sigmaE", "float").add("density", "float").add("cloudSize", "float").add("detailSize", "float").add("smoothness", "float").add("cloudHeight", "float").add("coverage", "float").add("viewMatrix", "mat3").add("cloudShapeTexture", "sampler2D"); p.vertex.code.add(c.glsl`void main(void) {
gl_Position = vec4(position, 1.0);
}`); p.fragment.code.add(c.glsl`
    const int STEPS = ${0 === n.steps ? c.glsl`16` : 1 === n.steps ? c.glsl`100` : c.glsl`200`};
    const int STEPS_LIGHT = 6;
    const float stepL = 300.0 / float(STEPS_LIGHT);

    const float cloudStart = 1500.0;

    vec3 rayDirection(vec2 fragCoord) {
      vec2 xy = fragCoord - halfCubeMapSize;
      return normalize(vec3(-xy, -halfCubeMapSize));
    }

    float remap(float x, float low1, float high1, float low2, float high2) {
      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);
    }

    float saturate(float x) {
      return clamp(x, 0.0, 1.0);
    }`); p.fragment.code.add(`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = float(${w.ATLAS_SIZE});\n      const float dataWidth = float(${w.ATLAS_SIZE});\n      const float tileRows = float(${w.TILE_ROWS});\n      const vec3 atlasDimensions = vec3(float(${w.TILE_SIZE}), float(${w.TILE_SIZE}), tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture2D(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }`);
            p.fragment.code.add("\n    float clouds(vec3 p) {\n      float cloudVariations \x3d getCloudShape(0.002 * p, 0.5);\n\n      float cloud \x3d saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\n      cloud +\x3d (cloudVariations * 0.6 - 0.3) * ( -4.0 * (coverage * coverage - coverage));\n      float heightFraction \x3d saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\n\n      //Round the bottom and top of the clouds\n      cloud *\x3d saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * saturate(remap(heightFraction, 0.75, 1.0, 1.0, 0.0));\n\n      float shape \x3d getCloudShape(cloudSize * p, 0.0);\n      shape *\x3d mix(0.0, 1.0, min(2.0 * (1.0 - coverage), 1.0));\n      cloud \x3d saturate(remap(cloud, shape, 1.0, 0.0, 1.0));\n\n      if (cloud \x3c\x3d 0.0) {\n        return 0.0;\n      }\n\n      return density * saturate(remap(cloud, smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n    }");
            p.fragment.code.add("\n    vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\n      float a \x3d dot(dir, dir);\n      float b \x3d 2.0 * dot(dir, start);\n      float c \x3d dot(start, start) - (radius * radius);\n      float d \x3d (b * b) - 4.0 * a * c;\n\n      if (d \x3c 0.0) {\n        return vec2(1e5, -1e5);\n      }\n\n      return vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n    }\n\n    float HenyeyGreenstein(float g, float costh) {\n      return (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n    }\n    ");
            p.fragment.code.add("\n    vec3 multipleOctaves(float extinction, float mu, float stepL) {\n      float attenuation \x3d 1.0;\n      float contribution \x3d 1.0;\n      float phaseAttenuation \x3d 1.0;\n      vec3 luminance \x3d vec3(0);\n\n      for (int i \x3d 0; i \x3c 4; i++) {\n        float phase \x3d mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\n        luminance +\x3d contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\n        attenuation *\x3d 0.2;\n        contribution *\x3d 0.6;\n        phaseAttenuation *\x3d 0.5;\n      }\n\n      return luminance;\n    }");
            p.fragment.code.add("\n    vec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\n      float lightRayDensity \x3d clouds(p);\n      lightRayDensity +\x3d clouds(p + sunDirection * 1.0 * stepL);\n      lightRayDensity +\x3d clouds(p + sunDirection * 2.0 * stepL);\n      lightRayDensity +\x3d clouds(p + sunDirection * 3.0 * stepL);\n      lightRayDensity +\x3d clouds(p + sunDirection * 4.0 * stepL);\n      lightRayDensity +\x3d clouds(p + sunDirection * 5.0 * stepL);\n\n      vec3 beersLaw \x3d multipleOctaves(lightRayDensity, mu, stepL);\n\n      return mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n    }");
            p.fragment.code.add('\n    vec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\n\n      // This is never true but having the if statement stops later loop unrolling, texture prefetching and WebGL context crashes\n      if (dir.z \x3c 0.0) {\n        return vec3(0);\n      }\n\n      //Variable to track transmittance along view ray. Assume clear sky and attenuate light when encountering clouds.\n      totalTransmittance \x3d 1.0;\n\n      float stepS \x3d totalDistance / float(STEPS);\n      float cameraHeight \x3d length(org);\n\n      //Alignment of view and light directions.\n      float mu \x3d 0.5 + 0.5 * dot(sunDirection, dir);\n      float phaseFunction \x3d mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n\n      vec3 p \x3d org + distToStart  * dir;\n      float dist \x3d distToStart;\n      vec3 color \x3d vec3(0.0);\n\n      for (int i \x3d 0; i \x3c STEPS; i++) {\n\n        float sampleDensity \x3d clouds(p);\n        float sampleSigmaE \x3d sampleDensity * sigmaE;\n\n        if (sampleDensity \x3e 0.0 ) {\n          float ambient \x3d mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\n\n          vec3 luminance \x3d sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\n          float transmittance \x3d exp(-sampleSigmaE * stepS);\n\n          //Better energy conserving integration\n          //"From Physically based sky, atmosphere and cloud rendering in Frostbite" 5.6\n          color +\x3d totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\n\n          totalTransmittance *\x3d transmittance;\n\n          //If ray combined transmittance is close to 0, nothing beyond this sample point is visible, so break early.\n          if (totalTransmittance \x3c\x3d 0.001) {\n            totalTransmittance \x3d 0.0;\n            break;\n          }\n\n        }\n\n        dist +\x3d stepS;\n        p \x3d org + dir * dist;\n      }\n\n      return color;\n    }');
            p.fragment.code.add("\n    void main() {\n      vec3 rayDir \x3d rayDirection(gl_FragCoord.xy);\n      rayDir \x3d normalize(viewMatrix * rayDir);\n\n      vec3 viewPos \x3d vec3(0, 0, cloudRadius + 1.0);\n\n      bool hitsPlanet \x3d rayDir.z \x3c 0.0;\n\n      if (hitsPlanet) {\n        gl_FragColor \x3d vec4(vec3(0), 1);\n        return;\n      }\n\n      vec2 rayStartIntersect \x3d sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\n      vec2 rayEndIntersect \x3d sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\n      float distToStart \x3d rayStartIntersect.y;\n      float totalDistance \x3d rayEndIntersect.y - distToStart;\n\n      float totalTransmittance \x3d 1.0;\n      vec3 sunDirection \x3d normalize(vec3(0, 0, 1));\n      vec3 col \x3d 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance).rgb;\n\n      gl_FragColor \x3d vec4(col, totalTransmittance);\n    }\n  ");
            return p
          } const y = Object.freeze({ __proto__: null, build: u }); a.CloudsShader = y; a.build = u
        })
    }, "esri/views/3d/environment/NoiseTextureAtlas": function () {
      define("exports ../../../core/has ../../../core/maybe ../../webgl/BufferObject ../../webgl/FramebufferObject ../../../chunks/_rollupPluginBabelHelpers ../../webgl/checkWebGLError ../../webgl/enums ../../../chunks/builtins ../../webgl/Texture ../../webgl/VertexArrayObject ./NoiseTextureAtlasTechnique ../webgl-engine/lib/glUtil3D".split(" "), function (a, w, c,
        q, u, y, n, p, l, h, b, d, f) {
          const t = w("esri-mobile") ? 64 : 128, v = Math.ceil(Math.sqrt(t)), m = (t + 2) * v; w = function () {
            function e(x, k) { this._shapeTextureDescriptor = { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9729, hasMipmap: !1, width: 1, height: 1 }; this._frameBuffer = new u(x, { colorTarget: 0 }); this._vao = f.createQuadVAO(x); this.textureAtlas = new h(x, this._shapeTextureDescriptor, null); this._technique = new d.NoiseTextureAtlasTechnique({ rctx: x, viewingMode: k.state.viewingMode }, null) } var g = e.prototype;
            g.destroy = function () { this._technique = c.releaseMaybe(this._technique); this._frameBuffer = c.disposeMaybe(this._frameBuffer); this._vao = c.disposeMaybe(this._vao); this.textureAtlas = c.disposeMaybe(this.textureAtlas) }; g.render = function (x) {
              if (c.isNone(this._vao) || c.isNone(this.textureAtlas)) return !1; this._frameBuffer.resize(m, m); this.textureAtlas.resize(m, m); this._frameBuffer.attachColorTexture(this.textureAtlas); x.bindFramebuffer(this._frameBuffer); var k = this._technique.program; x.bindVAO(this._vao); k.assertCompatibleVertexAttributeLocations(this._vao);
              this._technique.bindPipelineState(x); x.useProgram(k); k.setUniform1f("tileSize", t); k.setUniform1f("tileRows", v); k = x.getViewport(); x.setViewport(0, 0, m, m); x.gl.drawArrays(x.gl.TRIANGLE_STRIP, 0, 4); this._frameBuffer.detachColorTexture(); x.setViewport(k.x, k.y, k.width, k.height); return !0
            }; return e
          }(); a.ATLAS_SIZE = m; a.NoiseTextureAtlas = w; a.TILE_ROWS = v; a.TILE_SIZE = t; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/FramebufferObject": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../core/Logger ../../core/maybe ./checkWebGLError ./enums ./Renderbuffer ./Texture ./Util".split(" "),
        function (a, w, c, q, u, y, n, p) {
          function l(d) { return "type" in d && "texture" === d.type } function h(d, f) { void 0 !== f.width && 0 <= f.width && void 0 !== f.height && 0 <= f.height ? f.width === d.width && f.height === d.height || console.error("Renderbuffer dimensions must match the framebuffer's!") : (f.width = d.width, f.height = d.height) } const b = w.getLogger("esri.views.webgl.FrameBufferObject"); w = function () {
            function d(t, v, m = null, e = null) {
            this._context = t; this._stencilAttachment = this._depthAttachment = this._glName = null; this._colorAttachments =
              new Map; this._initialized = !1; this._desc = { ...v }; t.instanceCounter.increment(u.ResourceType.Framebuffer, this); if (c.isSome(m)) for (Array.isArray(m) || (m = [m]), v = 0; v < m.length; ++v) {
                var g, x; const r = m[v]; let A; l(r) ? (A = r.descriptor, this._colorAttachments.set(36064 + v, r)) : (A = r, this._colorAttachments.set(36064 + v, new n(t, r))); 0 !== (null == (g = this._desc) ? void 0 : g.colorTarget) && 2 !== (null == (x = this._desc) ? void 0 : x.colorTarget) && console.error("Framebuffer is initialized with a texture however the descriptor indicates using a renderbuffer color attachment!");
                this._validateColorAttachmentPoint(36064 + v); this._validateTextureDimensions(A, this._desc)
              } if (e instanceof y) { var k; t = null != (k = this._desc.depthStencilTarget) ? k : 3; 2 === t ? this._stencilAttachment = e : 1 === t || 3 === t ? this._depthAttachment = e : console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'); h(e.descriptor, this._desc) } else if (c.isSome(e)) {
                this._context.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");
                let r; l(e) ? (this._depthStencilTexture = e, r = e.descriptor) : this._depthStencilTexture = new n(this._context, e); this._validateTextureDimensions(r, this._desc)
              }
            } var f = d.prototype; f.dispose = function () {
              if (this._desc) {
                var t = this._context.getBoundFramebufferObject(); this._disposeColorAttachments(); this._disposeDepthStencilAttachments(); this._glName && (this._context.gl.deleteFramebuffer(this._glName), this._glName = null); this._context.bindFramebuffer(t); this._context.instanceCounter.decrement(u.ResourceType.Framebuffer,
                  this); this._desc = null
              }
            }; f.getColorTexture = function (t) { return (t = this._colorAttachments.get(t)) && l(t) ? t : null }; f.framebufferTexture2D = function (t, v, m = 36064, e = 3553, g = 0) { v.framebufferTexture2D(v.FRAMEBUFFER, m, e, t, g) }; f.attachColorTexture = function (t, v = 36064) {
              t && (this._validateColorAttachmentPoint(v), this._validateTextureDimensions(t.descriptor, this._desc), this._disposeColorAttachments(), this._initialized && (this._context.bindFramebuffer(this), this.framebufferTexture2D(t.glName, this._context.gl, v)), this._colorAttachments.set(v,
                t))
            }; f.detachColorTexture = function (t = 36064) { const v = this._colorAttachments.get(t); if (l(v)) return this._initialized && (this._context.bindFramebuffer(this), this.framebufferTexture2D(null, this._context.gl, t)), this._colorAttachments.delete(t), v }; f.attachDepthStencilTexture = function (t) {
              if (!c.isNone(t)) {
                var v = t.descriptor; 34041 !== v.pixelFormat && console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"); 34042 !== v.dataType && console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!");
                this._context.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"); this._validateTextureDimensions(v, this._desc); this._desc.depthStencilTarget && 4 !== this._desc.depthStencilTarget && (this._desc.depthStencilTarget = 4); this._disposeDepthStencilAttachments(); this._initialized && (this._context.bindFramebuffer(this), this.framebufferTexture2D(t.glName, this._context.gl, u.DepthStencilAttachment)); this._depthStencilTexture =
                  t
              }
            }; f.detachDepthStencilTexture = function () { const t = this._depthStencilTexture; t && this._initialized && (this._context.bindFramebuffer(this), this.framebufferTexture2D(null, this._context.gl, u.DepthStencilAttachment)); this._depthStencilTexture = null; return t }; f.attachDepthStencilBuffer = function (t) {
              if (!c.isNone(t)) {
                var v = t.descriptor; 34041 !== v.internalFormat && 33189 !== v.internalFormat && console.error("Depth/Stencil buffer must have correct internalFormat"); h(v, this._desc); this._disposeDepthStencilAttachments();
                this._desc.depthStencilTarget = 34041 === v.internalFormat ? 3 : 1; this._initialized && (this._context.bindFramebuffer(this), v = this._context.gl, v.framebufferRenderbuffer(v.FRAMEBUFFER, 1 === this._desc.depthStencilTarget ? v.DEPTH_ATTACHMENT : v.DEPTH_STENCIL_ATTACHMENT, v.RENDERBUFFER, t.glName)); this._depthAttachment = t
              }
            }; f.detachDepthStencilBuffer = function () {
              const t = this._context.gl, v = this._depthAttachment; v && this._initialized && (this._context.bindFramebuffer(this), t.framebufferRenderbuffer(t.FRAMEBUFFER, 1 === this._desc.depthStencilTarget ?
                t.DEPTH_ATTACHMENT : t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, null)); this._depthAttachment = null; return v
            }; f.detachAll = function () { this.detachColorTexture(); this.detachDepthStencilBuffer(); this.detachDepthStencilTexture() }; f.copyToTexture = function (t, v, m, e, g, x, k) {
            (0 > t || 0 > v || 0 > g || 0 > x) && console.error("Offsets cannot be negative!"); (0 >= m || 0 >= e) && console.error("Copy width and height must be greater than zero!"); var r = this._desc; const A = k.descriptor; 3553 !== k.descriptor.target && console.error("Texture target must be TEXTURE_2D!");
              (t + m > r.width || v + e > r.height || g + m > A.width || x + e > A.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!"); r = this._context; k = r.bindTexture(k, n.TEXTURE_UNIT_FOR_UPDATES); r.bindFramebuffer(this); r.gl.copyTexSubImage2D(3553, 0, g, x, t, v, m, e); r.bindTexture(k, n.TEXTURE_UNIT_FOR_UPDATES)
            }; f.readPixels = function (t, v, m, e, g, x, k) {
            (0 >= m || 0 >= e) && console.error("Copy width and height must be greater than zero!"); k || console.error("Target memory is not initialized!");
              this._context.bindFramebuffer(this); this._context.gl.readPixels(t, v, m, e, g, x, k)
            }; f.resize = function (t, v) {
              const m = this._desc; if (m.width !== t || m.height !== v) if (this._initialized) {
              m.width = t; m.height = v; this._colorAttachments.forEach(e => { e && e.resize(t, v) }); if (null != this._depthStencilTexture) this._depthStencilTexture.resize(t, v); else if (this._depthAttachment || this._stencilAttachment) this._depthAttachment && this._depthAttachment.resize(t, v), this._stencilAttachment && this._stencilAttachment.resize(t, v); this._context.getBoundFramebufferObject() ===
                this && this._context.bindFramebuffer(null); this._initialized = !1
              } else m.width = t, m.height = v, this._colorAttachments.forEach(e => { e && e.resize(t, v) }), this._depthStencilTexture && this._depthStencilTexture.resize(t, v)
            }; f.initializeAndBind = function (t = 3553) {
              var v, m, e, g; const x = this._context.gl; if (this._initialized) x.bindFramebuffer(x.FRAMEBUFFER, this.glName); else {
              this._glName && x.deleteFramebuffer(this._glName); var k = this._context, r = x.createFramebuffer(), A = this._desc, z = null != (v = A.colorTarget) ? v : 1; v = null != (m = A.width) ?
                m : 1; m = null != (e = A.height) ? e : 1; x.bindFramebuffer(x.FRAMEBUFFER, r); 0 === this._colorAttachments.size && (0 === z ? this._colorAttachments.set(36064, new n(k, { target: 2 === this.descriptor.colorTarget ? 34067 : 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, wrapMode: 33071, width: A.width, height: A.height })) : (e = new y(k, { internalFormat: 32854, width: v, height: m }), this._colorAttachments.set(36064, e))); this._colorAttachments.forEach((B, C) => {
                  B && (l(B) ? this.framebufferTexture2D(B.glName, x, C, t) : x.framebufferRenderbuffer(x.FRAMEBUFFER,
                    x.COLOR_ATTACHMENT0, x.RENDERBUFFER, B.glName))
                }); e = null != (g = A.depthStencilTarget) ? g : 0; switch (e) {
                  case 1: case 3: this._depthAttachment || (this._depthAttachment = new y(k, { internalFormat: 1 === A.depthStencilTarget ? 33189 : 34041, width: v, height: m })); x.framebufferRenderbuffer(x.FRAMEBUFFER, 1 === e ? x.DEPTH_ATTACHMENT : x.DEPTH_STENCIL_ATTACHMENT, x.RENDERBUFFER, this._depthAttachment.glName); break; case 2: this._stencilAttachment || (this._stencilAttachment = new y(k, { internalFormat: 36168, width: v, height: m })); x.framebufferRenderbuffer(x.FRAMEBUFFER,
                    x.STENCIL_ATTACHMENT, x.RENDERBUFFER, this._stencilAttachment.glName); break; case 4: this._depthStencilTexture || (k.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!"), this._depthStencilTexture = new n(k, { target: 3553, pixelFormat: 34041, dataType: 34042, samplingMode: 9728, wrapMode: 33071, width: v, height: m })), this.framebufferTexture2D(this._depthStencilTexture.glName, x, x.DEPTH_STENCIL_ATTACHMENT,
                      t)
                }q.webglValidateShadersEnabled() && x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!"); this._glName = r; this._initialized = !0
              }
            }; f._disposeColorAttachments = function () {
              this._colorAttachments.forEach((t, v) => {
                if (l(t)) this._initialized && (this._context.bindFramebuffer(this), this.framebufferTexture2D(null, this._context.gl, v)), t.dispose(); else if (t instanceof WebGLRenderbuffer) {
                  const m = this._context.gl; this._initialized && (this._context.bindFramebuffer(this),
                    m.framebufferRenderbuffer(m.FRAMEBUFFER, v, m.RENDERBUFFER, null)); this._context.gl.deleteRenderbuffer(t)
                }
              }); this._colorAttachments.clear()
            }; f._disposeDepthStencilAttachments = function () {
              const t = this._context.gl; this._depthAttachment && (this._initialized && (this._context.bindFramebuffer(this), t.framebufferRenderbuffer(t.FRAMEBUFFER, 1 === this._desc.depthStencilTarget ? t.DEPTH_ATTACHMENT : t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, null)), this._depthAttachment.dispose(), this._depthAttachment = null); this._stencilAttachment &&
                (this._initialized && (this._context.bindFramebuffer(this), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.STENCIL_ATTACHMENT, t.RENDERBUFFER, null)), this._stencilAttachment.dispose(), this._stencilAttachment = null); this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this.framebufferTexture2D(null, t, t.DEPTH_STENCIL_ATTACHMENT)), this._depthStencilTexture.dispose(), this._depthStencilTexture = null)
            }; f._validateTextureDimensions = function (t, v) {
            3553 !== t.target && 34067 !== t.target && console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!");
              void 0 !== v.width && 0 <= v.width && void 0 !== v.height && 0 <= v.height ? v.width === t.width && v.height === t.height || console.error("Color attachment texture must match the framebuffer's!") : (v.width = t.width, v.height = t.height)
            }; f._validateColorAttachmentPoint = function (t) {
              if (-1 === d._MAX_COLOR_ATTACHMENTS) { const v = this._context.capabilities.drawBuffers; d._MAX_COLOR_ATTACHMENTS = v ? this._context.gl.getParameter(v.MAX_COLOR_ATTACHMENTS) : 1 } t -= 36064; t + 1 > d._MAX_COLOR_ATTACHMENTS && b.error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${t +
                1}. Implementation supports up to ${d._MAX_COLOR_ATTACHMENTS} color attachments`)
            }; a._createClass(d, [{ key: "glName", get: function () { return this._glName } }, { key: "descriptor", get: function () { return this._desc } }, { key: "colorTexture", get: function () { const t = this._colorAttachments.get(36064); return t && l(t) ? t : null } }, { key: "colorAttachment", get: function () { return this._colorAttachments.get(36064) } }, { key: "depthStencilAttachment", get: function () { return this._depthStencilTexture || this._depthAttachment || this._stencilAttachment } },
            { key: "depthStencilTexture", get: function () { return this._depthStencilTexture } }, { key: "width", get: function () { return this._desc.width } }, { key: "height", get: function () { return this._desc.height } }, { key: "gpuMemoryUsage", get: function () { return p.getGpuMemoryUsage(this.colorAttachment) + p.getGpuMemoryUsage(this.depthStencilAttachment) } }]); return d
          }(); w._MAX_COLOR_ATTACHMENTS = -1; return w
        })
    }, "esri/views/webgl/Renderbuffer": function () {
      define(["../../chunks/_rollupPluginBabelHelpers", "./enums"], function (a, w) {
        return function () {
          function c(u,
            y) { this._context = u; this._desc = y; this._context.instanceCounter.increment(w.ResourceType.Renderbuffer, this); u = this._context.gl; this.glName = u.createRenderbuffer(); this._context.bindRenderbuffer(this); u.renderbufferStorage(u.RENDERBUFFER, y.internalFormat, y.width, y.height) } var q = c.prototype; q.resize = function (u, y) { const n = this._desc; if (n.width !== u || n.height !== y) n.width = u, n.height = y, u = this._context.gl, this._context.bindRenderbuffer(this), u.renderbufferStorage(u.RENDERBUFFER, n.internalFormat, n.width, n.height) };
          q.dispose = function () { this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(w.ResourceType.Renderbuffer, this), this._context = null) }; a._createClass(c, [{ key: "descriptor", get: function () { return this._desc } }]); return c
        }()
      })
    }, "esri/views/3d/environment/NoiseTextureAtlasTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/NoiseTextureAtlas.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          y = function (h) { function b() { return h.apply(this, arguments) || this } c._inheritsLoose(b, h); var d = b.prototype; d.initializeProgram = function (f) { const t = b.shader.get().build(); return new p.Program(f.rctx, t, n.Default3D) }; d.initializePipeline = function () { return l.makePipelineState({ blending: l.simpleBlendingParams(1, 0), depthTest: { func: 515 }, colorWrite: l.defaultColorWriteParams }) }; return b }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(q.NoiseTextureAtlasShader, () => new Promise((h,
            b) => a(["./NoiseTextureAtlas.glsl"], h, b))); w.NoiseTextureAtlasTechnique = y; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/NoiseTextureAtlas.glsl": function () {
      define(["exports", "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c) {
        function q() {
          const y = new c.ShaderBuilder; y.attributes.add("position", "vec3"); y.vertex.code.add(w.glsl`void main(void) {
gl_Position = vec4(position, 1.0);
}`); y.fragment.uniforms.add("tileRows", "float").add("tileSize", "float"); y.fragment.code.add("\n    #define NUM_CELLS 2.0\n    #define PERLIN_WORLEY 0\n    #define WORLEY 1\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }\n\n    vec4 taylorInvSqrt(vec4 r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    vec4 mod289(vec4 x) {\n      return x - floor( x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x) {\n      return mod289(((x * 34.0) + 1.0) * x);\n    }\n\n    vec4 fade(vec4 t) {\n      return (t * t * t) * (t * (t * vec4(6) - vec4(15)) + vec4(10));\n    }\n\n    float glmPerlin(vec4 Position, vec4 rep) {\n      vec4 Pi0 \x3d mod(floor(Position), rep);\n      vec4 Pi1 \x3d mod(Pi0 + float(1), rep);\n      vec4 Pf0 \x3d fract(Position);\n      vec4 Pf1 \x3d Pf0 - float(1);\n      vec4 ix \x3d vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n      vec4 iy \x3d vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);\n      vec4 iz0 \x3d vec4(Pi0.z);\n      vec4 iz1 \x3d vec4(Pi1.z);\n      vec4 iw0 \x3d vec4(Pi0.w);\n      vec4 iw1 \x3d vec4(Pi1.w);\n\n      vec4 ixy \x3d permute(permute(ix) + iy);\n      vec4 ixy0 \x3d permute(ixy + iz0);\n      vec4 ixy1 \x3d permute(ixy + iz1);\n      vec4 ixy00 \x3d permute(ixy0 + iw0);\n      vec4 ixy01 \x3d permute(ixy0 + iw1);\n      vec4 ixy10 \x3d permute(ixy1 + iw0);\n      vec4 ixy11 \x3d permute(ixy1 + iw1);\n\n      vec4 gx00 \x3d ixy00 / float(7);\n      vec4 gy00 \x3d floor(gx00) / float(7);\n      vec4 gz00 \x3d floor(gy00) / float(6);\n      gx00 \x3d fract(gx00) - float(0.5);\n      gy00 \x3d fract(gy00) - float(0.5);\n      gz00 \x3d fract(gz00) - float(0.5);\n      vec4 gw00 \x3d vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n      vec4 sw00 \x3d step(gw00, vec4(0));\n      gx00 -\x3d sw00 * (step(float(0), gx00) - float(0.5));\n      gy00 -\x3d sw00 * (step(float(0), gy00) - float(0.5));\n\n      vec4 gx01 \x3d ixy01 / float(7);\n      vec4 gy01 \x3d floor(gx01) / float(7);\n      vec4 gz01 \x3d floor(gy01) / float(6);\n      gx01 \x3d fract(gx01) - float(0.5);\n      gy01 \x3d fract(gy01) - float(0.5);\n      gz01 \x3d fract(gz01) - float(0.5);\n      vec4 gw01 \x3d vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n      vec4 sw01 \x3d step(gw01, vec4(0.0));\n      gx01 -\x3d sw01 * (step(float(0), gx01) - float(0.5));\n      gy01 -\x3d sw01 * (step(float(0), gy01) - float(0.5));\n\n      vec4 gx10 \x3d ixy10 / float(7);\n      vec4 gy10 \x3d floor(gx10) / float(7);\n      vec4 gz10 \x3d floor(gy10) / float(6);\n      gx10 \x3d fract(gx10) - float(0.5);\n      gy10 \x3d fract(gy10) - float(0.5);\n      gz10 \x3d fract(gz10) - float(0.5);\n      vec4 gw10 \x3d vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n      vec4 sw10 \x3d step(gw10, vec4(0.0));\n      gx10 -\x3d sw10 * (step(float(0), gx10) - float(0.5));\n      gy10 -\x3d sw10 * (step(float(0), gy10) - float(0.5));\n\n      vec4 gx11 \x3d ixy11 / float(7);\n      vec4 gy11 \x3d floor(gx11) / float(7);\n      vec4 gz11 \x3d floor(gy11) / float(6);\n      gx11 \x3d fract(gx11) - float(0.5);\n      gy11 \x3d fract(gy11) - float(0.5);\n      gz11 \x3d fract(gz11) - float(0.5);\n      vec4 gw11 \x3d vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n      vec4 sw11 \x3d step(gw11, vec4(float(0)));\n      gx11 -\x3d sw11 * (step(float(0), gx11) - float(0.5));\n      gy11 -\x3d sw11 * (step(float(0), gy11) - float(0.5));\n\n      vec4 g0000 \x3d vec4(gx00.x, gy00.x, gz00.x, gw00.x);\n      vec4 g1000 \x3d vec4(gx00.y, gy00.y, gz00.y, gw00.y);\n      vec4 g0100 \x3d vec4(gx00.z, gy00.z, gz00.z, gw00.z);\n      vec4 g1100 \x3d vec4(gx00.w, gy00.w, gz00.w, gw00.w);\n      vec4 g0010 \x3d vec4(gx10.x, gy10.x, gz10.x, gw10.x);\n      vec4 g1010 \x3d vec4(gx10.y, gy10.y, gz10.y, gw10.y);\n      vec4 g0110 \x3d vec4(gx10.z, gy10.z, gz10.z, gw10.z);\n      vec4 g1110 \x3d vec4(gx10.w, gy10.w, gz10.w, gw10.w);\n      vec4 g0001 \x3d vec4(gx01.x, gy01.x, gz01.x, gw01.x);\n      vec4 g1001 \x3d vec4(gx01.y, gy01.y, gz01.y, gw01.y);\n      vec4 g0101 \x3d vec4(gx01.z, gy01.z, gz01.z, gw01.z);\n      vec4 g1101 \x3d vec4(gx01.w, gy01.w, gz01.w, gw01.w);\n      vec4 g0011 \x3d vec4(gx11.x, gy11.x, gz11.x, gw11.x);\n      vec4 g1011 \x3d vec4(gx11.y, gy11.y, gz11.y, gw11.y);\n      vec4 g0111 \x3d vec4(gx11.z, gy11.z, gz11.z, gw11.z);\n      vec4 g1111 \x3d vec4(gx11.w, gy11.w, gz11.w, gw11.w);\n\n      vec4 norm00 \x3d taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n      g0000 *\x3d norm00.x;\n      g0100 *\x3d norm00.y;\n      g1000 *\x3d norm00.z;\n      g1100 *\x3d norm00.w;\n\n      vec4 norm01 \x3d taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n      g0001 *\x3d norm01.x;\n      g0101 *\x3d norm01.y;\n      g1001 *\x3d norm01.z;\n      g1101 *\x3d norm01.w;\n\n      vec4 norm10 \x3d taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n      g0010 *\x3d norm10.x;\n      g0110 *\x3d norm10.y;\n      g1010 *\x3d norm10.z;\n      g1110 *\x3d norm10.w;\n\n      vec4 norm11 \x3d taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n      g0011 *\x3d norm11.x;\n      g0111 *\x3d norm11.y;\n      g1011 *\x3d norm11.z;\n      g1111 *\x3d norm11.w;\n\n      float n0000 \x3d dot(g0000, Pf0);\n      float n1000 \x3d dot(g1000, vec4(Pf1.x, Pf0.y, Pf0.z, Pf0.w));\n      float n0100 \x3d dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.z, Pf0.w));\n      float n1100 \x3d dot(g1100, vec4(Pf1.x, Pf1.y, Pf0.z, Pf0.w));\n      float n0010 \x3d dot(g0010, vec4(Pf0.x, Pf0.y, Pf1.z, Pf0.w));\n      float n1010 \x3d dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n      float n0110 \x3d dot(g0110, vec4(Pf0.x, Pf1.y, Pf1.z, Pf0.w));\n      float n1110 \x3d dot(g1110, vec4(Pf1.x, Pf1.y, Pf1.z, Pf0.w));\n      float n0001 \x3d dot(g0001, vec4(Pf0.x, Pf0.y, Pf0.z, Pf1.w));\n      float n1001 \x3d dot(g1001, vec4(Pf1.x, Pf0.y, Pf0.z, Pf1.w));\n      float n0101 \x3d dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n      float n1101 \x3d dot(g1101, vec4(Pf1.x, Pf1.y, Pf0.z, Pf1.w));\n      float n0011 \x3d dot(g0011, vec4(Pf0.x, Pf0.y, Pf1.z, Pf1.w));\n      float n1011 \x3d dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.z, Pf1.w));\n      float n0111 \x3d dot(g0111, vec4(Pf0.x, Pf1.y, Pf1.z, Pf1.w));\n      float n1111 \x3d dot(g1111, Pf1);\n\n      vec4 fade_xyzw \x3d fade(Pf0);\n      vec4 n_0w \x3d mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n      vec4 n_1w \x3d mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n      vec4 n_zw \x3d mix(n_0w, n_1w, fade_xyzw.z);\n      vec2 n_yzw \x3d mix(vec2(n_zw.x, n_zw.y), vec2(n_zw.z, n_zw.w), fade_xyzw.y);\n      float n_xyzw \x3d mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n      return float(2.2) * n_xyzw;\n    }\n\n    float getPerlinNoise(vec3 pos, float frequency) {\n      const float octaveFrequencyFactor \x3d 2.0;\n\n      float sum \x3d 0.0;\n      float weightSum \x3d 0.0;\n      float weight \x3d 1.0;\n\n      for (int oct \x3d 0; oct \x3c 3; oct++) {\n        vec3 p \x3d pos * frequency;\n        float val \x3d 0.5 + 0.5 * glmPerlin(vec4(p, 0.0), vec4(frequency));\n        sum +\x3d val * weight;\n        weightSum +\x3d weight;\n        weight *\x3d 0.5;\n        frequency *\x3d octaveFrequencyFactor;\n      }\n\n      float noise \x3d (sum / weightSum);\n      noise \x3d saturate(noise);\n      return noise;\n    }\n\n    float hash(float p) {\n      p \x3d fract(p * 0.1031);\n      p *\x3d p + 33.33;\n      p *\x3d p + p;\n      return fract(p);;\n    }\n\n    float noise(vec3 x) {\n      vec3 p \x3d floor(x);\n      vec3 f \x3d fract(x);\n\n      f \x3d f * f * (3.0 - 2.0 * f);\n      float n \x3d p.x + p.y * 57.0 + 113.0 * p.z;\n\n      return mix(\n      mix(\n        mix(hash(n + 0.0), hash(n + 1.0), f.x),\n        mix(hash(n + 57.0), hash(n + 58.0), f.x),\n        f.y),\n      mix(\n        mix(hash(n + 113.0), hash(n + 114.0), f.x),\n        mix(hash(n + 170.0), hash(n + 171.0), f.x),\n        f.y),\n      f.z);\n    }\n\n    float worley(vec3 pos, float numCells) {\n      vec3 p \x3d pos * numCells;\n      float d \x3d 1.0e10;\n\n      for (int x \x3d -1; x \x3c\x3d 1; x++) {\n        for (int y \x3d -1; y \x3c\x3d 1; y++) {\n          for (int z \x3d -1; z \x3c\x3d 1; z++) {\n            vec3 tp \x3d floor(p) + vec3(x, y, z);\n            tp \x3d p - tp - noise(mod(tp, numCells));\n            d \x3d min(d, dot(tp, tp));\n          }\n        }\n      }\n\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n\n    vec3 get3Dfrom2D(vec2 uv, float tileRows) {\n      vec2 tile \x3d floor(uv);\n      float z \x3d floor(tileRows * tile.y + tile.x);\n      return vec3(fract(uv), z);\n    }\n\n    float getTextureForPoint(vec3 p, int type) {\n      if (type \x3d\x3d PERLIN_WORLEY) {\n\n        const float frequency \x3d 8.0;\n        float perlinNoise \x3d getPerlinNoise(p, frequency);\n\n        float worley0 \x3d worley(p, NUM_CELLS * 2.0);\n        float worley1 \x3d worley(p, NUM_CELLS * 8.0);\n        float worley2 \x3d worley(p, NUM_CELLS * 14.0);\n\n        float worleyFBM \x3d worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n        return remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n      }\n\n      float worley0 \x3d worley(p, NUM_CELLS);\n      float worley1 \x3d worley(p, NUM_CELLS * 2.0);\n      float worley2 \x3d worley(p, NUM_CELLS * 4.0);\n      float worley3 \x3d worley(p, NUM_CELLS * 8.0);\n\n      float FBM0 \x3d worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      float FBM1 \x3d worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n      float FBM2 \x3d worley2 * 0.75 + worley3 * 0.25;\n\n      return FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n    }\n  ");
          y.fragment.code.add("\n    void main() {\n      const float padWidth \x3d 1.0;\n      float paddedSize \x3d tileSize + 2.0 * padWidth;\n      float tileCount \x3d tileRows * tileRows;\n      vec2 tile \x3d floor((gl_FragCoord.xy - 0.5) / paddedSize);\n\n      bool padCell \x3d false;\n      if (mod(gl_FragCoord.x, paddedSize) \x3d\x3d 0.5 || mod(gl_FragCoord.x, paddedSize) \x3d\x3d paddedSize - 0.5) {\n        padCell \x3d true;\n      }\n\n      if (mod(gl_FragCoord.y, paddedSize) \x3d\x3d 0.5 || mod(gl_FragCoord.y, paddedSize) \x3d\x3d paddedSize - 0.5) {\n        padCell \x3d true;\n      }\n\n      bool startPadX \x3d false;\n      bool startPadY \x3d false;\n      bool endPadX \x3d false;\n      bool endPadY \x3d false;\n\n      if (gl_FragCoord.x \x3d\x3d tile.x * paddedSize + 0.5) {\n        startPadX \x3d true;\n      }\n\n      if (gl_FragCoord.y \x3d\x3d tile.y * paddedSize + 0.5) {\n        startPadY \x3d true;\n      }\n\n      if (gl_FragCoord.x \x3d\x3d (tile.x + 1.0) * paddedSize - 0.5) {\n        endPadX \x3d true;\n      }\n\n      if (gl_FragCoord.y \x3d\x3d (tile.y + 1.0) * paddedSize - 0.5) {\n        endPadY \x3d true;\n      }\n\n      vec2 padding \x3d vec2(2.0 * padWidth) * tile;\n      vec2 uv;\n\n      if (padCell) {\n        vec2 pixel \x3d gl_FragCoord.xy - padWidth - padding;\n\n        if (startPadX) {\n          pixel.x +\x3d tileSize;\t\n        }\n\n        if (startPadY) {\n          pixel.y +\x3d tileSize;\t\n        }\n\n        if (endPadX) {\n          pixel.x -\x3d tileSize;\t\n        }\n\n        if (endPadY) {\n          pixel.y -\x3d tileSize;\t\n        }\n\n        uv \x3d vec2(pixel.xy / tileSize);\n      } else {\n        vec2 pixel \x3d gl_FragCoord.xy - padWidth - padding;\n        uv \x3d vec2(pixel.xy / tileSize);\n      }\n\n      vec3 p_ \x3d get3Dfrom2D(uv, tileRows);\n      vec3 p \x3d p_;\n      p.z /\x3d (tileRows * tileRows);\n\n      float worleyPerlinNoise \x3d getTextureForPoint(p, PERLIN_WORLEY);\n      float worleyNoise \x3d getTextureForPoint(p, WORLEY);\n\n      gl_FragColor.r \x3d saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n      p_ \x3d mod(p_ + 1.0, tileRows * tileRows);\n      p \x3d p_;\n      p.z /\x3d (tileRows * tileRows);\n\n      worleyPerlinNoise \x3d getTextureForPoint(p, PERLIN_WORLEY);\n      worleyNoise \x3d getTextureForPoint(p, WORLEY);\n\n      gl_FragColor.g \x3d saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n    \tgl_FragColor.ba \x3d vec2(0, 1);\n    }\n  ");
          return y
        } const u = Object.freeze({ __proto__: null, build: q }); a.NoiseTextureAtlasShader = u; a.build = q
      })
    }, "esri/views/3d/environment/Fog": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../core/maybe ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec2 ../../../chunks/vec2f64 ../../../chunks/vec3 ../../../geometry/projectionEllipsoid ./atmosphereUtils ./FogTechnique ../webgl-engine/lib/DefaultVertexBufferLayouts ../webgl-engine/lib/glUtil3D".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          let v = function () {
            function m(g, x) { this._projectionInverse = y.create(); this._viewInverse = y.create(); this._nearFar = p.create(); this._darkenHaze = !1; this._hazeMultiplier = 1; this._strength = 4E-6; this._vao = t.createQuadVAO(g.renderContext.rctx, f.Pos2Tex); this._shaderTechniqueRepository = g.shaderTechniqueRep; g = h.getReferenceEllipsoid(x.spatialReference); this._planetRadius = g.radius; this._atmosphereRadius = g.radius + b.atmosphereHeight } var e = m.prototype; e.destroy = function () {
            this._distanceFogTechnique =
              q.releaseMaybe(this._distanceFogTechnique); this._foggyWeatherTechnique = q.releaseMaybe(this._foggyWeatherTechnique); this._vao = q.disposeMaybe(this._vao)
            }; e.when = function () { return Promise.resolve() }; e.render = function (g, x, k) {
            this._darkenHaze = k; this._update(g.camera, x); if (0 >= this._fogAmount) return !1; k = g.rctx; const r = g.offscreenRenderingHelper, A = x ? this.foggyWeatherTechnique : this.distanceFogTechnique; k.useProgram(A.program); A.bindPipelineState(k); r.renderDepthDetached(() => {
              A.program.bindTexture(r.depthTexture,
                "depthTex"); this._renderFog(A.program, g)
            }); return !0
            }; e._renderFog = function (g, x) {
              if (q.isNone(this._vao)) return !1; const k = x.rctx; x.scenelightingData.setLightDirectionUniform(g); g.setUniform3fv("cameraPosition", x.camera.eye); g.setUniformMatrix4fv("projectionInverse", this._projectionInverse); g.setUniformMatrix4fv("viewInverse", this._viewInverse); g.setUniform2fv("nearFar", this._nearFar); g.setUniform1f("atmosphereC", this._atmosphereC); g.setUniform1f("strength", this._strength); g.setUniform1f("fogAmount",
                this._hazeMultiplier * this._fogAmount); k.bindVAO(this._vao); g.assertCompatibleVertexAttributeLocations(this._vao); k.drawArrays(5, 0, 4); return !0
            }; e._update = function (g, x) {
              q.isNone(g) || (u.invert(this._projectionInverse, g.projectionMatrix), u.invert(this._viewInverse, g.viewMatrix), n.set(this._nearFar, g.near, g.far), g = l.length(g.eye), this._atmosphereC = g * g - this._atmosphereRadius * this._atmosphereRadius, this._fogAmount = x ? 1 - c.smoothstep(3E3, 6E3, Math.abs(g - this._planetRadius)) : 1 - c.smoothstep(7E3, 1E4, Math.abs(g -
                this._planetRadius)), this._hazeMultiplier = this._darkenHaze ? c.lerp(.4, 1, c.smoothstep(9500, 10500, g - this._planetRadius)) : 1)
            }; m.isSupported = function (g) { return g.capabilities.depthTexture }; w._createClass(m, [{ key: "strength", get: function () { return this._strength }, set: function (g) { this._strength = g } }, {
              key: "foggyWeatherTechnique", get: function () {
                if (q.isNone(this._foggyWeatherTechnique)) {
                  const g = new d.FogTechniqueConfiguration; g.haze = !1; this._foggyWeatherTechnique = this._shaderTechniqueRepository.acquire(d.FogTechnique,
                    g)
                } return this._foggyWeatherTechnique
              }
            }, { key: "distanceFogTechnique", get: function () { if (q.isNone(this._distanceFogTechnique)) { const g = new d.FogTechniqueConfiguration; g.haze = !0; this._distanceFogTechnique = this._shaderTechniqueRepository.acquire(d.FogTechnique, g) } return this._distanceFogTechnique } }]); return m
          }(); a.Fog = v; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/environment/FogTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../chunks/Fog.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          n = function (d) {
            function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build({ haze: this.configuration.haze }); return new h.Program(v.rctx, m, l.Default3D) }; t.initializePipeline = function () {
              return this.configuration.haze ? b.makePipelineState({ blending: b.separateBlendingParams(1, 0, 769, 1), colorWrite: b.defaultColorWriteParams }) : b.makePipelineState({
                blending: b.separateBlendingParams(770, 0,
                  771, 1), colorWrite: b.defaultColorWriteParams
              })
            }; return f
          }(n.ShaderTechnique); n.shader = new y.ReloadableShaderModule(u.FogShader, () => new Promise((d, f) => a(["./Fog.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.haze = !1; return t } c._inheritsLoose(f, d); return f }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter()], u.prototype, "haze", void 0); w.FogTechnique = n; w.FogTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/Fog.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y) {
          function n(l) {
            const h = new y.ShaderBuilder; h.attributes.add("position", "vec2"); h.include(w.TextureCoordinateAttribute, { attributeTextureCoordinates: 1 }); h.varyings.add("worldRay", "vec3"); h.varyings.add("eyeDir", "vec3"); h.vertex.uniforms.add("projectionInverse", "mat4"); h.vertex.uniforms.add("viewInverse", "mat4"); h.vertex.code.add(u.glsl`void main(void) {
vec3 posViewNear = (projectionInverse * vec4(position, -1, 1)).xyz;
eyeDir = posViewNear;
worldRay = (viewInverse * vec4(posViewNear, 0)).xyz;
forwardTextureCoordinates();
gl_Position = vec4(position, 1, 1);
}`); h.fragment.uniforms.add("lightingMainDirection", "vec3").add("atmosphereC", "float").add("cameraPosition", "vec3").add("nearFar", "vec2").add("depthTex", "sampler2D").add("strength", "float").add("fogAmount", "float"); h.include(q.Gamma); h.fragment.include(c.ReadLinearDepth); h.fragment.code.add(u.glsl`vec2 sphereIntersect(vec3 start, vec3 dir) {
float a = dot(dir, dir);
float b = 2.0 * dot(dir, start);
float d = (b * b) - 4.0 * a * atmosphereC;
if (d < 0.0) {
return vec2(1e5, -1e5);
}
return vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));
}`); h.fragment.code.add(u.glsl`
    vec4 applyFog(float dist, vec3 rayDir){
      bool sky = false;

      if(dist == -1.0){
        vec2 rayAtmosphereIntersect = sphereIntersect(cameraPosition, rayDir);
        dist = 0.1 * rayAtmosphereIntersect.y;
        sky = true;
      }

      float fogAmount = fogAmount * (1.0 - exp(-dist * strength));

      float sunAmount = max(0.0, dot(rayDir, lightingMainDirection));

      float lightAngle = max(0.0, dot(normalize(cameraPosition + dist * rayDir), lightingMainDirection));
      ${l.haze ? u.glsl`vec3 fogColor = mix(vec3(0.0), vec3(0.24, 0.44, 0.8), lightAngle);` : u.glsl`vec3 fogColor = mix(vec3(0.1), vec3(1.5), lightAngle);`}

      float phase = sky ? pow(sunAmount, 16.0) : 0.0;
      vec3 col = (lightAngle * vec3(1.0, 0.6, 0.3) * phase + fogColor) * fogAmount;
      return vec4(col, fogAmount);
    }
    `); h.fragment.code.add(u.glsl`
    vec3 tonemapACES(vec3 x) {
      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
    }

    void main() {
      vec3 rayDir = normalize(worldRay);
      float terrainDepth = -1.0;

      float depthSample = texture2D(depthTex, vuv0).r;
      float zNorm = 2.0 * depthSample - 1.0;
      float linDepth = 2.0 * nearFar[0] * nearFar[1] / (nearFar[1] + nearFar[0] - zNorm * (nearFar[1] - nearFar[0]));
      if(depthSample < 1.0 && depthSample > 0.0){
        vec3 cameraSpaceRay = normalize(eyeDir);
        cameraSpaceRay /= cameraSpaceRay.z;
        cameraSpaceRay *= linDepth;
        terrainDepth = max(0.0, length(cameraSpaceRay));
      }

      ${l.haze ? u.glsl`
          if(terrainDepth == -1.0){
            gl_FragColor = vec4(0);
            return;
          }`: ""}

      vec4 fog = applyFog(terrainDepth, rayDir);

      gl_FragColor = delinearizeGamma(vec4(tonemapACES(fog.rgb), fog.a));
    }
  `); return h
          } const p = Object.freeze({ __proto__: null, build: n }); a.FogShader = p; a.build = n
        })
    }, "esri/views/3d/environment/PanoramicAtmosphere": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../support/requestImageUtils ./SimpleAtmosphereTechnique ./resources/SimpleAtmosphereTexture ../support/buffer/glUtil ../support/buffer/InterleavedLayout ../webgl-engine/core/shaderLibrary/util/View.glsl ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/GeometryUtil ../../webgl/BufferObject ../../webgl/Texture ../../webgl/Util ../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
          const k = c.getLogger("esri.views.3d.environment.PanoramicAtmosphere"); c = function () {
            function z() { this.type = "panoramic"; this._atmosphereTechniqueConfig = new l.SimpleAtmosphereTechniqueConfiguration; this._readyResolver = u.createResolver(); this._readyController = new AbortController } var B = z.prototype; B.destroy = function () { this._readyResolver.reject(); this._texture = q.disposeMaybe(this._texture); this._vao = q.disposeMaybe(this._vao); this._readyController = q.abortMaybe(this._readyController) };
            B.when = function () { return this._readyResolver.promise }; B.initializeRenderContext = function (C) {
              this._atmosphereTechniqueConfig.geometry = 1; this._atmosphereTechnique = C.shaderTechniqueRep.acquire(l.SimpleAtmosphereTechnique, this._atmosphereTechniqueConfig); const D = C.renderContext.rctx; this._vao = this._createVertexArrayObject(D); this._vaoCount = g.vertexCount(this._vao, "geometry"); p.requestImage(h, { signal: this._readyController.signal }).then(E => {
              this._texture = new e(D, {
                pixelFormat: 6408, dataType: 5121, wrapMode: 33071,
                samplingMode: 9729, flipped: !0
              }, E); C.requestRender(); this._readyController = null; this._readyResolver.resolve()
              }).catch(E => { u.isAbortError(E) || k.error("Unable to initialize atmosphere: image request failed", E); this._readyResolver.reject() })
            }; B.render = function (C) {
              const D = C.rctx, E = this._atmosphereTechnique.program; D.useProgram(E); this._atmosphereTechnique.bindPipelineState(D); E.bindTexture(this._texture, "tex"); f.bindProjectionMatrix(E, C.camera.projectionMatrix); var H = r; y.copy(H, C.camera.viewMatrix); H[12] =
                0; H[13] = 0; H[14] = 0; H[15] = 1; E.setUniformMatrix4fv("view", r); E.setUniform4f("color", 1, 1, 1, 1); C.scenelightingData.setLightDirectionUniform(E); D.bindVAO(this._vao); E.assertCompatibleVertexAttributeLocations(this._vao); D.drawArrays(4, 0, this._vaoCount); return !0
            }; B.renderHaze = function () { return !1 }; B._createVertexArrayObject = function (C) {
              var D = v.createPolySphereGeometry(1, 2, !1); const E = D.indices.get("position"); for (var H = 0; H < E.length; H += 3) { var J = E[H]; E[H] = E[H + 2]; E[H + 2] = J } D = D.vertexAttributes.get("position").data;
              H = A.createBuffer(E.length); J = H.position; for (let M = 0; M < E.length; ++M) { const F = 3 * E[M]; J.set(M, 0, D[F]); J.set(M, 1, D[F + 1]); J.set(M, 2, D[F + 2]) } return new x(C, t.Default3D, { geometry: b.glLayout(A) }, { geometry: m.createVertex(C, 35044, H.buffer) })
            }; w._createClass(z, [{ key: "canRender", get: function () { return null != this._texture } }]); return z
          }(); const r = n.create(), A = d.newLayout().vec3f("position"); a.PanoramicAtmosphere = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/support/requestImageUtils": function () {
      define(["exports",
        "../chunks/_rollupPluginBabelHelpers", "../request"], function (a, w, c) { function q() { q = w._asyncToGenerator(function* (u, y) { ({ data: u } = yield c(u, { responseType: "image", ...y })); return u }); return q.apply(this, arguments) } a.requestImage = function (u, y) { return q.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/environment/SimpleAtmosphereTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../chunks/SimpleAtmosphere.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          n = function (d) {
            function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build({ geometry: this.configuration.geometry }); return new h.Program(v.rctx, m, l.Default3D) }; t.initializePipeline = function () {
              return 1 === this.configuration.geometry ? b.makePipelineState({ blending: b.separateBlendingParams(770, 1, 771, 771), culling: b.backFaceCullingParams, depthTest: { func: 515 }, colorWrite: b.defaultColorWriteParams }) :
                b.makePipelineState({ blending: b.separateBlendingParams(770, 1, 771, 771), depthTest: { func: 515 }, colorWrite: b.defaultColorWriteParams })
            }; return f
          }(n.ShaderTechnique); n.shader = new y.ReloadableShaderModule(u.SimpleAtmosphereShader, () => new Promise((d, f) => a(["./SimpleAtmosphere.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.geometry = 0; return t } c._inheritsLoose(f, d); return f }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter({ count: 3 })], u.prototype, "geometry", void 0);
          w.SimpleAtmosphereTechnique = n; w.SimpleAtmosphereTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/SimpleAtmosphere.glsl": function () {
      define(["exports", "../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl", "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c, q) {
        function u(n) {
          const p = new q.ShaderBuilder; 2 === n.geometry ? (p.attributes.add("position", "vec2"), p.varyings.add("color",
            "vec4"), p.vertex.uniforms.add("lightingMainDirection", "vec3").add("cameraPosition", "vec3").add("undergroundFadeAlpha", "float"), p.vertex.code.add(c.glsl`void main(void) {
float ndotl = dot(normalize(cameraPosition), lightingMainDirection);
float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));
color = vec4(vec3(lighting), undergroundFadeAlpha);
gl_Position = vec4(position.xy, 1.0, 1.0);
}`), p.fragment.code.add(c.glsl`void main() {
gl_FragColor = color;
}`)) : (p.include(w.Transform, { linearDepth: !1 }), p.attributes.add("position", "vec3"), p.varyings.add("vtc", "vec2"), p.varyings.add("falloff", "float"), n = 1 === n.geometry, p.vertex.uniforms.add("proj", "mat4").add("view", "mat4").add("lightingMainDirection", "vec3"), n || (p.varyings.add("innerFactor", "float"), p.vertex.uniforms.add("silCircleCenter", "vec3").add("silCircleV1", "vec3").add("silCircleV2", "vec3").add("texV", "vec2").add("innerScale", "float")), p.vertex.code.add(c.glsl`
		void main(void) {
      ${n ? c.glsl`
      vec3 pos = position;
      float ndotl = lightingMainDirection.z;
      vtc = vec2(0.0, position.z + 0.05);`: c.glsl`
      innerFactor = clamp(-position.z, 0.0, 1.0);
      float scale = position.y * (1.0 + innerFactor * innerScale);
      float phi = position.x * ${c.glsl.float(.04908738515625)} + 1.0;
      vec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;
      float ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightingMainDirection);
      vtc.x = position.x  * ${c.glsl.float(.0078125)};
      vtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;
      `}
      falloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));

		  gl_Position = transformPosition(proj, view, pos);
		  gl_Position.z = gl_Position.w; // project atmosphere onto the far plane
    }
	  `), p.fragment.uniforms.add("tex", "sampler2D"), n || p.fragment.uniforms.add("altitudeFade", "float"), p.fragment.code.add(c.glsl`
		void main() {
			vec4 atmosphereColor = texture2D(tex, vtc) * falloff;
      ${n ? c.glsl`gl_FragColor = atmosphereColor;` : c.glsl`
			vec4 innerColor = vec4(atmosphereColor.rgb, 1.0 - altitudeFade);
			gl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));
      `}
    }`)); return p
        } const y = Object.freeze({ __proto__: null, build: u }); a.SimpleAtmosphereShader = y; a.build = u
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl": function () {
      define(["exports", "../shaderModules/interfaces"], function (a, w) {
      a.Transform = function (c, q) {
        q.linearDepth ? c.vertex.code.add(w.glsl`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`) : c.vertex.code.add(w.glsl`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/environment/resources/SimpleAtmosphereTexture": function () { define(function () { return "data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAEAAAIACAYAAABD1gYFAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAXVJREFUeNq0k9GWhDAIQ3PjzP9/cuehFqhW19mz++IhkCZAq1prsqT+kSQS9g8Vnqp6VGVWkYVktR6tj3Gr968nLnfwlHzHYyHapkKS73bPd/39eI38AYWj24OGvqdwWjZ3l8IDgacXyl1Dj9tdLOzZiicj+P1YcGk0H2O2vN/VQpTveEHmPHQxZxYlqsQdhUeuCWREuDEvAjqlCqDIMYwIo2ijR1HdYUS58dQrKpgQ0EGeMocsTNXrxzyOhS9kfzlWjn82YuWLqwAnvfNEWJFjYXkJCT0s7AmS0NG4x7Lt6Cpy2MiVPBZmS668QT5AR1cevp7b6CpzQ/ZSNH0vmhy5CsNtdax0MBpXDBiFsrDiMSLKMc8b6hH93bNbEpRsIyHDUhNcfTyeKF16PC7c/2QdczvUnvOB1ylZHVFSMtd5s8C2IW/7w6hwM5GLavLCd1zkiFjB+BwH1DSgctQ7mPOimBLJrw35beSXkd8BM/cCqbXWPgMA+GQQ5sIgkfAAAAAASUVORK5CYII\x3d" }) },
    "esri/views/3d/support/buffer/glUtil": function () {
      define(["exports"], function (a) {
        const w = { u8: 5121, u16: 5123, u32: 5125, i8: 5120, i16: 5122, i32: 5124, f32: 5126 }; a.glLayout = function (c, q = 0) {
          const u = c.stride; return c.fieldNames.filter(y => { y = c.fields.get(y).optional; return !(y && y.glPadding) }).map(y => {
            const n = c.fields.get(y), p = n.constructor.ElementCount; var l = w[n.constructor.ElementType]; if (!l) throw Error("BufferType not supported in WebGL"); return {
              name: y, stride: u, count: p, type: l, offset: n.offset, normalized: !(!n.optional ||
                !n.optional.glNormalized), divisor: q
            }
          })
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/buffer/InterleavedLayout": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../geometry/support/buffer/BufferView", "../../../../geometry/support/buffer/types"], function (a, w, c, q) {
        let u = function () {
          function n(l, h) {
          this.layout = l; this.buffer = "number" === typeof h ? new ArrayBuffer(h * l.stride) : h; for (const b of l.fieldNames) h = l.fields.get(b), this[b] = new h.constructor(this.buffer,
            h.offset, this.stride)
          } var p = n.prototype; p.getField = function (l, h) { return (l = this[l]) && l.elementCount === h.ElementCount && l.elementType === h.ElementType ? l : null }; p.slice = function (l, h) { return new n(this.layout, this.buffer.slice(l * this.stride, h * this.stride)) }; p.copyFrom = function (l, h, b, d) { const f = this.stride; 0 === f % 4 ? (l = new Uint32Array(l.buffer, h * f, d * f / 4), (new Uint32Array(this.buffer, b * f, d * f / 4)).set(l)) : (l = new Uint8Array(l.buffer, h * f, d * f), (new Uint8Array(this.buffer, b * f, d * f)).set(l)) }; w._createClass(n, [{
            key: "stride",
            get: function () { return this.layout.stride }
          }, { key: "count", get: function () { return this.buffer.byteLength / this.stride } }, { key: "byteLength", get: function () { return this.buffer.byteLength } }]); return n
        }(), y = function () {
          function n() { this.stride = 0; this.fields = new Map; this.fieldNames = [] } var p = n.prototype; p.vec2f = function (l, h) { this.appendField(l, c.BufferViewVec2f, h); return this }; p.vec2f64 = function (l, h) { this.appendField(l, c.BufferViewVec2f64, h); return this }; p.vec3f = function (l, h) {
            this.appendField(l, c.BufferViewVec3f,
              h); return this
          }; p.vec3f64 = function (l, h) { this.appendField(l, c.BufferViewVec3f64, h); return this }; p.vec4f = function (l, h) { this.appendField(l, c.BufferViewVec4f, h); return this }; p.vec4f64 = function (l, h) { this.appendField(l, c.BufferViewVec4f64, h); return this }; p.mat3f = function (l, h) { this.appendField(l, c.BufferViewMat3f, h); return this }; p.mat3f64 = function (l, h) { this.appendField(l, c.BufferViewMat3f64, h); return this }; p.mat4f = function (l, h) { this.appendField(l, c.BufferViewMat4f, h); return this }; p.mat4f64 = function (l, h) {
            this.appendField(l,
              c.BufferViewMat4f64, h); return this
          }; p.vec4u8 = function (l, h) { this.appendField(l, c.BufferViewVec4u8, h); return this }; p.f32 = function (l, h) { this.appendField(l, c.BufferViewFloat, h); return this }; p.f64 = function (l, h) { this.appendField(l, c.BufferViewFloat64, h); return this }; p.u8 = function (l, h) { this.appendField(l, c.BufferViewUint8, h); return this }; p.u16 = function (l, h) { this.appendField(l, c.BufferViewUint16, h); return this }; p.i8 = function (l, h) { this.appendField(l, c.BufferViewInt8, h); return this }; p.vec2i8 = function (l, h) {
            this.appendField(l,
              c.BufferViewVec2i8, h); return this
          }; p.vec2i16 = function (l, h) { this.appendField(l, c.BufferViewVec2i16, h); return this }; p.vec2u8 = function (l, h) { this.appendField(l, c.BufferViewVec2u8, h); return this }; p.vec4u16 = function (l, h) { this.appendField(l, c.BufferViewVec4u16, h); return this }; p.u32 = function (l, h) { this.appendField(l, c.BufferViewUint32, h); return this }; p.appendField = function (l, h, b) {
            const d = h.ElementCount * q.elementTypeSize(h.ElementType); this.fields.set(l, { size: d, constructor: h, offset: this.stride, optional: b });
            this.stride += d; this.fieldNames.push(l)
          }; p.alignTo = function (l) { this.stride = Math.floor((this.stride + l - 1) / l) * l; return this }; p.hasField = function (l) { return 0 <= this.fieldNames.indexOf(l) }; p.createBuffer = function (l) { return new u(this, l) }; p.createView = function (l) { return new u(this, l) }; p.clone = function () { const l = new n; l.stride = this.stride; l.fields = new Map; this.fields.forEach((h, b) => l.fields.set(b, h)); l.fieldNames = this.fieldNames.slice(); l.BufferType = this.BufferType; return l }; return n
        }(); a.InterleavedBuffer =
          u; a.InterleavedLayout = y; a.newLayout = function () { return new y }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/BufferView": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ./internals/Mat3 ./internals/Mat4 ./internals/Scalar ./internals/Vec2 ./internals/Vec3 ./internals/Vec4".split(" "), function (a, w, c, q, u, y, n, p) {
        let l = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Float32Array, Q, T, da, Y) || this; Q.elementType = "f32"; return Q } w._inheritsLoose(S, R);
          S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(u.BufferViewScalarImpl); l.ElementType = "f32"; let h = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float32Array, Q, T, da, Y) || this; Q.elementType = "f32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(y.BufferViewVec2Impl); h.ElementType = "f32"; let b =
          function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float32Array, Q, T, da, Y) || this; Q.elementType = "f32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(n.BufferViewVec3Impl); b.ElementType = "f32"; let d = function (R) {
            function S(Q, T = 0, da, Y) { Q = R.call(this, Float32Array, Q, T, da, Y) || this; Q.elementType = "f32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q,
              T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
          }(p.BufferViewVec4Impl); d.ElementType = "f32"; let f = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float32Array, Q, T, da, Y) || this; Q.elementType = "f32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(c.BufferViewMat3Impl);
        f.ElementType = "f32"; c = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float64Array, Q, T, da, Y) || this; Q.elementType = "f64"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(c.BufferViewMat3Impl); c.ElementType = "f64"; let t = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Float32Array, Q, T, da, Y) || this; Q.elementType = "f32"; return Q } w._inheritsLoose(S, R); S.prototype.slice =
            function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(q.BufferViewMat4Impl); t.ElementType = "f32"; q = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float64Array, Q, T, da, Y) || this; Q.elementType = "f64"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(q.BufferViewMat4Impl);
        q.ElementType = "f64"; let v = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float64Array, Q, T, da, Y) || this; Q.elementType = "f64"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(u.BufferViewScalarImpl); v.ElementType = "f64"; let m = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Float64Array, Q, T, da, Y) || this; Q.elementType = "f64"; return Q } w._inheritsLoose(S,
            R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(y.BufferViewVec2Impl); m.ElementType = "f64"; let e = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Float64Array, Q, T, da, Y) || this; Q.elementType = "f64"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) };
          return S
        }(n.BufferViewVec3Impl); e.ElementType = "f64"; let g = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Float64Array, Q, T, da, Y) || this; Q.elementType = "f64"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(p.BufferViewVec4Impl); g.ElementType = "f64"; let x = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Uint8Array, Q, T, da, Y) || this; Q.elementType = "u8"; return Q }
          w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(u.BufferViewScalarImpl); x.ElementType = "u8"; let k = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Uint8Array, Q, T, da, Y) || this; Q.elementType = "u8"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) {
            return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset +
              Q.byteLength)
          }; return S
        }(y.BufferViewVec2Impl); k.ElementType = "u8"; let r = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Uint8Array, Q, T, da, Y) || this; Q.elementType = "u8"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(n.BufferViewVec3Impl); r.ElementType = "u8"; let A = function (R) {
          function S(Q, T = 0, da, Y) {
            Q = R.call(this, Uint8Array, Q, T, da, Y) || this; Q.elementType =
              "u8"; return Q
          } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(p.BufferViewVec4Impl); A.ElementType = "u8"; let z = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Uint16Array, Q, T, da, Y) || this; Q.elementType = "u16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) {
            return new S(Q.buffer, Q.byteOffset,
              T, Q.byteOffset + Q.byteLength)
          }; return S
        }(u.BufferViewScalarImpl); z.ElementType = "u16"; let B = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Uint16Array, Q, T, da, Y) || this; Q.elementType = "u16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(y.BufferViewVec2Impl); B.ElementType = "u16"; let C = function (R) {
          function S(Q, T = 0, da, Y) {
            Q = R.call(this, Uint16Array, Q, T,
              da, Y) || this; Q.elementType = "u16"; return Q
          } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(n.BufferViewVec3Impl); C.ElementType = "u16"; let D = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Uint16Array, Q, T, da, Y) || this; Q.elementType = "u16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q,
            T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(p.BufferViewVec4Impl); D.ElementType = "u16"; let E = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Uint32Array, Q, T, da, Y) || this; Q.elementType = "u32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(u.BufferViewScalarImpl); E.ElementType = "u32"; let H = function (R) {
          function S(Q, T =
            0, da, Y) { Q = R.call(this, Uint32Array, Q, T, da, Y) || this; Q.elementType = "u32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(y.BufferViewVec2Impl); H.ElementType = "u32"; let J = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Uint32Array, Q, T, da, Y) || this; Q.elementType = "u32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) {
            return this.sliceBuffer(S,
              Q, T)
          }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(n.BufferViewVec3Impl); J.ElementType = "u32"; let M = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Uint32Array, Q, T, da, Y) || this; Q.elementType = "u32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(p.BufferViewVec4Impl); M.ElementType = "u32"; let F =
          function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int8Array, Q, T, da, Y) || this; Q.elementType = "i8"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(u.BufferViewScalarImpl); F.ElementType = "i8"; let K = function (R) {
            function S(Q, T = 0, da, Y) { Q = R.call(this, Int8Array, Q, T, da, Y) || this; Q.elementType = "i8"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) {
              return this.sliceBuffer(S,
                Q, T)
            }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
          }(y.BufferViewVec2Impl); K.ElementType = "i8"; let P = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int8Array, Q, T, da, Y) || this; Q.elementType = "i8"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(n.BufferViewVec3Impl); P.ElementType = "i8"; let L =
            function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int8Array, Q, T, da, Y) || this; Q.elementType = "i8"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(p.BufferViewVec4Impl); L.ElementType = "i8"; let N = function (R) {
              function S(Q, T = 0, da, Y) { Q = R.call(this, Int16Array, Q, T, da, Y) || this; Q.elementType = "i16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) {
                return this.sliceBuffer(S,
                  Q, T)
              }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
            }(u.BufferViewScalarImpl); N.ElementType = "i16"; let G = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int16Array, Q, T, da, Y) || this; Q.elementType = "i16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(y.BufferViewVec2Impl); G.ElementType = "i16";
        let I = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int16Array, Q, T, da, Y) || this; Q.elementType = "i16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(n.BufferViewVec3Impl); I.ElementType = "i16"; let O = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Int16Array, Q, T, da, Y) || this; Q.elementType = "i16"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q,
            T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(p.BufferViewVec4Impl); O.ElementType = "i16"; u = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int32Array, Q, T, da, Y) || this; Q.elementType = "i32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(u.BufferViewScalarImpl);
        u.ElementType = "i32"; y = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int32Array, Q, T, da, Y) || this; Q.elementType = "i32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(y.BufferViewVec2Impl); y.ElementType = "i32"; n = function (R) {
          function S(Q, T = 0, da, Y) { Q = R.call(this, Int32Array, Q, T, da, Y) || this; Q.elementType = "i32"; return Q } w._inheritsLoose(S, R); S.prototype.slice =
            function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S
        }(n.BufferViewVec3Impl); n.ElementType = "i32"; p = function (R) { function S(Q, T = 0, da, Y) { Q = R.call(this, Int32Array, Q, T, da, Y) || this; Q.elementType = "i32"; return Q } w._inheritsLoose(S, R); S.prototype.slice = function (Q, T) { return this.sliceBuffer(S, Q, T) }; S.fromTypedArray = function (Q, T) { return new S(Q.buffer, Q.byteOffset, T, Q.byteOffset + Q.byteLength) }; return S }(p.BufferViewVec4Impl);
        p.ElementType = "i32"; a.BufferViewFloat = l; a.BufferViewFloat64 = v; a.BufferViewInt16 = N; a.BufferViewInt32 = u; a.BufferViewInt8 = F; a.BufferViewMat3f = f; a.BufferViewMat3f64 = c; a.BufferViewMat4f = t; a.BufferViewMat4f64 = q; a.BufferViewUint16 = z; a.BufferViewUint32 = E; a.BufferViewUint8 = x; a.BufferViewVec2f = h; a.BufferViewVec2f64 = m; a.BufferViewVec2i16 = G; a.BufferViewVec2i32 = y; a.BufferViewVec2i8 = K; a.BufferViewVec2u16 = B; a.BufferViewVec2u32 = H; a.BufferViewVec2u8 = k; a.BufferViewVec3f = b; a.BufferViewVec3f64 = e; a.BufferViewVec3i16 =
          I; a.BufferViewVec3i32 = n; a.BufferViewVec3i8 = P; a.BufferViewVec3u16 = C; a.BufferViewVec3u32 = J; a.BufferViewVec3u8 = r; a.BufferViewVec4f = d; a.BufferViewVec4f64 = g; a.BufferViewVec4i16 = O; a.BufferViewVec4i32 = p; a.BufferViewVec4i8 = L; a.BufferViewVec4u16 = D; a.BufferViewVec4u32 = M; a.BufferViewVec4u8 = A; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/internals/Mat3": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y,
            n, p = 0, l, h) { this.TypedArrayConstructor = y; this.elementCount = 9; y = this.TypedArrayConstructor; void 0 === l && (l = 9 * y.BYTES_PER_ELEMENT); const b = 0 === n.byteLength ? 0 : p; this.typedBuffer = null == h ? new y(n, b) : new y(n, b, (h - p) / y.BYTES_PER_ELEMENT); this.typedBufferStride = l / y.BYTES_PER_ELEMENT; this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride); this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT } var u = q.prototype; u.sliceBuffer = function (y, n, p = this.count - n) {
              n = this.typedBuffer.byteOffset +
              n * this.stride; return new y(this.buffer, n, this.stride, n + p * this.stride)
            }; u.getMat = function (y, n) { y *= this.typedBufferStride; for (let p = 0; 9 > p; p++)n[p] = this.typedBuffer[y++]; return n }; u.setMat = function (y, n) { y *= this.typedBufferStride; for (let p = 0; 9 > p; p++)this.typedBuffer[y++] = n[p] }; u.get = function (y, n) { return this.typedBuffer[y * this.typedBufferStride + n] }; u.set = function (y, n, p) { this.typedBuffer[y * this.typedBufferStride + n] = p }; u.copyFrom = function (y, n, p) {
              const l = this.typedBuffer, h = n.typedBuffer; y *= this.typedBufferStride;
              n = p * n.typedBufferStride; for (p = 0; 9 > p; ++p)l[y++] = h[n++]
            }; w._createClass(q, [{ key: "buffer", get: function () { return this.typedBuffer.buffer } }]); return q
        }(); c.ElementCount = 9; a.BufferViewMat3Impl = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/internals/Mat4": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y, n, p = 0, l, h) {
          this.TypedArrayConstructor = y; this.elementCount = 16; y = this.TypedArrayConstructor; void 0 ===
            l && (l = 16 * y.BYTES_PER_ELEMENT); const b = 0 === n.byteLength ? 0 : p; this.typedBuffer = null == h ? new y(n, b) : new y(n, b, (h - p) / y.BYTES_PER_ELEMENT); this.typedBufferStride = l / y.BYTES_PER_ELEMENT; this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride); this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT
          } var u = q.prototype; u.sliceBuffer = function (y, n, p = this.count - n) { n = this.typedBuffer.byteOffset + n * this.stride; return new y(this.buffer, n, this.stride, n + p * this.stride) }; u.getMat = function (y,
            n) { y *= this.typedBufferStride; for (let p = 0; 16 > p; p++)n[p] = this.typedBuffer[y++]; return n }; u.setMat = function (y, n) { y *= this.typedBufferStride; for (let p = 0; 16 > p; p++)this.typedBuffer[y++] = n[p] }; u.get = function (y, n) { return this.typedBuffer[y * this.typedBufferStride + n] }; u.set = function (y, n, p) { this.typedBuffer[y * this.typedBufferStride + n] = p }; u.copyFrom = function (y, n, p) { const l = this.typedBuffer, h = n.typedBuffer; y *= this.typedBufferStride; n = p * n.typedBufferStride; for (p = 0; 16 > p; ++p)l[y++] = h[n++] }; w._createClass(q, [{
              key: "buffer",
              get: function () { return this.typedBuffer.buffer }
            }]); return q
        }(); c.ElementCount = 16; a.BufferViewMat4Impl = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/internals/Scalar": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y, n, p = 0, l, h) {
          this.TypedArrayConstructor = y; this.elementCount = 1; y = this.TypedArrayConstructor; void 0 === l && (l = y.BYTES_PER_ELEMENT); const b = 0 === n.byteLength ? 0 : p; this.typedBuffer = null ==
            h ? new y(n, b) : new y(n, b, (h - p) / y.BYTES_PER_ELEMENT); this.typedBufferStride = l / y.BYTES_PER_ELEMENT; this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride); this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT
          } var u = q.prototype; u.sliceBuffer = function (y, n, p = this.count - n) { n = this.typedBuffer.byteOffset + n * this.stride; return new y(this.buffer, n, this.stride, n + p * this.stride) }; u.get = function (y) { return this.typedBuffer[y * this.typedBufferStride] }; u.set = function (y, n) {
          this.typedBuffer[y *
            this.typedBufferStride] = n
          }; w._createClass(q, [{ key: "buffer", get: function () { return this.typedBuffer.buffer } }]); return q
        }(); c.ElementCount = 1; a.BufferViewScalarImpl = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/internals/Vec2": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../chunks/vec2"], function (a, w, c) {
        let q = function () {
          function u(n, p, l = 0, h, b) {
          this.TypedArrayConstructor = n; this.elementCount = 2; n = this.TypedArrayConstructor; void 0 ===
            h && (h = 2 * n.BYTES_PER_ELEMENT); const d = 0 === p.byteLength ? 0 : l; this.typedBuffer = null == b ? new n(p, d) : new n(p, d, (b - l) / n.BYTES_PER_ELEMENT); this.typedBufferStride = h / n.BYTES_PER_ELEMENT; this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride); this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT
          } var y = u.prototype; y.sliceBuffer = function (n, p, l = this.count - p) { p = this.typedBuffer.byteOffset + p * this.stride; return new n(this.buffer, p, this.stride, p + l * this.stride) }; y.getVec = function (n,
            p) { n *= this.typedBufferStride; return c.set(p, this.typedBuffer[n], this.typedBuffer[n + 1]) }; y.setVec = function (n, p) { n *= this.typedBufferStride; this.typedBuffer[n++] = p[0]; this.typedBuffer[n] = p[1] }; y.get = function (n, p) { return this.typedBuffer[n * this.typedBufferStride + p] }; y.set = function (n, p, l) { this.typedBuffer[n * this.typedBufferStride + p] = l }; y.setValues = function (n, p, l) { n *= this.typedBufferStride; this.typedBuffer[n++] = p; this.typedBuffer[n] = l }; y.copyFrom = function (n, p, l) {
              const h = this.typedBuffer, b = p.typedBuffer;
              n *= this.typedBufferStride; p = l * p.typedBufferStride; h[n++] = b[p++]; h[n] = b[p]
            }; w._createClass(u, [{ key: "buffer", get: function () { return this.typedBuffer.buffer } }]); return u
        }(); q.ElementCount = 2; a.BufferViewVec2Impl = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/internals/Vec3": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../chunks/vec3"], function (a, w, c) {
        let q = function () {
          function u(n, p, l = 0, h, b) {
          this.TypedArrayConstructor = n; this.elementCount =
            3; n = this.TypedArrayConstructor; void 0 === h && (h = 3 * n.BYTES_PER_ELEMENT); const d = 0 === p.byteLength ? 0 : l; this.typedBuffer = null == b ? new n(p, d) : new n(p, d, (b - l) / n.BYTES_PER_ELEMENT); this.typedBufferStride = h / n.BYTES_PER_ELEMENT; this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride); this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT
          } var y = u.prototype; y.sliceBuffer = function (n, p, l = this.count - p) {
            p = this.typedBuffer.byteOffset + p * this.stride; return new n(this.buffer, p, this.stride,
              p + l * this.stride)
          }; y.getVec = function (n, p) { n *= this.typedBufferStride; return c.set(p, this.typedBuffer[n], this.typedBuffer[n + 1], this.typedBuffer[n + 2]) }; y.setVec = function (n, p) { n *= this.typedBufferStride; this.typedBuffer[n++] = p[0]; this.typedBuffer[n++] = p[1]; this.typedBuffer[n] = p[2] }; y.get = function (n, p) { return this.typedBuffer[n * this.typedBufferStride + p] }; y.set = function (n, p, l) { this.typedBuffer[n * this.typedBufferStride + p] = l }; y.setValues = function (n, p, l, h) {
            n *= this.typedBufferStride; this.typedBuffer[n++] = p; this.typedBuffer[n++] =
              l; this.typedBuffer[n] = h
          }; y.copyFrom = function (n, p, l) { const h = this.typedBuffer, b = p.typedBuffer; n *= this.typedBufferStride; p = l * p.typedBufferStride; h[n++] = b[p++]; h[n++] = b[p++]; h[n] = b[p] }; w._createClass(u, [{ key: "buffer", get: function () { return this.typedBuffer.buffer } }]); return u
        }(); q.ElementCount = 3; a.BufferViewVec3Impl = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/buffer/internals/Vec4": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../chunks/vec4"],
        function (a, w, c) {
          let q = function () {
            function u(n, p, l = 0, h, b) { this.TypedArrayConstructor = n; this.elementCount = 4; n = this.TypedArrayConstructor; void 0 === h && (h = 4 * n.BYTES_PER_ELEMENT); const d = 0 === p.byteLength ? 0 : l; this.typedBuffer = null == b ? new n(p, d) : new n(p, d, (b - l) / n.BYTES_PER_ELEMENT); this.typedBufferStride = h / n.BYTES_PER_ELEMENT; this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride); this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT } var y = u.prototype; y.sliceBuffer =
              function (n, p, l = this.count - p) { p = this.typedBuffer.byteOffset + p * this.stride; return new n(this.buffer, p, this.stride, p + l * this.stride) }; y.getVec = function (n, p) { n *= this.typedBufferStride; return c.set(p, this.typedBuffer[n++], this.typedBuffer[n++], this.typedBuffer[n++], this.typedBuffer[n]) }; y.setVec = function (n, p) { n *= this.typedBufferStride; this.typedBuffer[n++] = p[0]; this.typedBuffer[n++] = p[1]; this.typedBuffer[n++] = p[2]; this.typedBuffer[n] = p[3] }; y.get = function (n, p) {
                return this.typedBuffer[n * this.typedBufferStride +
                  p]
              }; y.set = function (n, p, l) { this.typedBuffer[n * this.typedBufferStride + p] = l }; y.setValues = function (n, p, l, h, b) { n *= this.typedBufferStride; this.typedBuffer[n++] = p; this.typedBuffer[n++] = l; this.typedBuffer[n++] = h; this.typedBuffer[n] = b }; y.copyFrom = function (n, p, l) { const h = this.typedBuffer, b = p.typedBuffer; n *= this.typedBufferStride; p = l * p.typedBufferStride; h[n++] = b[p++]; h[n++] = b[p++]; h[n++] = b[p++]; h[n] = b[p] }; w._createClass(u, [{ key: "buffer", get: function () { return this.typedBuffer.buffer } }]); return u
          }(); q.ElementCount =
            4; a.BufferViewVec4Impl = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/support/buffer/types": function () {
      define(["exports", "../../../core/has"], function (a, w) {
      a.elementTypeSize = function (c) { switch (c) { case "u8": return 1; case "u16": return 2; case "u32": return 4; case "i8": return 1; case "i16": return 2; case "i32": return 4; case "f32": return 4; case "f64": return 8 } }; a.isInteger = function (c) { switch (c) { case "u8": case "u16": case "u32": case "i8": case "i16": case "i32": return !0; case "f32": case "f64": return !1 } };
        a.isSigned = function (c) { switch (c) { case "u8": case "u16": case "u32": return !1; case "i8": case "i16": case "i32": case "f32": case "f64": return !0 } }; a.maximumValue = function (c) { switch (c) { case "u8": return 255; case "u16": return 65535; case "u32": return 4294967295; case "i8": return 127; case "i16": return 32767; case "i32": return 2147483647; case "f32": return 3.402823E38; case "f64": return 1.79769E308 } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/View.glsl": function () {
      define(["exports",
        "../../../../../../chunks/mat4", "../../../../../../chunks/mat4f32"], function (a, w, c) {
          function q(y, n, p) { w.translate(u, p, n); y.setUniform3fv("localOrigin", n); y.setUniformMatrix4fv("view", u) } const u = c.create(); a.bindCameraPosition = function (y, n, p) { y.setUniform3f("camPos", p[3] - n[0], p[7] - n[1], p[11] - n[2]) }; a.bindNearFar = function (y, n) { y.setUniform2fv("nearFar", n) }; a.bindProjectionMatrix = function (y, n) { y.setUniformMatrix4fv("proj", n) }; a.bindView = function (y, n) { q(y, n.origin, n.camera.viewMatrix) }; a.bindViewCustomOrigin =
            q; a.bindViewport = function (y, n) { y.setUniform4fv("viewport", n.camera.fullViewport) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/GeometryUtil": function () {
      define("../../../../chunks/vec3 ../../../../chunks/vec3f32 ../../../../chunks/vec3f64 ../../../../geometry/support/plane ../../../../geometry/support/ray ./BufferVectorMath ./Geometry ./geometryDataUtils ./Util".split(" "), function (a, w, c, q, u, y, n, p, l) {
        const h = y.Vec3Compact; var b; (function (m) {
          const e = [[-.5, -.5,
            .5], [.5, -.5, .5], [.5, .5, .5], [-.5, .5, .5], [-.5, -.5, -.5], [.5, -.5, -.5], [.5, .5, -.5], [-.5, .5, -.5]], g = [0, 0, 1, -1, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, -1], x = [0, 0, 1, 0, 1, 1, 0, 1], k = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 0, 3, 3, 7, 4, 1, 5, 6, 6, 2, 1, 1, 0, 4, 4, 5, 1, 3, 2, 6, 6, 7, 3, 5, 4, 7, 7, 6, 5]), r = new Uint16Array(36); for (var A = 0; 6 > A; A++)for (let B = 0; 6 > B; B++)r[6 * A + B] = A; const z = new Uint16Array(36); for (A = 0; 6 > A; A++)z[6 * A] = 0, z[6 * A + 1] = 1, z[6 * A + 2] = 2, z[6 * A + 3] = 2, z[6 * A + 4] = 3, z[6 * A + 5] = 0; m.createGeometry = function (B) {
              Array.isArray(B) || (B = [B, B, B]); const C = Array(24);
              for (let D = 0; 8 > D; D++)C[3 * D] = e[D][0] * B[0], C[3 * D + 1] = e[D][1] * B[1], C[3 * D + 2] = e[D][2] * B[2]; return new n.Geometry([["position", { size: 3, data: C, exclusive: !0 }], ["normal", { size: 3, data: g }], ["uv0", { size: 2, data: x }]], [["position", k], ["normal", r], ["uv0", z]])
            }
        })(b || (b = {})); var d; (function (m) {
          const e = [[-.5, 0, -.5], [.5, 0, -.5], [.5, 0, .5], [-.5, 0, .5], [0, -.5, 0], [0, .5, 0]], g = [0, 1, -1, 1, 1, 0, 0, 1, 1, -1, 1, 0, 0, -1, -1, 1, -1, 0, 0, -1, 1, -1, -1, 0], x = new Uint16Array([5, 1, 0, 5, 2, 1, 5, 3, 2, 5, 0, 3, 4, 0, 1, 4, 1, 2, 4, 2, 3, 4, 3, 0]), k = new Uint16Array([0, 0, 0,
            1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7]); m.createGeometry = function (r) { Array.isArray(r) || (r = [r, r, r]); const A = Array(18); for (let z = 0; 6 > z; z++)A[3 * z] = e[z][0] * r[0], A[3 * z + 1] = e[z][1] * r[1], A[3 * z + 2] = e[z][2] * r[2]; return new n.Geometry([["position", { size: 3, data: A, exclusive: !0 }], ["normal", { size: 3, data: g }]], [["position", x], ["normal", k]]) }
        })(d || (d = {})); var f; (function (m) {
          const e = w.fromValues(-.5, 0, -.5), g = w.fromValues(.5, 0, -.5), x = w.fromValues(0, 0, .5), k = w.fromValues(0, .5, 0), r = w.create(), A = w.create(), z = w.create(),
          B = w.create(), C = w.create(); a.subtract(r, e, k); a.subtract(A, e, g); a.cross(z, r, A); a.normalize(z, z); a.subtract(r, g, k); a.subtract(A, g, x); a.cross(B, r, A); a.normalize(B, B); a.subtract(r, x, k); a.subtract(A, x, e); a.cross(C, r, A); a.normalize(C, C); const D = [e, g, x, k], E = [0, -1, 0, z[0], z[1], z[2], B[0], B[1], B[2], C[0], C[1], C[2]], H = [0, 1, 2, 3, 1, 0, 3, 2, 1, 3, 0, 2], J = [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3]; m.createGeometry = function (M) {
            Array.isArray(M) || (M = [M, M, M]); const F = Array(12); for (let K = 0; 4 > K; K++)F[3 * K] = D[K][0] * M[0], F[3 * K + 1] = D[K][1] * M[1], F[3 *
              K + 2] = D[K][2] * M[2]; return new n.Geometry([["position", { size: 3, data: F, exclusive: !0 }], ["normal", { size: 3, data: E }]], [["position", new Uint16Array(H)], ["normal", new Uint16Array(J)]])
          }
        })(f || (f = {})); var t; (function (m) {
          function e(k, r, A, z, B) { if (Math.abs(a.dot(r, k)) > B) return !1; a.cross(A, k, r); a.normalize(A, A); a.cross(z, A, k); a.normalize(z, z); return !0 } function g(k, r, A, z, B, C, D) { return e(k, r, B, C, D) || e(k, A, B, C, D) || e(k, z, B, C, D) } m.createBoxGeometry = b.createGeometry; m.createDiamondGeometry = d.createGeometry; m.createTetrahedronGeometry =
            f.createGeometry; m.createSphereGeometry = function (k, r, A, z = { uv: !0 }) {
              var B = -Math.PI, C = 2 * Math.PI, D = -Math.PI / 2, E = Math.PI; r = Math.max(3, Math.floor(r)); const H = Math.max(2, Math.floor(A)); var J = (r + 1) * (H + 1); A = new Float32Array(3 * J); const M = new Float32Array(3 * J); J = new Float32Array(2 * J); const F = []; let K = 0; for (var P = 0; P <= H; P++) {
                var L = []; const G = P / H, I = D + G * E, O = Math.cos(I); for (let R = 0; R <= r; R++) {
                  const S = R / r; var N = B + S * C; const Q = Math.cos(N) * O, T = Math.sin(I); N = -Math.sin(N) * O; A[3 * K] = Q * k; A[3 * K + 1] = T * k; A[3 * K + 2] = N * k; M[3 * K] =
                    Q; M[3 * K + 1] = T; M[3 * K + 2] = N; J[2 * K] = S; J[2 * K + 1] = G; L.push(K); ++K
                } F.push(L)
              } k = new Uint32Array(2 * r * (H - 1) * 3); K = 0; for (B = 0; B < H; B++)for (C = 0; C < r; C++)D = F[B][C], E = F[B][C + 1], P = F[B + 1][C + 1], L = F[B + 1][C], 0 === B ? (k[K++] = D, k[K++] = P, k[K++] = L) : B === H - 1 ? (k[K++] = D, k[K++] = E, k[K++] = P) : (k[K++] = D, k[K++] = E, k[K++] = P, k[K++] = P, k[K++] = L, k[K++] = D); r = [["position", k], ["normal", k]]; A = [["position", { size: 3, data: A, exclusive: !0 }], ["normal", { size: 3, data: M, exclusive: !0 }]]; z.uv && (A.push(["uv0", { size: 2, data: J, exclusive: !0 }]), r.push(["uv0", k])); z.offset &&
                (r[0][0] = "offset", A[0][0] = "offset", r.push(["position", new Uint32Array(k.length)]), A.push(["position", { size: 3, data: Float64Array.from(z.offset), exclusive: !0 }])); return new n.Geometry(A, r)
            }; m.createPolySphereGeometry = function (k, r, A) {
              function z(E, H) { E > H && ([E, H] = [H, E]); const J = E.toString() + "." + H.toString(); if (D[J]) return D[J]; let M = B.length; B.length += 3; h.add(B, 3 * E, B, 3 * H, B, M); h.scale(B, M, k / h.length(B, M)); M /= 3; return D[J] = M } let B; A ? (B = [0, -1, 0, 1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0, 1, 0], A = new Uint32Array([0, 1, 2, 0, 2,
                3, 0, 3, 4, 0, 4, 1, 1, 5, 2, 2, 5, 3, 3, 5, 4, 4, 5, 1])) : (A = k * (1 + Math.sqrt(5)) / 2, B = [-k, A, 0, k, A, 0, -k, -A, 0, k, -A, 0, 0, -k, A, 0, k, A, 0, -k, -A, 0, k, -A, A, 0, -k, A, 0, k, -A, 0, -k, -A, 0, k], A = new Uint32Array([0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1])); for (var C = 0; C < B.length; C += 3)h.scale(B, C, k / h.length(B, C)); let D = {}; for (C = 0; C < r; C++) {
                  const E = A.length, H = new Uint32Array(4 * E); for (let J = 0; J < E; J += 3) {
                    const M = A[J], F = A[J + 1], K = A[J + 2], P = z(M, F), L = z(F, K), N =
                      z(K, M), G = 4 * J; H[G] = M; H[G + 1] = P; H[G + 2] = N; H[G + 3] = F; H[G + 4] = L; H[G + 5] = P; H[G + 6] = K; H[G + 7] = N; H[G + 8] = L; H[G + 9] = P; H[G + 10] = L; H[G + 11] = N
                  } A = H; D = {}
                } r = new Float32Array(B); for (C = 0; C < r.length; C += 3)h.normalize(r, C); A = [["position", A], ["normal", A]]; r = [["position", { size: 3, data: new Float32Array(B), exclusive: !0 }], ["normal", { size: 3, data: r, exclusive: !0 }]]; return new n.Geometry(r, A)
            }; m.createPointGeometry = function (k, r, A, z, B, C, D) {
              r = r ? [r[0], r[1], r[2]] : [0, 0, 0]; k = k ? [k[0], k[1], k[2]] : [0, 0, 1]; C = C || [0, 0]; A = [["position", {
                size: 3, data: r,
                exclusive: !0
              }], ["normal", { size: 3, data: k, exclusive: !0 }], ["uv0", { size: C.length, data: C }], ["color", { size: 4, data: A ? [255 * A[0], 255 * A[1], 255 * A[2], 3 < A.length ? 255 * A[3] : 255] : [255, 255, 255, 255], exclusive: !0 }], ["size", { size: 2, data: null != z && 2 === z.length ? z : [1, 1] }]]; null != B && (B = new Float32Array([B[0], B[1], B[2], B[3]]), A.push(["auxpos1", { size: 4, data: B }])); null != D && (D = new Float32Array([D[0], D[1], D[2], D[3]]), A.push(["auxpos2", { size: 4, data: D }])); return new n.Geometry(A, null, 1)
            }; m.updatePointGeometry = function (k, r, A, z, B,
              C, D, E) {
                if (null != k) { const { data: H } = E.getMutableAttribute("normal"); H[0] = k[0]; H[1] = k[1]; H[2] = k[2] } null != r && ({ data: k } = E.getMutableAttribute("position"), k[0] = r[0], k[1] = r[1], k[2] = r[2]); null != A && ({ data: r } = E.getMutableAttribute("color"), r[0] = A[0], r[1] = A[1], r[2] = A[2], r[3] = A[3]); null != z && ({ data: A } = E.getMutableAttribute("size"), A[0] = z[0], A[1] = z[1]); null != B && ({ data: z } = E.getMutableAttribute("auxpos1"), z[0] = B[0], z[1] = B[1], z[2] = B[2], z[3] = B[3]); null != C && ({ data: B } = E.getMutableAttribute("uv0"), B[0] = C[0], B[1] = C[1]);
              null != D && ({ data: C } = E.getMutableAttribute("auxpos2"), C[0] = D[0], C[1] = D[1], C[2] = D[2], C[3] = D[3])
            }; m.createPointArrayGeometry = function (k, r) {
              const A = new Float32Array(3 * k.length), z = new Float32Array(r ? 3 * k.length : 3), B = new Uint32Array(k.length), C = new Uint32Array(k.length); for (let D = 0; D < k.length; D++)A[3 * D] = k[D][0], A[3 * D + 1] = k[D][1], A[3 * D + 2] = k[D][2], r && (z[3 * D] = r[D][0], z[3 * D + 1] = r[D][1], z[3 * D + 2] = r[D][2]), B[D] = D, C[D] = 0; r || (z[0] = 0, z[1] = 1, z[2] = 0); return new n.Geometry([["position", { size: 3, data: A, exclusive: !0 }], ["normal",
                { size: 3, data: z, exclusive: !0 }], ["uv0", { size: 2, data: [0, 0], exclusive: !0 }]], [["position", B], ["normal", r ? B : C], ["uv0", C]], 1)
            }; m.createTriangleGeometry = function () { const k = new Uint16Array([0, 1, 2]), r = new Uint16Array([0, 0, 0]), A = new Uint16Array([0, 0, 0]); return new n.Geometry([["position", { size: 3, data: [0, 0, 0, 0, 0, 100, 100, 0, 0], exclusive: !0 }], ["normal", { size: 3, data: [0, 1, 0], exclusive: !0 }], ["uv0", { size: 2, data: [0, 0], exclusive: !0 }]], [["position", k], ["normal", r], ["uv0", A]]) }; const x = [[-1, -1, 0], [1, -1, 0], [1, 1, 0], [-1, 1,
              0]]; m.createSquareGeometry = function (k = x) { const r = Array(12); for (var A = 0; 4 > A; A++)for (let z = 0; 3 > z; z++)r[3 * A + z] = k[A][z]; k = new Uint32Array([0, 1, 2, 2, 3, 0]); A = new Uint32Array([0, 0, 0, 0, 0, 0]); return new n.Geometry([["position", { size: 3, data: r, exclusive: !0 }], ["normal", { size: 3, data: [0, 0, 1], exclusive: !0 }], ["uv0", { size: 2, data: [0, 0, 1, 0, 1, 1, 0, 1], exclusive: !0 }], ["color", { size: 4, data: [255, 255, 255, 255], exclusive: !0 }]], [["position", k], ["normal", A], ["uv0", k], ["color", A]]) }; m.createConeGeometry = function (k, r, A, z, B = !0, C =
                !0) {
                  var D = 0, E = w.fromValues(0, D, 0), H = w.fromValues(0, D + k, 0), J = w.fromValues(0, -1, 0), M = w.fromValues(0, 1, 0); z && (D = k, H = w.fromValues(0, 0, 0), E = w.fromValues(0, D, 0), J = w.fromValues(0, 1, 0), M = w.fromValues(0, -1, 0)); E = [H, E]; J = [J, M]; M = A + 2; H = Math.sqrt(k * k + r * r); if (z) for (z = A - 1; 0 <= z; z--) { var F = 2 * Math.PI / A * z, K = w.fromValues(Math.cos(F) * r, D, Math.sin(F) * r); E.push(K); F = w.fromValues(k * Math.cos(F) / H, -r / H, k * Math.sin(F) / H); J.push(F) } else for (z = 0; z < A; z++)F = 2 * Math.PI / A * z, K = w.fromValues(Math.cos(F) * r, D, Math.sin(F) * r), E.push(K),
                    F = w.fromValues(k * Math.cos(F) / H, r / H, k * Math.sin(F) / H), J.push(F); k = new Uint32Array(6 * (A + 2)); A = new Uint32Array(6 * (A + 2)); D = r = 0; if (B) { for (B = 3; B < E.length; B++)k[r++] = 1, k[r++] = B - 1, k[r++] = B, A[D++] = 0, A[D++] = 0, A[D++] = 0; k[r++] = E.length - 1; k[r++] = 2; k[r++] = 1; A[D++] = 0; A[D++] = 0; A[D++] = 0 } if (C) { for (C = 3; C < E.length; C++)k[r++] = C, k[r++] = C - 1, k[r++] = 0, A[D++] = C, A[D++] = C - 1, A[D++] = 1; k[r++] = 0; k[r++] = 2; k[r++] = E.length - 1; A[D++] = 1; A[D++] = 2; A[D++] = J.length - 1 } C = new Float32Array(3 * M); for (B = 0; B < M; B++)C[3 * B] = E[B][0], C[3 * B + 1] = E[B][1],
                      C[3 * B + 2] = E[B][2]; E = new Float32Array(3 * M); for (B = 0; B < M; B++)E[3 * B] = J[B][0], E[3 * B + 1] = J[B][1], E[3 * B + 2] = J[B][2]; return new n.Geometry([["position", { size: 3, data: C, exclusive: !0 }], ["normal", { size: 3, data: E, exclusive: !0 }]], [["position", k], ["normal", A]])
              }; m.createCylinderGeometry = function (k, r, A, z, B, C) {
                z = z ? w.clone(z) : w.fromValues(1, 0, 0); B = B ? w.clone(B) : w.fromValues(0, 0, 0); C = null == C ? !0 : C; var D = w.create(); a.normalize(D, z); const E = w.create(); a.scale(E, D, Math.abs(k)); const H = w.create(); a.scale(H, E, -.5); a.add(H, H, B);
                const J = w.fromValues(0, 1, 0); .2 > Math.abs(1 - a.dot(D, J)) && a.set(J, 0, 0, 1); const M = w.create(); a.cross(M, D, J); a.normalize(M, M); a.cross(J, M, D); k = 2 * A + (C ? 2 : 0); B = A + (C ? 2 : 0); z = new Float32Array(3 * k); const F = new Float32Array(3 * B), K = new Float32Array(2 * k), P = new Uint32Array(3 * A * (C ? 4 : 2)), L = new Uint32Array(3 * A * (C ? 4 : 2)); C && (z[3 * (k - 2)] = H[0], z[3 * (k - 2) + 1] = H[1], z[3 * (k - 2) + 2] = H[2], K[2 * (k - 2)] = 0, K[2 * (k - 2) + 1] = 0, z[3 * (k - 1)] = z[3 * (k - 2)] + E[0], z[3 * (k - 1) + 1] = z[3 * (k - 2) + 1] + E[1], z[3 * (k - 1) + 2] = z[3 * (k - 2) + 2] + E[2], K[2 * (k - 1)] = 1, K[2 * (k - 1) + 1] =
                  1, F[3 * (B - 2)] = -D[0], F[3 * (B - 2) + 1] = -D[1], F[3 * (B - 2) + 2] = -D[2], F[3 * (B - 1)] = D[0], F[3 * (B - 1) + 1] = D[1], F[3 * (B - 1) + 2] = D[2]); D = function (R, S, Q) { P[R] = S; L[R] = Q }; let N = 0; const G = w.create(), I = w.create(); for (let R = 0; R < A; R++) {
                    var O = 2 * Math.PI / A * R; a.scale(G, J, Math.sin(O)); a.scale(I, M, Math.cos(O)); a.add(G, G, I); F[3 * R] = G[0]; F[3 * R + 1] = G[1]; F[3 * R + 2] = G[2]; a.scale(G, G, r); a.add(G, G, H); z[3 * R] = G[0]; z[3 * R + 1] = G[1]; z[3 * R + 2] = G[2]; K[2 * R] = R / A; K[2 * R + 1] = 0; z[3 * (R + A)] = z[3 * R] + E[0]; z[3 * (R + A) + 1] = z[3 * R + 1] + E[1]; z[3 * (R + A) + 2] = z[3 * R + 2] + E[2]; K[2 * (R +
                      A)] = R / A; K[2 * R + 1] = 1; O = (R + 1) % A; D(N++, R, R); D(N++, R + A, R); D(N++, O, O); D(N++, O, O); D(N++, R + A, R); D(N++, O + A, O)
                  } if (C) { for (r = 0; r < A; r++)C = (r + 1) % A, D(N++, k - 2, B - 2), D(N++, r, B - 2), D(N++, C, B - 2); for (r = 0; r < A; r++)C = (r + 1) % A, D(N++, r + A, B - 1), D(N++, k - 1, B - 1), D(N++, C + A, B - 1) } return new n.Geometry([["position", { size: 3, data: z, exclusive: !0 }], ["normal", { size: 3, data: F, exclusive: !0 }], ["uv0", { size: 2, data: K, exclusive: !0 }]], [["position", P], ["normal", L], ["uv0", P]])
              }; m.createTubeGeometry = function (k, r, A, z, B) {
                A = A || 10; z = null != z ? z : !0; l.assert(1 <
                  k.length); const C = [], D = []; for (let E = 0; E < A; E++) { C.push([0, -E - 1, -((E + 1) % A) - 1]); const H = E / A * 2 * Math.PI; D.push([Math.cos(H) * r, Math.sin(H) * r]) } return m.createPathExtrusionGeometry(D, k, [[0, 0, 0]], C, z, B)
              }; m.createPathExtrusionGeometry = function (k, r, A, z, B, C = w.fromValues(0, 0, 0)) {
                var D = k.length; const E = new Float32Array(r.length * D * 3 + (6 * A.length || 0)), H = new Float32Array(r.length * D * 3 + (A ? 6 : 0)); var J = (r.length - 1) * D * 6 + 6 * z.length; const M = new Uint32Array(J); J = new Uint32Array(J); let F = 0; var K = 0; let P = 0, L = 0; const N = w.create(),
                  G = w.create(), I = w.create(), O = w.create(), R = w.create(), S = w.create(), Q = w.create(), T = c.create(), da = w.create(), Y = w.create(), fa = w.create(), ha = w.create(), ka = w.create(), ea = q.create(); a.set(da, 0, 1, 0); a.subtract(G, r[1], r[0]); a.normalize(G, G); B ? (a.add(T, r[0], C), a.normalize(I, T)) : a.set(I, 0, 0, 1); g(G, I, da, da, R, I, .99619469809); a.copy(O, I); a.copy(ha, R); for (var ba = 0; ba < A.length; ba++)a.scale(S, R, A[ba][0]), a.scale(T, I, A[ba][2]), a.add(S, S, T), a.add(S, S, r[0]), E[F++] = S[0], E[F++] = S[1], E[F++] = S[2]; H[K++] = -G[0]; H[K++] = -G[1];
                H[K++] = -G[2]; for (ba = 0; ba < z.length; ba++)M[P++] = 0 < z[ba][0] ? z[ba][0] : -z[ba][0] - 1 + A.length, M[P++] = 0 < z[ba][1] ? z[ba][1] : -z[ba][1] - 1 + A.length, M[P++] = 0 < z[ba][2] ? z[ba][2] : -z[ba][2] - 1 + A.length, J[L++] = 0, J[L++] = 0, J[L++] = 0; ba = A.length; const aa = A.length - 1; for (let U = 0; U < r.length; U++) {
                  let X = !1; 0 < U && (a.copy(N, G), U < r.length - 1 ? (a.subtract(G, r[U + 1], r[U]), a.normalize(G, G)) : X = !0, a.add(Y, N, G), a.normalize(Y, Y), a.add(fa, r[U - 1], O), q.fromPositionAndNormal(r[U], Y, ea), q.intersectRay(ea, u.wrap(fa, N), T) ? (a.subtract(T, T, r[U]), a.normalize(I,
                    T), a.cross(R, Y, I), a.normalize(R, R)) : g(Y, O, ha, da, R, I, .99619469809), a.copy(O, I), a.copy(ha, R)); B && (a.add(T, r[U], C), a.normalize(ka, T)); for (let Z = 0; Z < D; Z++)if (a.scale(S, R, k[Z][0]), a.scale(T, I, k[Z][1]), a.add(S, S, T), a.normalize(Q, S), H[K++] = Q[0], H[K++] = Q[1], H[K++] = Q[2], a.add(S, S, r[U]), E[F++] = S[0], E[F++] = S[1], E[F++] = S[2], !X) { var W = (Z + 1) % D; M[P++] = ba + Z; M[P++] = ba + D + Z; M[P++] = ba + W; M[P++] = ba + W; M[P++] = ba + D + Z; M[P++] = ba + D + W; for (W = 0; 6 > W; W++)J[L++] = M[P - 6 + W] - aa } ba += D
                } k = r[r.length - 1]; for (r = 0; r < A.length; r++)a.scale(S, R,
                  A[r][0]), a.scale(T, I, A[r][1]), a.add(S, S, T), a.add(S, S, k), E[F++] = S[0], E[F++] = S[1], E[F++] = S[2]; A = K / 3; H[K++] = G[0]; H[K++] = G[1]; H[K++] = G[2]; D = ba - D; for (K = 0; K < z.length; K++)M[P++] = 0 <= z[K][0] ? ba + z[K][0] : -z[K][0] - 1 + D, M[P++] = 0 <= z[K][2] ? ba + z[K][2] : -z[K][2] - 1 + D, M[P++] = 0 <= z[K][1] ? ba + z[K][1] : -z[K][1] - 1 + D, J[L++] = A, J[L++] = A, J[L++] = A; return new n.Geometry([["position", { size: 3, data: E, exclusive: !0 }], ["normal", { size: 3, data: H, exclusive: !0 }]], [["position", M], ["normal", J]])
              }; m.createPolylineGeometry = function (k, r, A) {
                l.assert(1 <
                  k.length, "createPolylineGeometry(): polyline needs at least 2 points"); l.assert(3 === k[0].length, "createPolylineGeometry(): malformed vertex"); l.assert(null == r || r.length === k.length, "createPolylineGeometry: need same number of points and normals"); l.assert(null == r || 3 === r[0].length, "createPolylineGeometry(): malformed normal"); var z = new Float64Array(3 * k.length); const B = new Uint32Array(2 * (k.length - 1)); var C = 0, D = 0; for (var E = 0; E < k.length; E++) { for (var H = 0; 3 > H; H++)z[C++] = k[E][H]; 0 < E && (B[D++] = E - 1, B[D++] = E) } C =
                    []; D = []; C.push(["position", B]); D.push(["position", { size: 3, data: z, exclusive: !0 }]); if (r) { z = new Float32Array(3 * r.length); E = 0; for (H = 0; H < k.length; H++)for (let J = 0; 3 > J; J++)z[E++] = r[H][J]; C.push(["normal", B]); D.push(["normal", { size: 3, data: z, exclusive: !0 }]) } A && (D.push(["color", { size: 4, data: A }]), C.push(["color", p.generateDefaultIndexArray(A.length / 4)])); return new n.Geometry(D, C, 2)
              }; m.createExtrudedTriangle = function (k, r, A, z, B = 0) {
                const C = Array(18); k = [[-r, B, z / 2], [A, B, z / 2], [0, k + B, z / 2], [-r, B, -z / 2], [A, B, -z / 2], [0,
                  k + B, -z / 2]]; r = new Uint16Array([0, 1, 2, 3, 0, 2, 2, 5, 3, 1, 4, 5, 5, 2, 1, 1, 0, 3, 3, 4, 1, 4, 3, 5]); for (A = 0; 6 > A; A++)C[3 * A] = k[A][0], C[3 * A + 1] = k[A][1], C[3 * A + 2] = k[A][2]; return new n.Geometry([["position", { size: 3, data: C, exclusive: !0 }]], [["position", r]])
              }; m.transformInPlace = function (k, r) { k = k.getMutableAttribute("position").data; for (let A = 0; A < k.length; A += 3)a.set(v, k[A], k[A + 1], k[A + 2]), a.transformMat4(v, v, r), k[A] = v[0], k[A + 1] = v[1], k[A + 2] = v[2] }; m.cgToGIS = function (k, r = k) {
                var A = k.vertexAttributes; k = A.get("position").data; if (A = A.get("normal").data) {
                  var z =
                    r.getMutableAttribute("normal").data; for (var B = 0; B < A.length; B += 3) { const C = A[B + 1]; z[B + 1] = -A[B + 2]; z[B + 2] = C }
                } if (k) for (A = r.getMutableAttribute("position").data, z = 0; z < k.length; z += 3)B = k[z + 1], A[z + 1] = -k[z + 2], A[z + 2] = B; return r
              }; m.makeOrthoBasisDirUp = e; m.makeOrthoBasisDirUpFallback = g
        })(t || (t = {})); const v = w.create(); return t
      })
    }, "esri/views/3d/webgl-engine/lib/BufferVectorMath": function () {
      define(["exports"], function (a) {
      a.Vec3Compact = void 0; (function (w) {
      w.length = function (c, q) {
        const u = c[q], y = c[q + 1]; c = c[q + 2]; return Math.sqrt(u *
          u + y * y + c * c)
      }; w.normalize = function (c, q) { var u = c[q]; const y = c[q + 1], n = c[q + 2]; u = 1 / Math.sqrt(u * u + y * y + n * n); c[q] *= u; c[q + 1] *= u; c[q + 2] *= u }; w.scale = function (c, q, u) { c[q] *= u; c[q + 1] *= u; c[q + 2] *= u }; w.add = function (c, q, u, y, n, p = q) { n = n || c; n[p] = c[q] + u[y]; n[p + 1] = c[q + 1] + u[y + 1]; n[p + 2] = c[q + 2] + u[y + 2] }; w.subtract = function (c, q, u, y, n, p = q) { n = n || c; n[p] = c[q] - u[y]; n[p + 1] = c[q + 1] - u[y + 1]; n[p + 2] = c[q + 2] - u[y + 2] }
      })(a.Vec3Compact || (a.Vec3Compact = {})); Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/Geometry": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ./BoundingInfo ./ContentObject ./geometryDataUtils ./Util".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(l) { if (l.BYTES_PER_ELEMENT === Uint16Array.BYTES_PER_ELEMENT) return l; for (const h of l) if (65536 <= h) return l; return new Uint16Array(l) } u = function (l) {
            function h(d, f = [], t = 0, v = -1) {
              var m = l.call(this) || this; m._primitiveType = t; m.edgeIndicesLength = v; m.type = 2; m._vertexAttributes = new Map; m._indices = new Map; m._boundingInfo = null; for (const [e, g] of d) g && m._vertexAttributes.set(e, { ...g }); if (null == f || 0 === f.length) {
                d = m._vertexAttributes.values().next().value; d = null == d ? 0 : d.data.length /
                  d.size; f = y.generateDefaultIndexArray(d); m.edgeIndicesLength = 0 > m.edgeIndicesLength ? d : m.edgeIndicesLength; for (const e of m._vertexAttributes.keys()) m._indices.set(e, f)
              } else for (const [e, g] of f) g && (m._indices.set(e, p(g)), "position" === e && (m.edgeIndicesLength = 0 > m.edgeIndicesLength ? m._indices.get(e).length : m.edgeIndicesLength)); return m
            } w._inheritsLoose(h, l); var b = h.prototype; b.getMutableAttribute = function (d) { (d = this._vertexAttributes.get(d)) && !d.exclusive && (d.data = Array.from(d.data), d.exclusive = !0); return d };
            b.computeAttachmentOrigin = function (d) { return 0 === this.primitiveType ? this.computeAttachmentOriginTriangles(d) : this.computeAttachmentOriginPoints(d) }; b.computeAttachmentOriginTriangles = function (d) { const f = this.indices.get("position"), t = this.vertexAttributes.get("position"); return y.computeAttachmentOriginTriangles(t, f, d) }; b.computeAttachmentOriginPoints = function (d) { const f = this.indices.get("position"), t = this.vertexAttributes.get("position"); return y.computeAttachmentOriginPoints(t, f, d) }; b.invalidateBoundingInfo =
              function () { this._boundingInfo = null }; b._calculateBoundingInfo = function () { const d = this.indices.get("position"); if (0 === d.length) return null; const f = 0 === this.primitiveType ? 3 : 1; n.assert(0 === d.length % f, "Indexing error: " + d.length + " not divisible by " + f); const t = y.generateDefaultIndexArray(d.length / f), v = this.vertexAttributes.get("position"); return new q.BoundingInfo(t, f, d, v) }; w._createClass(h, [{ key: "vertexAttributes", get: function () { return this._vertexAttributes } }, { key: "indices", get: function () { return this._indices } },
              { key: "indexCount", get: function () { const d = this._indices.values().next().value; return d ? d.length : 0 } }, { key: "primitiveType", get: function () { return this._primitiveType } }, { key: "faceCount", get: function () { return this.indexCount / 3 } }, { key: "boundingInfo", get: function () { c.isNone(this._boundingInfo) && (this._boundingInfo = this._calculateBoundingInfo()); return this._boundingInfo } }]); return h
          }(u.ContentObject); a.Geometry = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/BoundingInfo": function () {
      define(["exports",
        "../../../../core/PooledArray", "../../../../chunks/vec3", "../../../../chunks/vec3f64", "./Util"], function (a, w, c, q, u) {
          let y = function () {
            function p(h, b, d, f) {
            this.primitiveIndices = h; this._numIndexPerPrimitive = b; this.indices = d; this.position = f; this.center = q.create(); u.assert(1 <= h.length); u.assert(0 === d.length % this._numIndexPerPrimitive); u.assert(d.length >= h.length * this._numIndexPerPrimitive); u.assert(3 === f.size || 4 === f.size); const { data: t, size: v } = f; f = h.length; b = v * d[this._numIndexPerPrimitive * h[0]]; n.clear();
              n.push(b); this.bbMin = q.fromValues(t[b], t[b + 1], t[b + 2]); this.bbMax = q.clone(this.bbMin); for (var m = 0; m < f; ++m) { var e = this._numIndexPerPrimitive * h[m]; for (var g = 0; g < this._numIndexPerPrimitive; ++g) { b = v * d[e + g]; n.push(b); let x = t[b]; this.bbMin[0] = Math.min(x, this.bbMin[0]); this.bbMax[0] = Math.max(x, this.bbMax[0]); x = t[b + 1]; this.bbMin[1] = Math.min(x, this.bbMin[1]); this.bbMax[1] = Math.max(x, this.bbMax[1]); x = t[b + 2]; this.bbMin[2] = Math.min(x, this.bbMin[2]); this.bbMax[2] = Math.max(x, this.bbMax[2]) } } c.lerp(this.center, this.bbMin,
                this.bbMax, .5); this.radius = .5 * Math.max(Math.max(this.bbMax[0] - this.bbMin[0], this.bbMax[1] - this.bbMin[1]), this.bbMax[2] - this.bbMin[2]); h = this.radius * this.radius; for (d = 0; d < n.length; ++d)b = n.getItemAt(d), f = t[b] - this.center[0], m = t[b + 1] - this.center[1], b = t[b + 2] - this.center[2], e = f * f + m * m + b * b, e <= h || (e = Math.sqrt(e), g = .5 * (e - this.radius), this.radius += g, h = this.radius * this.radius, e = g / e, this.center[0] += f * e, this.center[1] += m * e, this.center[2] += b * e); n.clear()
            } var l = p.prototype; l.getCenter = function () { return this.center };
            l.getBSRadius = function () { return this.radius }; l.getBBMin = function () { return this.bbMin }; l.getBBMax = function () { return this.bbMax }; l.getChildren = function () {
              if (this._children) return this._children; if (1 < c.squaredDistance(this.bbMin, this.bbMax)) {
                var h = c.lerp(q.create(), this.bbMin, this.bbMax, .5), b = this.primitiveIndices.length; const v = new Uint8Array(b), m = Array(8); for (var d = 0; 8 > d; ++d)m[d] = 0; const { data: e, size: g } = this.position; for (d = 0; d < b; ++d) {
                  var f = 0; const x = this._numIndexPerPrimitive * this.primitiveIndices[d];
                  var t = g * this.indices[x]; let k = e[t], r = e[t + 1], A = e[t + 2]; for (let z = 1; z < this._numIndexPerPrimitive; ++z) { t = g * this.indices[x + z]; const B = e[t], C = e[t + 1]; t = e[t + 2]; B < k && (k = B); C < r && (r = C); t < A && (A = t) } k < h[0] && (f |= 1); r < h[1] && (f |= 2); A < h[2] && (f |= 4); v[d] = f; ++m[f]
                } h = 0; for (d = 0; 8 > d; ++d)0 < m[d] && ++h; if (2 > h) return; h = Array(8); for (d = 0; 8 > d; ++d)h[d] = 0 < m[d] ? new Uint32Array(m[d]) : void 0; for (d = 0; 8 > d; ++d)m[d] = 0; for (d = 0; d < b; ++d)f = v[d], h[f][m[f]++] = this.primitiveIndices[d]; this._children = Array(8); for (b = 0; 8 > b; ++b)void 0 !== h[b] && (this._children[b] =
                  new p(h[b], this._numIndexPerPrimitive, this.indices, this.position))
              } return this._children
            }; p.prune = function () { n.prune() }; return p
          }(); const n = new w({ deallocator: null }); a.BoundingInfo = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/Util": function () {
      define("exports ../../../../core/mathUtils ../../../../chunks/mat4 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64".split(" "), function (a,
        w, c, q, u, y, n, p) {
          function l(f, t) { if (!f) throw t = t || "assert", f = Error(t), f.stack && console.log(f.stack), new d(t); } function h(f, t) { f[12] = t[0]; f[13] = t[1]; f[14] = t[2] } const b = p.create(); let d = function () { function f(t) { this.message = t } f.prototype.toString = function () { return `AssertException: ${this.message}` }; return f }(); a.AssertException = d; a.assert = l; a.createTranslationMatrix = function (f, t) { f = c.identity(f); h(f, t); return f }; a.dec2hex = function (f) { f = f.toString(16); return "00000000".substr(0, 8 - f.length) + f }; a.encodeInt16 =
            function (f) { return w.clamp(Math.round(32767 * f), -32767, 32767) }; a.encodeNormal = function (f, t) { const v = Math.abs(f[0]), m = Math.abs(f[1]), e = 1 / (v + m + Math.abs(f[2])), g = Math.min(f[2] * e, 0); t[0] = (0 > f[0] ? -1 : 1) * (v * e - g); t[1] = (0 > f[1] ? -1 : 1) * (m * e - g) }; a.fallbackIfUndefined = function (f, t) { return void 0 === f ? t : f }; a.fovd2fovx = function (f, t, v) { return 2 * Math.atan(t * Math.tan(.5 * f) / Math.sqrt(t * t + v * v)) }; a.fovd2fovy = function (f, t, v) { return 2 * Math.atan(v * Math.tan(.5 * f) / Math.sqrt(t * t + v * v)) }; a.fovx2fovd = function (f, t, v) {
              return 2 * Math.atan(Math.sqrt(t *
                t + v * v) * Math.tan(.5 * f) / t)
            }; a.fovx2fovy = function (f, t, v) { return 2 * Math.atan(v * Math.tan(.5 * f) / t) }; a.fovy2fovd = function (f, t, v) { return 2 * Math.atan(Math.sqrt(t * t + v * v) * Math.tan(.5 * f) / v) }; a.fovy2fovx = function (f, t, v) { return 2 * Math.atan(t * Math.tan(.5 * f) / v) }; a.getFirstObjectKey = function (f) { for (const t in f) return t }; a.getMatrixTranslation = function (f, t = y.create()) { t[0] = f[12]; t[1] = f[13]; t[2] = f[14]; return t }; a.hex2rgb = function (f) { f = Math.floor(f); return [(f >> 16 & 255) / 255, (f >> 8 & 255) / 255, (f & 255) / 255] }; a.inverseProjectionInfo =
              function (f, t, v, m, e) { 0 === f[11] ? (m[0] = 2 / (t * f[0]), m[1] = 2 / (v * f[5]), m[2] = (1 + f[12]) / f[0], m[3] = (1 + f[13]) / f[5], q.set(e, 0, 1)) : (m[0] = -2 / (t * f[0]), m[1] = -2 / (v * f[5]), m[2] = (1 - f[8]) / f[0], m[3] = (1 - f[9]) / f[5], q.set(e, 1, 0)) }; a.isTranslationMatrix = function (f) { return 1 === f[0] && 0 === f[1] && 0 === f[2] && 0 === f[3] && 0 === f[4] && 1 === f[5] && 0 === f[6] && 0 === f[7] && 0 === f[8] && 0 === f[9] && 1 === f[10] && 0 === f[11] && 1 === f[15] }; a.logWithBase = function (f, t) { return Math.log(f) / Math.log(t) }; a.objectEmpty = function (f) { for (const t in f) return !1; return !0 };
        a.project = function (f, t, v, m, e) { e || (e = f); b[0] = f[0]; b[1] = f[1]; b[2] = f[2]; b[3] = 1; n.transformMat4(b, b, t); 2 < e.length && (e[2] = -b[2]); n.transformMat4(b, b, v); l(0 !== b[3]); e[0] = b[0] / b[3]; e[1] = b[1] / b[3]; e[2] = b[2] / b[3]; e[0] = (.5 * e[0] + .5) * m[2] + m[0]; e[1] = (.5 * e[1] + .5) * m[3] + m[1] }; a.rayBoxTest = function (f, t, v, m) {
          let e, g = (v[0] - f[0]) / t[0], x = (m[0] - f[0]) / t[0]; g > x && (e = g, g = x, x = e); let k = (v[1] - f[1]) / t[1], r = (m[1] - f[1]) / t[1]; k > r && (e = k, k = r, r = e); if (g > r || k > x) return !1; k > g && (g = k); r < x && (x = r); v = (v[2] - f[2]) / t[2]; f = (m[2] - f[2]) / t[2]; v > f &&
            (e = v, v = f, f = e); if (g > f || v > x) return !1; f < x && (x = f); return 0 > x ? !1 : !0
        }; a.rayRay2D = function (f, t, v, m, e, g = u.create()) { const x = (m[e] - v[e]) * (t[0] - f[0]) - (m[0] - v[0]) * (t[e] - f[e]); if (0 === x) return !1; v = ((m[0] - v[0]) * (f[e] - v[e]) - (m[e] - v[e]) * (f[0] - v[0])) / x; g[0] = f[0] + v * (t[0] - f[0]); g[1] = f[e] + v * (t[e] - f[e]); return !0 }; a.rayTriangle3D = function (f, t, v, m, e, g, x, k, r = y.create()) {
          var A = m[x] - v[g]; const z = m[x + 1] - v[g + 1], B = m[x + 2] - v[g + 2]; m = e[k] - v[g]; x = e[k + 1] - v[g + 1]; e = e[k + 2] - v[g + 2]; const C = t[1] * e - x * t[2], D = t[2] * m - e * t[0], E = t[0] * x - m * t[1];
          k = A * C + z * D + B * E; if (-1E-5 < k && 1E-5 > k) return !1; k = 1 / k; const H = f[0] - v[g], J = f[1] - v[g + 1]; f = f[2] - v[g + 2]; r[1] = k * (H * C + J * D + f * E); if (0 > r[1] || 1 < r[1]) return !1; v = J * B - z * f; f = f * A - B * H; A = H * z - A * J; r[2] = k * (t[0] * v + t[1] * f + t[2] * A); if (0 > r[2] || 1 < r[1] + r[2]) return !1; r[0] = k * (m * v + x * f + e * A); return !0
        }; a.rgb2hex = function (f) { const t = w.clamp(Math.round(255 * f[0]), 0, 255), v = w.clamp(Math.round(255 * f[1]), 0, 255); f = w.clamp(Math.round(255 * f[2]), 0, 255); return "0x" + ((t << 16) + (v << 8) + f).toString(16) }; a.setMatrixTranslation = h; a.setMatrixTranslation3 = function (f,
          t, v, m) { f[12] = t; f[13] = v; f[14] = m }; a.verify = function (f, t) { f || console.warn("Verify failed: " + (t || "") + "\n" + Error("verify").stack) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/ContentObject": function () { define(["exports", "../../../../core/uid"], function (a, w) { let c = function () { function q() { this.id = w.generateUID() } q.prototype.unload = function () { }; return q }(); a.ContentObject = c; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/webgl-engine/lib/geometryDataUtils": function () {
      define(["exports",
        "../../../../chunks/vec3", "../../../../chunks/vec3f64", "../../../../geometry/support/triangle"], function (a, w, c, q) {
          let u = (() => { const d = new Uint32Array(131072); for (let f = 0; f < d.length; ++f)d[f] = f; return d })(); const y = new Uint16Array([0]), n = (() => { const d = new Uint16Array(65536); for (let f = 0; f < d.length; ++f)d[f] = f; return d })(), p = c.create(), l = c.create(), h = c.create(), b = c.create(); a.computeAttachmentOriginLines = function (d, f, t, v) {
            if (!d) return !1; const { size: m, data: e } = d; w.set(v, 0, 0, 0); w.set(b, 0, 0, 0); let g = d = 0; const x =
              f ? f.length - 1 : e.length / m - 1; t = x + (t ? 2 : 0); for (let A = 0; A < t; A += 2) { var k = A < x ? A : x, r = A < x ? A + 1 : 0; k = (f ? f[k] : k) * m; r = (f ? f[r] : r) * m; p[0] = e[k + 0]; p[1] = e[k + 1]; p[2] = e[k + 2]; l[0] = e[r + 0]; l[1] = e[r + 1]; l[2] = e[r + 2]; w.scale(p, w.add(p, p, l), .5); r = w.dist(p, l); 0 < r ? (w.add(v, v, w.scale(p, p, r)), d += r) : (w.add(b, b, p), g++) } return 0 !== d ? (w.scale(v, v, 1 / d), !0) : 0 !== g ? (w.scale(v, b, 1 / g), !0) : !1
          }; a.computeAttachmentOriginPoints = function (d, f, t) {
            if (!d || !f) return !1; const { size: v, data: m } = d; w.set(t, 0, 0, 0); d = -1; let e = 0; for (let g = 0; g < f.length; g++) {
              const x =
                f[g] * v; d !== x && (t[0] += m[x + 0], t[1] += m[x + 1], t[2] += m[x + 2], e++); d = x
            } 1 < e && w.scale(t, t, 1 / e); return 0 < e
          }; a.computeAttachmentOriginTriangles = function (d, f, t) {
            if (!d) return !1; const { size: v, data: m } = d; w.set(t, 0, 0, 0); w.set(b, 0, 0, 0); let e = d = 0; for (let x = 0; x < f.length - 2; x += 3) {
              var g = f[x + 0] * v; const k = f[x + 1] * v, r = f[x + 2] * v; w.set(p, m[g + 0], m[g + 1], m[g + 2]); w.set(l, m[k + 0], m[k + 1], m[k + 2]); w.set(h, m[r + 0], m[r + 1], m[r + 2]); (g = q.areaPoints3d(p, l, h)) ? (w.add(p, p, l), w.add(p, p, h), w.scale(p, p, 1 / 3 * g), w.add(t, t, p), d += g) : (w.add(b, b, p), w.add(b,
                b, l), w.add(b, b, h), e += 3)
            } return 0 === e && 0 === d ? !1 : 0 !== d ? (w.scale(t, t, 1 / d), !0) : 0 !== e ? (w.scale(t, b, 1 / e), !0) : !1
          }; a.generateDefaultIndexArray = function (d) { if (1 === d) return y; if (d < n.length) return new Uint16Array(n.buffer, 0, d); if (d > u.length) { u = new Uint32Array(Math.max(2 * u.length, d)); for (let f = 0; f < u.length; f++)u[f] = f } return new Uint32Array(u.buffer, 0, d) }; a.generateIndexArray = function (d) {
            if (1 === d) return new Uint16Array(y); if (d < n.length) return new Uint16Array(n.slice(0, d)); if (d > u.length) {
              d = new Uint32Array(d); for (let f =
                0; f < d.length; f++)d[f] = f; return d
            } return new Uint32Array(u.slice(0, d))
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/support/triangle": function () {
      define("exports ../../core/ObjectStack ../../chunks/vec2 ../../chunks/vec3 ../../chunks/vec3f64 ./lineSegment ./vectorStacks".split(" "), function (a, w, c, q, u, y, n) {
        function p(v) { return v ? { p0: u.clone(v.p0), p1: u.clone(v.p1), p2: u.clone(v.p2) } : { p0: u.create(), p1: u.create(), p2: u.create() } } function l(v, m, e, g = p()) {
          q.copy(g.p0, v); q.copy(g.p1, m);
          q.copy(g.p2, e); return g
        } function h(v, m, e) { var g = c.distance(v, m); m = c.distance(m, e); v = c.distance(e, v); e = (g + m + v) / 2; g = e * (e - g) * (e - m) * (e - v); return 0 >= g ? 0 : Math.sqrt(g) } const b = new w.ObjectStack(y.create), d = new w.ObjectStack(() => ({ p0: null, p1: null, p2: null })), f = u.create(), t = u.create(); a.area2d = function (v) { return h(v.p0, v.p1, v.p2) }; a.areaPoints2d = h; a.areaPoints3d = function (v, m, e) { q.subtract(f, m, v); q.subtract(t, e, v); return q.length(q.cross(f, f, t)) / 2 }; a.copy = function (v, m = p()) { return l(v.p0, v.p1, v.p2, m) }; a.create =
          p; a.distance2 = function (v, m) {
            var e = v.p0, g = v.p1; v = v.p2; const x = q.subtract(n.sv3d.get(), g, e), k = q.subtract(n.sv3d.get(), v, g), r = q.subtract(n.sv3d.get(), e, v), A = q.subtract(n.sv3d.get(), m, e); var z = q.subtract(n.sv3d.get(), m, g), B = q.subtract(n.sv3d.get(), m, v); const C = q.cross(x, x, r), D = q.dot(q.cross(n.sv3d.get(), x, C), A); z = q.dot(q.cross(n.sv3d.get(), k, C), z); B = q.dot(q.cross(n.sv3d.get(), r, C), B); if (0 < D && 0 < z && 0 < B) return m = q.dot(C, A), m * m / q.dot(C, C); e = y.distance2(y.fromValues(e, x, b.get()), m); g = y.distance2(y.fromValues(g,
              k, b.get()), m); m = y.distance2(y.fromValues(v, r, b.get()), m); return Math.min(e, g, m)
          }; a.fromValues = l; a.intersectRay = function (v, m, e) {
            const { direction: g, origin: x } = m, { p0: k, p1: r, p2: A } = v; var z = r[0] - k[0], B = r[1] - k[1], C = r[2] - k[2]; v = A[0] - k[0]; m = A[1] - k[1]; const D = A[2] - k[2]; var E = g[1] * D - m * g[2], H = g[2] * v - D * g[0]; const J = g[0] * m - v * g[1]; var M = z * E + B * H + C * J; if (-1E-5 < M && 1E-5 > M) return !1; M = 1 / M; const F = x[0] - k[0], K = x[1] - k[1], P = x[2] - k[2]; E = M * (F * E + K * H + P * J); if (0 > E || 1 < E) return !1; H = K * C - B * P; C = P * z - C * F; z = F * B - z * K; B = M * (g[0] * H + g[1] * C + g[2] *
              z); if (0 > B || 1 < E + B) return !1; e && (q.scale(e, g, M * (v * H + m * C + D * z)), q.add(e, x, e)); return !0
          }; a.wrap = function (v, m, e) { const g = d.get(); g.p0 = v; g.p1 = m; g.p2 = e; return g }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/environment/SimpleAtmosphere": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../core/Logger ../../../core/mathUtils ../../../core/maybe ../../../core/promiseUtils ../../../core/watchUtils ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec2 ../../../chunks/vec2f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projectionEllipsoid ../../../geometry/support/spatialReferenceUtils ../../../support/requestImageUtils ./atmosphereUtils ./SimpleAtmosphereTechnique ./resources/MarsAtmosphereTexture ./resources/SimpleAtmosphereTexture ../support/mathUtils ../support/buffer/glUtil ../support/buffer/InterleavedLayout ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/glUtil3D ../webgl-engine/lib/Util ../../webgl/BufferObject ../../webgl/Texture ../../webgl/Util ../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          function M(O, R, S, Q, T) { const da = b.length(O), Y = Q * Math.sqrt(da * da - Q * Q) / da, fa = T.silCircleV1, ha = T.silCircleV2; b.scale(T.silCircleCenter, O, Math.sqrt(Q * Q - Y * Y) / da); b.cross(fa, O, R); 1 > b.squaredLength(fa) && b.cross(fa, O, S); b.scale(fa, fa, Y / b.length(fa)); b.cross(ha, fa, O); b.scale(ha, ha, Y / b.length(ha)); return Y } const F = w.getLogger("esri.views.3d.environment.SimpleAtmosphere"), K = -m.innerAtmosphereDepth, P = k.makePiecewiseLinearFunction([[50, .1015625],
          [500, .21875], [5E3, .51171875], [5E4, .4140625]]); w = function () {
            function O(S) {
            this.view = S; this.type = "simple"; this._renderData = { texV: h.create(), silCircleCenter: d.create(), silCircleV1: d.create(), silCircleV2: d.create(), altitudeFade: 0, innerScale: 0, undergroundFadeAlpha: 0 }; this._fadeVaoCount = 0; this._readyResolver = u.createResolver(); this._readyController = new AbortController; this.texV1 = 1; this.isOnMars = t.isMars(S.spatialReference); S = f.getReferenceEllipsoid(S.spatialReference); this.planetRadius = S.radius; this.outerRimWidth =
              S.outerAtmosphereRimWidth; this.innerRimFactor = (this.planetRadius + K) / this.planetRadius; this.middleRimFactor = (this.planetRadius + 0) / this.planetRadius; this.outerRimFactor = (this.planetRadius + this.outerRimWidth) / this.planetRadius; this.texV0 = 0 / this.outerRimWidth; this.texVScale = this.texV1 - this.texV0
            } var R = O.prototype; R.destroy = function () {
              this._readyResolver.reject(); this._cameraChangeHandle = q.removeMaybe(this._cameraChangeHandle); this._texture = q.disposeMaybe(this._texture); this._fadeVao = q.disposeMaybe(this._fadeVao);
              this._vao = q.disposeMaybe(this._vao); this._readyController = q.abortMaybe(this._readyController)
            }; R.when = function () { return this._readyResolver.promise }; R.initializeRenderContext = function (S) {
            this._shaderTechniqueRepository = S.shaderTechniqueRep; const Q = S.renderContext.rctx; this._cameraChangeHandle = y.init(this.view, "state.camera", () => S.requestRender(), !0); this._vao = this._createRibbon(Q); this._vaoCount = H.vertexCount(this._vao, "geometry"); this._fadeVao = B.createQuadVAO(Q); this._fadeVaoCount = H.vertexCount(this._fadeVao,
              "geometry"); v.requestImage(this.isOnMars ? g : x, { signal: this._readyController.signal }).then(T => { this._texture = new E(Q, { pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9729, flipped: !0 }, T); S.requestRender(); this._readyController = null; this._readyResolver.resolve() }).catch(T => { u.isAbortError(T) || F.error("Unable to initialize simple atmosphere: image request failed", T); this._readyResolver.reject(T) })
            }; R.render = function (S) {
              this._update(S.camera); const Q = S.rctx; this.atmosphereConeTechnique.bindPipelineState(Q);
              if (1 > this._renderData.undergroundFadeAlpha) {
                var T = this.atmosphereConeTechnique.program; Q.useProgram(T); T.setUniformMatrix4fv("proj", S.camera.projectionMatrix); T.setUniformMatrix4fv("view", S.camera.viewMatrix); T.setUniform3fv("silCircleCenter", this._renderData.silCircleCenter); T.setUniform3fv("silCircleV1", this._renderData.silCircleV1); T.setUniform3fv("silCircleV2", this._renderData.silCircleV2); T.setUniform2fv("texV", this._renderData.texV); T.bindTexture(this._texture, "tex"); S.scenelightingData.setLightDirectionUniform(T);
                T.setUniform1f("altitudeFade", this._renderData.altitudeFade); T.setUniform1f("innerScale", this._renderData.innerScale); Q.bindVAO(this._vao); Q.drawArrays(4, 0, this._vaoCount)
              } 0 < this._renderData.undergroundFadeAlpha && (T = this.atmosphereUndergroundTechnique.program, Q.useProgram(T), T.setUniform1f("undergroundFadeAlpha", this._renderData.undergroundFadeAlpha), S.scenelightingData.setLightDirectionUniform(T), T.setUniform3fv("cameraPosition", S.camera.eye), Q.bindVAO(this._fadeVao), Q.drawArrays(5, 0, this._fadeVaoCount));
              return !0
            }; R.renderHaze = function () { return !1 }; R._update = function (S) {
              var Q = d.create(); const T = this.planetRadius; var da = b.length(S.eye); const Y = da - T; this._renderData.undergroundFadeAlpha = 0 > Y ? Math.min(-Y / 5E3, 1) : 0; var fa = T + K, ha = T + Math.max(50, Y); this._renderData.innerScale = ha * ha / (Math.sqrt(ha * ha - T * T) * Math.sqrt(ha * ha - fa * fa) + T * fa) - 1; this._renderData.altitudeFade = m.computeInnerAltitudeFade(Y); b.scale(Q, S.eye, (T + 50) / da); M(Q, S.center, S.up, T, this._renderData); Q = this._computeScreenRimWidth(S, Q, S.up, this._renderData);
              da = P(Y); fa = this.texV0 + .001953125 * this.texVScale; ha = this.texV0 + Q * da * this.texVScale; 50 < Y && (M(S.eye, S.center, S.up, T, this._renderData), S = this._computeScreenRimWidth(S, S.eye, S.up, this._renderData), S = c.clamp((S - 1.5) / (Q - 1.5), 0, 1), fa = this.texV0 + .001953125 * S * this.texVScale, ha = this.texV0 + c.lerp(this.texV1, Q * da, S) * this.texVScale); l.set(this._renderData.texV, fa, ha)
            }; R._createRibbon = function (S) {
              const Q = new Float32Array(1155), T = new Uint32Array(1920); Q[0] = 0; Q[1] = 0; Q[2] = -1; for (var da = 0; 128 > da; da++) {
                var Y = 9 * da + 3;
                Q[Y + 0] = da; Q[Y + 1] = this.innerRimFactor; Q[Y + 2] = -1; Q[Y + 3] = da; Q[Y + 4] = this.middleRimFactor; Q[Y + 5] = 0; Q[Y + 6] = da; Q[Y + 7] = this.outerRimFactor; Q[Y + 8] = 1; Y = 3 * da + 1; var fa = 127 === da ? 1 : Y + 3, ha = 15 * da; T[ha + 0] = Y; T[ha + 1] = Y + 1; T[ha + 2] = fa + 1; T[ha + 3] = fa + 1; T[ha + 4] = fa; T[ha + 5] = Y; T[ha + 6] = Y + 1; T[ha + 7] = Y + 2; T[ha + 8] = fa + 2; T[ha + 9] = fa + 2; T[ha + 10] = fa + 1; T[ha + 11] = Y + 1; T[ha + 12] = Y; T[ha + 13] = fa; T[ha + 14] = 0
              } da = I.createBuffer(T.length); Y = da.position; for (fa = 0; fa < T.length; ++fa)ha = 3 * T[fa], Y.set(fa, 0, Q[ha]), Y.set(fa, 1, Q[ha + 1]), Y.set(fa, 2, Q[ha + 2]); return new J(S,
                z.Default3D, { geometry: r.glLayout(I) }, { geometry: D.createVertex(S, 35044, da.buffer) })
            }; R._computeScreenRimWidth = function (S, Q, T, da) { b.add(N, da.silCircleCenter, da.silCircleV2); b.scale(G, N, this.outerRimFactor); n.lookAt(L, Q, N, T); C.project(N, L, S.projectionMatrix, S.viewport); C.project(G, L, S.projectionMatrix, S.viewport); return b.distance(N, G) / S.height }; a._createClass(O, [{
              key: "atmosphereConeTechnique", get: function () {
                if (q.isNone(this._atmosphereConeTechnique)) {
                  const S = new e.SimpleAtmosphereTechniqueConfiguration;
                  S.geometry = 0; this._atmosphereConeTechnique = this._shaderTechniqueRepository.acquire(e.SimpleAtmosphereTechnique, S)
                } return this._atmosphereConeTechnique
              }
            }, { key: "atmosphereUndergroundTechnique", get: function () { if (q.isNone(this._atmosphereUndergroundTechnique)) { const S = new e.SimpleAtmosphereTechniqueConfiguration; S.geometry = 2; this._atmosphereUndergroundTechnique = this._shaderTechniqueRepository.acquire(e.SimpleAtmosphereTechnique, S) } return this._atmosphereUndergroundTechnique } }, {
              key: "canRender", get: function () {
                return null !=
                  this._texture
              }
            }]); return O
          }(); const L = p.create(), N = d.create(), G = d.create(), I = A.newLayout().vec3f("position"); return w
        })
    }, "esri/views/3d/environment/resources/MarsAtmosphereTexture": function () { define(function () { return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAIACAYAAAE00TaTAAAACXBIWXMAAA7AAAAOwAFq1okJAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAp1JREFUSMd9lcmSEzEQRCtflnqxYZgIThBDAP//kXDQ0pJtuDhqycxWZ5fKERFCERARIAVEyCjCtSFFEjWVa9q7OdJE0oiidIhKhRBROlhloiGVhaYERQHJWFEwMpYKrjUlibI2cqSJIJEpKNmM2c3GkRTOJDnThTMpnMWu0VFszs3Jfbe5bza3w+a229yOIs6zmP3czfn1K2w/for8+EVU15pNmmyqkeJyclinXNJRu1xrUaJmjmdzJiejVNt7zZVBRAIq1RwrsrrWnez+SR7WmQQP/1itKz2q/pmzuJtYnNy2bth9x9z2NLfDcB7FHOcGx6ebOb9/iPzxG/ztg4iorglFiKjzF9HSNphCoRb1OY3RZQJrYgRdT68bmgXGDdBzrTG8qNS7QP/m19ef7tGlcoH7vESYkK70uoPuOLEetz0IqeGoWQW6MlB/j36EnipYGKPWwDRg/RkNhXCNJIzAhMk6PrDePJNII6JHqM5VWqYApCtNFPe0GFFGtOWopWCrEVBSoiQi06KkRRaD08IlxXa/ifz8Jvz2LvjyLnh7F/r8Rei8a8xfjNkIrpmMOQ1C02COrkTEHxGhh+6DQJfXc/eZprXxcIyVIf1LJVgWvKaHvwI/1aQxtv851SQ/nqGXL6MHFVY3nmhLyqKsWO/+qzWif+yS1TpNKq8NezjGPCV69ciZoQj1PwfN6QRpWyCGVMe1D/AAHt3/gefu1Ign3AVpjOiNXkN90JlpL6TUnzFEUU+Jvks0tkp/dY3Fy1TzI24BWwsYJPyg11Q0FqDwK72xIz2kLojbeuxS1FpgtfNWyMX1gFw0j3W7RNeSHTVEe3VaV7SdCzVywFaEt02w7QH7Eeg4AvZDNdJ+Cu1HENsutO+Byi6ilEBZ9BeCNBJceJIjHgAAAABJRU5ErkJggg\x3d\x3d" }) },
    "esri/views/3d/environment/Stars": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../assets ../../../core/Accessor ../../../core/Error ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/mat4 ../../../chunks/mat4f64 ./StarsTechnique ../support/buffer/glUtil ../support/buffer/InterleavedLayout ../webgl-engine/lib/DefaultVertexAttributeLocations ../../support/WatchUpdatingTracking ../../webgl/BufferObject ../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z) {
          const B = n.getLogger("esri.views.3d.environment.Stars"); a.Stars = function (M) {
            function F(P) { P = M.call(this, P) || this; P._loadDataTask = null; P._numPoints = 0; P._renderParameter = { camera: null, modelMatrix: m.create() }; P._updatingTracking = new r.WatchUpdatingTracking; return P } w._inheritsLoose(F, M); var K = F.prototype; K.initialize = function () { this._loadDataTask = this._createLoadDataTask() }; K.destroy = function () {
            this._loadDataTask = p.abortMaybe(this._loadDataTask);
              this._updatingTracking.destroy(); this._numPoints = 0; this._technique = p.disposeMaybe(this._technique); this._vao = p.disposeMaybe(this._vao)
            }; K.render = function (P) {
              const { rctx: L, camera: N } = P; this._ensureResources(L); if (p.isNone(this._technique) || p.isNone(this._vao)) return !1; P = this._technique.program; L.useProgram(P); this._renderParameter.camera = N; this._technique.bindPass(this._renderParameter); this._technique.bindPipelineState(L); L.bindVAO(this._vao); P.assertCompatibleVertexAttributeLocations(this._vao); L.drawArrays(0,
                0, this._numPoints); return !0
            }; K._ensureResources = function (P) { if (!p.isSome(this._technique) && !p.isNone(J)) { this._technique = new e.StarsTechnique({ rctx: P, viewingMode: this.view.state.viewingMode }, null); this._numPoints = J.byteLength / 9; var L = new Float32Array(J, 0, 2 * this._numPoints), N = new Uint8Array(J, 8 * this._numPoints, this._numPoints); this._vao = this._createVertexArrayObject(P, L, N, this._numPoints); this._updatingTracking.add(this.view, "environment.lighting.date", G => this._update(G), 2) } }; K._computeDayDuration =
              function (P) { const L = new Date(P.getFullYear(), 0, 1, 11, 58, 56), N = new Date(P.getFullYear() + 1, 0, 1, 11, 58, 55); return (+P - +L) / (+N - +L) }; K._update = function (P) { if (P) { var L = P.getHours() / 12, N = P.getMinutes() / 60 * (2 / 24), G = P.getSeconds() / 60 * (2 / 1440); L = (L + N + G - .9972222) % 2; P = 2 * this._computeDayDuration(P); N = this._renderParameter.modelMatrix; v.copy(N, E); v.rotateZ(N, N, -P * Math.PI); v.multiply(N, D, N); v.rotateZ(N, N, -L * Math.PI); this.requestRender() } }; K._hexToRGB = function (P) {
                return [parseInt(P.substring(0, 2), 16), parseInt(P.substring(2,
                  4), 16), parseInt(P.substring(4, 6), 16)]
              }; K._unpackUint8Attributes = function (P) { return 192 <= P ? [2.9, P - 192] : 160 <= P ? [2.5, P - 160] : 128 <= P ? [2, P - 128] : 96 <= P ? [1.5, P - 96] : 64 <= P ? [1, P - 64] : 32 <= P ? [.7, P - 32] : [.4, P] }; K._createVertexArrayObject = function (P, L, N, G) {
                const I = H.createBuffer(G), O = I.position, R = I.color, S = I.size; for (let da = 0; da < G; da++) {
                  var Q = L[2 * da], T = L[2 * da + 1]; O.set(da, 0, -Math.cos(Q) * Math.sin(T)); O.set(da, 1, -Math.sin(Q) * Math.sin(T)); O.set(da, 2, -Math.cos(T)); Q = this._unpackUint8Attributes(N[da]); T = this._hexToRGB(C[Q[1]]);
                  R.set(da, 0, 255 * T[0]); R.set(da, 1, 255 * T[1]); R.set(da, 2, 255 * T[2]); R.set(da, 3, 255); S.set(da, Q[0])
                } return new z(P, k.Default3D, { geometry: g.glLayout(H) }, { geometry: A.createVertex(P, 35044, I.buffer) })
              }; K._createLoadDataTask = function () {
                var P = this; if (p.isSome(J)) return null; const L = l.createTask(function () {
                  var N = w._asyncToGenerator(function* (G) { ({ data: G } = yield q.fetchAsset("esri/views/3d/environment/resources/stars.wsv", { responseType: "array-buffer", signal: G })); P._verifyStarData(G); J = G }); return function (G) {
                    return N.apply(this,
                      arguments)
                  }
                }()); L.promise.catch(N => { l.isAbortError(N) || B.error(N) }).then(() => { this.destroyed || (this.requestRender(), this.notifyChange("updating")) }); return L
              }; K._verifyStarData = function (P) { if (!P) throw new y("stars:no-data-received", "Failed to create stars because star catalogue is missing"); P = P.byteLength / 9; if (0 !== P % 1 || 5E4 < P || 5E3 > P) throw new y("stars:invalid-data", "Failed to create stars because star catalogue data is invalid"); }; w._createClass(F, [{
                key: "updating", get: function () {
                  return this._updatingTracking.updating ||
                    this.loading
                }
              }, { key: "loading", get: function () { return p.isSome(this._loadDataTask) && !this._loadDataTask.finished } }]); return F
          }(u); c.__decorate([h.property({ constructOnly: !0 })], a.Stars.prototype, "view", void 0); c.__decorate([h.property({ constructOnly: !0 })], a.Stars.prototype, "requestRender", void 0); c.__decorate([h.property({ readOnly: !0 })], a.Stars.prototype, "updating", null); c.__decorate([h.property()], a.Stars.prototype, "_loadDataTask", void 0); c.__decorate([h.property()], a.Stars.prototype, "_updatingTracking",
            void 0); a.Stars = c.__decorate([t.subclass("esri.views.3d.environment.Stars")], a.Stars); const C = "9bb2ff;9eb5ff;aabfff;bbccff;ccd8ff ;dae2ff;e4e9ff;eeefff;f8f6ff;fff9fb;fff5ef;fff1e5;ffeddb;ffe9d2;ffe6ca;ffe3c3;ffe0bb;ffddb4;ffdaad;ffd6a5;ffd29c;ffcc8f;ffc178;ffa94b;ff7b00".split(";"), D = m.fromValues(1, 0, 0, 0, 0, .9174771405229186, .39778850739794974, 0, 0, -.39778850739794974, .9174771405229186, 0, 0, 0, 0, 1), E = m.fromValues(1, 0, 0, 0, 0, .9174771405229186, -.39778850739794974, 0, 0, .39778850739794974, .9174771405229186,
              0, 0, 0, 0, 1), H = x.newLayout().vec3f("position").vec4u8("color").f32("size"); let J = null; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/environment/StarsTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/Stars.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          p = function (f) {
            function t() { return f.apply(this, arguments) || this } c._inheritsLoose(t, f); var v = t.prototype; v.initializeProgram = function (m) { const e = t.shader.get().build(); return new h.Program(m.rctx, e, l.Default3D) }; v.initializePipeline = function () { return b.makePipelineState({ blending: b.separateBlendingParams(770, 1, 771, 771), depthTest: { func: 515 }, colorWrite: b.defaultColorWriteParams }) }; v.bindPass = function (m) {
              const e = this.makeInfiniteProjectionMatrix(m.camera.projectionMatrix,
                m.camera.near, d); q.multiply(e, e, m.camera.viewMatrix); q.multiply(e, e, m.modelMatrix); this.program.setUniformMatrix4fv("transform", e); this.program.setUniform4fv("viewport", m.camera.fullViewport); this.program.setUniform1f("pixelRatio", m.camera.pixelRatio)
            }; v.makeInfiniteProjectionMatrix = function (m, e, g) { q.copy(g, m); g[10] = 2.4E-7 - 1; g[11] = -1; g[14] = (2.4E-7 - 2) * e; return g }; return t
          }(p.ShaderTechnique); p.shader = new n.ReloadableShaderModule(y.StarsShader, () => new Promise((f, t) => a(["./Stars.glsl"], f, t))); const d =
            u.create(); w.StarsTechnique = p; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/Stars.glsl": function () {
      define(["exports", "../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl", "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c, q) {
        function u() {
          const n = new q.ShaderBuilder; n.attributes.add("position", "vec3"); n.attributes.add("color", "vec4"); n.attributes.add("size", "float"); n.varyings.add("vcolor",
            "vec4"); n.varyings.add("vsize", "float"); n.vertex.uniforms.add("transform", "mat4").add("viewport", "vec4").add("pixelRatio", "float"); n.include(w.AlignPixel); n.vertex.code.add(c.glsl`void main(void) {
vec4 posProj = transform * vec4(position, 0);
gl_Position = alignToPixelCenter(posProj, viewport.zw);
vcolor = color / 1.2;
vsize = size * 5.0 * pixelRatio;
gl_PointSize = vsize;
}`); n.fragment.code.add(c.glsl`void main() {
float cap = 0.7;
float scale = 1.0 / cap;
float helper = clamp(length(abs(gl_PointCoord - vec2(0.5))), 0.0, cap);
float alpha = clamp((cap - helper) * scale, 0.0, 1.0);
float intensity = alpha * alpha * alpha;
if (vsize < 3.0) {
intensity *= 0.5;
}
gl_FragColor = vec4(vcolor.xyz, intensity);
}`); return n
        } const y = Object.freeze({ __proto__: null, build: u }); a.StarsShader = y; a.build = u
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.AlignPixel = function (c) {
        const q = w.glsl`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`, u = w.glsl`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`; c.vertex.code.add(q); c.vertex.code.add(u); c.fragment.code.add(q); c.fragment.code.add(u)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/earthUtils": function () {
      define(["exports", "../../../core/mathUtils", "../../../geometry/Point", "../../../geometry/projectionEllipsoid"], function (a, w, c, q) {
        function u(p, l, h) { return y(p, l.longitude, l.latitude, h.longitude, h.latitude) } function y(p, l, h, b, d) {
          h = w.deg2rad(h); d = w.deg2rad(d); l = w.deg2rad(l); const f = w.deg2rad(b); b = Math.sin((h - d) / 2);
          l = Math.sin((l - f) / 2); h = 2 * w.asinClamped(Math.sqrt(b * b + Math.cos(h) * Math.cos(d) * l * l)); return Math.round(h * p * 1E4) / 1E4
        } function n(p, l) { p /= 15; l || (p = Math.round(p)); return p } a.getGreatCircleDistance = y; a.getGreatCircleDistanceFromPoints = u; a.getGreatCircleSpanAt = function (p, l, h) { const b = l.spatialReference, d = q.getReferenceEllipsoid(b), f = new c(l.x, p.y, b), t = new c(h.x, p.y, b); l = new c(p.x, l.y, b); p = new c(p.x, h.y, b); return { lon: u(d.radius, f, t), lat: u(d.radius, l, p) } }; a.getLatDeltaForDistance = function (p, l) {
          return w.rad2deg(p /
            l)
        }; a.getLonDeltaForDistance = function (p, l, h) { l /= h; p = w.deg2rad(p); l = Math.sin(l / 2); p = Math.cos(p); p = 2 * w.asinClamped(Math.sqrt(l * l / (p * p))); return w.rad2deg(p) }; a.getMaxCameraAltitude = function (p, l) { p = w.deg2rad(p / 2); return (1 - Math.sin(p)) * l / Math.sin(p) }; a.longitudeToTimezone = n; a.pointToTimezone = function (p, l) { return n(p.longitude, l) }; a.positionToTimezoneInfo = function (p, l) {
          l || (l = { hours: 0, minutes: 0, seconds: 0 }); l.hours = n(p[0], !0); p = l.hours % 1; l.hours -= p; l.minutes = 60 * p; p = l.minutes % 1; l.minutes -= p; l.seconds = Math.round(60 *
            p); return l
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/sunUtils": function () {
      define("exports ../../../core/mathUtils ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/SunCalc".split(" "), function (a, w, c, q, u, y, n) {
        function p(m, e, g, x) {
          const k = t, r = c.identity(f); if (1 === g) n.SunCalc.getPosition(m, 0, 0, k), u.set(x, 0, 0, -1), c.rotateX(r, r, -k.azimuth), c.rotateY(r, r, -k.altitude); else {
            var A = b.planarDirection; g = A.globalAngles; A =
              (Math.abs(e[2]) - A.localAltitude) / (A.globalAltitude - A.localAltitude); A = w.clamp(A, 0, 1); 1 > A ? (n.SunCalc.getPosition(m, e[1], e[0], k), k.azimuth = (1 - A) * k.azimuth + A * g.azimuth, k.altitude = (1 - A) * k.altitude + A * g.altitude) : (k.azimuth = g.azimuth, k.altitude = g.altitude); u.set(x, 0, -1, 0); c.rotateZ(r, r, -k.azimuth); c.rotateX(r, r, -k.altitude)
          } u.transformMat4(x, x, r)
        } function l(m) {
          switch (m) {
            case "disabled": case "sunny": return { direct: 1, ambient: 1 }; case "cloudy": return { direct: .8, ambient: 1.1 }; case "rainy": return { direct: .4, ambient: 1 };
            case "foggy": return { direct: .3, ambient: 1.6 }
          }
        } function h(m, e, g, x) { const k = []; for (let r = 0; r < g.length; r++)k[r] = (x[r] - g[r]) * m / e + g[r]; return k } const b = { local: { altitude: 1500, ambientAtNight: .1, ambientAtNoon: .45, ambientAtTwilight: .2, directAtNoon: .65, directAtTwilight: .7 }, global: { altitude: 8E5, ambient: .015, direct: .75 }, planarDirection: { localAltitude: 1E4, globalAltitude: 1E6, globalAngles: { azimuth: 1.3 * Math.PI, altitude: .6 * Math.PI } } }, d = y.fromValues(.5773502691896258, -.5773502691896258, .5773502691896258), f = q.create(),
          t = { azimuth: 0, altitude: 0 }, v = new Date(0); a.ColorAndIntensity = function () { this.ambient = { color: y.fromValues(1, 1, 1), intensity: .55 }; this.direct = { color: y.fromValues(1, 1, 1), intensity: .55, directionToLightSource: y.clone(d) }; this.noonFactor = .5; this.globalFactor = 0 }; a.computeColorAndIntensity = function (m, e, g, x, k) {
            var r = e[2]; u.set(x.ambient.color, 1, 1, 1); x.ambient.intensity = b.global.ambient; u.set(x.direct.color, 1, 1, 1); x.direct.intensity = b.global.direct; var A = w.clamp((Math.abs(r) - b.local.altitude) / (b.global.altitude -
              b.local.altitude), 0, 1); x.globalFactor = A; r = n.SunCalc.getTimes(m, e[1], e[0]); if (1 > A) {
                {
                  var z = m.valueOf(); if (r.polarException === n.SunCalc.POLAR_EXCEPTION.MIDNIGHT_SUN) { var B = z - 36E5 * (m.getHours() + 48) - 6E4 * m.getMinutes(); var C = B + 432E6 } else r.polarException === n.SunCalc.POLAR_EXCEPTION.POLAR_NIGHT ? (B = z - 2, C = z - 1) : (B = r.sunrise.valueOf(), C = r.sunset.valueOf()); var D = C - B; var E = B + D / 2; var H = D / 4; var J = E - H; H = E + H; var M = .06 * D; D = B - M / 2; B += M / 2; const K = C - M / 2; var F = C + M / 2; C = b.local; M = [.01, C.ambientAtNight]; const P = [.8, .8, 1],
                    L = [.01, .01, .01], N = [C.directAtTwilight, C.ambientAtTwilight], G = [1, .6, .5], I = [.8, .8, 1], O = [.9 * C.directAtNoon, C.ambientAtNoon], R = [1, .98, .98], S = [.98, .98, 1], Q = [C.directAtNoon, C.ambientAtNoon], T = [1, 1, 1], da = [1, 1, 1]; C = [0, 0]; let Y = [0, 0, 0], fa = [0, 0, 0]; z < D || z > F ? (C = M, Y = L, fa = P) : z < B ? (F = B - D, C = h(z - D, F, M, N), Y = h(z - D, F, L, G), fa = h(z - D, F, P, I)) : z < J ? (F = J - B, C = h(z - B, F, N, O), Y = h(z - B, F, G, R), fa = h(z - B, F, I, S)) : z < E ? (F = E - J, C = h(z - J, F, O, Q), Y = h(z - J, F, R, T), fa = h(z - J, F, S, da)) : z < H ? (F = H - E, C = h(z - E, F, Q, O), Y = h(z - E, F, T, R), fa = h(z - E, F, da, S)) : z < K ? (F =
                      K - H, C = h(z - H, F, O, N), Y = h(z - H, F, R, G), fa = h(z - H, F, S, I)) : z < F && (F -= K, C = h(z - K, F, N, M), Y = h(z - K, F, G, L), fa = h(z - K, F, I, P)); E = y.fromValues(Y[0], Y[1], Y[2]); z = y.fromValues(fa[0], fa[1], fa[2]); J = l(k); k = C[0] * J.direct; J = C[1] * J.ambient
                } u.lerp(x.ambient.color, z, x.ambient.color, A); x.ambient.intensity = w.lerp(J, x.ambient.intensity, A); u.lerp(x.direct.color, E, x.direct.color, A); x.direct.intensity = w.lerp(k, x.direct.intensity, A)
              } A = m.valueOf(); r.polarException === n.SunCalc.POLAR_EXCEPTION.MIDNIGHT_SUN ? (k = A - 36E5 * (m.getHours() + 48) -
                6E4 * m.getMinutes(), r = k + 432E6) : r.polarException === n.SunCalc.POLAR_EXCEPTION.POLAR_NIGHT ? (k = A - 2, r = A - 1) : (k = r.sunrise.valueOf(), r = r.sunset.valueOf()); r = 1 - w.clamp(Math.abs(A - (k + (r - k) / 2)) / 432E5, 0, 1); x.noonFactor = r; p(m, e, g, x.direct.directionToLightSource)
          }; a.computeDirectionsOverTime = function (m, e, g, x, k) { m = m.getTime(); e = e.getTime() - m; e = Math.floor(e / g) + 1; const r = Array(e); for (let A = 0; A < e; ++A)v.setTime(m + g * A), r[A] = y.create(), p(v, x, k, r[A]); return r }; a.computeShadowsEnabled = function (m, e) {
            return 1 === e ? !0 : Math.abs(m) <
              b.planarDirection.localAltitude
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/SunCalc": function () {
      define(["exports"], function (a) {
        var w = { exports: {} }; (function (c) {
          (function (q) { q = q(); void 0 !== q && (c.exports = q) })(function () {
            function q(C) { return new Date(864E5 * (C + .5 - 2440588)) } function u(C, D) { return g(t(C) * v(A) - m(D) * t(A), v(C)) } function y(C, D) { return e(t(D) * v(A) + v(D) * t(A) * t(C)) } function n(C, D, E) { return g(t(C), v(C) * t(D) - m(E) * v(D)) } function p(C, D, E) { return e(t(D) * t(E) + v(D) * v(E) * v(C)) } function l(C) {
              return k *
                (1.9148 * t(C) + .02 * t(2 * C) + 3E-4 * t(3 * C))
            } function h(C, D) { C = k * (357.5291 + .98560028 * C); var E = l(C); C = C + E + 102.9372 * k + f; D || (D = { dec: 0, ra: 0 }); D.dec = y(C, 0); D.ra = u(C, 0); return D } function b(C, D, E) { return 2451545 + C + .0053 * t(D) - .0069 * t(2 * E) } function d(C) { var D = k * (134.963 + 13.064993 * C), E = k * (93.272 + 13.22935 * C); C = k * (218.316 + 13.176396 * C) + 6.289 * k * t(D); E = 5.128 * k * t(E); D = 385001 - 20905 * v(D); return { ra: u(C, E), dec: y(C, E), dist: D } } var f = Math.PI, t = Math.sin, v = Math.cos, m = Math.tan, e = Math.asin, g = Math.atan2, x = Math.acos, k = f / 180, r = {
              dec: 0,
              ra: 0
            }, A = 23.4397 * k, z = { POLAR_EXCEPTION: { NORMAL: 0, MIDNIGHT_SUN: 1, POLAR_NIGHT: 2 }, getPosition: function (C, D, E, H) { E = k * -E; D *= k; var J = C.valueOf() / 864E5 - .5 + 2440588 - 2451545; C = h(J, r); E = k * (280.16 + 360.9856235 * J) - E - C.ra; H || (H = { azimuth: 0, altitude: 0 }); H.azimuth = n(E, D, C.dec); H.altitude = p(E, D, C.dec); return H } }, B = [[-.83, "sunrise", "sunset"]]; z.addTime = function (C, D, E) { B.push([C, D, E]) }; z.getTimes = function (C, D, E) {
              function H(R) { var S = M, Q = L; R = x((t(R) - t(S) * t(Q)) / (v(S) * v(Q))); return b(9E-4 + (R + J) / (2 * f) + F, K, P) } var J = k * -E, M = k *
                D, F = Math.round(C.valueOf() / 864E5 - .5 + 2440588 - 2451545 - 9E-4 - J / (2 * f)); C = 9E-4 + (0 + J) / (2 * f) + F; var K = k * (357.5291 + .98560028 * C); D = l(K); var P = K + D + 102.9372 * k + f, L = y(P, 0); C = b(C, K, P); D = { solarNoon: q(C), nadir: q(C - .5), polarException: z.POLAR_EXCEPTION.NORMAL }; var N; E = 0; for (N = B.length; E < N; E += 1) { var G = B[E]; var I = H(G[0] * k); var O = C - (I - C); D[G[1]] = q(O); D[G[2]] = q(I) } D.polarException = function (R) { R = (t(R) - t(M) * t(L)) / (v(M) * v(L)); return -1 > R ? z.POLAR_EXCEPTION.MIDNIGHT_SUN : 1 < R ? z.POLAR_EXCEPTION.POLAR_NIGHT : z.POLAR_EXCEPTION.NORMAL }(B[0][0] *
                  k); return D
            }; z.getMoonPosition = function (C, D, E) { E = k * -E; D *= k; var H = C.valueOf() / 864E5 - .5 + 2440588 - 2451545; C = d(H); E = k * (280.16 + 360.9856235 * H) - E - C.ra; H = p(E, D, C.dec); H += .017 * k / m(H + 10.26 * k / (H + 5.1 * k)); return { azimuth: n(E, D, C.dec), altitude: H, distance: C.dist } }; z.getMoonFraction = function (C) { var D = C.valueOf() / 864E5 - .5 + 2440588 - 2451545; C = h(D); D = d(D); C = x(t(C.dec) * t(D.dec) + v(C.dec) * v(D.dec) * v(C.ra - D.ra)); C = g(149598E3 * t(C), D.dist - 149598E3 * v(C)); return (1 + v(C)) / 2 }; return z
          })
        })(w); a.SunCalc = w.exports
      })
    }, "esri/views/3d/webgl-engine/lighting/Lightsources": function () {
      define(["exports",
        "../../../../chunks/vec3f64"], function (a, w) { a.AmbientLight = function (c = w.create()) { this.intensity = c }; a.FillLight = function (c = w.create(), q = w.fromValues(.57735, .57735, .57735)) { this.intensity = c; this.direction = q }; a.MainLight = function (c = w.create(), q = w.fromValues(.57735, .57735, .57735), u = !0) { this.intensity = c; this.direction = q; this.castShadows = u }; a.SphericalHarmonicsAmbientLight = function () { this.r = [0]; this.g = [0]; this.b = [0] }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/input/SceneInputManager": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./handlers/DoubleClickZoom ./handlers/DragRotate ./handlers/DragZoom ./handlers/GamepadNavigation ./handlers/KeyboardNavigation ./handlers/MouseWheelZoom ./handlers/PinchAndPanNavigation ./handlers/PointerDownCancelAnimation ./handlers/SingleKeyResetHeading ./handlers/SingleKeyResetTilt ./handlers/TwoFingerTilt ../../input/BrowserEventSource ../../input/InputManager ../../input/handlers/PreventContextMenu ../../input/recognizers/Drag ../../input/recognizers/ImmediateDoubleClick ../../input/recognizers/PointerClickHoldAndDrag ../../input/recognizers/SingleAndDoubleClick ../../input/recognizers/VerticalTwoFingerDrag".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          c = function (F) {
            function K() { var L = F.apply(this, arguments) || this; L._handles = new q; return L } a._inheritsLoose(K, F); var P = K.prototype; P.destroy = function () { this._handles && (this._handles.removeAll(), this._handles = null); this.disconnect() }; P.disconnect = function () { this.view.viewEvents.disconnect(); this._inputManager && (this._inputManager.destroy(), this._inputManager = null); this._source && (this._source.destroy(), this._source = null) }; P.connect = function () {
              const L =
                this.view; this._source = new A.BrowserEventSource(this.view.surface, L.input); var N = [new D.ImmediateDoubleClick, new E.PointerClickHoldAndDrag, new H.SingleAndDoubleClick, new C.Drag(this.view.navigation), new J.VerticalTwoFingerDrag]; this._inputManager = N = new z.InputManager({ eventSource: this._source, recognizers: N }); N.installHandlers("prevent-context-menu", [new B.PreventContextMenu], z.ViewEventPriorities.INTERNAL); this._modeDragPan = new e.PinchAndPanNavigation(L, "primary"); this._modeDragRotate = new d.DragRotate(L,
                  "secondary", 0); this._modeDragZoom = new f.DragZoom(L, "tertiary"); N.installHandlers("navigation", [new g.PointerDownCancelAnimation(L), new b.DoubleClickZoom(L), new t.GamepadNavigation(L), new v.KeyboardNavigation(L, { left: "ArrowLeft", right: "ArrowRight", forward: "ArrowUp", backward: "ArrowDown", up: "u", down: "j", headingLeft: "a", headingRight: "d", tiltUp: "w", tiltDown: "s", zoomIn: "+", zoomOut: "-" }), new m.MouseWheelZoom(L), new k.SingleKeyResetTilt(L, "p"), new x.SingleKeyResetHeading(L, "n"), new d.DragRotate(L, "primary",
                    1, ["b"]), new d.DragRotate(L, "secondary", 0, ["b"]), new e.PinchAndPanNavigation(L, "tertiary", ["b"]), this._modeDragRotate, this._modeDragZoom, this._modeDragPan, new r.TwoFingerTilt(L)], z.ViewEventPriorities.INTERNAL); this.view.viewEvents.connect(N); this._updateMode(); u.init(this.view.navigation, "browserTouchPanEnabled", G => { this._source.browserTouchPanningEnabled = !G })
            }; P._updateMode = function () {
              var L = this.primaryDragAction; L = M.get(this.mode).get(L); this._modeDragPan && (this._modeDragPan.pointerAction = L.pan);
              this._modeDragRotate && (this._modeDragRotate.pointerAction = L.rotate); this._modeDragZoom && (this._modeDragZoom.pointerAction = L.zoom)
            }; a._createClass(K, [{ key: "primaryDragAction", get: function () { return this._get("primaryDragAction") }, set: function (L) { "pan" !== L && "rotate" !== L || L === this._get("primaryDragAction") || (this._set("primaryDragAction", L), this._updateMode()) } }, { key: "mode", get: function () { return this._get("mode") }, set: function (L) { "default" !== L && "pro" !== L || L === this._get("mode") || (this._set("mode", L), this._updateMode()) } },
            { key: "test", get: function () { return { inputManager: this._inputManager, modeDragPan: this._modeDragPan, modeDragRotate: this._modeDragRotate, modeDragZoom: this._modeDragZoom } } }]); return K
          }(c); w.__decorate([y.property()], c.prototype, "view", void 0); w.__decorate([y.property({ value: "pan" })], c.prototype, "primaryDragAction", null); w.__decorate([y.property({ value: "default" })], c.prototype, "mode", null); w.__decorate([y.property({ readOnly: !0, aliasOf: "_inputManager.hasPendingInputs" })], c.prototype, "hasPendingInputs", void 0);
          w.__decorate([y.property({ readOnly: !0, aliasOf: "_inputManager.latestPointerType" })], c.prototype, "latestPointerType", void 0); w.__decorate([y.property()], c.prototype, "_inputManager", void 0); c = w.__decorate([h.subclass("esri.views.3d.input.SceneInputManager")], c); const M = new Map; w = new Map; y = new Map; w.set("pan", { pan: "primary", rotate: "secondary", zoom: "tertiary" }); w.set("rotate", { pan: "secondary", rotate: "primary", zoom: "tertiary" }); y.set("pan", { pan: "primary", rotate: "tertiary", zoom: "secondary" }); y.set("rotate",
            { pan: "tertiary", rotate: "primary", zoom: "secondary" }); M.set("default", w); M.set("pro", y); return c
        })
    }, "esri/views/3d/input/handlers/DoubleClickZoom": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/screenUtils ../../state/controllers/global/ZoomStepController ../../state/controllers/local/ZoomStepController ../../../input/InputHandler ../../../input/handlers/support".split(" "), function (a, w, c, q, u, y, n) {
        y = function (p) {
          function l(h, b) {
            var d = p.call(this, !0) || this; d.view =
              h; d.registerIncoming("double-click", b, f => d.handleDoubleClick(f)); return d
          } w._inheritsLoose(l, p); l.prototype.handleDoubleClick = function (h) { const b = h.data; if (n.eventMatchesPointerAction(b, "primary")) { const d = this.view.state.isGlobal ? new q.ZoomStepController({ view: this.view, mode: "animation" }) : new u.ZoomStepController({ view: this.view, mode: "animation" }); this.view.state.switchCameraController(d); d.zoomStep(Math.log(.5) / Math.log(.6), c.createScreenPointArray(b.x, b.y)); h.stopPropagation() } }; return l
        }(y.InputHandler);
        a.DoubleClickZoom = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/global/ZoomStepController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/has ../../../../../core/time ../../../../../core/Logger ../../../../../core/accessorSupport/ensureType ../../../../../core/arrayUtils ../../../../../core/accessorSupport/set ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/projectionEllipsoid ../../../../../chunks/sphere ../../../camera/constraintUtils ../PointToPointAnimationController ../../utils/navigationUtils ../../../support/geometryUtils/ray ../../../support/geometryUtils/sphere ../../../webgl-engine/lib/Camera ../../../webgl-engine/lib/Intersector ../../../../animation/easing ../../../camera/constraintUtils/surfaceCollision".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z) {
        a.ZoomStepController = function (C) {
          function D() { var H = C.apply(this, arguments) || this; H.zoomLocation = d.create(); H.tmpCamera = new k; H.tmpViewDir = d.create(); H.tmpRayDir = { origin: d.create(), direction: d.create() }; H.targetOnSphere = d.create(); H.tmpCenter = d.create(); H.constraintOptions = { selection: 7, interactionType: 1, interactionFactor: null, interactionStartCamera: new k, interactionDirection: null, tiltMode: 0 }; H.sphere = t.create(); return H } w._inheritsLoose(D, C);
          var E = D.prototype; E.initialize = function () { this.intersector = r.newIntersector(this.view.state.viewingMode) }; E.zoomStep = function (H, J) {
            if (this.active) {
              var M = this.view.state, { interactionStartCamera: F } = this.constraintOptions; this.animation.finished ? F.copyFrom(M.camera) : this.animation.cameraAt(1, F); var K = F = !1; this.intersectionHelper.intersectScreen(J, this.zoomLocation) && (F = 0 < H ? !0 : !1, K = !0); this.tmpCamera.copyFrom(M.camera); F ? this.intersectionHelper.intersectRay(this.tmpCamera.ray, this.intersector, this.tmpCenter) &&
                (this.tmpCamera.center = this.tmpCenter) : this.intersectionHelper.intersectRay(this.tmpCamera.ray, this.intersector, this.zoomLocation) ? this.tmpCamera.center = this.zoomLocation : b.copy(this.zoomLocation, this.tmpCamera.center); this.updateCamera(this.tmpCamera, H, this.zoomLocation, J, K); this.begin(this.tmpCamera)
            }
          }; E.animationSettings = function () { return { apex: null, duration: u.Milliseconds(600), easing: A.outExpo } }; E.updateCamera = function (H, J, M, F, K) {
            var P = f.getReferenceEllipsoid(this.view.spatialReference); if (e.decideNavigationMode(H,
              F, K, P) === e.NavigationMode.Horizontal || q("disable-feature:context-navigation")) {
                J = .6 ** J; this.sphere[3] = b.length(M); b.subtract(this.tmpViewDir, H.center, H.eye); K = b.length(this.tmpViewDir); P = K * J; 1 >= J && 4 > P && (P = 4, J = P / K); if (1E-6 > Math.abs(K - P)) return; K = b.length(H.center); this.sphere[3] !== K && (H.center = b.scale(B, H.center, (this.sphere[3] + J * (K - this.sphere[3])) / K)); b.scale(this.tmpViewDir, this.tmpViewDir, -J); H.eye = b.add(B, H.center, this.tmpViewDir); v.applyAll(this.view, H, this.constraintOptions); 1E-12 < b.squaredDistance(M,
                  H.center) && x.intersectScreen(this.sphere, H, F, this.targetOnSphere) && e.panToPosition(this.sphere, H, M, this.targetOnSphere, this.view.camera.heading, this.view.camera.tilt, !0)
            } else {
              K = .6 ** Math.abs(J); P = 0 < J ? 1 : -1; g.fromScreenAtEye(H, F, this.tmpRayDir); b.normalize(this.tmpRayDir.direction, this.tmpRayDir.direction); var L; this.view.camera.position.hasZ && (L = Math.abs(this.view.camera.position.z)); L = Math.max(12 * L, 20); F = this.view._stage.renderView.getMinimalDepthForArea(null, F[0], F[1], this.view.state.camera, 60); L =
                L > F ? F : L; b.scale(this.tmpRayDir.direction, this.tmpRayDir.direction, L); b.add(M, this.tmpRayDir.origin, this.tmpRayDir.direction); M = L * K; F = Math.max(4, 1.01 * H.nearFar[0]); 0 < J && M < F && (M = F, K = M / L); if (1E-6 > Math.abs(L - M)) return; b.scale(this.tmpRayDir.direction, this.tmpRayDir.direction, P * (1 - K)); H.eye = b.add(B, H.eye, this.tmpRayDir.direction); H.center = b.add(B, H.center, this.tmpRayDir.direction)
            } z.applySurfaceCollisionConstraint(this.view, H)
          }; return D
        }(m.PointToPointAnimationController); a.ZoomStepController = c.__decorate([h.subclass("esri.views.3d.state.controllers.global.ZoomStepController")],
          a.ZoomStepController); const B = d.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/camera/constraintUtils": function () {
      define("exports ../../../chunks/vec2 ./constraintUtils/altitude ./constraintUtils/common ./constraintUtils/distance ./constraintUtils/surfaceCollision ./constraintUtils/tilt ../../animation/easing".split(" "), function (a, w, c, q, u, y, n, p) {
        const l = [{ type: 1, error: function (b, d, f) { return n.getTiltConstraintError(b, d, f) * d.distance }, apply: n.applyTiltConstraint }, {
          type: 2,
          error: c.getAltitudeConstraintError, apply: c.applyAltitudeConstraint
        }, { type: 4, error: u.getDistanceConstraintError, apply: u.applyDistanceConstraint }], h = { selection: 15, interactionType: 0, interactionFactor: 0, interactionStartCamera: null, interactionDirection: null, tiltMode: 0 }; a.applyAltitudeConstraint = c.applyAltitudeConstraint; a.getAltitudeConstraintError = c.getAltitudeConstraintError; a.applyDistanceConstraint = u.applyDistanceConstraint; a.getDistanceConstraintError = u.getDistanceConstraintError; a.applySurfaceCollisionConstraint =
          y.applySurfaceCollisionConstraint; a.applyTiltConstraint = n.applyTiltConstraint; a.getTiltConstraintError = n.getTiltConstraintError; a.applyAll = function (b, d, f = h, t = d) {
            let v = !1; t !== d && t.copyFrom(d); t.computeUp(b.state.viewingMode); for (d = 0; 5 > d; d++) { let e = 0; for (var m of l) if (q.hasConstraintType(f.selection, m.type)) { const g = Math.abs(m.error(b, t, f)); m.apply(b, t, f) && (v = !0, e += g) } if (0 === e) break } m = q.hasConstraintType(f.selection, 8); a: switch (f.interactionType) {
              case 4: f = 1; break a; case 5: f = b.state.isGlobal ? 2 : 1; break a;
              default: f = 0
            }m && y.applySurfaceCollisionConstraint(b, t, f) && (v = !0); v && t.computeUp(b.state.viewingMode); return v
          }; a.pixelDistanceToInteractionFactor = function (b, d) { b = "number" === typeof b ? b : w.distance(b, d); return p.inOutCubic(Math.min(1, b / 150)) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/camera/constraintUtils/altitude": function () {
      define("exports ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/ray ./common ../../support/intersectionUtils".split(" "),
        function (a, w, c, q, u, y, n, p) {
          function l(m, e, g = n.defaultApplyOptions) {
            var x = m.state.constraints.altitude; x = m.state.isGlobal && x ? 2 === g.interactionType && n.hasConstraintType(g.selection, 1) ? !1 : !0 : !1; if (!x) return 0; var k = m.state.constraints.altitude; x = b; x.min = k.min; x.max = k.max; k = g.interactionType; if (0 !== k) {
              var { min: r, max: A } = x, { interactionStartCamera: z, interactionFactor: B } = g; g = 2 === k || 1 === k; k = l(m, z); var C = 0 === k ? 0 : m.renderCoordsHelper.getAltitude(z.eye); x.min = r; x.max = A; n.adjustRangeForInteraction(k, C, g, B, .05 *
                C, x)
            } m = m.renderCoordsHelper.getAltitude(e.eye); m = w.clamp(m, x.min, x.max) - m; return 1E-6 >= Math.abs(m) ? 0 : m
          } function h(m, e, g, x) { m.renderCoordsHelper.worldUpAtPosition(e.eye, x); q.scale(x, x, g); return x } const b = { min: 0, max: 0 }, d = u.create(), f = u.create(), t = u.create(), v = u.create(); a.applyAltitudeConstraint = function (m, e, g = n.defaultApplyOptions) {
            const x = l(m, e, g); if (0 === x) return !1; const k = m.renderCoordsHelper, r = k.getAltitude(e.eye) + x; g = n.interactionDirectionTowardsConstraintMinimization(e, g.interactionDirection,
              h(m, e, Math.sign(x), f), d); m = q.copy(t, e.viewForward); g = k.intersectInfiniteManifold(y.wrap(e.eye, g), r, v); e.eye = c.isSome(g) ? g : k.setAltitude(v, r, e.eye); e.center = p.closestPointOnRay(v, e.eye, m, e.center); return !0
          }; a.getAltitudeConstraintError = l; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/camera/constraintUtils/common": function () {
      define(["exports", "../../../../chunks/vec3"], function (a, w) {
      a.adjustRangeForInteraction = function (c, q, u, y, n, p) {
      0 !== c && (u ? (p.min = Math.min(p.min, q), p.max = Math.max(p.max,
        q)) : null != y ? (p.min -= Math.max(0, (q - p.min) * (1 - y)), p.max += Math.max(0, (q - p.max) * (1 - y))) : n && (p.min -= Math.max(0, q - p.min - n), p.max += Math.max(0, q - p.max - n)))
      }; a.defaultApplyOptions = { selection: 0, interactionType: 0, interactionFactor: 0, interactionStartCamera: null, interactionDirection: null, tiltMode: 0 }; a.hasConstraintType = function (c, q) { return 0 !== (c & q) }; a.interactionDirectionTowardsConstraintMinimization = function (c, q, u, y) { q = q || c.viewForward; w.copy(y, q); w.scale(y, y, Math.sign(w.dot(q, u))); return y }; Object.defineProperty(a,
        "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/intersectionUtils": function () {
      define(["exports", "../../../chunks/vec2f64", "../../../chunks/vec3", "../../../chunks/vec3f64", "../../../geometry/support/plane"], function (a, w, c, q, u) {
        function y(l, h, b, d) { const f = p; l ? (b && d && (f.len = c.distance(h, b)), c.copy(f.dir, l)) : d ? (f.len = c.distance(h, b), c.subtract(f.dir, b, h), c.scale(f.dir, f.dir, 1 / f.len)) : (c.subtract(f.dir, b, h), c.normalize(f.dir, f.dir)); return f } function n(l, h, b, d) {
        d.clip[0] = 0; d.clip[1] = b ? d.len : Number.MAX_VALUE;
          for (b = 0; b < l.length; b++) { { var f = l[b], t = h; var v = d; const m = c.dot(u.normal(f), v.dir); f = -u.signedDistance(f, t); 0 > f && 0 <= m ? v = !1 : -1E-6 < m && 1E-6 > m ? v = 0 < f : !(0 > f || 0 > m) || 0 > f && 0 > m ? (f /= m, 0 < m ? f < v.clip[1] && (v.clip[1] = f) : f > v.clip[0] && (v.clip[0] = f), v = v.clip[0] <= v.clip[1]) : v = !0 } if (!v) return !1 } return !0
        } const p = { dir: q.create(), len: 0, clip: w.create() }; a.closestPointOnRay = function (l, h, b, d) { d = c.dot(b, c.subtract(l, d, h)); return c.add(l, h, c.scale(l, b, d)) }; a.frustumLineSegment = function (l, h, b, d) { d = y(d, h, b, !0); return n(l, h, b, d) };
        a.frustumPoint = function (l, h) { for (let b = 0; 6 > b; b++)if (0 < u.signedDistance(l[b], h)) return !1; return !0 }; a.frustumRay = function (l, h, b, d) { b = y(d, h, b, !1); return n(l, h, null, b) }; a.frustumSphere = function (l, h, b) { const d = h[0], f = h[1]; h = h[2]; return l[0][0] * d + l[0][1] * f + l[0][2] * h + l[0][3] > b || l[1][0] * d + l[1][1] * f + l[1][2] * h + l[1][3] > b || l[2][0] * d + l[2][1] * f + l[2][2] * h + l[2][3] > b || l[3][0] * d + l[3][1] * f + l[3][2] * h + l[3][3] > b || l[4][0] * d + l[4][1] * f + l[4][2] * h + l[4][3] > b || l[5][0] * d + l[5][1] * f + l[5][2] * h + l[5][3] > b ? !1 : !0 }; a.planeSphere = function (l,
          h, b) { return l[0] * h[0] + l[1] * h[1] + l[2] * h[2] + l[3] < b }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/camera/constraintUtils/distance": function () {
      define("exports ../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/ray ../../../../chunks/sphere ./common".split(" "), function (a, w, c, q, u, y, n) {
        function p(v, m, e = n.defaultApplyOptions) {
          if (!v.state.isLocal) return 0; var g = v.state.constraints.distance; if (!v.pointsOfInterest.surfaceOrigin.renderLocation ||
            Infinity === g) return 0; l.min = 0; l.max = g; g = l; var x = e.interactionType; if (0 !== x) { var { min: k, max: r } = g, { interactionStartCamera: A, interactionFactor: z } = e; e = 1 === x || 4 === x; x = p(v, A); var B = 0 === x ? 0 : c.distance(A.eye, v.pointsOfInterest.surfaceOrigin.renderLocation); g.min = k; g.max = r; n.adjustRangeForInteraction(x, B, e, z, .05 * B, g) } v = c.distance(m.eye, v.pointsOfInterest.surfaceOrigin.renderLocation); v = l.max - v; return -1E-6 <= v ? 0 : v
        } const l = { min: 0, max: 0 }, h = q.create(), b = q.create(), d = q.create(), f = q.create(), t = q.create(); a.applyDistanceConstraint =
          function (v, m, e = n.defaultApplyOptions) {
            var g = p(v, m, e); if (0 === g) return !1; var x = v.pointsOfInterest.surfaceOrigin; g = c.distance(m.eye, v.pointsOfInterest.surfaceOrigin.renderLocation) + g; const k = c.copy(h, m.eye); e = n.interactionDirectionTowardsConstraintMinimization(m, e.interactionDirection, c.direction(f, m.eye, v.pointsOfInterest.surfaceOrigin.renderLocation), d); if (!y.intersectRay(y.fromCenterAndRadius(x.renderLocation, g), u.wrap(m.eye, e), t)) return !1; m.eye = t; x = c.subtract(b, m.eye, k); m.center = c.add(t, m.center,
              x); x = v.renderCoordsHelper.getAltitude(m.center); v = v.renderCoordsHelper.intersectInfiniteManifold(m.ray, x, t); w.isSome(v) && (m.center = v); return !0
          }; a.getDistanceConstraintError = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/camera/constraintUtils/surfaceCollision": function () {
      define(["exports", "../../../../chunks/vec3", "../../../../chunks/vec3f64", "../intersectionUtils"], function (a, w, c, q) {
        const u = c.create(), y = c.create(); a.applySurfaceCollisionConstraint = function (n, p, l = 0) {
          var h = n.state.constraints;
          if (!h.collision.enabled) return !1; var b = q.surfaceElevationBelowRenderLocation(n, p.eye); const d = n.renderCoordsHelper.getAltitude(p.eye); h = b + h.collision.elevationMargin; if (d >= h) return !1; b = w.length(p.eye); w.subtract(u, p.center, p.eye); p.eye = n.renderCoordsHelper.setAltitude(y, h, p.eye); 1 === l ? p.center = w.add(u, p.eye, u) : 2 === l && (p.center = w.scale(u, p.center, (b - d + h) / b)); return !0
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/camera/intersectionUtils": function () {
      define("exports ../../../core/maybe ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projectionEllipsoid ../../../geometry/support/aaBoundingRect ../webgl-engine/lib/Intersector".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(v, m) { return v.elevationProvider ? w.unwrapOr(v.elevationProvider.getElevation(m[0], m[1], m[2], v.renderCoordsHelper.spatialReference, "ground"), 0) : 0 } function l(v, m, e) { if (!v.state.isGlobal) return !1; const g = p(v, m); ({ far: v } = v.stateManager.constraintsManager.nearFarHeuristic.compute(m, e, v.renderDataExtent, g, t)); v *= v; return c.squaredDistance(m, e) > v } const h = {}, b = q.create(), d = q.create(), f = q.create(), t = { near: 0, far: 0 }; a.cameraOnContentAlongViewDirection = function (v, m, e, g) {
            const x =
              v.state.camera.clone(); m && (x.eye = m, x.center = e, x.up = g); m = x.ray; e = h[v.viewingMode]; e || (e = n.newIntersector(v.state.viewingMode), e.options.backfacesTerrain = !v.state.isGlobal, e.options.invisibleTerrain = !0, h[v.viewingMode] = e); ({ isGlobal: g } = v.state); v.sceneIntersectionHelper.intersectRay(m, e, d) && !l(v, m.origin, d) ? m = !0 : !v.renderCoordsHelper.intersectManifold(m, 0, d) || l(v, m.origin, d) ? g ? (e = u.getReferenceEllipsoid(v.spatialReference).radius, e = c.dot(m.origin, m.origin) - e * e, c.scale(d, m.direction, (0 < e ? Math.sqrt(e) /
                3 : 1) / c.length(m.direction)), c.add(d, d, m.origin), m = !0) : m = !1 : m = !0; m || c.copy(d, x.center); e = v.state.constraints; g = e.minimumPoiDistance; c.squaredDistance(x.eye, d) < g && (m = e.collision.enabled, c.copy(f, x.viewForward), c.scale(f, f, g), m ? x.eye = c.subtract(b, d, f) : c.add(d, x.eye, f), v = v.renderCoordsHelper, g = v.getAltitude(x.eye), e = e.collision.elevationMargin, m && g < e && (c.subtract(f, d, x.eye), x.eye = v.setAltitude(b, e, x.eye), c.add(d, x.eye, f))); x.center = d; return x
          }; a.eyeWithinExtent = function (v, m, e, g) {
            return w.isSome(v.renderCoordsHelper.fromRenderCoords(m.eye,
              b, g)) && y.containsPoint(e, b)
          }; a.surfaceElevationBelowRenderLocation = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/Intersector": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/support/ray ./IntersectorInterfaces ./intersectorUtils ./verticalOffsetUtils ../materials/renderers/utils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          function v(r) { return new g(r) } let m = function () {
            function r(z) { this.options = new b.IntersectorOptions; this._results = new e; this.transform = new f.IntersectorTransform; this.tolerance = 1E-5; this.verticalOffset = null; this._ray = h.create(); this._rayEnd = n.create(); this._rayBeginTransformed = n.create(); this._rayEndTransformed = n.create(); this.viewingMode = null == z ? 1 : z } var A = r.prototype; A.reset = function (z, B, C) { this.resetWithRay(h.fromPoints(z, B, this._ray), C) }; A.resetWithRay = function (z,
              B) { this.camera = B; z !== this._ray && h.copy(z, this._ray); 0 !== this.options.verticalOffset ? 2 === this.viewingMode ? this._ray.origin[2] -= this.options.verticalOffset : this.verticalOffset = this.options.verticalOffset : this.verticalOffset = null; y.add(this._rayEnd, this._ray.origin, this._ray.direction); this._results.init(this._ray) }; A.intersect = function (z = null, B, C, D, E) {
              this.point = B; this.filterPredicate = D; this.tolerance = null == C ? 1E-5 : C; B = f.getVerticalOffsetObject3D(this.verticalOffset); if (c.isSome(z) && 0 < z.length) {
                const H =
                  E ? J => { E(J) && this.intersectObject(J) } : J => { this.intersectObject(J) }; for (const J of z) z = J.getSpatialQueryAccelerator && J.getSpatialQueryAccelerator(), c.isSome(z) ? (c.isSome(B) ? z.forEachAlongRayWithVerticalOffset(this._ray.origin, this._ray.direction, H, B) : z.forEachAlongRay(this._ray.origin, this._ray.direction, H), this.options.selectionMode && this.options.hud && z.forEachDegenerateObject(H)) : J.objects.forAll(M => H(M))
              } this.sortResults()
              }; A.intersectObject = function (z) {
                const B = z.geometryRecords; if (B) {
                  var C = z.transformation,
                  D = f.getVerticalOffsetObject3D(this.verticalOffset); for (const E of B) {
                    const { geometry: H, material: J, instanceParameters: M } = E; if (t.isInstanceHidden(M)) continue; const F = H.id; this.transform.setAndInvalidateLazyTransforms(C, E.getShaderTransformation()); y.transformMat4(this._rayBeginTransformed, this.rayBegin, this.transform.inverse); y.transformMat4(this._rayEndTransformed, this.rayEnd, this.transform.inverse); const K = this.transform.transform; c.isSome(D) && (D.objectTransform = this.transform); J.intersect(H, M, this.transform.transform,
                      this, this._rayBeginTransformed, this._rayEndTransformed, (P, L, N, G, I, O) => {
                      0 <= P && (!c.isSome(this.filterPredicate) || this.filterPredicate(this._ray.origin, this._rayEnd, P)) && (G ? (null == this._results.hud.dist || P < this._results.hud.dist) && this._results.hud.set(1, { object: z, geometryId: F, triangleNr: N, center: O }, P, L, u.IDENTITY, I) : ((null == this._results.min.drapedLayerOrder || I >= this._results.min.drapedLayerOrder) && (null == this._results.min.dist || P < this._results.min.dist) && this._results.min.set(0, {
                        object: z, geometryId: F,
                        triangleNr: N
                      }, P, L, K, I), 0 !== this.options.store && (null == this._results.max.drapedLayerOrder || I < this._results.max.drapedLayerOrder) && (null == this._results.max.dist || P > this._results.max.dist) && this._results.max.set(0, { object: z, geometryId: F, triangleNr: N }, P, L, K, I), 2 === this.options.store && (G = v(this._ray), G.set(0, { object: z, geometryId: F, triangleNr: N }, P, L, K), this._results.all.push(G))))
                      }, E.shaderTransformation)
                  }
                }
              }; A.sortResults = function () {
                this._results.all.sort((z, B) => z.dist !== B.dist ? c.unwrapOr(z.dist, 0) - c.unwrapOr(B.dist,
                  0) : z.drapedLayerOrder !== B.drapedLayerOrder ? c.unwrapOr(z.drapedLayerOrder, Number.MAX_VALUE) - c.unwrapOr(B.drapedLayerOrder, Number.MAX_VALUE) : c.unwrapOr(B.drapedLayerGraphicOrder, Number.MIN_VALUE) - c.unwrapOr(z.drapedLayerGraphicOrder, Number.MIN_VALUE))
              }; w._createClass(r, [{ key: "results", get: function () { return this._results } }, { key: "ray", get: function () { return this._ray } }, { key: "rayBegin", get: function () { return this._ray.origin } }, { key: "rayEnd", get: function () { return this._rayEnd } }]); return r
          }(), e = function () {
            function r() {
            this._min =
              new g(h.create()); this._max = new g(h.create()); this._hud = new g(h.create()); this._ground = new g(h.create())
            } r.prototype.init = function (A) { this._min.init(A); this._max.init(A); this._hud.init(A); this._ground.init(A); this.all = [] }; w._createClass(r, [{ key: "min", get: function () { return this._min } }, { key: "max", get: function () { return this._max } }, { key: "hud", get: function () { return this._hud } }, { key: "ground", get: function () { return this._ground } }]); return r
          }(), g = function () {
            function r(z) {
            this.intersector = 0; this.normal = n.create();
              this.transformation = u.create(); this._ray = h.create(); this.init(z)
            } var A = r.prototype; A.getIntersectionPoint = function (z) { if (!d.isValidIntersectorResult(this)) return !1; y.scale(x, this.ray.direction, this.dist); y.add(z, this.ray.origin, x); return !0 }; A.getTransformedNormal = function (z) { y.copy(k, this.normal); k[3] = 0; p.transformMat4(k, k, this.transformation); y.copy(z, k); return y.normalize(z, z) }; A.init = function (z) {
            this.drapedLayerGraphicOrder = this.drapedLayerOrder = this.target = this.dist = null; this.intersector = 0; h.copy(z,
              this._ray)
            }; A.set = function (z, B, C, D, E, H, J) { this.intersector = z; this.dist = C; y.copy(this.normal, c.unwrapOr(D, n.UNIT_Z)); q.copy(this.transformation, c.unwrapOr(E, u.IDENTITY)); this.target = B; this.drapedLayerOrder = H; this.drapedLayerGraphicOrder = J }; A.copy = function (z) {
              h.copy(z.ray, this._ray); this.intersector = z.intersector; this.dist = z.dist; this.target = z.target; this.drapedLayerOrder = z.drapedLayerOrder; this.drapedLayerGraphicOrder = z.drapedLayerGraphicOrder; y.copy(this.normal, z.normal); q.copy(this.transformation,
                z.transformation)
            }; w._createClass(r, [{ key: "ray", get: function () { return this._ray } }, { key: "distanceInRenderSpace", get: function () { return c.isSome(this.dist) ? (y.scale(x, this.ray.direction, this.dist), y.length(x)) : null } }]); return r
          }(); const x = n.create(), k = l.create(); a.DEFAULT_TOLERANCE = 1E-5; a.newIntersector = function (r) { return new m(r) }; a.newIntersectorResult = v; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/IntersectorInterfaces": function () {
      define(["exports"], function (a) {
      a.IntersectorOptions =
        function () { this.verticalOffset = 0; this.selectionMode = !1; this.selectOpaqueTerrainOnly = this.hud = !0; this.invisibleTerrain = !1; this.backfacesTerrain = !0; this.isFiltered = !1; this.store = 2 }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/intersectorUtils": function () {
      define(["exports", "../../../../core/maybe", "../../../../chunks/vec3", "../../../../chunks/vec3f64", "../../../../chunks/boundedPlane"], function (a, w, c, q, u) {
        function y(p) { return w.isSome(p) && w.isSome(p.dist) } const n =
          q.create(); a.isHudIntersectorResult = function (p) { return y(p) && 1 === p.intersector && !!p.target && w.isSome(p.target.center) }; a.isObjectIntersectorResult = function (p) { return y(p) && 0 === p.intersector && !!p.target }; a.isValidIntersectorResult = y; 
          a.sliceFilterPredicate = function (p) { return (l, h, b) => {
            c.lerp(n, l, h, b);return !u.extrusionContainsPoint(p, n) } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/verticalOffsetUtils": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/quat ../../../../chunks/quatf64 ../../../../chunks/vec3 ../../../../chunks/vec3f32 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../../chunks/sphere".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          let v = function () {
            function B() { this._transform = n.create(); this._transformInverse = new m({ value: this._transform }, y.invert, n.create); this._transformInverseTranspose = new m(this._transformInverse, y.transpose, n.create); this._transformTranspose = new m({ value: this._transform }, y.transpose, n.create); this._transformInverseRotation = new m({ value: this._transform }, q.normalFromMat4Legacy, u.create) } var C = B.prototype; C.invalidateLazyTransforms = function () {
              this._transformInverse.invalidate();
              this._transformInverseTranspose.invalidate(); this._transformTranspose.invalidate(); this._transformInverseRotation.invalidate()
            }; C.setTransformMatrix = function (D) { y.copy(this._transform, D) }; C.multiplyTransform = function (D) { y.multiply(this._transform, this._transform, D) }; C.set = function (D) { y.copy(this._transform, D); this.invalidateLazyTransforms() }; C.setAndInvalidateLazyTransforms = function (D, E) { this.setTransformMatrix(D); this.multiplyTransform(E); this.invalidateLazyTransforms() }; w._createClass(B, [{
              key: "transform",
              get: function () { return this._transform }
            }, { key: "inverse", get: function () { return this._transformInverse.value } }, { key: "inverseTranspose", get: function () { return this._transformInverseTranspose.value } }, { key: "inverseRotation", get: function () { return this._transformInverseRotation.value } }, { key: "transpose", get: function () { return this._transformTranspose.value } }]); return B
          }(), m = function () {
            function B(C, D, E) { this.original = C; this.update = D; this.dirty = !0; this.transform = E() } B.prototype.invalidate = function () {
            this.dirty =
              !0
            }; w._createClass(B, [{ key: "value", get: function () { this.dirty && (this.update(this.transform, this.original.value), this.dirty = !1); return this.transform } }]); return B
          }(), e = function () {
            function B(D = 0) { this.offset = D; this.tmpVertex = d.create() } var C = B.prototype; C.applyToVertex = function (D, E, H) { const J = D + this.localOrigin[0], M = E + this.localOrigin[1], F = H + this.localOrigin[2], K = this.offset / Math.sqrt(J * J + M * M + F * F); this.tmpVertex[0] = D + J * K; this.tmpVertex[1] = E + M * K; this.tmpVertex[2] = H + F * K; return this.tmpVertex }; C.applyToAabb =
              function (D) { var E = D[0] + this.localOrigin[0]; const H = D[1] + this.localOrigin[1], J = D[2] + this.localOrigin[2], M = D[3] + this.localOrigin[0], F = D[4] + this.localOrigin[1], K = D[5] + this.localOrigin[2], P = this.offset / Math.sqrt(E * E + H * H + J * J); D[0] += E * P; D[1] += H * P; D[2] += J * P; E = this.offset / Math.sqrt(M * M + F * F + K * K); D[3] += M * E; D[4] += F * E; D[5] += K * E; return D }; return B
          }(), g = function () {
            function B(D = 0) {
            this.offset = D; this.componentLocalOriginLength = 0; this.tmpVertex = d.create(); this.mbs = f.create(); this.obb = {
              center: d.create(), halfSize: b.create(),
              quaternion: null
            }
            } var C = B.prototype; C.applyToVertex = function (D, E, H) { const J = H + this.componentLocalOriginLength, M = this.offset / Math.sqrt(D * D + E * E + J * J); this.tmpVertex[0] = D + D * M; this.tmpVertex[1] = E + E * M; this.tmpVertex[2] = H + J * M; return this.tmpVertex }; C.applyToAabb = function (D) {
              var E = D[0]; const H = D[1], J = D[2] + this.componentLocalOriginLength, M = D[3], F = D[4], K = D[5] + this.componentLocalOriginLength, P = this.offset / Math.sqrt(E * E + H * H + J * J); D[0] += E * P; D[1] += H * P; D[2] += J * P; E = this.offset / Math.sqrt(M * M + F * F + K * K); D[3] += M * E; D[4] +=
                F * E; D[5] += K * E; return D
            }; C.applyToMbs = function (D) { const E = Math.sqrt(D[0] * D[0] + D[1] * D[1] + D[2] * D[2]), H = this.offset / E; this.mbs[0] = D[0] + D[0] * H; this.mbs[1] = D[1] + D[1] * H; this.mbs[2] = D[2] + D[2] * H; this.mbs[3] = D[3] + D[3] * this.offset / E; return this.mbs }; C.applyToObb = function (D) {
              var E = D.center; const H = this.offset / Math.sqrt(E[0] * E[0] + E[1] * E[1] + E[2] * E[2]); this.obb.center[0] = E[0] + E[0] * H; this.obb.center[1] = E[1] + E[1] * H; this.obb.center[2] = E[2] + E[2] * H; h.transformQuat(this.obb.halfSize, D.halfSize, D.quaternion); h.add(this.obb.halfSize,
                this.obb.halfSize, D.center); E = this.offset / Math.sqrt(this.obb.halfSize[0] * this.obb.halfSize[0] + this.obb.halfSize[1] * this.obb.halfSize[1] + this.obb.halfSize[2] * this.obb.halfSize[2]); this.obb.halfSize[0] += this.obb.halfSize[0] * E; this.obb.halfSize[1] += this.obb.halfSize[1] * E; this.obb.halfSize[2] += this.obb.halfSize[2] * E; h.subtract(this.obb.halfSize, this.obb.halfSize, D.center); p.conjugate(z, D.quaternion); h.transformQuat(this.obb.halfSize, this.obb.halfSize, z); this.obb.halfSize[0] *= 0 > this.obb.halfSize[0] ? -1 :
                  1; this.obb.halfSize[1] *= 0 > this.obb.halfSize[1] ? -1 : 1; this.obb.halfSize[2] *= 0 > this.obb.halfSize[2] ? -1 : 1; this.obb.quaternion = D.quaternion; return this.obb
            }; w._createClass(B, [{ key: "localOrigin", set: function (D) { this.componentLocalOriginLength = Math.sqrt(D[0] * D[0] + D[1] * D[1] + D[2] * D[2]) } }]); return B
          }(), x = function () {
            function B(D = 0) { this.offset = D; this.sphere = t.create(); this.tmpVertex = d.create() } var C = B.prototype; C.applyToVertex = function (D, E, H) {
              const J = this.objectTransform.transform; let M = J[0] * D + J[4] * E + J[8] * H +
                J[12], F = J[1] * D + J[5] * E + J[9] * H + J[13]; D = J[2] * D + J[6] * E + J[10] * H + J[14]; E = this.offset / Math.sqrt(M * M + F * F + D * D); M += M * E; F += F * E; D += D * E; E = this.objectTransform.inverse; this.tmpVertex[0] = E[0] * M + E[4] * F + E[8] * D + E[12]; this.tmpVertex[1] = E[1] * M + E[5] * F + E[9] * D + E[13]; this.tmpVertex[2] = E[2] * M + E[6] * F + E[10] * D + E[14]; return this.tmpVertex
            }; C.applyToMinMax = function (D, E) {
              const H = this.offset / Math.sqrt(D[0] * D[0] + D[1] * D[1] + D[2] * D[2]); D[0] += D[0] * H; D[1] += D[1] * H; D[2] += D[2] * H; D = this.offset / Math.sqrt(E[0] * E[0] + E[1] * E[1] + E[2] * E[2]); E[0] +=
                E[0] * D; E[1] += E[1] * D; E[2] += E[2] * D
            }; C.applyToAabb = function (D) { var E = this.offset / Math.sqrt(D[0] * D[0] + D[1] * D[1] + D[2] * D[2]); D[0] += D[0] * E; D[1] += D[1] * E; D[2] += D[2] * E; E = this.offset / Math.sqrt(D[3] * D[3] + D[4] * D[4] + D[5] * D[5]); D[3] += D[3] * E; D[4] += D[4] * E; D[5] += D[5] * E; return D }; C.applyToBoundingSphere = function (D) { const E = Math.sqrt(D[0] * D[0] + D[1] * D[1] + D[2] * D[2]), H = this.offset / E; this.sphere[0] = D[0] + D[0] * H; this.sphere[1] = D[1] + D[1] * H; this.sphere[2] = D[2] + D[2] * H; this.sphere[3] = D[3] + D[3] * this.offset / E; return this.sphere };
            return B
          }(); const k = new x, r = new g, A = new e, z = l.create(); a.I3SVerticalOffsetGlobalViewingMode = g; a.IntersectorTransform = v; a.Object3DVerticalOffsetGlobalViewingMode = x; a.TERRAIN_ID = "terrain"; a.TerrainVerticalOffsetGlobalViewingMode = e; a.getVerticalOffsetI3S = function (B) { return c.isSome(B) ? (r.offset = B, r) : null }; a.getVerticalOffsetObject3D = function (B) { return c.isSome(B) ? (k.offset = B, k) : null }; a.getVerticalOffsetTerrain = function (B) { return c.isSome(B) ? (A.offset = B, A) : null }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/webgl-engine/materials/renderers/utils": function () {
      define("exports ../../../../../core/maybe ../../../../../chunks/mat4 ../../../../../chunks/mat4f64 ../../lib/Util ../../../../webgl/doublePrecisionUtils".split(" "), function (a, w, c, q, u, y) {
        const n = new Float64Array(3), p = new Float32Array(6), l = q.create(); a.addObject3DStateID = function (h, b) { w.isNone(h) && (h = []); h.push(b); return h }; a.calculateTransformRelativeToOrigin = function (h, b, d) {
          const f = h.origin.vec3; u.setMatrixTranslation3(l, -f[0], -f[1],
            -f[2]); w.isSome(h.transformation) ? c.multiply(b, l, h.transformation) : c.copy(b, l); d && (c.invert(d, b), c.transpose(d, d))
        }; a.encodeDoubleVec3 = function (h, b, d, f, t) { n[0] = h.get(b, 0); n[1] = h.get(b, 1); n[2] = h.get(b, 2); y.encodeDoubleArray(n, p, 3); d.set(t, 0, p[0]); f.set(t, 0, p[1]); d.set(t, 1, p[2]); f.set(t, 1, p[3]); d.set(t, 2, p[4]); f.set(t, 2, p[5]) }; a.isInstanceHidden = function (h) { return w.isSome(h) ? !h.visible : !1 }; a.removeObject3DStateID = function (h, b) {
          if (w.isNone(h)) return null; h = h.filter(d => d !== b); return 0 === h.length ? null :
            h
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/doublePrecisionUtils": function () {
      define(["exports"], function (a) {
        function w(u, y, n) { for (let p = 0; p < n; ++p)y[2 * p] = u[p], y[2 * p + 1] = u[p] - y[2 * p] } const c = new Float64Array(1), q = new Float32Array(2); a.decodeDoubleArray = function (u, y, n) { for (let p = 0; p < n; ++p)y[p] = u[2 * p] + u[2 * p + 1] }; a.encodeDouble = function (u, y) { q[0] = u; q[1] = u - q[0]; y[0] = q[0]; y[1] = q[1] }; a.encodeDoubleArray = w; a.encodeDoubleArraySplit = function (u, y, n, p) {
          for (let l = 0; l < p; ++l)c[0] = u[l], w(c,
            q, 1), y[l] = q[0], n[l] = q[1]
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/camera/constraintUtils/tilt": function () {
      define("exports ../../../../core/compilerUtils ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projectionEllipsoid ../../../../chunks/sphere ./common ../../state/utils/viewUtils".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d) {
        function f(B, C, D = b.defaultApplyOptions,
          E = !0) { z.eyeCenterDistance = 0; z.requiresTwoSteps = !1; const H = t(B, C, D, void 0, z); if (0 === H) return !1; u.identity(g); u.rotate(g, g, -H, C.viewRight); switch (D.tiltMode) { case 1: n.transformMat4(e, C.viewForward, g); n.scale(e, e, z.eyeCenterDistance); C.center = n.add(x, C.eye, e); break; case 0: n.subtract(e, C.center, C.eye); n.transformMat4(e, e, g); C.eye = n.subtract(x, C.center, e); break; default: w.neverReached(D.tiltMode) }C.up = n.transformMat4(x, C.up, g); return z.requiresTwoSteps && E ? f(B, C, D, !1) : !0 } function t(B, C, D = b.defaultApplyOptions,
            E = b.defaultApplyOptions, H) {
              if (!B.state.constraints.tilt) return 0; var J = B.state.constraints.tilt(C.distance, r); if (0 !== D.interactionType) { var { interactionStartCamera: M, interactionFactor: F } = D, { min: K, max: P } = J, L = t(B, M, b.defaultApplyOptions, D), N = 0 === L ? 0 : d.viewAngle(B.renderCoordsHelper, M.center, M.eye); J.min = K; J.max = P; 2 === D.interactionType ? (b.hasConstraintType(D.selection, 2) && m(B, M, J), b.adjustRangeForInteraction(L, N, !0, F, k, J)) : b.adjustRangeForInteraction(L, N, !1, F, k, J) } 2 === E.interactionType && b.hasConstraintType(E.selection,
                2) && m(B, E.interactionStartCamera, J); if (1 === D.tiltMode || 1 === E.tiltMode) {
                  a: switch (H && (H.requiresTwoSteps = !1), B.viewingMode) {
                    case "global": D = A; L = B.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude; E = L + l.getReferenceEllipsoid(B.spatialReference).radius; L = B.renderCoordsHelper.intersectManifold(C.ray, L, x); D.eyeCenterDistance = C.distance; D.centerIsOnSurface = !1; q.isSome(L) ? (D.eyeCenterDistance = n.distance(C.eye, L), D.tiltAtCenter = d.viewAngle(B.renderCoordsHelper, L, C.eye), D.centerIsOnSurface =
                      !0) : B.state.isLocal ? D.tiltAtCenter = d.viewAngle(B.renderCoordsHelper, C.center, C.eye) : (h.closestPointOnSilhouette(h.fromRadius(E), C.ray, x), D.eyeCenterDistance = n.distance(C.eye, x), D.tiltAtCenter = c.acosClamped(-n.dot(C.viewForward, n.normalize(x, x)))); D.radius = E; D.eyeRadius = n.length(C.eye); D.constraints = B.state.constraints; C = c.clamp(D.tiltAtCenter, J.min, J.max); if (1E-9 < Math.abs(D.tiltAtCenter - C)) {
                        if (D.centerIsOnSurface) {
                          {
                            const { constraints: G, eyeCenterDistance: I, tiltAtCenter: O } = D; C = O; B = G.clampTilt(I, O);
                            J = v(D, B); if (G.clampTilt(J, O) !== B) for (J = 0; 10 > J && 1E-9 < Math.abs(B - C);)E = (C + B) / 2, L = v(D, E), L = G.clampTilt(L, E), 1E-9 < Math.abs(L - E) ? C = E : B = E, J++; C = B
                          } J = C; B = c.asinClamped(D.radius / D.eyeRadius * Math.sin(D.tiltAtCenter)); J = c.asinClamped(D.radius / D.eyeRadius * Math.sin(J)); B = D.eyeRadius > D.radius ? B - J : J - B
                        } else C = D.constraints.clampTilt(D.eyeCenterDistance, D.tiltAtCenter), H && C < Math.PI / 2 && (H.requiresTwoSteps = !0, C = Math.PI / 2 - 1E-5), B = D.tiltAtCenter - Math.PI / 2 - (C - Math.PI / 2); H && (H.eyeCenterDistance = v(D, C)); H = B
                      } else H = 0; break a;
                    case "local": E = d.viewAngle(B.renderCoordsHelper, C.center, C.eye); D = c.clamp(E, J.min, J.max); J = E - D; 1E-9 < Math.abs(J) ? (H && (E = B.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude, B = B.renderCoordsHelper.getAltitude(C.eye) - E, D = Math.cos(D), H.eyeCenterDistance = 1E-4 < Math.abs(D) ? B / D : C.distance), H = J) : H = 0; break a; default: w.neverReached(B.viewingMode), H = void 0
                  }return H
                } H = d.viewAngle(B.renderCoordsHelper, C.center, C.eye); D = c.clamp(H, J.min, J.max); H -= D; H = 1E-9 < Math.abs(H) ? H : 0; return H
        } function v(B, C) {
          if (!B.centerIsOnSurface) return B.eyeCenterDistance;
          C = Math.PI - c.clamp(C, 0, Math.PI); const D = c.asinClamped(B.radius / B.eyeRadius * Math.sin(C)), E = Math.sin(Math.PI - C - D) / Math.sin(C); return B.eyeRadius < B.radius && 1 < E ? Math.sin(Math.PI - C - (Math.PI - D)) / Math.sin(C) * B.eyeRadius : E * B.eyeRadius
        } function m(B, C, D) {
          if (!B.state.isLocal) {
            var E = B.state.constraints; if (E.altitude) {
              var H = n.squaredLength(C.center), J = Math.sqrt(H); C = C.distance; var M = l.getReferenceEllipsoid(B.spatialReference).radius; B = E.altitude.min + M; E = E.altitude.max + M; B = (B * B - C * C - H) / (-2 * J * C); D.min = Math.max(D.min,
                Math.min(Math.PI - c.acosClamped((E * E - C * C - H) / (-2 * J * C)), D.max)); D.max = Math.min(D.max, Math.PI - c.acosClamped(B))
            }
          }
        } const e = p.create(), g = y.create(), x = p.create(), k = c.deg2rad(5), r = { min: 0, max: 0 }, A = { constraints: null, radius: 0, eyeRadius: 0, centerIsOnSurface: !0, eyeCenterDistance: 0, tiltAtCenter: 0 }, z = { eyeCenterDistance: 0, requiresTwoSteps: !1 }; a.applyTiltConstraint = f; a.getTiltConstraintError = t; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/utils/viewUtils": function () {
      define(["exports", "../../../../core/mathUtils",
        "../../../../chunks/vec3", "../../../../chunks/vec3f64"], function (a, w, c, q) { const u = q.create(), y = q.create(); a.viewAngle = function (n, p, l) { n.worldUpAtPosition(p, u); c.subtract(y, l, p); n = c.length(y); return 0 === n ? 0 : w.acosClamped(c.dot(y, u) / n) }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/animation/easing": function () {
      define(["exports"], function (a) {
        function w(O) { return O } function c(O) { const R = 2 * (O - Math.sqrt((O - 1) * O)), S = R / 2 / O; return Q => Q < S ? O * Q * Q : R * Q - R + 1 } function q(O, R) {
          return (S, Q) => S < R ? R * O(S /
            R, Q) : 1 - O((1 - S) / (1 - R), Q) * (1 - R)
        } const u = O => O * O, y = O => 1 - u(1 - O), n = O => .5 > O ? u(2 * O) / 2 : (1 - u(1 - 2 * (O - .5)) + 1) / 2, p = O => O * O * O, l = O => 1 - p(1 - O), h = O => .5 > O ? p(2 * O) / 2 : (1 - p(1 - 2 * (O - .5)) + 1) / 2, b = O => O * O * O * O, d = O => 1 - b(1 - O), f = O => .5 > O ? b(2 * O) / 2 : (1 - b(1 - 2 * (O - .5)) + 1) / 2, t = O => O * O * O * O * O, v = O => 1 - t(1 - O), m = O => .5 > O ? t(2 * O) / 2 : (1 - t(1 - 2 * (O - .5)) + 1) / 2, e = O => -Math.cos(O * Math.PI / 2) + 1, g = O => 1 - e(1 - O), x = O => .5 > O ? e(2 * O) / 2 : (1 - e(1 - 2 * (O - .5)) + 1) / 2, k = O => 2 ** (10 * (O - 1)), r = O => 1 - 2 ** (10 * (1 - O - 1)), A = O => .5 > O ? 2 ** (10 * (2 * O - 1)) / 2 : (1 - 2 ** (10 * (1 - 2 * (O - .5) - 1)) + 1) / 2, z = O => -(Math.sqrt(1 -
          O * O) - 1), B = O => 1 - z(1 - O), C = O => .5 > O ? z(2 * O) / 2 : (1 - z(1 - 2 * (O - .5)) + 1) / 2, D = q(c(1), 1), E = q(c(1), 0), H = q(c(1), .5), J = q(c(2), 1), M = q(c(2), 0), F = q(c(2), .5), K = q(c(3), 1), P = q(c(3), 0), L = q(c(3), .5), N = q(c(4), 1), G = q(c(4), 0), I = q(c(4), .5); a.EasingFunctions = {
            linear: w, "in-quad": u, "out-quad": y, "in-out-quad": n, "in-coast-quad": D, "out-coast-quad": E, "in-out-coast-quad": H, "in-cubic": p, "out-cubic": l, "in-out-cubic": h, "in-coast-cubic": J, "out-coast-cubic": M, "in-out-coast-cubic": F, "in-quart": b, "out-quart": d, "in-out-quart": f, "in-coast-quart": K,
            "out-coast-quart": P, "in-out-coast-quart": L, "in-quint": t, "out-quint": v, "in-out-quint": m, "in-coast-quint": N, "out-coast-quint": G, "in-out-coast-quint": I, "in-sine": e, "out-sine": g, "in-out-sine": x, "in-expo": k, "out-expo": r, "in-out-expo": A, "in-circ": z, "out-circ": B, "in-out-circ": C
          }; a.inCirc = z; a.inCoastCubic = J; a.inCoastQuad = D; a.inCoastQuart = K; a.inCoastQuint = N; a.inCubic = p; a.inExpo = k; a.inOutCirc = C; a.inOutCoastCubic = F; a.inOutCoastQuad = H; a.inOutCoastQuart = L; a.inOutCoastQuint = I; a.inOutCubic = h; a.inOutExpo = A; a.inOutQuad =
            n; a.inOutQuart = f; a.inOutQuint = m; a.inOutSine = x; a.inQuad = u; a.inQuart = b; a.inQuint = t; a.inSine = e; a.linear = w; a.outCirc = B; a.outCoastCubic = M; a.outCoastQuad = E; a.outCoastQuart = P; a.outCoastQuint = G; a.outCubic = l; a.outExpo = r; a.outQuad = y; a.outQuart = d; a.outQuint = v; a.outSine = g; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/PointToPointAnimationController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3f64 ../../../ViewAnimation ../../animation/pointToPoint/Animation ./AnimationController ../../webgl-engine/lib/Camera ../../webgl-engine/lib/Intersector ../../../animation/easing".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
        a.PointToPointAnimationController = function (g) {
          function x(r) { r = g.call(this, r) || this; r.view = null; r.mode = "interaction"; r.hasTarget = !1; return r } w._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this.animation = new b.Animation(this.view.state.viewingMode); this.viewAnimation = "interaction" === this.mode ? null : new h }; k.begin = function (r, A) {
          this.hasTarget = !0; A = this.animationSettings(A); m.copyFrom(this.view.state.camera); const z = t.newIntersector(this.view.state.viewingMode);
            this.intersectionHelper.intersectRay(m.ray, z, e) && (m.center = e); this.animation.update(m, r, A); this.animation.finished && this.finish()
          }; k.finish = function () { this.animation.currentTime = this.animation.time; g.prototype.finish.call(this) }; k.stepController = function (r, A) { this.hasTarget && this.animation.step(r, A) }; k.onControllerEnd = function (r) {
          this.hasTarget && (this.animation.cameraAt(this.animation.currentTime / this.animation.time, r), this.animation.currentTime = this.animation.time); g.prototype.onControllerEnd.call(this,
            r)
          }; k.animationSettings = function (r = {}) { return { apex: { maximumDistance: this.view.state.constraints.clampAltitude(Infinity) / 6, ascensionFactor: void 0, descensionFactor: void 0 }, ...r, easing: "string" === typeof r.easing ? v.EasingFunctions[r.easing] : r.easing } }; w._createClass(x, [{ key: "intersectionHelper", get: function () { return this.view.sceneIntersectionHelper } }, { key: "isInteractive", get: function () { return "interaction" === this.mode } }, { key: "steppingFinished", get: function () { return this.hasTarget && this.animation.finished } }]);
          return x
        }(d.AnimationController); c.__decorate([q.property({ constructOnly: !0 })], a.PointToPointAnimationController.prototype, "view", void 0); c.__decorate([q.property({ constructOnly: !0 })], a.PointToPointAnimationController.prototype, "mode", void 0); a.PointToPointAnimationController = c.__decorate([p.subclass("esri.views.3d.state.controllers.PointToPointAnimationController")], a.PointToPointAnimationController); const m = new f, e = l.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/animation/pointToPoint/Animation": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/time ../../../../chunks/vec3 ../../../../chunks/vec3f64 ./Camera ../../webgl-engine/lib/Camera ../../../animation/pointToPoint/Animation".split(" "),
        function (a, w, c, q, u, y, n, p) {
          const l = u.create(); u = function () {
            function h(d) { this.currentTime = c.Milliseconds(0); this._animation = new p.Animation(() => new y(d)); this._current = new y(d) } var b = h.prototype; b.update = function (d, f, t) {
              const v = this._animation.definition.source, m = this._animation.definition.target, e = q.subtract(l, f.center, d.center), g = q.length(e); 1E-5 <= g ? (e[0] /= g, e[1] /= g, e[2] /= g) : (e[0] = 0, e[1] = 1, e[0] = 0); q.copy(v.lookAtDirection, e); q.copy(m.lookAtDirection, e); v.copyFromRenderCamera(d); m.copyFromRenderCamera(f);
              this._current.copyFrom(v); this._animation.update(v, m, t); this.currentTime = c.Milliseconds(0); d.almostEquals(f) && (this.currentTime = this._animation.time)
            }; b.cameraAt = function (d, f) { this._animation.cameraAt(d, this._current); f = f || new n; this._current.copyToRenderCamera(f); return f }; b.step = function (d, f) { this.finished || (this.currentTime = c.Milliseconds(this.currentTime + c.MillisecondsFromSeconds(d)), this.currentTime >= this.time && (this.currentTime = this.time)); return this.cameraAt(this.currentTime / this.time, f) };
            w._createClass(h, [{ key: "finished", get: function () { return this.currentTime >= this._animation.time } }, { key: "time", get: function () { return this._animation.time } }]); return h
          }(); a.Animation = u; a.default = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/animation/pointToPoint/Camera": function () {
      define("../../../../core/mathUtils ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../support/mathUtils".split(" "), function (a, w, c, q, u, y) {
        const n =
          u.create(), p = u.create(), l = u.create(), h = u.create(), b = u.create(), d = u.create(); var f = u.fromValues(0, 0, 1), t = u.fromValues(0, 1, 0), v = u.fromValues(1, 0, 0); const m = c.create(); return function () {
            function e(x = 1) { this.viewingMode = x; this.center = u.create(); this.distance = this.yaw = this.pitch = 0; this.lookAtDirection = u.clone(t) } var g = e.prototype; g.pixelsPerPanAtZoom = function (x) { return this.size / 2 / (this._zoomToPanScale * x) }; g.zoomAtPixelsPerPan = function (x) { return this.size / 2 / (this._zoomToPanScale * x) }; g.pixelsPerRotateAtZoom =
              function () { return this.size / 2 / Math.max(Math.cos(Math.abs(this.pitch)), .5) }; g.compareTo = function (x, k) { k || (k = { pan: 0, rotate: 0, sourceZoom: 0, targetZoom: 0 }); if (1 === this.viewingMode) { var r = q.length(this.center); const A = q.length(x.center); r = (r + A) / 2; k.pan = y.angle(this.center, x.center) * r } else k.pan = q.distance(this.center, x.center); r = Math.abs(x.yaw - this.yaw); r >= Math.PI && (r = 2 * Math.PI - r); k.rotate = Math.max(r, Math.abs(x.pitch - this.pitch)); k.sourceZoom = this.distance; k.targetZoom = x.distance; return k }; g.interpolate =
                function (x, k, r) { 1 === this.viewingMode ? y.slerp(x.center, k.center, r.pan, this.center) : q.lerp(this.center, x.center, k.center, r.pan); this.distance = a.lerp(x.distance, k.distance, r.zoom); this.pitch = a.lerp(x.pitch, k.pitch, r.rotate); x = x.yaw; k = k.yaw; Math.abs(k - x) >= Math.PI && (x += 2 * (x < k ? 1 : -1) * Math.PI); this.yaw = a.lerp(x, k, r.rotate) }; g.copyFrom = function (x) {
                  q.copy(this.center, x.center); this.pitch = x.pitch; this.yaw = x.yaw; this.distance = x.distance; q.copy(this.lookAtDirection, x.lookAtDirection); this.size = x.size; this.copyFromCommon(x);
                  this.viewingMode = x.viewingMode
                }; g.copyFromRenderCamera = function (x) { const k = this._lookAtOrientation(x.center, m); q.copy(this.center, x.center); q.subtract(h, x.center, x.eye); q.transformMat3(h, h, k); q.transformMat3(b, x.up, k); this.distance = q.length(h); h[0] /= this.distance; h[1] /= this.distance; h[2] /= this.distance; this.pitch = this._eyeUpToPitch(h); this.yaw = this._eyeUpToYaw(h, b); this.size = Math.sqrt(x.width * x.width + x.height * x.height); this.copyFromCommon(x) }; g.copyFromCommon = function (x) {
                this.fov = x.fov; this._zoomToPanScale =
                  Math.atan(.5 * this.fov)
                }; g.copyToRenderCamera = function (x) { const k = this._lookAtOrientation(this.center, m); w.transpose(k, k); this._axisAngleVec3(v, this.pitch - Math.PI / 2, t, h); this._axisAngleVec3(f, this.yaw, h); this._axisAngleVec3(v, this.pitch - Math.PI / 2, f, b); this._axisAngleVec3(f, this.yaw, b); q.scale(h, h, this.distance); q.transformMat3(h, h, k); q.transformMat3(b, b, k); x.center = this.center; x.eye = q.subtract(h, this.center, h); x.up = b }; g._axisAngleVec3 = function (x, k, r, A = r) {
                  const z = Math.cos(k); k = Math.sin(k); q.scale(n,
                    r, z); q.cross(p, x, r); q.scale(p, p, k); q.scale(l, x, (1 - z) * q.dot(x, r)); return q.add(A, q.add(A, n, p), l)
                }; g._lookAtOrientation = function (x, k = c.create()) { this._upAtLookAt(x, l); q.cross(n, this.lookAtDirection, l); q.normalize(n, n); 0 === n[0] && 0 === n[1] && 0 === n[2] && q.copy(n, v); q.cross(p, l, n); q.normalize(p, p); k[0] = n[0]; k[1] = p[0]; k[2] = l[0]; k[3] = n[1]; k[4] = p[1]; k[5] = l[1]; k[6] = n[2]; k[7] = p[2]; k[8] = l[2]; return k }; g._upAtLookAt = function (x, k) { return 2 === this.viewingMode ? q.copy(k, f) : q.normalize(k, x) }; g._eyeUpToPitch = function (x) {
                  return Math.PI -
                    y.angle(f, x)
                }; g._eyeUpToYaw = function (x, k) { .5 > Math.abs(k[2]) ? (q.copy(d, k), 0 < x[2] && q.scale(d, d, -1)) : q.copy(d, x); q.cross(p, d, f); q.normalize(p, p); return y.angle(v, p, f) }; return e
          }()
      })
    }, "esri/views/3d/webgl-engine/lib/Camera": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Logger ../../../../core/mathUtils ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/support/frustum ../../../../geometry/support/ray ../../../../geometry/support/vector ./Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          const g = w.getLogger("esri.views.3d.webgl-engine.lib.Camera"); w = function () {
            function B(D = null, E = null, H = null) {
            this._viewUp = b.create(); this._viewForward = b.create(); this._viewRight = b.create(); this._ray = v.create(); this._viewport = f.fromValues(0, 0, 1, 1); this._padding = f.fromValues(0, 0, 0, 0); this._fov = 55 / 180 * Math.PI; this._nearFar = l.fromValues(1, 1E3); this._viewDirty = !0; this._viewMatrix = n.create(); this._projectionDirty = !0; this._projectionMatrix = n.create(); this._viewProjectionDirty =
              !0; this._viewProjectionMatrix = n.create(); this._viewInverseTransposeMatrixDirty = !0; this._viewInverseTransposeMatrix = n.create(); this._frustumDirty = !0; this._frustum = t.create(); this._fullViewport = f.create(); this.pixelRatio = 1; this.relativeElevation = 0; q.isSome(D) && h.copy(this._ray.origin, D); this._center = q.isSome(E) ? b.clone(E) : b.create(); this._up = q.isSome(H) ? b.clone(H) : b.fromValues(0, 0, 1)
            } var C = B.prototype; C.depthNDCToWorld = function (D) { return 2 * this.near * this.far / (this.far + this.near - (2 * D - 1) * (this.far - this.near)) };
            C.copyFrom = function (D) {
              h.copy(this._ray.origin, D.eye); h.copy(this._center, D.center); h.copy(this._up, D.up); d.copy(this._viewport, D.viewport); d.copy(this._padding, D.padding); p.copy(this._nearFar, D.nearFar); this._fov = D.fov; this.relativeElevation = D.relativeElevation; this._viewDirty = D._viewDirty; this._viewDirty || (y.copy(this._viewMatrix, D.viewMatrix), h.copy(this._viewRight, D.viewRight), h.copy(this._viewUp, D.viewUp), h.copy(this._viewForward, D.viewForward)); D._projectionDirty ? this._projectionDirty = !0 : (y.copy(this._projectionMatrix,
                D.projectionMatrix), this._projectionDirty = !1); this._viewProjectionDirty = !0; this._frustumDirty = D._frustumDirty; this._frustumDirty || (t.copy(D.frustum, this._frustum), this._frustumDirty = !1); D._viewInverseTransposeMatrixDirty ? this._viewInverseTransposeMatrixDirty = !0 : (y.copy(this._viewInverseTransposeMatrix, D.viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = !1); d.copy(this._fullViewport, D.fullViewport); this.pixelRatio = D.pixelRatio; return this
            }; C.copyViewFrom = function (D) {
            this.eye = D.eye;
              this.center = D.center; this.up = D.up
            }; C.clone = function () { return (new B).copyFrom(this) }; C.equals = function (D) { return h.exactEquals(this.eye, D.eye) && h.exactEquals(this._center, D.center) && h.exactEquals(this._up, D.up) && d.exactEquals(this._viewport, D.viewport) && d.exactEquals(this._padding, D.padding) && p.exactEquals(this._nearFar, D.nearFar) && this._fov === D.fov && this.pixelRatio === D.pixelRatio && this.relativeElevation === D.relativeElevation }; C.almostEquals = function (D) {
              if (this.pixelRatio !== D.pixelRatio || .001 <= Math.abs(D.fov -
                this._fov)) return !1; const E = 1 - 1E-10; h.sub(r, D.eye, D.center); h.sub(A, this.eye, this._center); const H = h.dot(r, A), J = h.sqrLen(r), M = h.sqrLen(A); return H * H >= E * J * M && h.sqrDist(D.eye, this.eye) < 2.5E-7 * Math.max(J, M) && .5 > d.squaredDistance(D.padding, this._padding) && .5 > d.squaredDistance(D.viewport, this._viewport)
            }; C.computeRenderPixelSizeAt = function (D) { return this.computeRenderPixelSizeAtDist(this.viewDirectionDistance(D)) }; C.computeRenderPixelSizeAtDist = function (D) { return D * this.perRenderPixelRatio }; C.computeScreenPixelSizeAt =
              function (D) { return this.computeScreenPixelSizeAtDist(this.viewDirectionDistance(D)) }; C.viewDirectionDistance = function (D) { return Math.abs(m.projectPointSignedLength(this.viewForward, h.subtract(r, D, this.eye))) }; C.computeScreenPixelSizeAtDist = function (D) { return D * this.perScreenPixelRatio }; C.computeDistanceFromRadius = function (D, E) { return D / Math.tan(Math.min(this.fovX, this.fovY) / (2 * (E || 1))) }; C.getScreenCenter = function (D = u.createScreenPointArray()) {
              D[0] = (this.padding[3] + this.width / 2) / this.pixelRatio; D[1] =
                (this.padding[0] + this.height / 2) / this.pixelRatio; return D
              }; C.getRenderCenter = function (D, E = .5, H = .5) { D[0] = this.padding[3] + this.width * E; D[1] = this.padding[2] + this.height * H; D[2] = .5; return D }; C.setGLViewport = function (D) { const E = this.viewport, H = this.padding; D.setViewport(E[0] - H[3], E[1] - H[2], E[2] + H[1] + H[3], E[3] + H[0] + H[2]) }; C.applyProjection = function (D, E, H = !1) {
              D !== x && h.copy(x, D); x[3] = 1; H && (E[2] = -x[2]); d.transformMat4(x, x, this.projectionMatrix); h.scale(x, x, 1 / Math.abs(x[3])); D = this.fullViewport; E[0] = c.lerp(0,
                D[0] + D[2], .5 + .5 * x[0]); E[1] = c.lerp(0, D[1] + D[3], .5 + .5 * x[1]); H || (E[2] = .5 * (x[2] + 1)); return E
              }; C.projectToScreen = function (D, E) { this.projectToRenderScreen(D, z); this.renderToScreen(z, E) }; C.projectToRenderScreen = function (D, E) {
              x[0] = D[0]; x[1] = D[1]; x[2] = D[2]; x[3] = 1; d.transformMat4(x, x, this.viewProjectionMatrix); if (0 === x[3]) return null; h.scale(x, x, 1 / Math.abs(x[3])); D = this.fullViewport; "x" in E ? (E.x = c.lerp(0, D[0] + D[2], .5 + .5 * x[0]), E.y = c.lerp(0, D[1] + D[3], .5 + .5 * x[1])) : (E[0] = c.lerp(0, D[0] + D[2], .5 + .5 * x[0]), E[1] = c.lerp(0,
                D[1] + D[3], .5 + .5 * x[1]), 2 < E.length && (E[2] = .5 * (x[2] + 1))); return E
              }; C.unprojectFromScreen = function (D, E) { return this.unprojectFromRenderScreen(this.screenToRender(D, z), E) }; C.unprojectFromRenderScreen = function (D, E) { y.multiply(k, this.projectionMatrix, this.viewMatrix); if (!y.invert(k, k)) return null; const H = this.fullViewport; x[0] = 2 * (D[0] - H[0]) / H[2] - 1; x[1] = 2 * (D[1] - H[1]) / H[3] - 1; x[2] = 2 * D[2] - 1; x[3] = 1; d.transformMat4(x, x, k); if (0 === x[3]) return null; E[0] = x[0] / x[3]; E[1] = x[1] / x[3]; E[2] = x[2] / x[3]; return E }; C.constrainWindowSize =
                function (D, E, H, J = H) { D *= this.pixelRatio; E *= this.pixelRatio; return [Math.max(D - H / 2, 0), Math.max(this.fullHeight - E - J / 2, 0), H - -Math.min(D - H / 2, 0) - -Math.min(this.fullWidth - D - H / 2, 0), J - -Math.min(this.fullHeight - E - J / 2, 0) - -Math.min(E - J / 2, 0)] }; C.computeUp = function (D) { 1 === D ? this.computeUpGlobal() : this.computeUpLocal() }; C.screenToRender = function (D, E) { const H = this.fullHeight - D[1] * this.pixelRatio; E[0] = D[0] * this.pixelRatio; E[1] = H; return E }; C.renderToScreen = function (D, E) {
                  const H = (this.fullHeight - D[1]) / this.pixelRatio;
                  E[0] = D[0] / this.pixelRatio; E[1] = H
                }; C.computeUpGlobal = function () { h.subtract(r, this.center, this.eye); const D = h.length(this.center); 1 > D ? (h.set(this._up, 0, 0, 1), this._markViewDirty()) : Math.abs(h.dot(r, this.center)) > .9999 * h.length(r) * D || (h.cross(this._up, r, this.center), h.cross(this._up, this._up, r), h.normalize(this._up, this._up), this._markViewDirty()) }; C.computeUpLocal = function () {
                  h.direction(r, this.eye, this.center); .9999 >= Math.abs(r[2]) && (h.scale(r, r, r[2]), h.set(this._up, -r[0], -r[1], 1 - r[2]), h.normalize(this._up,
                    this._up), this._markViewDirty())
                }; C._compareAndSetView = function (D, E) { "number" === typeof D[0] && isFinite(D[0]) && "number" === typeof D[1] && isFinite(D[1]) && "number" === typeof D[2] && isFinite(D[2]) ? h.exactEquals(D, E) || (h.copy(E, D), this._markViewDirty()) : g.warn("Camera vector contains invalid number, ignoring value") }; C._markViewDirty = function () { this._viewProjectionDirty = this._frustumDirty = this._viewDirty = !0 }; C._recomputeFrustum = function () {
                this._frustumDirty && (t.fromMatrix(this.viewMatrix, this.projectionMatrix,
                  this._frustum), this._frustumDirty = !1)
                }; C._ensureViewClean = function () { this._viewDirty && (y.lookAt(this._viewMatrix, this.eye, this._center, this._up), h.set(this._viewForward, -this._viewMatrix[2], -this._viewMatrix[6], -this._viewMatrix[10]), h.set(this._viewUp, this._viewMatrix[1], this._viewMatrix[5], this._viewMatrix[9]), h.set(this._viewRight, this._viewMatrix[0], this._viewMatrix[4], this._viewMatrix[8]), this._viewDirty = !1, this._viewInverseTransposeMatrixDirty = !0) }; a._createClass(B, [{
                  key: "eye", get: function () { return this._ray.origin },
                  set: function (D) { this._compareAndSetView(D, this._ray.origin) }
                }, { key: "center", get: function () { return this._center }, set: function (D) { this._compareAndSetView(D, this._center) } }, { key: "ray", get: function () { h.subtract(this._ray.direction, this.center, this.eye); return this._ray } }, { key: "up", get: function () { return this._up }, set: function (D) { this._compareAndSetView(D, this._up) } }, {
                  key: "viewMatrix", get: function () { this._ensureViewClean(); return this._viewMatrix }, set: function (D) {
                    y.copy(this._viewMatrix, D); this._viewDirty =
                      !1; this._frustumDirty = this._viewProjectionDirty = this._viewInverseTransposeMatrixDirty = !0
                  }
                }, { key: "viewForward", get: function () { this._ensureViewClean(); return this._viewForward } }, { key: "viewUp", get: function () { this._ensureViewClean(); return this._viewUp } }, { key: "viewRight", get: function () { this._ensureViewClean(); return this._viewRight } }, { key: "nearFar", get: function () { return this._nearFar } }, {
                  key: "near", get: function () { return this._nearFar[0] }, set: function (D) {
                  this._nearFar[0] !== D && (this._nearFar[0] = D, this._frustumDirty =
                    this._viewProjectionDirty = this._projectionDirty = !0)
                  }
                }, { key: "far", get: function () { return this._nearFar[1] }, set: function (D) { this._nearFar[1] !== D && (this._nearFar[1] = D, this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0) } }, { key: "viewport", get: function () { return this._viewport }, set: function (D) { this.x = D[0]; this.y = D[1]; this.width = D[2]; this.height = D[3] } }, {
                  key: "x", get: function () { return this._viewport[0] }, set: function (D) {
                    D += this._padding[3]; this._viewport[0] !== D && (this._viewport[0] = D, this._frustumDirty =
                      this._viewProjectionDirty = this._projectionDirty = !0)
                  }
                }, { key: "y", get: function () { return this._viewport[1] }, set: function (D) { D += this._padding[2]; this._viewport[1] !== D && (this._viewport[1] = D, this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0) } }, { key: "width", get: function () { return this._viewport[2] }, set: function (D) { this._viewport[2] !== D && (this._viewport[2] = D, this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0) } }, {
                  key: "height", get: function () { return this._viewport[3] }, set: function (D) {
                  this._viewport[3] !==
                    D && (this._viewport[3] = D, this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0)
                  }
                }, { key: "fullWidth", get: function () { return this._viewport[2] + this._padding[1] + this._padding[3] }, set: function (D) { this.width = D - (this._padding[1] + this._padding[3]) } }, { key: "fullHeight", get: function () { return this._viewport[3] + this._padding[0] + this._padding[2] }, set: function (D) { this.height = D - (this._padding[0] + this._padding[2]) } }, {
                  key: "fullViewport", get: function () {
                  this._fullViewport[0] = this._viewport[0] - this._padding[3];
                    this._fullViewport[1] = this._viewport[1] - this._padding[2]; this._fullViewport[2] = this.fullWidth; this._fullViewport[3] = this.fullHeight; return this._fullViewport
                  }
                }, { key: "aspect", get: function () { return this.width / this.height } }, {
                  key: "padding", get: function () { return this._padding }, set: function (D) {
                    if (this._padding[0] !== D[0] || this._padding[1] !== D[1] || this._padding[2] !== D[2] || this._padding[3] !== D[3]) this._viewport[0] += D[3] - this._padding[3], this._viewport[1] += D[2] - this._padding[2], this._viewport[2] -= D[1] + D[3] -
                      (this._padding[1] + this._padding[3]), this._viewport[3] -= D[0] + D[2] - (this._padding[0] + this._padding[2]), d.copy(this._padding, D), this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0
                  }
                }, { key: "viewProjectionMatrix", get: function () { this._viewProjectionDirty && (y.multiply(this._viewProjectionMatrix, this.projectionMatrix, this.viewMatrix), this._viewProjectionDirty = !1); return this._viewProjectionMatrix } }, {
                  key: "projectionMatrix", get: function () {
                    if (this._projectionDirty) {
                      const D = this.width, E = this.height,
                      H = this.near * Math.tan(this.fovY / 2), J = H * this.aspect; y.frustum(this._projectionMatrix, -J * (1 + 2 * this._padding[3] / D), J * (1 + 2 * this._padding[1] / D), -H * (1 + 2 * this._padding[2] / E), H * (1 + 2 * this._padding[0] / E), this.near, this.far); this._projectionDirty = !1
                    } return this._projectionMatrix
                  }, set: function (D) { y.copy(this._projectionMatrix, D); this._projectionDirty = !1; this._frustumDirty = this._viewProjectionDirty = !0 }
                }, {
                  key: "fov", get: function () { return this._fov }, set: function (D) {
                  this._fov = D; this._frustumDirty = this._viewProjectionDirty =
                    this._projectionDirty = !0
                  }
                }, { key: "fovX", get: function () { return e.fovd2fovx(this._fov, this.width, this.height) }, set: function (D) { this._fov = e.fovx2fovd(D, this.width, this.height); this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0 } }, { key: "fovY", get: function () { return e.fovd2fovy(this._fov, this.width, this.height) }, set: function (D) { this._fov = e.fovy2fovd(D, this.width, this.height); this._frustumDirty = this._viewProjectionDirty = this._projectionDirty = !0 } }, {
                  key: "distance", get: function () {
                    return h.distance(this._center,
                      this.eye)
                  }
                }, { key: "frustum", get: function () { this._recomputeFrustum(); return this._frustum } }, { key: "viewInverseTransposeMatrix", get: function () { if (this._viewInverseTransposeMatrixDirty || this._viewDirty) y.invert(this._viewInverseTransposeMatrix, this.viewMatrix), y.transpose(this._viewInverseTransposeMatrix, this._viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = !1; return this._viewInverseTransposeMatrix } }, {
                  key: "perRenderPixelRatio", get: function () {
                    return Math.tan(this.fovX / 2) / (this.width /
                      2)
                  }
                }, { key: "perScreenPixelRatio", get: function () { return this.perRenderPixelRatio * this.pixelRatio } }, { key: "aboveGround", get: function () { return this.relativeElevation && 0 <= this.relativeElevation } }]); return B
          }(); const x = f.create(), k = n.create(), r = b.create(), A = b.create(), z = u.createRenderScreenPointArray3(); return w
        })
    }, "esri/geometry/support/frustum": function () {
      define("exports ../../core/ObjectStack ../../chunks/mat4 ../../chunks/vec3 ../../chunks/vec3f64 ../../chunks/vec4 ../../chunks/vec4f64 ./clipRay ./plane ./vectorStacks".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          function b(g) { return g ? [l.create(g[0]), l.create(g[1]), l.create(g[2]), l.create(g[3]), l.create(g[4]), l.create(g[5])] : [l.create(), l.create(), l.create(), l.create(), l.create(), l.create()] } function d() { return [u.create(), u.create(), u.create(), u.create(), u.create(), u.create(), u.create(), u.create()] } function f(g, x) {
            l.fromPoints(x[4], x[0], x[3], g[0]); l.fromPoints(x[1], x[5], x[6], g[1]); l.fromPoints(x[4], x[5], x[1], g[2]); l.fromPoints(x[3], x[2], x[6], g[3]); l.fromPoints(x[0], x[1], x[2],
              g[4]); l.fromPoints(x[5], x[4], x[7], g[5])
          } function t(g, x) { for (let k = 0; 6 > k; k++)if (!l.clip(g[k], x)) return !1; return !0 } const v = [n.fromValues(-1, -1, -1, 1), n.fromValues(1, -1, -1, 1), n.fromValues(1, 1, -1, 1), n.fromValues(-1, 1, -1, 1), n.fromValues(-1, -1, 1, 1), n.fromValues(1, -1, 1, 1), n.fromValues(1, 1, 1, 1), n.fromValues(-1, 1, 1, 1)], m = new w.ObjectStack(p.create), e = d(); a.computePlanes = f; a.copy = function (g, x = b()) { for (let k = 0; 6 > k; k++)l.copy(g[k], x[k]) }; a.create = b; a.createPoints = d; a.fromMatrix = function (g, x, k, r = e) {
            g = c.multiply(h.sm4d.get(),
              x, g); c.invert(g, g); for (x = 0; 8 > x; ++x) { const A = y.transformMat4(h.sv4d.get(), v[x], g); q.set(r[x], A[0] / A[3], A[1] / A[3], A[2] / A[3]) } f(k, r)
          }; a.intersectClipRay = function (g, x) { for (let k = 0; 6 > k; k++)if (!l.clipInfinite(g[k], x)) return !1; return !0 }; a.intersectsAABB = function (g, x) { for (let k = 0; 6 > k; k++)if (l.isAABBFullyInside(g[k], x)) return !1; return !0 }; a.intersectsLineSegment = function (g, x, k) { return t(g, p.fromLineSegmentAndDirection(x, k, m.get())) }; a.intersectsPoint = function (g, x) {
            for (let k = 0; 6 > k; k++)if (0 < l.signedDistance(g[k],
              x)) return !1; return !0
          }; a.intersectsRay = function (g, x) { return t(g, p.fromRay(x, m.get())) }; a.intersectsSphere = function (g, x) { for (let k = 0; 6 > k; k++) { const r = g[k]; if (r[0] * x[0] + r[1] * x[1] + r[2] * x[2] + r[3] >= x[3]) return !1 } return !0 }; a.planePointIndices = { bottom: [5, 1, 0, 4], near: [0, 1, 2, 3], far: [5, 4, 7, 6], right: [1, 5, 6, 2], left: [4, 0, 3, 7], top: [7, 3, 2, 6] }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/support/clipRay": function () {
      define(["exports", "../../core/ObjectStack", "../../chunks/vec3", "./ray", "./vectorStacks"],
        function (a, w, c, q, u) {
          function y(b) { return b ? { ray: q.create(b.ray), c0: b.c0, c1: b.c1 } : { ray: q.create(), c0: 0, c1: Number.MAX_VALUE } } function n(b, d, f, t = y()) { q.copy(b, t.ray); t.c0 = d; t.c1 = f; return t } function p(b, d, f = y()) { const t = c.length(b.vector); q.fromValues(b.origin, d, f.ray); f.c0 = 0; f.c1 = t; return f } function l(b, d, f) { return c.add(f, b.ray.origin, c.scale(f, b.ray.direction, d)) } const h = new w.ObjectStack(() => ({ c0: 0, c1: 0, ray: null })); a.copy = function (b, d = y()) { return n(b.ray, b.c0, b.c1, d) }; a.create = y; a.fromLineSegment =
            function (b, d = y()) { const f = c.normalize(u.sv3d.get(), b.vector); return p(b, f, d) }; a.fromLineSegmentAndDirection = p; a.fromRay = function (b, d = y()) { q.copy(b, d.ray); d.c0 = 0; d.c1 = Number.MAX_VALUE; return d }; a.fromValues = n; a.getAt = l; a.getEnd = function (b, d) { return l(b, b.c1, d) }; a.getStart = function (b, d) { return l(b, b.c0, d) }; a.wrap = function (b, d, f) { const t = h.get(); t.ray = b; t.c0 = d; t.c1 = f; return t }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/animation/pointToPoint/Animation": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/time ../easing ./Definition ./Settings ./apex/Path".split(" "),
        function (a, w, c, q, u, y, n) {
          const p = { zoom: 0, pan: 0, rotate: 0 }; let l = function () {
            function h(d) { this.createCamera = d; this._time = c.Milliseconds(0); this.definition = new u.Definition(d); this.path = new n.Path } var b = h.prototype; b.update = function (d, f, t) { this.definition.update(d, f, t); this.path.update(this.definition, t); this._time = this._applyTimeSettings(c.MillisecondsFromSeconds(this.path.time), t); this._easing = t.easing ? t.easing : 1E3 <= this._time ? q.inOutCoastQuad : q.outExpo }; b.cameraAt = function (d, f) {
              f = f || this.createCamera();
              d = Math.min(Math.max(0, d), 1); d = this._normalizedEasing(d); d = this.path.interpolateComponentsAt(d, p); f.interpolate(this.definition.source, this.definition.target, d); return f
            }; b._normalizedEasing = function (d) { const f = this._easing(0, this._time), t = this._easing(1, this._time); return (this._easing(d, this._time) - f) / (t - f) }; b._applyTimeSettings = function (d, f) {
              const t = null != f.speedFactor ? f.speedFactor : 1; null != f.duration ? d = f.duration : null != f.speedFactor && (d = c.Milliseconds(d / t)); return c.Milliseconds(Math.min(Math.max(null !=
                f.minDuration ? f.minDuration : y.defaultSettings.minDuration / t, d), null != f.maxDuration ? f.maxDuration : y.defaultSettings.maxDuration / t))
            }; w._createClass(h, [{ key: "time", get: function () { return this._time } }]); return h
          }(); a.Animation = l; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/animation/pointToPoint/Definition": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "./Settings"], function (a, w, c) {
        let q = function () {
          function u(n) {
          this.createCamera = n; this.compared = {
            sourceZoom: 0,
            targetZoom: 0, pan: 0, rotate: 0
          }; this.settings = { desiredScreenFlow: c.defaultSettings.desiredScreenFlow }; this.source = n(); this.target = n()
          } var y = u.prototype; y.clone = function () { const n = new u(this.createCamera); n.copyFrom(this); return n }; y.copyFrom = function (n) { this.update(n.source, n.target, n.settings) }; y.update = function (n, p, l) {
          this.source !== n && this.source.copyFrom(n); this.target !== p && this.target.copyFrom(p); this.compared = this.source.compareTo(this.target, this.compared); this.settings.desiredScreenFlow = null !=
            l.desiredScreenFlow ? l.desiredScreenFlow : c.defaultSettings.desiredScreenFlow; this.desiredPixelFlow = this.settings.desiredScreenFlow * this.target.size; this.halfWindowSize = this.target.size / 2
          }; y.halfWindowPanAtZoom = function (n) { n = this.target.pixelsPerPanAtZoom(n); return this.halfWindowSize / n }; w._createClass(u, [{ key: "hasZoom", get: function () { return 1E-5 < Math.abs(this.compared.sourceZoom - this.compared.targetZoom) } }, { key: "hasPan", get: function () { return 1E-9 < this.compared.pan } }, {
            key: "hasRotate", get: function () {
              return 1E-9 <
                this.compared.rotate
            }
          }]); return u
        }(); a.Definition = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/animation/pointToPoint/Settings": function () { define(["exports", "../../../core/time"], function (a, w) { w = { desiredScreenFlow: 2, minDuration: w.Milliseconds(500), maxDuration: w.Milliseconds(8E3) }; a.defaultSettings = w; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/animation/pointToPoint/apex/Path": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../easing ../Path ../Segment ./planning".split(" "),
        function (a, w, c, q, u, y) {
          q = function (n) {
            function p(h, b) { var d = n.call(this) || this; d._preallocSegments = [new u.Segment, new u.Segment, new u.Segment]; d.update(h, b); return d } w._inheritsLoose(p, n); var l = p.prototype; l.update = function (h, b) { if (h) { this.definition ? this.definition.copyFrom(h) : this.definition = h.clone(); var d = null; b && b.apex && (d = y.optimalDistance(h, b.apex)); this.segments.length = 0; this._descensionSegment = this._ascensionSegment = null; null == d ? this._updateWithoutApex() : this._updateWithApex(d, b.apex) } }; l.segmentInterpolateComponentsAt =
              function (h, b, d) { d = h.interpolateComponentsAt(b, d); h === this._ascensionSegment ? d.zoom = c.outQuad(d.zoom) : h === this._descensionSegment && (d.zoom = c.inQuad(d.zoom)); return d }; l._updateWithApex = function (h, b) {
                const [d, f, t] = this._preallocSegments, v = null != b.ascensionFactor ? b.ascensionFactor : .5; b = Math.min(1 - v, null != b.ascensionFactor ? b.descensionFactor : .5); const m = 1 - v - b; d.definition ? d.definition.copyFrom(this.definition) : d.definition = this.definition.clone(); d.definition.compared.targetZoom = h; d.definition.compared.pan =
                  this.definition.compared.pan * v; d.definition.compared.rotate = this.definition.compared.rotate * v; d.update(); this._ascensionSegment = d; this.segments.push(d); 0 < m && (f.definition ? f.definition.copyFrom(this.definition) : f.definition = this.definition.clone(), f.definition.copyFrom(this.definition), f.definition.compared.sourceZoom = h, f.definition.compared.targetZoom = h, f.definition.compared.pan = this.definition.compared.pan * m, f.definition.compared.rotate = this.definition.compared.rotate * m, f.update(), this.segments.push(f));
                t.definition ? t.definition.copyFrom(this.definition) : t.definition = this.definition.clone(); t.definition.compared.sourceZoom = h; t.definition.compared.pan = this.definition.compared.pan * b; t.definition.compared.rotate = this.definition.compared.rotate * b; t.update(); this._descensionSegment = t; this.segments.push(t)
              }; l._updateWithoutApex = function () { const [h] = this._preallocSegments; h.update(this.definition); this.segments.push(h) }; return p
          }(q.Path); a.Path = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/animation/pointToPoint/Path": function () {
      define(["exports",
        "../../../chunks/_rollupPluginBabelHelpers", "../../../core/time"], function (a, w, c) {
          let q = function () {
            function u() { this.segments = [] } var y = u.prototype; y.interpolateComponentsAt = function (n, p) {
              n = Math.min(Math.max(n, 0), 1); n *= this.time; var l = 0, h = 0; const b = this.definition; for (let d = 0; d < this.segments.length; d++) {
                const f = this.segments[d], t = f.definition; if (n <= f.time || d === this.segments.length - 1) return p = this.segmentInterpolateComponentsAt(f, n / f.time, p), p.pan = b.hasPan ? (l + t.compared.pan * p.pan) / b.compared.pan : 1,
                  p.rotate = b.hasRotate ? (h + t.compared.rotate * p.rotate) / b.compared.rotate : 1, n = p.zoom * (t.compared.targetZoom - t.compared.sourceZoom) + t.compared.sourceZoom, l = this.segments[0].definition.compared.sourceZoom, h = this.segments[this.segments.length - 1].definition.compared.targetZoom, p.zoom = b.hasZoom ? (n - l) / (h - l) : 1, p; n -= f.time; l += t.compared.pan; h += t.compared.rotate
              }
            }; y.segmentInterpolateComponentsAt = function (n, p, l) { return n.interpolateComponentsAt(p, l) }; w._createClass(u, [{
              key: "time", get: function () {
                return this.segments.reduce((n,
                  p) => c.Seconds(n + p.time), c.Seconds(0))
              }
            }]); return u
          }(); a.Path = q; a.default = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/animation/pointToPoint/Segment": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/time"], function (a, w, c) {
        let q = function () {
          function u(n) { n && this.update(n) } var y = u.prototype; y.update = function (n) { n && (this.definition ? this.definition.copyFrom(n) : this.definition = n.clone()); this._updatePrecomputedVariables(); this._updatePixelFlow() };
          y._updatePrecomputedVariables = function () { var n = this.definition; const p = n.compared, l = p.sourceZoom, h = p.targetZoom; this._zoomSign = l > h ? 1 : -1; this._panPixelsAtSource = p.pan * n.source.pixelsPerPanAtZoom(l); n = (n.source.pixelsPerRotateAtZoom(l) + n.target.pixelsPerRotateAtZoom(h)) / 2; this._rotatePixels = p.rotate * n }; y._updatePixelFlow = function () {
            var n = this.definition.compared.sourceZoom, p = this.definition.compared.targetZoom; const { hasZoom: l, hasPan: h, hasRotate: b } = this.definition; var d = 0, f = 0; l && (h && (d = (p / n - 1) / (-1 /
              (this._zoomSign * this.definition.halfWindowSize) * Math.LN2 * this._panPixelsAtSource)), b && (f = Math.log(n / p) / Math.LN2 * this._zoomSign * this.definition.halfWindowSize / this._rotatePixels)); this._rotatePixelFlow = this._panPixelFlow = this._zoomPixelFlow = 0; n = this.definition.desiredPixelFlow; l && h && b ? (p = d + f + d * f, this._zoomPixelFlow = d * f / p * n, this._panPixelFlow = f / p * n, this._rotatePixelFlow = d / p * n) : l && h ? (f = 1 + d, this._zoomPixelFlow = d / f * n, this._panPixelFlow = 1 / f * n) : l && b ? (d = 1 + f, this._zoomPixelFlow = f / d * n, this._rotatePixelFlow =
                1 / d * n) : h && b ? (d = this._panPixelsAtSource / this._rotatePixels, f = 1 + d, this._panPixelFlow = d / f * n, this._rotatePixelFlow = 1 / f * n) : h ? this._panPixelFlow = n : l ? this._zoomPixelFlow = n : b && (this._rotatePixelFlow = n); this._time = b ? this.rotateTime : l ? this.zoomTime : h ? this.panTime : c.Seconds(0)
          }; y._interpolateComponentsZoom = function (n) { if (0 === n || 1 === n) return n; if (this.definition.hasZoom) { const p = this.definition.compared.sourceZoom, l = this.definition.compared.targetZoom; return (p * (p / l) ** -n - p) / (l - p) } return n }; y._interpolateComponentsPan =
            function (n) { if (0 === n || 1 === n) return n; if (this.definition.hasPan && this.definition.hasZoom) { const p = -1 / (this._zoomSign * this.definition.halfWindowSize) * this._zoomPixelFlow; return 1 / this._panPixelsAtSource * this._panPixelFlow * (2 ** (p * n * this._time) - 1) / (p * Math.LN2) } return n }; y._interpolateComponentsRotate = function (n) { return n }; y.interpolateComponentsAt = function (n, p) {
              n = Math.min(Math.max(n, 0), 1); const l = this._interpolateComponentsZoom(n), h = this._interpolateComponentsPan(n); n = this._interpolateComponentsRotate(n);
              p ? (p.zoom = l, p.pan = h, p.rotate = n) : p = { zoom: l, pan: h, rotate: n }; return p
            }; w._createClass(u, [{ key: "time", get: function () { return this._time } }, { key: "rotateTime", get: function () { return this.definition.hasRotate ? c.Seconds(this._rotatePixels / this._rotatePixelFlow) : c.Seconds(0) } }, { key: "zoomTime", get: function () { return this.definition.hasZoom ? c.Seconds(Math.log(this.definition.compared.sourceZoom / this.definition.compared.targetZoom) / Math.LN2 * this._zoomSign * this.definition.halfWindowSize / this._zoomPixelFlow) : c.Seconds(0) } },
            { key: "panTime", get: function () { if (this.definition.hasPan) { if (this.definition.hasZoom) { const n = -1 / (this._zoomSign * this.definition.halfWindowSize) * Math.LN2; return c.Seconds(Math.log(this._zoomPixelFlow / this._panPixelFlow * this._panPixelsAtSource * n + 1) / (n * this._zoomPixelFlow)) } return c.Seconds(this._panPixelsAtSource / this._panPixelFlow) } return c.Seconds(0) } }]); return u
        }(); a.Segment = q; a.default = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/animation/pointToPoint/apex/planning": function () {
      define(["exports",
        "./functions"], function (a, w) {
          function c(q, u) { const y = Math.max(q.compared.sourceZoom, q.compared.targetZoom); q = q.source.zoomAtPixelsPerPan(q.desiredPixelFlow / q.compared.pan) / 2; return q < y ? null != u.maximumDistance ? y + (u.maximumDistance - y) / 2 : 1.5 * y : u.maximumDistance ? Math.min(u.maximumDistance, q) : q } a.optimalDistance = function (q, u) {
            let y = c(q, u); const n = { ascensionFactor: null != u.ascensionFactor ? u.ascensionFactor : .5, descensionFactor: null != u.descensionFactor ? u.descensionFactor : .5 }; var p = 0 === n.ascensionFactor, l =
              0 === n.descensionFactor; const h = p ? w.tAscensionZoomOnly : w.tAscensionZoomPan, b = p ? w.dtAscensionZoomOnly : w.dtAscensionZoomPan, d = p ? w.ddtAscensionZoomOnly : w.ddtAscensionZoomPan, f = l ? w.tDescensionZoomOnly : w.tDescensionZoomPan, t = l ? w.dtDescensionZoomOnly : w.dtDescensionZoomPan, v = l ? w.ddtDescensionZoomOnly : w.ddtDescensionZoomPan; p = A => h(q, A, n) + w.tPanion(q, A, n) + f(q, A, n); l = A => b(q, A, n) + w.dtPanion(q, A, n) + t(q, A, n); const m = A => d(q, A, n) + w.ddtPanion(q, A, n) + v(q, A, n); let e = p(y); const g = w.tBaseLine(q), x = u.maximumIterations ||
                20, k = null != u.maximumDistance ? u.maximumDistance : Infinity; for (u = 0; u < x; u++) { var r = (l(y) + 1E-6) / m(y); if (isNaN(r) || y >= k && 0 > r) { if (!isFinite(k)) return null; y = k; e = p(y); break } y -= r; if (y < q.compared.sourceZoom || y < q.compared.targetZoom) return null; r = p(y); if (.005 >= Math.abs(r - e) / e) break; e = r } return e > .7 * g || y < q.compared.sourceZoom || y < q.compared.targetZoom ? null : y
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/animation/pointToPoint/apex/functions": function () {
      define(["exports"], function (a) {
      a.ddtAscensionZoomOnly =
        function (w, c) { return -w.halfWindowSize / (c * c * w.desiredPixelFlow * Math.LN2) }; a.ddtAscensionZoomPan = function (w, c, q) { const u = c - w.compared.sourceZoom, y = 1 / u, n = 1 / c, p = Math.log(w.compared.sourceZoom * n); q = (q.ascensionFactor * Math.LN2 * w.compared.pan + w.halfWindowPanAtZoom(u)) / w.halfWindowPanAtZoom(1); return w.halfWindowSize * y * (-2 * y * n * q + 2 * y * p + 2 * n - 2 * p * q / (u * u) - q / (c * c)) / (w.desiredPixelFlow * Math.LN2) }; a.ddtDescensionZoomOnly = function (w, c) { return -w.halfWindowSize / (c * c * w.desiredPixelFlow * Math.LN2) }; a.ddtDescensionZoomPan =
          function (w, c, q) { const u = c - w.compared.targetZoom, y = 1 / u, n = 1 / c, p = Math.log(c / w.compared.targetZoom); q = (w.halfWindowPanAtZoom(c) + q.descensionFactor * Math.LN2 * w.compared.pan - w.halfWindowPanAtZoom(w.compared.targetZoom)) / w.halfWindowPanAtZoom(1); return w.halfWindowSize * y * (-2 * y * n * q - 2 * y * p + 2 * n + 2 * p * q / (u * u) - q / (c * c)) / (w.desiredPixelFlow * Math.LN2) }; a.ddtPanion = function (w, c, q) { return -2 * w.compared.pan * w.halfWindowSize * (q.ascensionFactor + q.descensionFactor - 1) / (w.desiredPixelFlow * w.halfWindowPanAtZoom(c * c * c)) }; a.dtAscensionZoomOnly =
            function (w, c) { return w.halfWindowSize / (c * w.desiredPixelFlow * Math.LN2) }; a.dtAscensionZoomPan = function (w, c, q) { const u = 1 / c, y = Math.log(w.compared.sourceZoom * u), n = 1 / w.desiredPixelFlow, p = 1 / Math.LN2; c -= w.compared.sourceZoom; const l = 1 / c; q = (q.ascensionFactor * Math.LN2 * w.compared.pan + w.halfWindowPanAtZoom(c)) / w.halfWindowPanAtZoom(1); return w.halfWindowSize * u * n * p * l * q - w.halfWindowSize * y * n * p * l + w.halfWindowSize * y * n * p * q / (c * c) }; a.dtDescensionZoomOnly = function (w, c) { return w.halfWindowSize / (c * w.desiredPixelFlow * Math.LN2) };
        a.dtDescensionZoomPan = function (w, c, q) { const u = Math.log(c / w.compared.targetZoom), y = 1 / w.desiredPixelFlow, n = 1 / Math.LN2, p = -c + w.compared.targetZoom, l = 1 / p; q = (-w.halfWindowPanAtZoom(c) - q.descensionFactor * Math.LN2 * w.compared.pan + w.halfWindowPanAtZoom(w.compared.targetZoom)) / w.halfWindowPanAtZoom(1); return -w.halfWindowSize * u * y * n * l + w.halfWindowSize * u * y * n * q / (p * p) + w.halfWindowSize * y * n * l * q / c }; a.dtPanion = function (w, c, q) {
          return w.compared.pan * w.halfWindowSize * (q.ascensionFactor + q.descensionFactor - 1) / (w.desiredPixelFlow *
            w.halfWindowPanAtZoom(c * c))
        }; a.tAscensionZoomOnly = function (w, c) { return -w.halfWindowSize * Math.log(w.compared.sourceZoom / c) / (w.desiredPixelFlow * Math.LN2) }; a.tAscensionZoomPan = function (w, c, q) { const u = w.halfWindowPanAtZoom(c - w.compared.sourceZoom); return -w.halfWindowSize * (q.ascensionFactor * Math.LN2 * w.compared.pan + u) * Math.log(w.compared.sourceZoom / c) / (w.desiredPixelFlow * Math.LN2 * u) }; a.tBaseLine = function (w) {
          const c = Math.LN2 * w.compared.pan, q = w.halfWindowPanAtZoom(w.compared.sourceZoom - w.compared.targetZoom),
          u = w.halfWindowSize * Math.log(w.compared.sourceZoom / w.compared.targetZoom) / (w.desiredPixelFlow * Math.LN2 * q); return w.compared.sourceZoom <= w.compared.targetZoom ? u * (c - q) : u * (c + q)
        }; a.tDescensionZoomOnly = function (w, c) { return w.halfWindowSize * Math.log(c / w.compared.targetZoom) / (w.desiredPixelFlow * Math.LN2) }; a.tDescensionZoomPan = function (w, c, q) {
          return w.halfWindowSize * (-w.halfWindowPanAtZoom(c) - q.descensionFactor * Math.LN2 * w.compared.pan + w.halfWindowPanAtZoom(w.compared.targetZoom)) * Math.log(c / w.compared.targetZoom) /
            (w.desiredPixelFlow * Math.LN2 * w.halfWindowPanAtZoom(-c + w.compared.targetZoom))
        }; a.tPanion = function (w, c, q) { return -w.compared.pan * w.halfWindowSize * (q.ascensionFactor + q.descensionFactor - 1) / (w.desiredPixelFlow * w.halfWindowPanAtZoom(c)) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/AnimationController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/Logger ../../../../core/accessorSupport/ensureType ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/set ../../../../core/accessorSupport/decorators/subclass ../../../ViewAnimation ./CameraController".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
        a.AnimationController = function (t) {
          function v() { return t.apply(this, arguments) || this } w._inheritsLoose(v, t); var m = v.prototype; m.onControllerStart = function () { this.state = f.State.Running; q.isSome(this.viewAnimation) && this.viewAnimation.when(() => this.updateStateFromViewAnimation(), () => this.updateStateFromViewAnimation()) }; m.updateStateFromViewAnimation = function () {
          !q.isSome(this.viewAnimation) || this.state !== f.State.Ready && this.state !== f.State.Running || (this.viewAnimation.state ===
            d.State.FINISHED ? this.finish() : this.viewAnimation.state === d.State.STOPPED && (this.state = f.State.Stopped))
          }; m.onControllerEnd = function () { q.isSome(this.viewAnimation) && !this.viewAnimation.done && (this.state === f.State.Finished ? this.viewAnimation.finish() : this.state === f.State.Stopped && this.viewAnimation.stop()); this._asyncResult && (this.state === f.State.Finished ? this._asyncResult.resolve() : this._asyncResult.reject(u.createAbortError())) }; m.finish = function () { this.finishController() }; w._createClass(v, [{
            key: "canStop",
            get: function () { return !0 }
          }, { key: "asyncResult", get: function () { return this._asyncResult }, set: function (e) { this._asyncResult && (this._asyncResult.reject(u.createAbortError()), this._asyncResult = null); this.state === f.State.Finished || this.state === f.State.Stopped ? this.state === f.State.Finished ? e.resolve() : e.reject(u.createAbortError()) : this._asyncResult = e } }]); return v
        }(f.CameraController); a.AnimationController = c.__decorate([b.subclass("esri.views.3d.state.controllers.AnimationController")], a.AnimationController);
          Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/CameraController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p, l) {
      a.State = void 0; (function (h) {
      h.Ready =
        "ready"; h.Rejected = "rejected"; h.Running = "running"; h.Stopped = "stopped"; h.Finished = "finished"
      })(a.State || (a.State = {})); a.CameraController = function (h) {
        function b() { var f = h.apply(this, arguments) || this; f.state = a.State.Ready; return f } w._inheritsLoose(b, h); var d = b.prototype; d.stopController = function () { return this.canStop ? (this.state = a.State.Stopped, !0) : !1 }; d.finishController = function () { this.state = a.State.Finished }; w._createClass(b, [{ key: "active", get: function () { return this.state === a.State.Running } }, {
          key: "isInteractive",
          get: function () { return !1 }
        }, { key: "canStop", get: function () { return !1 } }, { key: "steppingFinished", get: function () { return !1 } }]); return b
      }(q); c.__decorate([u.property({ readOnly: !0 })], a.CameraController.prototype, "active", null); c.__decorate([u.property()], a.CameraController.prototype, "state", void 0); a.CameraController = c.__decorate([l.subclass("esri.views.3d.state.controllers.CameraController")], a.CameraController); Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/utils/navigationUtils": function () {
      define("exports ../../../../core/mathUtils ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/axisAngle ../../../../geometry/support/coordinateSystem ../../../../geometry/support/plane ../../../../chunks/sphere ../../../../geometry/support/vector ../../../../geometry/support/vectorStacks ../../support/mathUtils ../../support/geometryUtils/ray ../../support/geometryUtils/sphere ../../webgl-engine/lib/Camera".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k) {
          function r(Na, ya, pa) { const wa = m.sm4d.get(); u.identity(wa); u.rotate(wa, wa, pa[3], b.axis(pa)); l.subtract(ma, Na.eye, ya); l.transformMat4(ma, ma, wa); Na.eye = l.add(ma, ma, ya); l.subtract(ma, Na.center, ya); l.transformMat4(ma, ma, wa); Na.center = l.add(ma, ma, ya); Na.up = l.transformMat4(ma, Na.up, wa) } function A(Na, ya) { l.set(ya, 0, 0, 0); for (const pa of Na) l.add(ya, ya, pa); l.scale(ya, ya, 1 / Na.length) } function z(Na, ya, pa, wa) { return Math.sin(Na / l.length(ya)) * (pa + wa.radius) } function B(Na,
            ya, pa, wa) { pa = g.fromScreenAtEye(ya, pa, Ea); if (c.isNone(pa)) return !1; t.closestPointOnSilhouette(Na, pa, R); return t.intersectRay(Na, pa, wa) ? l.squaredDistance(R, pa.origin) < l.squaredDistance(wa, pa.origin) ? (l.copy(wa, R), !1) : !0 : (l.subtract(S, ya.eye, ya.center), l.normalize(S, S), f.fromNormalAndOffset(S, -l.dot(l.normalize(S, S), R), Q), f.intersectRay(Q, pa, wa), !1) } function C(Na, ya, pa, wa, Ia, Ha) {
              l.cross(za, Na, ya); l.subtract(ra, Na, ya); l.length(Na) <= Ia || !wa.aboveGround ? (l.cross(pa, ra, wa.eye), Na = l.dot(Na, ya) / (l.length(Na) *
                l.length(ya)), Ha = Math.cos(w.clamp(e.cyclicalPI.normalize(w.deg2rad(Ha)), 0, I)), ya = -w.acosClamped(Na) - Math.max(0, l.length(ya) - Ia) / (Ha * Ia)) : (l.subtract(T, wa.eye, wa.center), l.cross(pa, ra, T), ya = -l.length(ra) / Ia); l.normalize(pa, pa); l.scale(pa, pa, l.length(za)); return ya
            } function D(Na, ya, pa, wa) {
              wa = Math.cos(w.clamp(e.cyclicalPI.normalize(w.deg2rad(wa)), 0, I)); ya = ya > pa ? -(ya - pa) / (wa * pa) : ya < -pa ? Math.PI - (ya + pa) / (wa * pa) : w.acosClamped(ya / pa); return ((Na > pa ? -(Na - pa) / (wa * pa) : Na < -pa ? Math.PI - (Na + pa) / (wa * pa) : w.acosClamped(Na /
                pa)) - ya) * pa
            } function E(Na, ya, pa, wa, Ia, Ha, Oa, Ba, sa, Ca) { sa = D(Na[2], ya[2], Oa[3], sa); ya = Ca ? D(Na[0], ya[0], Oa[3], 180) : ya[0] - Na[0]; Na = Math.sin(Ba) * ya - Math.cos(Ba) * sa; Ba = Math.cos(Ba) * ya + Math.sin(Ba) * sa; l.normalize(ma, Ia); Ia = Ca ? Na / Math.sqrt(Math.abs(Oa[3] ** 2 - l.dot(pa, ma) ** 2)) : Na / Oa[3]; pa = Ba / Math.sqrt(Math.abs(Oa[3] ** 2 - l.dot(pa, wa) ** 2)); n.set(Ha, Ia, pa) } function H(Na, ya, pa, wa, Ia, Ha, Oa, Ba, sa, Ca) {
              l.cross(za, Na, ya); d.coordinateSystemFromOneAxisAndNormalVector(Ha.up, Ha.eye, ha, ka, ea); d.coordinateSystemFromOneAxisAndNormalVector([0,
                0, 1], Ha.eye, da, Y, fa); l.copy(pa, Y); l.copy(wa, da); l.normalize(pa, pa); l.scale(pa, pa, l.length(za)); d.vectorCoordinates(Na, l.normalize(ka, ka), l.normalize(ea, ea), l.normalize(ha, ha), ba); d.vectorCoordinates(ya, ka, ea, ha, aa); E(ba, aa, Na, da, Y, Ia, Oa, Ba, sa, Ca)
            } function J(Na, ya, pa, wa, Ia, Ha, Oa) { u.identity(X); u.identity(Z); u.identity(ia); u.rotate(X, X, Ia, wa); u.rotate(Z, Z, Oa, Ha); u.multiply(ia, X, Z); l.subtract(ya, Na, pa); l.transformMat4(ya, ya, ia); l.add(ya, ya, pa) } function M(Na, ya, pa, wa, Ia, Ha) {
              u.identity(X); u.identity(Z);
              u.identity(ia); u.rotate(X, X, wa, pa); u.rotate(Z, Z, Ha, Ia); u.multiply(ia, X, Z); l.subtract(ma, Na.eye, ya); l.transformMat4(ma, ma, ia); Na.eye = l.add(ma, ma, ya); l.subtract(ma, Na.center, ya); l.transformMat4(ma, ma, ia); Na.center = l.add(ma, ma, ya); l.subtract(ma, Na.up, ya); l.transformMat4(ma, ma, ia); Na.up = l.add(ma, ma, ya)
            } function F(Na, ya, pa, wa, Ia, Ha, Oa = G.Pole, Ba = G.Angle) { Na = Math.abs(Na[2]) < pa * Oa || Math.abs(ya) > pa; return (Math.abs(wa) > Math.PI - Ba || Math.abs(wa) < Ba) && Na && Ha.aboveGround && Ia < G.Tilt ? !0 : !1 } function K(Na, ya, pa, wa,
              Ia, Ha) { Ha ? (b.fromPoints(pa, wa, U), r(ya, Na, U)) : (pa = C(pa, wa, Ka, ya, Na[3], Ia), r(ya, Na, b.wrapAxisAngle(Ka, pa))) } function P(Na, ya, pa, wa, Ia, Ha, Oa) { const Ba = Oa ? 20 : 1; l.copy(la, wa); Aa.copyFrom(ya); let sa; for (let Ca = 0; Ca < Ba && 1E-12 < l.squaredDistance(pa, la); Ca++)if (wa = l.squaredDistance(pa, la), H(pa, la, Y, da, W, Aa, Na, Ia, Ha, Oa), M(Aa, Na, da, W[1], Y, W[0]), J(la, la, Na, da, W[1], Y, W[0]), sa = l.squaredDistance(pa, la), sa < wa || 0 === Ca) ya.copyFrom(Aa); else break } const L = q.createScreenPointArray(); a.NavigationMode = void 0; (function (Na) {
              Na[Na.Vertical =
                0] = "Vertical"; Na[Na.Horizontal = 1] = "Horizontal"
              })(a.NavigationMode || (a.NavigationMode = {})); const N = { Elevation: 3E4, Angle: w.deg2rad(6) }, G = { Pole: .95, Angle: w.deg2rad(18), Tilt: 45 }, I = w.deg2rad(80), O = h.create(), R = h.create(), S = h.create(), Q = f.create(), T = h.create(), da = h.create(), Y = h.create(), fa = h.create(), ha = h.create(), ka = h.create(), ea = h.create(), ba = h.create(), aa = h.create(), W = p.create(), U = b.create(), X = y.create(), Z = y.create(), ia = y.create(), la = h.create(), ma = h.create(), ra = h.create(), Aa = new k, za = h.create(), Ka = h.create(),
                Ea = { origin: h.create(), direction: h.create() }, Ua = { origin: h.create(), direction: h.create() }; a.DISTANCE_CLAMP_VALUES = [1, 3E8]; a.PIVOT_DISTANCE_MODIFIER = 30; a.PreservingHeadingThreshold = G; a.SCREEN_PIXEL_AREA = 70; a.TiltThresholdPanningSpeed = I; a.VerticalPanTresholds = N; a.applyPanPlanar = function (Na, ya, pa) { l.subtract(O, pa, ya); Na.eye = l.subtract(ma, Na.eye, O); Na.center = l.subtract(ma, Na.center, O) }; a.applyPanSphericalDirectRotation = K; a.applyPanSphericalPreserveHeading = P; a.applyRotation = r; a.applyRotationWithTwoAxes =
                  M; a.applyZoomOnSphere = function (Na, ya, pa) { ya.getScreenCenter(L); x.intersectScreen(Na, ya, L, ma) && (ya.center = ma); Na = ya.distance; pa *= Na; 1E-6 > Math.abs(Na - pa) || (pa = l.scale(m.sv3d.get(), ya.viewForward, pa), ya.eye = l.subtract(ma, ya.center, pa)) }; a.applyZoomToPoint = function (Na, ya, pa, wa) {
                    const Ia = m.sv3d.get(); pa = 1 - pa; l.subtract(Ia, ya, Na.eye); const Ha = l.length(Ia); let Oa = Ha * (1 - pa); 0 <= pa && Oa < wa && (Oa = wa, pa = -(Oa - Ha) / Ha); 1E-6 > Math.abs(Ha - Oa) || (l.scale(Ia, Ia, pa), Na.eye = l.add(ma, Na.eye, Ia), Na.center = l.lerp(ma, Na.center,
                      ya, pa))
                  }; a.centroid = A; a.centroidOnSphere = function (Na, ya, pa) { A(ya, pa); l.normalize(pa, pa); l.scale(pa, pa, Na) }; a.decideNavigationMode = function (Na, ya, pa, wa) { if (l.length(Na.eye) - wa.radius > N.Elevation) return a.NavigationMode.Horizontal; if (!pa) return a.NavigationMode.Vertical; g.fromScreenAtEye(Na, ya, Ua); return -Math.sign(Na.relativeElevation) * (.5 * Math.PI + v.angle(Na.eye, Ua.direction)) < N.Angle ? a.NavigationMode.Vertical : a.NavigationMode.Horizontal }; a.intersectPlaneFromScreenPoint = function (Na, ya, pa, wa) {
                    return f.intersectRay(Na,
                      g.fromScreen(ya, pa, Ea), wa)
                  }; a.intersectPlaneFromScreenPointAtEye = function (Na, ya, pa, wa) { return f.intersectRay(Na, g.fromScreenAtEye(ya, pa, Ea), wa) }; a.lengthFromPoints = D; a.normalizeCoordinate = function (Na, ya, pa) { pa[0] = ya[0] / (Na.fullWidth / Na.pixelRatio); pa[1] = ya[1] / (Na.fullHeight / Na.pixelRatio); return pa }; a.normalizeRotationDelta = function (Na) { for (; Na > Math.PI;)Na -= 2 * Math.PI; for (; Na < -Math.PI;)Na += 2 * Math.PI; return Na }; a.offSurfaceTiltToEyeTiltGlobal = function (Na, ya, pa, wa) {
                    return z(Math.PI / 2, ya, pa, wa) + (Na - Math.PI /
                      2)
                  }; a.onSurfaceTiltToEyeTiltGlobal = z; a.panMotionToRotationMatrix = function (Na, ya, pa, wa, Ia, Ha, Oa, Ba, sa) {
                    if (F(Na.center, l.dot(Na.up, Na.center), l.length(Na.center), -e.cyclicalPI.normalize(w.deg2rad(Ha)), Oa, ya)) switch (Na = -e.cyclicalPI.normalize(w.deg2rad(Ia)), { eye: Ia } = ya, d.coordinateSystemFromOneAxisAndNormalVector([0, 0, 1], Ia, da, Y, fa), Ia = pa.translation[0] * wa.pan, Ha = "zoom" === sa.mode ? 0 : pa.translation[1] * wa.pan, ya = Math.max(Math.sqrt(Math.abs(1 - l.dot(ya.center, da) ** 2 / l.length(ya.center) ** 2)), .5), Oa = -Math.cos(Na) *
                      Ha + Math.sin(Na) * Ia, u.rotate(Ba.pan.matrix, Ba.pan.matrix, (Math.sin(Na) * Ha + Math.cos(Na) * Ia) / ya, da), Ba.pan.enabled = !0, sa.mode) { case "pan": u.rotate(Ba.pan.matrix, Ba.pan.matrix, Oa, Y); Ba.pan.enabled = !0; break; case "zoom": Ba.zoom = -pa.translation[1] * wa.zoom } else {
                        {
                          const { eye: Ca, viewRight: Ja } = ya; ya = l.cross(m.sv3d.get(), Ja, Ca); Na = pa.translation[0] * wa.pan; 0 !== Na && (u.rotate(Ba.pan.matrix, Ba.pan.matrix, -Na, ya), Ba.pan.enabled = !0); switch (sa.mode) {
                            case "pan": pa = pa.translation[1] * wa.pan; 0 !== pa && (u.rotate(Ba.pan.matrix,
                              Ba.pan.matrix, pa, Ja), Ba.pan.enabled = !0); break; case "zoom": Ba.zoom = -pa.translation[1] * wa.zoom
                          }
                        }
                    }
                  }; a.panToPosition = function (Na, ya, pa, wa, Ia, Ha, Oa) { F(pa, l.dot(ya.up, pa), Na[3], -e.cyclicalPI.normalize(w.deg2rad(Ia)), Ha, ya, G.Pole, G.Angle) ? P(Na, ya, pa, wa, -e.cyclicalPI.normalize(w.deg2rad(Ia)), Ha, Oa) : K(Na, ya, pa, wa, Ha, Oa) }; a.pickPointAndInitSphere = function (Na, ya, pa, wa, Ia) {
                    const Ha = h.create(), Oa = t.create(); let Ba = !0, sa = !0; Na.intersectScreen(pa, Ha) ? Oa[3] = l.length(Ha) : (sa = !1, Oa[3] = ya.aboveGround ? Math.max(l.length(ya.center),
                      .9 * Ia.radius) : l.length(ya.eye) - ya.relativeElevation, wa ? B(Oa, ya, pa, Ha) : Ba = x.intersectScreen(Oa, ya, pa, Ha)); return { sphere: Oa, scenePickPoint: Ba ? Ha : null, hasGeometryIntersection: sa }
                  }; a.preserveHeadingThreshold = F; a.rotatePointAroundTwoAxes = J; a.rotationAngleAndAxisDirectRotation = C; a.rotationAnglesAndAxesHeadingPreserving = H; a.rotationAnglesHeadingPreserving = E; a.rotationFromPointsAroundAxis = function (Na, ya, pa) {
                    const wa = m.sv3d.get(), Ia = m.sv3d.get(), Ha = m.sv3d.get(); l.copy(Ia, Na); l.copy(Ha, ya); Na = l.dot(Ia, pa);
                    ya = l.dot(Ha, pa); l.scale(wa, pa, Na); l.subtract(Ia, Ia, wa); l.normalize(Ia, Ia); l.scale(wa, pa, ya); l.subtract(Ha, Ha, wa); l.normalize(Ha, Ha); Na = l.dot(Ia, Ha); l.cross(wa, pa, Ia); pa = l.dot(Ha, wa); return Math.atan2(pa, Na)
                  }; a.sphereOrPlanePointFromScreenPoint = B; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/geometryUtils/ray": function () {
      define("exports ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/vec2 ../../../../chunks/vec3 ../../../../geometry/support/vectorStacks".split(" "),
        function (a, w, c, q, u, y) {
          function n(l, h, b) { const d = c.castRenderScreenPointArray3(q.copy(y.sv3d.get(), h)); d[2] = 0; if (!l.unprojectFromRenderScreen(d, b.origin)) return null; h = c.castRenderScreenPointArray3(q.copy(y.sv3d.get(), h)); h[2] = 1; l = l.unprojectFromRenderScreen(h, y.sv3d.get()); if (w.isNone(l)) return null; u.subtract(b.direction, l, b.origin); return b } function p(l, h, b) {
            u.copy(b.origin, l.eye); h = u.set(y.sv3d.get(), h[0], h[1], 1); l = l.unprojectFromRenderScreen(h, y.sv3d.get()); if (w.isNone(l)) return null; u.subtract(b.direction,
              l, b.origin); return b
          } a.fromRender = n; a.fromRenderAtEye = p; a.fromScreen = function (l, h, b) { return n(l, l.screenToRender(h, c.castRenderScreenPointArray3(y.sv3d.get())), b) }; a.fromScreenAtEye = function (l, h, b) { return p(l, l.screenToRender(h, c.castRenderScreenPointArray3(y.sv3d.get())), b) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/geometryUtils/sphere": function () {
      define(["exports", "../../../../geometry/support/ray", "../../../../chunks/sphere", "./ray"], function (a, w, c, q) {
        const u =
          w.create(); a.intersectScreen = function (y, n, p, l) { n = q.fromScreenAtEye(n, p, u); return c.intersectRay(y, n, l) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/local/ZoomStepController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/time ../../../../../core/Logger ../../../../../core/accessorSupport/ensureType ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/set ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../support/featureFlags ../../../camera/constraintUtils ../PointToPointAnimationController ../../../webgl-engine/lib/Camera ../../../webgl-engine/lib/Intersector ../../../../animation/easing".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
        a.ZoomStepController = function (k) {
          function r() { var z = k.apply(this, arguments) || this; z.zoomLocation = d.create(); z.tmpCamera = new m; z.tmpRayDir = d.create(); z.tmpCenter = d.create(); z.constraintOptions = { selection: 15, interactionType: 1, interactionFactor: null, interactionStartCamera: new m, interactionDirection: null, tiltMode: 0 }; return z } w._inheritsLoose(r, k); var A = r.prototype; A.zoomStep = function (z, B) {
            if (this.active) {
              var C = this.view.state, { interactionStartCamera: D } = this.constraintOptions;
              this.animation.finished ? D.copyFrom(C.camera) : this.animation.cameraAt(1, D); this.tmpCamera.copyFrom(C.camera); C = e.newIntersector(this.view.state.viewingMode); 0 < z ? (this.intersectionHelper.intersectScreenFreePointFallback(B, this.zoomLocation), this.intersectionHelper.intersectRay(this.tmpCamera.ray, C, this.tmpCenter) && (this.tmpCamera.center = this.tmpCenter)) : this.intersectionHelper.intersectRay(this.tmpCamera.ray, C, this.zoomLocation) ? this.tmpCamera.center = this.zoomLocation : b.copy(this.zoomLocation, this.tmpCamera.center);
              z = .6 ** z; !f.disableContextNavigation() && (B = this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(), B[0], B[1], this.view.state.camera, 60), C = Math.max(14 * Math.abs(this.view.camera.position.z), 20), B = B ? Math.min(B, C) : C) && (C = d.create(), b.subtract(C, this.zoomLocation, this.tmpCamera.eye), B < b.length(C) && (b.normalize(C, C), b.add(this.zoomLocation, this.tmpCamera.eye, b.scale(C, C, B)))); this.updateCamera(this.tmpCamera, z, this.zoomLocation); this.begin(this.tmpCamera)
            }
          }; A.animationSettings =
            function () { return { apex: null, duration: q.Milliseconds(600), easing: g.outExpo } }; A.updateCamera = function (z, B, C) { b.subtract(this.tmpRayDir, C, z.eye); const D = b.length(this.tmpRayDir); let E = D * B; const H = Math.max(4, 1.01 * z.nearFar[0]); 1 >= B && E < H && (E = H, B = E / D); 1E-6 > Math.abs(D - E) || (b.scale(this.tmpRayDir, this.tmpRayDir, B), z.eye = b.subtract(x, C, this.tmpRayDir), z.center = b.lerp(x, z.center, C, 1 - B), t.applyAll(this.view, z, this.constraintOptions)) }; return r
        }(v.PointToPointAnimationController); a.ZoomStepController = c.__decorate([h.subclass("esri.views.3d.state.controllers.local.ZoomStepController")],
          a.ZoomStepController); const x = d.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/input/handlers/support": function () {
      define(["exports"], function (a) {
      a.eventMatchesMousePointerAction = function (w, c) { if ("touch" === w.pointerType) return !1; switch (c) { case "primary": return 0 === w.button; case "secondary": return 2 === w.button; case "tertiary": return 1 === w.button } }; a.eventMatchesPointerAction = function (w, c) {
        switch (c) {
          case "primary": return "touch" === w.pointerType || 0 === w.button; case "secondary": return "touch" !==
            w.pointerType && 2 === w.button; case "tertiary": return "touch" !== w.pointerType && 1 === w.button
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/input/handlers/DragRotate": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/screenUtils ../../state/controllers/RotateController ../../../input/InputHandler ../../../input/handlers/support".split(" "), function (a, w, c, q, u, y) {
        u = function (n) {
          function p(l, h, b, d) {
            var f = n.call(this, !0) || this; f.view = l; f.pointerAction =
              h; f.pivot = b; f.registerIncoming("drag", d, t => f.handleDrag(t)); return f
          } w._inheritsLoose(p, n); p.prototype.handleDrag = function (l) {
            const h = l.data; if (!(1 < h.pointers.size) && y.eventMatchesMousePointerAction(l.data, this.pointerAction)) {
              var b = c.createScreenPointArray(h.center.x, h.center.y); switch (h.action) {
                case "start": this.cameraController && (this.cameraController.end(), this.cameraController = null); this.cameraController = new q.RotateController({ view: this.view, pivot: this.pivot }); this.view.state.switchCameraController(this.cameraController);
                  this.cameraController.begin(b); break; case "update": this.cameraController && this.cameraController.update(b); break; case "end": this.cameraController && (this.cameraController.end(), this.cameraController = null)
              }l.stopPropagation()
            }
          }; return p
        }(u.InputHandler); a.DragRotate = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/RotateController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/has ../../../../core/mathUtils ../../../../core/screenUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projectionEllipsoid ../../camera/constraintUtils ../Constraints ./InteractiveController ../utils/navigationUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
        a.RotateController = function (z) {
          function B(D) { D = z.call(this, D) || this; D.view = null; D.pivot = 0; D.lastPoint = t.create(); D.tmpWorldUp = m.create(); D.tmpViewDir = m.create(); D.tmpRotCurPoint = t.create(); D.tmpTransf = d.create(); D.tmpAxis = m.create(); D.tmpPivotPoint = m.create(); D.pivotPos = m.create(); D.constraintOptions = { selection: 15, interactionType: 2, interactionFactor: 0, interactionStartCamera: null, interactionDirection: null, tiltMode: 0 }; return D } w._inheritsLoose(B, z);
          var C = B.prototype; C.initialize = function () { this.rotScale = 0 === this.pivot ? 3 : 1.5 }; C.begin = function (D) {
            if (this.active) {
              switch (this.pivot) {
                case 1: v.copy(this.pivotPos, this.startCamera.eye); this.constraintOptions.interactionType = 3; this.constraintOptions.tiltMode = 1; this.constraintOptions.selection = 0; break; case 0: this.intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray, this.pivotPos) || v.copy(this.pivotPos, this.startCamera.center), q("disable-feature:context-navigation") || this.constrainPivotPoint(D),
                  this.startCamera.center = this.pivotPos, this.constraintOptions.interactionType = 2, this.constraintOptions.tiltMode = 0, this.constraintOptions.selection = 11
              }this.constraintOptions.interactionStartCamera = this.startCamera; r.normalizeCoordinate(this.startCamera, D, this.lastPoint)
            }
          }; C.constrainPivotPoint = function (D) {
            const E = this.startCamera, H = m.create(); v.subtract(H, this.pivotPos, E.eye); let J = v.length(H); this.view.camera.position.hasZ && (J = Math.min(J, 7 * Math.abs(this.view.camera.position.z))); var M = e.getReferenceEllipsoid(this.view.spatialReference),
              F = y.createScreenPointArray(E.width / E.pixelRatio * .5, E.height / E.pixelRatio * .5); M = r.decideNavigationMode(this.startCamera, F, !0, M); F = this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(), E.fullWidth / E.pixelRatio * .5, E.fullHeight / E.pixelRatio * .5, E, 225, 90); D = this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(), D[0], D[1], E, 90); if (void 0 !== F || void 0 !== D) F = void 0 === F ? D : F, D = void 0 === D || M === r.NavigationMode.Horizontal ? F : D, J = F > D ? D : F; v.normalize(H,
                H); v.copy(this.pivotPos, v.add(this.tmpPivotPoint, E.eye, v.scale(this.tmpPivotPoint, H, J)))
          }; C.update = function (D) { if (this.active) { switch (this.pivot) { case 1: this.currentCamera.center = this.applyRotation(this.currentCamera, D, this.currentCamera.center, this.pivotPos); break; case 0: this.currentCamera.center = this.pivotPos, this.currentCamera.eye = this.applyRotation(this.currentCamera, D, this.currentCamera.eye, this.pivotPos) }g.applyAll(this.view, this.currentCamera, this.constraintOptions) } }; C.end = function () {
          this.active &&
            this.finishController()
          }; C.applyRotation = function (D, E, H, J) {
            this.view.renderCoordsHelper.worldUpAtPosition(J, this.tmpWorldUp); r.normalizeCoordinate(D, E, this.tmpRotCurPoint); E = (this.lastPoint[1] - this.tmpRotCurPoint[1]) * this.rotScale; let M = (this.tmpRotCurPoint[0] - this.lastPoint[0]) * this.rotScale; v.subtract(this.tmpViewDir, H, J); H = v.length(this.tmpViewDir); H = u.acosClamped(v.dot(this.tmpViewDir, this.tmpWorldUp) / H); if (1 === this.pivot) { const F = .5 * Math.PI - H, K = .495 * Math.PI; E = F - Math.max(-K, Math.min(K, F + -.5 * E)) } E =
              u.clamp(E + H, x.TiltDefault.min, x.TiltDefault.max) - H; b.identity(this.tmpTransf); v.cross(this.tmpAxis, D.up, this.tmpViewDir); 0 === this.pivot && (M = -M); b.rotate(this.tmpTransf, this.tmpTransf, M, this.tmpWorldUp); b.rotate(this.tmpTransf, this.tmpTransf, E, this.tmpAxis); v.transformMat4(this.tmpViewDir, this.tmpViewDir, this.tmpTransf); D.up = v.transformMat4(A, D.up, this.tmpTransf); v.add(A, J, this.tmpViewDir); f.copy(this.lastPoint, this.tmpRotCurPoint); return A
          }; w._createClass(B, [{ key: "intersectionHelper", get: function () { return this.view.sceneIntersectionHelper } }]);
          return B
        }(k.InteractiveController); c.__decorate([n.property({ constructOnly: !0 })], a.RotateController.prototype, "view", void 0); c.__decorate([n.property()], a.RotateController.prototype, "pivot", void 0); a.RotateController = c.__decorate([h.subclass("esri.views.3d.state.controllers.RotateController")], a.RotateController); const A = m.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/InteractiveController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Logger ../../../../core/accessorSupport/ensureType ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/set ../../../../core/accessorSupport/decorators/subclass ./CameraController ../../webgl-engine/lib/Camera".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
        a.InteractiveController = function (d) {
          function f() { var v = d.apply(this, arguments) || this; v.startCamera = new b; v.currentCamera = new b; return v } w._inheritsLoose(f, d); var t = f.prototype; t.stepController = function (v, m) { m.copyViewFrom(this.currentCamera); this.currentCamera.copyFrom(m) }; t.onControllerStart = function (v) { this.state = h.State.Running; this.startCamera.copyFrom(v); this.currentCamera.copyFrom(v) }; t.onControllerEnd = function (v) { v.copyViewFrom(this.currentCamera) }; w._createClass(f,
            [{ key: "isInteractive", get: function () { return !0 } }]); return f
        }(h.CameraController); a.InteractiveController = c.__decorate([l.subclass("esri.views.3d.state.controllers.InteractiveController")], a.InteractiveController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/input/handlers/DragZoom": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/screenUtils ../../state/controllers/global/ZoomController ../../state/controllers/local/ZoomController ../../../input/InputHandler ../../../input/handlers/support".split(" "),
        function (a, w, c, q, u, y, n) {
          y = function (p) {
            function l(h, b, d) { var f = p.call(this, !0) || this; f.view = h; f.pointerAction = b; f.registerIncoming("drag", d, t => f.handleDrag(t)); return f } w._inheritsLoose(l, p); l.prototype.handleDrag = function (h) {
              const b = h.data; if (!(1 < b.pointers.size) && n.eventMatchesMousePointerAction(h.data, this.pointerAction)) {
                var d = c.createScreenPointArray(b.center.x, b.center.y); switch (b.action) {
                  case "start": this.cameraController && (this.cameraController.end(), this.cameraController = null); this.cameraController =
                    this.view.state.isGlobal ? new q.ZoomController({ view: this.view }) : new u.ZoomController({ view: this.view }); this.view.state.switchCameraController(this.cameraController); this.cameraController.begin(d); break; case "update": this.cameraController && this.cameraController.update(d); break; case "end": this.cameraController && (this.cameraController.end(), this.cameraController = null)
                }h.stopPropagation()
              }
            }; return l
          }(y.InputHandler); a.DragZoom = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/global/ZoomController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/has ../../../../../core/mathUtils ../../../../../core/screenUtils ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec2 ../../../../../chunks/vec2f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/projectionEllipsoid ../../../../../geometry/support/axisAngle ../../../../../chunks/sphere ../../../camera/constraintUtils ../InteractiveController ../../utils/navigationUtils ../../../support/geometryUtils/ray ../../../camera/constraintUtils/surfaceCollision".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A) {
        a.ZoomController = function (B) {
          function C(E) {
            E = B.call(this, E) || this; E.view = null; E.pickPoint = t.create(); E.tmpP0 = d.create(); E.panAxisAngle = m.create(); E.tmpRayDir = t.create(); E.targetOnSphere = t.create(); E.tmpRay = { origin: t.create(), direction: t.create() }; E.dragBeginPoint = y.createScreenPointArray(); E.normalizedAnchorPoint = d.create(); E.constraintOptions = {
              selection: 7, interactionType: 1, interactionFactor: 0, interactionStartCamera: null, interactionDirection: null,
              tiltMode: 0
            }; E.sphere = e.create(); E.hasPickPoint = !1; return E
          } w._inheritsLoose(C, B); var D = C.prototype; D.begin = function (E) {
            if (this.active) {
              b.copy(this.dragBeginPoint, E); k.normalizeCoordinate(this.startCamera, E, this.normalizedAnchorPoint); var H = v.getReferenceEllipsoid(this.view.spatialReference), J = k.pickPointAndInitSphere(this.intersectionHelper, this.startCamera, E, !1, H); this.navMode = k.decideNavigationMode(this.startCamera, E, J.hasGeometryIntersection, H); if (this.navMode === k.NavigationMode.Horizontal || q("disable-feature:context-navigation")) this.hasPickPoint =
                !!J.scenePickPoint, this.pickPoint = J.scenePickPoint, this.sphere = J.sphere; else {
                  r.fromScreenAtEye(this.startCamera, E, this.tmpRay); f.normalize(this.tmpRay.direction, this.tmpRay.direction); let M; this.view.camera.position.hasZ && (M = Math.abs(this.view.camera.position.z)); H = u.clamp(k.PIVOT_DISTANCE_MODIFIER * M, k.DISTANCE_CLAMP_VALUES[0], k.DISTANCE_CLAMP_VALUES[1]); E = this.view._stage.renderView.getMinimalDepthForArea(null, E[0], E[1], this.view.state.camera, k.SCREEN_PIXEL_AREA); H = H > E ? E : H; this.hasPickPoint = !0; f.scale(this.tmpRay.direction,
                    this.tmpRay.direction, H); f.add(this.pickPoint, this.tmpRay.origin, this.tmpRay.direction)
              } this.constraintOptions.interactionStartCamera = this.startCamera
            }
          }; D.update = function (E) {
            if (this.active) {
              this.currentCamera.eye = this.startCamera.eye; this.currentCamera.center = this.startCamera.center; this.currentCamera.up = this.startCamera.up; if (this.navMode === k.NavigationMode.Horizontal || q("disable-feature:context-navigation")) {
                f.subtract(this.tmpRayDir, this.currentCamera.center, this.currentCamera.eye); var H = f.length(this.tmpRayDir);
                k.normalizeCoordinate(this.currentCamera, E, this.tmpP0); var J = 12 * (this.normalizedAnchorPoint[1] - this.tmpP0[1]), M = H * 2 ** J; const F = this.view.state.constraints.minimumPoiDistance; 0 > J && M < F && (M = F); if (1E-6 > Math.abs(H - M)) return; this.hasPickPoint && M < H && (J = 1 - (1 - M / H) * (1 - this.sphere[3] / f.length(this.currentCamera.center)), this.currentCamera.center = f.scale(z, this.currentCamera.center, J)); f.scale(this.tmpRayDir, this.tmpRayDir, -M / H); this.currentCamera.eye = f.add(z, this.currentCamera.center, this.tmpRayDir); this.constraintOptions.interactionFactor =
                  g.pixelDistanceToInteractionFactor(this.dragBeginPoint, E); g.applyAll(this.view, this.currentCamera, this.constraintOptions); this.hasPickPoint && (k.sphereOrPlanePointFromScreenPoint(this.sphere, this.currentCamera, this.dragBeginPoint, this.targetOnSphere), m.fromPoints(this.pickPoint, this.targetOnSphere, this.panAxisAngle), k.applyRotation(this.currentCamera, this.sphere, this.panAxisAngle))
              } else {
                H = f.length(this.tmpRay.direction); k.normalizeCoordinate(this.currentCamera, E, this.tmpP0); E = 12 * (this.normalizedAnchorPoint[1] -
                  this.tmpP0[1]); M = H * 2 ** E; J = this.view.state.constraints.minimumPoiDistance; 0 > E && M < J && (M = J); if (1E-6 > Math.abs(H - M)) return; f.scale(this.tmpRayDir, this.tmpRay.direction, 1 - M / H); this.currentCamera.eye = f.add(z, this.currentCamera.eye, this.tmpRayDir); this.currentCamera.center = f.add(z, this.currentCamera.center, this.tmpRayDir)
              } A.applySurfaceCollisionConstraint(this.view, this.currentCamera)
            }
          }; D.end = function () { this.active && this.finishController() }; w._createClass(C, [{ key: "intersectionHelper", get: function () { return this.view.sceneIntersectionHelper } }]);
          return C
        }(x.InteractiveController); c.__decorate([n.property({ constructOnly: !0 })], a.ZoomController.prototype, "view", void 0); a.ZoomController = c.__decorate([h.subclass("esri.views.3d.state.controllers.global.ZoomController")], a.ZoomController); const z = t.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/local/ZoomController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/mathUtils ../../../../../core/screenUtils ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec2 ../../../../../chunks/vec2f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/plane ../../../camera/constraintUtils ../InteractiveController ../../utils/navigationUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
        a.ZoomController = function (k) {
          function r(z) { z = k.call(this, z) || this; z.view = null; z.tmpP = t.create(); z.tmpDir = t.create(); z.tmpN = t.create(); z.tmpP0 = d.create(); z.tmpPoi = t.create(); z.tmpRayDir = t.create(); z.dragBeginPoint = u.createScreenPointArray(); z.normalizedAnchorPoint = d.create(); z.constraintOptions = { selection: 15, interactionType: 1, interactionFactor: 0, interactionStartCamera: null, interactionDirection: t.create(), tiltMode: 0 }; z.plane = v.create(); return z } w._inheritsLoose(r,
            k); var A = r.prototype; A.begin = function (z) {
              if (this.active) {
                b.copy(this.dragBeginPoint, z); g.normalizeCoordinate(this.startCamera, z, this.normalizedAnchorPoint); this.intersectionHelper.intersectScreenFreePointFallback(z, this.tmpP); f.subtract(this.tmpDir, this.tmpP, this.startCamera.eye); f.normalize(this.tmpDir, this.tmpDir); var B; this.view.camera.position.hasZ && (B = Math.abs(this.view.camera.position.z)); B = q.clamp(g.PIVOT_DISTANCE_MODIFIER * B, g.DISTANCE_CLAMP_VALUES[0], g.DISTANCE_CLAMP_VALUES[1]); z = this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(),
                  z[0], z[1], this.view.state.camera, g.SCREEN_PIXEL_AREA); f.scale(this.tmpDir, this.tmpDir, B > z ? z : B); f.add(this.tmpP, this.startCamera.eye, this.tmpDir); f.subtract(this.tmpN, this.startCamera.eye, this.startCamera.center); f.normalize(this.tmpN, this.tmpN); 0 > this.tmpN[1] && f.negate(this.tmpN, this.tmpN); v.fromPositionAndNormal(this.tmpP, this.tmpN, this.plane); this.constraintOptions.interactionStartCamera = this.startCamera
              }
            }; A.update = function (z) {
              if (this.active) {
                g.intersectPlaneFromScreenPoint(this.plane, this.currentCamera,
                  this.dragBeginPoint, this.tmpPoi) || f.copy(this.tmpPoi, this.currentCamera.center); g.normalizeCoordinate(this.currentCamera, z, this.tmpP0); var B = 4 * (this.tmpP0[1] - this.normalizedAnchorPoint[1]); b.copy(this.normalizedAnchorPoint, this.tmpP0); f.subtract(this.tmpRayDir, this.tmpPoi, this.currentCamera.eye); var C = f.length(this.tmpRayDir), D = C * (1 - B); f.copy(this.constraintOptions.interactionDirection, this.tmpRayDir); f.scale(this.constraintOptions.interactionDirection, this.constraintOptions.interactionDirection,
                    Math.sign(B) / C); var E = this.view.state.constraints.minimumPoiDistance; 0 <= B && D < E && (D = E, B = -(D - C) / C); 1E-6 > Math.abs(C - D) || (f.scale(this.tmpRayDir, this.tmpRayDir, B), this.currentCamera.eye = f.add(x, this.currentCamera.eye, this.tmpRayDir), f.lerp(x, this.currentCamera.center, this.tmpPoi, B), x[2] = this.tmpPoi[2] > this.startCamera.center[2] ? Math.max(this.startCamera.center[2], x[2]) : Math.min(this.startCamera.center[2], x[2]), this.currentCamera.center = x, this.constraintOptions.interactionFactor = m.pixelDistanceToInteractionFactor(this.dragBeginPoint,
                      z), m.applyAll(this.view, this.currentCamera, this.constraintOptions))
              }
            }; A.end = function () { this.active && this.finishController() }; w._createClass(r, [{ key: "intersectionHelper", get: function () { return this.view.sceneIntersectionHelper } }]); return r
        }(e.InteractiveController); c.__decorate([y.property({ constructOnly: !0 })], a.ZoomController.prototype, "view", void 0); a.ZoomController = c.__decorate([h.subclass("esri.views.3d.state.controllers.local.ZoomController")], a.ZoomController); const x = t.create(); Object.defineProperty(a,
          "__esModule", { value: !0 })
        })
    }, "esri/views/3d/input/handlers/GamepadNavigation": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Handles ../../../../core/watchUtils ../../state/controllers/GamepadKeyboardController ../../../input/InputHandler".split(" "), function (a, w, c, q, u, y) {
        y = function (n) {
          function p(h) { var b = n.call(this, !0) || this; b.view = h; b.watchHandles = new c; b.handle = b.registerIncoming("gamepad", d => b.handleEventGamepad(d)); b.handle.pause(); return b } w._inheritsLoose(p,
            n); var l = p.prototype; l.onInstall = function (h) {
              n.prototype.onInstall.call(this, h); this.watchHandles.add([q.init(this.view.navigation.gamepad, "enabled", b => { b ? this.handle.resume() : (this.handle.pause(), this.cameraControllerGamepad && (this.cameraControllerGamepad.finishController(), this.cameraControllerGamepad = null)) }), this.view.navigation.gamepad.watch("device", b => {
              this.cameraControllerGamepad && b && this.cameraControllerGamepad.gamepadDevice !== b && (this.cameraControllerGamepad.finishController(), this.cameraControllerGamepad =
                null)
              })])
            }; l.onUninstall = function () { this.watchHandles.removeAll(); n.prototype.onUninstall.call(this) }; l.handleEventGamepad = function (h) {
              var b = this.view.navigation.gamepad.device; if (!b || h.data.device === b) if ((b = this.cameraControllerGamepad && this.cameraControllerGamepad.active) || u.GamepadKeyboardController.activatesFor(this.view, h.data)) b || (b = new u.GamepadKeyboardController({ view: this.view, gamepadDevice: h.data.device }), this.view.state.switchCameraController(b) && (this.cameraControllerGamepad = b)), this.cameraControllerGamepad &&
                this.cameraControllerGamepad.active && this.cameraControllerGamepad.gamepadDevice === h.data.device && this.cameraControllerGamepad.handleEventGamepad(h.data)
            }; return p
        }(y.InputHandler); a.GamepadNavigation = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/GamepadKeyboardController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/compilerUtils ../../../../core/mathUtils ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projectionEllipsoid ../../../../geometry/support/ray ../../../../chunks/sphere ../../../../geometry/support/vectorStacks ../../camera/constraintUtils ../Constraints ./InteractiveController ../utils/navigationUtils ../utils/viewUtils ../../support/cameraUtils ../../support/cameraUtilsInternal ../../webgl-engine/lib/Camera ../../../navigation/gamepadAndKeyboardUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H) {
        a.GamepadKeyboardController = function (I) {
          function O(S) { S = I.call(this, S) || this; S.transformation = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }; S.keysButtonState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; S.tmpCamera = new E; S.constraintOptions = { selection: 15, interactionType: 0, interactionStartCamera: new E, interactionFactor: 0, interactionDirection: null, tiltMode: 1 }; return S } w._inheritsLoose(O, I); var R = O.prototype; R.handleEventGamepad = function (S) {
            const Q = H.extractTransformation(S,
              this.view.navigation.gamepad, this.transformation); ("end" === S.action || H.isZeroTransformation(Q)) && this.finishController()
          }; R.activateDirection = function (S) { this.keysButtonState[S] = 1; H.extractTransformationKeyboard(this.keysButtonState, this.transformation) }; R.deactivateDirection = function (S) { this.keysButtonState[S] = 0; S = H.extractTransformationKeyboard(this.keysButtonState, this.transformation); H.isZeroTransformation(S) && this.finishController() }; R.onControllerStart = function (S) {
          this.filteredSurfaceElevation =
            this.view.pointsOfInterest.cameraOnSurface.location.z; this.headingStart = this.view.camera.heading; I.prototype.onControllerStart.call(this, S)
          }; R.updateFilteredSurfaceElevation = function (S) { this.filteredSurfaceElevation += (this.view.pointsOfInterest.cameraOnSurface.location.z - this.filteredSurfaceElevation) * S }; R.stepController = function (S, Q) {
            this.updateStartHeading(); this.updateFilteredSurfaceElevation(S); this.currentCamera.copyViewFrom(Q); this.updateCameraCenter(); this.constraintOptions.interactionStartCamera.copyFrom(this.currentCamera);
            this.calculateControlTransformation(S, this.currentCamera, P); this.applyDisabledMovementTypes(P); this.applyPan(P.pan); this.applyRotate(P.rotate); this.applyZoom(P.zoom); this.applyAscend(P.ascend); this.constraintOptions.interactionType = 0; this.constraintOptions.selection = 8; k.applyAll(this.view, this.currentCamera, this.constraintOptions); I.prototype.stepController.call(this, S, Q)
          }; R.updateStartHeading = function () { 0 !== this.transformation.heading && (this.headingStart = this.view.camera.heading) }; R.applyRotate =
            function (S) { if (S.enabled) { var Q = this.currentCamera; t.subtract(L, Q.center, Q.eye); t.transformMat4(L, L, S.matrix); Q.center = t.add(L, L, Q.eye); Q.up = t.transformMat4(L, Q.up, S.matrix); this.constraintOptions.interactionType = 3; this.constraintOptions.selection = 7; k.applyAll(this.view, Q, this.constraintOptions) } }; R.applyPan = function (S, Q = this.currentCamera) {
            S.enabled && (Q.eye = t.transformMat4(L, Q.eye, S.matrix), Q.center = t.transformMat4(L, Q.center, S.matrix), this.view.state.isGlobal && (Q.up = t.transformMat4(L, Q.up, S.matrix)),
              this.constraintOptions.interactionType = 4, this.constraintOptions.selection = 15, k.applyAll(this.view, Q, this.constraintOptions))
            }; R.applyZoom = function (S) {
              if (S) {
                var Q = this.currentCamera.viewForward; this.currentCamera.eye = t.add(L, this.currentCamera.eye, t.scale(x.sv3d.get(), Q, S)); t.copy(N, Q); t.negate(N, N); this.constraintOptions.interactionDirection = N; this.constraintOptions.interactionType = 1; this.constraintOptions.selection = 7; k.applyAll(this.view, this.currentCamera, this.constraintOptions); this.constraintOptions.interactionDirection =
                  null
              }
            }; R.applyAscend = function (S) {
              if (S) {
                var Q = this.view.renderCoordsHelper.worldUpAtPosition(this.currentCamera.eye, x.sv3d.get()); this.constraintOptions.interactionDirection = t.copy(N, Q); this.view.state.isGlobal ? (Q = t.length(this.currentCamera.eye), S = (Q + S) / Q, this.currentCamera.eye = t.scale(L, this.currentCamera.eye, S), this.currentCamera.center = t.scale(L, this.currentCamera.center, S)) : (S = t.scale(x.sv3d.get(), Q, S), this.currentCamera.eye = t.add(L, this.currentCamera.eye, S), this.currentCamera.center = t.add(L,
                  this.currentCamera.center, S)); this.updateCameraCenter(); this.constraintOptions.interactionType = 5; this.constraintOptions.selection = 8; k.applyAll(this.view, this.currentCamera, this.constraintOptions) && this.updateCameraCenter(); this.constraintOptions.selection = 7; k.applyAll(this.view, this.currentCamera, this.constraintOptions); this.constraintOptions.interactionDirection = null
              }
            }; R.calculateControlTransformation = function (S, Q, T) {
            T.zoom = 0; T.ascend = 0; T.pan.enabled = !1; d.identity(T.pan.matrix); T.rotate.enabled =
              !1; d.identity(T.rotate.matrix); S = this.computeVelocities(S); this.view.state.isLocal ? this.calculateControlTransformationLocal(S, Q, T) : this.calculateControlTransformationGlobal(S, Q, T)
            }; R.updateCameraCenter = function () { this.currentCamera.center = this.view.renderCoordsHelper.intersectManifoldClosestSilhouette(this.currentCamera.ray, this.view.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude, L) }; R.calculateControlTransformationLocal = function (S, Q, T) {
              const { viewRight: da, viewForward: Y } = Q, fa = this.transformation;
              var ha = this.view.navigation.gamepad, ka = t.set(x.sv3d.get(), Y[0], Y[1], 0); t.normalize(ka, ka); var ea = fa.translation[0] * S.pan; 0 !== ea && (ea = t.scale(x.sv3d.get(), da, ea), d.translate(T.pan.matrix, T.pan.matrix, ea), T.pan.enabled = !0); switch (ha.mode) { case "pan": ha = -fa.translation[1] * S.pan; 0 !== ha && (ka = t.scale(x.sv3d.get(), ka, ha), d.translate(T.pan.matrix, T.pan.matrix, ka), T.pan.enabled = !0); T.zoom = fa.zoom * S.zoom; break; case "zoom": T.zoom = (-fa.translation[1] + fa.zoom) * S.zoom; break; default: q.neverReached(ha.mode) }T.ascend =
                fa.translation[2] * S.ascend; ka = -fa.heading * S.rotate; 0 !== ka && (d.rotate(T.rotate.matrix, T.rotate.matrix, ka, this.view.renderCoordsHelper.worldUpAtPosition(Q.eye, x.sv3d.get())), T.rotate.enabled = !0); S = fa.tilt * S.rotate; Q = B.viewAngle(this.view.renderCoordsHelper, Q.center, Q.eye); if (Q = u.clamp(Q + S, r.TiltDefault.min, r.TiltDefault.max) - Q) d.rotate(T.rotate.matrix, T.rotate.matrix, Q, da), T.rotate.enabled = !0
            }; R.calculateControlTransformationGlobal = function (S, Q, T) {
              const { eye: da, viewRight: Y } = Q, fa = this.transformation;
              var ha = this.view.navigation.gamepad, ka = t.cross(x.sv3d.get(), Y, da); t.normalize(ka, ka); t.negate(ka, ka); z.panMotionToRotationMatrix(this.startCamera, Q, fa, S, this.view.camera.heading, this.headingStart, this.view.camera.tilt, T, ha); this.tmpCamera.copyFrom(this.currentCamera); this.applyPan(P.pan, this.tmpCamera); ha = this.view.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude; T.ascend = fa.translation[2] * S.ascend; ka = -fa.heading * S.rotate; 0 !== ka && (d.rotate(T.rotate.matrix, T.rotate.matrix, ka, this.tmpCamera.eye),
                T.rotate.enabled = !0); Q = this.clampTiltDeltaGlobalToValidRange(fa.tilt * S.rotate, Q.ray, ha); 0 !== Q && (d.rotate(T.rotate.matrix, T.rotate.matrix, Q, this.tmpCamera.viewRight), T.rotate.enabled = !0); T.zoom += fa.zoom * S.zoom
            }; R.clampTiltDeltaGlobalToValidRange = function (S, Q, T) {
              const da = m.getReferenceEllipsoid(this.view.spatialReference), Y = z.onSurfaceTiltToEyeTiltGlobal(r.TiltDefault.min, Q.origin, T, da); var fa = 0; let ha = 0; fa = x.sv3d.get(); this.view.renderCoordsHelper.intersectManifold(Q, T, fa) ? (fa = B.viewAngle(this.view.renderCoordsHelper,
                fa, Q.origin), fa = z.onSurfaceTiltToEyeTiltGlobal(fa, Q.origin, T, da), ha = z.onSurfaceTiltToEyeTiltGlobal(r.TiltDefault.max, Q.origin, T, da)) : (g.closestPointOnSilhouette(g.fromRadius(T + da.radius), Q, fa), fa = u.acosClamped(-t.dot(Q.direction, t.normalize(fa, fa))), fa = z.offSurfaceTiltToEyeTiltGlobal(fa, Q.origin, T, da), ha = z.offSurfaceTiltToEyeTiltGlobal(r.TiltDefault.max, Q.origin, T, da)); return u.clamp(fa + S, Y, ha) - fa
            }; R.getPointAbsoluteSurfaceElevation = function (S, Q, T) {
              const { renderCoordsHelper: da } = this.view, Y = da.getAltitude(S);
              Q += Math.abs(Y - Q); da.setAltitude(T, Q, S); return Q
            }; R.clampedDistanceToSurface = function (S, Q) { const { renderCoordsHelper: T } = this.view, { camera: da } = this.view.state; var { direction: Y } = C.headingTiltToDirectionUp(this.view, Q, 0, 80, G); Y = T.intersectManifoldClosestSilhouette(e.wrap(Q, Y), S, x.sv3d.get()); Y = t.distance(Q, Y); S = T.intersectManifoldClosestSilhouette(e.wrap(Q, t.direction(x.sv3d.get(), Q, da.center)), S, x.sv3d.get()); Q = t.distance(Q, S); return Math.min(Y, Q) }; R.computeHeadingRotateRadius = function (S) {
              const { renderCoordsHelper: Q,
                state: T } = this.view, { camera: da, isGlobal: Y } = T; var fa = Q.intersectManifoldClosestSilhouette(da.ray, this.filteredSurfaceElevation, x.sv3d.get()); if (Y) { const ha = t.subtract(x.sv3d.get(), S, fa); fa = t.length(ha); t.scale(ha, ha, 1 / fa); S = t.normalize(x.sv3d.get(), S); S = u.acosClamped(t.dot(S, ha)); return fa * Math.sin(Math.min(M, S)) } S = t.copy(x.sv3d.get(), S); Q.setAltitude(S, this.filteredSurfaceElevation); return t.distance(fa, S)
            }; R.minimumAscendVelocity = function () { return this.view.state.constraints.collision.enabled ? 0 : 5 };
          R.computeVelocities = function (S) {
            var Q = this.filteredSurfaceElevation, T = Q + m.getReferenceEllipsoid(this.view.spatialReference).radius; const { camera: da, isGlobal: Y } = this.view.state; var fa = x.sv3d.get(); const ha = this.getPointAbsoluteSurfaceElevation(da.eye, Q, fa); var ka = this.clampedDistanceToSurface(Q, fa); const ea = da.width / 2, ba = .75 * da.width, aa = .75 * da.width; var W = ka * Math.tan(.5 * da.fovX) / ea; T = W / T; fa = W / this.computeHeadingRotateRadius(fa); W = (Y ? T : W) * ba * S; Q = ha - Q; Q = Math.max(this.minimumAscendVelocity() * S, 2 ** (ba *
              S / ea) * Q - Q); ka = 2 ** (ba * S / ea) * ka - ka; S *= u.clamp(fa * aa, F, K); return { pan: W, ascend: Q, zoom: ka, rotate: S }
          }; R.applyDisabledMovementTypes = function (S) {
          !y.isSome(this.disableMovements) || void 0 !== this.disableMovements.mode && this.view.state.viewingMode !== this.disableMovements.mode || (S.zoom = this.disableMovements.zoom ? 0 : S.zoom, S.ascend = this.disableMovements.ascend ? 0 : S.ascend, S.pan.enabled = !this.disableMovements.pan, this.disableMovements.pan && d.identity(S.pan.matrix), S.rotate.enabled = !this.disableMovements.rotate, this.disableMovements.rotate &&
            d.identity(S.rotate.matrix))
          }; O.activatesFor = function (S, Q) { S = H.extractTransformation(Q, S.navigation.gamepad, J); return !("end" === Q.action || H.isZeroTransformation(S)) }; return O
        }(A.InteractiveController); c.__decorate([n.property({ constructOnly: !0 })], a.GamepadKeyboardController.prototype, "view", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.GamepadKeyboardController.prototype, "gamepadDevice", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.GamepadKeyboardController.prototype, "disableMovements",
          void 0); a.GamepadKeyboardController = c.__decorate([b.subclass("esri.views.3d.state.controllers.GamepadKeyboardController")], a.GamepadKeyboardController); const J = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }, M = u.deg2rad(80), F = u.deg2rad(30), K = u.deg2rad(80), P = { zoom: 0, ascend: 0, pan: { enabled: !1, matrix: f.create() }, rotate: { enabled: !1, matrix: f.create() } }, L = v.create(), N = v.create(), G = D.createDirectionUp(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/cameraUtils": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../Camera ../../../core/Logger ../../../core/mathUtils ../../../core/maybe ../../../core/promiseUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/Point ../../../geometry/projection ../../../geometry/projectionEllipsoid ../../../geometry/SpatialReference ../../../geometry/support/scaleUtils ../camera/intersectionUtils ../../../chunks/cameraUtilsPlanar ../../../chunks/cameraUtilsSpherical ./earthUtils ./ElevationProvider ./mathUtils ../../support/spatialReferenceSupport".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
          function A(ka) { return "global" === ka.viewingMode ? e.cameraUtilsSpherical : m.cameraUtilsPlanar } function z(ka, ea, ba) { const aa = ka.state.camera, W = aa.width / 2 / aa.pixelRatio; 1 === ka.renderCoordsHelper.viewingMode && null != ba && (ea *= Math.cos(u.deg2rad(ba))); ea /= ka.renderCoordsHelper.unitInMeters; return W / (96 * 39.37 / ea) / Math.tan(aa.fovX / 2) } function B(ka, ea, ba) {
            const aa = ka.state.camera; ea = 96 * 39.37 / (aa.width / 2 / aa.pixelRatio / (ea * Math.tan(aa.fovX / 2))); 1 === ka.renderCoordsHelper.viewingMode &&
              (ea /= Math.cos(u.deg2rad(ba))); return ea *= ka.renderCoordsHelper.unitInMeters
          } function C(ka, ea, ba, aa, W, U) { if (I(U)) { const X = new ha(U.signal); P(ka, aa.heading, aa.tilt, ea, ba, W, X); X.resolver.promise.then(Z => { Z = G(ka, Z, aa.fov); if (y.isNone(Z)) U.resolver.reject(); else return U.resolver.resolve(Z) }, Z => U.resolver.reject(Z)) } else return ea = P(ka, aa.heading, aa.tilt, ea, ba, W), G(ka, ea, aa.fov, U) } function D(ka, ea, ba, aa, W) { return A(ka).directionToHeadingTilt(ea, ba, aa, W) } function E(ka, ea) {
            return !!(ka.basemapTerrain && ka.renderCoordsHelper.fromRenderCoords(ea,
              T, ka.spatialReference) && y.unwrapOr(x.getElevationAtPoint(ka.elevationProvider, T), 0) > T.z - 1)
          } function H(ka, ea, ba) { return J.apply(this, arguments) } function J() { J = w._asyncToGenerator(function* (ka, ea, ba) { if (!ka.renderCoordsHelper.fromRenderCoords(ea, T, ka.spatialReference)) return !1; ka = yield ka.elevationProvider.queryElevation(T.x, T.y, T.z, T.spatialReference, "ground", ba); return y.unwrapOr(ka, 0) > T.z - 1 }); return J.apply(this, arguments) } function M(ka, ea, ba) { return F.apply(this, arguments) } function F() {
            F = w._asyncToGenerator(function* (ka,
              ea, ba) { const aa = l.create(); ea ? ea instanceof h ? (b.projectPointToVector(ea, aa, ka.renderSpatialReference), null == ea.z && null != ka.basemapTerrain && (ea = yield ka.elevationProvider.queryElevation(ea.x, ea.y, ea.z, ea.spatialReference, "ground", ba), y.isSome(ea) && ka.renderCoordsHelper.setAltitude(aa, ea))) : p.copy(aa, ea) : p.copy(aa, ka.state.camera.center); return aa }); return F.apply(this, arguments)
          } function K(ka, ea) {
            const ba = l.create(); ea && ea instanceof h ? (b.projectPointToVector(ea, ba, ka.renderSpatialReference), null ==
              ea.z && null != ka.basemapTerrain && (ea = x.getElevationAtPoint(ka.elevationProvider, ea), y.isSome(ea) && ka.renderCoordsHelper.setAltitude(ba, ea))) : ea ? p.copy(ba, ea) : p.copy(ba, ka.state.camera.center); return ba
          } function P(ka, ea, ba, aa, W, U, X) { const Z = aa && aa instanceof h ? aa : null; if (I(X)) return M(ka, aa, X.signal).then(ia => { L(ka, ea, ba, Z, ia, W, U, X) }, ia => X.resolver.reject(ia)), null; aa = K(ka, aa); return L(ka, ea, ba, Z, aa, W, U, X) } function L(ka, ea, ba, aa, W, U, X, Z) {
            if (y.isNone(aa) && (aa = b.projectVectorToPoint(W, ka.renderSpatialReference,
              ka.spatialReference || f.WGS84), y.isNone(aa))) return null; U = Math.max(U, ka.state.constraints.minimumPoiDistance); var ia = N(ka, ea, ba, W, U, X); const la = A(ka).eyeForCenterWithHeadingTilt, ma = la(W, U, ia.heading, ia.tilt); if (1 === X && "global" === ka.viewingMode && 0 < ba) {
                const ra = () => { var Aa = U, za = U; var Ka = ka.state.constraints.tilt(za); za = A(ka).eyeTiltToLookAtTilt(ba, W, za); za = Math.min(za, .5 * Math.PI); Ka = Ka.min * (1 - .7) + .7 * za; Aa = A(ka).lookAtTiltToEyeTilt(Ka, W, Aa); X = 1 > ba - Aa ? 0 : 1; return L(ka, ea, Aa, aa, W, U, X, Z) }; ia = ka.map.ground.navigationConstraint;
                if (!ia || "stay-above" === ia.type) { if (E(ka, ma.eye)) return ra(); if (I(Z)) return H(ka, ma.eye, Z.signal).then(Aa => { if (Aa) return ra(); Z.resolver.resolve({ eye: ma.eye, up: ma.up, center: l.clone(W), heading: ma.heading, tilt: ma.tilt }); return null }), null }
              } ia = !Z || I(Z) ? { center: l.create(), eye: l.create(), up: l.create(), tilt: 0, heading: 0 } : Z; ia.eye = ma.eye; ia.up = ma.up; ia.center = l.clone(W); ia.heading = ma.heading; ia.tilt = ma.tilt; I(Z) && Z.resolver.resolve(ia); return ia
          } function N(ka, ea, ba, aa, W, U) {
            var X = 0; if (U = 1 === U) if (X = ka.pointsOfInterest.centerOnSurfaceFrequent.distance,
              8 < Math.log(W / X) / Math.LN2) U = !0; else { var Z = ka.renderSpatialReference, ia = ka.spatialReference || f.WGS84; U = b.projectVectorToPoint(aa, Z, ia); Z = b.projectVectorToPoint(ka.pointsOfInterest.centerOnSurfaceFrequent.renderLocation, Z, ia); y.isNone(U) || y.isNone(Z) ? U = !1 : (X *= Math.tan(.5 * ka.state.camera.fov), U = 5 < Z.distance(U) / X) } U ? (ea = 0, U = ka.state.constraints.tilt(W), U.max = Math.min(U.max, .5 * Math.PI), U = U.min * (1 - .7) + .7 * U.max, ba = A(ka).eyeTiltToLookAtTilt(ba, aa, W), X = Math.min(ba, U)) : X = A(ka).eyeTiltToLookAtTilt(ba, aa, W); ba =
                X = ka.state.constraints.clampTilt(W, X); ba = A(ka).lookAtTiltToEyeTilt(ba, aa, W); return { heading: ea, tilt: ba }
          } function G(ka, ea, ba, aa) { if (y.isNone(ea)) return null; ka = b.projectVectorToPoint(ea.eye, ka.renderSpatialReference, ka.spatialReference || f.WGS84); return y.isNone(ka) ? null : y.isSome(aa) ? (aa.position = ka, aa.heading = ea.heading, aa.tilt = ea.tilt, aa.fov = ba, aa) : new c(ka, ea.heading, ea.tilt, ba) } function I(ka) { return ka && "resolver" in ka } const O = q.getLogger("esri.views.3d.support.cameraUtils"), R = l.create(), S = l.create(),
            Q = { heading: 0, tilt: 0 }, T = new h, da = new k.Cyclical(-2.0037508342788905E7, 2.0037508342788905E7), Y = new k.Cyclical(-180, 180), fa = l.create(); let ha = function (ka) { this.signal = ka; this.resolver = n.createResolver() }; a.AsyncContext = ha; a.computeScale = function (ka, ea, ba) {
              const aa = ka.renderSpatialReference; ea || (ea = ka.state.camera); var W = f.WGS84; ea instanceof c ? (W = ea.position.latitude, b.projectPointToVector(ea.position, R, aa), b.projectPointToVector(ba, S, aa), ea = p.distance(R, S)) : (b.projectVectorToVector(ea.center, aa, S, W),
                W = S[1], ea = ea.distance); return B(ka, ea, W)
            }; a.directionToHeadingTilt = D; a.distanceToScale = B; a.externalToInternal = function (ka, ea) {
              if (y.isNone(ea)) return null; var ba = ka.renderSpatialReference; const aa = A(ka).headingTiltToDirectionUp, W = l.create(); if (!b.projectPointToVector(ea.position, W, ba)) return null; ba = aa(W, ea.heading, ea.tilt); p.scale(ba.direction, ba.direction, ka.state.camera.distance); p.add(ba.direction, ba.direction, W); ka = v.cameraOnContentAlongViewDirection(ka, W, ba.direction, ba.up); ka.fov = u.deg2rad(ea.fov);
              return ka
            }; a.fromCenterDistance = C; a.fromCenterScale = function (ka, ea, ba, aa, W, U) { ba = z(ka, ba, ea.latitude); return C(ka, ea, ba, aa, W, U) }; a.fromExtent = function (ka, ea, ba, aa, W, U = null) {
              var X = null != ea.zmax && null != ea.zmin; let Z; if (ka.state.isGlobal) {
                if (!r.isSpatialReferenceSupported(ea.spatialReference, 1)) return I(U) && U.resolver.reject(), null; var ia = new h(ea.xmin, ea.ymin, ea.spatialReference); const ra = new h(ea.xmax, ea.ymax, ea.spatialReference), Aa = ea.spatialReference.isGeographic ? Y : da; var la = new h({
                  x: Aa.center(ia.x,
                    ra.x), y: (ra.y + ia.y) / 2, z: X ? (ea.zmax + ea.zmin) / 2 : null, spatialReference: ea.spatialReference
                }); const za = d.getReferenceEllipsoid(ea.spatialReference); var ma = g.getGreatCircleSpanAt(la, ia, ra); Z = ma.lon; ma = ma.lat; Aa.diff(ia.x, ra.x) > Aa.range / 2 && (Z += za.halfCircumference); Z = Math.min(Z, za.halfCircumference); ma = Math.min(ma, za.halfCircumference)
              } else la = y.unwrapOr(ka.renderSpatialReference, ea.spatialReference), la.equals(ea.spatialReference) || (ea = b.project(ea, la)), Z = ea.xmax - ea.xmin, ma = ea.ymax - ea.ymin, la = new h({
                x: ea.xmin +
                  .5 * Z, y: ea.ymin + .5 * ma, z: X ? (ea.zmax + ea.zmin) / 2 : null, spatialReference: la
              }); ia = ka.state.camera; ea = Math.max(1 / Math.tan(ia.fovX / 2) * Z * .5, 1 / Math.tan(ia.fovY / 2) * ma * .5, 1 / Math.tan(ia.fov / 2) * (X ? ea.zmax - ea.zmin : 0) * .5) / 1; if (I(U)) X = new ha(U.signal), P(ka, ba, aa, la, ea, W, X), X.resolver.promise.then(ra => { ra = G(ka, ra, ka.camera.fov); if (y.isNone(ra)) U.resolver.reject(); else return U.resolver.resolve(ra) }, ra => U.resolver.reject(ra)); else return ba = P(ka, ba, aa, la, ea, W), G(ka, ba, ka.camera.fov, U)
            }; a.getObserverForPointAtDistance =
              P; a.headingTiltToDirectionUp = function (ka, ea, ba, aa, W) { return A(ka).headingTiltToDirectionUp(ea, ba, aa, W) }; a.internalToExternal = function (ka, ea, ba) {
                const aa = ka.renderSpatialReference, W = D(ka, ea.eye, ea.viewForward, ea.up, Q); ka = ka.spatialReference || f.WGS84; b.projectVectorToVector(ea.eye, aa, fa, ka) || (ka = f.WGS84, b.projectVectorToVector(ea.eye, aa, fa, ka)); if (y.isNone(ba)) return new c(new h(fa, ka), W.heading, W.tilt, u.rad2deg(ea.fov)); ba.position.x = fa[0]; ba.position.y = fa[1]; ba.position.z = fa[2]; ba.position.spatialReference =
                  ka; ba.heading = W.heading; ba.tilt = W.tilt; ba.fov = u.rad2deg(ea.fov); return ba
              }; a.observerToCamera = G; a.scaleToDistance = z; a.scaleToResolution = function (ka, ea) { return ka.spatialReference ? t.getResolutionForScale(ea, ka.spatialReference) : void 0 }; a.scaleToZoom = function (ka, ea) { var ba; if (ka = null == (ba = ka.basemapTerrain) ? void 0 : ba.tilingScheme) return ka.levelAtScale(ea); O.error("#scaleToZoom()", "Cannot compute zoom from scale without a tiling scheme") }; a.toExtent = function (ka, ea, ba) {
                const aa = b.projectVectorToPoint(ba,
                  ka.renderSpatialReference, ka.spatialReference || f.WGS84); if (y.isNone(aa)) return null; var W = Math.tan(ea.fovX / 2), U = Math.tan(ea.fovY / 2); ea = p.dist(ea.eye, ba); W *= 2 * ea; U *= 2 * ea; return "global" === ka.viewingMode ? e.toExtent(ka, aa, W, U) : m.toExtent(ka, aa, W, U)
              }; a.zoomToScale = function (ka, ea) { var ba; if (ka = null == (ba = ka.basemapTerrain) ? void 0 : ba.tilingScheme) return ka.scaleAtLevel(ea); O.error("#zoomToScale()", "Cannot compute scale from zoom without a tiling scheme") }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/chunks/cameraUtilsPlanar": function () {
      define("exports ../core/mathUtils ./mat4 ./mat4f64 ./vec3 ./vec3f64 ../geometry/Extent ../geometry/projection ../views/3d/support/cameraUtilsInternal".split(" "), function (a, w, c, q, u, y, n, p, l) {
        function h(r, A, z, B = l.createDirectionUp()) { c.identity(g); const { direction: C, up: D } = B; c.rotateZ(g, g, -w.deg2rad(A)); c.rotateX(g, g, w.deg2rad(z)); u.transformMat4(C, e, g); u.scale(C, C, -1); u.transformMat4(D, m, g); return B } function b(r, A, z, B) {
          return l.directionToHeadingTilt(A, z, B,
            e, m)
        } function d(r, A, z, B) { const C = h(r, z, B), D = y.create(); u.scale(D, C.direction, -A); u.add(D, D, r); return { up: C.up, eye: D, heading: z, tilt: B } } function f(r) { return w.rad2deg(r) } function t(r) { return w.deg2rad(r) } function v(r, A, z, B, C) {
          const D = r.renderSpatialReference; r = r.map && r.spatialReference || A.spatialReference; p.projectPointToVector(A, x, D); p.projectPointToVector(A, k, D); x[0] -= z / 2; k[0] += z / 2; x[1] -= B / 2; k[1] += B / 2; p.projectVectorToVector(x, D, x, r); p.projectVectorToVector(k, D, k, r); C ? (C.xmin = x[0], C.ymin = x[1], C.xmax =
            k[0], C.ymax = k[1], C.spatialReference = r) : C = new n(x[0], x[1], k[0], k[1], r); return C
        } const m = y.fromValues(0, 1, 0), e = y.fromValues(0, 0, 1), g = q.create(), x = y.create(), k = y.create(); q = Object.freeze({ __proto__: null, headingTiltToDirectionUp: h, directionToHeadingTilt: b, eyeForCenterWithHeadingTilt: d, lookAtTiltToEyeTilt: f, eyeTiltToLookAtTilt: t, toExtent: v }); a.cameraUtilsPlanar = q; a.directionToHeadingTilt = b; a.eyeForCenterWithHeadingTilt = d; a.eyeTiltToLookAtTilt = t; a.headingTiltToDirectionUp = h; a.lookAtTiltToEyeTilt = f; a.toExtent =
          v
      })
    }, "esri/views/3d/support/cameraUtilsInternal": function () {
      define(["exports", "../../../core/mathUtils", "../../../chunks/vec3", "../../../chunks/vec3f64"], function (a, w, c, q) {
        const u = q.create(), y = q.create(); a.createDirectionUp = function () { return { direction: q.create(), up: q.create() } }; a.directionToHeadingTilt = function (n, p, l, h, b) {
          let d = c.normalize(u, n), f = c.dot(d, h); const t = 0 < f; f = Math.abs(f); .99 < f && (f = Math.abs(c.dot(p, h)), .99 > f ? (c.copy(d, p), t && c.scale(d, d, -1)) : d = null); p = 0; d && (c.scale(y, h, c.dot(h, d)), c.subtract(d,
            d, y), p = c.dot(d, b) / (c.length(d) * c.length(b)), c.cross(y, d, b), p = (0 < c.dot(y, h) ? 1 : -1) * w.rad2deg(w.acosClamped(p))); n = w.rad2deg(w.acosClamped(-c.dot(h, n) / c.length(n))); if (!l) return { heading: p, tilt: n }; l.heading = p; l.tilt = n; return l
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/cameraUtilsSpherical": function () {
      define("exports ../core/mathUtils ./mat4 ./mat4f64 ./vec3 ./vec3f64 ../geometry/Extent ../geometry/projectionEllipsoid ../geometry/SpatialReference ../geometry/support/webMercatorUtils ../views/3d/support/cameraUtilsInternal ../views/3d/support/earthUtils ../views/3d/support/mathUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(H, J, M, F = b.createDirectionUp()) { u.cross(D, H, A); 0 === u.dot(D, D) && u.cross(D, H, z); c.identity(C); c.rotate(C, C, -w.deg2rad(J), H); c.rotate(C, C, -w.deg2rad(M), D); const { up: K, direction: P } = F; u.cross(K, D, H); u.normalize(K, K); u.transformMat4(K, K, C); u.normalize(P, H); u.negate(P, P); u.transformMat4(P, P, C); return F } function v(H, J, M, F) { const K = D, P = E; u.normalize(K, H); u.cross(E, K, A); 0 === u.dot(E, E) && u.cross(E, K, z); u.cross(P, E, K); return b.directionToHeadingTilt(J, M, F, K, P) } function m(H,
            J, M, F) {
              const K = { eye: y.create(), up: null, tilt: F, heading: M }, P = D; P[0] = H[0]; P[1] = H[2]; P[2] = -H[1]; M = w.deg2rad(M); var L = w.deg2rad(F); F = Math.sin(M); M = Math.cos(M); var N = Math.sin(L), G = Math.cos(L); const I = u.length(P); if (1E-8 > Math.abs(L)) L = J + I; else { var O = I / N, R = w.asinClamped(J / O); L = O * Math.sin(Math.PI - L - R) } G *= J; O = J * J * N * N; R = M * M * O; const S = L - G, Q = S * S; var T = R * (R + Q - P[1] * P[1]); if (0 > T) return u.scale(K.eye, P, L / I), K.tilt = 0, K; var da = Math.sqrt(T); const Y = P[1] * S; T = R + Q; da = 0 < M ? -da + Y : da + Y; if (1E-8 > Math.abs(T)) return 1E-8 > I ? (K.eye[0] =
                0, K.eye[1] = 0, K.eye[2] = J) : u.scale(K.eye, P, L / I), K.tilt = 0, e(K.eye), g(K, H); K.eye[1] = da / T; J *= N; da = K.eye[1] * K.eye[1]; N = 1 - da; T = Math.sqrt(N); O = R * da + F * F * O - 2 * M * J * K.eye[1] * T * S + N * Q; if (1E-8 > Math.abs(O)) return u.scale(K.eye, P, L / I), K.tilt = 0, e(K.eye), g(K, H); K.eye[0] = (N * (L * P[0] - G * P[0]) - J * T * (P[0] * K.eye[1] * M + P[2] * F)) / O; K.eye[2] = (N * (L * P[2] - G * P[2]) - J * T * (P[2] * K.eye[1] * M - P[0] * F)) / O; u.scale(K.eye, K.eye, L); e(K.eye); return g(K, H)
          } function e(H) { const J = H[1]; H[1] = -H[2]; H[2] = J } function g(H, J) {
            J = t(J, H.heading, H.tilt); H.up = J.up;
            return H
          } function x(H, J, M) { J = u.length(J); M = w.asinClamped(M / (Math.sqrt(M * M + J * J - 2 * M * J * Math.cos(Math.PI - H)) / Math.sin(H))); return w.rad2deg(H - M) } function k(H, J, M) { H = w.deg2rad(H); J = u.length(J); return w.asinClamped(M / (J / Math.sin(H))) + H } function r(H, J, M, F, K) {
            function P(I) { const O = Math.PI / 2; I = f.cyclical2PI.normalize(I, -O); I > O && (I = Math.PI - I); return I } var L = J.latitude; J = J.longitude; var N = d.getLonDeltaForDistance(L, M, p.getReferenceEllipsoid(H.spatialReference).radius) / 2; M = J - N; J += N; L = w.deg2rad(L); N = p.getReferenceEllipsoid(H.spatialReference).radius;
            L = (1 + Math.sin(L)) / (1 - Math.sin(L)); const G = (L + 1) * Math.tan(F / N / 2); L = 1.5 * Math.PI - 2 * Math.atan(.5 * (G + Math.sqrt(4 * L + G * G))); F = L + F / N; L = P(L); F = P(F); F < L && (N = F, F = L, L = N); L = Math.max(w.rad2deg(L), -90); F = Math.min(w.rad2deg(F), 90); J = B.monotonic(M, J); 180 < J - M && (N = (J - M - 180) / 2, M += N, J -= N); N = H.spatialReference && H.spatialReference.isGeographic ? H.spatialReference : l.WGS84; K ? (K.xmin = M, K.ymin = L, K.xmax = J, K.ymax = F, K.spatialReference = N) : K = new n(M, L, J, F, N); H.spatialReference && H.spatialReference.isWebMercator && h.geographicToWebMercator(K,
              !1, K); return K
          } const A = y.fromValues(0, 0, 1), z = u.normalize(y.create(), y.fromValues(1, 1, 1)), B = new f.Cyclical(-180, 180), C = q.create(), D = y.create(), E = y.create(); q = Object.freeze({ __proto__: null, headingTiltToDirectionUp: t, directionToHeadingTilt: v, eyeForCenterWithHeadingTilt: m, lookAtTiltToEyeTilt: x, eyeTiltToLookAtTilt: k, toExtent: r }); a.cameraUtilsSpherical = q; a.directionToHeadingTilt = v; a.eyeForCenterWithHeadingTilt = m; a.eyeTiltToLookAtTilt = k; a.headingTiltToDirectionUp = t; a.lookAtTiltToEyeTilt = x; a.toExtent = r
        })
    },
    "esri/views/support/spatialReferenceSupport": function () { define(["exports"], function (a) { a.isSpatialReferenceSupported = function (w, c) { return null == w ? !1 : null == c ? !0 : 2 === c ? w.isGeographic ? w.isWGS84 || 4490 === w.wkid : !0 : w.isWebMercator || w.isWGS84 || 4490 === w.wkid || 104971 === w.wkid || 104905 === w.wkid || 104903 === w.wkid }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/navigation/gamepadAndKeyboardUtils": function () {
      define(["exports", "../../chunks/vec3"], function (a, w) {
        function c(q) {
          let u = q * q; 0 > q && (u *= -1);
          return u
        } a.extractTransformation = function (q, u, y) {
          const n = q.state; q = q.device; u = "forward-down" === u.tiltDirection ? 1 : -1; "standard" === q.deviceType ? (y.translation[0] = c(n.axes[0]), y.translation[1] = c(n.axes[1]), y.translation[2] = c(n.buttons[7]) - c(n.buttons[6]), y.heading = c(n.axes[2]), y.tilt = c(n.axes[3])) : "spacemouse" === q.deviceType && (y.translation[0] = 1.2 * c(n.axes[0]), y.translation[1] = 1.2 * c(n.axes[1]), y.translation[2] = 2 * -c(n.axes[2]), y.heading = 1.2 * c(n.axes[5]), y.tilt = 1.2 * c(n.axes[3])); y.tilt *= u; w.scale(y.translation,
            y.translation, 1); return y
        }; a.extractTransformationKeyboard = function (q, u) { u.translation[0] = q[1] - q[0]; u.translation[1] = q[3] - q[2]; u.translation[2] = q[4] - q[5]; u.heading = q[7] - q[6]; u.tilt = q[8] - q[9]; u.zoom = q[10] - q[11]; return u }; a.isZeroTransformation = function (q) { return 0 === q.translation[0] && 0 === q.translation[1] && 0 === q.translation[2] && 0 === q.heading && 0 === q.tilt && 0 === q.zoom }; a.quadraticAccentuation = c; a.resetTransformation = function (q) {
        q.translation[0] = 0; q.translation[1] = 0; q.translation[2] = 0; q.heading = 0; q.tilt =
          0; return q
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/input/handlers/KeyboardNavigation": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../state/controllers/GamepadKeyboardController", "../../../input/InputHandler"], function (a, w, c, q) {
        q = function (u) {
          function y(p, l) {
            var h = u.call(this, !0) || this; h.view = p; h.disableMovements = { pan: !0, zoom: !1, ascend: !0, rotate: !1, mode: 2 }; h.keyToNumber = {
              [l.left]: 0, [l.right]: 1, [l.forward]: 2, [l.backward]: 3, [l.up]: 4, [l.down]: 5,
              [l.headingLeft]: 6, [l.headingRight]: 7, [l.tiltUp]: 8, [l.tiltDown]: 9, [l.zoomIn]: 10, [l.zoomOut]: 11
            }; h.registerIncoming("key-down", null, b => h.handleKeyDown(b)); h.registerIncoming("key-up", null, b => h.handleKeyUp(b)); h.registerIncoming("blur", null, () => h.handleBlur()); return h
          } w._inheritsLoose(y, u); var n = y.prototype; n.handleKeyDown = function (p) {
            if (!p.data.native.ctrlKey && !p.data.native.metaKey) {
              var l = this.keyToNumber[p.data.key]; null != l && (this.cameraControllerKeyboard && this.cameraControllerKeyboard.active || (this.cameraControllerKeyboard =
                new c.GamepadKeyboardController({ view: this.view, disableMovements: this.disableMovements }), this.view.state.switchCameraController(this.cameraControllerKeyboard)), this.cameraControllerKeyboard.active && (this.cameraControllerKeyboard.activateDirection(l), p.stopPropagation()))
            }
          }; n.handleBlur = function () { this.cameraControllerKeyboard && this.cameraControllerKeyboard.active && (this.cameraControllerKeyboard.finishController(), this.cameraControllerKeyboard = null) }; n.handleKeyUp = function (p) {
            if (!p.data.native.ctrlKey &&
              !p.data.native.metaKey) { var l = this.keyToNumber[p.data.key]; null != l && this.cameraControllerKeyboard && this.cameraControllerKeyboard.active && (this.cameraControllerKeyboard.deactivateDirection(l), p.stopPropagation()) }
          }; return y
        }(q.InputHandler); a.KeyboardNavigation = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/input/handlers/MouseWheelZoom": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/screenUtils ../../state/controllers/global/ZoomStepController ../../state/controllers/local/ZoomStepController ../../../input/InputHandler".split(" "),
        function (a, w, c, q, u, y) {
          y = function (n) {
            function p(l, h) { var b = n.call(this, !0) || this; b.view = l; b.registerIncoming("mouse-wheel", h, d => b.handleMouseWheel(d)); return b } w._inheritsLoose(p, n); p.prototype.handleMouseWheel = function (l) {
              if (this.view.navigation.mouseWheelZoomEnabled) {
                var h = l.data; this.cameraController && this.cameraController.active || (this.cameraController = this.view.state.isGlobal ? new q.ZoomStepController({ view: this.view, mode: "interaction" }) : new u.ZoomStepController({ view: this.view, mode: "interaction" }),
                  this.view.state.switchCameraController(this.cameraController)); this.cameraController.zoomStep(-1 / 60 * h.deltaY, c.createScreenPointArray(h.x, h.y)); l.preventDefault(); l.stopPropagation()
              }
            }; return p
          }(y.InputHandler); a.MouseWheelZoom = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/input/handlers/PinchAndPanNavigation": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../state/controllers/global/PinchAndPanController ../../state/controllers/local/PinchAndPanController ../../../input/InputHandler ../../../input/handlers/support".split(" "),
        function (a, w, c, q, u, y) {
          u = function (n) {
            function p(h, b, d) { var f = n.call(this, !0) || this; f.view = h; f.pointerAction = b; f.lastEndTimestamp = 0; f.lastTimestamp = 0; f.registerIncoming("drag", d, t => f.handleDrag(t)); return f } w._inheritsLoose(p, n); var l = p.prototype; l.handleDrag = function (h) {
              if ("mouse" !== h.data.pointerType || y.eventMatchesMousePointerAction(h.data, this.pointerAction)) {
                var b = h.timestamp - this.lastEndTimestamp; b = this.momentum && this.momentum.active && 40 > b; switch (h.data.action) {
                  case "start": case "update": if (b) break;
                    this.controller && this.controller.active ? 2 < h.data.timestamp - this.lastTimestamp && (this.controller.update(h.data), this.lastTimestamp = h.timestamp) : this.startController(h); break; case "end": case "removed": this.endController(h, !0); break; case "added": this.endController(h, !1), this.startController(h)
                }h.stopPropagation()
              }
            }; l.endController = function (h, b) {
            this.controller && this.controller.active && (this.lastEndTimestamp = h.timestamp, h = this.controller.end(h.data), b && h && (this.momentum = h, this.view.state.switchCameraController(this.momentum)));
              this.controller = null
            }; l.startController = function (h) { this.controller = this.createController(); this.view.state.switchCameraController(this.controller); this.controller.begin(h.data); this.lastTimestamp = h.timestamp }; l.createController = function () { return this.view.state.isGlobal ? new c.PinchAndPanController({ view: this.view }) : new q.PinchAndPanController({ view: this.view }) }; return p
          }(u.InputHandler); a.PinchAndPanNavigation = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/global/PinchAndPanController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/mathUtils ../../../../../core/screenUtils ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec2 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/projectionEllipsoid ../../../../../geometry/support/axisAngle ../../../../../geometry/support/plane ../../../../../chunks/sphere ../../../../../support/featureFlags ../../../camera/constraintUtils ../../../input/util ../InteractiveController ../momentum/PanPlanarMomentumController ../momentum/PanSphericalMomentumController ../momentum/RotationMomentumController ../momentum/ZoomPlanarMomentumController ../momentum/ZoomSphericalMomentumController ../../utils/navigationUtils ../../../support/mathUtils ../../../webgl-engine/lib/Camera ../../../../navigation/PanPlanarMomentumEstimator ../../../../navigation/PanSphericalMomentumEstimator ../../../../navigation/RotationMomentumEstimator ../../../../navigation/ZoomMomentumEstimator".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P) {
        a.PinchAndPanController = function (L) {
          function N(I) {
            I = L.call(this, I) || this; I.view = null; I.smoothRotation = new k.ExponentialFalloff(.05); I.rotationAxis = f.create(); I.panningPlane = m.create(); I.smoothScaling = new k.ExponentialFalloff(.05); I.zoomCenterScreen = u.createScreenPointArray(); I.zoomMomentumEstimator = new P.ZoomMomentumEstimator; I.rotationMomentumEstimator = new K.RotationMomentumEstimator; I.panSphericalMomentumEstimator = new F.PanSphericalMomentumEstimator;
            I.panPlanarMomentumEstimator = new M.PanPlanarMomentumEstimator; I.adjustedSphere = e.create(); I.tmp3d = f.create(); I.tmpScreenPointArray = u.createScreenPointArray(); I.beginScreenPoint = u.createScreenPointArray(); I.beginScenePoint = f.create(); I.screenPickPoint = u.createScreenPointArray(); I.navMode = E.NavigationMode.Horizontal; I.tmpInteractionDirection = f.create(); I.constraintOptions = { selection: 15, interactionType: 0, interactionFactor: 0, interactionStartCamera: new J, interactionDirection: null, tiltMode: 0 }; return I
          }
          w._inheritsLoose(N, L); var G = N.prototype; G.begin = function (I) {
            if (this.active) {
              var O = this.view.navigation.momentumEnabled; this.zoomMomentumEstimator.enabled = O; this.rotationMomentumEstimator.enabled = O; this.panPlanarMomentumEstimator.enabled = O; this.panSphericalMomentumEstimator.enabled = O; this.beginHeading = -H.cyclicalPI.normalize(q.deg2rad(this.view.camera.heading)); this.beginRadius = I.radius; this.pointerCount = I.pointers.size; this.beginAngle = I.angle; this.smoothRotation.reset(); u.screenPointObjectToArray(I.center,
                this.screenPickPoint); b.copy(this.beginScreenPoint, this.screenPickPoint); O = t.getReferenceEllipsoid(this.view.spatialReference); var R = E.pickPointAndInitSphere(this.intersectionHelper, this.startCamera, this.screenPickPoint, !0, O); this.scenePickPoint = R.scenePickPoint; this.sphere = R.sphere; d.copy(this.beginScenePoint, this.scenePickPoint); this.navMode = E.decideNavigationMode(this.startCamera, this.screenPickPoint, R.hasGeometryIntersection, O); this.navMode === E.NavigationMode.Vertical && this.preparePlanarPanMode(I);
              this.constraintOptions.interactionStartCamera.copyFrom(this.startCamera)
            }
          }; G.preparePlanarPanMode = function (I) {
            var O = d.negate(this.tmp3d, this.startCamera.viewForward); m.fromPositionAndNormal(this.scenePickPoint, O, this.panningPlane); var R = u.createScreenPointArray(this.screenPickPoint[0], 0); O = f.create(); var S = d.length(this.startCamera.eye); this.adjustedSphere[3] = S < this.sphere[3] ? S - 100 : this.sphere[3]; E.sphereOrPlanePointFromScreenPoint(this.adjustedSphere, this.startCamera, R, O); R = u.createRenderScreenPointArray3();
            this.startCamera.projectToRenderScreen(O, R); this.screenPickPoint[1] = Math.min(this.screenPickPoint[1], .9 * R[1]); this.intersectionHelper.intersectScreen(this.screenPickPoint, this.scenePickPoint) && m.fromPositionAndNormal(this.scenePickPoint, m.normal(this.panningPlane), this.panningPlane); if (!g.disableContextNavigation()) {
              O = f.create(); R = f.create(); S = f.create(); d.subtract(O, this.scenePickPoint, this.currentCamera.eye); d.normalize(O, O); var Q = 5 * Math.max(Math.abs(this.view.camera.position.z), 50); const T = this.view._stage.renderView.getMinimalDepthForArea(null,
                this.screenPickPoint[0], this.screenPickPoint[1], this.view.state.camera, 80); Q = T ? Math.min(T, Q) : Q; d.copy(S, d.add(R, this.currentCamera.eye, d.scale(R, O, Q))); this.panningPlane[3] = -d.dot(this.panningPlane, S); this.startCamera.center = d.add(R, this.startCamera.eye, d.scale(R, this.startCamera.viewForward, Q))
            } I = u.screenPointObjectToArray(I.center, this.tmpScreenPointArray); E.intersectPlaneFromScreenPointAtEye(this.panningPlane, this.startCamera, I, this.beginScenePoint)
          }; G.update = function (I) {
            if (this.active) {
              this.currentCamera.copyFrom(this.startCamera);
              var O = 1 < I.pointers.size; this.navMode === E.NavigationMode.Horizontal ? (O && this.zoomSpherical(I), this.panningSpherical(I), O && this.rotateSpherical(I)) : (O && this.zoomPlanar(I), this.panningPlanar(I), O && this.rotatePlanar(I))
            }
          }; G.end = function (I) {
            I.pointers.size === this.pointerCount && this.update(I); this.finishController(); if (I = this.zoomMomentumEstimator.evaluateMomentum()) return this.navMode === E.NavigationMode.Horizontal ? new D.ZoomSphericalMomentumController({
              view: this.view, momentum: I, screenCenter: this.zoomCenterScreen,
              sceneCenter: this.beginScenePoint, radius: this.sphere[3]
            }) : new C.ZoomPlanarMomentumController({ view: this.view, momentum: I, zoomCenter: this.beginScenePoint }); if (I = this.rotationMomentumEstimator.evaluateMomentum()) return new B.RotationMomentumController({ view: this.view, momentum: I, center: this.sphere, axis: this.rotationAxis }); if (this.navMode === E.NavigationMode.Horizontal) { if (I = this.panSphericalMomentumEstimator.evaluateMomentum()) return new z.PanSphericalMomentumController({ view: this.view, momentum: I }) } else if (I =
              this.panPlanarMomentumEstimator.evaluateMomentum()) return new A.PanPlanarMomentumController({ view: this.view, momentum: I }); return null
          }; G.zoomSpherical = function (I) {
            const O = this.beginRadius / I.radius; this.smoothScaling.gain = .001875 * Math.min(Math.max(I.radius, 40), 120); this.smoothScaling.update(O); E.applyZoomOnSphere(this.sphere, this.currentCamera, this.smoothScaling.value); u.screenPointObjectToArray(I.center, this.zoomCenterScreen); this.zoomMomentumEstimator.add(this.smoothScaling.value, .001 * I.timestamp);
            this.constraintOptions.interactionType = 1; this.constraintOptions.interactionFactor = x.pixelDistanceToInteractionFactor(I.radius - this.beginRadius); x.applyAll(this.view, this.currentCamera, this.constraintOptions)
          }; G.panningSpherical = function (I) {
            const O = u.screenPointObjectToArray(I.center, this.tmpScreenPointArray); E.sphereOrPlanePointFromScreenPoint(this.sphere, this.currentCamera, O, this.tmp3d); E.preserveHeadingThreshold(this.beginScenePoint, d.dot(this.currentCamera.up, this.beginScenePoint), this.sphere[3],
              this.beginHeading, this.view.camera.tilt, this.startCamera) ? (E.applyPanSphericalPreserveHeading(this.sphere, this.currentCamera, this.beginScenePoint, this.tmp3d, this.beginHeading, this.view.camera.tilt, !1), this.panSphericalMomentumEstimator.addMomentumPreserveHeading(O, this.tmp3d, .001 * I.timestamp, this.startCamera, this.sphere, this.beginHeading, this.view.camera.tilt)) : (E.applyPanSphericalDirectRotation(this.sphere, this.currentCamera, this.beginScenePoint, this.tmp3d, this.view.camera.tilt, !1), this.panSphericalMomentumEstimator.addMomentumDirectRotation(O,
                this.tmp3d, .001 * I.timestamp, this.startCamera, this.sphere[3], this.view.camera.tilt)); this.constraintOptions.interactionType = 4; this.constraintOptions.interactionFactor = x.pixelDistanceToInteractionFactor(this.screenPickPoint, O); x.applyAll(this.view, this.currentCamera, this.constraintOptions)
          }; G.rotateSpherical = function (I) {
            d.normalize(this.rotationAxis, this.scenePickPoint); this.currentCamera.aboveGround || d.negate(this.rotationAxis, this.rotationAxis); var O = this.smoothRotation.value, R = E.normalizeRotationDelta(I.angle -
              O); O += R; this.smoothRotation.gain = .00125 * Math.min(Math.max(I.radius, 40), 120); this.smoothRotation.update(O); R = this.smoothRotation.value - this.beginAngle; this.rotationMomentumEstimator.add(R, .001 * I.timestamp); E.applyRotation(this.currentCamera, this.sphere, v.wrapAxisAngle(this.rotationAxis, R)); this.constraintOptions.interactionType = 2; this.constraintOptions.interactionFactor = x.pixelDistanceToInteractionFactor(I.radius * O); x.applyAll(this.view, this.currentCamera, this.constraintOptions)
          }; G.panningPlanar = function (I) {
            const O =
              u.screenPointObjectToArray(I.center, this.tmpScreenPointArray); E.intersectPlaneFromScreenPointAtEye(this.panningPlane, this.currentCamera, O, this.tmp3d) && (E.applyPanPlanar(this.currentCamera, this.beginScenePoint, this.tmp3d), this.panPlanarMomentumEstimator.add(O, this.tmp3d, .001 * I.timestamp), this.constraintOptions.interactionType = 4, this.constraintOptions.interactionFactor = x.pixelDistanceToInteractionFactor(this.beginScreenPoint, O), this.constraintOptions.interactionDirection = this.view.renderCoordsHelper.worldUpAtPosition(this.currentCamera.eye,
                this.tmpInteractionDirection), x.applyAll(this.view, this.currentCamera, this.constraintOptions), this.constraintOptions.interactionDirection = null)
          }; G.zoomPlanar = function (I) {
            const O = this.beginRadius / I.radius; this.smoothScaling.gain = .001875 * Math.min(Math.max(I.radius, 40), 120); this.smoothScaling.update(O); this.zoomMomentumEstimator.add(this.smoothScaling.value, .001 * I.timestamp); E.applyZoomToPoint(this.currentCamera, this.beginScenePoint, this.smoothScaling.value, this.view.state.constraints.minimumPoiDistance);
            this.constraintOptions.interactionType = 1; this.constraintOptions.interactionFactor = x.pixelDistanceToInteractionFactor(I.radius - this.beginRadius); x.applyAll(this.view, this.currentCamera, this.constraintOptions)
          }; G.rotatePlanar = function (I) {
            d.copy(this.rotationAxis, this.beginScenePoint); this.currentCamera.aboveGround || d.negate(this.rotationAxis, this.rotationAxis); var O = this.smoothRotation.value; let R = I.angle - O; R = E.normalizeRotationDelta(R); this.smoothRotation.gain = .00125 * Math.min(Math.max(I.radius, 40),
              120); this.smoothRotation.update(O + R); O = this.smoothRotation.value - this.beginAngle; this.rotationMomentumEstimator.add(O, .001 * I.timestamp); E.applyRotation(this.currentCamera, this.sphere, v.wrapAxisAngle(this.rotationAxis, O)); this.constraintOptions.interactionType = 2; this.constraintOptions.interactionFactor = x.pixelDistanceToInteractionFactor(I.radius * O); x.applyAll(this.view, this.currentCamera, this.constraintOptions)
          }; w._createClass(N, [{ key: "intersectionHelper", get: function () { return this.view.sceneIntersectionHelper } }]);
          return N
        }(r.InteractiveController); c.__decorate([y.property({ constructOnly: !0 })], a.PinchAndPanController.prototype, "view", void 0); a.PinchAndPanController = c.__decorate([h.subclass("esri.views.3d.state.controllers.global.PinchAndPanController")], a.PinchAndPanController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/input/util": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y) { this._gain = y } var u = q.prototype; u.reset =
            function (y) { this._value = y }; u.update = function (y) { this._value = void 0 === this._value ? y : this._gain * y + (1 - this._gain) * this._value }; w._createClass(q, [{ key: "gain", set: function (y) { this._gain = y } }, { key: "value", get: function () { return void 0 === this._value ? 0 : this._value } }]); return q
        }(); a.ExponentialFalloff = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/momentum/PanPlanarMomentumController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ./MomentumController".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
        a.PanPlanarMomentumController = function (f) { function t(v) { v = f.call(this, v) || this; v.interactionType = 4; v.tmpPan = h.create(); return v } w._inheritsLoose(t, f); t.prototype.momentumStep = function (v, m) { v = this.momentum.value(v); l.scale(this.tmpPan, this.momentum.direction, v); m.eye = l.subtract(d, m.eye, this.tmpPan); m.center = l.subtract(d, m.center, this.tmpPan); this.constraintOptions.interactionDirection = this.tmpPan }; return t }(b.MomentumController); c.__decorate([q.property({ constructOnly: !0 })],
          a.PanPlanarMomentumController.prototype, "momentum", void 0); a.PanPlanarMomentumController = c.__decorate([p.subclass("esri.views.3d.state.controllers.momentum.PanPlanarMomentumController")], a.PanPlanarMomentumController); const d = h.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/momentum/MomentumController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../ViewAnimation ../../../camera/constraintUtils ../AnimationController ../../../webgl-engine/lib/Camera".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        a.MomentumController = function (f) {
          function t(m) { m = f.call(this, m) || this; m.view = null; m.beginCamera = new d; m.elapsedTimeSec = 0; m.constraintOptions = { selection: 15, interactionType: 4, interactionFactor: 0, interactionStartCamera: new d, interactionDirection: null, tiltMode: 0 }; return m } w._inheritsLoose(t, f); var v = t.prototype; v.initialize = function () { this.constraintOptions.interactionType = this.interactionType; this.viewAnimation = new l }; v.onControllerStart = function (m) {
            this.beginCamera.copyFrom(m);
            this.constraintOptions.interactionStartCamera = this.beginCamera; f.prototype.onControllerStart.call(this, m)
          }; v.stepController = function (m, e) { e.copyViewFrom(this.beginCamera); this.elapsedTimeSec += m; this.momentumStep(this.elapsedTimeSec, e); h.applyAll(this.view, e, this.constraintOptions) }; w._createClass(t, [{ key: "steppingFinished", get: function () { return this.momentum.isFinished(this.elapsedTimeSec) } }]); return t
        }(b.AnimationController); c.__decorate([q.property({ constructOnly: !0 })], a.MomentumController.prototype,
          "view", void 0); a.MomentumController = c.__decorate([p.subclass("esri.views.3d.state.controllers.momentum.MomentumController")], a.MomentumController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/momentum/PanSphericalMomentumController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ./MomentumController ../../utils/navigationUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          const f = h.create(), t = h.create(); a.PanSphericalMomentumController = function (v) { function m(e) { e = v.call(this, e) || this; e.interactionType = 4; return e } w._inheritsLoose(m, v); m.prototype.momentumStep = function (e, g) { const x = this.momentum.value1(e); e = this.momentum.value2(e); l.copy(t, g.eye); l.normalize(t, t); l.cross(this.momentum.axis2, t, this.momentum.axis1); d.applyRotationWithTwoAxes(g, f, this.momentum.axis1, x, this.momentum.axis2, e) }; return m }(b.MomentumController); c.__decorate([q.property({ constructOnly: !0 })],
            a.PanSphericalMomentumController.prototype, "momentum", void 0); a.PanSphericalMomentumController = c.__decorate([p.subclass("esri.views.3d.state.controllers.momentum.PanSphericalMomentumController")], a.PanSphericalMomentumController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/momentum/RotationMomentumController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3f64 ../../../../../geometry/support/axisAngle ./MomentumController ../../utils/navigationUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        a.RotationMomentumController = function (f) { function t(v) { v = f.call(this, v) || this; v.interactionType = 2; return v } w._inheritsLoose(t, f); t.prototype.momentumStep = function (v, m) { v = this.momentum.value(v); d.applyRotation(m, this.center, h.wrapAxisAngle(this.axis, v)) }; w._createClass(t, [{ key: "center", set: function (v) { this._set("center", l.clone(v)) } }, { key: "axis", set: function (v) { this._set("axis", l.clone(v)) } }]); return t }(b.MomentumController); c.__decorate([q.property({ constructOnly: !0 })],
          a.RotationMomentumController.prototype, "momentum", void 0); c.__decorate([q.property({ constructOnly: !0 })], a.RotationMomentumController.prototype, "center", null); c.__decorate([q.property({ constructOnly: !0 })], a.RotationMomentumController.prototype, "axis", null); a.RotationMomentumController = c.__decorate([p.subclass("esri.views.3d.state.controllers.momentum.MomentumController")], a.RotationMomentumController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/momentum/ZoomPlanarMomentumController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ./MomentumController ../../utils/navigationUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        a.ZoomPlanarMomentumController = function (f) {
          function t(v) { v = f.call(this, v) || this; v.interactionType = 1; v.constraintOptions.interactionDirection = h.create(); return v } w._inheritsLoose(t, f); t.prototype.momentumStep = function (v, m) {
            l.copy(this.constraintOptions.interactionDirection, m.eye); v = this.momentum.valueDelta(0, v); d.applyZoomToPoint(m, this.zoomCenter, v, this.view.state.constraints.minimumPoiDistance); this.constraintOptions.interactionDirection = l.direction(this.constraintOptions.interactionDirection,
              m.eye, this.constraintOptions.interactionDirection)
          }; w._createClass(t, [{ key: "zoomCenter", set: function (v) { this._set("zoomCenter", h.clone(v)) } }]); return t
        }(b.MomentumController); c.__decorate([q.property({ constructOnly: !0 })], a.ZoomPlanarMomentumController.prototype, "momentum", void 0); c.__decorate([q.property({ constructOnly: !0 })], a.ZoomPlanarMomentumController.prototype, "zoomCenter", null); a.ZoomPlanarMomentumController = c.__decorate([p.subclass("esri.views.3d.state.controllers.momentum.ZoomPlanarMomentumController")],
          a.ZoomPlanarMomentumController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/controllers/momentum/ZoomSphericalMomentumController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/screenUtils ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3f64 ../../../../../geometry/support/axisAngle ../../../../../chunks/sphere ../../../camera/constraintUtils ./MomentumController ../../utils/navigationUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
        a.ZoomSphericalMomentumController = function (m) {
          function e(x) { x = m.call(this, x) || this; x.interactionType = 1; x.radius = 0; x.tmpSceneCenter = h.create(); x.tmpZoomAxisAngle = b.create(); x.sphere = d.create(); return x } w._inheritsLoose(e, m); var g = e.prototype; g.initialize = function () { this.sphere[3] = this.radius }; g.momentumStep = function (x, k) {
            x = this.momentum.valueDelta(0, x); v.applyZoomOnSphere(this.sphere, k, x); this.constraintOptions.interactionType = 1; f.applyAll(this.view, k, this.constraintOptions);
            v.sphereOrPlanePointFromScreenPoint(this.sphere, k, this.screenCenter, this.tmpSceneCenter); b.fromPoints(this.sceneCenter, this.tmpSceneCenter, this.tmpZoomAxisAngle); v.applyRotation(k, this.sphere, this.tmpZoomAxisAngle); this.constraintOptions.interactionType = 4
          }; w._createClass(e, [{ key: "screenCenter", set: function (x) { this._set("screenCenter", q.createScreenPointArray(x[0], x[1])) } }, { key: "sceneCenter", set: function (x) { this._set("sceneCenter", h.clone(x)) } }]); return e
        }(t.MomentumController); c.__decorate([u.property({ constructOnly: !0 })],
          a.ZoomSphericalMomentumController.prototype, "momentum", void 0); c.__decorate([u.property({ constructOnly: !0 })], a.ZoomSphericalMomentumController.prototype, "screenCenter", null); c.__decorate([u.property({ constructOnly: !0 })], a.ZoomSphericalMomentumController.prototype, "sceneCenter", null); c.__decorate([u.property({ constructOnly: !0 })], a.ZoomSphericalMomentumController.prototype, "radius", void 0); a.ZoomSphericalMomentumController = c.__decorate([l.subclass("esri.views.3d.state.controllers.momentum.ZoomSphericalMomentumController")],
            a.ZoomSphericalMomentumController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/navigation/PanPlanarMomentumEstimator": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/vec3 ../../chunks/vec3f64 ./FilteredFiniteDifference ./Momentum".split(" "), function (a, w, c, q, u, y) {
        let n = function (p) {
          function l(h, b, d, f, t) { h = p.call(this, h, b, d) || this; h.sceneVelocity = f; h.direction = t; return h } w._inheritsLoose(l, p); l.prototype.value = function (h) {
            return p.prototype.valueFromInitialVelocity.call(this,
              this.sceneVelocity, h)
          }; return l
        }(y.Momentum); y = function () {
          function p(h = 300, b = 12, d = .84) { this.minimumInitialVelocity = h; this.stopVelocity = b; this.friction = d; this.enabled = !0; this.time = new u.FilteredFiniteDifference(.6); this.screen = [new u.FilteredFiniteDifference(.4), new u.FilteredFiniteDifference(.4)]; this.scene = [new u.FilteredFiniteDifference(.6), new u.FilteredFiniteDifference(.6), new u.FilteredFiniteDifference(.6)]; this.tmpDirection = q.create() } var l = p.prototype; l.add = function (h, b, d) {
          !this.enabled || this.time.hasLastValue &&
            .015 > this.time.computeDelta(d) || (this.screen[0].update(h[0]), this.screen[1].update(h[1]), this.scene[0].update(b[0]), this.scene[1].update(b[1]), this.scene[2].update(b[2]), this.time.update(d))
          }; l.reset = function () { this.screen[0].reset(); this.screen[1].reset(); this.scene[0].reset(); this.scene[1].reset(); this.scene[2].reset(); this.time.reset() }; l.evaluateMomentum = function () {
            if (!this.enabled || !this.screen[0].hasFilteredDelta) return null; var h = this.screen[0].filteredDelta; const b = this.screen[1].filteredDelta;
            h = Math.sqrt(h * h + b * b) / this.time.filteredDelta; return Math.abs(h) < this.minimumInitialVelocity ? null : this.createMomentum(h, this.stopVelocity, this.friction)
          }; l.createMomentum = function (h, b, d) { c.set(this.tmpDirection, this.scene[0].filteredDelta, this.scene[1].filteredDelta, this.scene[2].filteredDelta); const f = c.length(this.tmpDirection); 0 < f && c.scale(this.tmpDirection, this.tmpDirection, 1 / f); return new n(h, b, d, f / this.time.filteredDelta, this.tmpDirection) }; return p
        }(); a.PanPlanarMomentum = n; a.PanPlanarMomentumEstimator =
          y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/FilteredFiniteDifference": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y) { this.gain = y } var u = q.prototype; u.update = function (y) { if (this.hasLastValue) { const n = this.computeDelta(y); this.updateDelta(n) } this.lastValue = y }; u.reset = function () { this.filteredDelta = this.lastValue = void 0 }; u.computeDelta = function (y) { return y - this.lastValue }; u.updateDelta = function (y) {
          this.filteredDelta =
            this.hasFilteredDelta ? (1 - this.gain) * this.filteredDelta + this.gain * y : y
          }; w._createClass(q, [{ key: "hasLastValue", get: function () { return void 0 !== this.lastValue } }, { key: "hasFilteredDelta", get: function () { return void 0 !== this.filteredDelta } }]); return q
        }(); a.FilteredFiniteDifference = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/Momentum": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y, n, p) {
          this._initialVelocity =
            y; this._stopVelocity = n; this._friction = p; this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction))
          } var u = q.prototype; u.isFinished = function (y) { return y > this.duration }; u.value = function (y) { return this.valueFromInitialVelocity(this._initialVelocity, y) }; u.valueDelta = function (y, n) { const p = this.value(y); return this.value(y + n) - p }; u.valueFromInitialVelocity = function (y, n) { n = Math.min(n, this.duration); const p = 1 - this.friction; return y * (p ** n - 1) / Math.log(p) };
          w._createClass(q, [{ key: "duration", get: function () { return this._duration } }, { key: "friction", get: function () { return this._friction } }]); return q
        }(); a.Momentum = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/PanSphericalMomentumEstimator": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/vec2f64 ../../chunks/vec3 ../../chunks/vec3f64 ../3d/state/utils/navigationUtils ./FilteredFiniteDifference ./FilteredValue ./Momentum".split(" "), function (a, w, c,
        q, u, y, n, p, l) {
          let h = function (b) { function d(t, v, m, e, g, x = 0, k) { t = b.call(this, t, v, m) || this; t.angularVelocity1 = e; t.axis1 = g; t.angularVelocity2 = x; t.axis2 = k; return t } w._inheritsLoose(d, b); var f = d.prototype; f.value1 = function (t) { return b.prototype.valueFromInitialVelocity.call(this, this.angularVelocity1, t) }; f.value2 = function (t) { return b.prototype.valueFromInitialVelocity.call(this, this.angularVelocity2, t) }; return d }(l.Momentum); l = function () {
            function b(f = 300, t = 12, v = .84) {
            this.minimumInitialVelocity = f; this.stopVelocity =
              t; this.friction = v; this.enabled = !0; this.tmpAxis1 = u.create(); this.tmpAxis2 = u.create(); this.tmpAngles = c.create(); this.time = new n.FilteredFiniteDifference(.3); this.screen = [new n.FilteredFiniteDifference(.4), new n.FilteredFiniteDifference(.4)]; this.angle1 = new p.FilteredValue(.6); this.angle2 = new p.FilteredValue(.6); this.axis1 = u.create(); this.axis2 = u.create(); this.lastScene = u.create()
            } var d = b.prototype; d.addMomentumDirectRotation = function (f, t, v, m, e, g) {
              if (this.enabled) {
                if (this.time.hasLastValue) {
                  if (.01 > this.time.computeDelta(v)) return;
                  m = y.rotationAngleAndAxisDirectRotation(this.lastScene, t, this.tmpAxis2, m, e, g); this.angle2.update(0); 1E-5 > q.squaredLength(this.tmpAxis2) ? m = 0 : q.normalize(this.axis1, this.tmpAxis2); this.angle1.update(m); q.copy(this.lastScene, t)
                } this.screen[0].update(f[0]); this.screen[1].update(f[1]); this.time.update(v)
              }
            }; d.addMomentumPreserveHeading = function (f, t, v, m, e, g, x) {
              if (this.enabled) {
                if (this.time.hasLastValue) {
                  if (.01 > this.time.computeDelta(v)) return; y.rotationAnglesAndAxesHeadingPreserving(this.lastScene, t, this.tmpAxis2,
                    this.tmpAxis1, this.tmpAngles, m, e, g, x, !1); 1E-5 > q.squaredLength(this.tmpAxis2) ? (this.angle1.update(0), this.angle2.update(0)) : (this.angle1.update(this.tmpAngles[1]), this.angle2.update(this.tmpAngles[0]), q.normalize(this.axis1, this.tmpAxis1), q.normalize(this.axis2, this.tmpAxis2)); q.copy(this.lastScene, t)
                } this.screen[0].update(f[0]); this.screen[1].update(f[1]); this.time.update(v)
              }
            }; d.reset = function () { this.screen[0].reset(); this.screen[1].reset(); this.angle1.reset(); this.angle2.reset(); this.time.reset() };
            d.evaluateMomentum = function () { if (!this.enabled || !this.screen[0].hasFilteredDelta) return null; var f = this.screen[0].filteredDelta; const t = this.screen[1].filteredDelta; f = Math.sqrt(f * f + t * t) / this.time.filteredDelta; return Math.abs(f) < this.minimumInitialVelocity ? null : this.createMomentum(f, this.stopVelocity, this.friction) }; d.createMomentum = function (f, t, v) { return new h(f, t, v, this.angle1.filteredValue / this.time.filteredDelta, this.axis1, this.angle2.filteredValue / this.time.filteredDelta, this.axis2) }; return b
          }();
        a.PanSphericalMomentum = h; a.PanSphericalMomentumEstimator = l; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/FilteredValue": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y) { this.gain = y } var u = q.prototype; u.update = function (y) { this.filteredValue = this.hasFilteredValue ? (1 - this.gain) * this.filteredValue + this.gain * y : y }; u.reset = function () { this.filteredValue = void 0 }; w._createClass(q, [{
            key: "hasFilteredValue", get: function () {
              return void 0 !==
                this.filteredValue
            }
          }]); return q
        }(); a.FilteredValue = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/RotationMomentumEstimator": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "./MomentumEstimator"], function (a, w, c) {
        c = function (q) {
          function u(y = 3, n = .01, p = .95, l = 12) { return q.call(this, y, n, p, l) || this } w._inheritsLoose(u, q); u.prototype.add = function (y, n) {
            if (this.value.hasLastValue) {
              const p = this.value.lastValue; for (y -= p; y > Math.PI;)y -= 2 * Math.PI; for (; y < -Math.PI;)y +=
                2 * Math.PI; y = p + y
            } q.prototype.add.call(this, y, n)
          }; return u
        }(c.MomentumEstimator); a.RotationMomentumEstimator = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/MomentumEstimator": function () {
      define(["exports", "../../core/mathUtils", "./FilteredFiniteDifference", "./Momentum"], function (a, w, c, q) {
        let u = function () {
          function y(p = 2.5, l = .01, h = .95, b = 12) {
          this.minimumInitialVelocity = p; this.stopVelocity = l; this.friction = h; this.maxVelocity = b; this.enabled = !0; this.value = new c.FilteredFiniteDifference(.8);
            this.time = new c.FilteredFiniteDifference(.3)
          } var n = y.prototype; n.add = function (p, l) { if (this.enabled) { if (this.time.hasLastValue) { if (.01 > this.time.computeDelta(l)) return; if (this.value.hasFilteredDelta) { const h = this.value.computeDelta(p); 0 > this.value.filteredDelta * h && this.value.reset() } } this.time.update(l); this.value.update(p) } }; n.reset = function () { this.value.reset(); this.time.reset() }; n.evaluateMomentum = function () {
            if (!this.enabled || !this.value.hasFilteredDelta) return null; let p = this.value.filteredDelta /
              this.time.filteredDelta; p = w.clamp(p, -this.maxVelocity, this.maxVelocity); return Math.abs(p) < this.minimumInitialVelocity ? null : this.createMomentum(p, this.stopVelocity, this.friction)
          }; n.createMomentum = function (p, l, h) { return new q.Momentum(p, l, h) }; return y
        }(); a.MomentumEstimator = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/navigation/ZoomMomentumEstimator": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "./Momentum", "./MomentumEstimator"], function (a, w, c, q) {
        let u =
          function (y) { function n(l, h, b) { return y.call(this, l, h, b) || this } w._inheritsLoose(n, y); var p = n.prototype; p.value = function (l) { l = y.prototype.value.call(this, l); return Math.exp(l) }; p.valueDelta = function (l, h) { const b = y.prototype.value.call(this, l); l = y.prototype.value.call(this, l + h); return Math.exp(l - b) }; return n }(c.Momentum); c = function (y) {
            function n(l = 2.5, h = .01, b = .95, d = 12) { return y.call(this, l, h, b, d) || this } w._inheritsLoose(n, y); var p = n.prototype; p.add = function (l, h) {
              y.prototype.add.call(this, Math.log(l),
                h)
            }; p.createMomentum = function (l, h, b) { return new u(l, h, b) }; return n
          }(q.MomentumEstimator); a.ZoomMomentum = u; a.ZoomMomentumEstimator = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/local/PinchAndPanController": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/mathUtils ../../../../../core/screenUtils ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/axisAngle ../../../../../geometry/support/plane ../../../../../support/featureFlags ../../../camera/constraintUtils ../../../input/util ../InteractiveController ../momentum/PanPlanarMomentumController ../momentum/RotationMomentumController ../momentum/ZoomPlanarMomentumController ../../utils/navigationUtils ../../../webgl-engine/lib/Camera ../../../../navigation/PanPlanarMomentumEstimator ../../../../navigation/RotationMomentumEstimator ../../../../navigation/ZoomMomentumEstimator".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D) {
          const E = d.fromValues(0, 0, 1); var H = 16 / 180 * Math.PI; a.PinchAndPanController = function (J) {
            function M(K) {
              K = J.call(this, K) || this; K.view = null; K.rotationValueSmooth = new e.ExponentialFalloff(.05); K.scalingValueSmooth = new e.ExponentialFalloff(.05); K.planeHorizontal = t.create(); K.planeVertical = t.create(); K.rotationMomentumEstimator = new C.RotationMomentumEstimator; K.panMomentumEstimator = new B.PanPlanarMomentumEstimator(300, 12, .9); K.zoomMomentumEstimator =
                new D.ZoomMomentumEstimator; K.beginCenter = d.create(); K.tmpPoints = []; K.beginCenterScreen = u.createScreenPointArray(); K.tmpCentroid3d = d.create(); K.tmpCentroid2d = u.createScreenPointArray(); K.tmp2d = u.createScreenPointArray(); K.constraintOptions = { selection: 15, interactionType: 0, interactionFactor: 0, interactionStartCamera: new z, interactionDirection: null, tiltMode: 0 }; return K
            } w._inheritsLoose(M, J); var F = M.prototype; F.begin = function (K) {
              if (this.active) {
                var P = this.view.navigation.momentumEnabled; this.zoomMomentumEstimator.enabled =
                  P; this.rotationMomentumEstimator.enabled = P; this.panMomentumEstimator.enabled = P; this.beginRadius = K.radius; this.pointerCount = K.pointers.size; this.beginAngle = K.angle; this.rotationValueSmooth.reset(); this.scalingValueSmooth.reset(); u.screenPointObjectToArray(K.center, this.beginCenterScreen); t.fromNormalAndOffset(E, 0, this.planeHorizontal); P = d.create(); this.intersectionHelper.intersectScreenFreePointFallback(this.beginCenterScreen, P); var L = d.create(); b.negate(L, this.startCamera.viewForward); var N = d.create();
                b.copy(N, E); var G = b.dot(L, N); this.panMode = q.asinClamped(0 > G ? -G : G) >= H ? A.NavigationMode.Horizontal : A.NavigationMode.Vertical; t.setOffsetFromPoint(this.planeHorizontal, P, this.planeHorizontal); this.startCamera.aboveGround || t.negate(this.planeHorizontal, this.planeHorizontal); if (this.panMode === A.NavigationMode.Vertical) {
                  b.scale(N, N, G); b.subtract(this.planeVertical, L, N); b.normalize(this.planeVertical, this.planeVertical); t.setOffsetFromPoint(this.planeVertical, P, this.planeVertical); if (!v.disableContextNavigation()) {
                    L =
                    d.create(); N = d.create(); G = d.create(); b.subtract(L, P, this.currentCamera.eye); b.normalize(L, L); P = 5 * Math.max(Math.abs(this.view.camera.position.z), 50); const I = this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(), this.beginCenterScreen[0], this.beginCenterScreen[1], this.view.state.camera, 80); b.copy(G, b.add(N, this.currentCamera.eye, b.scale(N, L, I ? Math.min(I, P) : P))); this.planeVertical[3] = -b.dot(this.planeVertical, G)
                  } this.computePlanePoints(K.pointers, this.planeVertical,
                    this.startCamera, this.tmpPoints)
                } else this.computePlanePoints(K.pointers, this.planeHorizontal, this.startCamera, this.tmpPoints); A.centroid(this.tmpPoints, this.beginCenter); this.constraintOptions.interactionStartCamera.copyFrom(this.startCamera)
              }
            }; F.update = function (K) {
              if (this.active) {
                this.currentCamera.copyFrom(this.startCamera); var P = 1 < K.pointers.size, L = this.panMode === A.NavigationMode.Horizontal ? this.planeHorizontal : this.planeVertical, N = this.beginCenter; if (P) {
                  var G = this.beginRadius / K.radius; this.scalingValueSmooth.gain =
                    .001875 * Math.min(Math.max(K.radius, 40), 120); this.scalingValueSmooth.update(G); A.applyZoomToPoint(this.currentCamera, N, this.scalingValueSmooth.value, this.view.state.constraints.minimumPoiDistance); this.zoomMomentumEstimator.add(this.scalingValueSmooth.value, .001 * K.timestamp); this.constraintOptions.interactionType = 1; this.constraintOptions.interactionFactor = m.pixelDistanceToInteractionFactor(Math.abs(K.radius - this.beginRadius)); m.applyAll(this.view, this.currentCamera, this.constraintOptions)
                } this.computePlanePoints(K.pointers,
                  L, this.currentCamera, this.tmpPoints); A.centroid(this.tmpPoints, this.tmpCentroid3d); u.screenPointObjectToArray(K.center, this.tmpCentroid2d); A.applyPanPlanar(this.currentCamera, N, this.tmpCentroid3d); this.panMomentumEstimator.add(this.tmpCentroid2d, this.tmpCentroid3d, .001 * K.timestamp); this.constraintOptions.interactionType = 4; this.constraintOptions.interactionFactor = m.pixelDistanceToInteractionFactor(this.beginCenterScreen, this.tmpCentroid2d); m.applyAll(this.view, this.currentCamera, this.constraintOptions);
                P && (P = this.planeHorizontal, L = this.rotationValueSmooth.value, G = A.normalizeRotationDelta(K.angle - L), L += G, this.rotationValueSmooth.gain = .00125 * Math.min(Math.max(K.radius, 40), 120), this.rotationValueSmooth.update(L), L = this.rotationValueSmooth.value - this.beginAngle, this.rotationMomentumEstimator.add(L, .001 * K.timestamp), A.applyRotation(this.currentCamera, N, f.wrapAxisAngle(P, L)), this.constraintOptions.interactionType = 2, this.constraintOptions.interactionFactor = m.pixelDistanceToInteractionFactor(Math.abs(K.radius *
                  L)), m.applyAll(this.view, this.currentCamera, this.constraintOptions))
              }
            }; F.end = function (K) {
              K.pointers.size === this.pointerCount && this.update(K); this.finishController(); return (K = this.zoomMomentumEstimator.evaluateMomentum()) ? new r.ZoomPlanarMomentumController({ view: this.view, momentum: K, zoomCenter: this.beginCenter }) : (K = this.rotationMomentumEstimator.evaluateMomentum()) ? new k.RotationMomentumController({ view: this.view, momentum: K, center: this.beginCenter, axis: t.normal(this.planeHorizontal) }) : (K = this.panMomentumEstimator.evaluateMomentum()) ?
                new x.PanPlanarMomentumController({ view: this.view, momentum: K }) : null
            }; F.computePlanePoints = function (K, P, L, N) { N.length = K.size; const G = this.tmp2d; let I = 0; K.forEach(O => { G[0] = O.x; G[1] = O.y; void 0 === N[I] && (N[I] = d.create()); A.intersectPlaneFromScreenPointAtEye(P, L, G, N[I]); I += 1 }); return N }; w._createClass(M, [{ key: "intersectionHelper", get: function () { return this.view.sceneIntersectionHelper } }]); return M
          }(g.InteractiveController); c.__decorate([y.property({ constructOnly: !0 })], a.PinchAndPanController.prototype,
            "view", void 0); a.PinchAndPanController = c.__decorate([h.subclass("esri.views.3d.state.controllers.local.PinchAndPanController")], a.PinchAndPanController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/input/handlers/PointerDownCancelAnimation": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../input/InputHandler"], function (a, w, c) {
        c = function (q) {
          function u(y, n) {
            var p = q.call(this, !0) || this; p.view = y; p.registerIncoming("pointer-down", n, () => p.view.state.stopActiveCameraController());
            return p
          } w._inheritsLoose(u, q); return u
        }(c.InputHandler); a.PointerDownCancelAnimation = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/input/handlers/SingleKeyResetHeading": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "./SingleKey"], function (a, w, c) {
        c = function (q) { function u(y, n, p) { n = q.call(this, n, p) || this; n.view = y; return n } w._inheritsLoose(u, q); u.prototype.activate = function () { this.view.goTo({ heading: 0 }).catch(() => { }) }; return u }(c.SingleKey); a.SingleKeyResetHeading =
          c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/input/handlers/SingleKey": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../input/InputHandler"], function (a, w, c) {
        c = function (q) { function u(y, n) { var p = q.call(this, !0) || this; p.key = y; p.registerIncoming("key-down", n, l => p._handleKeyDown(l)); return p } w._inheritsLoose(u, q); u.prototype._handleKeyDown = function (y) { y.data.key === this.key && (this.activate(), y.stopPropagation()) }; return u }(c.InputHandler); a.SingleKey =
          c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/input/handlers/SingleKeyResetTilt": function () { define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "./SingleKey"], function (a, w, c) { c = function (q) { function u(y, n, p) { n = q.call(this, n, p) || this; n.view = y; return n } w._inheritsLoose(u, q); u.prototype.activate = function () { this.view.goTo({ tilt: 0 }).catch(() => { }) }; return u }(c.SingleKey); a.SingleKeyResetTilt = c; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/input/handlers/TwoFingerTilt": function () {
      define(["exports",
        "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/screenUtils", "../../state/controllers/RotateController", "../../../input/InputHandler"], function (a, w, c, q, u) {
          u = function (y) {
            function n(p, l = !1) { var h = y.call(this, !0) || this; h.view = p; h.invert = l; h.registerIncoming("vertical-two-finger-drag", b => h.handleTwoFinger(b)); return h } w._inheritsLoose(n, y); n.prototype.handleTwoFinger = function (p) {
              var l, h, b; const d = c.createScreenPointArray(0, p.data.delta * (this.invert ? -1 : 1)); switch (p.data.action) {
                case "begin": null ==
                  (l = this.cameraController) ? void 0 : l.end(); this.cameraController = new q.RotateController({ view: this.view, pivot: 0 }); this.view.state.switchCameraController(this.cameraController); this.cameraController.begin(d); break; case "update": null == (h = this.cameraController) ? void 0 : h.update(d); break; case "end": null == (b = this.cameraController) ? void 0 : b.end(), this.cameraController = null
              }
            }; return n
          }(u.InputHandler); a.TwoFingerTilt = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/input/BrowserEventSource": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ./keys ./gamepad/GamepadSource ../support/screenUtils".split(" "),
        function (a, w, c, q, u, y) {
          const n = c("trident"), p = c("edge"), l = c("chrome"), h = c("ff"), b = c("safari"); c = function () {
            function f(v, m) {
            this.input = m; this._active = {}; this._activePointerCaptures = new Set; this._keyDownState = new Set; this._eventId = 1; this._browserTouchPanningEnabled = !1; this._element = v; v.getAttribute("tabindex") || v.setAttribute("tabindex", "0"); this._eventHandlers = {
              "key-down": this._handleKey, "key-up": this._handleKey, "pointer-down": this._handlePointer, "pointer-move": this._handlePointerPreventDefault, "pointer-up": this._handlePointerPreventDefault,
              "pointer-enter": this._handlePointer, "pointer-leave": this._handlePointer, "pointer-cancel": this._handlePointer, "mouse-wheel": this._handleMouseWheel, "pointer-capture-lost": this._handlePointerCaptureLost
            }; this._updateTouchAction(); this._element.addEventListener("keydown", this._preventAltKeyDefault); this._gamepadSource = new u.GamepadSource(v, this.input); this._gamepadSource.onEvent = e => this._callback("gamepad", e)
            } var t = f.prototype; t.destroy = function () {
            this.activeEvents = this._callback = null; this._activePointerCaptures.forEach(v => { this._releasePointerCaptureSafe(v) }); this._gamepadSource && (this._gamepadSource.destroy(), this._gamepadSource = null); this._activePointerCaptures = null; this._removeTouchAction(); this._element.removeEventListener("keydown", this._preventAltKeyDefault)
            }; t.setPointerCapture = function (v, m) { m ? (this._element.setPointerCapture(v.pointerId), this._activePointerCaptures.add(v.pointerId)) : (this._releasePointerCaptureSafe(v.pointerId), this._activePointerCaptures.delete(v.pointerId)) }; t._updateTouchAction = function () {
              this._element.classList.remove(this._browserTouchPanningEnabled ?
                "esri-view-surface--touch-none" : "esri-view-surface--touch-pan"); this._element.classList.add(this._browserTouchPanningEnabled ? "esri-view-surface--touch-pan" : "esri-view-surface--touch-none")
            }; t._updateTouchEventHandling = function () { this._browserTouchPanningEnabled ? this._element.addEventListener("touchmove", this._preventMultiTouchPanning) : this._element.removeEventListener("touchmove", this._preventMultiTouchPanning) }; t._removeTouchAction = function () {
              this._element.classList.remove("esri-view-surface--touch-none");
              this._element.classList.remove("esri-view-surface--touch-pan"); this._element.removeEventListener("touchmove", this._preventMultiTouchPanning)
            }; t._releasePointerCaptureSafe = function (v) { try { this._element.hasPointerCapture && !this._element.hasPointerCapture(v) || this._element.releasePointerCapture(v) } catch (m) { } }; t._updateNormalizedPointerLikeEvent = function (v, m) {
              v = y.createScreenPointFromNativeEvent(this._element, v); f.test.disableSubpixelCoordinates && (v.x = Math.round(v.x), v.y = Math.round(v.y)); m.x = v.x; m.y =
                v.y; return m
            }; t._handleKey = function (v, m) { const e = q.eventKey(m); e && "key-up" === v && this._keyDownState.delete(e); m = { native: m, key: e, repeat: e && this._keyDownState.has(e) }; e && "key-down" === v && this._keyDownState.add(m.key); this._callback(v, m) }; t._handlePointer = function (v, m) { m = this._updateNormalizedPointerLikeEvent(m, { native: m, x: 0, y: 0, pointerType: m.pointerType, button: m.button, buttons: m.buttons, eventId: this._eventId++ }); this._callback(v, m) }; t._handlePointerPreventDefault = function (v, m) {
              const e = this._updateNormalizedPointerLikeEvent(m,
                { native: m, x: 0, y: 0, pointerType: m.pointerType, button: m.button, buttons: m.buttons, eventId: this._eventId++ }); m.preventDefault(); this._callback(v, e)
            }; t._handleMouseWheel = function (v, m) {
              let e = m.deltaY; switch (m.deltaMode) { case 0: if (n || p) e = e / document.documentElement.clientHeight * 600; break; case 1: e *= 30; break; case 2: e *= 900 }n || p ? e *= .7 : l || b ? e *= .6 : h && (e *= 1.375); const g = Math.abs(e); 100 < g && (e = e / g * 200 / (1 + Math.exp(-.02 * (g - 100)))); m = this._updateNormalizedPointerLikeEvent(m, { native: m, x: 0, y: 0, deltaY: e }); this._callback(v,
                m)
            }; t._handlePointerCaptureLost = function (v, m) { this._activePointerCaptures.delete(m.pointerId); this._handleDefault(v, m) }; t._handleDefault = function (v, m) { const e = { native: m }; m.preventDefault(); this._callback(v, e) }; t._preventAltKeyDefault = function (v) { "Alt" === v.key && v.preventDefault() }; t._preventMultiTouchPanning = function (v) { 1 < v.touches.length && v.preventDefault() }; w._createClass(f, [{
              key: "browserTouchPanningEnabled", get: function () { return this._browserTouchPanningEnabled }, set: function (v) {
              this._browserTouchPanningEnabled =
                v; this._updateTouchAction(); this._updateTouchEventHandling()
              }
            }, { key: "onEventReceived", set: function (v) { this._callback = v } }, { key: "activeEvents", set: function (v) { for (const m in this._active) v && v.has(m) || (this._element.removeEventListener(d[m], this._active[m]), delete this._active[m]); v && v.forEach(m => { if (!this._active[m] && d[m]) { const e = (this._eventHandlers[m] || this._handleDefault).bind(this, m); this._element.addEventListener(d[m], e); this._active[m] = e } }); this._gamepadSource.hasEventListeners = v && v.has("gamepad") } }]);
            return f
          }(); c.test = { disableSubpixelCoordinates: !1 }; const d = { "key-down": "keydown", "key-up": "keyup", "pointer-down": "pointerdown", "pointer-up": "pointerup", "pointer-move": "pointermove", "mouse-wheel": "wheel", "pointer-capture-got": "gotpointercapture", "pointer-capture-lost": "lostpointercapture", "context-menu": "contextmenu", "pointer-enter": "pointerenter", "pointer-leave": "pointerleave", "pointer-cancel": "pointercancel", focus: "focus", blur: "blur" }; a.BrowserEventSource = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/input/gamepad/GamepadSource": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/scheduling", "./GamepadInputDevice", "./GamepadState"], function (a, w, c, q, u) {
        let y = function () {
          function n(l, h) {
          this.element = l; this.input = h; this._hasEventListeners = !1; this.onConnectGamepad = b => { this.connectGamepad(b.gamepad) }; this.onDisconnectGamepad = b => {
            b = b.gamepad; const d = b.index, f = this.inputDevices[d]; f && (this.emitGamepadEvent(b, u.extractState(f), !1), this.inputDevices.splice(d,
              1), this.latestUpdate.splice(d, 1), this.input.gamepad.devices.remove(f), this.ensurePollingState())
          }; this.frameTask = null; this.latestUpdate = []; this.inputDevices = []; this.callback = null; l = window.isSecureContext; if (this.supported = "getGamepads" in window.navigator && l) this.forEachGamepad(b => this.connectGamepad(b)), window.addEventListener("gamepadconnected", this.onConnectGamepad), window.addEventListener("gamepaddisconnected", this.onDisconnectGamepad), this.ensurePollingState()
          } var p = n.prototype; p.destroy = function () {
          this.hasEventListeners =
            !1; this.supported && (window.removeEventListener("gamepadconnected", this.onConnectGamepad), window.removeEventListener("gamepaddisconnected", this.onDisconnectGamepad))
          }; p.connectGamepad = function (l) { const h = new q(l); "unknown" !== h.deviceType && (this.inputDevices[l.index] = h, this.input.gamepad.devices.add(h)); this.ensurePollingState() }; p.ensurePollingState = function () { this.eventsEnabled ? this.startPolling() : this.stopPolling() }; p.startPolling = function () {
          null == this.frameTask && (this.frameTask = c.addFrameTask({
            update: () =>
              this.readGamepadState()
          }))
          }; p.stopPolling = function () { null != this.frameTask && (this.frameTask.remove(), this.frameTask = null, this.latestUpdate = []) }; p.readGamepadState = function () {
            const l = document.hasFocus(), h = this.element.contains(document.activeElement), b = "document" === this.input.gamepad.enabledFocusMode && !l || "view" === this.input.gamepad.enabledFocusMode && !h; this.forEachGamepad(d => {
              var f = this.inputDevices[d.index]; if (f) {
                var t = this.latestUpdate[d.index]; f = u.extractState(f); var v = b || u.stateIdle(f); t && (t.timestamp ===
                  d.timestamp || !t.active && v || u.stateEqual(t.state, f)) || this.emitGamepadEvent(d, f, !v)
              }
            })
          }; p.forEachGamepad = function (l) { const h = window.navigator.getGamepads(); for (let b = 0; b < h.length; b++) { const d = h[b]; this.validate(d) && l(d) } }; p.emitGamepadEvent = function (l, h, b) { var d = this.latestUpdate[l.index]; if ((d = d && d.active) || b) this.latestUpdate[l.index] = { timestamp: l.timestamp, state: h, active: b }, this.callback && this.callback({ device: this.inputDevices[l.index], state: h, action: !d && b ? "start" : d && b ? "update" : "end" }) }; p.validate =
            function (l) { if (!l || !l.connected) return !1; for (let h = 0; h < l.axes.length; h++)if (isNaN(l.axes[h])) return !1; return !0 }; w._createClass(n, [{ key: "hasEventListeners", set: function (l) { this._hasEventListeners !== l && (this._hasEventListeners = l, this.ensurePollingState()) } }, { key: "eventsEnabled", get: function () { return this.supported && 0 < this.inputDevices.length && this._hasEventListeners } }, { key: "onEvent", set: function (l) { this.callback = l } }]); return n
        }(); a.GamepadSource = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    },
    "esri/views/input/gamepad/GamepadState": function () {
      define(["exports"], function (a) {
      a.extractState = function (w) { const c = w.native; return c ? { buttons: c.buttons.map(q => q.pressed ? q.value ? q.value : 1 : 0), axes: c.axes.map(q => { { var u = w.axisThreshold; const y = Math.abs(q); q = y < u ? 0 : Math.sign(q) * (y - u) / (1 - u) } return q }) } : { buttons: [], axes: [] } }; a.stateEqual = function (w, c) {
        if (w.axes.length !== c.axes.length || w.buttons.length !== c.buttons.length) return !1; for (var q = 0; q < w.axes.length; q++)if (w.axes[q] !== c.axes[q]) return !1; for (q = 0; q <
          w.buttons.length; q++)if (w.buttons[q] !== c.buttons[q]) return !1; return !0
      }; a.stateIdle = function (w) { for (var c = 0; c < w.axes.length; c++)if (0 !== w.axes[c]) return !1; for (c = 0; c < w.buttons.length; c++)if (0 !== w.buttons[c]) return !1; return !0 }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/handlers/PreventContextMenu": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../InputHandler"], function (a, w, c) {
        c = function (q) {
          function u() {
            var y = q.call(this, !0) || this; y.registerIncoming("context-menu",
              n => { n.data.native.preventDefault() }); return y
          } w._inheritsLoose(u, q); return u
        }(c.InputHandler); a.PreventContextMenu = c; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/recognizers/Drag": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/screenUtils ../../../core/time ../InputHandler ./support".split(" "), function (a, w, c, q, u, y) {
        function n(b) { const d = []; b.forEach(f => { d.push(c.createScreenPoint(f.event.x, f.event.y)) }); return y.fitCircleLSQ(d) }
        function p(b) { const d = n(b); let f = 0; b.forEach(t => { var v = h(t, d); for (v -= t.lastAngle; v > Math.PI;)v -= 2 * Math.PI; for (; v < -Math.PI;)v += 2 * Math.PI; v = t.lastAngle + v; t.lastAngle = v; f += v - t.initialAngle }); f /= b.size || 1; return { angle: f, radius: d.radius, center: d.center } } function l(b) { const d = new Map; b.forEach((f, t) => d.set(t, f.event)); return d } function h(b, d) { b = b.event; return Math.atan2(b.y - d.center.y, b.x - d.center.x) } u = function (b) {
          function d(t) {
            var v = b.call(this, !1) || this; v.navigationTouch = t; v.startStateModifiers = new Set;
            v.activePointerMap = new Map; v.isDragging = !1; v.isCurrentDragSuppressed = !1; v.drag = v.registerOutgoing("drag"); v.registerIncoming("pointer-drag", v.handlePointerDrag.bind(w._assertThisInitialized(v))); v.registerIncoming("pointer-up", v.handlePointerUpAndPointerLost.bind(w._assertThisInitialized(v))); v.registerIncoming("pointer-capture-lost", v.handlePointerUpAndPointerLost.bind(w._assertThisInitialized(v))); v.registerIncoming("pointer-cancel", v.handlePointerUpAndPointerLost.bind(w._assertThisInitialized(v)));
            return v
          } w._inheritsLoose(d, b); var f = d.prototype; f.createPayload = function (t, v, m, e) { return { action: t, pointerType: this.pointerType, button: this.mouseButton, buttons: v.buttons, timestamp: e, pointers: l(this.activePointerMap), pointer: v, angle: m.angle, radius: m.radius, center: m.center } }; f.addPointer = function (t) { var v = t.native.pointerId; const m = p(this.activePointerMap).angle; t = { event: t, initialAngle: 0, lastAngle: 0 }; this.activePointerMap.set(v, t); v = h(t, n(this.activePointerMap)); t.initialAngle = v; t.lastAngle = v; this.updatePointerAngles(m) };
          f.updatePointer = function (t) { if (!t || null != t.x || null != t.y) { var v = this.activePointerMap.get(t.native.pointerId); v ? v.event = t : this.addPointer(t) } }; f.removePointer = function (t) { const v = p(this.activePointerMap).angle; this.activePointerMap.delete(t); this.updatePointerAngles(v) }; f.updatePointerAngles = function (t) { const v = p(this.activePointerMap); this.activePointerMap.forEach(m => { m.initialAngle = h(m, v) - t; m.lastAngle = h(m, v) - t }) }; f.emitEvent = function (t, v, m) {
            const e = p(this.activePointerMap); this.drag.emit(this.createPayload(t,
              v, e, m), void 0, this.startStateModifiers)
          }; f.handlePointerUpAndPointerLost = function (t) { const v = t.data.native.pointerId, m = q.Milliseconds(t.timestamp); this.activePointerMap.get(v) && (1 === this.activePointerMap.size ? (this.updatePointer(t.data), !this.isCurrentDragSuppressed && this.emitEvent("end", t.data, m), this.isCurrentDragSuppressed = this.isDragging = !1, this.removePointer(v)) : (this.removePointer(v), this.emitEvent("removed", t.data, q.Milliseconds(t.timestamp)))) }; f.handlePointerDrag = function (t) {
            const v = t.data,
            m = v.currentEvent, e = q.Milliseconds(t.timestamp); switch (v.action) {
              case "start": case "update": this.isDragging ? this.activePointerMap.has(m.native.pointerId) ? (this.updatePointer(m), !this.isCurrentDragSuppressed && this.emitEvent("update", m, e)) : (this.addPointer(m), this.emitEvent("added", m, e), this.isCurrentDragSuppressed = this.isSuppressed) : (this.updatePointer(m), this.pointerType = t.data.startEvent.pointerType, this.mouseButton = t.data.startEvent.button, this.startStateModifiers = t.modifiers, this.isDragging = !0,
                this.isCurrentDragSuppressed = this.isSuppressed, !this.isCurrentDragSuppressed && this.emitEvent("start", m, e))
            }
          }; w._createClass(d, [{ key: "isSuppressed", get: function () { return this.navigationTouch && !this.navigationTouch.browserTouchPanEnabled && "touch" === this.pointerType && 1 === this.activePointerMap.size } }]); return d
        }(u.InputHandler); a.Button = void 0; (function (b) { b[b.Left = 0] = "Left"; b[b.Middle = 1] = "Middle"; b[b.Right = 2] = "Right"; b[b.Back = 3] = "Back"; b[b.Forward = 4] = "Forward"; b[b.Undefined = -1] = "Undefined" })(a.Button ||
          (a.Button = {})); a.Drag = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/recognizers/support": function () {
      define(["exports", "../../../core/screenUtils"], function (a, w) {
      a.euclideanDistance = function (c, q) { const u = q.x - c.x; c = q.y - c.y; return Math.sqrt(u * u + c * c) }; a.fitCircleLSQ = function (c, q) {
        q ? (q.radius = 0, q.center.x = 0, q.center.y = 0) : q = { radius: 0, center: w.createScreenPoint() }; if (0 === c.length) return q; if (1 === c.length) return q.center.x = c[0].x, q.center.y = c[0].y, q; if (2 === c.length) {
          const [m, e] =
            c, [g, x] = [e.x - m.x, e.y - m.y]; q.radius = Math.sqrt(g * g + x * x) / 2; q.center.x = (m.x + e.x) / 2; q.center.y = (m.y + e.y) / 2; return q
        } let u = 0, y = 0; for (q = 0; q < c.length; q++)u += c[q].x, y += c[q].y; u /= c.length; y /= c.length; var n = c.map(m => m.x - u), p = c.map(m => m.y - y); let l = q = 0; var h = 0, b = 0, d = 0, f = 0, t = 0; for (var v = 0; v < n.length; v++) { const m = n[v], e = p[v], g = m * m, x = e * e; q += g; l += x; h += m * e; b += g * m; d += x * e; f += m * x; t += e * g } n = q; p = h; v = l; b = .5 * (b + f); d = .5 * (d + t); t = n * v - h * p; f = (b * v - d * p) / t; d = (n * d - h * b) / t; t = w.createScreenPoint(f + u, d + y); return {
          radius: Math.sqrt(f * f + d *
            d + (q + l) / c.length), center: t
        }
      }; a.manhattanDistance = function (c, q) { return Math.abs(q.x - c.x) + Math.abs(q.y - c.y) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/recognizers/ImmediateDoubleClick": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/clock ../InputHandler ./SingleAndDoubleClick ./support".split(" "), function (a, w, c, q, u, y) {
        q = function (n) {
          function p(h = u.DefaultParameters.maximumDoubleClickDelay, b = u.DefaultParameters.maximumDoubleClickDistance,
            d = u.DefaultParameters.maximumDoubleTouchDelay, f = u.DefaultParameters.maximumDoubleTouchDistance, t = c.default) {
              var v = n.call(this, !1) || this; v.maximumDoubleClickDelay = h; v.maximumDoubleClickDistance = b; v.maximumDoubleTouchDelay = d; v.maximumDoubleTouchDistance = f; v._clock = t; v._pointerState = new Map; v._immediateDoubleClick = v.registerOutgoing("immediate-double-click"); v.registerIncoming("pointer-down", v._handlePointerDown.bind(w._assertThisInitialized(v))); v.registerIncoming("pointer-up", m => {
                v._handlePointerLoss(m,
                  "pointer-up")
              }); v.registerIncoming("pointer-capture-lost", m => { v._handlePointerLoss(m, "pointer-capture-lost") }); v.registerIncoming("pointer-cancel", m => { v._handlePointerLoss(m, "pointer-cancel") }); return v
          } w._inheritsLoose(p, n); var l = p.prototype; l.onUninstall = function () { this._pointerState.forEach(h => { h.immediateDoubleClick && h.immediateDoubleClick.timeoutHandle.remove() }); n.prototype.onUninstall.call(this) }; l._handlePointerDown = function (h) {
            h = h.data; const b = this._pointerId(h); this._pointerState.has(b) ||
              (this._pointerState.set(b, { downButton: h.native.button, immediateDoubleClick: null }), this.startCapturingPointer(h.native))
          }; l._handlePointerLoss = function (h, b) {
            const d = h.data; var f = this._pointerId(d); if ((f = this._pointerState.get(f)) && "pointer-up" === b && f.downButton === d.native.button) if (b = f.immediateDoubleClick) {
              b.timeoutHandle.remove(); const t = "touch" === h.data.native.pointerType ? this.maximumDoubleTouchDistance : this.maximumDoubleClickDistance; y.manhattanDistance(b, h.data) > t ? this._startImmediateDoubleClick(h,
                f) : (this._immediateDoubleClick.emit(h.data, void 0, b.modifiers), this._removeState(d))
            } else this._startImmediateDoubleClick(h, f)
          }; l._startImmediateDoubleClick = function (h, b) { b.immediateDoubleClick = { x: h.data.x, y: h.data.y, modifiers: h.modifiers, timeoutHandle: this._clock.setTimeout(() => this._removeState(h.data), "touch" === h.data.native.pointerType ? this.maximumDoubleTouchDelay : this.maximumDoubleClickDelay) } }; l._pointerId = function (h) { h = h.native; return "mouse" === h.pointerType ? `${h.pointerId}:${h.button}` : `${h.pointerType}` };
          l._removeState = function (h) { const b = this._pointerId(h); this._pointerState.delete(b); this.stopCapturingPointer(h.native); this.refreshHasPendingInputs() }; return p
        }(q.InputHandler); a.ImmediateDoubleClick = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/recognizers/SingleAndDoubleClick": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/clock ../../../core/MapUtils ../InputHandler ./support".split(" "), function (a, w, c, q, u, y) {
        const n = {
          maximumDoubleClickDelay: 250,
          maximumDoubleClickDistance: 10, maximumDoubleTouchDelay: 350, maximumDoubleTouchDistance: 35
        }; u = function (p) {
          function l(b = n.maximumDoubleClickDelay, d = n.maximumDoubleClickDistance, f = n.maximumDoubleTouchDelay, t = n.maximumDoubleTouchDistance, v = c.default) {
            var m = p.call(this, !1) || this; m.maximumDoubleClickDelay = b; m.maximumDoubleClickDistance = d; m.maximumDoubleTouchDelay = f; m.maximumDoubleTouchDistance = t; m._clock = v; m._pointerState = new Map; m._click = m.registerOutgoing("click"); m._doubleClick = m.registerOutgoing("double-click");
            m.registerIncoming("immediate-click", m._handleImmediateClick.bind(w._assertThisInitialized(m))); m.registerIncoming("pointer-drag", m._handlePointerDrag.bind(w._assertThisInitialized(m))); m.registerIncoming("drag", m._handleDrag.bind(w._assertThisInitialized(m))); return m
          } w._inheritsLoose(l, p); var h = l.prototype; h.onUninstall = function () { this._pointerState.forEach(b => { null != b.doubleClickTimeout && (b.doubleClickTimeout.remove(), b.doubleClickTimeout = null) }) }; h._pointerId = function (b) {
            b = b.native; return "mouse" ===
              b.pointerType ? `${b.pointerId}:${b.button}` : `${b.pointerType}`
          }; h._handleImmediateClick = function (b) { const d = b.data, f = this._pointerId(d), t = this._pointerState.get(f); if (t) { const v = "touch" === d.native.pointerType ? this.maximumDoubleTouchDistance : this.maximumDoubleClickDistance; y.manhattanDistance(t.event.data, d) > v ? (this._clearDoubleClickTimeout(f, !0), this._startClick(b)) : (this._clearDoubleClickTimeout(f, !1), this._doubleClick.emit(t.event.data, void 0, t.event.modifiers)) } else this._startClick(b) }; h._startClick =
            function (b) { const d = this._pointerId(b.data); this._pointerState.set(d, { event: b, doubleClickTimeout: this._clock.setTimeout(() => this._doubleClickTimeoutExceeded(d), "touch" === b.data.native.pointerType ? this.maximumDoubleTouchDelay : this.maximumDoubleClickDelay) }); this.refreshHasPendingInputs() }; h._handlePointerDrag = function (b) { b = this._pointerId(b.data.currentEvent); this._clearDoubleClickTimeout(b, !0) }; h._handleDrag = function (b) { b = this._pointerId(b.data.pointer); this._clearDoubleClickTimeout(b, !0) }; h._clearDoubleClickTimeout =
              function (b, d) { const f = this._pointerState.get(b); f && (f.doubleClickTimeout.remove(), f.doubleClickTimeout = null, d && this._doubleClickTimeoutExceeded(b), this._pointerState.delete(b), this.refreshHasPendingInputs()) }; h._doubleClickTimeoutExceeded = function (b) { const d = this._pointerState.get(b); this._click.emit(d.event.data, void 0, d.event.modifiers); d.doubleClickTimeout = null; this._pointerState.delete(b); this.refreshHasPendingInputs() }; w._createClass(l, [{
                key: "hasPendingInputs", get: function () {
                  return q.someMap(this._pointerState,
                    b => null != b.doubleClickTimeout)
                }
              }]); return l
        }(u.InputHandler); a.DefaultParameters = n; a.SingleAndDoubleClick = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/recognizers/PointerClickHoldAndDrag": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/clock", "../InputHandler", "./support"], function (a, w, c, q, u) {
        const y = { maximumClickDelay: 300, movementUntilMouseDrag: 1.5, movementUntilPenDrag: 6, movementUntilTouchDrag: 6, holdDelay: 500 }; q = function (n) {
          function p(h =
            y.maximumClickDelay, b = y.movementUntilMouseDrag, d = y.movementUntilPenDrag, f = y.movementUntilTouchDrag, t = y.holdDelay, v = c.default) {
              var m = n.call(this, !1) || this; m.maximumClickDelay = h; m.movementUntilMouseDrag = b; m.movementUntilPenDrag = d; m.movementUntilTouchDrag = f; m.holdDelay = t; m._clock = v; m._pointerState = new Map; m._pointerDrag = m.registerOutgoing("pointer-drag"); m._immediateClick = m.registerOutgoing("immediate-click"); m._pointerHold = m.registerOutgoing("hold"); m.registerIncoming("pointer-down", m._handlePointerDown.bind(w._assertThisInitialized(m)));
            m.registerIncoming("pointer-up", e => { m._handlePointerLoss(e, "pointer-up") }); m.registerIncoming("pointer-capture-lost", e => { m._handlePointerLoss(e, "pointer-capture-lost") }); m.registerIncoming("pointer-cancel", e => { m._handlePointerLoss(e, "pointer-cancel") }); m._moveHandle = m.registerIncoming("pointer-move", m._handlePointerMove.bind(w._assertThisInitialized(m))); m._moveHandle.pause(); return m
          } w._inheritsLoose(p, n); var l = p.prototype; l.onUninstall = function () {
            this._pointerState.forEach(h => {
            null != h.holdTimeout &&
              (h.holdTimeout.remove(), h.holdTimeout = null)
            }); n.prototype.onUninstall.call(this)
          }; l._handlePointerDown = function (h) {
            const b = h.data, d = b.native.pointerId; var f = null; 0 === this._pointerState.size && (f = this._clock.setTimeout(() => { const t = this._pointerState.get(d); t && (t.isDragging || (this._pointerHold.emit(t.previousEvent, void 0, h.modifiers), t.holdEmitted = !0), t.holdTimeout = null) }, this.holdDelay)); f = {
              startEvent: b, previousEvent: b, startTimestamp: h.timestamp, isDragging: !1, downButton: b.native.button, holdTimeout: f,
              modifiers: new Set
            }; this._pointerState.set(d, f); this.startCapturingPointer(b.native); this._moveHandle.resume(); 1 < this._pointerState.size && this.startDragging(h)
          }; l._createPointerDragData = function (h, b, d) { return { action: h, startEvent: b.startEvent, previousEvent: b.previousEvent, currentEvent: d } }; l._handlePointerMove = function (h) {
            const b = h.data, d = this._pointerState.get(b.native.pointerId); if (d) {
              if (d.isDragging) this._pointerDrag.emit(this._createPointerDragData("update", d, b), void 0, d.modifiers); else {
                const f =
                  u.euclideanDistance(b, d.startEvent), t = this._getDragThreshold(b.native.pointerType); f > t && this.startDragging(h)
              } d.previousEvent = b
            }
          }; l._getDragThreshold = function (h) { switch (h) { case "touch": return this.movementUntilTouchDrag; case "pen": return this.movementUntilPenDrag; default: return this.movementUntilMouseDrag } }; l.startDragging = function (h) {
            const b = h.data, d = b.native.pointerId; this._pointerState.forEach(f => {
            null != f.holdTimeout && (f.holdTimeout.remove(), f.holdTimeout = null); f.isDragging || (f.modifiers = h.modifiers,
              f.isDragging = !0, d === f.startEvent.native.pointerId ? this._pointerDrag.emit(this._createPointerDragData("start", f, b)) : this._pointerDrag.emit(this._createPointerDragData("start", f, f.previousEvent), h.timestamp))
            })
          }; l._handlePointerLoss = function (h, b) {
            const d = h.data, f = d.native.pointerId, t = this._pointerState.get(f); t && (null != t.holdTimeout && (t.holdTimeout.remove(), t.holdTimeout = null), t.isDragging ? this._pointerDrag.emit(this._createPointerDragData("end", t, "pointer-up" === b ? d : t.previousEvent), void 0, t.modifiers) :
              "pointer-up" === b && t.downButton === d.native.button && h.timestamp - t.startTimestamp <= this.maximumClickDelay && !t.holdEmitted && this._immediateClick.emit(d), this._pointerState.delete(f), this.stopCapturingPointer(d.native), 0 === this._pointerState.size && this._moveHandle.pause())
          }; return p
        }(q.InputHandler); a.DefaultParameters = y; a.PointerClickHoldAndDrag = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/input/recognizers/VerticalTwoFingerDrag": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers",
        "../DragEventSeparator", "../InputHandler"], function (a, w, c, q) {
          q = function (u) {
            function y(p = 20, l = 40) {
              var h = u.call(this, !1) || this; h._threshold = p; h._maxDelta = l; h.state = "ready"; h.emittedArtificalEnd2 = !1; h._vertical = h.registerOutgoing("vertical-two-finger-drag"); h._artificalDrag = h.registerOutgoing("drag"); h.dragEventSeparator = new c.DragEventSeparator({ start: (b, d) => h.observeStart(b, d), update: (b, d, f) => h.observeUpdate(b, d, f), end: (b, d) => h.observeEnd(d) }); h.registerIncoming("drag", b => h.dragEventSeparator.handle(b));
              return h
            } w._inheritsLoose(y, u); var n = y.prototype; n.observeStart = function (p, l) { 1 === p && this.emittedArtificalEnd2 && (this.emittedArtificalEnd2 = !1, this._artificalDrag.emit({ action: "start", button: l.data.button, buttons: l.data.buttons, pointerType: l.data.pointerType, timestamp: l.data.timestamp, pointers: l.data.pointers, pointer: l.data.pointer, angle: l.data.angle, radius: l.data.radius, center: l.data.center }), l.stopPropagation()); this.state = 2 === p ? "ready" : "failed" }; n.observeUpdate = function (p, l, h) {
            "failed" !== this.state &&
              2 === p && ("active" === this.state ? (this._vertical.emit({ delta: l.data.center.y - this._thresholdReachedCenter.y, action: "update" }), l.stopPropagation()) : this.checkMovementWithinLimits(l.data, h.data) ? this.checkVerticalThresholdReached(l.data, h.data) && (this.state = "active", this.emittedArtificalEnd2 = !0, this._thresholdReachedCenter = l.data.center, this._artificalDrag.emit({
                action: "end", button: l.data.button, buttons: l.data.buttons, pointerType: l.data.pointerType, timestamp: l.data.timestamp, pointers: l.data.pointers, pointer: l.data.pointer,
                angle: l.data.angle, radius: l.data.radius, center: l.data.center
              }), this._vertical.emit({ delta: l.data.center.y - this._thresholdReachedCenter.y, action: "begin" }), l.stopPropagation()) : this.state = "failed")
            }; n.observeEnd = function (p) { "active" === this.state && (this._vertical.emit({ delta: p.data.center.y - this._thresholdReachedCenter.y, action: "end" }), this.state = "ready", p.stopPropagation()) }; n.checkMovementWithinLimits = function (p, l) {
              let h = -Infinity, b = Infinity, d = -Infinity, f = Infinity; l.pointers.forEach(g => {
                h = Math.max(h,
                  g.x); b = Math.min(b, g.x); d = Math.max(d, g.y); f = Math.min(f, g.y)
              }); let t = -Infinity, v = Infinity, m = -Infinity, e = Infinity; p.pointers.forEach(g => { t = Math.max(t, g.x); v = Math.min(v, g.x); m = Math.max(m, g.y); e = Math.min(e, g.y) }); return Math.abs(p.center.x - l.center.x) < this._threshold && Math.abs(t - v - (h - b)) <= this._maxDelta && Math.abs(m - e - (d - f)) <= this._maxDelta
            }; n.checkVerticalThresholdReached = function (p, l) {
              let h = Math.abs(p.center.y - l.center.y); p.pointers.forEach((b, d) => { d = l.pointers.get(d); h = Math.min(h, Math.abs(b.y - d.y)) });
              return h >= this._threshold
            }; w._createClass(y, [{ key: "failed", get: function () { return "failed" === this.state } }]); return y
          }(q.InputHandler); a.VerticalTwoFingerDrag = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/input/DragEventSeparator": function () {
      define(["exports"], function (a) {
        let w = function () {
          function c(u) { this.callbacks = u; this.currentCount = 0; this.callbacks.condition || (this.callbacks.condition = () => !0) } var q = c.prototype; q.handle = function (u) {
            const y = u.data, n = y.pointers.size; switch (y.action) {
              case "start": this.currentCount =
                n; this.emitStart(u); break; case "added": this.emitEnd(this.previousEvent); this.currentCount = n; this.emitStart(u); break; case "update": this.emitUpdate(u); break; case "removed": this.startEvent && this.emitEnd(this.previousEvent); this.currentCount = n; this.emitStart(u); break; case "end": this.emitEnd(u), this.currentCount = 0
            }this.previousEvent = u
          }; q.emitStart = function (u) { this.startEvent = u; this.callbacks.condition(this.currentCount, u) && this.callbacks.start(this.currentCount, u, this.startEvent) }; q.emitUpdate = function (u) {
            this.callbacks.condition(this.currentCount,
              u) && this.callbacks.update(this.currentCount, u, this.startEvent)
          }; q.emitEnd = function (u) { this.callbacks.condition(this.currentCount, u) && this.callbacks.end(this.currentCount, u, this.startEvent); this.startEvent = null }; return c
        }(); a.DragEventSeparator = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/GraphicsDeconflictor": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Handles ../../../../core/MapUtils ../../../../core/maybe ../../../../core/watchUtils ../../../../core/Logger ../../../../core/accessorSupport/ensureType ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/set ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/boundedPlane ./Deconflictor ./LabelDeconflictor ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          function g(k) { k = k.layer; return !(!k || !k.featureReduction || "selection" !== k.featureReduction.type) } function x(k) { (k = k.graphics3DGraphics) && k.forEach(r => r.clearVisibilityFlag(3)) } a.GraphicsDeconflictor = function (k) {
            function r() { var z = k.apply(this, arguments) || this; z._handles = new q; z._contexts = new Map; z._viewState = new v.DeconflictorViewState; z.visibilityGroup = 0; z._iconMarginFactor = -.1; return z } w._inheritsLoose(r, k); var A = r.prototype; A.initialize = function () {
              this._handles.add([this.view.watch("state.camera",
                () => { this.updateViewState(); this.setDirty() }), this.view.watch("map.ground.opacity", (z, B) => { 1 !== z && 1 !== B || this.setDirty() }), n.init(this.view, "slicePlane", () => { this.updateSlicePlane(); this.slicePlaneChanged() })]); this._frameTask = this.view.resourceController.scheduler.registerTask(e.TaskPriority.GRAPHICS_DECONFLICTOR, this); this._labels = new m.LabelDeconflictor({ view: this.view, parent: this })
            }; A.destroy = function () {
              this._labels.destroy(); this._labels = null; this._handles.destroy(); this._handles = null; this._frameTask &&
                (this._frameTask.remove(), this._frameTask = null)
            }; A.setDirty = function () { 0 < this._contexts.size && (k.prototype.setDirty.call(this), this._labels.setDirty()) }; A.runTask = function (z) { k.prototype.runTask.call(this, z); this.running || this._labels.setDirty() }; A.setInitialIconVisibilityFlag = function (z, B) { z = !(this._graphicSupportsDeconfliction(B) && g(z)); B.setVisibilityFlag(3, z, 0) }; A.updateViewState = function () { this.view && this.view.state && (this._viewState.camera.copyFrom(this.view.state.camera), this.updateSlicePlane()) };
            A.updateSlicePlane = function () { const z = this.view ? this.view.slicePlane : null; y.isSome(z) && t.transform(z, this._viewState.camera.viewMatrix, this._viewState.slicePlane); this._viewState.slicePlaneEnabled = y.isSome(z) }; A.slicePlaneChanged = function () { u.someMap(this._contexts, (z, B) => B.symbolCreationContext.slicePlaneEnabled) && this.setDirty() }; A.addGraphicsOwner = function (z) {
              let B = this._contexts.get(z); null == B && (B = new Map, this._contexts.set(z, B), this.setDirty()); return {
                addGraphic: C => this.addGraphic(z, B, C), removeGraphic: C =>
                  this.removeGraphic(B, C), labelingInfoChange: () => this._labels.enabledChanged(z, B), featureReductionChange: () => this.enabledChanged(z, B), slicePlaneEnabledChange: () => this._slicePlaneEnabledChanged(z, B), clear: () => B.forEach(C => this.removeGraphic(B, C.graphics3DGraphic))
              }
            }; A.removeGraphicsOwner = function (z) { const B = this._contexts.get(z); B && (B.forEach(C => this.removeGraphic(B, C.graphics3DGraphic)), this._contexts.delete(z), this.setDirty()) }; A.addGraphic = function (z, B, C) {
              const D = C.graphic.uid; C = new v.DeconflictorGraphic(C,
                z.symbolCreationContext.slicePlaneEnabled); B.set(D, C); g(z) && this.addToActiveGraphics(C); z.labelsEnabled && this._labels.addToActiveGraphics(C)
            }; A.removeGraphic = function (z, B) { B = B.graphic.uid; const C = z.get(B); C && (this.removeFromActiveGraphics(C), this._labels.removeFromActiveGraphics(C), z.delete(B), this.setDirty()) }; A.enabledChanged = function (z, B) { const C = g(z); C || x(z); this.modifyGraphics(B, C) }; A._slicePlaneEnabledChanged = function (z, B) {
              const C = z.symbolCreationContext.slicePlaneEnabled; B.forEach(D => D.slicePlaneEnabled =
                C); this.setDirty()
            }; A.getGraphicsLayers = function (z) { return z.graphics }; A._graphicSupportsDeconfliction = function (z) { if (z.isDraped) return !1; z = z.graphics; if (!z || !z.length) return !1; for (const B of z) if (this.layerSupportsDeconfliction(B)) return !0; return !1 }; w._createClass(r, [{ key: "labels", get: function () { return this._labels } }, { key: "viewState", get: function () { return this._viewState } }, { key: "iconMarginFactor", get: function () { return this._iconMarginFactor }, set: function (z) { this._iconMarginFactor = z; this.setDirty() } }]);
            return r
          }(v.Deconflictor); a.GraphicsDeconflictor = c.__decorate([f.subclass("esri.views.3d.layers.graphics.GraphicsDeconflictor")], a.GraphicsDeconflictor); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Deconflictor": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/mathUtils ../../../../core/maybe ../../../../core/PooledArray ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/projectionEllipsoid ../../../../geometry/support/aaBoundingRect ../../../../chunks/boundedPlane ../../../../geometry/support/ray ../../../../chunks/sphere ./deconflictorDebug ../../support/debugFlags ../../webgl-engine/lib/Camera ../../webgl-engine/lib/screenSizePerspectiveUtils ../../webgl-engine/materials/HUDMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          function* M(ea) { if (Map.prototype.entries) { ea = ea.entries(); for (let ba = ea.next(); !ba.done; ba = ea.next())yield ba.value[1] } else yield* ea.values() } function* F(ea, ba, aa) {
            ba.clear(); ea.forEach((U, X) => { const Z = ba.pushNew(); Z.id = X; Z.prio = U.info ? -U.info[aa].distance : Number.MAX_VALUE }); yield; const W = ba.iterableSort((U, X) => X.prio - U.prio); for (let U = W.next(); !U.done; U = W.next())yield; ba.forAll(U => {
              const X = ea.get(U.id); X && (ea.delete(U.id), ea.set(U.id,
                X))
            }); ba.clear()
          } const K = e.create(), P = x.create(), L = x.create(), N = e.create(), G = t.create(), I = B.create(), O = z.create(), R = e.create(), S = r.create(); let Q = function () { this.aabr = r.create(); this.distance = 0; this.visible = this.culled = !1 }, T = function () { function ea() { this.active = new Map; this.visible = new Map } ea.prototype.clear = function () { this.active.clear(); this.visible.clear() }; return ea }(), da = function () { }, Y = function () { this.sortArray = new n({ allocator: ea => ea || new da }) }, fa = function () {
            function ea() {
            this.camera = new E;
              this.slicePlane = A.create(); this.slicePlaneEnabled = !1
            } ea.prototype.copyFrom = function (ba) { this.camera.copyFrom(ba.camera); A.copy(ba.slicePlane, this.slicePlane); this.slicePlaneEnabled = ba.slicePlaneEnabled }; return ea
          }(); a.Deconflictor = function (ea) {
            function ba() { var W = ea.apply(this, arguments) || this; W._dirty = !1; W._runningViewState = new fa; W._state = 0; W.graphics = new T; W.iterators = new Y; W.accBinsNumX = 15; W.accBinsNumY = 20; W.accBinsSizeX = 0; W.accBinsSizeY = 0; W.accBins = null; W.accNumTests = 0; return W } w._inheritsLoose(ba,
              ea); var aa = ba.prototype; aa.destroy = function () { this.graphics.clear(); this.iterators = null }; aa.setDirty = function () { !this._dirty && 0 < this.graphics.active.size && (this._dirty = !0, this.notifyChange("updating")) }; aa.runTask = function (W) {
                switch (this._state) {
                  case 0: this.startUpdate(), W.madeProgress(); case 1: if (this._state = 1, !this.processActiveGraphics(W)) break; case 2: if (this._state = 2, !this.sortVisibleGraphics(W)) break; case 3: if (this._state = 3, !this.deconflictVisibleGraphics(W)) break; default: C.drawAccelerationStruct(this,
                    this.graphics.visible), this._state = 0, this.notifyChange("updating")
                }
              }; aa.modifyGraphics = function (W, U) { U ? W.forEach(X => this.addToActiveGraphics(X)) : W.forEach(X => this.removeFromActiveGraphics(X)); this.setDirty() }; aa.layerSupportsDeconfliction = function (W) { if (y.isNone(W) || "object3d" !== W.type) return !1; W = W.stageObject; return 1 === (W ? W.geometryRecords.length : 0) && W.geometryRecords[0].material instanceof J.HUDMaterial ? !0 : !1 }; aa.startUpdate = function () {
                C.prepare(this.view); this._dirty = !1; this._runningViewState.copyFrom(this.viewState);
                const { fullWidth: W, fullHeight: U } = this._runningViewState.camera; this.initBins(W, U); this.resetIterators()
              }; aa.addToActiveGraphics = function (W) { W.info[this.visibilityGroup] = new Q; this.graphics.active.set(W.graphics3DGraphic.graphic.uid, W); this.setDirty() }; aa.removeFromActiveGraphics = function (W) {
                this.removeFromVisibleGraphics(W); { const U = W.graphics3DGraphic; U.destroyed || U.clearVisibilityFlag(3, this.visibilityGroup) } delete W.info[this.visibilityGroup]; this.graphics.active.delete(W.graphics3DGraphic.graphic.uid);
                this.setDirty()
              }; aa.addToVisibleGraphics = function (W) { this.graphics.visible.set(W.graphics3DGraphic.graphic.uid, W) }; aa.removeFromVisibleGraphics = function (W) { this.graphics.visible.delete(W.graphics3DGraphic.graphic.uid) }; aa.processActiveGraphics = function (W) {
                const U = this.ensureActiveGraphicsIterator(), X = f.invert(G, this._runningViewState.camera.projectionMatrix), Z = "global" === this.view.viewingMode && 1 === this.view.map.ground.opacity && 0 < this._runningViewState.camera.relativeElevation ? I : null; let ia = 0; y.isSome(Z) &&
                  (m.transformMat4(Z, e.ZEROS, this._runningViewState.camera.viewMatrix), Z[3] = k.getReferenceEllipsoid(this.view.spatialReference).radius, ia = B.distanceToSilhouette(Z, e.ZEROS)); for (; !W.done;) { W.madeProgress(); var la = U.next(); if (la.done) return this.resetActiveGraphicsIterator(), !0; const ma = (la = la.value) && la.info[this.visibilityGroup]; ma && (this.collectGraphics3DGraphics(la, X, Z, ia), ma.culled ? this.removeFromVisibleGraphics(la) : this.addToVisibleGraphics(la)) } return !1
              }; aa.sortVisibleGraphics = function (W) {
                const U =
                  this.ensureSortGraphicsIterator(); for (; !W.done;) { const X = U.next(); W.madeProgress(); if (X.done) return this.resetSortGraphicsIterator(), !0 } return !1
              }; aa.deconflictVisibleGraphics = function (W) {
                const U = this.ensureVisibleGraphicsIterator(), X = 1 === this.visibilityGroup; for (; !W.done;) {
                  W.madeProgress(); var Z = U.next(); if (Z.done) return this.resetVisibleGraphicsIterator(), !0; Z = Z.value; const la = Z.info[this.visibilityGroup]; if (la && !la.culled) {
                    var ia = Z.graphics3DGraphic; (ia = (!X || ia.isVisible()) && !this.isConflicted(Z)) &&
                      this.addToBins(Z); la.visible = ia; this.setGraphicVisibility(Z, ia); C.drawPoly(la, ia)
                  }
                } return !1
              }; aa.resetIterators = function () { this.iterators.active = null; this.iterators.visible = null; this.iterators.sort = null }; aa.ensureActiveGraphicsIterator = function () { this.iterators.active || (this.iterators.active = M(this.graphics.active)); return this.iterators.active }; aa.resetActiveGraphicsIterator = function () { this.iterators.active = null }; aa.ensureVisibleGraphicsIterator = function () {
                this.iterators.visible || (this.iterators.visible =
                  M(this.graphics.visible)); return this.iterators.visible
              }; aa.resetVisibleGraphicsIterator = function () { this.iterators.visible = null }; aa.ensureSortGraphicsIterator = function () { this.iterators.sort || (this.iterators.sort = F(this.graphics.visible, this.iterators.sortArray, this.visibilityGroup)); return this.iterators.sort }; aa.resetSortGraphicsIterator = function () { this.iterators.sort = null }; aa.collectGraphics3DGraphics = function (W, U, X, Z) {
                var ia = W.graphics3DGraphic; if (!ia.destroyed) {
                  var la = W.info[this.visibilityGroup];
                  if (ia.isVisible(0, 3)) {
                    var ma = this.getGraphicsLayers(ia); r.empty(la.aabr); ia = null; for (const ra of ma) if (this.layerSupportsDeconfliction(ra)) { ma = ra.stageObject.geometryRecords[0].material; if (y.isNone(ia)) { ia = this.getProjectionInfo(ra, U, ka); if (ia.isOutsideScreen || this.isCulledBySlice(W, K) || y.isSome(X) && this.isCulledByHorizon(ia, X, Z)) { la.culled = !0; return } !D.TESTS_DISABLE_OPTIMIZATIONS && la.visible && (ia.distance *= .7) } this.expandBoundingRect(la, ra, ma, ia) } y.isNone(ia) ? la.culled = !0 : (la.distance = ia.distance,
                      la.culled = !1)
                  } else la.culled = !0
                }
              }; aa.getProjectionInfo = function (W, U, X) {
                const Z = this._runningViewState.camera; W = W.stageObject; var ia = W.geometryRecords[0]; const la = ia.material; var ma = B.getCenter(W.boundingVolumeWorldSpace.bounds); m.transformMat4(K, ma, Z.viewMatrix); ma = ia.geometry.vertexAttributes; ia = ma.get("normal").data; ma = ma.get("auxpos1").data; la.applyShaderOffsetsView(K, ia, W.transformation, ma, Z, X.scaleInfo, K); g.set(P, K[0], K[1], K[2], 1); g.transformMat4(L, P, Z.projectionMatrix); m.scale(X.positionNDC,
                  L, 1 / L[3]); la.applyShaderOffsetsNDC(X.positionNDC, ma, Z, X.positionNDC, N); X.distanceWithoutPolygonOffset = Z.depthNDCToWorld(N[2]); X.distance = N[2] === X.positionNDC[2] ? X.distanceWithoutPolygonOffset : Z.depthNDCToWorld(X.positionNDC[2]); g.set(L, X.positionNDC[0], X.positionNDC[1], X.positionNDC[2], 1); g.transformMat4(P, L, U); g.scale(P, P, 1 / P[3]); m.set(X.positionView, K[0], K[1], K[2]); return X
              }; aa.isCulledByHorizon = function (W, U, X) {
                m.copy(O.direction, W.positionView); m.set(O.origin, 0, 0, 0); return B.intersectRay(U, O, R) ?
                  W.distanceWithoutPolygonOffset > X : !1
              }; aa.isCulledBySlice = function (W, U) { return W.slicePlaneEnabled && this._runningViewState.slicePlaneEnabled && A.extrusionContainsPoint(this._runningViewState.slicePlane, U) }; aa.expandBoundingRect = function (W, U, X, { positionNDC: Z, scaleInfo: ia }) {
                const la = this._runningViewState.camera; U = U.getScreenSize(ha); H.applyPrecomputedScaleFactor(U, ia.factor, U); U[0] *= la.pixelRatio; U[1] *= la.pixelRatio; X = r.offset(X.calculateRelativeScreenBounds(U, ia.factorAlignment.scale, S), u.lerp(0, la.fullWidth,
                  .5 + .5 * Z[0]), u.lerp(0, la.fullHeight, .5 + .5 * Z[1])); Z = this.iconMarginFactor; 0 !== Z && (Z *= Math.min(r.width(X), r.height(X)), X[0] -= Z, X[1] -= Z, X[2] += Z, X[3] += Z); r.expand(W.aabr, X, W.aabr)
              }; aa.isConflicted = function (W) {
                const U = W.graphics3DGraphic.graphic.uid; W = W.info[this.visibilityGroup]; for (let X = Math.floor(W.aabr[0] / this.accBinsSizeX); X <= Math.floor(W.aabr[2] / this.accBinsSizeX); X++)if (!(0 > X || X >= this.accBinsNumX)) for (let Z = Math.floor(W.aabr[1] / this.accBinsSizeY); Z <= Math.floor(W.aabr[3] / this.accBinsSizeY); Z++) {
                  if (0 >
                    Z || Z >= this.accBinsNumY) continue; const ia = this.accBins[X][Z]; for (let la = 0; la < ia.length; la++) { const ma = ia.data[la], ra = ma.info[this.visibilityGroup]; if (ra && ra.visible && ma.graphics3DGraphic.graphic.uid !== U && (this.accNumTests++ , r.intersects(ra.aabr, W.aabr))) return !0 }
                } return !1
              }; aa.initBins = function (W, U) {
                if (null == this.accBins) { this.accBins = []; for (var X = 0; X < this.accBinsNumX; X++) { this.accBins.push([]); var Z = this.accBins[this.accBins.length - 1]; for (let ia = 0; ia < this.accBinsNumY; ia++)Z.push(new n) } } else for (X =
                  0; X < this.accBinsNumX; X++)for (Z = 0; Z < this.accBinsNumY; Z++)this.accBins[X][Z].clear(); this.accBinsSizeX = W / this.accBinsNumX; this.accBinsSizeY = U / this.accBinsNumY; this.accNumTests = 0
              }; aa.addToBins = function (W) {
                var U = W.info[this.visibilityGroup], X = Math.floor(U.aabr[0] / this.accBinsSizeX); const Z = Math.floor(U.aabr[2] / this.accBinsSizeX), ia = Math.floor(U.aabr[1] / this.accBinsSizeY); for (U = Math.floor(U.aabr[3] / this.accBinsSizeY); X <= Z; X++)if (!(0 > X || X >= this.accBinsNumX)) for (let la = ia; la <= U; la++)0 > la || la >= this.accBinsNumY ||
                  this.accBins[X][la].push(W)
              }; aa.setGraphicVisibility = function (W, U) { W = W.graphics3DGraphic; W.destroyed || (W.setVisibilityFlag(3, U, this.visibilityGroup), 1 === this.visibilityGroup && this.view.labeler.setLabelGraphicVisibility(W, U)) }; w._createClass(ba, [{ key: "dirty", get: function () { return this._dirty } }, { key: "state", get: function () { return this._state } }, { key: "updating", get: function () { return 0 !== this._state || this._dirty } }, {
                key: "updatingProgress", get: function () {
                  if (!this.updating) return 1; const W = this._state / 4; return this._dirty ?
                    .5 * W : W
                }
              }, { key: "running", get: function () { return this.view.ready && null != this.view.state && this.updating } }]); return ba
          }(q); c.__decorate([p.property({ constructOnly: !0 })], a.Deconflictor.prototype, "view", void 0); c.__decorate([p.property({ type: Boolean, readOnly: !0 })], a.Deconflictor.prototype, "updating", null); a.Deconflictor = c.__decorate([d.subclass("esri.views.3d.layers.graphics.Deconflictor")], a.Deconflictor); const ha = v.create(), ka = new (function () {
            function ea() {
            this.positionView = e.create(); this.positionNDC =
              e.create(); this.distanceWithoutPolygonOffset = this.distance = 0; this.scaleInfo = { factor: { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 }, factorAlignment: { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 } }
            } w._createClass(ea, [{ key: "isOutsideScreen", get: function () { const ba = this.positionNDC; return -1 > ba[0] || -1 > ba[1] || -1 > ba[2] || 1 <= ba[0] || 1 <= ba[1] } }]); return ea
          }()); a.DeconflictorGraphic = function (ea, ba, aa = {}) { this.graphics3DGraphic = ea; this.slicePlaneEnabled = ba; this.info = aa }; a.DeconflictorViewState = fa; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/deconflictorDebug": function () {
      define(["exports", "../../support/debugFlags"], function (a, w) {
        function c(b, d, f, t, v) { p && (p(), p = null); const m = l.height, e = h; e.beginPath(); e.lineWidth = 1; e.strokeStyle = v; e.moveTo(b, m - f); e.lineTo(d, m - f); e.stroke(); e.lineTo(d, m - t); e.stroke(); e.lineTo(d, m - f); e.stroke(); e.lineTo(b, m - f); e.stroke(); e.lineTo(b, m - f); e.stroke(); e.closePath() } let q = !1, u = !1, y = !1, n = !1, p = null, l, h; a.drawAccelerationStruct = function (b, d) {
          if (u && h) {
            p &&
            (p(), p = null); var f = h, t = 0; for (let v = 0; v < b.accBinsNumX; v++)for (let m = 0; m < b.accBinsNumY; m++) { const e = b.accBins[v][b.accBinsNumY - 1 - m]; t += e.length; const g = v * b.accBinsSizeX, x = (v + 1) * b.accBinsSizeX, k = m * b.accBinsSizeY, r = (m + 1) * b.accBinsSizeY; f.fillText(e.length.toFixed(), g + 5, k + 15); c(g, x, k, r, "blue") } f.fillText("total totalShownLabels: " + t, 70, 40); f.fillText("total visible labels: " + d.size, 70, 50); f.fillText("total numTests: " + b.accNumTests, 70, 30)
          }
        }; a.drawPoly = function (b, d) {
        q && (d && y || !d && n) && c(b.aabr[0], b.aabr[2],
          b.aabr[1], b.aabr[3], d ? "green" : "red")
        }; a.prepare = function (b) {
          y = w.DECONFLICTOR_SHOW_VISIBLE; n = w.DECONFLICTOR_SHOW_INVISIBLE; q = y || n; u = w.DECONFLICTOR_SHOW_GRID; p = null; q || u ? p = () => {
            {
            null == l && (l = document.createElement("canvas"), l.setAttribute("id", "canvas2d"), b.surface.parentElement.style.position = "relative", b.surface.parentElement.appendChild(l)); const d = b.height * b.pixelRatio; l.setAttribute("width", `${b.width * b.pixelRatio}px`); l.setAttribute("height", `${d}px`); l.setAttribute("style", `position:absolute;left:0px;top:0px;display:block;pointer-events:none;width:${b.width}px;height:${b.height}px`);
              h = l.getContext("2d"); h.clearRect(0, 0, b.width, b.height); h.font = "12px Arial"
            }
          } : l && (l.parentElement.removeChild(l), l = null)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/debugFlags": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p) {
          c = function (l) {
            function h() {
              var b = l.apply(this, arguments) || this; b.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = !1; b.SCENEVIEW_LOCKING_LOG = !1; b.HIGHLIGHTS_GRID_OPTIMIZATION_ENABLED = !0; b.HIGHLIGHTS_PROFILE_TO_CONSOLE = !1; b.DECONFLICTOR_SHOW_VISIBLE = !1; b.DECONFLICTOR_SHOW_INVISIBLE = !1; b.DECONFLICTOR_SHOW_GRID = !1; b.LABELS_SHOW_BORDER = !1; b.OVERLAY_DRAW_DEBUG_TEXTURE = !1; b.OVERLAY_SHOW_CENTER = !1; b.SHOW_POI = !1; b.TESTS_DISABLE_OPTIMIZATIONS = !1; b.TESTS_DISABLE_FAST_UPDATES = !1; b.DRAW_MESH_GEOMETRY_NORMALS =
                !1; b.FEATURE_TILE_FETCH_SHOW_TILES = !1; b.FEATURE_TILE_TREE_SHOW_TILES = !1; b.TERRAIN_TILE_TREE_SHOW_TILES = !1; b.I3S_TREE_SHOW_TILES = !1; b.I3S_SHOW_MODIFICATIONS = !1; b.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = !1; b.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = !1; b.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = !1; return b
            } a._inheritsLoose(h, l); return h
          }(c); w.__decorate([q.property()], c.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0); w.__decorate([q.property()], c.prototype, "SCENEVIEW_LOCKING_LOG", void 0); w.__decorate([q.property()],
            c.prototype, "HIGHLIGHTS_GRID_OPTIMIZATION_ENABLED", void 0); w.__decorate([q.property()], c.prototype, "HIGHLIGHTS_PROFILE_TO_CONSOLE", void 0); w.__decorate([q.property()], c.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0); w.__decorate([q.property()], c.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0); w.__decorate([q.property()], c.prototype, "DECONFLICTOR_SHOW_GRID", void 0); w.__decorate([q.property()], c.prototype, "LABELS_SHOW_BORDER", void 0); w.__decorate([q.property()], c.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE",
              void 0); w.__decorate([q.property()], c.prototype, "OVERLAY_SHOW_CENTER", void 0); w.__decorate([q.property()], c.prototype, "SHOW_POI", void 0); w.__decorate([q.property()], c.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0); w.__decorate([q.property()], c.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0); w.__decorate([q.property()], c.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0); w.__decorate([q.property()], c.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0); w.__decorate([q.property()], c.prototype, "FEATURE_TILE_TREE_SHOW_TILES",
                void 0); w.__decorate([q.property()], c.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0); w.__decorate([q.property()], c.prototype, "I3S_TREE_SHOW_TILES", void 0); w.__decorate([q.property()], c.prototype, "I3S_SHOW_MODIFICATIONS", void 0); w.__decorate([q.property()], c.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0); w.__decorate([q.property()], c.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0); w.__decorate([q.property()], c.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0); c = w.__decorate([p.subclass("esri.views.3d.support.DebugFlags")],
                  c); return new c
        })
    }, "esri/views/3d/webgl-engine/lib/screenSizePerspectiveUtils": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/mathUtils"], function (a, w, c) {
        function q(b, d, f) { const t = f.parameters; f = f.paddingPixelsOverride; l.scale = Math.min(t.divisor / (d - t.offset), 1); l.factor = Math.abs(b * b * b); l.minPixelSize = t.minPixelSize; l.paddingPixels = f; return l } function u(b, d) { return 0 === b ? d.minPixelSize : d.minPixelSize * (1 + 2 * d.paddingPixels / b) } function y(b, d) {
          return Math.max(c.lerp(b *
            d.scale, b, d.factor), u(b, d))
        } let n = function () {
          function b(f, t, v, m = { camera: { distance: 0, fovY: 0 }, divisor: 0, offset: 0, minPixelSize: 0, paddingPixels: 0 }, e) {
          this.viewingMode = f; this.description = t; this.ellipsoidRadius = v; this.parameters = m; this._paddingPixelsOverride = e; 2 === this.viewingMode ? (this.coverageCompensation = this.surfaceCoverageCompensationLocal, this.calculateCurvatureDependentParameters = this.calculateCurvatureDependentParametersLocal) : (this.coverageCompensation = this.surfaceCoverageCompensationGlobal, this.calculateCurvatureDependentParameters =
            this.calculateCurvatureDependentParametersGlobal)
          } var d = b.prototype; d.update = function (f) { if (this.parameters && this.parameters.camera.fovY === f.fovY && this.parameters.camera.distance === f.distance) return !1; this.calculateParameters(f, this.ellipsoidRadius, this.parameters); return !0 }; d.overridePadding = function (f) { return f !== this.paddingPixelsOverride ? new b(this.viewingMode, this.description, this.ellipsoidRadius, this.parameters, f) : this }; d.calculateParameters = function (f, t, v) {
            const { scaleStart: m, scaleFallOffRange: e,
              minPixelSize: g } = this.description, { fovY: x, distance: k } = f; var r = this.calculateCurvatureDependentParameters(f, t); t = this.coverageCompensation(f, t, r); const { tiltAngle: A, scaleFallOffFactor: z } = r, B = Math.sin(A) * k, C = .5 * Math.PI - A - x * (.5 - m * t); r = B / Math.cos(C); t = (r - B / Math.cos(C + x * e * t) * z) / (1 - z); v.camera.fovY = f.fovY; v.camera.distance = f.distance; v.offset = t; v.divisor = r - t; v.minPixelSize = g; return v
          }; d.calculateCurvatureDependentParametersLocal = function (f, t, v = h) {
          v.tiltAngle = this.description.curvatureDependent.min.tiltAngle;
            v.scaleFallOffFactor = this.description.curvatureDependent.min.scaleFallOffFactor; return v
          }; d.calculateCurvatureDependentParametersGlobal = function (f, t, v = h) { const m = this.description.curvatureDependent; f = 1 + f.distance / t; f = Math.sqrt(f * f - 1); const [e, g] = [m.min.curvature, m.max.curvature]; f = c.clamp((f - e) / (g - e), 0, 1); const [x, k] = [m.min, m.max]; v.tiltAngle = c.lerp(x.tiltAngle, k.tiltAngle, f); v.scaleFallOffFactor = c.lerp(x.scaleFallOffFactor, k.scaleFallOffFactor, f); return v }; d.surfaceCoverageCompensationLocal = function (f,
            t, v) { return (f.fovY - v.tiltAngle) / f.fovY }; d.surfaceCoverageCompensationGlobal = function (f, t, v) { const m = t * t; v = v.tiltAngle + .5 * Math.PI; const { fovY: e, distance: g } = f; f = g * g + m - 2 * Math.cos(v) * g * t; const x = Math.sqrt(f); return (Math.acos(Math.sqrt(f - m) / x) - Math.asin(t / (x / Math.sin(v))) + .5 * e) / e }; w._createClass(b, [{ key: "paddingPixelsOverride", get: function () { return this._paddingPixelsOverride || this.parameters.paddingPixels } }]); return b
        }(); const p = {
          curvatureDependent: {
            min: {
              curvature: c.deg2rad(10), tiltAngle: c.deg2rad(12),
              scaleFallOffFactor: .5
            }, max: { curvature: c.deg2rad(70), tiltAngle: c.deg2rad(40), scaleFallOffFactor: .8 }
          }, scaleStart: .3, scaleFallOffRange: .65, minPixelSize: 0
        }, l = { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 }, h = { tiltAngle: 0, scaleFallOffFactor: 0 }; a.applyPrecomputedScaleFactor = function (b, d, f = [0, 0]) { d = Math.min(Math.max(d.scale, u(b[1], d) / b[1]), 1); f[0] = b[0] * d; f[1] = b[1] * d; return f }; a.applyScaleFactor = y; a.applyScaleFactorVec2 = function (b, d, f = [0, 0]) {
          const t = Math.min(Math.max(d.scale, u(b[1], d) / b[1]), 1); f[0] = c.lerp(b[0] *
            t, b[0], d.factor); f[1] = c.lerp(b[1] * t, b[1], d.factor); return f
        }; a.getLabelSettings = function (b, d) { const { curvatureDependent: f, scaleStart: t, scaleFallOffRange: v } = p; return new n(b, { curvatureDependent: { min: { curvature: f.min.curvature, tiltAngle: f.min.tiltAngle, scaleFallOffFactor: .7 }, max: { curvature: f.max.curvature, tiltAngle: f.max.tiltAngle, scaleFallOffFactor: .95 } }, scaleStart: t, scaleFallOffRange: v, minPixelSize: 14 }, d) }; a.getSettings = function (b, d) { return new n(b, p, d) }; a.precomputeScaleFactor = function (b, d, f, t) {
          b =
          q(b, d, f); b.minPixelSize = 0; b.paddingPixels = 0; b = y(1, b); t.scale = b; t.factor = 0; t.minPixelSize = f.parameters.minPixelSize; t.paddingPixels = f.paddingPixelsOverride
        }; a.scale = function (b, d, f, t) { return y(b, q(d, f, t)) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/HUDMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../core/libs/gl-matrix-2/types/mat4 ../../../../geometry/support/aaBoundingRect ../../support/buffer/InterleavedLayout ../lib/geometryDataUtils ../lib/GLMaterials ../lib/GLMaterialTexture ../lib/Material ../lib/screenSizePerspectiveUtils ../lib/Util ./internal/bufferWriterUtils ./internal/MaterialUtil ./renderers/utils ../../../../chunks/HUDMaterial.glsl ../shaders/HUDMaterialTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E) {
          function H(W, U, X, Z = L) { h.copy(Z, W.anchorPos); Z[0] *= -U[0]; Z[1] *= -U[1]; Z[0] += W.screenOffset[0] * X; Z[1] += W.screenOffset[1] * X; return Z } function J(W, U, X, Z, ia, la, ma, ra) {
            U = U - ia - (0 < ra[0] ? Z[0] * ra[0] : 0); let Aa = U + Z[0] + 2 * ia; X = X - ia - (0 < ra[1] ? Z[1] * ra[1] : 0); ia = X + Z[1] + 2 * ia; ma.textureIsSignedDistanceField && (ma = ma.distanceFieldBoundingBox, U += Z[0] * ma[0], X += Z[1] * ma[1], Aa -= Z[0] * (1 - ma[2]), ia -= Z[1] * (1 - ma[3]), U -= la, Aa += la, X -= la, ia += la); return W[0] > U && W[0] < Aa &&
              W[1] > X && W[1] < ia
          } let M = function (W) {
            function U(Z) { Z = W.call(this, Z, ea) || this; Z.techniqueConfig = new E.HUDMaterialTechniqueConfiguration; return Z } w._inheritsLoose(U, W); var X = U.prototype; X.getTechniqueConfig = function (Z, ia) {
              this.techniqueConfig.output = Z; this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this.techniqueConfig.verticalOffset = !!this.parameters.verticalOffset; this.techniqueConfig.screenSizePerspective = !!this.parameters.screenSizePerspective; this.techniqueConfig.screenCenterOffsetUnitsEnabled =
                "screen" === this.parameters.centerOffsetUnits ? 1 : 0; this.techniqueConfig.polygonOffsetEnabled = this.parameters.polygonOffset; this.techniqueConfig.isDraped = this.parameters.isDraped; this.techniqueConfig.occlusionTestEnabled = this.parameters.occlusionTest; this.techniqueConfig.pixelSnappingEnabled = this.parameters.pixelSnappingEnabled; this.techniqueConfig.sdf = this.parameters.textureIsSignedDistanceField; this.techniqueConfig.vvSize = !!this.parameters.vvSizeEnabled; this.techniqueConfig.vvColor = !!this.parameters.vvColorEnabled;
              0 === Z && (this.techniqueConfig.debugDrawBorder = !!this.parameters.debugDrawBorder); 4 === Z && (this.techniqueConfig.binaryHighlightOcclusion = this.parameters.binaryHighlightOcclusion); this.techniqueConfig.depthEnabled = this.parameters.depthEnabled; this.techniqueConfig.transparencyPassType = ia.transparencyPassType; this.techniqueConfig.multipassGeometryEnabled = ia.multipassGeometryEnabled; this.techniqueConfig.multipassTerrainEnabled = ia.multipassTerrainEnabled; this.techniqueConfig.cullAboveGround = ia.cullAboveGround;
              return this.techniqueConfig
            }; X.intersect = function (Z, ia, la, ma, ra, Aa, za, Ka, Ea) { q.isSome(Ea) ? this.intersectDrapedHudGeometry(Z, Aa, za, Ka, Ea) : this.intersectHudGeometry(Z, ia, la, ma, za, Ka) }; X.intersectDrapedHudGeometry = function (Z, ia, la, ma, ra) {
              const Aa = Z.vertexAttributes.get("position"), za = Z.vertexAttributes.get("size"), Ka = this.parameters, Ea = D.calculateAnchorPosForRendering(Ka); let Ua = 1; var Na = 1; q.isSome(ma) && (Na = ma(fa), Ua = Na[0], Na = Na[5]); Ua *= Z.screenToWorldRatio; Na *= Z.screenToWorldRatio; ma = 2 * Z.screenToWorldRatio;
              for (let pa = 0; pa < Aa.data.length / Aa.size; pa++) { var ya = pa * Aa.size; const wa = Aa.data[ya]; ya = Aa.data[ya + 1]; const Ia = pa * za.size; ha[0] = za.data[Ia] * Ua; ha[1] = za.data[Ia + 1] * Na; let Ha; Ka.textureIsSignedDistanceField && (Ha = Ka.outlineSize * Z.screenToWorldRatio / 2); J(ia, wa, ya, ha, ma, Ha, Ka, Ea) && la(ra.dist, ra.normal, -1, !0) }
            }; X.intersectHudGeometry = function (Z, ia, la, ma, ra, Aa) {
              if (ma.options.selectionMode && ma.options.hud && !C.isInstanceHidden(ia)) {
                ia = this.parameters; var za = 1, Ka = 1; y.fromMat4(S, la); if (q.isSome(Aa)) {
                  Ka = Aa(fa);
                  za = Ka[0]; Ka = Ka[5]; { Aa = S; var Ea = Aa[0], Ua = Aa[1], Na = Aa[2], ya = Aa[3], pa = Aa[4], wa = Aa[5], Ia = Aa[6], Ha = Aa[7], Oa = Aa[8], Ba = 1 / Math.sqrt(Ea * Ea + Ua * Ua + Na * Na); const sa = 1 / Math.sqrt(ya * ya + pa * pa + wa * wa), Ca = 1 / Math.sqrt(Ia * Ia + Ha * Ha + Oa * Oa); Aa[0] = Ea * Ba; Aa[1] = Ua * Ba; Aa[2] = Na * Ba; Aa[3] = ya * sa; Aa[4] = pa * sa; Aa[5] = wa * sa; Aa[6] = Ia * Ca; Aa[7] = Ha * Ca; Aa[8] = Oa * Ca }
                } Aa = Z.vertexAttributes.get("position"); Ea = Z.vertexAttributes.get("size"); Ua = Z.vertexAttributes.get("normal"); Z = Z.vertexAttributes.get("auxpos1"); A.assert(3 <= Aa.size); Na = ma.point;
                ya = ma.camera; pa = D.calculateAnchorPosForRendering(ia); za *= ya.pixelRatio; Ka *= ya.pixelRatio; wa = "screen" === this.parameters.centerOffsetUnits; for (Ia = 0; Ia < Aa.data.length / Aa.size; Ia++)if (Ha = Ia * Aa.size, d.set(N, Aa.data[Ha], Aa.data[Ha + 1], Aa.data[Ha + 2]), d.transformMat4(N, N, la), Ha = Ia * Ea.size, ha[0] = Ea.data[Ha] * za, ha[1] = Ea.data[Ha + 1] * Ka, d.transformMat4(N, N, ya.viewMatrix), Ha = Ia * Z.size, d.set(da, Z.data[Ha + 0], Z.data[Ha + 1], Z.data[Ha + 2]), wa || (N[0] += da[0], N[1] += da[1], 0 !== da[2] && (Ha = da[2], d.normalize(da, N), d.subtract(N,
                  N, d.scale(da, da, Ha)))), Ha = Ia * Ua.size, d.set(G, Ua.data[Ha], Ua.data[Ha + 1], Ua.data[Ha + 2]), this.normalAndViewAngle(G, S, ya, Y), this.applyVerticalOffsetTransformationView(N, Y, ya, P), ya.applyProjection(N, I), -1 < I[0]) {
                    Ha = Math.floor(I[0]) + this.parameters.screenOffset[0]; Oa = Math.floor(I[1]) + this.parameters.screenOffset[1]; wa && (Ha += da[0], 0 !== da[1] && (Oa += r.applyScaleFactor(da[1], P.factorAlignment))); r.applyPrecomputedScaleFactor(ha, P.factor, ha); Ba = 1 * ya.pixelRatio; let sa; ia.textureIsSignedDistanceField && (sa = ia.outlineSize *
                      ya.pixelRatio / 2); J(Na, Ha, Oa, ha, Ba, sa, ia, pa) && (Oa = ma.ray, d.transformMat4(R, N, p.invert(T, ya.viewMatrix)), I[0] = Na[0], I[1] = Na[1], ya.unprojectFromRenderScreen(I, N) && (Ha = f.create(), d.copy(Ha, Oa.direction), Ba = 1 / d.length(Ha), d.scale(Ha, Ha, Ba), Oa = d.distance(Oa.origin, N) * Ba, ra(Oa, Ha, -1, !0, 1, R)))
                }
              }
            }; X.computeAttachmentOrigin = function (Z, ia) { var la = Z.vertexAttributes; if (!la) return !1; la = la.get("position"); Z = Z.indices.get("position"); return e.computeAttachmentOriginPoints(la, Z, ia) }; X.createBufferWriter = function () { return new aa(this) };
            X.normalAndViewAngle = function (Z, ia, la, ma) { t.isMat4(ia) && (ia = y.fromMat4(Q, ia)); d.transformMat3(ma.normal, Z, ia); d.transformMat4(ma.normal, ma.normal, la.viewInverseTransposeMatrix); ma.cosAngle = d.dot(O, ka); return ma }; X.updateScaleInfo = function (Z, ia, la) {
              const ma = this.parameters; ma.screenSizePerspective ? r.precomputeScaleFactor(la, ia, ma.screenSizePerspective, Z.factor) : (Z.factor.scale = 1, Z.factor.factor = 0, Z.factor.minPixelSize = 0, Z.factor.paddingPixels = 0); ma.screenSizePerspectiveAlignment ? r.precomputeScaleFactor(la,
                ia, ma.screenSizePerspectiveAlignment, Z.factorAlignment) : (Z.factorAlignment.factor = Z.factor.factor, Z.factorAlignment.scale = Z.factor.scale, Z.factorAlignment.minPixelSize = Z.factor.minPixelSize, Z.factorAlignment.paddingPixels = Z.factor.paddingPixels)
            }; X.applyShaderOffsetsView = function (Z, ia, la, ma, ra, Aa, za) {
              ia = this.normalAndViewAngle(ia, la, ra, Y); this.applyVerticalGroundOffsetView(Z, ia, ra, za); this.applyVerticalOffsetTransformationView(za, ia, ra, Aa); this.applyPolygonOffsetView(za, ia, ma[3], ra, za); this.applyCenterOffsetView(za,
                ma, za); return za
            }; X.applyShaderOffsetsNDC = function (Z, ia, la, ma, ra) { this.applyCenterOffsetNDC(Z, ia, la, ma); q.isSome(ra) && d.copy(ra, ma); this.applyPolygonOffsetNDC(ma, ia, la, ma); return ma }; X.applyPolygonOffsetView = function (Z, ia, la, ma, ra) { var Aa = ma.aboveGround ? 1 : -1; la = Math.sign(la); 0 === la && (la = Aa); Aa *= la; if (0 >= this.parameters.shaderPolygonOffset) return d.copy(ra, Z); ia = c.clamp(Math.abs(ia.cosAngle), .01, 1); ma = 1 - Math.sqrt(1 - ia * ia) / ia / ma.viewport[2]; 0 < Aa ? d.scale(ra, Z, ma) : d.scale(ra, Z, 1 / ma); return ra }; X.applyVerticalGroundOffsetView =
              function (Z, ia, la, ma) { const ra = d.length(Z), Aa = la.aboveGround ? 1 : -1; la = .5 * la.computeRenderPixelSizeAtDist(ra); ia = d.scale(N, ia.normal, Aa * la); d.add(ma, Z, ia); return ma }; X.applyVerticalOffsetTransformationView = function (Z, ia, la, ma) {
                const ra = this.parameters; if (!ra.verticalOffset || !ra.verticalOffset.screenLength) { if (ra.screenSizePerspective || ra.screenSizePerspectiveAlignment) { var Aa = d.length(Z); this.updateScaleInfo(ma, Aa, ia.cosAngle) } else ma.factor.scale = 1, ma.factorAlignment.scale = 1; return Z } Aa = d.length(Z);
                la = B.verticalOffsetAtDistance(la, Aa, ra.verticalOffset, ia.cosAngle, ra.screenSizePerspectiveAlignment || ra.screenSizePerspective); this.updateScaleInfo(ma, Aa, ia.cosAngle); d.scale(ia.normal, ia.normal, la); return d.add(Z, Z, ia.normal)
              }; X.applyCenterOffsetView = function (Z, ia, la) { const ma = "screen" !== this.parameters.centerOffsetUnits; la !== Z && d.copy(la, Z); ma && (la[0] += ia[0], la[1] += ia[1], ia[2] && (d.normalize(G, la), d.add(la, la, d.scale(G, G, ia[2])))); return la }; X.applyCenterOffsetNDC = function (Z, ia, la, ma) {
                const ra = "screen" !==
                  this.parameters.centerOffsetUnits; ma !== Z && d.copy(ma, Z); ra || (ma[0] += ia[0] / la.fullWidth * 2, ma[1] += ia[1] / la.fullHeight * 2); return ma
              }; X.applyPolygonOffsetNDC = function (Z, ia, la, ma) { const ra = this.parameters.shaderPolygonOffset; Z !== ma && d.copy(ma, Z); ra && (Z = la.aboveGround ? 1 : -1, ma[2] -= (Z * Math.sign(ia[3]) || Z) * ra); return ma }; X.requiresSlot = function (Z, ia) {
                ia = g.outputFromPass(ia); if (0 === ia || 7 === ia) {
                  if (20 === Z) return !0; ia = this.parameters.drawInSecondSlot ? 17 : 16; return this.parameters.occlusionTest ? 11 === Z || Z === ia : Z ===
                    ia
                } return Z === (this.parameters.drawInSecondSlot ? 17 : 16) || 20 === Z
              }; X.createGLMaterial = function (Z) { return 0 === Z.output || 7 === Z.output ? new K(Z) : 4 === Z.output ? new F(Z) : null }; X.calculateRelativeScreenBounds = function (Z, ia, la = v.create()) { H(this.parameters, Z, ia, la); la[2] = la[0] + Z[0]; la[3] = la[1] + Z[1]; return la }; return U
          }(k.Material), F = function (W) {
            function U(Z) { return W.call(this, { ...Z, ...Z.material.parameters }) || this } w._inheritsLoose(U, W); var X = U.prototype; X.updateParameters = function (Z) {
              this.updateTexture(this._material.parameters.textureId);
              return this.selectProgram(Z)
            }; X.selectProgram = function (Z) { return this.ensureTechnique(E.HUDMaterialTechnique, Z) }; X.beginSlot = function (Z) { return this.updateParameters(Z) }; X.bind = function (Z, ia) { this.bindTextures(ia.program); this.bindTextureScale(ia.program); ia.bindPass(this._material.parameters, Z) }; return U
          }(x), K = function (W) {
            function U() { return W.apply(this, arguments) || this } w._inheritsLoose(U, W); var X = U.prototype; X.isOcclusionSlot = function (Z) {
              return 11 === Z.slot && this._material.parameters.occlusionTest &&
                (0 === this._output || 7 === this._output)
            }; X.selectProgram = function (Z) { return this.ensureTechnique(E.HUDMaterialTechnique, Z, this.isOcclusionSlot(Z) ? 6 : this._output) }; X.bind = function (Z, ia) { this.isOcclusionSlot(Z) || (this.bindTextures(ia.program), this.bindTextureScale(ia.program)); ia.bindPass(this._material.parameters, Z) }; return U
          }(F); const P = { factor: { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 }, factorAlignment: { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 } }, L = b.create(), N = f.create(), G = f.create(), I =
            u.createRenderScreenPointArray3(), O = f.create(), R = f.create(), S = n.create(), Q = n.create(), T = l.create(), da = f.create(), Y = { normal: O, cosAngle: 0 }, fa = l.create(), ha = [0, 0], ka = f.fromValues(0, 0, 1), ea = {
              texCoordScale: [1, 1], occlusionTest: !0, binaryHighlightOcclusion: !0, drawInSecondSlot: !1, color: [1, 1, 1, 1], outlineColor: [1, 1, 1, 1], outlineSize: 0, textureIsSignedDistanceField: !1, distanceFieldBoundingBox: null, vvSizeEnabled: !1, vvSizeMinSize: [1, 1, 1], vvSizeMaxSize: [100, 100, 100], vvSizeOffset: [0, 0, 0], vvSizeFactor: [1, 1, 1], vvColorEnabled: !1,
              vvColorValues: [0, 0, 0, 0, 0, 0, 0, 0], vvColorColors: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], screenOffset: [0, 0], verticalOffset: null, screenSizePerspective: null, screenSizePerspectiveAlignment: null, slicePlaneEnabled: !1, anchorPos: b.fromValues(.5, .5), shaderPolygonOffset: 1E-5, polygonOffset: !1, textureId: null, centerOffsetUnits: "world", depthEnabled: !0, pixelSnappingEnabled: !0, debugDrawBorder: !1, isDraped: !1, ...k.materialParametersDefaults
            }, ba = m.newLayout().vec3f("position").vec3f("normal").vec2f("uv0").vec4u8("color").vec2f("size").vec4f("auxpos1").vec4f("auxpos2");
          let aa = function () {
            function W(X) { this.material = X; this.vertexBufferLayout = ba } var U = W.prototype; U.allocate = function (X) { return this.vertexBufferLayout.createBuffer(X) }; U.elementCount = function (X) { return 6 * X.indices.get("position").length }; U.write = function (X, Z, ia, la) {
              z.writePosition(Z.indices.get("position"), Z.vertexAttributes.get("position").data, X.transformation, ia.position, la, 6); z.writeNormal(Z.indices.get("normal"), Z.vertexAttributes.get("normal").data, X.invTranspTransformation, ia.normal, la, 6); var ma =
                Z.vertexAttributes.get("uv0").data; if (null == ma || 4 > ma.length) { ma = this.material.parameters; var ra = X = 0; var Aa = ma.texCoordScale[0]; ma = ma.texCoordScale[1] } else X = ma[0], ra = ma[1], Aa = ma[2], ma = ma[3]; Aa = Math.min(1.99999, Aa + 1); ma = Math.min(1.99999, ma + 1); var za = Z.indices.get("position").length, Ka = ia.uv0, Ea = la; for (var Ua = 0; Ua < za; ++Ua)Ka.set(Ea, 0, X), Ka.set(Ea, 1, ra), Ea += 1, Ka.set(Ea, 0, Aa), Ka.set(Ea, 1, ra), Ea += 1, Ka.set(Ea, 0, Aa), Ka.set(Ea, 1, ma), Ea += 1, Ka.set(Ea, 0, Aa), Ka.set(Ea, 1, ma), Ea += 1, Ka.set(Ea, 0, X), Ka.set(Ea, 1, ma),
                  Ea += 1, Ka.set(Ea, 0, X), Ka.set(Ea, 1, ra), Ea += 1; z.writeColor(Z.indices.get("color"), Z.vertexAttributes.get("color").data, 4, ia.color, la, 6); X = Z.indices.get("size"); ra = Z.vertexAttributes.get("size").data; Aa = X.length; ma = ia.size; za = la; for (Ka = 0; Ka < Aa; ++Ka) { Ea = ra[2 * X[Ka]]; Ua = ra[2 * X[Ka] + 1]; for (let Na = 0; 6 > Na; ++Na)ma.set(za, 0, Ea), ma.set(za, 1, Ua), za += 1 } Z.indices.get("auxpos1") && Z.vertexAttributes.get("auxpos1") && z.writeBufferVec4(Z.indices.get("auxpos1"), Z.vertexAttributes.get("auxpos1").data, ia.auxpos1, la, 6); Z.indices.get("auxpos2") &&
                    Z.vertexAttributes.get("auxpos2") && z.writeBufferVec4(Z.indices.get("auxpos2"), Z.vertexAttributes.get("auxpos2").data, ia.auxpos2, la, 6)
            }; return W
          }(); a.HUDMaterial = M; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/libs/gl-matrix-2/types/mat4": function () {
      define(["exports"], function (a) {
        function w(q) { return q instanceof Float32Array && 16 <= q.length } function c(q) { return Array.isArray(q) && 16 <= q.length } a.isMat4 = function (q) { return w(q) || c(q) }; a.isMat4f32 = w; a.isMat4f64 = c; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/GLMaterials": function () {
      define(["exports", "../../../../core/maybe"], function (a, w) {
        function c(u) { switch (u) { default: case 0: return 0; case 1: return 7; case 4: return 3; case 3: return 2; case 2: return 1; case 5: return 4; case 7: return 3; case 6: return 3 } } let q = function () {
          function u(n, p) { this._material = n; this._repository = p; this._map = new Map } var y = u.prototype; y.destroy = function () {
            this._map.forEach((n, p) => {
              w.isSome(n) && this._repository.release(this._material,
                c(p))
            })
          }; y.load = function (n, p) { this._map.has(p) || this._map.set(p, this._repository.acquire(this._material, c(p))); p = this._map.get(p); if (w.isSome(p)) { if (2 === p.ensureResources(n)) return p; this._repository.requestRender() } return null }; return u
        }(); a.GLMaterials = q; a.outputFromPass = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/GLMaterialTexture": function () {
      define(["../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "./GLMaterial"], function (a, w, c) {
        return function (q) {
          function u(n) {
            var p =
              q.call(this, n) || this; p._numLoading = 0; p._disposed = !1; p._textureRepository = n.textureRep; p._textureId = n.textureId; p._acquire(n.textureId).then(l => p._texture = l); p._acquire(n.normalTextureId).then(l => p._textureNormal = l); p._acquire(n.emissiveTextureId).then(l => p._textureEmissive = l); p._acquire(n.occlusionTextureId).then(l => p._textureOcclusion = l); p._acquire(n.metallicRoughnessTextureId).then(l => p._textureMetallicRoughness = l); return p
          } a._inheritsLoose(u, q); var y = u.prototype; y.dispose = function () {
          this._texture =
            w.releaseMaybe(this._texture); this._textureNormal = w.releaseMaybe(this._textureNormal); this._textureEmissive = w.releaseMaybe(this._textureEmissive); this._textureOcclusion = w.releaseMaybe(this._textureOcclusion); this._textureMetallicRoughness = w.releaseMaybe(this._textureMetallicRoughness); this._disposed = !0
          }; y.ensureResources = function (n) { return 0 === this._numLoading ? 2 : 1 }; y.updateTexture = function (n) {
            if (w.isNone(this._texture) || n !== this._texture.id) this._texture = w.releaseMaybe(this._texture), this._textureId =
              n, this._acquire(this._textureId).then(p => this._texture = p)
          }; y.bindTextures = function (n) {
            w.isSome(this._texture) && n.bindTexture(this._texture.glTexture, "tex"); w.isSome(this._textureNormal) && n.bindTexture(this._textureNormal.glTexture, "normalTexture"); w.isSome(this._textureEmissive) && n.bindTexture(this._textureEmissive.glTexture, "texEmission"); w.isSome(this._textureOcclusion) && n.bindTexture(this._textureOcclusion.glTexture, "texOcclusion"); w.isSome(this._textureMetallicRoughness) && n.bindTexture(this._textureMetallicRoughness.glTexture,
              "texMetallicRoughness")
          }; y.bindTextureScale = function (n) { const p = w.isSome(this._texture) ? this._texture.glTexture : null; w.isSome(p) && p.descriptor.textureCoordinateScaleFactor ? n.setUniform2fv("textureCoordinateScaleFactor", p.descriptor.textureCoordinateScaleFactor) : n.setUniform2f("textureCoordinateScaleFactor", 1, 1) }; y._acquire = function (n) {
            if (w.isNone(n)) return Promise.resolve(null); ++this._numLoading; return this._textureRepository.acquire(n).then(p => this._disposed ? (w.releaseMaybe(p), null) : p).finally(() =>
              --this._numLoading)
          }; return u
        }(c)
      })
    }, "esri/views/3d/webgl-engine/lib/GLMaterial": function () {
      define(["../../../../chunks/_rollupPluginBabelHelpers"], function (a) {
        return function () {
          function w(q) { this._material = q.material; this._techniqueRep = q.techniqueRep; this._output = q.output } var c = w.prototype; c.dispose = function () { this._techniqueRep.release(this._technique) }; c.ensureTechnique = function (q, u, y = this._output) {
            return this._technique = this._techniqueRep.releaseAndAcquire(q, this._material.getTechniqueConfig(y,
              u), this._technique)
          }; c.ensureResources = function (q) { return 2 }; a._createClass(w, [{ key: "technique", get: function () { return this._technique } }]); return w
        }()
      })
    }, "esri/views/3d/webgl-engine/lib/Material": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ./ContentObject ./DefaultVertexAttributeLocations ../materials/internal/MaterialUtil".split(" "), function (a, w, c, q, u, y) {
        q = function (n) {
          function p(h, b) {
            var d = n.call(this) || this; d.type = 3; d.supportsEdges = !1; d._visible =
              !0; d._renderPriority = 0; d._insertOrder = 0; d._vertexAttributeLocations = u.Default3D; d._parameters = y.copyParameters(h, b); d.validateParameters(d._parameters); return d
          } w._inheritsLoose(p, n); var l = p.prototype; l.dispose = function () { }; l.update = function (h) { return !1 }; l.setParameters = function (h) { y.updateParameters(this._parameters, h) && (this.validateParameters(this._parameters), this.parametersChanged()) }; l.validateParameters = function (h) { }; l.shouldRender = function (h) {
            return this.isVisible() && this.isVisibleInPass(h.pass) &&
              0 !== (this.renderOccluded & h.renderOccludedMask)
          }; l.isVisibleInPass = function (h) { return !0 }; l.isVisible = function () { return this._visible }; l.parametersChanged = function () { c.isSome(this.repository) && this.repository.materialChanged(this) }; w._createClass(p, [{ key: "parameters", get: function () { return this._parameters } }, { key: "visible", get: function () { return this._visible }, set: function (h) { h !== this._visible && (this._visible = h, this.parametersChanged()) } }, { key: "renderOccluded", get: function () { return this.parameters.renderOccluded } },
          { key: "renderPriority", get: function () { return this._renderPriority }, set: function (h) { h !== this._renderPriority && (this._renderPriority = h, this.parametersChanged()) } }, { key: "insertOrder", get: function () { return this._insertOrder }, set: function (h) { h !== this._insertOrder && (this._insertOrder = h, this.parametersChanged()) } }, { key: "vertexAttributeLocations", get: function () { return this._vertexAttributeLocations } }]); return p
        }(q.ContentObject); a.Material = q; a.materialParametersDefaults = { renderOccluded: 1 }; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/internal/MaterialUtil": function () {
      define("exports ../../../../../core/mathUtils ../../../../../core/maybe ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/aaBoundingBox ../../lib/screenSizePerspectiveUtils ../../lib/Util ../renderers/utils".split(" "), function (a, w, c, q, u, y, n, p, l) {
        function h(z, B, C, D, E, H) {
          if (!c.isNone(z)) {
            var J = f(B, C, x); y.setMin(g, z.getBBMin()); y.setMax(g, z.getBBMax()); c.isSome(E) &&
              E.applyToAabb(g); if (t(g, B, J, D)) { const { primitiveIndices: M, indices: F, position: K } = z; J = M ? M.length : F.length / 3; if (1E3 < J && (z = z.getChildren(), void 0 !== z)) { for (J = 0; 8 > J; ++J)void 0 !== z[J] && h(z[J], B, C, D, E, H); return } b(B, C, 0, J, F, K, M, E, H) }
          }
        } function b(z, B, C, D, E, H, J, M, F) {
          if (J) {
            var K = H.data; H = H.stride || H.size; var P = z[0], L = z[1]; z = z[2]; var N = B[0] - P, G = B[1] - L; for (B = B[2] - z; C < D; ++C) {
              var I = J[C], O = 3 * I, R = H * E[O++], S = K[R++], Q = K[R++], T = K[R]; R = H * E[O++]; var da = K[R++], Y = K[R++], fa = K[R]; R = H * E[O]; O = K[R++]; var ha = K[R++]; R = K[R]; c.isSome(M) &&
                ([S, Q, T] = M.applyToVertex(S, Q, T, C), [da, Y, fa] = M.applyToVertex(da, Y, fa, C), [O, ha, R] = M.applyToVertex(O, ha, R, C)); da -= S; Y -= Q; fa -= T; O -= S; ha -= Q; R -= T; var ka = G * R - ha * B, ea = B * O - R * N; const aa = N * ha - O * G; var ba = da * ka + Y * ea + fa * aa; if (!(Math.abs(ba) <= Number.EPSILON)) {
                  S = P - S; Q = L - Q; T = z - T; ka = S * ka + Q * ea + T * aa; if (0 < ba) { if (0 > ka || ka > ba) continue } else if (0 < ka || ka < ba) continue; ea = Q * fa - Y * T; T = T * da - fa * S; Q = S * Y - da * Q; S = N * ea + G * T + B * Q; if (0 < ba) { if (0 > S || ka + S > ba) continue } else if (0 < S || ka + S < ba) continue; T = (O * ea + ha * T + R * Q) / ba; 0 <= T && (da = d(da, Y, fa, O, ha,
                    R, k), F(T, da, I, !1))
                }
            }
          } else {
            J = H.data; K = H.stride || H.size; H = z[0]; P = z[1]; L = z[2]; z = B[0] - H; N = B[1] - P; G = B[2] - L; for (let aa = C, W = 3 * C; aa < D; ++aa)if (O = K * E[W++], Q = J[O++], T = J[O++], fa = J[O], O = K * E[W++], B = J[O++], C = J[O++], I = J[O], O = K * E[W++], da = J[O++], Y = J[O++], O = J[O], c.isSome(M) && ([Q, T, fa] = M.applyToVertex(Q, T, fa, aa), [B, C, I] = M.applyToVertex(B, C, I, aa), [da, Y, O] = M.applyToVertex(da, Y, O, aa)), B -= Q, C -= T, I -= fa, da -= Q, Y -= T, O -= fa, R = N * O - Y * G, S = G * da - O * z, ba = z * Y - da * N, ha = B * R + C * S + I * ba, !(Math.abs(ha) <= Number.EPSILON)) {
              Q = H - Q; T = P - T; fa = L - fa; R =
                Q * R + T * S + fa * ba; if (0 < ha) { if (0 > R || R > ha) continue } else if (0 < R || R < ha) continue; S = T * I - C * fa; fa = fa * B - I * Q; T = Q * C - B * T; Q = z * S + N * fa + G * T; if (0 < ha) { if (0 > Q || R + Q > ha) continue } else if (0 < Q || R + Q < ha) continue; fa = (da * S + Y * fa + O * T) / ha; 0 <= fa && (B = d(B, C, I, da, Y, O, k), F(fa, B, aa, !1))
            }
          }
        } function d(z, B, C, D, E, H, J) { q.set(r, z, B, C); q.set(A, D, E, H); q.cross(J, r, A); q.normalize(J, J); return J } function f(z, B, C) { return q.set(C, 1 / (B[0] - z[0]), 1 / (B[1] - z[1]), 1 / (B[2] - z[2])) } function t(z, B, C, D) { return v(z, B, C, D, Infinity) } function v(z, B, C, D, E) {
          var H = (z[0] -
            D - B[0]) * C[0], J = (z[3] + D - B[0]) * C[0]; let M = Math.min(H, J); H = Math.max(H, J); J = (z[1] - D - B[1]) * C[1]; const F = (z[4] + D - B[1]) * C[1]; H = Math.min(H, Math.max(J, F)); if (0 > H) return !1; M = Math.max(M, Math.min(J, F)); if (M > H) return !1; J = (z[2] - D - B[2]) * C[2]; z = (z[5] + D - B[2]) * C[2]; H = Math.min(H, Math.max(J, z)); if (0 > H) return !1; M = Math.max(M, Math.min(J, z)); return M > H ? !1 : M < E
        } function m(z, B) { B = B ? m(B) : {}; for (const C in z) { let D = z[C]; D && D.forEach && (D = e(D)); null == D && C in B || (B[C] = D) } return B } function e(z) {
          const B = []; z.forEach(C => B.push(C));
          return B
        } const g = y.create(), x = u.create(), k = u.create(), r = u.create(), A = u.create(); a.bindScreenSizePerspective = function (z, B, C) { if (z) { var D = z.parameters; B.setUniform4f(C, D.divisor, D.offset, D.minPixelSize, z.paddingPixelsOverride) } }; a.colorMixModes = { multiply: 1, ignore: 2, replace: 3, tint: 4 }; a.computeInvDir = f; a.computeNormal = d; a.copyParameters = m; a.intersectAabbInvDir = t; a.intersectAabbInvDirBefore = v; a.intersectDrapedRenderLineGeometry = function (z, B, C, D, E, H) {
          if (B.options.selectionMode) {
            B = z.vertexAttributes.get("position").data;
            var J = z.vertexAttributes.get("size"), M = D[0]; D = D[1]; z = (((J && J.data[0]) + E) / 2 + 4) * z.screenToWorldRatio; E = Number.MAX_VALUE; J = 0; for (let N = 0; N < B.length - 5; N += 3) { var F = B[N], K = B[N + 1], P = M - F, L = D - K; F = B[N + 3] - F; K = B[N + 4] - K; const G = w.clamp((F * P + K * L) / (F * F + K * K), 0, 1); P = F * G - P; L = K * G - L; L = P * P + L * L; L < E && (E = L, J = N / 3) } E < z * z && H(C.dist, C.normal, J, !1)
          }
        }; a.intersectTriangleGeometry = function (z, B, C, D, E, H, J) {
          l.isInstanceHidden(B) || (z.boundingInfo ? (p.assert(0 === z.primitiveType), h(z.boundingInfo, D, E, C.tolerance, H, J)) : (B = z.indices.get("position"),
            z = z.vertexAttributes.get("position"), b(D, E, 0, B.length / 3, B, z, void 0, H, J)))
        }; a.intersectTriangles = b; a.updateParameters = function (z, B) { let C = !1; for (const D in B) { const E = B[D]; void 0 !== E && (C = !0, Array.isArray(E) ? z[D] = E.slice() : z[D] = E) } return C }; a.verticalOffsetAtDistance = function (z, B, C, D, E) { let H = (C.screenLength || 0) * z.pixelRatio; E && (H = n.scale(H, D, B, E)); return w.clamp(H * Math.tan(.5 * z.fovY) / (.5 * z.fullHeight) * B, C.minWorldLength || 0, null != C.maxWorldLength ? C.maxWorldLength : Infinity) }; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/internal/bufferWriterUtils": function () {
      define(["exports", "../../../../../chunks/mat4", "../../../../../geometry/support/buffer/BufferView", "../../lib/Util"], function (a, w, c, q) {
        function u(d, f, t, v) { const m = t.typedBuffer; t = t.typedBufferStride; const e = d.length; v *= t; for (let g = 0; g < e; ++g) { const x = 2 * d[g]; m[v] = f[x]; m[v + 1] = f[x + 1]; v += t } } function y(d, f, t, v, m) {
          const e = t.typedBuffer; t = t.typedBufferStride; const g = d.length; v *= t; if (null == m || 1 === m) for (m =
            0; m < g; ++m) { var x = 3 * d[m]; e[v] = f[x]; e[v + 1] = f[x + 1]; e[v + 2] = f[x + 2]; v += t } else for (x = 0; x < g; ++x) { const k = 3 * d[x]; for (let r = 0; r < m; ++r)e[v] = f[k], e[v + 1] = f[k + 1], e[v + 2] = f[k + 2], v += t }
        } function n(d, f, t, v, m = 1) { const e = t.typedBuffer; t = t.typedBufferStride; const g = d.length; v *= t; if (1 === m) for (m = 0; m < g; ++m) { var x = 4 * d[m]; e[v] = f[x]; e[v + 1] = f[x + 1]; e[v + 2] = f[x + 2]; e[v + 3] = f[x + 3]; v += t } else for (x = 0; x < g; ++x) { const k = 4 * d[x]; for (let r = 0; r < m; ++r)e[v] = f[k], e[v + 1] = f[k + 1], e[v + 2] = f[k + 2], e[v + 3] = f[k + 3], v += t } } function p(d, f, t, v, m, e = 1) {
          if (t) {
            var g =
              v.typedBuffer; v = v.typedBufferStride; var x = d.length, k = t[0], r = t[1], A = t[2], z = t[4], B = t[5], C = t[6], D = t[8], E = t[9], H = t[10], J = t[12], M = t[13]; t = t[14]; m *= v; if (1 === e) for (e = 0; e < x; ++e) { var F = 3 * d[e], K = f[F], P = f[F + 1]; F = f[F + 2]; g[m] = k * K + z * P + D * F + J; g[m + 1] = r * K + B * P + E * F + M; g[m + 2] = A * K + C * P + H * F + t; m += v } else for (K = 0; K < x; ++K) { P = 3 * d[K]; var L = f[P], N = f[P + 1]; const G = f[P + 2]; P = k * L + z * N + D * G + J; F = r * L + B * N + E * G + M; L = A * L + C * N + H * G + t; for (N = 0; N < e; ++N)g[m] = P, g[m + 1] = F, g[m + 2] = L, m += v }
          } else y(d, f, v, m, e)
        } function l(d, f, t, v, m, e = 1) {
          if (t) {
            var g = v.typedBuffer;
            v = v.typedBufferStride; var x = d.length, k = t[0], r = t[1], A = t[2], z = t[4], B = t[5], C = t[6], D = t[8], E = t[9], H = t[10]; t = !w.isOrthoNormal(t); m *= v; if (1 === e) for (e = 0; e < x; ++e) { var J = 3 * d[e], M = f[J], F = f[J + 1], K = f[J + 2]; J = k * M + z * F + D * K; var P = r * M + B * F + E * K; M = A * M + C * F + H * K; t && (F = J * J + P * P + M * M, .999999 > F && 1E-6 < F && (F = 1 / Math.sqrt(F), J *= F, P *= F, M *= F)); g[m + 0] = J; g[m + 1] = P; g[m + 2] = M; m += v } else for (J = 0; J < x; ++J) {
              P = 3 * d[J]; F = f[P]; K = f[P + 1]; const L = f[P + 2]; P = k * F + z * K + D * L; M = r * F + B * K + E * L; F = A * F + C * K + H * L; t && (K = P * P + M * M + F * F, .999999 > K && 1E-6 < K && (K = 1 / Math.sqrt(K),
                P *= K, M *= K, F *= K)); for (K = 0; K < e; ++K)g[m + 0] = P, g[m + 1] = M, g[m + 2] = F, m += v
            }
          } else y(d, f, v, m, e)
        } function h(d, f, t, v, m, e = 1) {
          if (t) {
            var g = v.typedBuffer; v = v.typedBufferStride; var x = d.length, k = t[0], r = t[1], A = t[2], z = t[4], B = t[5], C = t[6], D = t[8], E = t[9], H = t[10]; t = !w.isOrthoNormal(t); m *= v; if (1 === e) for (e = 0; e < x; ++e) { var J = 4 * d[e], M = f[J], F = f[J + 1], K = f[J + 2]; J = f[J + 3]; var P = k * M + z * F + D * K, L = r * M + B * F + E * K; M = A * M + C * F + H * K; t && (F = P * P + L * L + M * M, .999999 > F && 1E-6 < F && (F = 1 / Math.sqrt(F), P *= F, L *= F, M *= F)); g[m + 0] = P; g[m + 1] = L; g[m + 2] = M; g[m + 3] = J; m += v } else for (J =
              0; J < x; ++J) { P = 4 * d[J]; F = f[P]; K = f[P + 1]; const N = f[P + 2]; P = f[P + 3]; L = k * F + z * K + D * N; M = r * F + B * K + E * N; F = A * F + C * K + H * N; t && (K = L * L + M * M + F * F, .999999 > K && 1E-6 < K && (K = 1 / Math.sqrt(K), L *= K, M *= K, F *= K)); for (K = 0; K < e; ++K)g[m + 0] = L, g[m + 1] = M, g[m + 2] = F, g[m + 3] = P, m += v }
          } else n(d, f, v, m, e)
        } function b(d, f, t, v, m, e = 1) {
          const g = v.typedBuffer; v = v.typedBufferStride; const x = d.length; m *= v; if (1 === e) if (4 === t) for (e = 0; e < x; ++e)t = 4 * d[e], g[m] = f[t], g[m + 1] = f[t + 1], g[m + 2] = f[t + 2], g[m + 3] = f[t + 3], m += v; else {
            if (3 === t) for (e = 0; e < x; ++e)t = 3 * d[e], g[m] = f[t], g[m + 1] = f[t +
              1], g[m + 2] = f[t + 2], g[m + 3] = 255, m += v
          } else if (4 === t) for (t = 0; t < x; ++t) { var k = 4 * d[t]; for (var r = 0; r < e; ++r)g[m] = f[k], g[m + 1] = f[k + 1], g[m + 2] = f[k + 2], g[m + 3] = f[k + 3], m += v } else if (3 === t) for (t = 0; t < x; ++t)for (k = 3 * d[t], r = 0; r < e; ++r)g[m] = f[k], g[m + 1] = f[k + 1], g[m + 2] = f[k + 2], g[m + 3] = 255, m += v
        } a.writeBufferMat3f = function (d, f, t, v) { const m = t.typedBuffer; t = t.typedBufferStride; const e = d.length; v *= t; for (let g = 0; g < e; ++g) { const x = 9 * d[g]; for (let k = 0; 9 > k; ++k)m[v + k] = f[x + k]; v += t } }; a.writeBufferMat4f = function (d, f, t, v) {
          const m = t.typedBuffer;
          t = t.typedBufferStride; const e = d.length; v *= t; for (let g = 0; g < e; ++g) { const x = 16 * d[g]; for (let k = 0; 16 > k; ++k)m[v + k] = f[x + k]; v += t }
        }; a.writeBufferVec2 = u; a.writeBufferVec3 = y; a.writeBufferVec4 = n; a.writeColor = b; a.writeDefaultAttributes = function (d, f, t, v, m, e) {
          for (const x of f.fieldNames) {
            f = d.vertexAttributes.get(x); const k = d.indices.get(x); if (f && k) switch (x) {
              case "position": q.assert(3 === f.size); var g = m.getField(x, c.BufferViewVec3f); g && p(k, f.data, t, g, e); break; case "normal": q.assert(3 === f.size); (g = m.getField(x, c.BufferViewVec3f)) &&
                l(k, f.data, v, g, e); break; case "uv0": q.assert(2 === f.size); (g = m.getField(x, c.BufferViewVec2f)) && u(k, f.data, g, e); break; case "color": q.assert(3 === f.size || 4 === f.size); (g = m.getField(x, c.BufferViewVec4u8)) && b(k, f.data, f.size, g, e); break; case "symbolColor": q.assert(3 === f.size || 4 === f.size); (g = m.getField(x, c.BufferViewVec4u8)) && b(k, f.data, f.size, g, e); break; case "tangent": q.assert(4 === f.size), (g = m.getField(x, c.BufferViewVec4f)) && h(k, f.data, v, g, e)
            }
          }
        }; a.writeNormal = l; a.writePosition = p; a.writeTangent = h; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/chunks/HUDMaterial.glsl": function () {
      define("exports ./vec2 ./vec2f64 ./vec4f64 ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl ../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl ../views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          function e(r) {
            const A = new m.ShaderBuilder; var z = r.signedDistanceFieldEnabled; A.include(y.AlignPixel); A.include(n.HUD, r); A.include(u.Slice, r); if (6 === r.output) return A.include(p.HUDOcclusionPass, r), A; A.include(t.ScreenSizePerspective); A.fragment.include(f.RgbaFloatEncoding); A.fragment.include(d.ColorConversion); A.include(h.VisualVariables, r); A.varyings.add("vcolor", "vec4"); A.varyings.add("vtc", "vec2"); A.varyings.add("vsize", "vec2"); r.binaryHighlightOcclusionEnabled &&
              A.varyings.add("voccluded", "float"); A.vertex.uniforms.add("screenOffset", "vec2").add("anchorPos", "vec2").add("textureCoordinateScaleFactor", "vec2").add("materialColor", "vec4"); z && A.vertex.uniforms.add("outlineColor", "vec4"); r.screenSizePerspectiveEnabled && A.vertex.uniforms.add("screenSizePerspective", "vec4"); (r.debugDrawBorder || r.binaryHighlightOcclusionEnabled) && A.varyings.add("debugBorderCoords", "vec4"); A.attributes.add("uv0", "vec2"); A.attributes.add("color", "vec4"); A.attributes.add("size", "vec2");
            A.attributes.add("auxpos2", "vec4"); A.vertex.code.add(v.glsl`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${r.screenSizePerspectiveEnabled ? v.glsl`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `: v.glsl`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${r.vvSize ? "inputSize *\x3d vvScale(auxpos2).xx;" : ""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${r.occlusionTestEnabled || r.binaryHighlightOcclusionEnabled ? "bool visible \x3d testVisibilityHUD(posProj);" : ""}

      ${r.binaryHighlightOcclusionEnabled ? "voccluded \x3d visible ? 0.0 : 1.0;" : ""}
    `); var B = v.glsl`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`; const C = r.pixelSnappingEnabled ? z ? v.glsl`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;` : v.glsl`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`: v.glsl`posProj += quadOffset;`; A.vertex.code.add(v.glsl`
      ${r.occlusionTestEnabled ? "if (visible) {" : ""}
      ${B}
      ${r.vvColor ? "vcolor \x3d vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;" : "vcolor \x3d color / 255.0 * materialColor;"}

      bool alphaDiscard = vcolor.a < ${v.glsl.float(b.symbolAlphaCutoff)};
      ${z ? `alphaDiscard = alphaDiscard && outlineColor.a < ${v.glsl.float(b.symbolAlphaCutoff)};` : ""}
      if (alphaDiscard) {
        // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      } else {
        ${C}
        gl_Position = posProj;
      }

      vtc = uv * textureCoordinateScaleFactor;

      ${r.debugDrawBorder ? "debugBorderCoords \x3d vec4(uv01, 1.5 / combinedSize);" : ""}
      vsize = inputSize;
      ${r.occlusionTestEnabled ? v.glsl`} else { vtc = vec2(0.0);
        ${r.debugDrawBorder ? "debugBorderCoords \x3d vec4(0.5, 0.5, 1.5 / combinedSize);}" : "}"}` : ""}
    }
    `); A.fragment.uniforms.add("tex", "sampler2D"); z && (A.fragment.uniforms.add("outlineColor", "vec4"), A.fragment.uniforms.add("outlineSize", "float")); B = r.debugDrawBorder ? v.glsl`(isBorder > 0.0 ? 0.0 : ${v.glsl.float(b.defaultMaskAlphaCutoff)})` : v.glsl.float(b.defaultMaskAlphaCutoff); z = v.glsl`
    ${r.debugDrawBorder ? v.glsl`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`: ""}

    ${z ? v.glsl`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = 128.0;
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${B} ||
          fillPixelColor.a + outlinePixelColor.a < ${v.glsl.float(b.symbolAlphaCutoff)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        gl_FragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${B}) {
          discard;
        }

        gl_FragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `: v.glsl`
          vec4 texColor = texture2D(tex, vtc, -0.5);
          if (texColor.a < ${B}) {
            discard;
          }
          gl_FragColor = texColor * premultiplyAlpha(vcolor);
          `}

    ${r.debugDrawBorder ? v.glsl`gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);` : ""}
  `; 7 === r.output && A.fragment.code.add(v.glsl`
      void main() {
        ${z}
        gl_FragColor = vec4(gl_FragColor.a);
      }
      `); 0 === r.output && A.fragment.code.add(v.glsl`
    void main() {
      ${z}
      ${r.FrontFacePass ? "gl_FragColor.rgb /\x3d gl_FragColor.a;" : ""}
    }
    `); 4 === r.output && (A.include(l.OutputHighlight), A.fragment.code.add(v.glsl`
    void main() {
      ${z}
      ${r.binaryHighlightOcclusionEnabled ? v.glsl`
          if (voccluded == 1.0) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }`: "outputHighlight();"}
    }
    `)); return A
          } function g(r, A, z) { r.setUniform4fv("materialColor", A.color); A.textureIsSignedDistanceField && (0 >= A.outlineColor[3] || 0 >= A.outlineSize ? (r.setUniform4fv("outlineColor", q.ZEROS), r.setUniform1f("outlineSize", 0)) : (r.setUniform4fv("outlineColor", A.outlineColor), r.setUniform1f("outlineSize", A.outlineSize))); r.setUniform2f("screenOffset", 2 * A.screenOffset[0] * z, 2 * A.screenOffset[1] * z); r.setUniform2fv("anchorPos", x(A)) } function x(r, A = k) {
            if (r.textureIsSignedDistanceField) {
              var z = r.anchorPos; r = r.distanceFieldBoundingBox;
              A[0] = z[0] * (r[2] - r[0]) + r[0]; A[1] = z[1] * (r[3] - r[1]) + r[1]
            } else w.copy(A, r.anchorPos); return A
          } const k = c.create(); c = Object.freeze({ __proto__: null, build: e, bindHUDMaterialUniforms: g, calculateAnchorPosForRendering: x }); a.HUDMaterialShader = c; a.bindHUDMaterialUniforms = g; a.build = e; a.calculateAnchorPosForRendering = x
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl": function () {
      define(["exports", "../../../../../core/maybe", "../../../../../chunks/vec3", "../../../../../chunks/vec3f64", "../shaderModules/interfaces"],
        function (a, w, c, q, u) {
          function y(p, l, h, b) {
             l.slicePlaneEnabled && (w.isSome(h) ? (b ? (c.subtract(n, h.origin, b),
              p.setUniform3fv("slicePlaneOrigin", n)) : p.setUniform3fv("slicePlaneOrigin", h.origin), 
              p.setUniform3fv("slicePlaneBasis1", h.basis1), 
              p.setUniform3fv("slicePlaneBasis2", h.basis2),
              h.cut ? p.setUniform1f("isCut", h.cut) : p.setUniform1f("isCut", false),
              h.num && p.setUniform1f("pNum", h.num),
              h.polygon && p.setUniform3fv("slicePoint1", [h.polygon[0].x, h.polygon[0].y, h.polygon[0].z]),
              h.polygon && p.setUniform3fv("slicePoint2", [h.polygon[1].x, h.polygon[1].y, h.polygon[1].z]),
              h.polygon && p.setUniform3fv("slicePoint3", [h.polygon[2].x, h.polygon[2].y, h.polygon[2].z]),
              h.polygon && p.setUniform3fv("slicePoint4", [h.polygon[3].x, h.polygon[3].y, h.polygon[3].z]),
              h.polygon && p.setUniform3fv("slicePoint5", [h.polygon[4].x, h.polygon[4].y, h.polygon[4].z]),
              h.polygon && p.setUniform3fv("slicePoint6", [h.polygon[5].x, h.polygon[5].y, h.polygon[5].z]),
              h.polygon && p.setUniform3fv("slicePoint7", [h.polygon[6].x, h.polygon[6].y, h.polygon[6].z]),
              h.polygon && p.setUniform3fv("slicePoint8", [h.polygon[7].x, h.polygon[7].y, h.polygon[7].z]),
              h.polygon && p.setUniform3fv("slicePoint9", [h.polygon[8].x, h.polygon[8].y, h.polygon[8].z]),
              h.polygon && p.setUniform3fv("slicePoint10", [h.polygon[9].x, h.polygon[9].y, h.polygon[9].z])) : (
                p.setUniform3fv("slicePlaneBasis1", q.ZEROS), 
              p.setUniform3fv("slicePlaneBasis2", q.ZEROS),
               p.setUniform3fv("slicePlaneOrigin", q.ZEROS),
               p.setUniform1f("isCut", false),
               p.setUniform1f("pNum", 0.0),
               p.setUniform3fv("slicePoint1", q.ZEROS),
               p.setUniform3fv("slicePoint2", q.ZEROS),
               p.setUniform3fv("slicePoint3", q.ZEROS),
               p.setUniform3fv("slicePoint4", q.ZEROS),
               p.setUniform3fv("slicePoint5", q.ZEROS),
               p.setUniform3fv("slicePoint6", q.ZEROS),
               p.setUniform3fv("slicePoint7", q.ZEROS),
               p.setUniform3fv("slicePoint8", q.ZEROS),
               p.setUniform3fv("slicePoint9", q.ZEROS),
               p.setUniform3fv("slicePoint10", q.ZEROS))) 
            } const n = q.create(); a.Slice = function (p, l) {
            if (l.slicePlaneEnabled) {
              p.extensions.add("GL_OES_standard_derivatives");
              l.sliceEnabledForVertexPrograms && (
                p.vertex.uniforms.add("slicePlaneOrigin", "vec3"), 
              p.vertex.uniforms.add("slicePlaneBasis1", "vec3"), 
              p.vertex.uniforms.add("slicePlaneBasis2", "vec3"),
              p.vertex.uniforms.add("isCut", "bool"),
              p.vertex.uniforms.add("pNum", "float"),
              p.vertex.uniforms.add("slicePoint1", "vec3"),
              p.vertex.uniforms.add("slicePoint2", "vec3"),
              p.vertex.uniforms.add("slicePoint3", "vec3"),
              p.vertex.uniforms.add("slicePoint4", "vec3"),
              p.vertex.uniforms.add("slicePoint5", "vec3"),
              p.vertex.uniforms.add("slicePoint6", "vec3"),
              p.vertex.uniforms.add("slicePoint7", "vec3"),
              p.vertex.uniforms.add("slicePoint8", "vec3"),
              p.vertex.uniforms.add("slicePoint9", "vec3"),
              p.vertex.uniforms.add("slicePoint10", "vec3")); 
              p.fragment.uniforms.add("slicePlaneOrigin", "vec3"); 
              p.fragment.uniforms.add("slicePlaneBasis1", "vec3"); 
              p.fragment.uniforms.add("slicePlaneBasis2", "vec3"); 
              p.fragment.uniforms.add("isCut", "bool");
              p.fragment.uniforms.add("pNum", "float");
              p.fragment.uniforms.add("slicePoint1", "vec3");
              p.fragment.uniforms.add("slicePoint2", "vec3");
              p.fragment.uniforms.add("slicePoint3", "vec3");
              p.fragment.uniforms.add("slicePoint4", "vec3");
              p.fragment.uniforms.add("slicePoint5", "vec3");
              p.fragment.uniforms.add("slicePoint6", "vec3");
              p.fragment.uniforms.add("slicePoint7", "vec3");
              p.fragment.uniforms.add("slicePoint8", "vec3");
              p.fragment.uniforms.add("slicePoint9", "vec3");
              p.fragment.uniforms.add("slicePoint10", "vec3");
              var h = u.glsl`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
bool inside;
bool iscut;
};
bool caculateSide(vec3 VecPoint1, vec3 VecPoint2, vec3 Rel){
  float L1=length(VecPoint1);
  float L2= length(VecPoint2);
  float LR= length(Rel);
  float m1=L1/LR;
  float m2=L2/LR;
 
  vec3 v1 = cross(VecPoint1,VecPoint2);
  vec3 v2 = cross(VecPoint1,Rel);
  float dot_1=dot(v1,v2);

  vec3 v3 = cross(VecPoint2,VecPoint1);
  vec3 v4 = cross(VecPoint2,Rel);
  float dot_2=dot(v3,v4);

  vec3 v5 = cross(VecPoint1-VecPoint2,-VecPoint2);
  vec3 v6 = cross(VecPoint1-VecPoint2,Rel-VecPoint2);
  float dot_3=dot(v5,v6);

  bool line1=(m1*Rel.x==VecPoint1.x)&&dot(VecPoint1,Rel)>0.0;
  bool line2=(m2*Rel.x==VecPoint2.x)&&dot(VecPoint2,Rel)>0.0;

  return (dot_1>0.0&&dot_2>0.0&&dot_3>0.0)||line1||line2;
}
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);

vec3 P=pos;
bool inside=false;
if(isCut){
  if(pNum==3.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel);
  }else if(pNum==4.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel);
  }else if(pNum==5.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel)||caculateSide(slicePoint4,slicePoint5,rel);
  }else if(pNum==6.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel)||caculateSide(slicePoint4,slicePoint5,rel)||caculateSide(slicePoint5,slicePoint6,rel);
  }else if(pNum==7.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel)||caculateSide(slicePoint4,slicePoint5,rel)||caculateSide(slicePoint5,slicePoint6,rel)||caculateSide(slicePoint6,slicePoint7,rel);
  }else if(pNum==8.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel)||caculateSide(slicePoint4,slicePoint5,rel)||caculateSide(slicePoint5,slicePoint6,rel)||caculateSide(slicePoint6,slicePoint7,rel)||caculateSide(slicePoint7,slicePoint8,rel);
  }else if(pNum==9.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel)||caculateSide(slicePoint4,slicePoint5,rel)||caculateSide(slicePoint5,slicePoint6,rel)||caculateSide(slicePoint6,slicePoint7,rel)||caculateSide(slicePoint7,slicePoint8,rel)||caculateSide(slicePoint8,slicePoint9,rel);
  }else if(pNum==10.0){
    inside=caculateSide(slicePoint2,slicePoint3,rel)||caculateSide(slicePoint3,slicePoint4,rel)||caculateSide(slicePoint4,slicePoint5,rel)||caculateSide(slicePoint5,slicePoint6,rel)||caculateSide(slicePoint6,slicePoint7,rel)||caculateSide(slicePoint7,slicePoint8,rel)||caculateSide(slicePoint8,slicePoint9,rel)||caculateSide(slicePoint9,slicePoint10,rel);
  }
}

return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2,
inside,
isCut
);
}
bool sliceByFactors(SliceFactors factors) {
  if(factors.iscut){
    return factors.inside;
  }else{
    return factors.front < 0.0
    &&factors.side0 < 0.0
    && factors.side1 < 0.0
    && factors.side2 < 0.0
    && factors.side3 < 0.0;
  }
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`, b = u.glsl`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
if (sliceByFactors(factors)) {
  if(factors.iscut){
    return vec4(0.0,0.0,0.0,0.0);
  }else{
    return color;
  }
}
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`; b = l.sliceHighlightDisabled ? u.glsl`#define highlightSlice(_color_, _pos_) (_color_)` : u.glsl`
        ${b}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      `; l.sliceEnabledForVertexPrograms && p.vertex.code.add(h); p.fragment.code.add(h); p.fragment.code.add(b)
            } else h = u.glsl`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`, l.sliceEnabledForVertexPrograms && p.vertex.code.add(h), p.fragment.code.add(h)
          }; a.bindSliceUniforms = y; a.bindSliceUniformsWithOrigin = function (p, l, h) { y(p, l, h.slicePlane, h.origin) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl": function () {
      define(["exports", "../util/ScreenSizePerspective.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.HUD = function (q, u) {
        q.include(w.ScreenSizePerspective);
        q.attributes.add("position", "vec3"); q.attributes.add("normal", "vec3"); q.attributes.add("auxpos1", "vec4"); q.vertex.uniforms.add("proj", "mat4"); q.vertex.uniforms.add("view", "mat4"); q.vertex.uniforms.add("viewNormal", "mat4"); q.vertex.uniforms.add("viewport", "vec4"); q.vertex.uniforms.add("camPos", "vec3"); q.vertex.uniforms.add("polygonOffset", "float"); q.vertex.uniforms.add("cameraGroundRelative", "float"); q.vertex.uniforms.add("pixelRatio", "float"); q.vertex.uniforms.add("perDistancePixelRatio", "float");
        q.vertex.uniforms.add("uRenderTransparentlyOccludedHUD", "float"); u.verticalOffsetEnabled && q.vertex.uniforms.add("verticalOffset", "vec4"); u.screenSizePerspectiveEnabled && q.vertex.uniforms.add("screenSizePerspectiveAlignment", "vec4"); q.vertex.uniforms.add("hudVisibilityTexture", "sampler2D"); q.vertex.constants.add("smallOffsetAngle", "float", .984807753012208); q.vertex.code.add(c.glsl`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`); q.vertex.code.add(c.glsl`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
float pointGroundSign = sign(pointGroundDistance);
if (pointGroundSign == 0.0) {
pointGroundSign = cameraGroundRelative;
}
float groundRelative = cameraGroundRelative * pointGroundSign;
if (polygonOffset > .0) {
float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
float factor = (1.0 - tanAlpha / viewport[2]);
if (groundRelative > 0.0) {
posView *= factor;
}
else {
posView /= factor;
}
}
return groundRelative;
}`); u.isDraped || q.vertex.code.add(c.glsl`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
float distanceToCamera = length(posView);
float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;
vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;
vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
posModel += modelOffset;
posView += viewOffset;
}`); q.vertex.code.add(c.glsl`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      // centerOffset is in view space and is used to implement world size offsetting
      // of labels with respect to objects. It also pulls the label towards the viewer
      // so that the label is visible in front of the object.
      vec3 centerOffset = auxpos1.xyz;

      // The pointGroundDistance is the distance of the geometry to the ground and is
      // negative if the point is below the ground, or positive if the point is above
      // ground.
      float pointGroundDistance = auxpos1.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${u.isDraped ? "" : "applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(camPos - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${u.screenSizePerspectiveEnabled ? u.verticalOffsetEnabled || 1 === u.screenCenterOffsetUnitsEnabled ? "vec4 perspectiveFactor \x3d screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);" : "" : ""}

      ${u.verticalOffsetEnabled ? u.screenSizePerspectiveEnabled ? "float verticalOffsetScreenHeight \x3d applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);" : "float verticalOffsetScreenHeight \x3d verticalOffset.x;" : ""}

      ${u.verticalOffsetEnabled ? c.glsl`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`: ""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${1 !== u.screenCenterOffsetUnitsEnabled ? c.glsl`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `: ""}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${1 === u.screenCenterOffsetUnitsEnabled ? u.screenSizePerspectiveEnabled ? "float centerOffsetY \x3d applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);" : "float centerOffsetY \x3d centerOffset.y;" : ""}

      ${1 === u.screenCenterOffsetUnitsEnabled ? "posProj.xy +\x3d vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;" : ""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `); q.vertex.code.add(c.glsl`bool testVisibilityHUD(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (uRenderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)
      }; a.bindHUDUniforms = function (q, u) { q.setUniform1f("uRenderTransparentlyOccludedHUD", 0 === u.renderTransparentlyOccludedHUD ? 1 : 1 === u.renderTransparentlyOccludedHUD ? 0 : .75) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl": function () {
      define(["exports", "../../shaderModules/interfaces", "../../../materials/internal/MaterialUtil"], function (a, w, c) {
      a.ScreenSizePerspective = function (q) {
        q.vertex.code.add(w.glsl`float screenSizePerspectiveMinSize(float size, vec4 factor) {
float nonZeroSize = 1.0 - step(size, 0.0);
return (
factor.z * (
1.0 +
nonZeroSize *
2.0 * factor.w / (
size + (1.0 - nonZeroSize)
)
)
);
}`); q.vertex.code.add(w.glsl`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`); q.vertex.code.add(w.glsl`vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {
return vec4(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z,
params.w
);
}`); q.vertex.code.add(w.glsl`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {
return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));
}`); q.vertex.code.add(w.glsl`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`); q.vertex.code.add(w.glsl`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {
return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);
}`); q.vertex.code.add(w.glsl`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)
      }; a.bindScreenSizePerspectiveUniforms = function (q, u) { u.screenSizePerspective && (c.bindScreenSizePerspective(u.screenSizePerspective, q, "screenSizePerspective"), c.bindScreenSizePerspective(u.screenSizePerspectiveAlignment || u.screenSizePerspective, q, "screenSizePerspectiveAlignment")) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl": function () {
      define(["exports", "../output/ReadLinearDepth.glsl", "../shading/MultipassGeometryTest.glsl",
        "../util/RgbaFloatEncoding.glsl", "../../shaderModules/interfaces"], function (a, w, c, q, u) {
        a.HUDOcclusionPass = function (y, n) {
        n.multipassGeometryEnabled && y.vertex.include(c.multipassGeometryTest); n.multipassTerrainEnabled && y.varyings.add("depth", "float"); y.vertex.code.add(u.glsl`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${n.multipassGeometryEnabled ? u.glsl`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }`: ""}

      ${n.multipassTerrainEnabled ? "depth \x3d projectAux.posView.z;" : ""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `); n.multipassTerrainEnabled && y.fragment.include(w.ReadLinearDepth); y.fragment.uniforms.add("terrainDepthTexture", "sampler2D"); y.fragment.uniforms.add("cameraNearFar", "vec2"); y.fragment.uniforms.add("inverseViewport", "vec2"); y.fragment.include(q.RgbaFloatEncoding); y.fragment.code.add(u.glsl`
  void main() {
    gl_FragColor = vec4(1, 1, 1, 1);
    ${n.multipassTerrainEnabled ? u.glsl`

          vec2 uv = gl_FragCoord.xy * inverseViewport;

          //Read the rgba data from the texture linear depth
          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), cameraNearFar);

          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          //Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            gl_FragColor.g = 0.5;
          }`: ""}
  }
  `)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl": function () {
      define(["exports", "../output/ReadLinearDepth.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.bindMultipassGeometryTexture = function (q, u) { u.multipassGeometryEnabled && u.geometryLinearDepthTexture && q.bindTexture(u.geometryLinearDepthTexture, "geometryDepthTexture") }; a.multipassGeometryTest = function (q) {
        q.include(w.ReadLinearDepth); q.uniforms.add("geometryDepthTexture",
          "sampler2D"); q.uniforms.add("cameraNearFar", "vec2"); q.code.add(c.glsl`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, cameraNearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl": function () {
      define(["exports", "../../../../../../chunks/vec4f64", "../../shaderModules/interfaces"], function (a, w, c) {
        const q = w.fromValues(1, 1, 0, 1), u = w.fromValues(1, 0, 1, 1); a.OutputHighlight = function (y) {
          y.fragment.uniforms.add("depthTex", "sampler2D"); y.fragment.uniforms.add("highlightViewportPixelSz", "vec4"); y.fragment.constants.add("occludedHighlightFlag", "vec4", q).add("unoccludedHighlightFlag",
            "vec4", u); y.fragment.code.add(c.glsl`void outputHighlight() {
vec4 fragCoord = gl_FragCoord;
float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;
if (fragCoord.z > sceneDepth + 5e-7) {
gl_FragColor = occludedHighlightFlag;
}
else {
gl_FragColor = unoccludedHighlightFlag;
}
}`)
        }; a.bindOutputHighlight = function (y, n) { y.bindTexture(n.highlightDepthTexture, "depthTex"); y.setUniform4f("highlightViewportPixelSz", 0, 0, n.inverseViewport[0], n.inverseViewport[1]) }; a.occludedHighlightFlag = q; a.unoccludedHighlightFlag = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
        function c(q, u) {
        u.vvSizeEnabled && (q.setUniform3fv("vvSizeMinSize",
          u.vvSizeMinSize), q.setUniform3fv("vvSizeMaxSize", u.vvSizeMaxSize), q.setUniform3fv("vvSizeOffset", u.vvSizeOffset), q.setUniform3fv("vvSizeFactor", u.vvSizeFactor)); u.vvColorEnabled && (q.setUniform1fv("vvColorValues", u.vvColorValues), q.setUniform4fv("vvColorColors", u.vvColorColors))
        } a.VisualVariables = function (q, u) {
        u.vvInstancingEnabled && (u.vvSize || u.vvColor) && q.attributes.add("instanceFeatureAttribute", "vec4"); u.vvSize ? (q.vertex.uniforms.add("vvSizeMinSize", "vec3"), q.vertex.uniforms.add("vvSizeMaxSize",
          "vec3"), q.vertex.uniforms.add("vvSizeOffset", "vec3"), q.vertex.uniforms.add("vvSizeFactor", "vec3"), q.vertex.uniforms.add("vvSymbolRotationMatrix", "mat3"), q.vertex.uniforms.add("vvSymbolAnchor", "vec3"), q.vertex.code.add(w.glsl`vec3 vvScale(vec4 _featureAttribute) {
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`), q.vertex.code.add(w.glsl`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);
        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);
      }

      ${u.vvInstancingEnabled ? w.glsl`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }`: ""}
    `)) : q.vertex.code.add(w.glsl`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`); u.vvColor ? (q.vertex.constants.add("vvColorNumber", "int", 8), q.vertex.code.add(w.glsl`
      uniform float vvColorValues[vvColorNumber];
      uniform vec4 vvColorColors[vvColorNumber];

      vec4 vvGetColor(vec4 featureAttribute, float values[vvColorNumber], vec4 colors[vvColorNumber]) {
        float value = featureAttribute.y;
        if (value <= values[0]) {
          return colors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (values[i] >= value) {
            float f = (value - values[i-1]) / (values[i] - values[i-1]);
            return mix(colors[i-1], colors[i], f);
          }
        }
        return colors[vvColorNumber - 1];
      }

      ${u.vvInstancingEnabled ? w.glsl`
      vec4 vvColor() {
        return vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);
      }`: ""}
    `)) : q.vertex.code.add(w.glsl`vec4 vvColor() { return vec4(1.0); }`)
        }; a.bindVisualVariablesUniforms = c; a.bindVisualVariablesUniformsForSymbols = function (q, u) { c(q, u); u.vvSizeEnabled && (q.setUniform3fv("vvSymbolAnchor", u.vvSymbolAnchor), q.setUniformMatrix3fv("vvSymbolRotationMatrix", u.vvSymbolRotationMatrix)) }; a.bindVisualVariablesUniformsWithOpacity = function (q, u) { c(q, u); u.vvOpacityEnabled && (q.setUniform1fv("vvOpacityValues", u.vvOpacityValues), q.setUniform1fv("vvOpacityOpacities", u.vvOpacityOpacities)) };
        Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.DiscardOrAdjustAlpha = function (c, q) {
        const u = c.fragment; switch (q.alphaDiscardMode) {
          case 0: u.code.add(w.glsl`
        #define discardOrAdjustAlpha(color) { if (color.a < ${w.glsl.float(.001)}) { discard; } }
      `); break; case 1: u.code.add(w.glsl`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`); break; case 2: u.uniforms.add("textureAlphaCutoff", "float"); u.code.add(w.glsl`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`); break; case 3: c.fragment.uniforms.add("textureAlphaCutoff", "float"), c.fragment.code.add(w.glsl`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`)
        }
      }; a.defaultMaskAlphaCutoff = .1; a.symbolAlphaCutoff = .001; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/HUDMaterialTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/attributes/VerticalOffset.glsl ../core/shaderLibrary/hud/HUD.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/MultipassGeometryTest.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/shading/VisualVariables.glsl ../core/shaderLibrary/util/ScreenSizePerspective.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/OrderIndependentTransparency ../lib/Program ../../../../chunks/HUDMaterial.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
          v = function (B) {
            function C() { return B.apply(this, arguments) || this } c._inheritsLoose(C, B); var D = C.prototype; D.initializeProgram = function (E) {
              var H = C.shader.get(); const J = this.configuration; H = H.build({
                output: J.output, FrontFacePass: 2 === J.transparencyPassType, viewingMode: E.viewingMode, occlusionTestEnabled: J.occlusionTestEnabled, signedDistanceFieldEnabled: J.sdf, slicePlaneEnabled: J.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !0,
                debugDrawBorder: J.debugDrawBorder, binaryHighlightOcclusionEnabled: J.binaryHighlightOcclusion, screenCenterOffsetUnitsEnabled: J.screenCenterOffsetUnitsEnabled, screenSizePerspectiveEnabled: J.screenSizePerspective, verticalOffsetEnabled: J.verticalOffset, pixelSnappingEnabled: J.pixelSnappingEnabled, vvSize: J.vvSize, vvColor: J.vvColor, vvInstancingEnabled: !1, isDraped: J.isDraped, multipassGeometryEnabled: J.multipassGeometryEnabled, multipassTerrainEnabled: J.multipassTerrainEnabled, cullAboveGround: J.cullAboveGround
              });
              return new x.Program(E.rctx, H, e.Default3D)
            }; D.bindPass = function (E, H) {
              f.bindProjectionMatrix(this.program, H.camera.projectionMatrix); this.program.setUniform1f("cameraGroundRelative", H.camera.aboveGround ? 1 : -1); this.program.setUniform1f("perDistancePixelRatio", Math.tan(H.camera.fovY / 2) / (H.camera.fullViewport[2] / 2)); this.program.setUniformMatrix4fv("viewNormal", H.camera.viewInverseTransposeMatrix); this.program.setUniform1f("polygonOffset", E.shaderPolygonOffset); y.bindVerticalOffsetUniforms(this.program,
                E, H); d.bindScreenSizePerspectiveUniforms(this.program, E); this.program.setUniform1f("pixelRatio", H.camera.pixelRatio || 1); f.bindViewport(this.program, H); 6 === this.configuration.output ? (this.program.setUniform2fv("cameraNearFar", H.camera.nearFar), this.program.setUniform2fv("inverseViewport", H.inverseViewport), l.bindMultipassGeometryTexture(this.program, H), h.bindMultipassTerrainTexture(this.program, H)) : (n.bindHUDUniforms(this.program, H), k.bindHUDMaterialUniforms(this.program, E, H.camera.pixelRatio || 1),
                  b.bindVisualVariablesUniforms(this.program, E), this.configuration.occlusionTestEnabled && this.program.bindTexture(H.hudVisibilityTexture, "hudVisibilityTexture")); 4 === this.configuration.output && p.bindOutputHighlight(this.program, H)
            }; D.bindDraw = function (E) { f.bindView(this.program, E); f.bindCameraPosition(this.program, E.origin, E.camera.viewInverseTransposeMatrix); u.bindSliceUniformsWithOrigin(this.program, this.configuration, E); this.program.rebindTextures() }; D.setPipelineState = function (E) {
              const H = this.configuration,
              J = 3 === E, M = this.configuration.polygonOffsetEnabled && A, F = !J && 2 !== E || 4 === H.output ? null : (H.depthEnabled || 6 === H.output) && r.defaultDepthWriteParams; return r.makePipelineState({ blending: 0 === H.output || 7 === H.output || 4 === H.output ? J ? z : g.OITBlending(E) : null, depthTest: { func: 515 }, depthWrite: F, colorWrite: r.defaultColorWriteParams, polygonOffset: M })
            }; D.initializePipeline = function () { return this.setPipelineState(this.configuration.transparencyPassType) }; c._createClass(C, [{
              key: "primitiveType", get: function () {
                return 6 ===
                  this.configuration.output ? 0 : 4
              }
            }]); return C
          }(v.ShaderTechnique); v.shader = new t.ReloadableShaderModule(k.HUDMaterialShader, () => new Promise((B, C) => a(["./HUDMaterial.glsl"], B, C))); const A = { factor: 0, units: -4 }, z = r.simpleBlendingParams(1, 771); t = function (B) {
            function C() {
              var D = B.apply(this, arguments) || this; D.output = 0; D.occlusionTestEnabled = !0; D.sdf = !1; D.vvSize = !1; D.vvColor = !1; D.verticalOffset = !1; D.screenSizePerspective = !1; D.screenCenterOffsetUnitsEnabled = 0; D.debugDrawBorder = !1; D.binaryHighlightOcclusion = !0;
              D.slicePlaneEnabled = !1; D.polygonOffsetEnabled = !1; D.depthEnabled = !0; D.transparencyPassType = 3; D.pixelSnappingEnabled = !0; D.isDraped = !1; D.multipassGeometryEnabled = !1; D.multipassTerrainEnabled = !1; D.cullAboveGround = !1; return D
            } c._inheritsLoose(C, B); return C
          }(m.ShaderTechniqueConfiguration); q.__decorate([m.parameter({ count: 8 })], t.prototype, "output", void 0); q.__decorate([m.parameter()], t.prototype, "occlusionTestEnabled", void 0); q.__decorate([m.parameter()], t.prototype, "sdf", void 0); q.__decorate([m.parameter()],
            t.prototype, "vvSize", void 0); q.__decorate([m.parameter()], t.prototype, "vvColor", void 0); q.__decorate([m.parameter()], t.prototype, "verticalOffset", void 0); q.__decorate([m.parameter()], t.prototype, "screenSizePerspective", void 0); q.__decorate([m.parameter({ count: 2 })], t.prototype, "screenCenterOffsetUnitsEnabled", void 0); q.__decorate([m.parameter()], t.prototype, "debugDrawBorder", void 0); q.__decorate([m.parameter()], t.prototype, "binaryHighlightOcclusion", void 0); q.__decorate([m.parameter()], t.prototype,
              "slicePlaneEnabled", void 0); q.__decorate([m.parameter()], t.prototype, "polygonOffsetEnabled", void 0); q.__decorate([m.parameter()], t.prototype, "depthEnabled", void 0); q.__decorate([m.parameter({ count: 4 })], t.prototype, "transparencyPassType", void 0); q.__decorate([m.parameter()], t.prototype, "pixelSnappingEnabled", void 0); q.__decorate([m.parameter()], t.prototype, "isDraped", void 0); q.__decorate([m.parameter()], t.prototype, "multipassGeometryEnabled", void 0); q.__decorate([m.parameter()], t.prototype, "multipassTerrainEnabled",
                void 0); q.__decorate([m.parameter()], t.prototype, "cullAboveGround", void 0); w.HUDMaterialTechnique = v; w.HUDMaterialTechniqueConfiguration = t; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl": function () {
      define(["exports", "../util/ScreenSizePerspective.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
        function q(y, n, p, l = u) {
        l.screenLength = y.screenLength; l.perDistance = Math.tan(.5 * n) / (.5 * p); l.minWorldLength = y.minWorldLength;
          l.maxWorldLength = y.maxWorldLength; return l
        } const u = { screenLength: 0, perDistance: 0, minWorldLength: 0, maxWorldLength: 0 }; a.VerticalOffset = function (y, n) {
          const p = y.vertex.code; n.verticalOffsetEnabled ? (y.vertex.uniforms.add("verticalOffset", "vec4"), n.screenSizePerspectiveEnabled && (y.include(w.ScreenSizePerspective), y.vertex.uniforms.add("screenSizePerspectiveAlignment", "vec4")), p.add(c.glsl`
    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
      ${1 === n.viewingMode ? c.glsl`vec3 worldNormal = normalize(worldPos + localOrigin);` : c.glsl`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
      ${n.screenSizePerspectiveEnabled ? c.glsl`
          float cosAngle = dot(worldNormal, normalize(worldPos - camPos));
          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`: c.glsl`
          float verticalOffsetScreenHeight = verticalOffset.x;`}
      // Screen sized offset in world space, used for example for line callouts
      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
      return worldNormal * worldOffset;
    }

    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
      return worldPos + calculateVerticalOffset(worldPos, localOrigin);
    }
    `)) : p.add(c.glsl`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)
        }; a.bindVerticalOffsetUniforms = function (y, n, p) { n.verticalOffset && (n = q(n.verticalOffset, p.camera.fovY, p.camera.fullViewport[3]), y.setUniform4f("verticalOffset", n.screenLength * (p.camera.pixelRatio || 1), n.perDistance, n.minWorldLength, n.maxWorldLength)) }; a.calculateVerticalOffsetFactors = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl": function () {
      define(["exports",
        "../../shaderModules/interfaces"], function (a, w) {
        a.bindMultipassTerrainTexture = function (c, q) { q.multipassTerrainEnabled && q.terrainLinearDepthTexture && c.bindTexture(q.terrainLinearDepthTexture, "terrainDepthTexture") }; a.multipassTerrainTest = function (c, q) {
          c.fragment.uniforms.add("terrainDepthTexture", "sampler2D"); c.fragment.uniforms.add("cameraNearFar", "vec2"); c.fragment.uniforms.add("inverseViewport", "vec2"); c.fragment.code.add(w.glsl`
    // Compare the linearized depths of fragment and terrain. Discard fragments on the wrong side of the terrain.
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){

      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, cameraNearFar);
      if(fragmentDepth ${q.cullAboveGround ? "\x3e" : "\x3c\x3d"} terrainDepth){
        discard;
      }
    }
  `)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/OrderIndependentTransparency": function () {
      define(["exports", "../../../webgl/renderState"], function (a, w) {
        const c = w.separateBlendingParams(770, 1, 771, 771), q = w.simpleBlendingParams(1, 1), u = w.simpleBlendingParams(0, 771), y = { factor: -1, units: -2 }; a.OITBlending = function (n) { return 2 === n ? null : 1 === n ? u : q }; a.OITDepthTest = function (n) { return 3 === n || 2 === n ? 513 : 515 }; a.OITDepthWrite = function (n) {
          return 2 === n ? w.defaultDepthWriteParams :
            null
        }; a.OITPolygonOffset = y; a.OITPolygonOffsetLimit = 5E5; a.blendingAlpha = u; a.blendingColor = q; a.blendingDefault = c; a.getOITPolygonOffset = function (n) { return n ? y : null }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/LabelDeconflictor": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ./Deconflictor".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
        a.LabelDeconflictor = function (h) {
          function b() { var f = h.apply(this, arguments) || this; f.visibilityGroup = 1; f.iconMarginFactor = 0; f._lastDeconfliction = 0; return f } w._inheritsLoose(b, h); var d = b.prototype; d.runTask = function (f) { if (!this.parent.running) { var t = performance.now(); if (2 === f.state || 2E3 < t - this._lastDeconfliction) h.prototype.runTask.call(this, f), 0 === this.state && (this._lastDeconfliction = t) } }; d.enabledChanged = function (f, t) { this.modifyGraphics(t, f.labelsEnabled) }; d.getGraphicsLayers =
            function (f) { return f.labelGraphics }; w._createClass(b, [{ key: "viewState", get: function () { return this.parent.viewState } }]); return b
        }(l.Deconflictor); c.__decorate([q.property({ constructOnly: !0 })], a.LabelDeconflictor.prototype, "parent", void 0); a.LabelDeconflictor = c.__decorate([p.subclass("esri.views.3d.layers.graphics.LabelDeconflictor")], a.LabelDeconflictor); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Labeler": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/asyncUtils ../../../../core/Handles ../../../../core/Logger ../../../../core/MapUtils ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../layers/graphics/hydratedFeatures ../../../../layers/support/labelFormatUtils ../../../../layers/support/layerUtils ../../../../symbols/callouts/calloutUtils ./Graphics3DCalloutSymbolLayerFactory ./Graphics3DGraphicCreationContext ./graphicSymbolUtils ./labelPlacement ../../support/debugFlags ../../webgl-engine/lib/MaterialCollection ../../webgl-engine/lib/TextRenderer ../../webgl-engine/lib/TextRenderParameters ../../webgl-engine/lib/TextTextureAtlas ../../webgl-engine/lib/WebGLLayer ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M) {
          const F = n.getLogger("esri.views.3d.layers.graphics.Labeler"); a.Labeler = function (P) {
            function L() { var G = P.apply(this, arguments) || this; G._dirty = !1; G._labels = new Map; G._labelsToAdd = new Map; G._labelsToRemove = new Map; G._labelingContexts = []; return G } w._inheritsLoose(L, P); var N = L.prototype; N.setup = function () {
              this.dispose(); this._handles = new y; this._handles.add([this.view.watch("state.camera", () => this.setDirty()), this.view.watch("pixelRatio",
                () => this._resetAllLabels()), this.view.resourceController.scheduler.registerTask(M.TaskPriority.LABELER, this)]); this._textTextureAtlas = new H.default({ view: this.view }); this._hudMaterialCollection = new C.MaterialCollection(this.view._stage); this._calloutMaterialCollection = new C.MaterialCollection(this.view._stage)
            }; N.dispose = function () {
            this._handles = l.destroyMaybe(this._handles); this._textTextureAtlas = l.disposeMaybe(this._textTextureAtlas); this._hudMaterialCollection = l.disposeMaybe(this._hudMaterialCollection);
              this._calloutMaterialCollection = l.disposeMaybe(this._calloutMaterialCollection); this._labelingContexts.length = 0; this._labels.clear(); this._labelsToAdd.clear(); this._labelsToRemove.clear()
            }; N._activateLabelingContext = function (G) { G.labels.forEach((I, O) => { this._labels.set(O, I); I.graphics3DGraphic.setVisibilityFlag(0, !0, 1) }); G.active = !0 }; N._deactivateLabelingContext = function (G) {
              G.labels.forEach((I, O) => {
                I.graphics3DGraphic.setVisibilityFlag(0, !1, 1); this.setLabelGraphicVisibility(I.graphics3DGraphic, !1);
                this._labels.delete(O)
              }); G.active = !1
            }; N._addLabelTextureToAtlas = function (G) { for (const I of G.graphics3DGraphic.labelGraphics) { if (!I._labelClass) continue; const O = G.textRenderers[I._labelIndex]; O && this._textTextureAtlas.addTextTexture(O, I.stageObject) } G.rendered = !0 }; N._removeLabelTextureFromAtlas = function (G) { for (const I of G.graphics3DGraphic.labelGraphics) { if (!I._labelClass) continue; const O = G.textRenderers[I._labelIndex]; O && this._textTextureAtlas.removeTextTexture(O, I.stageObject) } G.rendered = !1 }; N.runTask =
              function (G) { this._updateLabels(G); !this._dirty && this.deconflictor.running && this.deconflictor.runTask(G) }; N._updateLabels = function (G) {
                if (this._dirty) {
                this._dirty = !1; for (const I of this._labelingContexts) if (I.active && g.areLabelsVisible(I.layer)) {
                  if (!I.labelClassContexts || !I.labelClassContexts.length) {
                    if (null === I.labelClassContexts) { this._deactivateLabelingContext(I); continue } this._createLabelClassContext(I); if (I.labelClassPromise && I.labelClassAbortController) { this._dirty = !0; continue } if (!I.labelClassContexts ||
                      !I.labelClassContexts.length) continue
                  } p.someMap(I.labelsToInitialize, (O, R) => { this._ensureGraphics3DResources(O) && (this._labels.set(R, O), this.deconflictor.setDirty(), G.madeProgress()); if (O.visible && O.hasTextTextureResources || !O.visible && O.hasGraphics3DResources) I.labelsToInitialize.delete(R), G.madeProgress(); return G.done }) && (this._dirty = !0)
                } this._labelsToRemove.forEach(I => this._removeLabelTextureFromAtlas(I)); this._labelsToAdd.forEach(I => this._addLabelTextureToAtlas(I)); this._labelsToRemove.clear();
                  this._labelsToAdd.clear(); this._dirty || this.notifyChange("updating")
                }
              }; N._createLabelClassContextAsync = function () {
                var G = w._asyncToGenerator(function* (I) {
                  var O = this; const R = I.labelClassAbortController.signal; yield I.layer.when(); h.throwIfAborted(R); I.scaleVisibility && I.scaleVisibility.updateScaleRangeActive(); const S = I.graphics3DCore; var Q = S.layer; if ((Q = Q.labelingInfo && Q.labelingInfo.filter(Y => !!Y.symbol)) && 0 !== Q.length) {
                    var T = Array(Q.length), da = !1; yield u.forEach(Q, function () {
                      var Y = w._asyncToGenerator(function* (fa,
                        ha) {
                          var ka = fa.symbol; const ea = A.getGraphics3DSymbol(S.getOrCreateGraphics3DSymbol(ka)); if (l.isNone(ea)) F.error("Failed to create Graphics3DSymbol for label"); else {
                            yield ea.load(); h.throwIfAborted(R); var ba = null; x.isCalloutSupport(ka) && ka.hasVisibleCallout() && (ba = k.make(ka, S.symbolCreationContext), yield ba.load(), h.throwIfAborted(R)); ka = yield u.result(e.createLabelFunction(fa, I.layer.fieldsIndex, O.view.spatialReference)); h.throwIfAborted(R); !0 === ka.ok ? T[ha] = {
                              labelClass: fa, labelFunction: ka.value, graphics3DSymbol: ea,
                              graphics3DCalloutSymbolLayer: ba, calloutSymbolLayerIndex: 0, textRenderParameters: O._createTextRenderParameters(ea.symbol)
                            } : (F.error(`Label expression failed to evaluate: ${ka.error}`), da = !0)
                          }
                      }); return function (fa, ha) { return Y.apply(this, arguments) }
                    }()); h.throwIfAborted(R); da || (I.labelClassContexts = T)
                  }
                }); return function (I) { return G.apply(this, arguments) }
              }(); N._createLabelClassContext = function () {
                var G = w._asyncToGenerator(function* (I) {
                I.labelClassPromise || (I.labelClassPromise = this._createLabelClassContextAsync(I).catch(O => { if (h.isAbortError(O)) throw O; I.labelClassContexts = null }).then(() => { I.labelClassAbortController = null; this.notifyChange("updating") }).catch(() => { }), this.notifyChange("updating")); return I.labelClassPromise
                }); return function (I) { return G.apply(this, arguments) }
              }(); N._createTextRenderParameters = function (G) { return (G = G.symbolLayers.getItemAt(0)) && "text" === G.type ? E.TextRenderParameters.fromSymbol(G, this.view.pixelRatio) : null }; N._destroyLabelClassContext = function (G) {
                for (var I of G.labelClassContexts)--I.graphics3DSymbol.referenced,
                  I.graphics3DSymbol = null; I = G.labelClassAbortController; G.labelClassAbortController = new AbortController; I && I.abort(); G.labelClassContexts = []; G.labelClassPromise = null; this.notifyChange("updating")
              }; N._createTextSymbolGraphic = function (G, I, O, R, S) {
                G = {
                  text: G.text, centerOffset: O.centerOffset, translation: O.translation, elevationOffset: O.elevationOffset, screenOffset: O.screenOffset, anchor: O.anchor, centerOffsetUnits: O.centerOffsetUnits, verticalOffset: O.verticalOffset, debugDrawBorder: B.LABELS_SHOW_BORDER, displayWidth: G.displayWidth,
                  displayHeight: G.displayHeight
                }; K.graphic = I; K.renderingInfo = null; K.layer = R; return S.createLabel(K, G, this._hudMaterialCollection, this._textTextureAtlas)
              }; N._createLineCalloutGraphic = function (G, I, O, R, S) { I = { symbol: I, translation: R.translation, elevationOffset: R.elevationOffset, screenOffset: R.screenOffset, centerOffset: R.centerOffset, centerOffsetUnits: R.centerOffsetUnits, materialCollection: this._calloutMaterialCollection }; K.graphic = G; K.renderingInfo = I; K.layer = S; return O.createGraphics3DGraphic(K) }; N._ensureGraphics3DResources =
                function (G) {
                  if (G.hasGraphics3DResources) return !1; const I = G.graphics3DGraphic; if (I.destroyed) return !1; this._ensureTextTextureResources(G); const O = G.labelingContext, R = O.labelClassContexts; if (!R || 0 === R.length || !O.emptySymbolLabelSupported && 0 === I.graphics.length) return !1; var S = !1, Q = I.graphic; const T = O.layer; var da = g.areLabelsVisible(O.layer); const Y = this.view._stage; for (let ha = 0; ha < R.length; ha++) {
                    const ka = G.textRenderers[ha]; if (!ka) continue; const ea = R[ha]; var fa = ea.graphics3DSymbol; let ba = null; fa.symbol &&
                      "label-3d" === fa.symbol.type && (ba = fa.symbol); const aa = fa.symbolLayers[0]; if (!aa) continue; const W = ea.labelClass; fa = z.get({ graphics3DGraphic: I, labelSymbol: ba, labelClass: W, disablePlacement: O.disablePlacement }); if (!l.isNone(fa)) {
                        aa.setElevationInfoOverride(O.elevationInfoOverride); S = this._createTextSymbolGraphic(ka, Q, fa, T, aa); if (!S) return !1; S._labelClass = W; S._labelIndex = ha; I.addLabelGraphic(S, Y, O.stageLayer); I.setVisibilityFlag(0, da, 1); I.clearVisibilityFlag(1, 1); I.setVisibilityFlag(3, !1, 1); S = !0; (da = ea.graphics3DCalloutSymbolLayer) &&
                          fa.hasLabelVerticalOffset && (da.setElevationInfoOverride(O.elevationInfoOverride), Q = this._createLineCalloutGraphic(Q, ba, da, fa, T)) && (ea.calloutSymbolLayerIndex = I.labelGraphics.length, I.addLabelGraphic(Q, Y, O.stageLayer)); break
                      }
                  } O.scaleVisibility && S && O.scaleVisibility.updateGraphicLabelScaleVisibility(I); return G.hasGraphics3DResources = !0
                }; N._destroyGraphics3DResources = function (G) {
                  const I = G.labelingContext.labelClassContexts; for (const O of G.graphics3DGraphic.labelGraphics) {
                    if (null == O._labelClass) continue;
                    const R = I[O._labelIndex].graphics3DSymbol.symbolLayers[0]; if (null != R) R.onRemoveGraphic(O)
                  } G.graphics3DGraphic.clearLabelGraphics(); G.hasGraphics3DResources = !1
                }; N._ensureTextTextureResources = function (G) {
                  if (!G.hasTextTextureResources) {
                    var I = G.labelingContext, O = I.labelClassContexts; if (O && 0 !== O.length) {
                      var R = G.graphics3DGraphic.graphic; for (let S = 0; S < O.length; S++) {
                        const Q = O[S]; G.textRenderers[S] = null; if (!Q.textRenderParameters) continue; const T = Q.labelFunction; let da; if ("arcade" === T.type) try {
                          const Y = T.needsHydrationToEvaluate() ?
                            m.hydrateGraphic(R, I.layer) : R; da = T.evaluate(Y)
                        } catch (Y) { da = null } else da = T.evaluate(R); l.isNone(da) || "" === da || /^\s+$/.test(da) || (G.textRenderers[S] = new D.TextRenderer(da, Q.textRenderParameters))
                      } G.hasTextTextureResources = !0
                    }
                  }
                }; N._destroyTextTextureResources = function (G) { G.textRenderers = []; G.hasTextTextureResources = !1 }; N._addGraphic = function (G, I) {
                  const O = { hasGraphics3DResources: !1, hasTextTextureResources: !1, visible: !1, rendered: !1, labelingContext: G, graphics3DGraphic: I, textRenderers: [] }; I = I.graphic.uid;
                  G.labels.set(I, O); G.labelsToInitialize.set(I, O); this.setDirty(); this.deconflictor.setDirty()
                }; N._removeGraphic = function (G, I) { I = I.graphic.uid; const O = G.labels.get(I); O && (this._destroyGraphic(O, I), G.labels.delete(I), G.labelsToInitialize.delete(I), this.setDirty(), this.deconflictor.setDirty()) }; N._destroyGraphic = function (G, I) {
                  this._labels.has(I) && (this._labels.delete(I), this._labelsToAdd.delete(I), this._labelsToRemove.delete(I)); G.hasTextTextureResources && (this._removeLabelTextureFromAtlas(G), this._destroyTextTextureResources(G));
                  G.hasGraphics3DResources && this._destroyGraphics3DResources(G)
                }; N._labelingInfoChange = function () { var G = w._asyncToGenerator(function* (I, O) { if (O) for (const R of O) { if (O = I.labels.get(R)) this._removeGraphic(I, O.graphics3DGraphic), this._addGraphic(I, O.graphics3DGraphic) } else return this._visibilityInfoChange(I), this._resetLabels(I), this._createLabelClassContext(I) }); return function (I, O) { return G.apply(this, arguments) } }(); N._globalPropertyChanged = function (G, I) {
                  for (const O of I.labelClassContexts) {
                    const R =
                      new Map; I.labels.forEach(S => { S = S.graphics3DGraphic; R.set(S.graphic.uid, S) }); l.unwrap(O.graphics3DSymbol.symbolLayers[0]).globalPropertyChanged(G, R, S => S.labelGraphics[0]); O.graphics3DCalloutSymbolLayer && O.graphics3DCalloutSymbolLayer.globalPropertyChanged(G, R, S => S.labelGraphics[O.calloutSymbolLayerIndex])
                  }
                }; N._visibilityInfoChange = function (G) { const I = G.layer.labelsVisible; I && !G.active && this._activateLabelingContext(G); !I && G.active && this._deactivateLabelingContext(G); this.setDirty() }; N._resetAllLabels =
                  function () { for (const G of this._labelingContexts) this._resetLabels(G) }; N._resetLabels = function (G) { G.labels.forEach((I, O) => { this._destroyGraphic(I, O); I.visible = !1; I.rendered = !1; G.labelsToInitialize.set(O, I) }); this._destroyLabelClassContext(G); this.setDirty(); this.deconflictor.setDirty() }; N._findLabelingContext = function (G) { for (const I of this._labelingContexts) if (I.graphics3DCore === G) return I; return null }; N.addGraphicsOwner = function (G, I, O) {
                    const R = O && O.emptySymbolLabelSupported || !1, S = O && O.elevationInfoOverride ||
                      null; O = O && O.disablePlacement || null; if (!this._findLabelingContext(G)) {
                        var Q = G.layer, T = { graphics3DCore: G, layer: Q, scaleVisibility: I, emptySymbolLabelSupported: R, elevationInfoOverride: S, disablePlacement: O, active: Q.labelsVisible, labelClassPromise: null, labelClassAbortController: new AbortController, labelClassContexts: [], labels: new Map, labelsToInitialize: new Map, stageLayer: new J.WebGLLayer({ isPickable: !0 }, Q.uid) }; this.view._stage.add(T.stageLayer); this._labelingContexts.push(T); this.setDirty(); return {
                          addGraphic: da =>
                            this._addGraphic(T, da), removeGraphic: da => this._removeGraphic(T, da), featureReductionChange: () => { }, layerLabelsEnabled: () => g.areLabelsVisible(T.layer), labelingInfoChange: da => this._labelingInfoChange(T, da), elevationInfoChange: () => this._globalPropertyChanged("elevationInfo", T), slicePlaneEnabledChange: () => this._globalPropertyChanged("slicePlaneEnabled", T), visibilityInfoChange: () => this._visibilityInfoChange(T), reset: () => this._resetLabels(T), clear: () => { }
                        }
                      }
                  }; N.removeGraphicsOwner = function (G) {
                    const I = this._findLabelingContext(G);
                    I && (G = this._labelingContexts.indexOf(I), this._labelingContexts.splice(G, 1), I.labels.forEach(O => this._removeGraphic(I, O.graphics3DGraphic)), this.view._stage.remove(I.stageLayer), I.stageLayer = null, this.setDirty())
                  }; N.setLabelGraphicVisibility = function (G, I) {
                    G = G.graphic.uid; const O = this._labels.get(G); O && O.visible !== I && (I && !O.rendered ? (this._labelsToAdd.set(G, O), this._labelsToRemove.delete(G), O.hasTextTextureResources || O.labelingContext.labelsToInitialize.set(G, O)) : !I && O.rendered && (this._labelsToRemove.set(G,
                      O), this._labelsToAdd.delete(G)), O.visible = I, this.setDirty())
                  }; N.setDirty = function () { !this._dirty && 0 < this._labelingContexts.length && (this._dirty = !0, this.notifyChange("updating")) }; w._createClass(L, [{ key: "running", get: function () { var G; return this.view.ready ? this._dirty || (null == (G = this._textTextureAtlas) ? void 0 : G.updating) || this.deconflictor.running : !1 } }, {
                    key: "updating", get: function () {
                      var G; return this._dirty || (null == (G = this._textTextureAtlas) ? void 0 : G.updating) || this.deconflictor.updating || this._labelingContexts.some(I =>
                        I.labelClassPromise && !!I.labelClassAbortController)
                    }
                  }, { key: "updatingProgress", get: function () { if (!this.updating || !this._textTextureAtlas) return 1; const G = 0 < this._labelingContexts.length ? this._labelingContexts.reduce((I, O) => I + (O.labelClassPromise && O.labelClassAbortController ? 0 : 1), 0) / this._labelingContexts.length : 1; return (this._dirty ? 0 : .3) + (this._textTextureAtlas.updating ? 0 : .1) + .1 * G + .5 * this.deconflictor.updatingProgress } }, {
                    key: "test", get: function () {
                      return {
                        textTextureAtlas: this._textTextureAtlas, resetAllLabels: () =>
                          this._resetAllLabels()
                      }
                    }
                  }]); return L
          }(q); c.__decorate([b.property({ constructOnly: !0 })], a.Labeler.prototype, "view", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.Labeler.prototype, "deconflictor", void 0); c.__decorate([b.property()], a.Labeler.prototype, "_textTextureAtlas", void 0); c.__decorate([b.property({ type: Boolean, readOnly: !0 })], a.Labeler.prototype, "updating", null); a.Labeler = c.__decorate([v.subclass("esri.views.3d.layers.graphics.Labeler")], a.Labeler); const K = new r(null, null, null); Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/hydratedFeatures": function () {
      define("exports ../../Graphic ../../core/has ../../core/lang ../../core/maybe ../../core/typedArrayUtil ../../geometry/support/jsonUtils ./dehydratedFeatures".split(" "), function (a, w, c, q, u, y, n, p) {
        function l(g) { return "declaredClass" in g } function h(g) { return "declaredClass" in g } function b(g) { return "declaredClass" in g } function d(g) { return u.isNone(g) ? null : l(g) ? g : n.fromJSON(f(g)) } function f(g) {
          const x = g.spatialReference.toJSON();
          switch (g.type) {
            case "point": { const { x: k, y: r, z: A, m: z } = g; return { x: k, y: r, z: A, m: z, spatialReference: x } } case "polygon": { const { rings: k, hasZ: r, hasM: A } = g; return { rings: t(k), hasZ: r, hasM: A, spatialReference: x } } case "polyline": { const { paths: k, hasZ: r, hasM: A } = g; return { paths: t(k), hasZ: r, hasM: A, spatialReference: x } } case "extent": { const { xmin: k, xmax: r, ymin: A, ymax: z, zmin: B, zmax: C, mmin: D, mmax: E, hasZ: H, hasM: J } = g; return { xmin: k, xmax: r, ymin: A, ymax: z, zmin: B, zmax: C, mmin: D, mmax: E, hasZ: H, hasM: J, spatialReference: x } } case "multipoint": {
              const { points: k,
                hasZ: r, hasM: A } = g; return { points: e(k) ? v(k) : k, hasZ: r, hasM: A, spatialReference: x }
            }
          }
        } function t(g) { return m(g) ? g.map(x => v(x)) : g } function v(g) { return g.map(x => y.toArray(x)) } function m(g) { for (const x of g) if (0 !== x.length) return e(x); return !1 } function e(g) { return g.length && (y.isFloat32Array(g[0]) || y.isFloat64Array(g[0])) } a.clonePoint = function (g, x) {
          if (!g) return null; if (h(g)) { if (null == x) return g.clone(); if (h(x)) return x.copy(g) } null != x ? (x.x = g.x, x.y = g.y, x.spatialReference = g.spatialReference, g.hasZ ? (x.z = g.z, x.hasZ =
            g.hasZ) : (x.z = null, x.hasZ = !1), g.hasM ? (x.m = g.m, x.hasM = !0) : (x.m = null, x.hasM = !1)) : (x = p.makeDehydratedPoint(g.x, g.y, g.z, g.spatialReference), g.hasM && (x.m = g.m, x.hasM = !0)); return x
        }; a.hydrateGeometry = d; a.hydrateGraphic = function (g, x) { if (!g) return null; if (b(g)) return g; x = new w({ layer: x, sourceLayer: x }); x.visible = g.visible; x.symbol = q.clone(g.symbol); x.attributes = q.clone(g.attributes); x.geometry = d(g.geometry); return x }; a.isHydratedGeometry = l; a.isHydratedGraphic = b; a.isHydratedPoint = h; Object.defineProperty(a, "__esModule",
          { value: !0 })
      })
    }, "esri/layers/graphics/dehydratedFeatures": function () {
      define("exports ../../core/byteSizeEstimations ../../core/has ../../core/maybe ../../core/typedArrayUtil ../../core/uid ../../geometry/SpatialReference ../../geometry/support/aaBoundingBox ../../geometry/support/aaBoundingRect ../../geometry/support/quantizationUtils ../../geometry/support/typeUtils ../support/Field ./dehydratedFeatureComparison".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
        function t(k, r, A) {
          if (q.isNone(k)) return null;
          switch (r) { case "point": return { x: k.x, y: k.y, z: k.z, m: k.m, hasZ: null != k.z, hasM: null != k.m, type: "point", spatialReference: A }; case "polyline": return { paths: k.paths, hasZ: !!k.hasZ, hasM: !!k.hasM, type: "polyline", spatialReference: A }; case "polygon": return { rings: k.rings, hasZ: !!k.hasZ, hasM: !!k.hasM, type: "polygon", spatialReference: A }; case "multipoint": return { points: k.points, hasZ: !!k.hasZ, hasM: !!k.hasM, type: "multipoint", spatialReference: A } }
        } function v(k) {
          if (q.isNone(k)) return 0; let r = 32; switch (k.type) {
            case "point": r +=
              42; break; case "polyline": case "polygon": { var A = 0; const z = 2 + (k.hasZ ? 1 : 0) + (k.hasM ? 1 : 0); k = "polyline" === k.type ? k.paths : k.rings; for (const B of k) A += B.length; r += 8 * A * z + 64; r += 128 * A; r = r + 34 + 32 * (k.length + 1); break } case "multipoint": A = k.points.length; r += 8 * A * (2 + (k.hasZ ? 1 : 0) + (k.hasM ? 1 : 0)) + 64; r += 128 * A; r = r + 34 + 32; break; case "extent": r += 98; k.hasM && (r += 32); k.hasZ && (r += 32); break; case "mesh": r += u.estimateSize(k.vertexAttributes.position), r += u.estimateSize(k.vertexAttributes.normal), r += u.estimateSize(k.vertexAttributes.uv),
                r += u.estimateSize(k.vertexAttributes.tangent)
          }return r
        } function m(k, r) {
          p.empty(r); "mesh" === k.type && (k = k.extent); switch (k.type) {
            case "point": r[0] = r[3] = k.x; r[1] = r[4] = k.y; k.hasZ && (r[2] = r[5] = k.z); break; case "polyline": for (var A = 0; A < k.paths.length; A++)p.expandWithNestedArray(r, k.paths[A], k.hasZ); break; case "polygon": for (A = 0; A < k.rings.length; A++)p.expandWithNestedArray(r, k.rings[A], k.hasZ); break; case "multipoint": p.expandWithNestedArray(r, k.points, k.hasZ); break; case "extent": r[0] = k.xmin, r[1] = k.ymin, r[3] =
              k.xmax, r[4] = k.ymax, null != k.zmin && (r[2] = k.zmin), null != k.zmax && (r[5] = k.zmax)
          }
        } function e(k, r) { l.empty(r); "mesh" === k.type && (k = k.extent); switch (k.type) { case "point": r[0] = r[2] = k.x; r[1] = r[3] = k.y; break; case "polyline": for (var A = 0; A < k.paths.length; A++)l.expandWithNestedArray(r, k.paths[A]); break; case "polygon": for (A = 0; A < k.rings.length; A++)l.expandWithNestedArray(r, k.rings[A]); break; case "multipoint": l.expandWithNestedArray(r, k.points); break; case "extent": r[0] = k.xmin, r[1] = k.ymin, r[2] = k.xmax, r[3] = k.ymax } } const g =
          p.create(), x = l.create(); a.equals = f.equals; a.DehydratedFeatureClass = function (k, r, A) { this.uid = k; this.geometry = r; this.attributes = A; this.visible = !0; this.centroid = this.objectId = null }; a.DehydratedFeatureSetClass = function () { this.exceededTransferLimit = !1; this.features = []; this.fields = []; this.hasZ = this.hasM = !1; this.transform = this.spatialReference = this.geohashFieldName = this.geometryProperties = this.globalIdFieldName = this.objectIdFieldName = this.geometryType = null }; a.computeAABB = m; a.computeAABR = e; a.estimateGeometryObjectSize =
            v; a.estimateSize = function (k) { let r; r = 32 + w.estimateAttributesObjectSize(k.attributes); return r = r + 3 + (8 + v(k.geometry)) }; a.expandAABB = function (k, r) { m(k, g); p.expandWithAABB(r, g) }; a.expandAABR = function (k, r) { q.isSome(k) && (e(k, x), l.expand(r, x, r)) }; a.fromFeatureSetJSON = function (k) {
              const r = b.featureGeometryTypeKebabDictionary.fromJSON(k.geometryType), A = n.fromJSON(k.spatialReference), z = k.transform, B = k.features.map(C => {
                var D = k.objectIdFieldName; C = {
                  uid: y.generateUID(), objectId: D && C.attributes ? C.attributes[D] :
                    null, attributes: C.attributes, geometry: t(C.geometry, r, A), visible: !0
                }; D = C.geometry; if (q.isSome(D) && z) switch (D.type) { case "point": C.geometry = h.unquantizePoint(z, D, D, D.hasZ, D.hasM); break; case "multipoint": C.geometry = h.unquantizeMultipoint(z, D, D, D.hasZ, D.hasM); break; case "polygon": C.geometry = h.unquantizePolygon(z, D, D, D.hasZ, D.hasM); break; case "polyline": C.geometry = h.unquantizePolyline(z, D, D, D.hasZ, D.hasM); break; case "extent": C.geometry = D; break; case "mesh": C.geometry = D }return C
              }); return {
                geometryType: r,
                features: B, spatialReference: A, fields: k.fields ? k.fields.map(C => d.fromJSON(C)) : null, objectIdFieldName: k.objectIdFieldName, globalIdFieldName: k.globalIdFieldName, geohashFieldName: k.geohashFieldName, geometryProperties: k.geometryProperties, hasZ: k.hasZ, hasM: k.hasM, exceededTransferLimit: k.exceededTransferLimit, transform: null
              }
            }; a.fromJSONGeometry = t; a.getObjectId = function (k, r) { return null != k.objectId ? k.objectId : k.attributes && r ? k.attributes[r] : null }; a.hasGeometry = function (k) { return q.isSome(k.geometry) }; a.hasVertices =
              function (k) { if (q.isNone(k)) return !1; switch (k.type) { case "extent": case "point": return !0; case "polyline": for (const r of k.paths) if (0 < r.length) return !0; return !1; case "polygon": for (const r of k.rings) if (0 < r.length) return !0; return !1; case "multipoint": return 0 < k.points.length; case "mesh": return !k.loaded || 0 < k.vertexAttributes.position.length } }; a.isFeatureGeometry = function (k) { return b.isFeatureGeometryType(k.type) }; a.makeDehydratedPoint = function (k, r, A, z) {
                return {
                  x: k, y: r, z: A, hasZ: null != A, hasM: !1, spatialReference: z,
                  type: "point"
                }
              }; a.numVertices = function (k) { if (q.isNone(k)) return 0; switch (k.type) { case "point": return 1; case "polyline": var r = 0; for (var A of k.paths) r += A.length; return r; case "polygon": A = 0; for (r of k.rings) A += r.length; return A; case "multipoint": return k.points.length; case "extent": return 2; case "mesh": return (k = k.vertexAttributes && k.vertexAttributes.position) ? k.length / 3 : 0 } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/byteSizeEstimations": function () {
      define(["exports"], function (a) {
        function w(c) {
          return 32 +
            c.length
        } a.estimateAttributesObjectSize = function (c) { if (!c) return 0; let q = 32; for (const u in c) if (c.hasOwnProperty(u)) { const y = c[u]; switch (typeof y) { case "string": q += w(y); break; case "number": q += 16; break; case "boolean": q += 4 } } return q }; a.estimateFixedArraySize = function (c, q) { return 32 + c.length * q }; a.estimateNumberByteSize = function () { return 16 }; a.estimateStringByteSize = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/quantizationUtils": function () {
      define(["exports", "../../core/maybe",
        "./jsonUtils"], function (a, w, c) {
          function q({ scale: E, translate: H }, J) { return Math.round((J - H[0]) / E[0]) } function u({ scale: E, translate: H }, J) { return Math.round((H[1] - J) / E[1]) } function y(E, H, J) { const M = []; let F, K, P, L; for (let N = 0; N < J.length; N++) { const G = J[N]; if (0 < N) { if (P = q(E, G[0]), L = u(E, G[1]), P !== F || L !== K) M.push(H(G, P - F, L - K)), F = P, K = L } else F = q(E, G[0]), K = u(E, G[1]), M.push(H(G, F, K)) } return 0 < M.length ? M : null } function n(E, H, J, M) { return y(E, J ? M ? D : C : M ? C : B, H) } function p(E, H, J, M) {
            const F = []; J = J ? M ? D : C : M ? C : B; for (M = 0; M <
              H.length; M++) { const K = y(E, J, H[M]); K && 3 <= K.length && F.push(K) } return F.length ? F : null
          } function l(E, H, J, M) { const F = []; J = J ? M ? D : C : M ? C : B; for (M = 0; M < H.length; M++) { const K = y(E, J, H[M]); K && 2 <= K.length && F.push(K) } return F.length ? F : null } function h({ scale: E, translate: H }, J) { return J * E[0] + H[0] } function b({ scale: E, translate: H }, J) { return H[1] - J * E[1] } function d(E, H, J) {
            const M = Array(J.length); if (!J.length) return M; const [F, K] = E.scale; let P = h(E, J[0][0]); E = b(E, J[0][1]); M[0] = H(J[0], P, E); for (let L = 1; L < J.length; L++) {
              const N =
                J[L]; P += N[0] * F; E -= N[1] * K; M[L] = H(N, P, E)
            } return M
          } function f(E, H, J) { const M = Array(J.length); for (let F = 0; F < J.length; F++)M[F] = d(E, H, J[F]); return M } function t(E, H, J, M) { return d(E, J ? M ? D : C : M ? C : B, H) } function v(E, H, J, M) { return f(E, J ? M ? D : C : M ? C : B, H) } function m(E, H, J, M) { return f(E, J ? M ? D : C : M ? C : B, H) } function e(E, H, J) {
            let [M, F] = J[0], K = Math.min(M, H[0]), P = Math.min(F, H[1]), L = Math.max(M, H[2]); H = Math.max(F, H[3]); for (let N = 1; N < J.length; N++) {
              const [G, I] = J[N]; M += G; F += I; 0 > G && (K = Math.min(K, M)); 0 < G && (L = Math.max(L, M)); 0 > I ?
                P = Math.min(P, F) : 0 < I && (H = Math.max(H, F))
            } E[0] = K; E[1] = P; E[2] = L; E[3] = H; return E
          } function g(E, H) { if (!H.length) return null; E[0] = E[1] = Number.POSITIVE_INFINITY; E[2] = E[3] = Number.NEGATIVE_INFINITY; for (let J = 0; J < H.length; J++)e(E, E, H[J]); return E } function x(E, H, J, M, F) { H.xmin = q(E, J.xmin); H.ymin = u(E, J.ymin); H.xmax = q(E, J.xmax); H.ymax = u(E, J.ymax); H !== J && (M && (H.zmin = J.zmin, H.zmax = J.zmax), F && (H.mmin = J.mmin, H.mmax = J.mmax)); return H } function k(E, H, J, M, F) { H.points = n(E, J.points, M, F); return H } function r(E, H, J, M, F) {
          H.x =
            q(E, J.x); H.y = u(E, J.y); H !== J && (M && (H.z = J.z), F && (H.m = J.m)); return H
          } function A(E, H, J, M, F) { E = p(E, J.rings, M, F); if (!E) return null; H.rings = E; return H } function z(E, H, J, M, F) { E = l(E, J.paths, M, F); if (!E) return null; H.paths = E; return H } const B = (E, H, J) => [H, J], C = (E, H, J) => [H, J, E[2]], D = (E, H, J) => [H, J, E[2], E[3]]; a.equals = function (E, H) {
            if (E === H || null == E && null == H) return !0; if (null == E || null == H) return !1; let J, M, F, K; E && "upperLeft" === E.originPosition ? (J = E.translate[0], M = E.translate[1], E = E.scale[0]) : (J = w.isSome(E.extent) ? E.extent.xmin :
              0, M = w.isSome(E.extent) ? E.extent.ymax : 0, E = E.tolerance); H && "upperLeft" === H.originPosition ? (F = H.translate[0], K = H.translate[1], H = H.scale[0]) : (F = w.isSome(H.extent) ? H.extent.xmin : 0, K = w.isSome(H.extent) ? H.extent.ymax : 0, H = H.tolerance); return J === F && M === K && E === H
          }; a.getQuantizedBoundsCoordsArray = e; a.getQuantizedBoundsCoordsArrayArray = g; a.getQuantizedBoundsPaths = function (E) { return g([0, 0, 0, 0], E) }; a.getQuantizedBoundsPoints = function (E) {
            const H = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY,
            Number.NEGATIVE_INFINITY]; return e(H, H, E)
          }; a.getQuantizedBoundsRings = function (E) { return g([0, 0, 0, 0], E) }; a.quantizeBounds = function (E, H, J) { H[0] = q(E, J[0]); H[3] = u(E, J[1]); H[2] = q(E, J[2]); H[1] = u(E, J[3]); return H }; a.quantizeExtent = x; a.quantizeGeometry = function (E, H) { return E && H ? c.isPoint(H) ? r(E, {}, H, !1, !1) : c.isPolyline(H) ? z(E, {}, H, !1, !1) : c.isPolygon(H) ? A(E, {}, H, !1, !1) : c.isMultipoint(H) ? k(E, {}, H, !1, !1) : c.isExtent(H) ? x(E, {}, H, !1, !1) : null : null }; a.quantizeMultipoint = k; a.quantizePaths = l; a.quantizePoint = r; a.quantizePoints =
            n; a.quantizePolygon = A; a.quantizePolyline = z; a.quantizeRings = p; a.quantizeX = q; a.quantizeY = u; a.toQuantizationTransform = function (E) { return E ? { originPosition: "upper-left" === E.originPosition ? "upperLeft" : "lower-left" === E.originPosition ? "lowerLeft" : E.originPosition, scale: E.tolerance ? [E.tolerance, E.tolerance] : [1, 1], translate: w.isSome(E.extent) ? [E.extent.xmin, E.extent.ymax] : [0, 0] } : null }; a.unquantizeBounds = function (E, H, J) {
              return J ? (H[0] = h(E, J[0]), H[1] = b(E, J[3]), H[2] = h(E, J[2]), H[3] = b(E, J[1]), H) : [h(E, H[0]), b(E,
                H[3]), h(E, H[2]), b(E, H[1])]
            }; a.unquantizeCoordsArray = d; a.unquantizeCoordsArrayArray = f; a.unquantizeExtent = function (E, H, J, M, F) { H.xmin = h(E, J.xmin); H.ymin = b(E, J.ymin); H.xmax = h(E, J.xmax); H.ymax = b(E, J.ymax); H !== J && (M && (H.zmin = J.zmin, H.zmax = J.zmax), F && (H.mmin = J.mmin, H.mmax = J.mmax)); return H }; a.unquantizeMultipoint = function (E, H, J, M, F) { w.isSome(J) && (H.points = t(E, J.points, M, F)); return H }; a.unquantizePaths = v; a.unquantizePoint = function (E, H, J, M, F) {
              if (w.isNone(J)) return H; H.x = h(E, J.x); H.y = b(E, J.y); H !== J && (M && (H.z =
                J.z), F && (H.m = J.m)); return H
            }; a.unquantizePoints = t; a.unquantizePolygon = function (E, H, J, M, F) { w.isSome(J) && (H.rings = m(E, J.rings, M, F)); return H }; a.unquantizePolyline = function (E, H, J, M, F) { w.isSome(J) && (H.paths = v(E, J.paths, M, F)); return H }; a.unquantizeRings = m; a.unquantizeX = h; a.unquantizeY = b; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/dehydratedFeatureComparison": function () {
      define(["exports", "../../core/has", "../../core/maybe"], function (a, w, c) {
        function q(h, b) {
          if (h === b) return !0;
          if (null == h || null == b || h.length !== b.length) return !1; for (let d = 0; d < h.length; d++) { const f = h[d], t = b[d]; if (f.length !== t.length) return !1; for (let v = 0; v < f.length; v++)if (f[v] !== t[v]) return !1 } return !0
        } function u(h, b) { if (h === b) return !0; if (null == h || null == b || h.length !== b.length) return !1; for (let d = 0; d < h.length; d++)if (!q(h[d], b[d])) return !1; return !0 } function y(h, b) { return n(h.spatialReference, b.spatialReference) ? h.x === b.x && h.y === b.y && h.z === b.z && h.m === b.m : !1 } function n(h, b) { return h === b || h && b && h.equals(b) } function p(h,
          b) {
            if (h === b) return !0; if (c.isNone(h) || c.isNone(b) || h.type !== b.type) return !1; switch (h.type) {
              case "point": return y(h, b); case "extent": return h = h.hasZ !== b.hasZ || h.hasM !== b.hasM ? !1 : n(h.spatialReference, b.spatialReference) ? h.xmin === b.xmin && h.ymin === b.ymin && h.zmin === b.zmin && h.xmax === b.xmax && h.ymax === b.ymax && h.zmax === b.zmax : !1, h; case "polyline": return h = h.hasZ !== b.hasZ || h.hasM !== b.hasM ? !1 : n(h.spatialReference, b.spatialReference) ? u(h.paths, b.paths) : !1, h; case "polygon": return h = h.hasZ !== b.hasZ || h.hasM !== b.hasM ?
                !1 : n(h.spatialReference, b.spatialReference) ? u(h.rings, b.rings) : !1, h; case "multipoint": return h = h.hasZ !== b.hasZ || h.hasM !== b.hasM ? !1 : n(h.spatialReference, b.spatialReference) ? q(h.points, b.points) : !1, h; case "mesh": return !1
            }
        } function l(h, b) { if (h === b) return !0; if (!h || !b) return !1; const d = Object.keys(h), f = Object.keys(b); if (d.length !== f.length) return !1; for (const t of d) if (h[t] !== b[t]) return !1; return !0 } a.equals = function (h, b) {
          return h === b ? !0 : null != h && null != b && h.objectId === b.objectId && p(h.geometry, b.geometry) &&
            l(h.attributes, b.attributes) ? !0 : !1
        }; a.pointEquals = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/support/labelFormatUtils": function () {
      define("require exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/Logger ../../intl/date ../../intl/number ./fieldUtils ./labelUtils ../../support/arcadeOnDemand".split(" "), function (a, w, c, q, u, y, n, p, l, h) {
        function b() {
          b = c._asyncToGenerator(function* (m, e, g) {
            if (!m || !m.symbol) return t; const x = m.where, k = l.getLabelExpression(m);
            m = x ? yield new Promise((r, A) => a(["../../core/sql/WhereClause"], r, A)) : null; if ("arcade" === k.type) {
              const r = yield h.createLabelExpression(k.expression, g, e); g = {
                type: "arcade", evaluate(A) { try { const z = r.evaluate({ $feature: "attributes" in A ? r.repurposeFeature(A) : r.repurposeAdapter(A) }); if (null != z) return z.toString() } catch (z) { f.error(new q("bad-arcade-expression", "Encountered an error when evaluating label expression for feature", { feature: A, expression: k })) } return null }, needsHydrationToEvaluate() {
                  return null ==
                    l.getSingleFieldArcadeExpression(k.expression)
                }
              }
            } else g = { type: "simple", evaluate(r) { return k.expression.replace(/{[^}]*}/g, A => { var z = A.slice(1, -1); z = e.get(z); if (!z) return A; A = null; "attributes" in r ? r && r.attributes && (A = r.attributes[z.name]) : A = r.field(z.name); return null == A ? "" : d(A, z) }) } }; if (x) { let r; try { r = m.WhereClause.create(x, e) } catch (z) { return t } const A = g.evaluate; g.evaluate = z => r.testFeature(z, "attributes" in z ? void 0 : v) ? A(z) : null } return g
          }); return b.apply(this, arguments)
        } function d(m, e) {
          if (null == m) return "";
          const g = e.domain; if (g) if ("codedValue" === g.type || "coded-value" === g.type) for (var x of g.codedValues) { if (x.code === m) return x.name } else if ("range" === g.type) { x = +m; const k = "range" in g ? g.range[1] : g.maxValue; if (("range" in g ? g.range[0] : g.minValue) <= x && x <= k) return g.name } "date" === e.type || "esriFieldTypeDate" === e.type ? m = y.formatDate(m, y.convertDateFormatToIntlOptions("short-date")) : p.isNumericField(e) && (m = n.formatNumber(+m)); return m ? m : ""
        } const f = u.getLogger("esri.layers.support.labelFormatUtils"), t = {
          type: "simple",
          evaluate() { return null }
        }, v = { getAttribute(m, e) { return m.field(e) } }; w.createLabelFunction = function (m, e, g) { return b.apply(this, arguments) }; w.formatField = d; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DCalloutSymbolLayerFactory": function () {
      define(["exports", "../../../../core/Logger", "../../../../symbols/callouts/calloutUtils", "./Graphics3DLineCalloutSymbolLayer"], function (a, w, c, q) {
        const u = w.getLogger("esri.views.3d.layers.graphics.Graphics3DCalloutSymbolLayerFactory"),
        y = { line: q.Graphics3DLineCalloutSymbolLayer }; a.make = function (n, p) { if (!c.isCalloutSupport(n)) return u.error("Graphics3DCalloutSymbolLayerFactory#make", `symbol of type '${n.type}' does not support callouts`), null; if (!n.callout) return null; const l = y[n.callout.type]; return l ? new l(n, p) : (u.error("Graphics3DCalloutSymbolLayerFactory#make", `unknown or unsupported callout type ${n.callout.type}`), null) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DLineCalloutSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/maybe ../../../../core/screenUtils ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ./pointUtils ./symbolComplexity ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/Material ../../webgl-engine/materials/LineCalloutMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          h = function (r) {
            function A(B, C) { B = r.call(this, B, null, C, k) || this; B._elevationOptions = { supportsOffsetAdjustment: !0, supportsOnTheGround: !1 }; B.ensureDrapedStatus(!1); return B } w._inheritsLoose(A, r); var z = A.prototype; z.doLoad = function () { var B = w._asyncToGenerator(function* () { this._material = new m.LineCalloutMaterial(this.materialParameters); this._context.stage.add(this._material) }); return function () { return B.apply(this, arguments) } }(); z.destroy = function () {
              r.prototype.destroy.call(this);
              this._context.stage.remove(this._material); this._material = null
            }; z.perInstanceMaterialParameters = function (B) { const C = this.materialParameters; C.screenOffset = B.screenOffset || [0, 0]; C.centerOffsetUnits = B.centerOffsetUnits || "world"; return C }; z._defaultElevationInfoNoZ = function () { return x }; z.createGraphics3DGraphic = function (B) {
              const C = B.renderingInfo; B = B.graphic; const D = this.setGraphicElevationContext(B, new p.ElevationContext, C.elevationOffset || 0); var E = C.symbol; const H = "on-the-ground" === this._elevationContext.mode &&
                ("cim" === E.type || !E.symbolLayers.some(J => "object" === J.type || "text" === J.type)); if ("label-3d" !== E.type && H) return null; E = b.computeCentroid(B.geometry); return q.isNone(E) ? null : this._createAs3DShape(E, D, C, B.uid)
            }; z.layerOpacityChanged = function () { if (q.isNone(this._material)) return !0; this._material.setParameters(this.materialParameters); return !0 }; z.layerElevationInfoChanged = function (B, C, D) {
              D = n.elevationModeChangeUpdateType(A.elevationModeChangeTypes, D, this._elevationContext.mode); if (D !== n.SymbolUpdateType.UPDATE) return D;
              B.forEach(E => { const H = C(E); q.isSome(H) && this.updateGraphicElevationContext(E.graphic, H) }); return D
            }; z.slicePlaneEnabledChanged = function () { if (q.isNone(this._material)) return !0; this._material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); return !0 }; z.physicalBasedRenderingChanged = function () { return !0 }; z.pixelRatioChanged = function () { return !0 }; z.setGraphicElevationContext = function (B, C, D = 0) { B = r.prototype.setGraphicElevationContext.call(this, B, C); B.addOffsetRenderUnits(D); return B }; z.updateGraphicElevationContext =
              function (B, C) { this.setGraphicElevationContext(B, C.elevationContext, C.metadata.elevationOffset); C.needsElevationUpdates = n.needsElevationUpdates2D(C.elevationContext.mode) }; z.updateGeometry = function (B, C) { return !1 }; z.computeComplexity = function () { return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: !1, memory: f.emptySymbolComplexity.memory } }; z.createVertexData = function (B) {
                const { translation: C, centerOffset: D } = B; return [["position", C ? { size: 3, data: [C[0], C[1], C[2]], exclusive: !0 } :
                  { size: 3, data: [0, 0, 0], exclusive: !0 }], ["normal", { size: 3, data: [0, 0, 1], exclusive: !0 }], ["auxpos1", D ? { size: 4, data: [D[0], D[1], D[2], D[3]], exclusive: !0 } : { size: 4, data: [0, 0, 0, 1], exclusive: !0 }]]
              }; z._getOrCreateMaterial = function (B) {
                const C = this.perInstanceMaterialParameters(B), D = m.LineCalloutMaterial.uniqueMaterialIdentifier(C); if (q.isSome(this._material) && D === this._material.uniqueMaterialIdentifier) return { material: this._material, isUnique: !1 }; if (B.materialCollection) {
                  let E = B.materialCollection.get(D); q.isNone(E) &&
                    (E = new m.LineCalloutMaterial(C), B.materialCollection.add(D, E)); return { material: E, isUnique: !1 }
                } return { material: new m.LineCalloutMaterial(C), isUnique: !0 }
              }; z._createAs3DShape = function (B, C, D, E) {
                var H = [new t.Geometry(this.createVertexData(D), g, 1)]; const J = this._getOrCreateMaterial(D); E = d.createStageObjectForHUD(this._context, B, H, [J.material], C, this._context.layer.uid, E); if (null === E) return null; H = new l.Graphics3DObject3DGraphicLayer(this, E.object, H, J.isUnique ? [J.material] : null, null, y.perObjectElevationAligner,
                  C); H.metadata = { elevationOffset: D.elevationOffset || 0 }; H.alignedSampledElevation = E.sampledElevation; H.needsElevationUpdates = n.needsElevationUpdates2D(C.mode); d.extendPointGraphicElevationContext(H, B, this._context.elevationProvider); return H
              }; w._createClass(A, [{
                key: "materialParameters", get: function () {
                  const B = this.symbol; var C = B.callout; const D = q.isSome(C.color) ? c.toUnitRGBA(C.color) : [0, 0, 0, 0]; D[3] *= this._getLayerOpacity(); const E = u.pt2px(C.size || 0); let H = null; if (B.verticalOffset) {
                    const { screenLength: M,
                      minWorldLength: F, maxWorldLength: K } = B.verticalOffset; H = { screenLength: u.pt2px(M), minWorldLength: F || 0, maxWorldLength: null != K ? K : Infinity }
                  } C = q.isSome(C.border) && q.isSome(C.border.color) ? c.toUnitRGBA(C.border.color) : null; const J = "object" === B.symbolLayers.getItemAt(0).type; return {
                    color: D, size: E, verticalOffset: H, screenSizePerspective: this._context.screenSizePerspectiveEnabled ? this._context.sharedResources.screenSizePerspectiveSettings : null, screenOffset: [0, 0], centerOffsetUnits: "world", borderColor: C, occlusionTest: !J,
                    shaderPolygonOffset: J ? 0 : void 0, depthHUDAlignStart: "label-3d" === B.type, slicePlaneEnabled: this._context.slicePlaneEnabled, renderOccluded: v.materialParametersDefaults.renderOccluded
                  }
                }
              }]); return A
          }(h.Graphics3DSymbolLayer); h.elevationModeChangeTypes = { definedChanged: n.SymbolUpdateType.UPDATE, staysOnTheGround: n.SymbolUpdateType.UPDATE, onTheGroundChanged: n.SymbolUpdateType.RECREATE }; const e = new Uint16Array([0]), g = [["position", e], ["normal", e], ["auxpos1", e]], x = { mode: "relative-to-ground", offset: 0 }, k = {
            ignoreDrivers: !0,
            renderPriority: 0, renderPriorityStep: 1
          }; a.Graphics3DLineCalloutSymbolLayer = h; a.default = h; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/ElevationAligners": function () {
      define("exports ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ./elevationAlignmentUtils ./graphicUtils ../../support/debugFlags ../../support/ElevationProvider".split(" "), function (a, w, c, q,
        u, y, n, p, l, h, b) {
          const d = q.create(), f = y.create(), t = y.create(), v = y.create(), m = q.create(), e = y.create(), g = new p.SampleElevationInfo; a.perLodInstanceElevationAligner = function (x, k, r, A) {
            var z = x.graphics3DSymbolLayer.lodRenderer; if (w.isNone(z)) return 0; const B = k.centerPointInElevationSR; p.evaluateElevationInfoAtPoint(B, r, k, A, g); k = "absolute-height" !== k.mode ? g.sampledElevation : 0; z = z.instanceData; x = x.instanceIndex; z.getGlobalTransform(x, m); r = u.set(e, m[12], m[13], m[14]); h.TESTS_DISABLE_OPTIMIZATIONS ? (f[0] = B.x,
              f[1] = B.y, f[2] = g.z, n.computeTranslationToOriginAndRotation(B.spatialReference, f, m, A.spatialReference) && z.setGlobalTransform(x, m)) : A.setAltitudeOfTransformation(g.z, m); A = .01 / A.unitInMeters; (h.TESTS_DISABLE_OPTIMIZATIONS || Math.abs(m[12] - r[0]) >= A || Math.abs(m[13] - r[1]) >= A || Math.abs(m[14] - r[2]) >= A) && z.setGlobalTransform(x, m); return k
          }; a.perObjectElevationAligner = function (x, k, r, A) {
            x = x.stageObject; const z = k.centerPointInElevationSR; let B = 0; x.metadata.usesVerticalDistanceToGround ? (p.evaluateElevationInfoAtPoint(z,
              r, k, A, g), l.updateVertexAttributeAuxpos1w(x, g.verticalDistanceToGround), B = g.sampledElevation) : (p.evaluateElevationInfoAtPoint(z, r, k, A, g), "absolute-height" !== k.mode && (B = g.sampledElevation)); k = c.copy(d, x.transformation); r = u.set(e, k[12], k[13], k[14]); h.TESTS_DISABLE_OPTIMIZATIONS ? (f[0] = z.x, f[1] = z.y, f[2] = g.z, n.computeTranslationToOriginAndRotation(z.spatialReference, f, k, A.spatialReference) && (x.transformation = k)) : A.setAltitudeOfTransformation(g.z, k); A = .01 / A.unitInMeters; if (Math.abs(k[12] - r[0]) >= A || Math.abs(k[13] -
                r[1]) >= A || Math.abs(k[14] - r[2]) >= A) x.transformation = k; return B
          }; a.perVertexElevationAligner = function (x, k, r, A) {
            x = x.stageObject; const z = r.spatialReference, B = x.geometryRecords, C = "absolute-height" !== k.mode; let D = 0; for (const F of B) {
              var E = F.geometry, H = F.getShaderTransformation(); t[0] = H[12]; t[1] = H[13]; t[2] = H[14]; E.invalidateBoundingInfo(); var J = E.getMutableAttribute("position"); H = J.data; var M = E.vertexAttributes.get("mapPos").data; E = J.size; J = H.length / E; M = new b.SamplePosition(M, z); let K = 0, P = !1, L = 0; for (let N =
                0; N < J; N++) {
                v[0] = H[K]; v[1] = H[K + 1]; v[2] = H[K + 2]; p.evaluateElevationInfoAtPoint(M, r, k, A, g); C && (L += g.sampledElevation); if (h.TESTS_DISABLE_OPTIMIZATIONS) H[K] = M.array[M.offset], H[K + 1] = M.array[M.offset + 1], H[K + 2] = g.z, n.projectBuffer(H, z, K, H, A.spatialReference, K, 1), H[K] -= t[0], H[K + 1] -= t[1], H[K + 2] -= t[2], P = !0; else {
                f[0] = H[K] + t[0]; f[1] = H[K + 1] + t[1]; f[2] = H[K + 2] + t[2]; A.setAltitude(f, g.z); H[K] = f[0] - t[0]; H[K + 1] = f[1] - t[1]; H[K + 2] = f[2] - t[2]; const G = .01 / A.unitInMeters; if (Math.abs(v[0] - H[K]) >= G || Math.abs(v[1] - H[K + 1]) >= G ||
                  Math.abs(v[2] - H[K + 2]) >= G) P = !0
                } K += E; M.offset += 3
              } D += L / J; P && x.geometryVertexAttrsUpdated(F)
            } return D / B.length
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/elevationAlignmentUtils": function () {
      define("exports ../../../../core/compilerUtils ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../layers/graphics/dehydratedFeatureUtils ./graphicUtils ../../support/ElevationProvider".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          function b(e, g, x, k, r) {
            const A = (p.isDehydratedPoint(e) ? e.z : h.isSamplePosition(e) ? e.array[e.offset + 2] : e[2]) || 0; switch (x.mode) {
              case "on-the-ground": x = c.unwrapOr(h.getElevationAtPoint(g, e, "ground"), 0); r.verticalDistanceToGround = 0; r.sampledElevation = x; r.z = x; break; case "relative-to-ground": e = c.unwrapOr(h.getElevationAtPoint(g, e, "ground"), 0); x = x.geometryZWithOffset(A, k); r.verticalDistanceToGround = x; r.sampledElevation = e; r.z = x + e; break; case "relative-to-scene": e = c.unwrapOr(h.getElevationAtPoint(g,
                e, "scene"), 0); x = x.geometryZWithOffset(A, k); r.verticalDistanceToGround = x; r.sampledElevation = e; r.z = x + e; break; case "absolute-height": x = x.geometryZWithOffset(A, k); k = c.unwrapOr(h.getElevationAtPoint(g, e, "ground"), 0); r.verticalDistanceToGround = x - k; r.sampledElevation = k; r.z = x; break; default: w.neverReached(x.mode), r.z = 0
            }
          } let d = function () { this.z = this.sampledElevation = this.verticalDistanceToGround = 0 }; a.SymbolUpdateType = void 0; (function (e) { e[e.NONE = 0] = "NONE"; e[e.UPDATE = 1] = "UPDATE"; e[e.RECREATE = 2] = "RECREATE" })(a.SymbolUpdateType ||
            (a.SymbolUpdateType = {})); const f = {
              "absolute-height": { applyElevationAlignmentBuffer: function (e, g, x, k, r, A, z, B) { A = B.calculateOffsetRenderUnits(z); B = B.featureExpressionInfoContext; g *= 3; k *= 3; for (z = 0; z < r; ++z) { const C = e[g + 1], D = e[g + 2]; x[k + 0] = e[g + 0]; x[k + 1] = C; x[k + 2] = null == B ? D + A : A; g += 3; k += 3 } return 0 }, requiresAlignment: function (e) { const g = e.featureExpressionInfoContext; return 0 !== e.meterUnitOffset || null != g } }, "on-the-ground": {
                applyElevationAlignmentBuffer: function (e, g, x, k, r, A) {
                  let z = 0; const B = A.spatialReference;
                  g *= 3; k *= 3; for (let C = 0; C < r; ++C) { const D = e[g + 0], E = e[g + 1], H = c.unwrapOr(A.getElevation(D, E, e[g + 2], B, "ground"), 0); z += H; x[k + 0] = D; x[k + 1] = E; x[k + 2] = H; g += 3; k += 3 } return z / r
                }, requiresAlignment: () => !0
              }, "relative-to-ground": {
                applyElevationAlignmentBuffer: function (e, g, x, k, r, A, z, B) {
                  let C = 0; z = B.calculateOffsetRenderUnits(z); B = B.featureExpressionInfoContext; const D = A.spatialReference; g *= 3; k *= 3; for (let E = 0; E < r; ++E) {
                    const H = e[g + 0], J = e[g + 1], M = e[g + 2], F = c.unwrapOr(A.getElevation(H, J, M, D, "ground"), 0); C += F; x[k + 0] = H; x[k + 1] =
                      J; x[k + 2] = null == B ? M + F + z : F + z; g += 3; k += 3
                  } return C / r
                }, requiresAlignment: () => !0
              }, "relative-to-scene": { applyElevationAlignmentBuffer: function (e, g, x, k, r, A, z, B) { let C = 0; z = B.calculateOffsetRenderUnits(z); B = B.featureExpressionInfoContext; const D = A.spatialReference; g *= 3; k *= 3; for (let E = 0; E < r; ++E) { const H = e[g + 0], J = e[g + 1], M = e[g + 2], F = c.unwrapOr(A.getElevation(H, J, M, D, "scene"), 0); C += F; x[k + 0] = H; x[k + 1] = J; x[k + 2] = null == B ? M + F + z : F + z; g += 3; k += 3 } return C / r }, requiresAlignment: () => !0 }
            }, t = u.create(), v = new d, m = y.create(); a.SampleElevationInfo =
              d; a.applyElevationAlignmentForHUD = function (e, g, x, k, r) { b(g, x, r, k, v); l.updateVertexAttributeAuxpos1w(e, v.verticalDistanceToGround); x = v.sampledElevation; r = q.copy(t, e.transformation); m[0] = g.x; m[1] = g.y; m[2] = v.z; n.computeTranslationToOriginAndRotation(g.spatialReference, m, r, k.spatialReference) ? e.transformation = r : console.warn("Could not locate symbol object properly, it might be misplaced"); return x }; a.applyPerVertexElevationAlignment = function (e, g, x, k, r, A, z, B, C, D, E) {
                const H = f[E.mode]; let J = 0; if (n.projectBuffer(e,
                  g, x, k, C.spatialReference, r, B) && (H.requiresAlignment(E) ? (J = H.applyElevationAlignmentBuffer(k, r, A, z, B, C, D, E), e = A, r = z) : e = k, n.projectBuffer(e, C.spatialReference, r, A, D.spatialReference, z, B))) return J
              }; a.elevationModeChangeUpdateType = function (e, g, x) { return null == g || null == x ? e.definedChanged : "on-the-ground" === g && "on-the-ground" === x ? e.staysOnTheGround : g === x || "on-the-ground" !== g && "on-the-ground" !== x ? a.SymbolUpdateType.UPDATE : e.onTheGroundChanged }; a.evaluateElevationAlignmentAtPoint = function (e, g, x, k) {
                b(e, g,
                  x, k, v); return v.z
              }; a.evaluateElevationInfoAtPoint = b; a.needsElevationUpdates2D = function (e) { return "relative-to-ground" === e || "relative-to-scene" === e }; a.needsElevationUpdates3D = function (e) { return "absolute-height" !== e }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/graphicUtils": function () {
      define("exports ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2f64 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/centroid ../../../../geometry/support/coordsUtils ../../../../layers/graphics/dehydratedFeatures ../../../../layers/graphics/hydratedFeatures".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(x) { var k = x.paths[0]; if (!k || 0 === k.length) return null; k = f.getPointOnPath(k, f.getPathLength(k) / 2); return t.makeDehydratedPoint(k[0], k[1], k[2], x.spatialReference) } function e(x, k, r) { r = r ? x : v.clonePoint(x); return k && x ? l.projectPoint(x, r, k) ? r : null : r } function g(x) { if (Array.isArray(x)) { for (const k of x) if (!g(k)) return !1; return !0 } return null == x || 0 <= x } u = {
            "bottom-left": u.fromValues(0, 0), bottom: u.fromValues(.5, 0), "bottom-right": u.fromValues(1, 0), left: u.fromValues(0,
              .5), center: u.fromValues(.5, .5), right: u.fromValues(1, .5), "top-left": u.fromValues(0, 1), top: u.fromValues(.5, 1), "top-right": u.fromValues(1, 1)
          }; a.computeCentroid = function (x, k) {
            if ("point" === x.type) return e(x, k, !1); if (v.isHydratedGeometry(x)) switch (x.type) { case "extent": return e(x.center, k, !1); case "polygon": return e(x.centroid, k, !1); case "polyline": return e(m(x), k, !0); case "mesh": return e(x.origin, k, !1) } else switch (x.type) {
              case "extent": var r = isFinite(x.zmin); x = t.makeDehydratedPoint(.5 * (x.xmax + x.xmin),
                .5 * (x.ymax + x.ymin), r ? .5 * (x.zmax + x.zmin) : void 0, x.spatialReference); return e(x, k, !0); case "polygon": return (r = x.rings[0]) && 0 !== r.length ? (r = d.ringsCentroid(x.rings, x.hasZ), x = t.makeDehydratedPoint(r[0], r[1], r[2], x.spatialReference)) : x = null, e(x, k, !0); case "polyline": return e(m(x), k, !0)
            }
          }; a.computeObjectRotation = function (x, k, r, A = q.create()) { x = x || 0; k = k || 0; r = r || 0; 0 !== x && c.rotateZ(A, A, -x / 180 * Math.PI); 0 !== k && c.rotateX(A, A, k / 180 * Math.PI); 0 !== r && c.rotateY(A, A, r / 180 * Math.PI); return A }; a.computeObjectScale = function (x =
            y.ONES, k, r, A = 1) { const z = Array(3); if (w.isNone(k) || w.isNone(r)) z[0] = 1, z[1] = 1, z[2] = 1; else { let C = 0; for (let D = 2; 0 <= D; D--) { const E = x[D]; let H; const J = null != E, M = 0 === D && !B && !J, F = r[D]; "symbol-value" === E || M ? H = 0 !== F ? k[D] / F : 1 : J && "proportional" !== E && isFinite(E) && (H = 0 !== F ? E / F : 1); if (null != H) { var B = z[D] = H; C = Math.max(C, Math.abs(H)) } } for (x = 2; 0 <= x; x--)null == z[x] ? z[x] = B : 0 === z[x] && (z[x] = .001 * C) } for (B = 2; 0 <= B; B--)z[B] /= A; return y.fromArray(z) }; a.demResolutionForBoundingBox = function (x, k) {
              return null != k.minDemResolution ?
                k.minDemResolution : h.isPoint(x) ? k.minDemResolutionForPoints : .01 * h.maximumDimension(x)
            }; a.enlargeExtent = function (x, k, r, A = 0) { if (x) { k || (k = b.create()); let z = .5 * x.width * (r - 1); r = .5 * x.height * (r - 1); x.width < 1E-7 * x.height ? z += r / 20 : x.height < 1E-7 * x.width && (r += z / 20); n.set(k, x.xmin - z - A, x.ymin - r - A, x.xmax + z + A, x.ymax + r + A); return k } return null }; a.isValidSize = g; a.mixinColorAndOpacity = function (x, k) {
              const r = p.clone(p.ONES); w.isSome(x) && (r[0] = x[0], r[1] = x[1], r[2] = x[2]); w.isSome(k) ? r[3] = k : w.isSome(x) && 3 < x.length && (r[3] = x[3]);
              return r
            }; a.namedAnchorToHUDMaterialAnchorPos = u; a.overrideColor = function (x, k, r, A, z, B = [0, 0, 0, 0]) { for (let C = 0; 3 > C; ++C)w.isSome(x) && null != x[C] ? B[C] = x[C] : w.isSome(r) && null != r[C] ? B[C] = r[C] : B[C] = z[C]; w.isSome(k) ? B[3] = k : w.isSome(A) ? B[3] = A : B[3] = z[3]; return B }; a.updateVertexAttributeAuxpos1w = function (x, k) { for (let r = 0; r < x.geometries.length; ++r) { const A = x.geometries[r].getMutableAttribute("auxpos1"); A && A.data[3] !== k && (A.data[3] = k, x.geometryVertexAttrsUpdated(x.geometryRecords[r])) } }; a.validateSymbolLayerSize =
              function (x) { null != x.isPrimitive && (x = [x.width, x.depth, x.height]); return g(x) ? null : "Symbol sizes may not be negative values" }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/ElevationContext": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "../../../../symbols/support/unitConversionUtils", "./featureExpressionInfoUtils"], function (a, w, c, q, u) {
        let y = function () {
          function n() {
          this._renderUnitOffset = this._meterUnitOffset =
            0; this._unit = "meters"; this._metersPerElevationInfoUnit = 1; this.mode = this.centerPointInElevationSR = this._featureExpressionInfoContext = null
          } var p = n.prototype; p.reset = function () { this.mode = null; this._renderUnitOffset = this._meterUnitOffset = 0; this._featureExpressionInfoContext = null; this.unit = "meters" }; p.addOffsetRenderUnits = function (l) { this._renderUnitOffset += l }; p.geometryZWithOffset = function (l, h) { h = this.calculateOffsetRenderUnits(h); return null != this.featureExpressionInfoContext ? h : l + h }; p.calculateOffsetRenderUnits =
            function (l) { let h = this._meterUnitOffset; const b = this.featureExpressionInfoContext; null != b && (h += u.execute(b) * this._metersPerElevationInfoUnit); return h / l.unitInMeters + this._renderUnitOffset }; p.setFromElevationInfo = function (l) { this.mode = l.mode; this.unit = q.supportsUnit(l.unit) ? l.unit : "meters"; this.offsetElevationInfoUnits = c.unwrapOr(l.offset, 0) }; p.updateFeatureExpressionInfoContext = function (l, h, b) {
              if (c.isNone(l)) this._featureExpressionInfoContext = null; else {
                var d = l && l.arcade; d && c.isSome(h) && c.isSome(b) ?
                  (this._featureExpressionInfoContext = u.clone(l), u.setContextFeature(this._featureExpressionInfoContext, u.createFeature(d.modules, h, b))) : this._featureExpressionInfoContext = l
              }
            }; n.fromElevationInfo = function (l) { const h = new n; c.isSome(l) && h.setFromElevationInfo(l); return h }; w._createClass(n, [{ key: "featureExpressionInfoContext", get: function () { return this._featureExpressionInfoContext } }, { key: "meterUnitOffset", get: function () { return this._meterUnitOffset } }, {
              key: "unit", get: function () { return this._unit }, set: function (l) {
              this._unit =
                l; this._metersPerElevationInfoUnit = q.getMetersPerUnit(l)
              }
            }, { key: "offsetMeters", set: function (l) { this._meterUnitOffset = l; this._renderUnitOffset = 0 } }, { key: "offsetElevationInfoUnits", set: function (l) { this._meterUnitOffset = l * this._metersPerElevationInfoUnit; this._renderUnitOffset = 0 } }]); return n
        }(); a.ElevationContext = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/featureExpressionInfoUtils": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/Logger",
        "../../../../layers/graphics/hydratedFeatures", "../../../../support/arcadeOnDemand"], function (a, w, c, q, u) {
          function y() {
            y = w._asyncToGenerator(function* (p, l, h) {
              p = p && p.expression; if ("string" !== typeof p) return null; var b = "0" === p ? 0 : null; if (null != b) return { cachedResult: b }; b = yield u.loadArcade(); const d = b.arcadeUtils; p = d.createSyntaxTree(p); return d.dependsOnView(p) ? (null != h && h.error("Expressions containing '$view' are not supported on ElevationInfo"), { cachedResult: 0 }) : {
                arcade: {
                  func: d.createFunction(p), context: d.createExecContext(null,
                    { sr: l }), modules: b
                }
              }
            }); return y.apply(this, arguments)
          } const n = c.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils"); a.clone = function (p) { return { cachedResult: p.cachedResult, arcade: p.arcade ? { func: p.arcade.func, context: p.arcade.modules.arcadeUtils.createExecContext(null, { sr: p.arcade.context.spatialReference }), modules: p.arcade.modules } : null } }; a.createContext = function (p, l, h) { return y.apply(this, arguments) }; a.createContextWithoutExpressionSupport = function (p) {
            p = p && p.expression; return "string" ===
              typeof p && (p = "0" === p ? 0 : null, null != p) ? { cachedResult: p } : null
          }; a.createFeature = function (p, l, h) { return p.arcadeUtils.createFeature(l.attributes, l.geometry, h) }; a.execute = function (p) { if (null != p) { if (null != p.cachedResult) return p.cachedResult; var l = p.arcade; l = p.arcade.modules.arcadeUtils.executeFunction(l.func, l.context); "number" !== typeof l && (l = p.cachedResult = 0); return l } return 0 }; a.extractExpressionInfo = function (p, l = !1) { const h = (p = p && p.featureExpressionInfo) && p.expression; l || "0" === h || (p = null); return p };
          a.setContextFeature = function (p, l) { null != p && null == p.cachedResult && (l && p.arcade ? (l._geometry && (l._geometry = q.hydrateGeometry(l._geometry)), p.arcade.modules.arcadeUtils.updateExecContext(p.arcade.context, l)) : n.errorOncePerTick("Arcade support required but not provided")) }; a.zeroContext = { cachedResult: 0 }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DObject3DGraphicLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingBox ../../../../chunks/sphere ./featureExpressionInfoUtils ./graphicUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(m) { return m.isVisible ? m.parameters.transparent ? 1 : 2 : 0 } let b = function () {
            function m(g, x, k, r, A, z, B, C = null) {
            this.graphics3DSymbolLayer = g; this.stageObject = x; this._uniqueGeometries = k; this._uniqueMaterials = r; this._uniqueTextures = A; this.elevationAligner = z; this.elevationContext = B; this._edgeState = C; this.type = "object3d"; this._stage = this._stageLayer = null; this._addedToStage = this._visible = !1; this.alignedSampledElevation = 0; this.useObjectOriginAsAttachmentOrigin = this.needsElevationUpdates =
              !1; this.graphics3DSymbolLayer = g; this.stageObject = x
            } var e = m.prototype; e.initialize = function (g, x) { this._stageLayer = x; this._stage = g; g.addMany(this._uniqueMaterials); g.addMany(this._uniqueGeometries); g.addMany(this._uniqueTextures); g.load(this._uniqueTextures); g.add(this.stageObject) }; e.destroy = function () {
              var g = this._stage; this._stageLayer && (g.removeMany(this._uniqueMaterials), g.removeMany(this._uniqueGeometries), g.removeMany(this._uniqueTextures)); g.remove(this.stageObject); this._addedToStage && (this._stageLayer.remove(this.stageObject),
                this._addedToStage = !1); g = this._stage.renderView.ensureEdgeView(); g.hasObject(this.stageObject) && g.removeObject(this.stageObject); this.stageObject.dispose(); this._visible = !1; this._stage = this._stageLayer = null
            }; e.layerOpacityChanged = function (g, x) {
              if (!c.isNone(this._edgeState)) {
                var k = h(this._edgeState.baseMaterial), r = !1; for (const A of this._edgeState.edgeMaterials) A.objectTransparency !== k && (A.objectTransparency = k, r = !0); r && this.resetEdgeObject(x); this._stage.renderView.ensureEdgeView().updateAllComponentOpacities(this.stageObject,
                  [g])
              }
            }; e.slicePlaneEnabledChanged = function (g, x) { c.isNone(this._edgeState) || (this._stage.renderView.ensureEdgeView().updateAllComponentMaterials(this.stageObject, this._edgeState.edgeMaterials, { slicePlaneEnabled: g }, !x), this._edgeState.properties.slicePlaneEnabled = g) }; e.setVisibility = function (g) {
              if (null != this._stage && this._visible !== g && ((this._visible = g) ? this._addedToStage ? this.stageObject.setVisible(!0) : (this._stageLayer.add(this.stageObject), this._addedToStage = !0) : this.stageObject.setVisible(!1), c.isSome(this._edgeState))) {
                const x =
                  this._stage.renderView.ensureEdgeView(); x.hasObject(this.stageObject) ? x.updateObjectVisibility(this.stageObject, g) : g && this.addOrUpdateEdgeObject(x, !1)
              }
            }; e.alignWithElevation = function (g, x, k, r) { null != this.elevationAligner && (c.isSome(k) && p.setContextFeature(this.elevationContext.featureExpressionInfoContext, k), this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, g, x), this.resetEdgeObject(r)) }; e.getCenterObjectSpace = function (g = u.create()) { return q.copy(g, n.getCenter(this.stageObject.boundingVolumeObjectSpace.bounds)) };
            e.getBoundingBoxObjectSpace = function (g = y.create()) { const x = this.stageObject.boundingVolumeObjectSpace; y.setMin(g, x.min); y.setMax(g, x.max); return g }; e.computeAttachmentOrigin = function (g) {
              if (this.useObjectOriginAsAttachmentOrigin) { var x = this.stageObject.transformation; g.render.origin[0] += x[12]; g.render.origin[1] += x[13]; g.render.origin[2] += x[14]; g.render.num++ } else for (x of this.stageObject.geometryRecords) x.computeAttachmentOrigin(t) && (q.transformMat4(t, t, this.stageObject.transformation), q.add(g.render.origin,
                g.render.origin, t), g.render.num++)
            }; e.getProjectedBoundingBox = function () {
              var g = w._asyncToGenerator(function* (x, k, r, A, z) {
                z = this.getBoundingBoxObjectSpace(z); var B = v, C = y.isPoint(z) ? 1 : B.length; for (var D = 0; D < C; D++) { const E = B[D]; f[0] = z[E[0]]; f[1] = z[E[1]]; f[2] = z[E[2]]; q.transformMat4(f, f, this.stageObject.transformation); d[3 * D] = f[0]; d[3 * D + 1] = f[1]; d[3 * D + 2] = f[2] } if (!x(d, 0, C)) return null; y.empty(z); x = null; this.calculateRelativeScreenBounds && (x = this.calculateRelativeScreenBounds()); for (B = 0; B < 3 * C; B += 3) {
                  for (D =
                    0; 3 > D; D++)z[D] = Math.min(z[D], d[B + D]), z[D + 3] = Math.max(z[D + 3], d[B + D]); x && r.push({ location: d.slice(B, B + 3), screenSpaceBoundingRect: x })
                } if (k && k.service && "absolute-height" !== this.elevationContext.mode) {
                  y.center(z, t); r = "relative-to-scene" === this.elevationContext.mode ? "scene" : "ground"; C = 0; if (k.useViewElevation) C = c.unwrapOr(k.service.getElevation(t[0], t[1], r), 0); else try { const E = l.demResolutionForBoundingBox(z, k); C = c.unwrapOr(yield k.service.queryElevation(t[0], t[1], A, E, r), 0) } catch (E) { } y.offset(z, 0, 0, -this.alignedSampledElevation +
                    C)
                } return z
              }); return function (x, k, r, A, z) { return g.apply(this, arguments) }
            }(); e.addObjectState = function (g, x) { 0 === g && x.addObject(this.stageObject, this.stageObject.highlight()); 1 === g && x.addObject(this.stageObject, this.stageObject.maskOccludee()) }; e.removeObjectState = function (g) { g.removeObject(this.stageObject) }; e.resetEdgeObject = function (g) { if (!c.isNone(this._edgeState)) { var x = this._stage.renderView.ensureEdgeView(); this._visible ? this.addOrUpdateEdgeObject(x, g) : x.removeObject(this.stageObject) } }; e.addOrUpdateEdgeObject =
              function (g, x) { const k = this._edgeState; if (!c.isNone(k)) { var r = h(k.baseMaterial); for (const A of k.edgeMaterials) A.objectTransparency = r; g.addOrUpdateObject3D(this.stageObject, k.edgeMaterials, k.properties, !x).then(() => { var A; return null == (A = this._stageLayer) ? void 0 : A.sync() }) } }; w._createClass(m, [{ key: "isElevationSource", get: function () { return !(!this.stageObject.metadata || !this.stageObject.metadata.isElevationSource) } }, { key: "visible", get: function () { return this._visible } }]); return m
          }(); const d = [0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], f = u.create(), t = u.create(), v = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]]; a.Graphics3DObject3DGraphicLayer = b; a.default = b; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ./elevationAlignmentUtils ./ElevationContext ./featureExpressionInfoUtils ./graphicUtils ./Loadable ./symbolComplexity".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          function v(k, r) { k = null != k ? r.attributes[k] : 0; return null != k && isFinite(k) ? k : 0 } const m = u.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayer"); q = function (k) {
            function r(z, B, C, D) {
              var E = k.call(this, C.schedule) || this; E._context = C; E._elevationInfoOverride = null; E.complexity = null; E.logger = m; E._elevationOptions = { supportsOffsetAdjustment: !1, supportsOnTheGround: !0 }; E.symbol = z; E.symbolLayer = B; E._renderPriority = D.renderPriority; E._renderPriorityStep = D.renderPriorityStep;
              E._elevationContext = new h.ElevationContext; E.complexity = E.computeComplexity(); E._updateDrivenProperties(D.ignoreDrivers); E._updateElevationContext(); return E
            } w._inheritsLoose(r, k); var A = r.prototype; A.getCachedSize = function () { return null }; A._logGeometryCreationWarnings = function (z, B, C, D) {
              const E = "polygons" in z ? z.polygons : null; D = `${D} geometry failed to be created`; let H = null; z.projectionSuccess ? !B.length || 1 === B.length && !B[0].length ? H = `${D} (no ${C} were defined)` : Array.isArray(B) && Array.isArray(B[0]) ?
                E && 0 === E.length && "rings" === C && 0 < B.length && 2 < B[0].length && (H = `${D} (filled rings should use clockwise winding - try reversing the order of vertices)`) : H = `${D} (${C} should be defined as a 2D array)` : H = `${D} (failed to project geometry to view spatial reference)`; H && m.warnOncePerTick(H)
            }; A._validateGeometry = function (z, B = null, C = null) {
              return y.isSome(B) && !B.includes(z.type) ? (this.logger.warn("unsupported geometry type for " + C + ` symbol: ${z.type}`), !1) : "point" !== z.type || isFinite(z.x) && isFinite(z.y) ? !0 :
                (m.warn("point coordinate is not a valid number, graphic skipped"), !1)
            }; A._defaultElevationInfoNoZ = function () { return e }; A._defaultElevationInfoZ = function () { return g }; A._updateElevationContext = function () {
              y.isSome(this._elevationInfoOverride) ? (this._elevationContext.setFromElevationInfo(this._elevationInfoOverride), this._elevationContext.updateFeatureExpressionInfoContext(null)) : this._context.layer.elevationInfo ? (this._elevationContext.setFromElevationInfo(this._context.layer.elevationInfo), this._elevationContext.updateFeatureExpressionInfoContext(this._context.featureExpressionInfoContext)) :
                this._elevationContext.reset()
            }; A.getDefaultElevationInfo = function (z) { return z.hasZ ? this._defaultElevationInfoZ() : this._defaultElevationInfoNoZ() }; A.getGeometryElevationMode = function (z, B = this.getDefaultElevationInfo(z)) { return this._elevationContext.mode || B.mode }; A.setElevationInfoOverride = function (z) { this._elevationInfoOverride = z; this._updateElevationContext() }; A.setGraphicElevationContext = function (z, B) {
              var C = y.unwrap(z.geometry); const D = this.getDefaultElevationInfo(C); B.unit = null != this._elevationContext.unit ?
                this._elevationContext.unit : D.unit; B.mode = this.getGeometryElevationMode(C, D); B.offsetMeters = y.unwrapOr(this._elevationContext.meterUnitOffset, y.unwrapOr(D.offset, 0)); if (C = !this._elevationOptions.supportsOnTheGround && "on-the-ground" === B.mode) B.mode = "relative-to-ground", B.offsetMeters = 0; B.updateFeatureExpressionInfoContext(C ? b.zeroContext : this._elevationContext.featureExpressionInfoContext, z, this._context.layer); return B
            }; A.prepareSymbolLayerPatch = function (z) { }; A.updateGeometry = function (z, B) { return !1 };
            A.onRemoveGraphic = function (z) { }; A._updateDrivenProperties = function (z) {
              const B = { color: !1, opacity: !1, opacityAlwaysOpaque: !0, size: !1 }; z || (z = this._context.renderer) && "visualVariables" in z && z.visualVariables && z.visualVariables.forEach(C => { switch (C.type) { case "color": B.color = !0; if (C.stops) for (let D = 0; D < C.stops.length; D++) { const E = C.stops[D].color; E && (B.opacity = !0, 1 > E.a && (B.opacityAlwaysOpaque = !1)) } break; case "opacity": B.opacity = !0; B.opacityAlwaysOpaque = !1; break; case "size": B.size = !0 } }); this._drivenProperties =
                B
            }; A._getLayerOpacity = function () { if (this._context.layerView && "fullOpacity" in this._context.layerView) return this._context.layerView.fullOpacity; const z = this._context.layer.opacity; return null == z ? 1 : z }; A._getCombinedOpacity = function (z, B = x) { let C = 1; this.draped || (C *= this._getLayerOpacity()); if (this._drivenProperties.opacity) return C; y.isSome(z) ? C *= z.a : B.hasIntrinsicColor || (C = 0); return C }; A._getCombinedOpacityAndColor = function (z, B = x) {
              B = this._getCombinedOpacity(z, B); if (this._drivenProperties.color) return d.mixinColorAndOpacity(null,
                B); z = y.isSome(z) ? c.toUnitRGB(z) : n.ONES; return d.mixinColorAndOpacity(z, B)
            }; A._getVertexOpacityAndColor = function (z, B = null) { z = d.mixinColorAndOpacity(this._drivenProperties.color ? z.color : null, this._drivenProperties.opacity ? z.opacity : null); y.isSome(B) && (z[0] *= B, z[1] *= B, z[2] *= B, z[3] *= B); return z }; A.isFastUpdatesEnabled = function () { return this._fastUpdates && this._fastUpdates.enabled }; A.computeComplexity = function () { return t.defaultSymbolLayerComplexity(this.symbol, this.symbolLayer) }; A.globalPropertyChanged =
              function (z, B, C) { switch (z) { case "opacity": return this.layerOpacityChanged(B, C); case "elevationInfo": return z = this._elevationContext.mode, this._updateElevationContext(), this.layerElevationInfoChanged(B, C, z) === l.SymbolUpdateType.RECREATE ? !1 : !0; case "slicePlaneEnabled": return this.slicePlaneEnabledChanged(B, C); case "physicalBasedRenderingEnabled": return this.physicalBasedRenderingChanged(); case "pixelRatio": return this.pixelRatioChanged(); default: return !1 } }; A.updateGraphics3DGraphicElevationInfo = function (z,
                B, C) { let D = l.SymbolUpdateType.UPDATE; z.forEach(E => { const H = B(E); y.isSome(H) ? (this.setGraphicElevationContext(E.graphic, H.elevationContext), H.needsElevationUpdates = C(H.elevationContext.mode)) : D = l.SymbolUpdateType.RECREATE }); return D }; A.applyRendererDiff = function (z, B) { return 0 }; A.getFastUpdateAttrValues = function (z) {
                  if (!this._fastUpdates.enabled) return null; const B = this._fastUpdates.visualVariables, C = B.size ? v(B.size.field, z) : 0, D = B.color ? v(B.color.field, z) : 0; z = B.opacity ? v(B.opacity.field, z) : 0; return p.fromValues(C,
                    D, z, 0)
                }; A.ensureDrapedStatus = function (z) { if (null == this._draped) return this._draped = z, !0; z !== this.draped && m.warnOnce("A symbol can only produce either draped or non-draped visualizations. Use two separate symbol instances for draped and non-draped graphics if necessary."); return !1 }; w._createClass(r, [{ key: "extentPadding", get: function () { return 0 } }, { key: "needsDrivenTransparentPass", get: function () { return this._drivenProperties.opacity && !this._drivenProperties.opacityAlwaysOpaque } }, { key: "draped", get: function () { return this._draped } }]);
            return r
          }(f.Loadable); const e = { mode: "on-the-ground", offset: 0, unit: "meters" }, g = { mode: "absolute-height", offset: 0, unit: "meters" }, x = { hasIntrinsicColor: !1 }; a.Graphics3DSymbolLayer = q; a.default = q; a.getAttributeValue = v; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Loadable": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "../../../../core/promiseUtils"], function (a, w, c, q) {
        let u = function () {
          function y(p) {
          this.schedule =
            p; this._loadStatus = 0; this.logger = null
          } var n = y.prototype; n.destroy = function () { this.abortLoad() }; n.load = function (p, l) {
            if (1 === this._loadStatus) return p && p(), c.unwrap(this._loader); if (2 === this._loadStatus) return l && l(this._loadError), c.unwrap(this._loader); c.isNone(this._loader) && (this._abortController = new AbortController, this._loader = this.doLoad(this._abortController.signal).then(() => { this._abortController = null; this._loadStatus = 1 }, h => {
            this._loadError = h; this._abortController = null; this._loadStatus = 2; !q.isAbortError(h) &&
              this.logger && h.message && this.logger.warn(h.message); throw h;
            })); this._loader.then(p, l).catch(() => { }); return this._loader
          }; n.abortLoad = function () { c.isSome(this._abortController) ? this._abortController = c.abortMaybe(this._abortController) : 0 === this._loadStatus && (this._loadStatus = 2); this._loader = null }; w._createClass(y, [{ key: "loadStatus", get: function () { return this._loadStatus } }]); return y
        }(); a.Loadable = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/symbolComplexity": function () {
      define("exports ../../../../core/compilerUtils ../../../../core/maybe ../../../../symbols/support/ObjectSymbol3DLayerResource ./primitiveObjectSymbolUtils ../support/edgeUtils ../../webgl-engine/lib/lodRendering/LodResources".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(v) {
            let m = 0, e = 0, g = 0, x = !1, k = 0; const r = { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } }; for (const A of v) c.isNone(A) || (m += A.primitivesPerFeature, e += A.primitivesPerCoordinate, g += A.drawCallsPerFeature, r.bytesPerFeature += A.memory.bytesPerFeature, r.bytesPerFeatureLabel += A.memory.bytesPerFeatureLabel, r.bytesPerCoordinate += A.memory.bytesPerCoordinate, r.draped.bytesPerFeature += A.memory.bytesPerFeature,
              r.draped.bytesPerFeatureLabel += A.memory.bytesPerFeatureLabel, r.draped.bytesPerCoordinate += A.memory.bytesPerCoordinate, x = x || A.estimated, ++k); return { primitivesPerFeature: m, primitivesPerCoordinate: e, drawCallsPerFeature: g, estimated: x, memory: r, numComplexities: k }
          } function l(v, m) {
            const e = h(v, m); var g = y.hasEdges(m) ? 2 : 0; switch (m.type) {
              case "extrude": return { primitivesPerFeature: -4, primitivesPerCoordinate: 4, drawCallsPerFeature: g, estimated: !1, memory: e }; case "fill": return "mesh-3d" === v.type ? {
                primitivesPerFeature: 0,
                primitivesPerCoordinate: 0, drawCallsPerFeature: g, estimated: !1, memory: e
              } : c.isSome(m.outline) && 0 < m.outline.size ? { primitivesPerFeature: -4, primitivesPerCoordinate: 3, drawCallsPerFeature: 0, estimated: !1, memory: e } : { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: !1, memory: e }; case "water": return { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: !1, memory: e }; case "line": return {
                primitivesPerFeature: -2, primitivesPerCoordinate: 2, drawCallsPerFeature: 0,
                estimated: !1, memory: e
              }; case "object": return m.resource && m.resource.href ? { primitivesPerFeature: 16, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: !0, memory: e } : { ...b(m.resource && m.resource.primitive || q.defaultPrimitive), memory: e }; case "path": {
                var x = v = 0; switch (m.profile) { case "circle": v = 10; break; case "quad": v = 4; break; default: w.neverReached(m.profile); return }switch (m.join) { case "round": x = 3; break; case "miter": case "bevel": x = 1; break; default: w.neverReached(m.join); return }g = 2 * v; x = v * x * 2; let k = -2 *
                  x - g; switch (m.cap) { case "none": break; case "butt": case "square": k += 2 * (v - 1); break; case "round": k += 2 * (4 * v + v); break; default: return }return { primitivesPerFeature: k, primitivesPerCoordinate: x + g, drawCallsPerFeature: 0, estimated: !1, memory: e }
              } case "text": case "icon": return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: !1, memory: e }
            }
          } function h(v, m) {
            v = "point-3d" === v.type; switch (m.type) {
              case "extrude": return m.edges && 0 < m.edges.size ? t.EXTRUDE_EDGES : t.EXTRUDE; case "fill": return c.isSome(m.outline) &&
                0 < m.outline.size ? t.FILL_OUTLINE : t.FILL; case "water": return t.FILL; case "line": return "round" === m.join ? t.LINE_ROUND : t.LINE_MITER; case "path": switch (m.join) { case "round": switch (m.profile) { case "circle": return t.PATH_ROUND_CIRCLE; case "quad": return t.PATH_ROUND_QUAD; default: w.neverReached(m.profile); return }case "miter": case "bevel": switch (m.profile) { case "circle": return t.PATH_MITER_CIRCLE; case "quad": return t.PATH_MITER_QUAD; default: w.neverReached(m.profile); return }default: w.neverReached(m.join); return }case "object": return v ?
                  t.OBJECT_POINT : t.OBJECT_POLYGON; case "icon": case "text": return v ? t.ICON_POINT : t.ICON_POLYGON
            }
          } function b(v) { var m = f[v]; if (m) return m; m = u.primitiveLodResources(v, null); m = { primitivesPerFeature: n.geometriesFromLodLevelResources(m.levels[0]).reduce((e, g) => e + g.indices.get("position").length / 3, 0), primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: !1 }; return f[v] = m } const d = {
            primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: !0, memory: {
              bytesPerFeature: 0, bytesPerCoordinate: 0,
              bytesPerFeatureLabel: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 }
            }
          }, f = {}, t = {
            ICON_POINT: { bytesPerFeature: 7127.413186968842, bytesPerFeatureLabel: 4826.302896296296, bytesPerCoordinate: 0, draped: { bytesPerFeature: 3929.4396628895197, bytesPerFeatureLabel: 3550.1332222222227, bytesPerCoordinate: 0 } }, ICON_POLYGON: {
              bytesPerFeature: 9329.452613976147, bytesPerFeatureLabel: 3675.3372604938268, bytesPerCoordinate: 60.177252982212096, draped: {
                bytesPerFeature: 6190.247450139383, bytesPerFeatureLabel: 3744.074358024691,
                bytesPerCoordinate: 59.488211068026104
              }
            }, OBJECT_POINT: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0, draped: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0 } }, OBJECT_POLYGON: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506, draped: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506 } }, LINE_MITER: {
              bytesPerFeature: 7321.028181375921,
              bytesPerFeatureLabel: 4048.0226716049388, bytesPerCoordinate: 186.55621386363578, draped: { bytesPerFeature: 4246.856619435009, bytesPerFeatureLabel: 3852.3737679012347, bytesPerCoordinate: 163.47884002621583 }
            }, LINE_ROUND: { bytesPerFeature: 7482.205842738954, bytesPerFeatureLabel: 4045.886987654321, bytesPerCoordinate: 191.5452524171851, draped: { bytesPerFeature: 4473.481387957992, bytesPerFeatureLabel: 3842.1112395061728, bytesPerCoordinate: 167.27703460226945 } }, PATH_MITER_CIRCLE: {
              bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109,
              bytesPerCoordinate: 4618.2594178027275, draped: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275 }
            }, PATH_ROUND_CIRCLE: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957, draped: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957 } }, PATH_MITER_QUAD: {
              bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203,
              draped: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203 }
            }, PATH_ROUND_QUAD: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826, draped: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826 } }, FILL: {
              bytesPerFeature: 9478.244183633637, bytesPerFeatureLabel: 3713.816824691358, bytesPerCoordinate: 95.9343604185578, draped: {
                bytesPerFeature: 6287.911108168086,
                bytesPerFeatureLabel: 3790.785032098766, bytesPerCoordinate: 83.08783220478168
              }
            }, FILL_OUTLINE: { bytesPerFeature: 13085.871870349445, bytesPerFeatureLabel: 3392.613241975309, bytesPerCoordinate: 118.63968023169875, draped: { bytesPerFeature: 8437.199992480122, bytesPerFeatureLabel: 3973.5431172839503, bytesPerCoordinate: 106.33556817014312 } }, EXTRUDE: {
              bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477, draped: {
                bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546,
                bytesPerCoordinate: 372.6819978900477
              }
            }, EXTRUDE_EDGES: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312, draped: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312 } }
          }; a.averageSymbolComplexities = function (v) {
            v = p(v); 0 < v.numComplexities && (v.primitivesPerFeature /= v.numComplexities, v.primitivesPerCoordinate /= v.numComplexities, v.drawCallsPerFeature /= v.numComplexities, v.memory.bytesPerFeature /=
              v.numComplexities, v.memory.bytesPerFeatureLabel /= v.numComplexities, v.memory.bytesPerCoordinate /= v.numComplexities, v.memory.draped.bytesPerFeature /= v.numComplexities, v.memory.draped.bytesPerFeatureLabel /= v.numComplexities, v.memory.draped.bytesPerCoordinate /= v.numComplexities); return v
          }; a.defaultSymbolComplexity = function (v) { if ("web-style" === v.type) return d; const m = v.symbolLayers.toArray().map(e => l(v, e)); return p(m) }; a.defaultSymbolLayerComplexity = l; a.defaultSymbolLayerMemoryComplexity = h; a.emptySymbolComplexity =
            d; a.memoryEstimators = t; a.totalSymbolComplexities = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/primitiveObjectSymbolUtils": function () {
      define(["exports", "../../../../core/has", "../../webgl-engine/lib/GeometryUtil"], function (a, w, c) {
        const q = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }]; a.isValidPrimitive = function (u) { switch (u) { case "sphere": case "cube": case "diamond": case "cylinder": case "cone": case "inverted-cone": case "tetrahedron": return !0 }return !1 };
        a.primitiveLodResources = function (u, y) {
          const n = (p, l, h = !1) => ({ levels: p.map(b => { const d = l(b.tesselation); h && c.cgToGIS(d); return { components: [{ geometry: d, material: y }], faceCount: d.indexCount / 3, minScreenSpaceRadius: b.minScreenSpaceRadius } }) }); switch (u) {
            case "sphere": return n([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], p => c.createPolySphereGeometry(.5,
              p, !0)); case "cube": return n([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => c.createBoxGeometry(1)); case "cone": return n(q, p => c.createConeGeometry(1, .5, p, !1), !0); case "inverted-cone": return n(q, p => c.createConeGeometry(1, .5, p, !0), !0); case "cylinder": return n(q, p => c.createCylinderGeometry(1, .5, p, [0, 0, 1], [0, 0, .5])); case "tetrahedron": return n([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => c.createTetrahedronGeometry(1), !0); case "diamond": return n([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => c.createDiamondGeometry(1),
                !0)
          }
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/edgeUtils": function () {
      define("exports ../../../../Color ../../../../core/has ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/vec4f64 ./layerUtils".split(" "), function (a, w, c, q, u, y, n) {
        function p(d, f) {
          if (q.isNone(d)) return null; const t = q.isSome(d.color) ? y.fromArray(w.toUnitRGBA(d.color)) : y.fromValues(0, 0, 0, 0), v = u.pt2px(d.size), m = u.pt2px(d.extensionLength); switch (d.type) {
            case "solid": return l({
              color: t,
              size: v, extensionLength: m, ...f
            }); case "sketch": return { ...b, color: t, size: v, extensionLength: m, ...f, type: "sketch" }
          }
        } function l(d) { return { ...h, ...d, type: "solid" } } const h = { color: y.fromValues(0, 0, 0, .2), size: 1, extensionLength: 0, opacity: 1, objectTransparency: 2 }, b = { color: y.fromValues(0, 0, 0, .2), size: 1, extensionLength: 0, opacity: 1, objectTransparency: 2 }; a.createMaterial = function (d, f) { return p(d && d.enabled && d.edges || null, f) }; a.createMaterialFromEdges = p; a.createSolidEdgeMaterial = l; a.hasEdges = function (d) {
          return d &&
            d.enabled && (n.isExtrudeSymbol3DLayer(d) || n.isFillSymbol3DLayer(d)) && q.isSome(d.edges)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/layerUtils": function () { define(["exports"], function (a) { a.isExtrudeSymbol3DLayer = function (w) { return "extrude" === w.type }; a.isFillSymbol3DLayer = function (w) { return "fill" === w.type }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/webgl-engine/lib/lodRendering/LodResources": function () {
      define(["exports", "../../../../../core/arrayUtils"],
        function (a, w) {
          function c(q) { const u = []; q.components.forEach(y => { u.push(y.geometry) }); return w.unique(u) } a.computeFaceCount = function (q) { return c(q).reduce((u, y) => u + y.indexCount / 3, 0) }; a.geometriesFromLodLevelResources = c; a.geometriesFromLodResources = function (q) { const u = []; q.levels.forEach(y => { y.components.forEach(n => { u.push(n.geometry) }) }); return w.unique(u) }; a.materialsFromLodResources = function (q) { const u = []; q.levels.forEach(y => { y.components.forEach(n => { u.push(n.material) }) }); return w.unique(u) }; a.texturesFromLodResources =
            function (q) { const u = []; q.levels.forEach(y => { y.components.forEach(n => { n.textures && u.push(...n.textures) }) }); return w.unique(u) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/pointUtils": function () {
      define("exports ../../../../core/maybe ../../../../chunks/mat4f64 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/coordsUtils ../../../../layers/graphics/dehydratedFeatures ./elevationAlignmentUtils ./graphicUtils ../../webgl-engine/lib/Object3D".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          const d = q.create(); a.createStageObjectForHUD = function (f, t, v, m, e, g, x, k) {
            const r = v ? v.length : 0; var A = f.clippingExtent; u.projectPointToVector(t, d, f.elevationProvider.spatialReference); if (w.isSome(A) && !y.containsPoint(A, d)) return null; u.projectPointToVector(t, d, f.renderCoordsHelper.spatialReference); A = f.localOriginFactory.getOrigin(d); g = new b.Object3D({ castShadow: !1, metadata: { layerUid: g, graphicUid: x, usesVerticalDistanceToGround: !0 } }); for (x = 0; x < r; x++)g.addGeometry(v[x], m[x],
              c.IDENTITY, A, k); f = l.applyElevationAlignmentForHUD(g, t, f.elevationProvider, f.renderCoordsHelper, e); return { object: g, sampledElevation: f }
          }; a.extendPointGraphicElevationContext = function (f, t, v) { f = f.elevationContext; v = v.spatialReference; u.projectPointToVector(t, d, v); f.centerPointInElevationSR = p.makeDehydratedPoint(d[0], d[1], t.hasZ ? d[2] : 0, v) }; a.geometryToRenderInfo = function (f, t, v, m, e) {
            const g = new Float64Array(3 * f.length), x = new Float64Array(g.length); f.forEach((k, r) => {
            g[3 * r] = k[0]; g[3 * r + 1] = k[1]; g[3 * r + 2] = 2 <
              k.length ? k[2] : 0
            }); t = l.applyPerVertexElevationAlignment(g, t, 0, x, 0, g, 0, g.length / 3, v, m, e); return { numVertices: f.length, position: g, mapPosition: x, projectionSuccess: null != t, sampledElevation: t }
          }; a.placePointOnGeometry = function (f) { switch (f.type) { case "point": return f; case "polygon": case "extent": return h.computeCentroid(f); case "polyline": var t = f.paths[0]; if (!t || 0 === t.length) break; t = n.getPointOnPath(t, n.getPathLength(t) / 2); return p.makeDehydratedPoint(t[0], t[1], t[2], f.spatialReference); case "mesh": return f.origin }return null };
          Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/Object3D": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/sphere ../../support/mathUtils ./ContentObject ./GeometryRecord ./Object3DStateID ./Util ../materials/renderers/utils".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        h = function (e) {
          function g(k =
            {}) {
              var r = e.call(this) || this; r.type = 1; r._geometryRecords = []; r._geometries = []; r._objectTransformation = u.create(); r._bvObjectSpace = new m; r._bvWorldSpace = new m; r._bvDirty = !0; r._hasVolatileTransformation = !1; r._visible = !0; r.castShadow = null != k.castShadow ? k.castShadow : !0; r.metadata = k.metadata; r.metadata && r.metadata.isElevationSource && (r.metadata.lastValidElevationBB = new v); r.transformation = u.create(); const { geometries: A, materials: z, transformations: B, origins: C } = k; if (!Array.isArray(A)) return w._assertThisInitialized(r);
            f.assert(z.length === A.length, "Object3D: materials don't match geometries"); f.assert(B.length === A.length, "Object3D: transformations don't match geometries"); r._geometryRecords.length = A.length; r._geometries.length = A.length; for (k = 0; k < A.length; k++)r._geometries[k] = A[k], r._geometryRecords[k] = b.GeometryRecord.pool.acquire(A[k], z[k], u.clone(B[k]), { highlights: null, occludees: null, visible: r._visible }, C && C[k]); return r
          } w._inheritsLoose(g, e); var x = g.prototype; x.dispose = function () {
            this._geometryRecords.length =
            0; this._geometries.length = 0
          }; x.addGeometry = function (k, r, A, z, B) { A = A ? A : u.IDENTITY; this._geometries.push(k); k = b.GeometryRecord.pool.acquire(k, r, A, { highlights: null, occludees: null, visible: this._visible }, z, B); this._geometryRecords.push(k); this._hasVolatileTransformation = this._hasVolatileTransformation || c.isSome(k.shaderTransformation); this._emit("objectGeometryAdded", { object: this, record: k }); this._invalidateBoundingVolume(); return k }; x.removeGeometry = function (k) {
            const r = this._geometryRecords.splice(k, 1)[0];
            this._hasVolatileTransformation = c.isSome(r.shaderTransformation) ? this._geometryRecords.some(A => c.isSome(A.shaderTransformation)) : this._hasVolatileTransformation; r.dispose(); this._geometries.splice(k, 1); this._emit("objectGeometryRemoved", { object: this, record: r }); this._invalidateBoundingVolume(); return r
          }; x.removeAllGeometries = function () { for (; 0 < this.geometryRecords.length;)this.removeGeometry(0) }; x.geometryVertexAttrsUpdated = function (k) { this._emit("vertexAttrsUpdated", { object: this, record: k }); this._invalidateBoundingVolume() };
          x.setVisible = function (k) { if (this._visible !== k) { this._visible = k; for (const r of this._geometryRecords) r.instanceParameters.visible = this._visible; this._emit("visibilityChanged", this) } }; x.maskOccludee = function () { const k = new d.Object3DStateID(1); for (const r of this._geometryRecords) r.instanceParameters.occludees = t.addObject3DStateID(r.instanceParameters.occludees, k); this._emit("occlusionChanged", this); return k }; x.removeOcclude = function (k) {
            for (const r of this._geometryRecords) r.instanceParameters.occludees =
              t.removeObject3DStateID(r.instanceParameters.occludees, k); this._emit("occlusionChanged", this)
          }; x.highlight = function () { const k = new d.Object3DStateID(0); for (const r of this._geometryRecords) r.instanceParameters.highlights = t.addObject3DStateID(r.instanceParameters.highlights, k); this._emit("highlightChanged", this); return k }; x.removeHighlight = function (k) {
            for (const r of this._geometryRecords) r.instanceParameters.highlights = t.removeObject3DStateID(r.instanceParameters.highlights, k); this._emit("highlightChanged",
              this)
          }; x.getCombinedStaticTransformation = function (k, r) { return q.multiply(c.unwrapOr(r, u.create()), this.transformation, k.getStaticTransformation()) }; x.getCombinedShaderTransformation = function (k, r) { r = r || u.create(); q.multiply(r, this.transformation, k.getShaderTransformation()); return r }; x.hasVolativeTransformation = function () { return this._hasVolatileTransformation }; x._validateBoundingVolume = function () {
            if (this._bvDirty || this._hasVolatileTransformation) {
              this._bvObjectSpace.init(); this._bvWorldSpace.init();
              for (var k = 0; k < this._geometryRecords.length; ++k) { var r = this._geometryRecords[k], A = this._geometries[k].boundingInfo; c.isSome(A) && (this._calculateTransformedBoundingVolume(A, this._bvObjectSpace, r.getShaderTransformation()), this._calculateTransformedBoundingVolume(A, this._bvWorldSpace, this.getCombinedShaderTransformation(r))) } y.lerp(this._bvObjectSpace.bounds, this._bvObjectSpace.min, this._bvObjectSpace.max, .5); y.lerp(this._bvWorldSpace.bounds, this._bvWorldSpace.min, this._bvWorldSpace.max, .5); k = n.create();
              r = n.create(); A = l.maxScale(this.transformation); for (let D = 0; D < this._geometryRecords.length; ++D) {
                var z = this._geometries[D].boundingInfo; if (!c.isNone(z)) {
                  var B = this._geometryRecords[D].getShaderTransformation(), C = l.maxScale(B); y.transformMat4(k, z.getCenter(), B); B = y.distance(k, this._bvObjectSpace.bounds); z = z.getBSRadius() * C; this._bvObjectSpace.bounds[3] = Math.max(this._bvObjectSpace.bounds[3], B + z); y.transformMat4(r, k, this.transformation); C = y.distance(r, this._bvWorldSpace.bounds); this._bvWorldSpace.bounds[3] =
                    Math.max(this._bvWorldSpace.bounds[3], C + z * A)
                }
              } this._bvDirty = !1
            }
          }; x._calculateTransformedBoundingVolume = function (k, r, A) {
            const z = k.getBBMin(); k = k.getBBMax(); const B = n.clone(z), C = n.clone(k); y.transformMat4(B, B, A); y.transformMat4(C, C, A); for (var D = 0; 3 > D; ++D)r.min[D] = Math.min(r.min[D], B[D], C[D]), r.max[D] = Math.max(r.max[D], B[D], C[D]); for (D = 0; 3 > D; ++D) {
              y.copy(B, z); y.copy(C, k); B[D] = k[D]; C[D] = z[D]; y.transformMat4(B, B, A); y.transformMat4(C, C, A); for (let E = 0; 3 > E; ++E)r.min[E] = Math.min(r.min[E], B[E], C[E]), r.max[E] =
                Math.max(r.max[E], B[E], C[E])
            }
          }; x._invalidateBoundingVolume = function () { this._bvDirty = !0; c.isSome(this._parentLayer) && this._parentLayer.notifyObjectBBChanged(this, this._bvWorldSpace.bounds) }; x._emit = function (k, r) { c.isSome(this._parentLayer) && this._parentLayer.events.emit(k, r) }; w._createClass(g, [{ key: "geometryRecords", get: function () { return this._geometryRecords } }, { key: "geometries", get: function () { return this._geometries } }, {
            key: "transformation", get: function () { return this._objectTransformation }, set: function (k) {
              q.copy(this._objectTransformation,
                k); this._invalidateBoundingVolume(); this._emit("objectTransformation", this)
            }
          }, { key: "parentLayer", get: function () { return this._parentLayer }, set: function (k) { f.assert(null == this._parentLayer || null == k, "Object3D can only be added to a single Layer"); this._parentLayer = k } }, { key: "isVisible", get: function () { return this._visible } }, { key: "boundingVolumeWorldSpace", get: function () { this._validateBoundingVolume(); return this._bvWorldSpace } }, {
            key: "boundingVolumeObjectSpace", get: function () {
              this._validateBoundingVolume();
              return this._bvObjectSpace
            }
          }, { key: "test", get: function () { const k = this; return { hasGeometry: r => -1 < k._geometries.indexOf(r), getGeometryIndex: r => k._geometries.indexOf(r) } } }]); return g
        }(h.ContentObject); let v = function () { function e() { this.min = n.fromValues(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); this.max = n.fromValues(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE) } e.prototype.isEmpty = function () { return this.max[0] < this.min[0] && this.max[1] < this.min[1] && this.max[2] < this.min[2] }; return e }(),
          m = function (e) { function g() { var x = e.apply(this, arguments) || this; x.bounds = p.create(); return x } w._inheritsLoose(g, e); g.prototype.init = function () { y.set(this.min, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); y.set(this.max, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); p.clear(this.bounds) }; return g }(v); a.Object3D = h; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/GeometryRecord": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/ObjectPool ../../../../core/uid ../../../../chunks/vec3".split(" "),
        function (a, w, c, q, u, y) {
          let n = function () {
            function p() { this._disposed = !1 } var l = p.prototype; l.acquire = function (h, b, d, f, t, v) { this.id = u.generateUID(); this.geometry = h; this.material = b; this.transformation = d; this.instanceParameters = f; this.origin = t; this._shaderTransformation = v; this._disposed = !1 }; l.release = function () { this._disposed = !1 }; l.dispose = function () { this._disposed = !0 }; l.getStaticTransformation = function () { return this.transformation }; l.getShaderTransformation = function () {
              return c.isSome(this._shaderTransformation) ?
                this._shaderTransformation(this.transformation) : this.transformation
            }; l.computeAttachmentOrigin = function (h) { return (this.material.computeAttachmentOrigin ? this.material.computeAttachmentOrigin(this.geometry, h) : this.geometry.computeAttachmentOrigin(h)) ? (y.transformMat4(h, h, this.getStaticTransformation()), !0) : !1 }; w._createClass(p, [{ key: "disposed", get: function () { return this._disposed } }, { key: "shaderTransformation", get: function () { return this._shaderTransformation } }]); return p
          }(); n.pool = new q(n); a.GeometryRecord =
            n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/Object3DStateID": function () { define(["exports", "../../../../core/uid"], function (a, w) { a.Object3DStateID = function (c) { this.channel = c; this.id = w.generateUID() }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/webgl-engine/materials/LineCalloutMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/vec2f32 ../../support/buffer/InterleavedLayout ../lib/GLMaterial ../lib/Material ./internal/bufferWriterUtils ../shaders/LineCalloutTechnique".split(" "),
        function (a, w, c, q, u, y, n, p) {
          let l = function (v) {
            function m(g) { g = v.call(this, g, b) || this; g.techniqueConfig = new p.LineCalloutTechniqueConfiguration; g._uniqueMaterialIdentifier = m.uniqueMaterialIdentifier(g.parameters); return g } w._inheritsLoose(m, v); var e = m.prototype; e.getPassParameters = function () { return this.parameters }; e.getTechniqueConfig = function (g, x) {
              g = 18 !== (null == x ? void 0 : x.slot); this.techniqueConfig.occlusionTestEnabled = this.parameters.occlusionTest; this.techniqueConfig.verticalOffset = !!this.parameters.verticalOffset;
              this.techniqueConfig.screenSizePerspective = !!this.parameters.screenSizePerspective; this.techniqueConfig.depthHudEnabled = g; this.techniqueConfig.depthHudAlignStartEnabled = !!this.parameters.depthHUDAlignStart; this.techniqueConfig.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits ? 1 : 0; this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this.techniqueConfig.multipassGeometryEnabled = x ? x.multipassGeometryEnabled : !1; return this.techniqueConfig
            }; e.intersect = function () { };
            e.requiresSlot = function (g) { switch (g) { case 18: case 19: return !0 }return !1 }; e.createGLMaterial = function (g) { return 0 === g.output ? new h(g) : null }; e.createBufferWriter = function () { return new t }; e.validateParameters = function (g) { g = m.uniqueMaterialIdentifier(g); g !== this._uniqueMaterialIdentifier && (this._uniqueMaterialIdentifier = g) }; m.uniqueMaterialIdentifier = function (g) { return JSON.stringify({ screenOffset: g.screenOffset || [0, 0], centerOffsetUnits: g.centerOffsetUnits || "world" }) }; w._createClass(m, [{
              key: "uniqueMaterialIdentifier",
              get: function () { return this._uniqueMaterialIdentifier }
            }]); return m
          }(y.Material), h = function (v) { function m() { return v.apply(this, arguments) || this } w._inheritsLoose(m, v); var e = m.prototype; e.updateParameters = function (g) { return this.ensureTechnique(p.LineCalloutTechnique, g) }; e.beginSlot = function (g) { return this.updateParameters(g) }; e.bind = function (g, x) { x.bindPass(this._material.getPassParameters(), g) }; return m }(u); const b = {
            verticalOffset: null, screenSizePerspective: null, screenOffset: [0, 0], color: [0, 0, 0, 1],
            size: 1, borderColor: null, occlusionTest: !1, shaderPolygonOffset: 1E-5, depthHUDAlignStart: !1, centerOffsetUnits: "world", slicePlaneEnabled: !1, ...y.materialParametersDefaults
          }, d = q.newLayout().vec3f("position").vec3f("normal").vec2f("uv0").vec4f("auxpos1"), f = [c.fromValues(0, 0), c.fromValues(1, 0), c.fromValues(0, 1), c.fromValues(1, 0), c.fromValues(1, 1), c.fromValues(0, 1)]; let t = function () {
            function v() { this.vertexBufferLayout = d } var m = v.prototype; m.allocate = function (e) { return this.vertexBufferLayout.createBuffer(e) };
            m.elementCount = function (e) { return 6 * e.indices.get("position").length }; m.write = function (e, g, x, k) { n.writePosition(g.indices.get("position"), g.vertexAttributes.get("position").data, e.transformation, x.position, k, 6); n.writeNormal(g.indices.get("normal"), g.vertexAttributes.get("normal").data, e.invTranspTransformation, x.normal, k, 6); n.writeBufferVec4(g.indices.get("auxpos1"), g.vertexAttributes.get("auxpos1").data, x.auxpos1, k, 6); for (e = 0; e < f.length; ++e)x.uv0.setVec(k + e, f[e]) }; return v
          }(); a.LineCalloutMaterial =
            l; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/vec2f32": function () {
      define(["exports"], function (a) {
        function w() { return new Float32Array(2) } function c(v) { const m = new Float32Array(2); m[0] = v[0]; m[1] = v[1]; return m } function q(v, m) { const e = new Float32Array(2); e[0] = v; e[1] = m; return e } function u(v, m) { return new Float32Array(v, m, 2) } function y() { return w() } function n() { return q(1, 1) } function p() { return q(1, 0) } function l() { return q(0, 1) } const h = w(), b = n(), d = p(), f = l(), t = Object.freeze({
          __proto__: null,
          create: w, clone: c, fromValues: q, createView: u, zeros: y, ones: n, unitX: p, unitY: l, ZEROS: h, ONES: b, UNIT_X: d, UNIT_Y: f
        }); a.ONES = b; a.UNIT_X = d; a.UNIT_Y = f; a.ZEROS = h; a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.ones = n; a.unitX = p; a.unitY = l; a.vec2f32 = t; a.zeros = y
      })
    }, "esri/views/3d/webgl-engine/shaders/LineCalloutTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/attributes/VerticalOffset.glsl ../core/shaderLibrary/hud/HUD.glsl ../core/shaderLibrary/shading/MultipassGeometryTest.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/Program ../materials/internal/MaterialUtil ../../../../chunks/LineCallout.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          b = function (g) {
            function x() { return g.apply(this, arguments) || this } c._inheritsLoose(x, g); var k = x.prototype; k.initializeProgram = function (r) {
              var A = x.shader.get(); const z = this.configuration; A = A.build({
                occlusionTestEnabled: z.occlusionTestEnabled, verticalOffsetEnabled: z.verticalOffset, screenSizePerspectiveEnabled: z.screenSizePerspective, depthHudEnabled: z.depthHudEnabled, depthHudAlignStartEnabled: z.depthHudAlignStartEnabled, screenCenterOffsetUnitsEnabled: z.screenCenterOffsetUnitsEnabled,
                slicePlaneEnabled: z.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !0, viewingMode: r.viewingMode, isDraped: !1, multipassGeometryEnabled: z.multipassGeometryEnabled
              }); return new t.Program(r.rctx, A, f.Default3D)
            }; k.bindPass = function (r, A) {
              l.bindProjectionMatrix(this.program, A.camera.projectionMatrix); m.LineCallout.bindUniforms(this.program, r, A.camera.pixelRatio || 1); y.bindVerticalOffsetUniforms(this.program, r, A); n.bindHUDUniforms(this.program, A); this.program.setUniform2fv("cameraNearFar",
                A.camera.nearFar); this.program.setUniform2fv("inverseViewport", A.inverseViewport); p.bindMultipassGeometryTexture(this.program, A); this.program.bindTexture(A.hudVisibilityTexture, "hudVisibilityTexture"); this.program.setUniform1f("cameraGroundRelative", A.camera.aboveGround ? 1 : -1); this.program.setUniform1f("polygonOffset", r.shaderPolygonOffset); l.bindViewport(this.program, A); this.program.setUniform1f("perDistancePixelRatio", Math.tan(A.camera.fovY / 2) / (A.camera.fullViewport[2] / 2)); this.program.setUniformMatrix4fv("viewNormal",
                  A.camera.viewInverseTransposeMatrix); this.program.setUniform2f("pixelToNDC", 2 / A.camera.fullViewport[2], 2 / A.camera.fullViewport[3]); this.program.setUniform1f("lineSize", Math.ceil(r.size) * (A.camera.pixelRatio || 1)); v.bindScreenSizePerspective(r.screenSizePerspective, this.program, "screenSizePerspectiveAlignment")
            }; k.bindDraw = function (r) {
              l.bindView(this.program, r); l.bindCameraPosition(this.program, r.origin, r.camera.viewInverseTransposeMatrix); u.bindSliceUniformsWithOrigin(this.program, this.configuration,
                r); this.program.rebindTextures()
            }; k.setPipelineState = function (r) { r = r ? 519 : 513; return this.configuration.depthHudEnabled ? e.makePipelineState({ depthTest: { func: r }, depthWrite: e.defaultDepthWriteParams }) : e.makePipelineState({ blending: e.separateBlendingParams(1, 770, 771, 771), depthTest: { func: r }, colorWrite: e.defaultColorWriteParams }) }; k.initializePipeline = function () { return this.setPipelineState(this.configuration.multipassGeometryEnabled) }; return x
          }(b.ShaderTechnique); b.shader = new h.ReloadableShaderModule(m.LineCalloutShader,
            () => new Promise((g, x) => a(["./LineCallout.glsl"], g, x))); h = function (g) { function x() { var k = g.apply(this, arguments) || this; k.occlusionTestEnabled = !0; k.verticalOffset = !1; k.screenSizePerspective = !1; k.depthHudEnabled = !1; k.depthHudAlignStartEnabled = !1; k.screenCenterOffsetUnitsEnabled = 0; k.slicePlaneEnabled = !1; k.multipassGeometryEnabled = !1; return k } c._inheritsLoose(x, g); return x }(d.ShaderTechniqueConfiguration); q.__decorate([d.parameter()], h.prototype, "occlusionTestEnabled", void 0); q.__decorate([d.parameter()],
              h.prototype, "verticalOffset", void 0); q.__decorate([d.parameter()], h.prototype, "screenSizePerspective", void 0); q.__decorate([d.parameter()], h.prototype, "depthHudEnabled", void 0); q.__decorate([d.parameter()], h.prototype, "depthHudAlignStartEnabled", void 0); q.__decorate([d.parameter({ count: 2 })], h.prototype, "screenCenterOffsetUnitsEnabled", void 0); q.__decorate([d.parameter()], h.prototype, "slicePlaneEnabled", void 0); q.__decorate([d.parameter()], h.prototype, "multipassGeometryEnabled", void 0); w.LineCalloutTechnique =
                b; w.LineCalloutTechniqueConfiguration = h; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/LineCallout.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl ../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(b) {
            const d = new n.ShaderBuilder; d.include(c.AlignPixel); d.include(q.HUD, b); d.include(w.Slice, b); d.attributes.add("uv0", "vec2"); d.vertex.uniforms.add("lineSize", "float").add("pixelToNDC", "vec2").add("borderSize", "float").add("screenOffset", "vec2"); d.varyings.add("coverageSampling", "vec4"); d.varyings.add("lineSizes", "vec2"); b.multipassGeometryEnabled && d.varyings.add("depth", "float"); d.vertex.code.add(y.glsl`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 endPoint = projectPositionHUD(projectAux);

      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }
    ${b.occlusionTestEnabled ? y.glsl`
      if (!testVisibilityHUD(endPoint)) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }`: ""}

    ${b.screenSizePerspectiveEnabled ? y.glsl`
      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);
        `: y.glsl`
      vec2 screenOffsetScaled = screenOffset;
        `}
      // Add view dependent polygon offset to get exact same original starting point. This is mostly
      // used to get the correct depth value
      vec3 posView = (view * vec4(position, 1.0)).xyz;
      ${b.multipassGeometryEnabled ? "depth \x3d posView.z;" : ""}

      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);
      vec4 startPoint = proj * vec4(posView, 1.0);
      // Apply screen offset to both start and end point
      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;
      startPoint.xy += screenOffsetNorm * startPoint.w;
      endPoint.xy += screenOffsetNorm * endPoint.w;
      // Align start and end to pixel origin
      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);
      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);
    ${b.depthHudEnabled ? b.depthHudAlignStartEnabled ? y.glsl`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : y.glsl`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : ""}
      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);
      // The direction of the line in screen space
      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);
      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);
    ${b.screenSizePerspectiveEnabled ? y.glsl`
      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);
      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);
        `: y.glsl`
      float lineSizeScaled = lineSize;
      float borderSizeScaled = borderSize;
        `}
      float halfPixelSize = lineSizeScaled * 0.5;
      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned
      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,
      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel
      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).
      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;
      float halfPixelSizeInt = floor(halfWholePixelSize);

      // Sub-pixel offset if we need to grow sub-pixels to the left
      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);

      // Pixel offset aligning to whole pixels and adding subpixel offset if needed
      float pixelOffset = -halfPixelSizeInt + subpixelOffset;

      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size
      float padding = 1.0 + borderSizeScaled;
      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;

      // Offset x/y from the center of the line in screen space
      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;

      // Compute a coverage varying which we can use in the fragment shader to determine
      // how much a pixel is actually covered by the line (i.e. to anti alias the line).
      // This works by computing two coordinates that can be linearly interpolated and then
      // subtracted to find out how far away from the line edge we are.
      float edgeDirection = (uv0.x * 2.0 - 1.0);

      float halfBorderSize = 0.5 * borderSizeScaled;
      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;
      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);

      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);

      coverageSampling = vec4(
        // Edge coordinate
        outerEdgeCoverageSampler,

        // Border edge coordinate
        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,

        // Line offset
        halfPixelSize - 0.5,

        // Border offset
        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)
      );

      lineSizes = vec2(lineSizeScaled, borderSizeScaled);

      gl_Position = projectedPosition;
    }
  `); d.fragment.uniforms.add("color", "vec4"); d.fragment.uniforms.add("borderColor", "vec4"); b.multipassGeometryEnabled && (d.fragment.include(u.multipassGeometryTest, b), d.fragment.uniforms.add("inverseViewport", "vec2")); d.fragment.code.add(y.glsl`
    void main() {
      ${b.multipassGeometryEnabled ? "if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }" : ""}

      // Mix between line and border coverage offsets depending on whether we need
      // a border (based on the sidedness).
      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);

      // Mix between border and line color based on the line coverage (conceptually the line
      // blends on top of the border background).
      //
      // Anti-alias by blending final result using the full (including optional border) coverage
      // and the color alpha
      float borderAlpha = color.a * borderColor.a * coverage.y;
      float colorAlpha = color.a * coverage.x;

      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);

    ${b.depthHudEnabled ? y.glsl`
      if (finalAlpha < 0.01) {
        discard;
      }
      `: y.glsl`
      // Compute the finalRgb, but keep it pre-multiplied (for unpre-multiplied you
      // need to divide by finalAlpha). We avoid the division here by setting the
      // appropriate blending function in the material.
      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);
      gl_FragColor = vec4(finalRgb, finalAlpha);
      `}
  }
  `); return d
          } function l(b, d, f) { 3 === f.length ? b.setUniform4f(d, f[0], f[1], f[2], 1) : b.setUniform4fv(d, f) } a.LineCallout = void 0; (function (b) { b.bindUniforms = function (d, f, t) { l(d, "color", f.color); d.setUniform1f("pixelRatio", t); d.setUniform2f("screenOffset", f.screenOffset[0] * t, f.screenOffset[1] * t); null !== f.borderColor ? (l(d, "borderColor", f.borderColor), d.setUniform1f("borderSize", t)) : (d.setUniform4f("borderColor", 0, 0, 0, 0), d.setUniform1f("borderSize", 0)) } })(a.LineCallout || (a.LineCallout = {})); const h = Object.freeze({
            __proto__: null,
            build: p, get LineCallout() { return a.LineCallout }
          }); a.LineCalloutShader = h; a.build = p
        })
    }, "esri/views/3d/layers/graphics/Graphics3DGraphicCreationContext": function () { define(function () { return function (a, w, c) { this.graphic = a; this.renderingInfo = w; this.layer = c } }) }, "esri/views/3d/layers/graphics/graphicSymbolUtils": function () {
      define(["exports", "./Graphics3DSymbol", "./Graphics3DWebStyleSymbol"], function (a, w, c) {
      a.getGraphics3DSymbol = function (q) { return q instanceof c ? q.graphics3DSymbol : q instanceof w ? q : null }; Object.defineProperty(a,
        "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DSymbol": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/asyncUtils ../../../../core/maybe ../../../../core/promiseUtils ./Graphics3DGraphic ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayerFactory ./Loadable ./symbolComplexity".split(" "), function (a, w, c, q, u, y, n, p, l) {
        const h = { renderPriority: 0, renderPriorityStep: 1, ignoreDrivers: !1 }; return function (b) {
          function d(t, v, m) {
            var e = b.call(this, v.schedule) ||
              this; e._symbol = t; e._context = v; e._backgroundLayers = m; e._destroyed = !1; e.symbolLayers = []; e.referenced = 0; e._extentPadding = 0; return e
          } a._inheritsLoose(d, b); var f = d.prototype; f.doLoad = function () {
            var t = a._asyncToGenerator(function* (v) {
              var m = this; let e = this._symbol.symbolLayers; this._extentPadding = 0; this._backgroundLayers && (e = this._backgroundLayers.concat(e)); const g = e.length; for (; this.symbolLayers.length < e.length;)this.symbolLayers.push(null); this.symbolLayers.length = e.length; const x = []; for (let k = 0; k < g; k++) {
                const r =
                  e.getItemAt(k); if (!1 === r.enabled) continue; h.renderPriority = 1 - (1 + k) / g; h.renderPriorityStep = 1 / g; h.ignoreDrivers = r._ignoreDrivers; const A = n.make(this.symbol, r, this._context, h); x.push(q.onAbortOrThrow(v, () => { this.symbolLayers[k] = null; A.destroy() })); this.symbolLayers[k] = A
              } yield w.forEach(this.symbolLayers, function () {
                var k = a._asyncToGenerator(function* (r, A) { if (c.isSome(r)) try { yield r.load(), m._extentPadding += Math.max(m._extentPadding, r.extentPadding) } catch{ m.symbolLayers[A] = null } }); return function (r, A) {
                  return k.apply(this,
                    arguments)
                }
              }()); for (const k of x) null == k ? void 0 : k.remove(); x.length = 0; q.throwIfAborted(v); if (this.symbolLayers.length && !this.symbolLayers.some(k => !!k)) throw Error();
            }); return function (v) { return t.apply(this, arguments) }
          }(); f.getSymbolLayerSize = function (t) { t = this.symbolLayers[t]; return c.isSome(t) ? t.getCachedSize() : null }; f.createGraphics3DGraphic = function (t, v) {
            const m = t.graphic, e = Array(this.symbolLayers.length); for (let g = 0; g < this.symbolLayers.length; g++) {
              const x = this.symbolLayers[g]; e[g] = c.isSome(x) ?
                x.createGraphics3DGraphic(t) : null
            } return new u(m, v || this, e, t.layer, this._context.arcade || this._context.featureExpressionInfoContext && this._context.featureExpressionInfoContext.arcade && this._context.featureExpressionInfoContext.arcade.modules || null)
          }; f.globalPropertyChanged = function (t, v) { const m = this.symbolLayers.length; for (let e = 0; e < m; e++) { const g = this.symbolLayers[e], x = k => { k = k.graphics[e]; return k instanceof y.Graphics3DObject3DGraphicLayer ? k : null }; if (c.isSome(g) && !g.globalPropertyChanged(t, v, x)) return !1 } return !0 };
          f.applyRendererDiff = function (t, v) { return 1 !== this.loadStatus ? 0 : this.symbolLayers.reduce((m, e) => 0 !== m && c.isSome(e) ? Math.min(m, e.applyRendererDiff(t, v)) : m, 2) }; f.prepareSymbolPatch = function (t) {
            if (2 !== this.loadStatus && "partial" === t.diff.type) {
              var v = t.diff.diff; if (v.symbolLayers && "partial" === v.symbolLayers.type) {
                var m = v.symbolLayers.diff; this.symbolLayers.forEach((e, g) => {
                  if (!c.isNone(e)) {
                    var x = m[g]; if (x) {
                      const k = { diff: x, graphics3DGraphicPatches: [], symbolLayerStatePatches: [] }; e.prepareSymbolLayerPatch(k);
                      t.symbolStatePatches.push(...k.symbolLayerStatePatches); k.graphics3DGraphicPatches.length && t.graphics3DGraphicPatches.push((r, A) => { const z = r.graphics[g]; c.isSome(z) && k.graphics3DGraphicPatches.forEach(B => B(z, A)) })
                    }
                  }
                })
              }
            }
          }; f.updateGeometry = function (t, v) { for (let m = 0; m < this.symbolLayers.length; m++) { const e = this.symbolLayers[m]; if (c.isNone(e)) continue; const g = t.graphics[m]; if (c.isNone(g) || !e.updateGeometry(g, v)) return !1 } return !0 }; f.onRemoveGraphic = function (t) {
            for (let v = 0; v < this.symbolLayers.length; v++) {
              const m =
                this.symbolLayers[v]; if (c.isNone(m)) continue; const e = t.graphics[v]; if (c.isSome(e)) m.onRemoveGraphic(e)
            }
          }; f.getFastUpdateStatus = function () { let t = 0, v = 0, m = 0; this.symbolLayers.forEach(e => { c.isNone(e) || (0 === e.loadStatus ? t++ : e.isFastUpdatesEnabled() ? m++ : v++) }); return { loading: t, slow: v, fast: m } }; f.destroy = function () {
            if (this.destroyed) console.error("Graphics3DSymbol.destroy called when already destroyed!"); else {
              b.prototype.destroy.call(this); for (const t of this.symbolLayers) c.isSome(t) && t.destroy(); this.symbolLayers.length =
                0; this._destroyed = !0
            }
          }; a._createClass(d, [{ key: "symbol", get: function () { return this._symbol }, set: function (t) { this._symbol = t; for (let v = 0; v < t.symbolLayers.length; v++) { const m = this.symbolLayers[v]; c.isNone(m) || (m.symbol = t, m.symbolLayer = t.symbolLayers.items[v]) } } }, { key: "extentPadding", get: function () { return this._extentPadding } }, { key: "complexity", get: function () { return l.totalSymbolComplexities(this.symbolLayers.map(t => c.get(t, "complexity"))) } }, { key: "destroyed", get: function () { return this._destroyed } }]); return d
        }(p.Loadable)
      })
    },
    "esri/views/3d/layers/graphics/Graphics3DGraphic": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/asyncUtils ../../../../core/byteSizeEstimations ../../../../core/maybe ../../../../core/ObjectPool ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/Polygon ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ../../../../layers/graphics/dehydratedFeatures ../../../../layers/graphics/featureConversionUtils ./featureExpressionInfoUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = new u(Array, x => d.set(x, d.ZERO), null, 10, 5), g = f.create(); return function () {
            function x(r, A, z, B, C) {
            this.graphic = r; this.graphics3DSymbol = A; this.graphics = z; this._labelGraphics = []; this._auxiliaryGraphics = []; var D = Array(2); for (let E = 0; E < D.length; E++)D[E] = Array(4); this._visibilityFlags = D; this._featureExpressionFeature = null; this._optimizedGeometry = { geometry: null, hasZ: !1, hasM: !1 }; this._extent = null; this.isElevationSource = !1; ++A.referenced; this._featureExpressionFeature =
              C ? m.createFeature(C, r, B) : null; for (const E of z) q.isSome(E) && (this.isElevationSource = this.isElevationSource || E.isElevationSource)
            } var k = x.prototype; k.initialize = function (r, A, z) { this._layer = A; this._stage = r; this.forEachSymbolLayerGraphic(B => { B.initialize(r, A, z); B.setVisibility(this.isVisible()) }) }; k.destroy = function () { this.forEachSymbolLayerGraphic(r => r.destroy()); this._auxiliaryGraphics = this.graphics = null; --this.graphics3DSymbol.referenced; this.graphics3DSymbol = null }; k.clearLabelGraphics = function () {
              this.forEachLabelGraphic(r =>
                r.destroy()); this._labelGraphics.length = 0
            }; k.addLabelGraphic = function (r, A, z) { this._labelGraphics.push(r); r.initialize(A, z); r.setVisibility(this.isVisible(1)) }; k.addAuxiliaryGraphic = function (r) { this._auxiliaryGraphics.push(r); this._layer && (r.initialize(this._stage, this._layer), r.setVisibility(this.isVisible())) }; k.isVisible = function (r = 0, A) { for (let z = 0; z <= r; z++) { const B = this._visibilityFlags[z]; for (let C = 0; C < B.length; ++C)if (!1 === B[C] && C !== A) return !1 } return !0 }; k.hasVisibilityFlag = function (r, A) {
              return null !=
                this._visibilityFlags[A][r]
            }; k.setVisibilityFlag = function (r, A, z) { const B = this.isVisible(z); this._visibilityFlags[z][r] = A; const C = this.isVisible(z); if (B === C) return !1; if (1 === z) this.forEachLabelGraphic(D => D.setVisibility(C)); else { this.forEachSymbolLayerGraphic(E => E.setVisibility(C)); const D = this.isVisible(1); this.forEachLabelGraphic(E => E.setVisibility(D)) } return !0 }; k.clearVisibilityFlag = function (r, A = 0) { return this.setVisibilityFlag(r, void 0, A) }; k.computeExtent = function (r) {
              if (!this._extent) {
                var A = this.graphic.geometry;
                if (q.isNone(A)) return !1; this._extent = f.create(); t.computeAABR(A, this._extent); A = A.spatialReference; if (!A.equals(r) && !b.projectBoundingRect(this._extent, A, this._extent, r)) return this._extent = null, !1
              } return !0
            }; k.getAsOptimizedGeometry = function (r, A) {
              if (q.isSome(this._optimizedGeometry.geometry) && this._optimizedGeometry.hasZ === r && this._optimizedGeometry.hasM === A) return this._optimizedGeometry.geometry; this._optimizedGeometry.geometry = this._convertGraphicToOptimizedGeometry(this.graphic, r, A); this._optimizedGeometry.hasZ =
                r; this._optimizedGeometry.hasM = A; return this._optimizedGeometry.geometry
            }; k._convertGraphicToOptimizedGeometry = function (r, A, z) { r = r.geometry; if ("mesh" === r.type || "extent" === r.type) r = h.fromExtent("mesh" === r.type ? r.extent : r); return v.convertFromGeometry(r, A, z) }; k.computeAttachmentOrigin = function () {
              const r = { render: { origin: l.create(), num: 0 }, draped: { origin: n.create(), num: 0 } }; for (const A of this.graphics) q.isNone(A) || A.computeAttachmentOrigin(r); r.render.num && p.scale(r.render.origin, r.render.origin, 1 / r.render.num);
              r.draped.num && y.scale(r.draped.origin, r.draped.origin, 1 / r.draped.num); return r
            }; k.getProjectedBoundingBox = function () {
              var r = a._asyncToGenerator(function* (A, z, B, C, D) {
                D || (D = { boundingBox: null, requiresDrapedElevation: !1, screenSpaceObjects: [] }); D.boundingBox ? d.empty(D.boundingBox) : D.boundingBox = d.empty(); D.requiresDrapedElevation = !1; yield w.forEach(this.graphics, function () {
                  var E = a._asyncToGenerator(function* (H) {
                    if (!q.isNone(H)) {
                      var J = "draped" === H.type ? z : A, M = e.acquire(); H = yield H.getProjectedBoundingBox(J,
                        B, D.screenSpaceObjects, C, M); isFinite(H[2]) && isFinite(H[5]) || (D.requiresDrapedElevation = !0); H && d.expandWithAABB(D.boundingBox, M); e.release(M)
                    }
                  }); return function (H) { return E.apply(this, arguments) }
                }()); return d.allFinite(D.boundingBox) || f.allFinite(d.toRect(D.boundingBox, g)) ? D : null
              }); return function (A, z, B, C, D) { return r.apply(this, arguments) }
            }(); k.needsElevationUpdates = function () {
              for (const r of this.graphics) if (q.isSome(r) && ("object3d" === r.type || "lod-instance" === r.type) && r.needsElevationUpdates) return !0;
              for (const r of this._labelGraphics) if (r && r.needsElevationUpdates) return !0; return !1
            }; k.alignWithElevation = function (r, A, z) { this.forEachRenderedGraphic(B => { "object3d" !== B.type && "lod-instance" !== B.type || B.alignWithElevation(r, A, this._featureExpressionFeature, z) }) }; k.addObjectStateSet = function (r, A) { this.forEachSymbolLayerGraphic(z => z.addObjectState(r, A)) }; k.removeObjectState = function (r) { this.forEachSymbolLayerGraphic(A => A.removeObjectState(r)) }; k.forEachGraphicList = function (r, A) { r.forEach(z => z && A(z)) };
            k.forEachSymbolLayerGraphic = function (r) { this.forEachGraphicList(this.graphics, r); this.forEachGraphicList(this._auxiliaryGraphics, r) }; k.forEachLabelGraphic = function (r) { this.forEachGraphicList(this._labelGraphics, r) }; k.forEachRenderedGraphic = function (r) { this.forEachSymbolLayerGraphic(r); this.forEachLabelGraphic(r) }; a._createClass(x, [{ key: "labelGraphics", get: function () { return this._labelGraphics } }, { key: "extent", get: function () { return this._extent } }, { key: "destroyed", get: function () { return null == this.graphics } },
            { key: "isDraped", get: function () { let r = !1; this.forEachSymbolLayerGraphic(A => { "draped" === A.type && (r = !0) }); return r } }, { key: "usedMemory", get: function () { let r = c.estimateAttributesObjectSize(this.graphic.attributes); this.forEachSymbolLayerGraphic(A => { const z = A.graphics3DSymbolLayer.complexity; q.isNone(z) || (A = "draped" === A.type ? z.memory.draped : z.memory, r += A.bytesPerFeature, A.bytesPerCoordinate && (r += t.numVertices(this.graphic.geometry) * A.bytesPerCoordinate)) }); return r } }]); return x
          }()
        })
    }, "esri/views/3d/layers/graphics/Graphics3DSymbolLayerFactory": function () {
      define("exports ../../../../core/Logger ./Graphics3DExtrudeSymbolLayer ./Graphics3DIconSymbolLayer ./Graphics3DLineSymbolLayer ./Graphics3DMeshFillSymbolLayer ./Graphics3DObjectSymbolLayer ./Graphics3DPathSymbolLayer ./Graphics3DPolygonFillSymbolLayer ./Graphics3DTextSymbolLayer ./Graphics3DWaterSymbolLayer".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          const d = w.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayerFactory"), f = { icon: q.Graphics3DIconSymbolLayer, object: n.Graphics3DObjectSymbolLayer, line: u.Graphics3DLineSymbolLayer, path: p.Graphics3DPathSymbolLayer, fill: l.Graphics3DPolygonFillSymbolLayer, extrude: c.Graphics3DExtrudeSymbolLayer, text: h.Graphics3DTextSymbolLayer, water: b.Graphics3DWaterSymbolLayer }, t = { "mesh-3d": { fill: y.Graphics3DMeshFillSymbolLayer } }; a.make = function (v, m, e, g) {
            const x = t[v.type] && t[v.type][m.type] ||
              f[m.type]; return x ? new x(v, m, e, g) : (d.error("GraphicsLayerFactory#make", `unknown symbol type ${m.type}`), null)
          }; a.setSymbolClass = function (v, m) { f[v] = m }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DExtrudeSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Error ../../../../core/maybe ../../../../chunks/earcut ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/buffer/BufferView ../../../../chunks/vec32 ../../../../renderers/support/renderingInfoUtils ./elevationAlignmentUtils ./ElevationContext ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ./polygonUtils ../support/edgeUtils ../../support/debugFlags ../../support/ElevationProvider ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/Object3D ../../webgl-engine/materials/DefaultMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H) {
          function J(ha, ka, ea, ba, aa, W, U, X, Z, ia, la, ma, ra, Aa) {
            let za = 0; var Ka = 2 * ba.count; {
              var Ea = ba.index, Ua = ba.count, Na = ea.length / 3, ya = Z; h.copy(T, ra); const pa = 0 < ma ? 1 : -1; Ea *= 3; let wa = ya; ra = 3 * wa; let Ia = ya + Ua; ya = 3 * Ia; for (let Ha = 0; Ha < Ua; ++Ha)Aa && (T[0] = ha[Ea + 0], T[1] = ha[Ea + 1], T[2] = ha[Ea + 2], h.normalize(T, T)), aa[ra + 0] = ha[Ea + 0], aa[ra + 1] = ha[Ea + 1], aa[ra + 2] = ha[Ea + 2], W[ra + 0] = ka[Ea + 0], W[ra + 1] = ka[Ea + 1], W[ra + 2] = ka[Ea + 2], U[ra + 0] = -pa * T[0], U[ra + 1] = -pa * T[1], U[ra +
                2] = -pa * T[2], X[wa] = 0, aa[ya + 0] = ha[Ea + 0] + ma * T[0], aa[ya + 1] = ha[Ea + 1] + ma * T[1], aa[ya + 2] = ha[Ea + 2] + ma * T[2], W[ya + 0] = ka[Ea + 0], W[ya + 1] = ka[Ea + 1], W[ya + 2] = ka[Ea + 2], U[ya + 0] = pa * T[0], U[ya + 1] = pa * T[1], U[ya + 2] = pa * T[2], X[Ia] = ma, ra += 3, ya += 3, Ea += 3, wa += 1, Ia += 1; ra = Ea = 0; ya = 3 * Ka; ha = 0 > ma ? fa : Y; ka = 0 > ma ? Y : fa; for (Aa = 0; Aa < Na; ++Aa)la[ra + 0] = ea[Ea + ha[0]], la[ra + 1] = ea[Ea + ha[1]], la[ra + 2] = ea[Ea + ha[2]], ia[ya + 0] = ea[Ea + ka[0]] + Ua, ia[ya + 1] = ea[Ea + ka[1]] + Ua, ia[ya + 2] = ea[Ea + ka[2]] + Ua, ra += 3, ya += 3, Ea += 3
            } Z += 2 * ba.count; Ka = 0; F(aa, W, X, U, za, ba.pathLengths[0],
              ba.count, Z, ia, Ka, ma); Z += 4 * ba.pathLengths[0]; Ka += 2 * ba.pathLengths[0]; za += ba.pathLengths[0]; for (ea = 1; ea < ba.pathLengths.length; ++ea)F(aa, W, X, U, za, ba.pathLengths[ea], ba.count, Z, ia, Ka, ma), Z += 4 * ba.pathLengths[ea], Ka += 2 * ba.pathLengths[ea], za += ba.pathLengths[ea]
          } function M(ha, ka, ea, ba, aa, W, U) { ba[W] = ba[U]; U *= 3; W *= 3; ha[W + 0] = ha[U + 0]; ha[W + 1] = ha[U + 1]; ha[W + 2] = ha[U + 2]; ka[W + 0] = ka[U + 0]; ka[W + 1] = ka[U + 1]; ka[W + 2] = ka[U + 2]; ea[W + 0] = aa[0]; ea[W + 1] = aa[1]; ea[W + 2] = aa[2] } function F(ha, ka, ea, ba, aa, W, U, X, Z, ia, la) {
            let ma = aa, ra = aa +
              1, Aa = aa + U, za = aa + U + 1, Ka = X, Ea = X + 1, Ua = X + 2 * W; X = X + 2 * W + 1; 0 > la && (ma = aa + U + 1, za = aa); ia *= 3; for (let Ha = 0; Ha < W; ++Ha) {
              Ha === W - 1 && (0 < la ? (ra = aa, za = aa + U) : (ra = aa, ma = aa + U)); var Na = ha, ya = ma, pa = ra, wa = Aa, Ia = L; ya *= 3; pa *= 3; wa *= 3; h.set(N, Na[ya++], Na[ya++], Na[ya++]); h.set(G, Na[pa++], Na[pa++], Na[pa++]); h.set(I, Na[wa++], Na[wa++], Na[wa++]); h.subtract(O, G, N); h.subtract(R, I, N); h.cross(Ia, R, O); h.normalize(Ia, Ia); M(ha, ka, ba, ea, L, Ka, ma); M(ha, ka, ba, ea, L, Ea, ra); M(ha, ka, ba, ea, L, Ua, Aa); M(ha, ka, ba, ea, L, X, za); Z[ia++] = Ka; Z[ia++] = Ua; Z[ia++] =
                X; Z[ia++] = Ka; Z[ia++] = X; Z[ia++] = Ea; ma++; ra++; Aa++; za++; Ka += 2; Ea += 2; Ua += 2; X += 2
              }
          } function K(ha, ka, ea, ba) {
            ha = ha.stageObject; const aa = ha.geometryRecords, W = aa.length, U = "absolute-height" !== ka.mode; let X = 0; const Z = ha.transformation, ia = p.invert(l.create(), Z); for (let ma = 0; ma < W; ma += 2) {
              const ra = aa[ma].geometry, Aa = ra.getMutableAttribute("position").data, za = ra.vertexAttributes.get("size").data; var la = ra.vertexAttributes.get("mapPos").data; la = new C.SamplePosition(la); const Ka = Aa.length / 3; let Ea = 0, Ua = !1, Na = 0; const ya =
                ea.spatialReference; for (let pa = 0; pa < Ka; pa++) {
                S[0] = Aa[Ea]; S[1] = Aa[Ea + 1]; S[2] = Aa[Ea + 2]; e.evaluateElevationInfoAtPoint(la, ea, ka, ba, da); U && (Na += da.sampledElevation); B.TESTS_DISABLE_OPTIMIZATIONS ? (h.set(Q, la.array[la.offset + 0], la.array[la.offset + 1], da.z + za[Ea / 3]), ba.toRenderCoords(Q, ya, Q)) : (h.set(Q, Aa[Ea + 0], Aa[Ea + 1], Aa[Ea + 2]), h.transformMat4(Q, Q, Z), ba.setAltitude(Q, da.z + za[Ea / 3])); h.transformMat4(Q, Q, ia); Aa[Ea] = Q[0]; Aa[Ea + 1] = Q[1]; Aa[Ea + 2] = Q[2]; const wa = .01 / ba.unitInMeters; if (Math.abs(S[0] - Aa[Ea]) >= wa ||
                  Math.abs(S[1] - Aa[Ea + 1]) >= wa || Math.abs(S[2] - Aa[Ea + 2]) >= wa) Ua = !0; la.offset += 3; Ea += 3
                } Ua && (ra.invalidateBoundingInfo(), ha.geometryVertexAttrsUpdated(aa[ma]), aa[ma + 1].geometry.invalidateBoundingInfo(), ha.geometryVertexAttrsUpdated(aa[ma + 1])); X += Na / Ka
            } return X / W
          } const P = ["polygon", "extent"]; k = function (ha) {
            function ka(ba, aa, W, U) { ba = ha.call(this, ba, aa, W, U) || this; ba.ensureDrapedStatus(!1); return ba } w._inheritsLoose(ka, ha); var ea = ka.prototype; ea.doLoad = function () {
              var ba = w._asyncToGenerator(function* () {
                if (!this._drivenProperties.size) {
                  var aa =
                    r.validateSymbolLayerSize(this._getSymbolSize()); if (aa) throw new c("graphics3dextrudesymbollayer:invalid-size", aa);
                } aa = q.get(this.symbolLayer, "material", "color"); var W = this._getCombinedOpacityAndColor(aa); aa = b.fromArray(W); W = W[3]; const U = 1 > W || this.needsDrivenTransparentPass; aa = {
                  usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0, diffuse: aa, ambient: aa, opacity: W, transparent: U, cullFace: U ? 0 : 2, vertexColors: !0, slicePlaneEnabled: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows,
                  offsetTransparentBackfaces: !0
                }; this._material = new H.DefaultMaterial(aa); this._bottomMaterial = new H.DefaultMaterial({ ...aa, cullFace: 2 }); this._context.stage.add(this._material); this._context.stage.add(this._bottomMaterial)
              }); return function () { return ba.apply(this, arguments) }
            }(); ea.destroy = function () { ha.prototype.destroy.call(this); this._material && (this._context.stage.remove(this._material), this._context.stage.remove(this._bottomMaterial)) }; ea.createGraphics3DGraphic = function (ba) {
              const aa = ba.graphic;
              if (!this._validateGeometry(aa.geometry, P, this.symbolLayer.type)) return null; const W = this._getVertexOpacityAndColor(ba.renderingInfo, 255), U = this.setGraphicElevationContext(aa, new g.ElevationContext); return this._createAs3DShape(aa, ba.renderingInfo, W, U, aa.uid)
            }; ea.layerOpacityChanged = function (ba, aa) {
              var W = q.get(this.symbolLayer, "material", "color"); W = this._getCombinedOpacity(W); const U = 1 > W || this.needsDrivenTransparentPass; this._material.setParameters({ opacity: W, transparent: U }); this._bottomMaterial.setParameters({
                opacity: W,
                transparent: U
              }); const X = this._getLayerOpacity(); ba.forEach(Z => { Z = aa(Z); q.isSome(Z) && Z.layerOpacityChanged(X, this._context.isAsync) }); return !0
            }; ea.layerElevationInfoChanged = function (ba, aa) { return this.updateGraphics3DGraphicElevationInfo(ba, aa, e.needsElevationUpdates3D) }; ea.slicePlaneEnabledChanged = function (ba, aa) {
              this._material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); this._bottomMaterial.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); ba.forEach(W => {
                W =
                aa(W); q.isSome(W) && W.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync)
              }); return !0
            }; ea.physicalBasedRenderingChanged = function () { this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0 }); this._bottomMaterial.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0 }); return !0 }; ea.pixelRatioChanged = function () { return !0 }; ea._getExtrusionSize = function (ba) {
              if (ba.size && this._drivenProperties.size) {
                var aa; ba = null !=
                  (aa = m.getDriverAxisSizeValue(ba.size, 2)) ? aa : 0
              } else ba = this._getSymbolSize(); return ba /= this._context.renderCoordsHelper.unitInMeters
            }; ea.applyRendererDiff = function () { return 1 }; ea._getSymbolSize = function () { var ba; return null != (ba = this.symbolLayer.size) ? ba : 1 }; ea._createAs3DShape = function (ba, aa, W, U, X) {
              var Z = A.geometryAsPolygon(ba.geometry); if (q.isNone(Z)) return null; ba = A.geometryToRenderInfo(Z, this._context.elevationProvider, this._context.renderCoordsHelper, U); this._logGeometryCreationWarnings(ba, Z.rings,
                "rings", "ExtrudeSymbol3DLayer"); if (0 === Z.rings.length || !Z.rings.some(qa => 0 < qa.length)) return null; var ia = r.computeCentroid(Z); if (q.isNone(ia)) return null; var la = []; const ma = [], ra = [], Aa = f.create(), za = l.create(), Ka = b.create(), Ea = 1 === this._context.renderCoordsHelper.viewingMode; Ea || this._context.renderCoordsHelper.worldUpAtPosition(null, Ka); d.computeTranslationToOriginAndRotation(Z.spatialReference, [ia.x, ia.y, 0], za, this._context.renderCoordsHelper.spatialReference); Z = l.create(); p.invert(Z, za); ia = n.create();
              y.normalFromMat4(ia, Z); const { polygons: Ua, mapPosition: Na, position: ya } = ba; var pa = ya.length / 3; const wa = new Float64Array(18 * pa), Ia = new Float64Array(18 * pa), Ha = new Float64Array(18 * pa); pa = new Float64Array(6 * pa); let Oa = 0; for (let qa = 0; qa < Ua.length; ++qa) {
                var Ba = Ua[qa]; const Da = Ba.count; if (this._context.clippingExtent && (f.empty(Aa), f.expandWithBuffer(Aa, Ba.mapPosition), !f.intersectsClippingArea(Aa, this._context.clippingExtent))) continue; const na = u.earcut(Ba.mapPosition, Ba.holeIndices, 3); if (0 === na.length) continue;
                const xa = new Uint32Array(6 * Da + na.length); var sa = new Uint32Array(na.length), Ca = 6 * Da, Ja = 3 * wa.BYTES_PER_ELEMENT; Ja = new t.BufferViewVec3f64(wa.buffer, Oa * Ja, Ja, (Oa + Ca) * Ja); var ca = 3 * Ia.BYTES_PER_ELEMENT; ca = new t.BufferViewVec3f64(Ia.buffer, Oa * ca, ca, (Oa + Ca) * ca); const Qa = new Float64Array(Ha.buffer, 3 * Oa * Ha.BYTES_PER_ELEMENT, 3 * Ca); Ca = new Float64Array(pa.buffer, 1 * Oa * pa.BYTES_PER_ELEMENT, 1 * Ca); const Wa = this._getExtrusionSize(aa); J(ya, Na, na, Ba, Ja.typedBuffer, Qa, ca.typedBuffer, Ca, 0, xa, sa, Wa, Ka, Ea); v.transformMat4(Ja,
                  Ja, Z); v.transformMat3(ca, ca, ia); Oa += 6 * Da; Ba = this._createExtrudeGeometry(xa, xa.length - sa.length, { positions: Ja.typedBuffer, elevation: Qa, normals: ca.typedBuffer, heights: Ca }, W); la.push(Ba); ma.push(this._material); ra.push(l.IDENTITY); sa = this._createExtrudeGeometry(sa, 0, { positions: Ja.typedBuffer, elevation: Qa, normals: ca.typedBuffer, heights: Ca }, W); la.push(sa); ma.push(this._bottomMaterial); ra.push(l.IDENTITY)
              } if (0 === la.length) return null; aa = new E.Object3D({
                geometries: la, materials: ma, transformations: ra, metadata: {
                  layerUid: this._context.layer.uid,
                  graphicUid: X, isElevationSource: !0
                }
              }); aa.transformation = za; W = z.createMaterial(this.symbolLayer, { opacity: this._getLayerOpacity() }); W = q.isSome(W) ? { baseMaterial: this._material, edgeMaterials: [W], properties: { mergeGeometries: !0, slicePlaneEnabled: this._context.slicePlaneEnabled } } : null; la = new x.Graphics3DObject3DGraphicLayer(this, aa, la, null, null, K, U, W); la.alignedSampledElevation = ba.sampledElevation; la.needsElevationUpdates = e.needsElevationUpdates3D(U.mode); return la
            }; ea._createExtrudeGeometry = function (ba,
              aa, W, U) { var X = new Uint32Array(ba.length); U = [["position", { size: 3, data: W.positions, exclusive: !0 }], ["normal", { size: 3, data: W.normals, exclusive: !0 }], ["color", { size: 4, data: U, exclusive: !0 }], ["size", { size: 1, data: W.heights, exclusive: !0 }]]; X = [["position", ba], ["normal", ba], ["color", X]]; W.elevation && (U.push(["mapPos", { size: 3, data: W.elevation }]), X.push(["mapPos", ba])); return new D.Geometry(U, X, 0, aa) }; return ka
          }(k.Graphics3DSymbolLayer); const L = b.create(), N = b.create(), G = b.create(), I = b.create(), O = b.create(), R = b.create(),
            S = b.create(), Q = b.create(), T = b.create(), da = new e.SampleElevationInfo, Y = [0, 2, 1], fa = [0, 1, 2]; a.Graphics3DExtrudeSymbolLayer = k; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/earcut": function () {
      define(["exports"], function (a) {
        var w = { exports: {} }; (function (c) {
          (function (q) { q = q(); void 0 !== q && (c.exports = q) })(function () {
            function q(E, H, J) {
              J = J || 2; var M = H && H.length, F = M ? H[0] * J : E.length, K = u(E, 0, F, J, !0), P = []; if (!K || K.next === K.prev) return P; var L; if (M) {
                var N = K; var G = J; K = []; var I; M = 0; for (I = H.length; M <
                  I; M++) { var O = H[M] * G; var R = M < I - 1 ? H[M + 1] * G : E.length; O = u(E, O, R, G, !1); O === O.next && (O.steiner = !0); K.push(t(O)) } K.sort(l); for (M = 0; M < K.length; M++)G = K[M], H = N, (N = b(G, H)) ? (I = A(N, G), G = y(N, N.next), I = h(I), y(I, I.next), G = h(G), N = h(H === N ? G : H)) : N = H, N = y(N, N.next); K = N
              } if (E.length > 80 * J) { var S = L = E[0]; var Q = M = E[1]; for (G = J; G < F; G += J)H = E[G], N = E[G + 1], H < S && (S = H), N < Q && (Q = N), H > L && (L = H), N > M && (M = N); L = Math.max(L - S, M - Q); L = 0 !== L ? 1 / L : 0 } n(K, P, J, S, Q, L); return P
            } function u(E, H, J, M, F) {
              if (F === 0 < D(E, H, J, M)) for (F = H; F < J; F += M)var K = z(F, E[F],
                E[F + 1], K); else for (F = J - M; F >= H; F -= M)K = z(F, E[F], E[F + 1], K); K && e(K, K.next) && (E = K.next, B(K), K = E); return K
            } function y(E, H) { if (!E) return E; H || (H = E); do { var J = !1; if (E.steiner || !e(E, E.next) && 0 !== m(E.prev, E, E.next)) E = E.next; else { H = E.prev; B(E); E = H; if (E === E.next) break; J = !0 } } while (J || E !== H); return H } function n(E, H, J, M, F, K, P) {
              if (E) {
              !P && K && d(E, M, F, K); for (var L = E, N, G; E.prev !== E.next;) {
                N = E.prev; G = E.next; if (K) var I = p(E, M, F, K); else a: {
                  I = E; var O = I.prev, R = I, S = I.next; if (0 <= m(O, R, S)) I = !1; else {
                    for (var Q = I.next.next; Q !== I.prev;) {
                      if (v(O.x,
                        O.y, R.x, R.y, S.x, S.y, Q.x, Q.y) && 0 <= m(Q.prev, Q, Q.next)) { I = !1; break a } Q = Q.next
                    } I = !0
                  }
                } if (I) H.push(N.i / J), H.push(E.i / J), H.push(G.i / J), B(E), L = E = G.next; else if (E = G, E === L) {
                  if (!P) n(y(E), H, J, M, F, K, 1); else if (1 === P) { E = y(E); P = H; L = J; N = E; do G = N.prev, I = N.next.next, !e(G, I) && g(G, N, N.next, I) && r(G, I) && r(I, G) && (P.push(G.i / L), P.push(N.i / L), P.push(I.i / L), B(N), B(N.next), N = E = I), N = N.next; while (N !== E); E = y(N); n(E, H, J, M, F, K, 2) } else if (2 === P) a: {
                    P = E; do {
                      for (L = P.next.next; L !== P.prev;) {
                        if (N = P.i !== L.i) {
                          I = I = I = I = void 0; N = P; G = L; if (I =
                            N.next.i !== G.i && N.prev.i !== G.i) { b: { I = N; do { if (I.i !== N.i && I.next.i !== N.i && I.i !== G.i && I.next.i !== G.i && g(I, I.next, N, G)) { I = !0; break b } I = I.next } while (I !== N); I = !1 } I = !I } if (I) { if (I = r(N, G) && r(G, N)) { I = N; O = !1; R = (N.x + G.x) / 2; S = (N.y + G.y) / 2; do I.y > S !== I.next.y > S && I.next.y !== I.y && R < (I.next.x - I.x) * (S - I.y) / (I.next.y - I.y) + I.x && (O = !O), I = I.next; while (I !== N); I = O } I = I && (m(N.prev, N, G.prev) || m(N, G.prev, G)) || e(N, G) && 0 < m(N.prev, N, N.next) && 0 < m(G.prev, G, G.next) } N = I
                        } if (N) {
                          E = A(P, L); P = y(P, P.next); E = y(E, E.next); n(P, H, J, M, F, K); n(E,
                            H, J, M, F, K); break a
                        } L = L.next
                      } P = P.next
                    } while (P !== E)
                  } break
                }
              }
              }
            } function p(E, H, J, M) {
              var F = E.prev, K = E.next; if (0 <= m(F, E, K)) return !1; var P = F.x > E.x ? F.x > K.x ? F.x : K.x : E.x > K.x ? E.x : K.x, L = F.y > E.y ? F.y > K.y ? F.y : K.y : E.y > K.y ? E.y : K.y, N = f(F.x < E.x ? F.x < K.x ? F.x : K.x : E.x < K.x ? E.x : K.x, F.y < E.y ? F.y < K.y ? F.y : K.y : E.y < K.y ? E.y : K.y, H, J, M); H = f(P, L, H, J, M); J = E.prevZ; for (M = E.nextZ; J && J.z >= N && M && M.z <= H;) {
                if (J !== E.prev && J !== E.next && v(F.x, F.y, E.x, E.y, K.x, K.y, J.x, J.y) && 0 <= m(J.prev, J, J.next)) return !1; J = J.prevZ; if (M !== E.prev && M !== E.next && v(F.x,
                  F.y, E.x, E.y, K.x, K.y, M.x, M.y) && 0 <= m(M.prev, M, M.next)) return !1; M = M.nextZ
              } for (; J && J.z >= N;) { if (J !== E.prev && J !== E.next && v(F.x, F.y, E.x, E.y, K.x, K.y, J.x, J.y) && 0 <= m(J.prev, J, J.next)) return !1; J = J.prevZ } for (; M && M.z <= H;) { if (M !== E.prev && M !== E.next && v(F.x, F.y, E.x, E.y, K.x, K.y, M.x, M.y) && 0 <= m(M.prev, M, M.next)) return !1; M = M.nextZ } return !0
            } function l(E, H) { return E.x - H.x } function h(E) { if (E.next.prev === E) return E; let H = E; do { const J = H.next; if (J.prev === H || J === H || J === E) break; H = J } while (1); return H } function b(E, H) {
              var J = H,
              M = E.x, F = E.y, K = -Infinity; do { if (F <= J.y && F >= J.next.y && J.next.y !== J.y) { var P = J.x + (F - J.y) * (J.next.x - J.x) / (J.next.y - J.y); if (P <= M && P > K) { K = P; if (P === M) { if (F === J.y) return J; if (F === J.next.y) return J.next } var L = J.x < J.next.x ? J : J.next } } J = J.next } while (J !== H); if (!L) return null; if (M === K) return L; H = L; P = L.x; var N = L.y, G = Infinity; J = L; do {
                if (M >= J.x && J.x >= P && M !== J.x && v(F < N ? M : K, F, P, N, F < N ? K : M, F, J.x, J.y)) {
                  var I = Math.abs(F - J.y) / (M - J.x); var O; if ((O = r(J, E)) && !(O = I < G) && (O = I === G) && !(O = J.x > L.x) && (O = J.x === L.x)) {
                    O = L; var R = J; O = 0 > m(O.prev,
                      O, R.prev) && 0 > m(R.next, O, O.next)
                  } O && (L = J, G = I)
                } J = J.next
              } while (J !== H); return L
            } function d(E, H, J, M) {
              var F = E; do { null === F.z && (F.z = f(F.x, F.y, H, J, M)); if (F.prev.next !== F || F.next.prev !== F) return F.prev.next = F, F.next.prev = F, d(E, H, J, M); F.prevZ = F.prev; F = F.nextZ = F.next } while (F !== E); F.prevZ.nextZ = null; F.prevZ = null; E = F; var K, P, L, N = 1; do {
                H = E; M = E = null; for (F = 0; H;) {
                  F++; J = H; for (K = P = 0; K < N && (P++ , J = J.nextZ, J); K++); for (L = N; 0 < P || 0 < L && J;)0 !== P && (0 === L || !J || H.z <= J.z) ? (K = H, H = H.nextZ, P--) : (K = J, J = J.nextZ, L--), M ? M.nextZ = K : E = K, K.prevZ =
                    M, M = K; H = J
                } M.nextZ = null; N *= 2
              } while (1 < F)
            } function f(E, H, J, M, F) { E = 32767 * (E - J) * F; H = 32767 * (H - M) * F; E = (E | E << 8) & 16711935; E = (E | E << 4) & 252645135; E = (E | E << 2) & 858993459; H = (H | H << 8) & 16711935; H = (H | H << 4) & 252645135; H = (H | H << 2) & 858993459; return (E | E << 1) & 1431655765 | ((H | H << 1) & 1431655765) << 1 } function t(E) { var H = E, J = E; do { if (H.x < J.x || H.x === J.x && H.y < J.y) J = H; H = H.next } while (H !== E); return J } function v(E, H, J, M, F, K, P, L) { return 0 <= (F - P) * (H - L) - (E - P) * (K - L) && 0 <= (E - P) * (M - L) - (J - P) * (H - L) && 0 <= (J - P) * (K - L) - (F - P) * (M - L) } function m(E, H, J) {
              return (H.y -
                E.y) * (J.x - H.x) - (H.x - E.x) * (J.y - H.y)
            } function e(E, H) { return E.x === H.x && E.y === H.y } function g(E, H, J, M) { var F = k(m(E, H, J)), K = k(m(E, H, M)), P = k(m(J, M, E)), L = k(m(J, M, H)); return F !== K && P !== L || 0 === F && x(E, J, H) || 0 === K && x(E, M, H) || 0 === P && x(J, E, M) || 0 === L && x(J, H, M) ? !0 : !1 } function x(E, H, J) { return H.x <= Math.max(E.x, J.x) && H.x >= Math.min(E.x, J.x) && H.y <= Math.max(E.y, J.y) && H.y >= Math.min(E.y, J.y) } function k(E) { return 0 < E ? 1 : 0 > E ? -1 : 0 } function r(E, H) {
              return 0 > m(E.prev, E, E.next) ? 0 <= m(E, H, E.next) && 0 <= m(E, E.prev, H) : 0 > m(E, H, E.prev) ||
                0 > m(E, E.next, H)
            } function A(E, H) { var J = new C(E.i, E.x, E.y), M = new C(H.i, H.x, H.y), F = E.next, K = H.prev; E.next = H; H.prev = E; J.next = F; F.prev = J; M.next = J; J.prev = M; K.next = M; M.prev = K; return M } function z(E, H, J, M) { E = new C(E, H, J); M ? (E.next = M.next, E.prev = M, M.next.prev = E, M.next = E) : (E.prev = E, E.next = E); return E } function B(E) { E.next.prev = E.prev; E.prev.next = E.next; E.prevZ && (E.prevZ.nextZ = E.nextZ); E.nextZ && (E.nextZ.prevZ = E.prevZ) } function C(E, H, J) {
            this.i = E; this.x = H; this.y = J; this.nextZ = this.prevZ = this.z = this.next = this.prev =
              null; this.steiner = !1
            } function D(E, H, J, M) { for (var F = 0, K = J - M; H < J; H += M)F += (E[K] - E[H]) * (E[H + 1] + E[K + 1]), K = H; return F } q.deviation = function (E, H, J, M) { var F = H && H.length, K = Math.abs(D(E, 0, F ? H[0] * J : E.length, J)); if (F) { F = 0; for (var P = H.length; F < P; F++)K -= Math.abs(D(E, H[F] * J, F < P - 1 ? H[F + 1] * J : E.length, J)) } for (F = H = 0; F < M.length; F += 3) { P = M[F] * J; var L = M[F + 1] * J, N = M[F + 2] * J; H += Math.abs((E[P] - E[N]) * (E[L + 1] - E[P + 1]) - (E[P] - E[L]) * (E[N + 1] - E[P + 1])) } return 0 === K && 0 === H ? 0 : Math.abs((H - K) / K) }; q.flatten = function (E) {
              for (var H = E[0][0].length,
                J = { vertices: [], holes: [], dimensions: H }, M = 0, F = 0; F < E.length; F++) { for (var K = 0; K < E[F].length; K++)for (var P = 0; P < H; P++)J.vertices.push(E[F][K][P]); 0 < F && (M += E[F - 1].length, J.holes.push(M)) } return J
            }; return q
          })
        })(w); a.earcut = w.exports
      })
    }, "esri/chunks/vec32": function () {
      define(["exports", "../geometry/support/buffer/math/common"], function (a, w) {
        function c(l, h, b) {
          if (l.count !== h.count) w.logger.error("source and destination buffers need to have the same number of elements"); else {
            var d = l.count, f = b[0], t = b[1], v = b[2],
            m = b[4], e = b[5], g = b[6], x = b[8], k = b[9], r = b[10], A = b[12], z = b[13]; b = b[14]; var B = l.typedBuffer; l = l.typedBufferStride; var C = h.typedBuffer; h = h.typedBufferStride; for (let E = 0; E < d; E++) { const H = E * l; var D = E * h; const J = C[D], M = C[D + 1]; D = C[D + 2]; B[H] = f * J + m * M + x * D + A; B[H + 1] = t * J + e * M + k * D + z; B[H + 2] = v * J + g * M + r * D + b }
          }
        } function q(l, h, b) {
          if (l.count !== h.count) w.logger.error("source and destination buffers need to have the same number of elements"); else {
            var d = l.count, f = b[0], t = b[1], v = b[2], m = b[3], e = b[4], g = b[5], x = b[6], k = b[7]; b = b[8]; var r =
              l.typedBuffer; l = l.typedBufferStride; var A = h.typedBuffer; h = h.typedBufferStride; for (let B = 0; B < d; B++) { const C = B * l; var z = B * h; const D = A[z], E = A[z + 1]; z = A[z + 2]; r[C] = f * D + m * E + x * z; r[C + 1] = t * D + e * E + k * z; r[C + 2] = v * D + g * E + b * z }
          }
        } function u(l, h, b) { const d = Math.min(l.count, h.count), f = l.typedBuffer; l = l.typedBufferStride; const t = h.typedBuffer; h = h.typedBufferStride; for (let v = 0; v < d; v++) { const m = v * l, e = v * h; f[m] = b * t[e]; f[m + 1] = b * t[e + 1]; f[m + 2] = b * t[e + 2] } } function y(l, h) {
          const b = Math.min(l.count, h.count), d = l.typedBuffer; l = l.typedBufferStride;
          const f = h.typedBuffer; h = h.typedBufferStride; for (let m = 0; m < b; m++) { const e = m * l; var t = m * h; const g = f[t], x = f[t + 1]; t = f[t + 2]; var v = Math.sqrt(g * g + x * x + t * t); 0 < v && (v = 1 / v, d[e] = v * g, d[e + 1] = v * x, d[e + 2] = v * t) }
        } function n(l, h, b) { const d = Math.min(l.count, h.count), f = l.typedBuffer; l = l.typedBufferStride; const t = h.typedBuffer; h = h.typedBufferStride; for (let v = 0; v < d; v++) { const m = v * l, e = v * h; f[m] = t[e] >> b; f[m + 1] = t[e + 1] >> b; f[m + 2] = t[e + 2] >> b } } const p = Object.freeze({
          __proto__: null, transformMat4: c, transformMat3: q, scale: u, normalize: y,
          shiftRight: n
        }); a.normalize = y; a.scale = u; a.shiftRight = n; a.transformMat3 = q; a.transformMat4 = c; a.vec3 = p
      })
    }, "esri/geometry/support/buffer/math/common": function () { define(["exports", "../../../../core/Logger"], function (a, w) { w = w.getLogger("esri.views.3d.support.buffer.math"); a.logger = w; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/renderers/support/renderingInfoUtils": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../Color", "../../core/maybe", "../visualVariables/support/visualVariableUtils"],
        function (a, w, c, q, u) {
          function y(h, b) { if (!h || h.symbol) return null; b = b && b.renderer; return h && q.isSome(b) && b.getObservationRenderer ? b.getObservationRenderer(h) : b } function n(h, b) { return p.apply(this, arguments) } function p() { p = w._asyncToGenerator(function* (h, b) { if (q.isSome(h.symbol)) return h.symbol; const d = y(h, b); return q.isSome(d) && d.getSymbolAsync(h, { ...b, abortOptions: { signal: b.signal } }) }); return p.apply(this, arguments) } function l() {
            l = w._asyncToGenerator(function* (h, b) {
              var d = y(h, b), f = yield n(h, b); if (!f) return null;
              f = { renderer: d, symbol: f }; if (!(d && "visualVariables" in d && d.visualVariables)) return f; b = u.getVisualVariableValues(d, h, b); h = ["proportional", "proportional", "proportional"]; for (const { variable: t, value: v } of b) "color" === t.type ? f.color = c.toUnitRGBA(v) : "size" === t.type ? "outline" === t.target ? f.outlineSize = v : (b = t.axis, d = t.useSymbolValue ? "symbol-value" : v, "width" === b ? h[0] = d : "depth" === b ? h[1] = d : "height" === b ? h[2] = d : h[0] = "width-and-depth" === b ? h[1] = d : h[1] = h[2] = d) : "opacity" === t.type ? f.opacity = v : "rotation" === t.type && "tilt" ===
                t.axis ? f.tilt = v : "rotation" === t.type && "roll" === t.axis ? f.roll = v : "rotation" === t.type && (f.heading = v); if (isFinite(h[0]) || isFinite(h[1]) || isFinite(h[2])) f.size = h; return f
            }); return l.apply(this, arguments)
          } a.getDriverAxisSizeValue = function (h, b = 0) { h = h[b]; return "number" === typeof h && isFinite(h) ? h : null }; a.getDriverAxisSizeValueAny = function (h) { for (let b = 0; 3 > b; b++) { const d = h[b]; if ("number" === typeof d) return isFinite(d) ? d : 0 } return 0 }; a.getRenderer = y; a.getRenderingInfo = function (h, b) {
            const d = y(h, b); if (q.isSome(h.symbol)) var f =
              h.symbol; else f = y(h, b), f = q.isSome(f) && "dot-density" !== f.type ? f.getSymbol(h, b) : null; if (q.isNone(f)) return null; f = { renderer: d, symbol: f }; if (q.isNone(d) || !("visualVariables" in d) || !d.visualVariables) return f; b = u.getVisualVariableValues(d, h, b); h = ["proportional", "proportional", "proportional"]; for (const { variable: t, value: v } of b) switch (t.type) {
                case "color": f.color = v.toRgba(); break; case "size": if ("outline" === t.target) f.outlineSize = v; else switch (b = t.useSymbolValue ? "symbol-value" : v, t.axis) {
                  case "width": h[0] =
                    b; break; case "depth": h[1] = b; break; case "height": h[2] = b; break; case "width-and-depth": h[0] = h[1] = b; break; default: h[0] = h[1] = h[2] = b
                }break; case "opacity": f.opacity = v; break; case "rotation": switch (t.axis) { case "tilt": f.tilt = v; break; case "roll": f.roll = v; break; default: f.heading = v }
              }if ("proportional" !== h[0] || "proportional" !== h[1] || "proportional" !== h[2]) f.size = h; return f
          }; a.getRenderingInfoAsync = function (h, b) { return l.apply(this, arguments) }; a.getSymbolAsync = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/layers/graphics/polygonUtils": function () {
      define("exports ../../../../geometry ../../../../core/maybe ../../../../geometry/projection ../../../../geometry/support/triangulationUtils ./elevationAlignmentUtils ../../terrain/OverlayRenderer ../../webgl-engine/lib/Geometry ../../../../geometry/Extent ../../../../geometry/Polygon".split(" "), function (a, w, c, q, u, y, n, p, l, h) {
        function b(f, t, v) {
          const m = []; for (const { index: e, count: g } of f) {
            if (1 >= g) continue; f = 3 * e; const x = f + 3 * g; m.push({
              index: e, count: g,
              position: t.subarray(f, x), mapPosition: v ? v.subarray(f, x) : void 0
            })
          } return m
        } function d(f, t, v) { const m = []; for (const { index: e, count: g, holeIndices: x, pathLengths: k } of f) { if (1 >= g) continue; f = 3 * e; const r = f + 3 * g, A = x.map(z => z - e); m.push({ index: e, count: g, holeIndices: A, pathLengths: k, position: t.subarray(f, r), mapPosition: v ? v.subarray(f, r) : void 0 }) } return m } a.createColorGeometry = function (f) {
          const t = [["position", f.indices]], v = [["position", { size: 3, data: f.attributeData.position, exclusive: !0 }]]; c.isSome(f.attributeData.color) &&
            (v.push(["color", { size: 4, data: f.attributeData.color, exclusive: !0 }]), t.push(["color", new Uint32Array(f.indices.length)])); c.isSome(f.attributeData.uvMapSpace) && (v.push(["uvMapSpace", { size: 4, data: f.attributeData.uvMapSpace, exclusive: !0 }]), t.push(["uvMapSpace", f.indices])); c.isSome(f.attributeData.boundingRect) && (v.push(["boundingRect", { size: 9, data: f.attributeData.boundingRect, exclusive: !0 }]), t.push(["boundingRect", f.indices])); c.isSome(f.attributeData.mapPosition) && (v.push(["mapPos", {
              size: 3, data: f.attributeData.mapPosition,
              exclusive: !0
            }]), t.push(["mapPos", f.indices])); return new p.Geometry(v, t)
        }; a.createWaterGeometry = function (f) { const t = [["position", f.indices], ["uv0", f.indices]], v = [["position", { size: 3, data: f.attributeData.position, exclusive: !0 }], ["uv0", { size: 2, data: f.attributeData.uv0, exclusive: !0 }]]; c.isSome(f.attributeData.mapPosition) && (v.push(["mapPos", { size: 3, data: f.attributeData.mapPosition, exclusive: !0 }]), t.push(["mapPos", f.indices])); return new p.Geometry(v, t) }; a.geometryAsPolygon = function (f) {
          switch (f.type) {
            case "extent": if (f instanceof
              l) return h.fromExtent(f); break; case "polygon": return f
          }return null
        }; a.geometryToRenderInfo = function (f, t, v, m) { const e = u.pathsToTriangulationInfo(f.rings, f.hasZ, 1), g = new Float64Array(e.position.length); f = y.applyPerVertexElevationAlignment(e.position, f.spatialReference, 0, g, 0, e.position, 0, e.position.length / 3, t, v, m); t = null != f; return { position: e.position, mapPosition: g, polygons: d(e.polygons, e.position, g), outlines: b(e.outlines, e.position, g), projectionSuccess: t, sampledElevation: f } }; a.geometryToRenderInfoDraped =
          function (f, t) { const v = u.pathsToTriangulationInfo(f.rings, !1, 1); f = q.projectBuffer(v.position, f.spatialReference, 0, v.position, t, 0, v.position.length / 3); for (t = 2; t < v.position.length; t += 3)v.position[t] = n.DRAPED_Z; return { position: v.position, polygons: d(v.polygons, v.position), outlines: b(v.outlines, v.position), projectionSuccess: f } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/triangulationUtils": function () {
      define(["exports", "../../chunks/earcut", "./coordsUtils", "./meshUtils/deduplicate"],
        function (a, w, c, q) {
          function u(p, l, h) { if (1 === p.length) return p[0]; l = new Float64Array(l); h = new Uint32Array(h); let b = 0, d = 0, f = 0; for (const t of p) { for (p = 0; p < t.position.length; p++)l[b++] = t.position[p]; for (p = 0; p < t.faces.length; p++)h[d++] = t.faces[p] + f; f = b / 3 } return { position: l, faces: h } } function y(p, l, h) {
            const b = p.length, d = Array(b), f = Array(b), t = Array(b); let v = 0, m = 0, e = 0; var g = 0; for (var x = 0; x < b; ++x)g += p[x].length; g = new Float64Array(3 * g); x = 0; for (let z = b - 1; 0 <= z; z--) {
              var k = p[z], r = 1 === h ? !c.isClockwise(k, !1, !1) : !1;
              if (r && 1 !== b) d[v++] = k; else { var A = k.length; for (let B = 0; B < v; ++B)A += d[B].length; A = { index: x, pathLengths: Array(v + 1), count: A, holeIndices: Array(v) }; A.pathLengths[0] = k.length; 0 < k.length && (t[e++] = { index: x, count: k.length }); x = r ? n(k, k.length - 1, -1, g, x, k.length, l) : n(k, 0, 1, g, x, k.length, l); for (k = 0; k < v; ++k)r = d[k], A.holeIndices[k] = x, A.pathLengths[k + 1] = r.length, 0 < r.length && (t[e++] = { index: x, count: r.length }), x = n(r, 0, 1, g, x, r.length, l); v = 0; 0 < A.count && (f[m++] = A) }
            } for (p = 0; p < v; ++p)h = d[p], 0 < h.length && (t[e++] = { index: x, count: h.length }),
              x = n(h, 0, 1, g, x, h.length, l); m < b && (f.length = m); e < b && (t.length = e); return { position: g, polygons: f, outlines: t }
          } function n(p, l, h, b, d, f, t) { d *= 3; for (let v = 0; v < f; ++v) { const m = p[l]; b[d++] = m[0]; b[d++] = m[1]; b[d++] = t ? m[2] : 0; l += h } return d / 3 } a.pathsToTriangulationInfo = y; a.triangulate = function (p) {
            p = y(p.rings, p.hasZ, 1); const l = []; let h = 0, b = 0; for (var d of p.polygons) {
              const t = d.index, v = new Float64Array(p.position.buffer, 3 * t * p.position.BYTES_PER_ELEMENT, 3 * d.count); var f = d.holeIndices.map(m => m - t); f = new Uint32Array(w.earcut(v,
                f, 3)); l.push({ position: v, faces: f }); h += v.length; b += f.length
            } d = u(l, h, b); p = q.deduplicate(d.position.buffer, 6, { originalIndices: d.faces }); d.position = new Float64Array(p.buffer); d.faces = p.indices; return d
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/support/meshUtils/deduplicate": function () {
      define(["exports", "../../../core/mathUtils"], function (a, w) {
        function c(u, y, n) {
          var p, l = u.byteLength / (4 * y), h = new Uint32Array(u, 0, l * y); u = new Uint32Array(l); var b = null != (p = null == n ? void 0 : n.minReduction) ?
            p : 0; const d = (p = (null == n ? void 0 : n.originalIndices) || null) ? p.length : 0; var f = (null == n ? void 0 : n.componentOffsets) || null; n = 0; if (f) for (var t = 0; t < f.length - 1; t++) { var v = f[t + 1] - f[t]; v > n && (n = v) } else n = l; var m = Math.floor(1.1 * n) + 1; if (null == q || q.length < 2 * m) q = new Uint32Array(w.nextHighestPowerOfTwo(2 * m)); for (n = 0; n < 2 * m; n++)q[n] = 0; n = 0; v = (t = !!f && !!p) ? d : l; var e = t ? new Uint32Array(d) : null, g = 0 !== b ? Math.ceil(7.84 * 1.96 / (b * b) * b * (1 - b)) : v, x = 1, k = f ? f[1] : v; for (var r = 0; r < v; r++) {
              if (r === g) {
                var A = 1 - n / r; if (A + 1.96 * Math.sqrt(A * (1 - A) /
                  r) < b) return null; g *= 2
              } if (r === k) { for (k = 0; k < 2 * m; k++)q[k] = 0; if (p) for (k = f[x - 1]; k < f[x]; k++)e[k] = u[p[k]]; k = f[++x] } A = t ? p[r] : r; const D = A * y; var z = 0; for (var B = 0; B < y; B++)z = h[D + B] + z | 0, z = z + (z << 11) + (z >>> 2) | 0; z >>>= 0; B = z % m; let E = n; for (; 0 !== q[2 * B + 1];) { if (q[2 * B] === z) { const H = q[2 * B + 1] - 1; var C = H * y; a: { for (let J = 0; J < y; J++)if (h[D + J] !== h[C + J]) { C = !1; break a } C = !0 } if (C) { E = u[H]; break } } B++; B >= m && (B -= m) } E === n && (q[2 * B] = z, q[2 * B + 1] = A + 1, n++); u[A] = E
            } if (0 !== b && 1 - n / l < b) return null; if (t) { for (l = f[x - 1]; l < e.length; l++)e[l] = u[p[l]]; u = e } l =
              new Uint32Array(y * n); n = 0; for (x = 0; x < v; x++)if (u[x] === n) { b = h; f = (t ? p[x] : x) * y; m = l; e = n * y; g = y; for (r = 0; r < g; r++)m[e + r] = b[f + r]; n++ } if (p && !t) { y = new Uint32Array(d); for (h = 0; h < y.length; h++)y[h] = u[p[h]]; u = y } return { buffer: l.buffer, indices: u, uniqueCount: n }
        } let q = null; a.deduplicate = c; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/OverlayRenderer": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Evented ../../../core/Handles ../../../core/Logger ../../../core/MapUtils ../../../core/maybe ../../../core/PooledArray ../../../core/SetUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/mat4 ../../../chunks/vec2f64 ../../../chunks/vec3f64 ../../../chunks/mat4f64 ../support/debugFlags ./Overlay ./OverlayFramebufferObject ./OverlayRenderTarget ../webgl-engine/core/shaderTechnique/ShaderTechniqueRepository ../webgl-engine/lib/AutoDisposable ../webgl-engine/lib/Camera ../webgl-engine/lib/GLMaterialRepository ../webgl-engine/lib/glUtil3D ../webgl-engine/lib/GridLocalOriginFactory ../webgl-engine/lib/Intersector ../webgl-engine/lib/RenderContext ../webgl-engine/lib/SortedRenderGeometryRenderer ../webgl-engine/lib/TextureTechnique ../webgl-engine/lighting/Lightsources ../webgl-engine/lighting/SceneLighting ../webgl-engine/materials/StippleTextureRepository ../../support/Scheduler ../../webgl/Texture ../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q) {
          function T(ba, aa, W, U, X, Z, ia) {
            const la = { layerUid: Z, graphicUid: ia, triangleNr: aa }; aa = ma => { ma.set(3, la, ba.dist, ba.normal, ba.transformation, W, U) }; (null == X.results.min.drapedLayerOrder || W >= X.results.min.drapedLayerOrder) && (null == X.results.min.dist || X.results.ground.dist <= X.results.min.dist) && aa(X.results.min); 0 !== X.options.store && (null == X.results.max.drapedLayerOrder || W < X.results.max.drapedLayerOrder) && (null == X.results.max.dist ||
              X.results.ground.dist > X.results.max.dist) && aa(X.results.max); 2 === X.options.store && (Z = K.newIntersectorResult(X.ray), aa(Z), X.results.all.push(Z))
          } const da = n.getLogger("esri.views.3d.webgl-engine.lib.OverlayRenderer"); a.OverlayRenderer = function (ba) {
            function aa(U) {
              U = ba.call(this, U) || this; U._overlays = null; U._overlayRenderTarget = null; U._hasHighlights = !1; U._rendersOccluded = !1; U._hasWater = !1; U._lighting = new I.SceneLighting; U._handles = new y; U._frameTask = R.ImmediateTask; U._layerRenderers = new Map; U._sortedLayerRenderersDirty =
                !1; U._sortedLayerRenderers = new h; U._geometries = new Map; U.worldToPCSRatio = 1; U.events = new u; U.longitudeCyclical = null; return U
            } w._inheritsLoose(aa, ba); var W = aa.prototype; W.initialize = function () {
              const U = this.view._stage.renderView; this._rctx = U.renderingContext; this._renderContext = new P.OverlayRenderContext(this._rctx); const X = U.waterTextureRepository; this._stippleTextureRepository = new O.StippleTextureRepository(U.renderingContext); this._shaderTechniqueRepository = new D.ShaderTechniqueRepository({
                rctx: this._rctx,
                viewingMode: 2, stippleTextureRepository: this._stippleTextureRepository, waterTextureRepository: X
              }); this._handles.add([d.init(X, "loadingState", () => this.events.emit("content-changed")), d.init(this, "spatialReference", Z => this._localOrigins = new F.GridLocalOriginFactory(Z))]); this._materialRepository = new J.GLMaterialRepository(U.textureRepository, this._shaderTechniqueRepository, Z => { 0 < (Z.renderOccluded & 4) !== this._rendersOccluded && this.updateRendersOccluded(); this.events.emit("content-changed"); this.notifyChange("updating") },
                () => this.events.emit("content-changed")); this._lighting.groundLightingFactor = 1; this._lighting.globalFactor = 0; this._lighting.set([new G.AmbientLight(k.fromValues(1, 1, 1))]); this._bindParameters = {
                  slot: 20, highlightDepthTexture: M.createEmptyDepthTexture(this._rctx), camera: ha, inverseViewport: x.create(), origin: null, screenToWorldRatio: null, screenToPCSRatio: null, shadowMappingEnabled: !1, slicePlane: null, ssaoEnabled: !1, hasOccludees: !1, linearDepthTexture: null, lastFrameColorTexture: null, reprojectionMatrix: r.IDENTITY,
                  ssrEnabled: !1, lighting: this._lighting, transparencyPassType: 3, terrainLinearDepthTexture: null, geometryLinearDepthTexture: null, multipassTerrainEnabled: !1, cullAboveGround: !1, multipassGeometryEnabled: !1, highlightColorTexture: null
                }; this._frameTask = this.view.resourceController.scheduler.registerTask(R.TaskPriority.STAGE, this); this._handles.add(this._frameTask)
            }; W.dispose = function () {
              this._handles.destroy(); this._layerRenderers.forEach(U => U.dispose()); this._layerRenderers.clear(); this._debugTextureTechnique =
                l.releaseMaybe(this._debugTextureTechnique); this._debugPatternTexture = l.disposeMaybe(this._debugPatternTexture); this._bindParameters.highlightDepthTexture = l.disposeMaybe(this._bindParameters.highlightDepthTexture); this._shaderTechniqueRepository = l.disposeMaybe(this._shaderTechniqueRepository); this._temporaryFBO = l.disposeMaybe(this._temporaryFBO); this._quadVAO = l.disposeMaybe(this._quadVAO); this.disposeOverlays()
            }; W.collectUnusedRenderTargetMemory = function (U) {
              let X = !1; if (l.isSome(this._overlayRenderTarget)) for (const Z of this._overlayRenderTarget.renderTargets) X =
                this._overlayRenderTarget.validateUsageForTarget(this.overlays[0].validTargets[Z.type] || !this.overlays[1].validTargets[Z.type], Z, U) || X; return X
            }; W.ensureDrapeTargets = function (U) { l.isSome(this._overlays) && this._overlays.forEach(X => { X.hasTargetWithoutRasterImage = b.someSet(U, Z => 1 === Z.drapeTargetType) }) }; W.ensureDrapeSources = function (U) {
              l.isSome(this._overlays) && this._overlays.forEach(X => {
              X.hasDrapedFeatureSource = p.someMap(U, (Z, ia) => 1 === ia.drapeSourceType); X.hasDrapedRasterSource = p.someMap(U, (Z, ia) =>
                0 === ia.drapeSourceType)
              })
            }; W.ensureOverlays = function (U, X) { l.isNone(this._overlays) && (this._overlayRenderTarget = new C.OverlayRenderTarget(this._rctx), this._overlays = [new z.Overlay(0, this._overlayRenderTarget), new z.Overlay(1, this._overlayRenderTarget)]); this.ensureDrapeTargets(U); this.ensureDrapeSources(X) }; W.disposeOverlays = function () { this._overlays = null; this._overlayRenderTarget = l.disposeMaybe(this._overlayRenderTarget); this.events.emit("textures-disposed") }; W.runTask = function (U, X = () => !0) {
              this._frameTask.processQueue(U);
              U.done || this._processLayers(U, X)
            }; W._processLayers = function (U, X) {
              let Z = !1; for (const [ia, la] of this._layerRenderers) { if (U.done) break; if (ia.destroyed || X(ia)) la.commitChanges() && (Z = !0, U.madeProgress()), la.isEmpty && (this._sortedLayerRenderersDirty = Z = !0, this._layerRenderers.delete(ia), this._handles.remove(ia)) } this.updateSortedLayerRenderers(); Z && (l.isSome(this._overlays) && 0 === this._layerRenderers.size && this.disposeOverlays(), this.notifyChange("updating"), this.events.emit("content-changed"), this.updateHasHighlights(),
                this.updateRendersOccluded(), this.updateHasWater())
            }; W.processSyncLayers = function () { this._processLayers(R.noBudget, U => 1 === U.updatePolicy) }; W.addGeometries = function (U, X, Z) { for (const ia of U) l.isNone(ia.origin) && (ia.origin = this._localOrigins.getOrigin(ia.boundingSphere)), this._geometries.set(ia.id, ia); this.ensureLayerRenderer(X).add(U); 2 === Z && this.notifyGraphicGeometryChanged(U, X) }; W.removeGeometries = function (U, X, Z) {
              for (var ia of U) this._geometries.delete(l.unwrap(ia.id)); if (ia = this._layerRenderers.get(X)) ia.remove(U),
                2 === Z && this.notifyGraphicGeometryChanged(U, X)
            }; W.updateGeometries = function (U, X, Z) { const ia = this._layerRenderers.get(X); if (ia) switch (ia.modify(U, Z), Z) { case 4: case 2: return this.notifyGraphicGeometryChanged(U, X); case 1: return this.notifyGraphicVisibilityChanged(U, X) } else da.warn("Attempted to update geometry for nonexistent layer") }; W.notifyGraphicGeometryChanged = function (U, X) {
              if (!l.isNone(X.notifyGraphicGeometryChanged)) for (const ia of U) if (U = ia.graphicUid, l.isSome(U) && U !== Z) {
                X.notifyGraphicGeometryChanged(U);
                var Z = U
              }
            }; W.notifyGraphicVisibilityChanged = function (U, X) { if (!l.isNone(X.notifyGraphicVisibilityChanged)) for (const ia of U) if (U = ia.graphicUid, l.isSome(U) && U !== Z) { X.notifyGraphicVisibilityChanged(U); var Z = U } }; W.updateHighlights = function (U, X) { (X = this._layerRenderers.get(X)) ? X.modify(U, 8) : da.warn("Attempted to update highlights for nonexistent layer") }; W.isEmpty = function () { return 0 === this._geometries.size && !A.OVERLAY_DRAW_DEBUG_TEXTURE }; W.updateLogic = function (U) {
              let X = !1; this._layerRenderers.forEach(Z =>
                X = Z.updateLogic(U) || X); return X
            }; W.updateLayerOrder = function () { this._sortedLayerRenderersDirty = !0 }; W.drawTarget = function (U, X, Z) {
              const ia = U.canvasGeometries; if (0 === ia.numViews) return !1; this._screenToWorldRatio = Z * U.mapUnitsPerPixel; const la = X.renderPass; if (this.isEmpty() || 5 === la && !this.hasHighlights || 3 === la && !this.hasWater || !U.hasSomeSizedView()) return !1; const ma = X.fbo; if (!ma.isValid()) return !1; const ra = 2 * U.resolution, Aa = U.resolution; ma.resize(ra, Aa); const za = this._rctx; ha.pixelRatio = U.pixelRatio * Z;
              this._renderContext.pass = la; this._bindParameters.screenToWorldRatio = this._screenToWorldRatio; this._bindParameters.screenToPCSRatio = this._screenToWorldRatio * this.worldToPCSRatio; this._bindParameters.slot = 3 === la ? 21 : 20; U.applyViewport(this._rctx); ma.bind(za); 0 === U.index && (za.setClearColor(0, 0, 0, 0), za.clearSafe(16384)); const Ka = 1 === X.type ? 2 : 4 === X.type ? 1 : 0; 1 === Ka && (this._renderContext.renderOccludedMask = 4); if (A.OVERLAY_DRAW_DEBUG_TEXTURE && 1 !== Ka) for (X = 0; X < ia.numViews; X++)this.setViewParameters(ia.extents[X],
                U, ha), this.drawDebugTexture(U.resolution, fa[U.index]); 0 < this._layerRenderers.size && this._sortedLayerRenderers.forAll(({ layerView: Ea, renderer: Ua }) => {
                  if (2 !== Ka || !l.isSome(Ea) || 0 !== Ea.drapeSourceType) {
                    var Na = l.isSome(Ea) && l.isSome(Ea.fullOpacity) && 1 > Ea.fullOpacity && 0 === la; Na && (this.bindTemporaryFramebuffer(this._rctx, ra, Aa), za.clearSafe(16384)); for (let ya = 0; ya < ia.numViews; ya++)this.setViewParameters(ia.extents[ya], U, ha), Ua.render(this._renderContext, this._bindParameters); Na && l.isSome(this._temporaryFBO) &&
                      (ma.bind(za), this.view._stage.renderView.compositingHelper.composite(this._temporaryFBO.getTexture(), 2, l.unwrap(l.unwrap(Ea).fullOpacity), 3, U.index))
                  }
                }); za.bindFramebuffer(null); ma.generateMipMap(); this._renderContext.resetRenderOccludedMask(); return !0
            }; W.bindTemporaryFramebuffer = function (U, X, Z) { l.isNone(this._temporaryFBO) && (this._temporaryFBO = new B.OverlayFramebufferObject(U, !1)); this._temporaryFBO.resize(X, Z); this._temporaryFBO.bind(U) }; W.reloadShaders = function () {
              var U = w._asyncToGenerator(function* () { yield this._shaderTechniqueRepository.reloadAll() });
              return function () { return U.apply(this, arguments) }
            }(); W.intersect = function (U, X, Z, ia) { let la = 0; this._geometries.forEach(ma => { if (!ia || ia(ma)) { this._intersectRenderGeometry(ma, Z, X, 0, U, la); var ra = this.longitudeCyclical; ra && (ma.boundingSphere[0] - ma.boundingSphere[3] < ra.min && this._intersectRenderGeometry(ma, Z, X, ra.range, U, la), ma.boundingSphere[0] + ma.boundingSphere[3] > ra.max && this._intersectRenderGeometry(ma, Z, X, -ra.range, U, la)); la++ } }) }; W._intersectRenderGeometry = function (U, X, Z, ia, la, ma) {
              if (U.instanceParameters.visible) {
                var ra =
                  0; l.isSome(U.transformation) && (ia += U.transformation[12], ra = U.transformation[13]); ka[0] = Z[0] - ia; ka[1] = Z[1] - ra; ka[2] = 1; ea[0] = Z[0] - ia; ea[1] = Z[1] - ra; ea[2] = 0; U.screenToWorldRatio = this._screenToWorldRatio; U.material.intersect(U, null, U.getShaderTransformation(), la, ka, ea, (Aa, za, Ka) => { T(X, Ka, U.material.renderPriority, ma, la, U.layerUid, U.graphicUid) }, U.calculateShaderTransformation, X)
              }
            }; W.ensureLayerRenderer = function (U) {
              let X = this._layerRenderers.get(U); X || (X = new L.SortedRenderGeometryRenderer({
                rctx: this._rctx,
                materialRepository: this._materialRepository
              }), this._layerRenderers.set(U, X), this._sortedLayerRenderersDirty = !0, "fullOpacity" in U && this._handles.add(U.watch("fullOpacity", () => this.events.emit("content-changed")), U), this._handles.add(d.init(X, "updating", () => this.notifyChange("updating")), U)); return X
            }; W.updateSortedLayerRenderers = function () {
              if (this._sortedLayerRenderersDirty && (this._sortedLayerRenderersDirty = !1, this._sortedLayerRenderers.clear(), 0 !== this._layerRenderers.size)) {
                var U = new Set(this._layerRenderers.values());
                this.view.allLayerViews.forEach(X => { const Z = this._layerRenderers.get(X); Z && (this._sortedLayerRenderers.push(new Y(X, Z)), U.delete(Z)) }); U.forEach(X => this._sortedLayerRenderers.push(new Y(null, X)))
              }
            }; W.setViewParameters = function (U, X, Z) {
            Z.viewport[0] = Z.viewport[1] = 0; Z.viewport[2] = Z.viewport[3] = X.resolution; g.ortho(Z.projectionMatrix, 0, U[2] - U[0], 0, U[3] - U[1], Z.near, Z.far); g.identity(Z.viewMatrix); g.translate(Z.viewMatrix, Z.viewMatrix, [-U[0], -U[1], 0]); this._renderContext.camera = Z; this._bindParameters.camera =
              Z; this._bindParameters.inverseViewport[0] = 1 / Z.fullViewport[2]; this._bindParameters.inverseViewport[1] = 1 / Z.fullViewport[3]
            }; W.updateHasWater = function () { const U = p.someMap(this._layerRenderers, X => X.hasWater); U !== this._hasWater && (this._hasWater = U, this.events.emit("has-water", U)) }; W.updateHasHighlights = function () { const U = p.someMap(this._layerRenderers, X => X.hasHighlights); U !== this._hasHighlights && (this._hasHighlights = U, this.events.emit("has-highlights", U)) }; W.updateRendersOccluded = function () {
              const U = p.someMap(this._layerRenderers,
                X => X.rendersOccluded); U !== this._rendersOccluded && (this._rendersOccluded = U, this.events.emit("renders-occluded", U))
            }; W.drawDebugTexture = function (U, X) { const Z = this._rctx; this.ensureDebugPatternResources(U, U); U = this._debugTextureTechnique.program; Z.useProgram(U); this._debugTextureTechnique.bindPipelineState(Z); U.setUniform4f("color", X[0], X[1], X[2], 1); U.bindTexture(this._debugPatternTexture, "tex"); Z.bindVAO(this._quadVAO); Z.drawArrays(5, 0, Q.vertexCount(this._quadVAO, "geometry")) }; W.ensureDebugPatternResources =
              function (U, X) {
                if (!this._debugPatternTexture) {
                  var Z = new Uint8Array(U * X * 4), ia = 0; for (let la = 0; la < X; la++)for (let ma = 0; ma < U; ma++) { const ra = Math.floor(ma / 10), Aa = Math.floor(la / 10); 2 > ra || 2 > Aa || 10 * ra > U - 20 || 10 * Aa > X - 20 ? (Z[ia++] = 255, Z[ia++] = 255, Z[ia++] = 255, Z[ia++] = 255) : (Z[ia++] = 255, Z[ia++] = 255, Z[ia++] = 255, ra & 1 && Aa & 1 ? Z[ia++] = ma & 1 ^ la & 1 ? 0 : 255 : Z[ia++] = ra & 1 ^ Aa & 1 ? 0 : 128) } this._debugPatternTexture = new S(this._rctx, { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: U, height: X }, Z); U = new N.TextureTechniqueConfiguration;
                  U.hasAlpha = !0; this._debugTextureTechnique = this._shaderTechniqueRepository.acquire(N.TextureTechnique, U); this._quadVAO = M.createQuadVAO(this._rctx)
                }
              }; w._createClass(aa, [{ key: "updating", get: function () { return this._sortedLayerRenderersDirty || this._frameTask.updating || p.someMap(this._layerRenderers, U => U.updating) } }, { key: "hasOverlays", get: function () { return l.isSome(this._overlays) && l.isSome(this._overlayRenderTarget) } }, {
                key: "gpuMemoryUsage", get: function () {
                  return l.isSome(this._overlayRenderTarget) ? this._overlayRenderTarget.gpuMemoryUsage :
                    0
                }
              }, { key: "overlays", get: function () { return l.unwrapOr(this._overlays, []) } }, { key: "running", get: function () { return this.updating } }, { key: "hasHighlights", get: function () { return this._hasHighlights } }, { key: "hasWater", get: function () { return this._hasWater } }, { key: "rendersOccluded", get: function () { return this._rendersOccluded } }, { key: "test", get: function () { return { layerRenderers: this._layerRenderers } } }]); return aa
          }(E.AutoDisposableMixin(q)); c.__decorate([f.property()], a.OverlayRenderer.prototype, "_frameTask", void 0);
          c.__decorate([f.property()], a.OverlayRenderer.prototype, "_sortedLayerRenderersDirty", void 0); c.__decorate([E.autoDispose()], a.OverlayRenderer.prototype, "_shaderTechniqueRepository", void 0); c.__decorate([E.autoDispose()], a.OverlayRenderer.prototype, "_stippleTextureRepository", void 0); c.__decorate([f.property({ constructOnly: !0 })], a.OverlayRenderer.prototype, "view", void 0); c.__decorate([f.property()], a.OverlayRenderer.prototype, "worldToPCSRatio", void 0); c.__decorate([f.property()], a.OverlayRenderer.prototype,
            "spatialReference", void 0); c.__decorate([f.property({ type: Boolean, readOnly: !0 })], a.OverlayRenderer.prototype, "updating", null); a.OverlayRenderer = c.__decorate([e.subclass("esri.views.3d.terrain.OverlayRenderer")], a.OverlayRenderer); let Y = function (ba, aa) { this.layerView = ba; this.renderer = aa }; const fa = [[1, .5, .5], [.5, .5, 1]], ha = new H; ha.near = 1; ha.far = 1E4; ha.relativeElevation = null; const ka = k.create(), ea = k.create(); a.DRAPED_Z = -2; a.overlayRenderOccludedFlag = 4; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/terrain/Overlay": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/mathUtils", "../../../geometry/support/aaBoundingRect", "../webgl-engine/lib/localOrigin"], function (a, w, c, q, u) {
        let y = function () {
          function n(l, h) {
          this.index = l; this.renderTargets = h; this.extent = q.create(); this.resolution = 0; this.renderLocalOrigin = u.fromValues(0, 0, 0, "O"); this.mapUnitsPerPixel = this.pixelRatio = 1; this.canvasGeometries = { extents: [q.create(), q.create(), q.create()], numViews: 0 };
            this.validTargets = null; this.hasTargetWithoutRasterImage = this.hasDrapedRasterSource = this.hasDrapedFeatureSource = !1; this.index = l; this.validTargets = Array(h.renderTargets.length).fill(!1)
          } var p = n.prototype; p.getValidTarget = function (l) { return this.validTargets[l] ? this.renderTargets.getTarget(l) : null }; p.getColorTexture = function (l) { return (l = 1 === l ? this.renderTargets.getTarget(0) : 2 === l ? this.renderTargets.getTarget(2) : this.renderTargets.getTarget(4)) ? l.getTexture() : null }; p.getNormalTexture = function (l) {
            return (l =
              1 === l ? this.renderTargets.getTarget(3) : null) ? l.getTexture() : null
          }; p.draw = function (l, h) { const b = this.computeRenderTargetValidityBitfield(), d = this.needsColorWithoutRasterImage; for (const f of this.renderTargets.renderTargets) this.validTargets[f.type] = 1 === f.type && !1 === d ? !1 : l.drawTarget(this, f, h); l = this.computeRenderTargetValidityBitfield(); return b ^ l ? 0 : 1 }; p.computeRenderTargetValidityBitfield = function () { const l = this.validTargets; return +l[0] | +l[1] << 1 | +l[2] << 2 | +l[3] << 3 | +l[4] << 4 }; p.setupGeometryViewsCyclical =
            function (l) { this.setupGeometryViewsDirect(); var h = .001 * l.range; if (this.extent[0] - h <= l.min) { const b = this.canvasGeometries.extents[this.canvasGeometries.numViews++]; q.offset(this.extent, l.range, 0, b) } this.extent[2] + h >= l.max && (h = this.canvasGeometries.extents[this.canvasGeometries.numViews++], q.offset(this.extent, -l.range, 0, h)) }; p.setupGeometryViewsDirect = function () { this.canvasGeometries.numViews = 1; q.copy(this.canvasGeometries.extents[0], this.extent) }; p.hasSomeSizedView = function () {
              for (let l = 0; l < this.canvasGeometries.numViews; l++) {
                const h =
                  this.canvasGeometries.extents[l]; if (h[0] !== h[2] && h[1] !== h[3]) return !0
              } return !1
            }; p.applyViewport = function (l) { l.setViewport(0 === this.index ? 0 : this.resolution, 0, this.resolution, this.resolution) }; w._createClass(n, [{ key: "needsColorWithoutRasterImage", get: function () { return this.hasDrapedRasterSource && this.hasDrapedFeatureSource && this.hasTargetWithoutRasterImage } }]); return n
        }(); a.Overlay = y; a.computeOverlayResolution = function (n, p, l) { return Math.min(c.nextHighestPowerOfTwo(Math.max(n, p) + 256), l) }; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/localOrigin": function () { define(["exports", "../../../../chunks/vec3f64"], function (a, w) { let c = function (q, u) { this.vec3 = q; this.id = u }; a.LocalOrigin = c; a.fromValues = function (q, u, y, n) { return new c(w.fromValues(q, u, y), n) }; a.fromVector = function (q, u) { return new c(w.clone(q), u) }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/terrain/OverlayFramebufferObject": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../chunks/vec2f32 ../../webgl/BufferObject ../../webgl/FramebufferObject ../../../core/has ../../webgl/checkWebGLError ../../webgl/enums ../../../chunks/builtins ../../webgl/Texture ../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          u = function () {
            function f(v, m) { this.size = q.create(); this._fbo = null; this._fbo = new y(v, { colorTarget: 0, depthStencilTarget: 0 }, { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9987, hasMipmap: m, maxAnisotropy: 8, width: 0, height: 0 }) } var t = f.prototype; t.dispose = function () { this._fbo = c.disposeMaybe(this._fbo) }; t.getTexture = function () { return this._fbo ? this._fbo.colorTexture : null }; t.isValid = function () { return null !== this._fbo }; t.resize = function (v, m) {
            this.size[0] =
              v; this.size[1] = m; this._fbo.resize(this.size[0], this.size[1])
            }; t.bind = function (v) { v.bindFramebuffer(this._fbo) }; t.generateMipMap = function () { this._fbo.colorTexture.descriptor.hasMipmap && this._fbo.colorTexture.generateMipmap() }; t.disposeRenderTargetMemory = function () { var v; null == (v = this._fbo) ? void 0 : v.resize(0, 0) }; w._createClass(f, [{ key: "gpuMemoryUsage", get: function () { var v, m; return null != (v = null == (m = this._fbo) ? void 0 : m.gpuMemoryUsage) ? v : 0 } }]); return f
          }(); a.OverlayFramebufferObject = u; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/OverlayRenderTarget": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "./OverlayFramebufferObject"], function (a, w, c) {
        let q = function () {
          function u(n) { const p = (l, h, b = !0) => ({ type: h, fbo: new c.OverlayFramebufferObject(n, b), renderPass: l, valid: !1, lastUsed: Infinity }); this.renderTargets = [p(0, 0), p(0, 1), p(5, 2, !1), p(3, 3), p(0, 4)] } var y = u.prototype; y.getTarget = function (n) { return this.renderTargets[n].fbo }; y.dispose = function () { for (const n of this.renderTargets) n.fbo.dispose() };
          y.disposeRenderTargetMemory = function () { for (const n of this.renderTargets) n.fbo.disposeRenderTargetMemory() }; y.validateUsageForTarget = function (n, p, l) { if (n) p.lastUsed = l; else if (1E3 < l - p.lastUsed) p.fbo.disposeRenderTargetMemory(), p.lastUsed = Infinity; else if (Infinity > p.lastUsed) return !0; return !1 }; w._createClass(u, [{ key: "gpuMemoryUsage", get: function () { return this.renderTargets.reduce((n, p) => n + p.fbo.gpuMemoryUsage, 0) } }]); return u
        }(); a.OverlayRenderTarget = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    },
    "esri/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueRepository": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../core/maybe", "../../../../../core/NestedMap"], function (a, w, c, q) {
        let u = function (n) { this.technique = n; this.refZeroFrame = this.refCount = 0 }, y = function () {
          function n(l) { this._context = l; this._perConstructorInstances = new q.NestedMap; this._frameCounter = 0; this._keepAliveFrameCount = -1 } var p = n.prototype; p.dispose = function () {
            this._perConstructorInstances.forEach(l =>
              l.forEach(h => h.technique.dispose())); this._perConstructorInstances.clear()
          }; p.acquire = function (l, h) { const b = h.key; let d = this._perConstructorInstances.get(l, b); if (c.isNone(d)) { const f = new l(this._context, h, () => this.release(f)); d = new u(f); this._perConstructorInstances.set(l, b, d) } ++d.refCount; return d.technique }; p.releaseAndAcquire = function (l, h, b) { if (c.isSome(b)) { if (h.key === b.key) return b; b.release() } return this.acquire(l, h) }; p.release = function (l) {
            c.isNone(l) || this._perConstructorInstances.empty || (l =
              this._perConstructorInstances.get(l.constructor, l.key), c.isNone(l) || (--l.refCount, 0 === l.refCount && (l.refZeroFrame = this._frameCounter)))
          }; p.frameUpdate = function () { this._frameCounter++; -1 !== this._keepAliveFrameCount && this._perConstructorInstances.forEach((l, h) => { l.forEach((b, d) => { 0 === b.refCount && b.refZeroFrame + this._keepAliveFrameCount < this._frameCounter && (b.technique.dispose(), this._perConstructorInstances.delete(h, d)) }) }) }; p.reloadAll = function () {
            var l = w._asyncToGenerator(function* () {
              var h = this; const b =
                []; this._perConstructorInstances.forEach((d, f) => { const t = function () { var v = w._asyncToGenerator(function* (m, e) { if (e = e.shader) yield e.reload(), m.forEach(g => { g.technique.reload(h._context) }) }); return function (m, e) { return v.apply(this, arguments) } }(); b.push(t(d, f)) }); yield Promise.all(b)
            }); return function () { return l.apply(this, arguments) }
          }(); w._createClass(n, [{ key: "viewingMode", get: function () { return this._context.viewingMode } }, { key: "constructionContext", get: function () { return this._context } }]); return n
        }();
        a.ShaderTechniqueRepository = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/NestedMap": function () {
      define(["exports", "../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q() { this._outer = new Map } var u = q.prototype; u.clear = function () { this._outer.clear() }; u.get = function (y, n) { var p; return null == (p = this._outer.get(y)) ? void 0 : p.get(n) }; u.set = function (y, n, p) { const l = this._outer.get(y); l ? l.set(n, p) : this._outer.set(y, new Map([[n, p]])) }; u.delete = function (y, n) {
            const p =
              this._outer.get(y); p && (p.delete(n), 0 === p.size && this._outer.delete(y))
          }; u.forEach = function (y) { this._outer.forEach((n, p) => y(n, p)) }; w._createClass(q, [{ key: "empty", get: function () { return 0 === this._outer.size } }]); return q
        }(); a.NestedMap = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/AutoDisposable": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        const c = u => function (y) {
          function n() {
            var p = y.apply(this, arguments) || this; p._isDisposed =
              !1; return p
          } w._inheritsLoose(n, y); n.prototype.dispose = function () { for (const l of null != (p = this._managedDisposables) ? p : []) { var p; p = this[l]; this[l] = null; p && "function" === typeof p.dispose && p.dispose() } this._isDisposed = !0 }; w._createClass(n, [{ key: "isDisposed", get: function () { return this._isDisposed } }]); return n
        }(u); let q = function (u) { function y() { return u.apply(this, arguments) || this } w._inheritsLoose(y, u); return y }(c(function () { return function () { } }())); a.AutoDisposable = q; a.AutoDisposableMixin = c; a.autoDispose =
          function () { return (u, y) => { if (!u.hasOwnProperty("_managedDisposables")) { var n, p; u._managedDisposables = null != (n = null == (p = u._managedDisposables) ? void 0 : p.slice()) ? n : [] } u._managedDisposables.unshift(y) } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/GLMaterialRepository": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Logger ../../../../core/maybe ../../../../core/NestedMap ./Util".split(" "), function (a, w, c, q, u, y) {
        const n = c.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository");
        let p = function () { function l(b) { this._glMaterial = b; this.refCnt = 0; this._glMaterial = b } var h = l.prototype; h.incRefCnt = function () { ++this.refCnt }; h.decRefCnt = function () { --this.refCnt; y.assert(0 <= this.refCnt) }; h.getRefCnt = function () { return this.refCnt }; w._createClass(l, [{ key: "glMaterial", get: function () { return this._glMaterial } }]); return l }(); c = function () {
          function l(b, d, f, t) { this._textureRepository = b; this._techniqueRepository = d; this.materialChanged = f; this.requestRender = t; this._id2glMaterialRef = new u.NestedMap }
          var h = l.prototype; h.dispose = function () { this._textureRepository.dispose() }; h.acquire = function (b, d) { this._ownMaterial(b); var f = this._id2glMaterialRef.get(d, b.id); q.isNone(f) && (f = b.createGLMaterial({ material: b, techniqueRep: this._techniqueRepository, textureRep: this._textureRepository, output: d }), f = new p(f), this._id2glMaterialRef.set(d, b.id, f)); f.incRefCnt(); return f.glMaterial }; h.release = function (b, d) {
            const f = this._id2glMaterialRef.get(d, b.id); q.isSome(f) && (f.decRefCnt(), 0 === f.getRefCnt() && (q.disposeMaybe(f.glMaterial),
              this._id2glMaterialRef.delete(d, b.id)))
          }; h._ownMaterial = function (b) { q.isSome(b.repository) && b.repository !== this && n.error("Material is already owned by a different material repository"); b.repository = this }; return l
        }(); a.GLMaterialRepository = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/GridLocalOriginFactory": function () {
      define("exports ../../../../core/maybe ../../../../core/uid ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ./Geometry ./localOrigin ./Object3D ./WebGLLayer ../materials/RibbonLineMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          function f(e) { v = e } let t = function () {
            function e(x, k = 125E4) { this._originSR = x; this._gridSize = k; this._origins = new Map; this._objects = new Map; this._rootOriginId = "root/" + c.generateUID() } var g = e.prototype; g.getOrigin = function (x) {
              const k = this._origins.get(this._rootOriginId); if (null == k) {
                if (w.isSome(v)) return this._origins.set(this._rootOriginId, l.fromValues(v[0], v[1], v[2], this._rootOriginId)), this.getOrigin(x); x = l.fromValues(x[0] + Math.random() - .5, x[1] + Math.random() - .5, x[2] +
                  Math.random() - .5, this._rootOriginId); this._origins.set(this._rootOriginId, x); return x
              } var r = this._gridSize; const A = Math.round(x[0] / r), z = Math.round(x[1] / r), B = Math.round(x[2] / r), C = `${A}/${z}/${B}`; let D = this._origins.get(C); const E = .5 * r; u.subtract(m, x, k.vec3); m[0] = Math.abs(m[0]); m[1] = Math.abs(m[1]); m[2] = Math.abs(m[2]); if (m[0] < E && m[1] < E && m[2] < E) return D && (r = Math.max(...m), u.subtract(m, x, D.vec3), m[0] = Math.abs(m[0]), m[1] = Math.abs(m[1]), m[2] = Math.abs(m[2]), Math.max(...m) < r) ? D : k; D || (D = l.fromValues(A * r, z *
                r, B * r, C), this._origins.set(C, D)); return D
            }; g._drawOriginBox = function (x, k = [1, 1, 0, 1]) {
              const r = window.view, A = r._stage; var z = k.toString(); if (!this._objects.has(z)) { this._material = new d.RibbonLineMaterial({ width: 2, color: k }); A.add(this._material); k = new b.WebGLLayer({ isPickable: !1 }); var B = new h.Object3D({ castShadow: !1 }); A.add(B); k.add(B); A.add(k); this._objects.set(z, B) } z = this._objects.get(z); k = [0, 1, 5, 4, 0, 2, 1, 7, 6, 2, 0, 1, 3, 7, 5, 4, 6, 2, 0]; B = k.length; const C = Array(3 * B), D = new Uint16Array(2 * (B - 1)), E = .5 * this._gridSize;
              for (let H = 0; H < B; H++)C[3 * H] = x[0] + (k[H] & 1 ? E : -E), C[3 * H + 1] = x[1] + (k[H] & 2 ? E : -E), C[3 * H + 2] = x[2] + (k[H] & 4 ? E : -E), 0 < H && (D[2 * H] = H - 1, D[2 * H + 1] = H); n.projectBuffer(C, this._originSR, 0, C, r.renderSpatialReference, 0, B); x = new p.Geometry([["position", { size: 3, data: C, exclusive: !0 }]], [["position", D]], 2); A.add(x); z.addGeometry(x, this._material, q.IDENTITY)
            }; return e
          }(), v = null; const m = y.create(); a.GridLocalOriginFactory = t; a.default = f; a.setTestRootOrigin = f; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/WebGLLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Evented ../../../../core/Handles ../../../../core/maybe ../../../../core/PooledArray ./ContentObject ./DirtyEvents ./Octree".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          n = function (h) {
            function b(f, t = "") { var v, m, e; var g = h.call(this) || this; g.apiLayerUid = t; g.type = 0; g.events = new c; g.isSliceable = !1; g._objects = new y; g._stageHandles = new q; g.apiLayerUid = t; g.isVisible = null != (v = null == f ? void 0 : f.isVisible) ? v : !0; g.isPickable = null != (m = null == f ? void 0 : f.isPickable) ? m : !0; g.updatePolicy = null != (e = null == f ? void 0 : f.updatePolicy) ? e : 0; return g } w._inheritsLoose(b, h); var d = b.prototype; d.destroy = function () { this.detachStage(); this._stage = null }; d.attachStage = function (f) {
              this.detachStage();
              this._stage = f; for (const t of p.DirtyEventNames) this._stageHandles.add(this.events.on(t, v => f.handleEvent(t, v)))
            }; d.detachStage = function () { this._stageHandles.removeAll(); this.invalidateSpatialQueryAccelerator() }; d.add = function (f) { this._objects.push(f); f.parentLayer = this; this.events.emit("layerObjectAdded", { layer: this, object: f }); u.isSome(this._octree) && this._octree.add([f]) }; d.remove = function (f) {
              this._objects.removeUnordered(f) && (f.parentLayer = null, this.events.emit("layerObjectRemoved", { layer: this, object: f }),
                u.isSome(this._octree) && this._octree.remove([f]))
            }; d.addMany = function (f) { this._objects.pushArray(f); for (const t of f) t.parentLayer = this; this.events.emit("layerObjectsAdded", { layer: this, objects: f }); u.isSome(this._octree) && this._octree.add(f) }; d.removeMany = function (f) { const t = []; this._objects.removeUnorderedMany(f, f.length, t); if (0 !== t.length) { for (const v of t) v.parentLayer = null; this.events.emit("layerObjectsRemoved", { layer: this, objects: t }); u.isSome(this._octree) && this._octree.remove(t) } }; d.sync = function () {
              u.isSome(this._stage) &&
              1 !== this.updatePolicy && this._stage.syncLayer(this.id)
            }; d.notifyObjectBBChanged = function (f, t) { u.isSome(this._octree) && this._octree.update(f, t) }; d.getSpatialQueryAccelerator = function () { u.isNone(this._octree) && 50 < this._objects.length && this._createOctree(); return this._octree }; d.shaderTransformationChanged = function () { this.invalidateSpatialQueryAccelerator(); this.events.emit("shaderTransformationChanged", this) }; d.invalidateSpatialQueryAccelerator = function () { this._octree = u.destroyMaybe(this._octree) }; d._createOctree =
              function () { this._octree = new l(f => f.boundingVolumeWorldSpace.bounds); this._octree.add(this._objects.data, this._objects.length) }; w._createClass(b, [{ key: "objects", get: function () { return this._objects } }]); return b
          }(n.ContentObject); a.WebGLLayer = n; a.isWebGLLayer = function (h) { return u.isSome(h) && 0 === h.type }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/DirtyEvents": function () {
      define(["exports"], function (a) {
      a.DirtyEventNames = "layerObjectAdded layerObjectRemoved layerObjectsAdded layerObjectsRemoved shaderTransformationChanged objectTransformation visibilityChanged occlusionChanged highlightChanged objectGeometryAdded objectGeometryRemoved vertexAttrsUpdated".split(" ");
        Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/Octree": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/ObjectPool ../../../../core/PooledArray ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/frustum ../../../../geometry/support/ray ../../../../chunks/sphere ./Util".split(" "), function (a, w, c, q, u, y, n, p, l, h) {
        function b(N, G, I) { I[0] = N[0] + G; I[1] = N[1] + G; I[2] = N[2] + G } function d(N, G,
          I, O) { if (1 === G) N = I(N[0]), l.copy(N, O); else { C[0] = Infinity; C[1] = Infinity; C[2] = Infinity; D[0] = -Infinity; D[1] = -Infinity; D[2] = -Infinity; for (let T = 0; T < G; T++) { var R = I(N[T]); if (m(R[3])) { var S = C, Q = R; S[0] = Math.min(S[0], Q[0] - Q[3]); S[1] = Math.min(S[1], Q[1] - Q[3]); S[2] = Math.min(S[2], Q[2] - Q[3]); S = D; S[0] = Math.max(S[0], R[0] + R[3]); S[1] = Math.max(S[1], R[1] + R[3]); S[2] = Math.max(S[2], R[2] + R[3]) } } u.lerp(O, C, D, .5); O[3] = Math.max(D[0] - C[0], D[1] - C[1], D[2] - C[2]) / 2 } } function f(N, G, I) {
            if (!P.length) for (var O = 0; 8 > O; ++O)P.push({
              index: 0,
              distance: 0
            }); for (O = 0; 8 > O; ++O) { const R = x[O]; P.data[O].index = O; P.data[O].distance = v(N, G, R) } P.sort((R, S) => R.distance - S.distance); for (N = 0; 8 > N; ++N)I[N] = P.data[N].index
          } function t(N, G) { let I = Infinity, O = null; for (let R = 0; 8 > R; ++R) { const S = v(N, G, k[R]); S < I && (I = S, O = k[R]) } return O } function v(N, G, I) { return G * (N[0] * I[0] + N[1] * I[1] + N[2] * I[2]) } function m(N) { return !isNaN(N) && -Infinity !== N && Infinity !== N && 0 < N } let e = function () {
            function N(I, O) {
            this._objectToBoundingSphere = I; this._maximumObjectsPerNode = 10; this._maximumDepth =
              20; this._degenerateObjects = new Set; this._root = new g; this._objectCount = 0; O && (void 0 !== O.maximumObjectsPerNode && (this._maximumObjectsPerNode = O.maximumObjectsPerNode), void 0 !== O.maximumDepth && (this._maximumDepth = O.maximumDepth))
            } var G = N.prototype; G.destroy = function () { this._degenerateObjects.clear(); g.clearPool(); A[0] = null; E.prune(); P.prune() }; G.add = function (I, O = I.length) {
            this._objectCount += O; this._grow(I, O); const R = g.acquire(); for (let S = 0; S < O; S++) {
              const Q = I[S]; this._isDegenerate(Q) ? this._degenerateObjects.add(Q) :
                (R.init(this._root), this._add(Q, R))
            } g.release(R)
            }; G.remove = function (I, O = null) { this._objectCount -= I.length; const R = g.acquire(); for (const S of I) I = w.isSome(O) ? O : l.copy(this._objectToBoundingSphere(S), H), m(I[3]) ? (R.init(this._root), this._remove(S, I, R)) : this._degenerateObjects.delete(S); g.release(R); this._shrink() }; G.update = function (I, O) { if (m(O[3]) || !this._isDegenerate(I)) A[0] = I, I = A, this.remove(I, O), this.add(I) }; G.forEachAlongRay = function (I, O, R) {
              const S = p.wrap(I, O); this._forEachNode(this._root, Q => {
                if (!this._intersectsNode(S,
                  Q)) return !1; Q = Q.node; Q.terminals.forAll(T => { this._intersectsObject(S, T) && R(T) }); null !== Q.residents && Q.residents.forAll(T => { this._intersectsObject(S, T) && R(T) }); return !0
              })
            }; G.forEachAlongRayWithVerticalOffset = function (I, O, R, S) {
              const Q = p.wrap(I, O); this._forEachNode(this._root, T => {
                if (!this._intersectsNodeWithOffset(Q, T, S)) return !1; T = T.node; T.terminals.forAll(da => { this._intersectsObjectWithOffset(Q, da, S) && R(da) }); null !== T.residents && T.residents.forAll(da => { this._intersectsObjectWithOffset(Q, da, S) && R(da) });
                return !0
              })
            }; G.forEach = function (I) { this._forEachNode(this._root, O => { O = O.node; O.terminals.forAll(I); null !== O.residents && O.residents.forAll(I); return !0 }); this._degenerateObjects.forEach(I) }; G.forEachDegenerateObject = function (I) { this._degenerateObjects.forEach(I) }; G.findClosest = function (I, O, R, S = () => !0, Q = Infinity) {
              let T = Infinity, da = Infinity, Y = null; const fa = t(I, O), ha = ka => {
                --Q; if (S(ka)) {
                  var ea = this._objectToBoundingSphere(ka); if (n.intersectsSphere(R, ea)) {
                    var ba = v(I, O, l.getCenter(ea)), aa = ba - ea[3]; ea = ba + ea[3];
                    aa < T && (T = aa, da = ea, Y = ka)
                  }
                }
              }; this._forEachNodeDepthOrdered(this._root, ka => { if (0 >= Q || !n.intersectsSphere(R, ka.bounds)) return !1; u.scale(B, fa, ka.halfSize); u.add(B, B, ka.bounds); if (v(I, O, B) > da) return !1; ka = ka.node; ka.terminals.forAll(ea => ha(ea)); null !== ka.residents && ka.residents.forAll(ea => ha(ea)); return !0 }, I, O); return Y
            }; G.forEachInDepthRange = function (I, O, R, S, Q, T, da) {
              let Y = -Infinity, fa = Infinity; const ha = {
                setRange: W => {
                  1 === R ? (Y = Math.max(Y, W.near), fa = Math.min(fa, W.far)) : (Y = Math.max(Y, -W.far), fa = Math.min(fa,
                    -W.near))
                }
              }; ha.setRange(S); const ka = v(O, R, I), ea = t(O, R), ba = t(O, -R), aa = W => { if (da(W)) { var U = this._objectToBoundingSphere(W), X = l.getCenter(U); X = v(O, R, X) - ka; var Z = X + U[3]; X - U[3] > fa || Z < Y || !n.intersectsSphere(T, U) || Q(W, ha) } }; this._forEachNodeDepthOrdered(this._root, W => {
                if (!n.intersectsSphere(T, W.bounds)) return !1; u.scale(B, ea, W.halfSize); u.add(B, B, W.bounds); if (v(O, R, B) - ka > fa) return !1; u.scale(B, ba, W.halfSize); u.add(B, B, W.bounds); if (v(O, R, B) - ka < Y) return !1; W = W.node; W.terminals.forAll(U => aa(U)); null !== W.residents &&
                  W.residents.forAll(U => aa(U)); return !0
              }, O, R)
            }; G.forEachNode = function (I) { this._forEachNode(this._root, O => I(O.node, O.bounds, O.halfSize)) }; G._intersectsNode = function (I, O) { b(O.bounds, 2 * -O.halfSize, C); b(O.bounds, 2 * O.halfSize, D); return h.rayBoxTest(I.origin, I.direction, C, D) }; G._intersectsNodeWithOffset = function (I, O, R) { b(O.bounds, 2 * -O.halfSize, C); b(O.bounds, 2 * O.halfSize, D); R.applyToMinMax(C, D); return h.rayBoxTest(I.origin, I.direction, C, D) }; G._intersectsObject = function (I, O) {
              O = this._objectToBoundingSphere(O);
              return 0 < O[3] ? l.intersectsRay(O, I) : !0
            }; G._intersectsObjectWithOffset = function (I, O, R) { O = this._objectToBoundingSphere(O); return 0 < O[3] ? l.intersectsRay(R.applyToBoundingSphere(O), I) : !0 }; G._forEachNode = function (I, O) { I = g.acquire().init(I); const R = [I]; for (; 0 !== R.length;) { I = R.pop(); if (O(I) && !I.isLeaf()) for (let S = 0; S < I.node.children.length; S++)I.node.children[S] && R.push(g.acquire().init(I).advance(S)); g.release(I) } }; G._forEachNodeDepthOrdered = function (I, O, R, S = 1) {
              I = g.acquire().init(I); const Q = [I]; for (f(R,
                S, L); 0 !== Q.length;) { I = Q.pop(); if (O(I) && !I.isLeaf()) for (R = 7; 0 <= R; --R)S = L[R], I.node.children[S] && Q.push(g.acquire().init(I).advance(S)); g.release(I) }
            }; G._remove = function (I, O, R) { E.clear(); O = R.advanceTo(O, (S, Q) => { E.push(S.node); E.push(Q) }) ? R.node.terminals : R.node.residents; O.removeUnordered(I); if (0 === O.length) for (I = E.length - 2; 0 <= I && this._purge(E.data[I], E.data[I + 1]); I -= 2); }; G._nodeIsEmpty = function (I) {
              if (0 !== I.terminals.length) return !1; if (null !== I.residents) return 0 === I.residents.length; for (let O = 0; O <
                I.children.length; O++)if (I.children[O]) return !1; return !0
            }; G._purge = function (I, O) { 0 <= O && (I.children[O] = null); return this._nodeIsEmpty(I) ? (null === I.residents && (I.residents = new q({ shrink: !0 })), !0) : !1 }; G._add = function (I, O) { O.advanceTo(this._objectToBoundingSphere(I)) ? O.node.terminals.push(I) : (O.node.residents.push(I), O.node.residents.length > this._maximumObjectsPerNode && O.depth < this._maximumDepth && this._split(O)) }; G._split = function (I) {
              const O = I.node.residents; I.node.residents = null; for (let R = 0; R < O.length; R++) {
                const S =
                  g.acquire().init(I); this._add(O.getItemAt(R), S); g.release(S)
              }
            }; G._grow = function (I, O) { 0 !== O && (d(I, O, R => this._objectToBoundingSphere(R), J), m(J[3]) && !this._fitsInsideTree(J) && (this._nodeIsEmpty(this._root.node) ? (l.copy(J, this._root.bounds), this._root.halfSize = 1.25 * J[3]) : (I = this._rootBoundsForRootAsSubNode(J), this._placingRootViolatesMaxDepth(I) ? this._rebuildTree(J, I) : this._growRootAsSubNode(I), g.release(I)))) }; G._rebuildTree = function (I, O) {
              u.copy(M, O.bounds); M[3] = O.halfSize; d([I, M], 2, R => R, F); I = g.acquire().init(this._root);
              this._root.initFrom(null, F, 1.25 * F[3]); this._forEachNode(I, R => { this.add(R.node.terminals.data, R.node.terminals.length); null !== R.node.residents && this.add(R.node.residents.data, R.node.residents.length); return !0 }); g.release(I)
            }; G._placingRootViolatesMaxDepth = function (I) { const O = Math.log(I.halfSize / this._root.halfSize) * Math.LOG2E; let R = 0; this._forEachNode(this._root, S => { R = Math.max(R, S.depth); return R + O <= this._maximumDepth }); return R + O > this._maximumDepth }; G._rootBoundsForRootAsSubNode = function (I) {
              var O =
                I[3]; let R = -Infinity; const S = this._root.bounds, Q = this._root.halfSize; for (var T = 0; 3 > T; T++) { var da = Math.max(0, Math.ceil((S[T] - Q - (I[T] - O)) / (2 * Q))); const Y = Math.max(0, Math.ceil((I[T] + O - (S[T] + Q)) / (2 * Q))) + 1; R = Math.max(R, 2 ** Math.ceil(Math.log(da + Y) * Math.LOG2E)); K[T].min = da; K[T].max = Y } for (I = 0; 3 > I; I++)O = K[I].min, T = K[I].max, da = (R - (O + T)) / 2, O += Math.ceil(da), T += Math.floor(da), z[I] = S[I] - Q - O * Q * 2 + (T + O) * Q; z[3] = R * Q * r; return g.acquire().initFrom(null, z, R * Q, 0)
            }; G._growRootAsSubNode = function (I) {
              const O = this._root.node;
              u.copy(J, this._root.bounds); J[3] = this._root.halfSize; this._root.init(I); I.advanceTo(J, null, !0); I.node.children = O.children; I.node.residents = O.residents; I.node.terminals = O.terminals
            }; G._shrink = function () { for (; ;) { const I = this._findShrinkIndex(); if (-1 === I) break; this._root.advance(I); this._root.depth = 0 } }; G._findShrinkIndex = function () {
              if (0 !== this._root.node.terminals.length || this._root.isLeaf()) return -1; let I = null; const O = this._root.node.children; let R = 0, S = 0; for (; S < O.length && null == I;)R = S++ , I = O[R]; for (; S <
                O.length;)if (O[S++]) return -1; return R
            }; G._isDegenerate = function (I) { I = this._objectToBoundingSphere(I)[3]; return !m(I) }; G._fitsInsideTree = function (I) { const O = this._root.bounds, R = this._root.halfSize; return I[3] <= R && I[0] >= O[0] - R && I[0] <= O[0] + R && I[1] >= O[1] - R && I[1] <= O[1] + R && I[2] >= O[2] - R && I[2] <= O[2] + R }; a._createClass(N, [{ key: "bounds", get: function () { return this._root.bounds } }, { key: "halfSize", get: function () { return this._root.halfSize } }, { key: "root", get: function () { return this._root.node } }, {
              key: "maximumObjectsPerNode",
              get: function () { return this._maximumObjectsPerNode }
            }, { key: "maximumDepth", get: function () { return this._maximumDepth } }, { key: "objectCount", get: function () { return this._objectCount } }]); return N
          }(), g = function () {
            function N() { this.bounds = l.create(); this.halfSize = 0; this.initFrom(null, null, 0, 0) } var G = N.prototype; G.init = function (I) { return this.initFrom(I.node, I.bounds, I.halfSize, I.depth) }; G.initFrom = function (I, O, R, S = this.depth) {
            this.node = w.isSome(I) ? I : N.createEmptyNode(); w.isSome(O) && l.copy(O, this.bounds); this.halfSize =
              R; this.depth = S; return this
            }; G.advance = function (I) { let O = this.node.children[I]; O || (O = N.createEmptyNode(), this.node.children[I] = O); this.node = O; this.halfSize /= 2; this.depth++; I = x[I]; this.bounds[0] += I[0] * this.halfSize; this.bounds[1] += I[1] * this.halfSize; this.bounds[2] += I[2] * this.halfSize; this.bounds[3] = this.halfSize * r; return this }; G.advanceTo = function (I, O, R = !1) {
              for (; ;) {
                if (this.isTerminalFor(I)) return O && O(this, -1), !0; if (this.isLeaf()) { if (!R) return O && O(this, -1), !1; this.node.residents = null } const S = this._childIndex(I);
                O && O(this, S); this.advance(S)
              }
            }; G.isLeaf = function () { return null != this.node.residents }; G.isTerminalFor = function (I) { return I[3] > this.halfSize / 2 }; G._childIndex = function (I) { const O = this.bounds; return (O[0] < I[0] ? 1 : 0) + (O[1] < I[1] ? 2 : 0) + (O[2] < I[2] ? 4 : 0) }; N.createEmptyNode = function () { return { children: [null, null, null, null, null, null, null, null], terminals: new q({ shrink: !0 }), residents: new q({ shrink: !0 }) } }; N.acquire = function () { return N._pool.acquire() }; N.release = function (I) { N._pool.release(I) }; N.clearPool = function () { N._pool.prune() };
            return N
          }(); g._pool = new c(g); const x = [y.fromValues(-1, -1, -1), y.fromValues(1, -1, -1), y.fromValues(-1, 1, -1), y.fromValues(1, 1, -1), y.fromValues(-1, -1, 1), y.fromValues(1, -1, 1), y.fromValues(-1, 1, 1), y.fromValues(1, 1, 1)], k = [y.fromValues(-1, -1, -1), y.fromValues(-1, -1, 1), y.fromValues(-1, 1, -1), y.fromValues(-1, 1, 1), y.fromValues(1, -1, -1), y.fromValues(1, -1, 1), y.fromValues(1, 1, -1), y.fromValues(1, 1, 1)], r = Math.sqrt(3), A = [null], z = l.create(), B = y.create(), C = y.create(), D = y.create(), E = new q, H = l.create(), J = l.create(), M = l.create(),
            F = l.create(), K = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }], P = new q, L = [0, 0, 0, 0, 0, 0, 0, 0]; return e
      })
    }, "esri/views/3d/webgl-engine/materials/RibbonLineMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Logger ../../../../core/mathUtils ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/vec2 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/lineSegment ../../../../geometry/support/plane ../../support/buffer/InterleavedLayout ../lib/geometryDataUtils ../lib/GLMaterial ../lib/GLMaterials ../lib/Material ../lib/Util ./VisualVariableMaterialParameters ./renderers/utils ../../../../chunks/RibbonLine.glsl ../shaders/RibbonLineTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
          function A(ea, ba, aa, W, U) { for (let X = 0; X < U; X++)aa[W++] = ea[ba++]; return W } function z(ea, ba, aa) { ba = ba.get("position").data; aa = aa ? aa.get("position") : null; return ea.isClosed ? aa ? 2 < aa.length : 6 < ba.length : !1 } const B = c.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial"); c = function (ea) {
            function ba(W) {
              W = ea.call(this, W, D) || this; W._vertexAttributeLocations = r.ribbonVertexAttributeLocations; W.techniqueConfig = new r.RibbonLineTechniqueConfiguration;
              W.layout = W.createLayout(); return W
            } w._inheritsLoose(ba, ea); var aa = ba.prototype; aa.isClosed = function (W, U) { return this.parameters.isClosed ? U ? 2 < U.length : 6 < W.length : !1 }; aa.dispose = function () { }; aa.getPassParameters = function () { return this.parameters }; aa.getTechniqueConfig = function (W, U) {
              this.techniqueConfig.output = W; this.techniqueConfig.draped = 20 === U.slot; W = u.isSome(this.parameters.stipplePattern); this.techniqueConfig.stippleEnabled = W; this.techniqueConfig.stippleOffColorEnabled = W && u.isSome(this.parameters.stippleOffColor);
              this.techniqueConfig.stippleScaleWithLineWidth = W && this.parameters.stippleScaleWithLineWidth; this.techniqueConfig.stipplePreferContinuous = W && this.parameters.stipplePreferContinuous; this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this.techniqueConfig.sceneHasOcludees = this.parameters.sceneHasOcludees; this.techniqueConfig.roundJoins = "round" === this.parameters.join; this.techniqueConfig.roundCaps = 2 === this.parameters.cap; this.techniqueConfig.transparent = this.parameters.transparent;
              this.techniqueConfig.polygonOffset = this.parameters.polygonOffset; this.techniqueConfig.writeDepth = this.parameters.writeDepth; this.techniqueConfig.vvColor = this.parameters.vvColorEnabled; this.techniqueConfig.vvOpacity = this.parameters.vvOpacityEnabled; this.techniqueConfig.vvSize = this.parameters.vvSizeEnabled; this.techniqueConfig.innerColorEnabled = 0 < this.parameters.innerWidth && u.isSome(this.parameters.innerColor); this.techniqueConfig.falloffEnabled = 0 < this.parameters.falloff; this.techniqueConfig.occluder =
                8 === this.parameters.renderOccluded; this.techniqueConfig.transparencyPassType = U.transparencyPassType; this.techniqueConfig.multipassTerrainEnabled = U.multipassTerrainEnabled; this.techniqueConfig.cullAboveGround = U.cullAboveGround; return this.techniqueConfig
            }; aa.intersect = function (W, U, X, Z, ia, la, ma, ra, Aa) { u.isSome(Aa) ? this.intersectDrapedLineGeometry(W, Z, Aa, la, ma) : this.intersectLineGeometry(W, U, X, Z, ma) }; aa.intersectDrapedLineGeometry = function (W, U, X, Z, ia) {
              if (U.options.selectionMode) {
                U = W.vertexAttributes.get("position").data;
                var la = W.vertexAttributes.get("size"), ma = this.parameters.width; this.parameters.vvSizeEnabled ? (la = W.vertexAttributes.get("sizeFeatureAttribute").data[0], ma *= q.clamp(this.parameters.vvSizeOffset[0] + la * this.parameters.vvSizeFactor[0], this.parameters.vvSizeMinSize[0], this.parameters.vvSizeMaxSize[0])) : la && (ma *= la.data[0]); la = Z[0]; Z = Z[1]; W = (ma / 2 + 4) * W.screenToWorldRatio; ma = Number.MAX_VALUE; var ra = 0; for (let Ua = 0; Ua < U.length - 5; Ua += 3) {
                  var Aa = U[Ua], za = U[Ua + 1], Ka = la - Aa, Ea = Z - za; Aa = U[Ua + 3] - Aa; za = U[Ua + 4] - za; const Na =
                    q.clamp((Aa * Ka + za * Ea) / (Aa * Aa + za * za), 0, 1); Ka = Aa * Na - Ka; Ea = za * Na - Ea; Ea = Ka * Ka + Ea * Ea; Ea < ma && (ma = Ea, ra = Ua / 3)
                } ma < W * W && ia(X.dist, X.normal, ra, !1)
              }
            }; aa.intersectLineGeometry = function (W, U, X, Z, ia) {
              if (Z.options.selectionMode && !x.isInstanceHidden(U)) if (e.isTranslationMatrix(X)) {
                var la = W.vertexAttributes, ma = la.get("position").data; U = this.parameters.width; if (this.parameters.vvSizeEnabled) {
                  var ra = la.get("sizeFeatureAttribute").data[0]; U *= q.clamp(this.parameters.vvSizeOffset[0] + ra * this.parameters.vvSizeFactor[0], this.parameters.vvSizeMinSize[0],
                    this.parameters.vvSizeMaxSize[0])
                } else la.has("size") && (U *= la.get("size").data[0]); var Aa = Z.camera, za = K; n.copy(za, Z.point); ra = U * Aa.pixelRatio / 2 + 4 * Aa.pixelRatio; p.set(T[0], za[0] - ra, za[1] + ra, 0); p.set(T[1], za[0] + ra, za[1] + ra, 0); p.set(T[2], za[0] + ra, za[1] - ra, 0); p.set(T[3], za[0] - ra, za[1] - ra, 0); for (U = 0; 4 > U; U++)if (!Aa.unprojectFromRenderScreen(T[U], da[U])) return; b.fromPoints(Aa.eye, da[0], da[1], Y); b.fromPoints(Aa.eye, da[1], da[2], fa); b.fromPoints(Aa.eye, da[2], da[3], ha); b.fromPoints(Aa.eye, da[3], da[0], ka); var Ka =
                  Number.MAX_VALUE; U = 0; W = z(this.parameters, la, W.indices) ? ma.length - 2 : ma.length - 5; for (la = 0; la < W; la += 3) {
                  H[0] = ma[la] + X[12]; H[1] = ma[la + 1] + X[13]; H[2] = ma[la + 2] + X[14]; var Ea = (la + 3) % ma.length; J[0] = ma[Ea] + X[12]; J[1] = ma[Ea + 1] + X[13]; J[2] = ma[Ea + 2] + X[14]; if (!(0 > b.signedDistance(Y, H) && 0 > b.signedDistance(Y, J) || 0 > b.signedDistance(fa, H) && 0 > b.signedDistance(fa, J) || 0 > b.signedDistance(ha, H) && 0 > b.signedDistance(ha, J) || 0 > b.signedDistance(ka, H) && 0 > b.signedDistance(ka, J))) {
                    Aa.projectToRenderScreen(H, P); Aa.projectToRenderScreen(J,
                      L); if (0 > P[2] && 0 < L[2]) p.subtract(M, H, J), Ea = Aa.frustum, Ea = -b.signedDistance(Ea[4], H) / p.dot(M, b.normal(Ea[4])), p.scale(M, M, Ea), p.add(H, H, M), Aa.projectToRenderScreen(H, P); else if (0 < P[2] && 0 > L[2]) p.subtract(M, J, H), Ea = Aa.frustum, Ea = -b.signedDistance(Ea[4], J) / p.dot(M, b.normal(Ea[4])), p.scale(M, M, Ea), p.add(J, J, M), Aa.projectToRenderScreen(J, L); else if (0 > P[2] && 0 > L[2]) continue; P[2] = 0; L[2] = 0; Ea = h.distance2(h.fromPoints(P, L, I), za); Ea < Ka && (Ka = Ea, p.copy(N, H), p.copy(G, J), U = la / 3)
                  }
                  } X = Z.rayBegin; Z = Z.rayEnd; Ka < ra * ra &&
                    (ma = Number.MAX_VALUE, h.closestLineSegmentPoint(h.fromPoints(N, G, I), h.fromPoints(X, Z, O), F) && (p.subtract(F, F, X), ma = p.length(F), p.scale(F, F, 1 / ma), ma /= p.distance(X, Z)), ia(ma, F, U, !1))
              } else B.error("intersection assumes a translation-only matrix")
            }; aa.computeAttachmentOrigin = function (W, U) { const X = W.vertexAttributes; if (!X) return null; W = W.indices; const Z = X.get("position"); return f.computeAttachmentOriginLines(Z, W ? W.get("position") : null, W && z(this.parameters, X, W), U) }; aa.createLayout = function () {
              const W = d.newLayout().vec3f("position").f32("subdivisionFactor").vec2f("uv0").vec3f("auxpos1").vec3f("auxpos2");
              this.parameters.vvSizeEnabled ? W.f32("sizeFeatureAttribute") : W.f32("size"); this.parameters.vvColorEnabled ? W.f32("colorFeatureAttribute") : W.vec4f("color"); this.parameters.vvOpacityEnabled && W.f32("opacityFeatureAttribute"); return W
            }; aa.createBufferWriter = function () { return new E(this.layout, this.parameters) }; aa.requiresSlot = function (W, U) {
              if (20 === W) return !0; if (8 === this.parameters.renderOccluded) return 2 === W || 9 === W || 10 === W; U = v.outputFromPass(U); return 0 === U || 7 === U ? W === (this.parameters.writeDepth ? 4 : 7) : 2 ===
                W
            }; aa.createGLMaterial = function (W) { return 0 === W.output || 7 === W.output || 4 === W.output || 1 === W.output ? new C(W) : null }; aa.validateParameters = function (W) { "miter" !== W.join && (W.miterLimit = 0); this.requiresTransparent(W) && (W.transparent = !0) }; aa.requiresTransparent = function (W) { return !!(1 > (W.color && W.color[3]) || 0 < W.innerWidth && this.colorRequiresTransparent(W.innerColor) || W.stipplePattern && this.colorRequiresTransparent(W.stippleOffColor) || 0 < W.falloff) }; aa.colorRequiresTransparent = function (W) {
              return u.isSome(W) &&
                1 > W[3] && 0 < W[3]
            }; return ba
          }(m.Material); let C = function (ea) {
            function ba() { return ea.apply(this, arguments) || this } w._inheritsLoose(ba, ea); var aa = ba.prototype; aa.updateParameters = function (W) { return this.ensureTechnique(r.RibbonLineTechnique, W) }; aa._updateOccludeeState = function (W) { W.hasOccludees !== this._material.parameters.sceneHasOcludees && this._material.setParameters({ sceneHasOcludees: W.hasOccludees }) }; aa.beginSlot = function (W) { 0 !== this._output && 7 !== this._output || this._updateOccludeeState(W); return this.updateParameters(W) };
            aa.bind = function (W, U) { U.bindPass(this._material.getPassParameters(), W) }; return ba
          }(t); const D = { width: 0, color: [1, 1, 1, 1], join: "miter", cap: 0, miterLimit: 5, writeDepth: !0, polygonOffset: !1, stipplePattern: null, stippleOffColor: null, stippleScaleWithLineWidth: !1, stipplePreferContinuous: !0, slicePlaneEnabled: !1, vvFastUpdate: !1, transparent: !1, isClosed: !1, falloff: 0, innerWidth: 0, innerColor: null, sceneHasOcludees: !1, ...m.materialParametersDefaults, ...g.Default }; let E = function () {
            function ea(aa, W) {
            this.parameters = W;
              this.numJoinSubdivisions = 0; this.vertexBufferLayout = aa; aa = W.stipplePattern ? 1 : 0; switch (this.parameters.join) { case "miter": case "bevel": this.numJoinSubdivisions = aa; break; case "round": this.numJoinSubdivisions = k.NUM_ROUND_JOIN_SUBDIVISIONS + aa }
            } var ba = ea.prototype; ba.isClosed = function (aa) { return z(this.parameters, aa.vertexAttributes, aa.indices) }; ba.numCapSubdivisions = function (aa) { if (this.isClosed(aa)) return 0; switch (this.parameters.cap) { case 1: case 2: return 1; default: return 0 } }; ba.allocate = function (aa) { return this.vertexBufferLayout.createBuffer(aa) };
            ba.elementCount = function (aa) { var W = 2 * this.numCapSubdivisions(aa) + 2, U = aa.indices.get("position").length / 2 + 1; const X = this.isClosed(aa); W = X ? 2 : 2 * W; var Z = X ? 0 : 1; U = X ? U : U - 1; if (aa.vertexAttributes.has("subdivisions")) for (aa = aa.vertexAttributes.get("subdivisions").data; Z < U; ++Z)W += 4 + 2 * aa[Z]; else W += (U - Z) * (2 * this.numJoinSubdivisions + 4); return W + 2 }; ba.write = function (aa, W, U, X) {
              var Z; const ia = R, la = S, ma = Q; var ra = W.vertexAttributes.get("position").data, Aa = W.indices && W.indices.get("position"); const za = null == (Z = W.vertexAttributes.get("distanceToStart")) ?
                void 0 : Z.data; Z = this.numCapSubdivisions(W); Aa && Aa.length !== 2 * (ra.length / 3 - 1) && console.warn("RibbonLineMaterial does not support indices"); Aa = null; W.vertexAttributes.has("subdivisions") && (Aa = W.vertexAttributes.get("subdivisions").data); let Ka = 1, Ea = 0; this.parameters.vvSizeEnabled ? Ea = W.vertexAttributes.get("sizeFeatureAttribute").data[0] : W.vertexAttributes.has("size") && (Ka = W.vertexAttributes.get("size").data[0]); let Ua = [1, 1, 1, 1], Na = 0; this.parameters.vvColorEnabled ? Na = W.vertexAttributes.get("colorFeatureAttribute").data[0] :
                  W.vertexAttributes.has("color") && (Ua = W.vertexAttributes.get("color").data); let ya = 0; this.parameters.vvOpacityEnabled && (ya = W.vertexAttributes.get("opacityFeatureAttribute").data[0]); const pa = ra.length / 3; aa = aa.transformation; const wa = new Float32Array(U.buffer); U = this.vertexBufferLayout.stride / 4; let Ia = X * U; X = Ia; let Ha = 0; const Oa = (ca, qa, Da, na, xa, Qa, Wa) => {
                  wa[Ia++] = qa[0]; wa[Ia++] = qa[1]; wa[Ia++] = qa[2]; wa[Ia++] = na; wa[Ia++] = Wa; wa[Ia++] = xa; wa[Ia++] = ca[0]; wa[Ia++] = ca[1]; wa[Ia++] = ca[2]; wa[Ia++] = Da[0]; wa[Ia++] =
                    Da[1]; wa[Ia++] = Da[2]; this.parameters.vvSizeEnabled ? wa[Ia++] = Ea : wa[Ia++] = Ka; this.parameters.vvColorEnabled ? wa[Ia++] = Na : (ca = Math.min(4 * Qa, Ua.length - 4), wa[Ia++] = Ua[ca + 0], wa[Ia++] = Ua[ca + 1], wa[Ia++] = Ua[ca + 2], wa[Ia++] = Ua[ca + 3]); this.parameters.vvOpacityEnabled && (wa[Ia++] = ya)
                  }; Ia += U; p.set(la, ra[0], ra[1], ra[2]); aa && p.transformMat4(la, la, aa); if (W = this.isClosed(W)) { var Ba = ra.length - 3; p.set(ia, ra[Ba], ra[Ba + 1], ra[Ba + 2]); aa && p.transformMat4(ia, ia, aa) } else {
                    p.copy(ia, la); p.set(ma, ra[3], ra[4], ra[5]); aa && p.transformMat4(ma,
                      ma, aa); for (Ba = 0; Ba < Z; ++Ba) { var sa = 1 - Ba / Z; Oa(ia, la, ma, sa, -4, 0, Ha); Oa(ia, la, ma, sa, 4, 0, Ha) } Oa(ia, la, ma, 0, -4, 0, Ha); Oa(ia, la, ma, 0, 4, 0, Ha); p.copy(ia, la); p.copy(la, ma)
                  } sa = W ? 0 : 1; Ba = W ? pa : pa - 1; const Ca = za ? (ca, qa, Da) => Ha = za[Da] : (ca, qa, Da) => Ha += p.distance(ca, qa); for (let ca = sa; ca < Ba; ca++) {
                    var Ja = (ca + 1) % pa * 3; p.set(ma, ra[Ja + 0], ra[Ja + 1], ra[Ja + 2]); aa && p.transformMat4(ma, ma, aa); Ca(ia, la, ca); Oa(ia, la, ma, 0, -1, ca, Ha); Oa(ia, la, ma, 0, 1, ca, Ha); Ja = Aa ? Aa[ca] : this.numJoinSubdivisions; for (let qa = 0; qa < Ja; ++qa) {
                      const Da = (qa + 1) /
                        (Ja + 1); Oa(ia, la, ma, Da, -1, ca, Ha); Oa(ia, la, ma, Da, 1, ca, Ha)
                    } Oa(ia, la, ma, 1, -2, ca, Ha); Oa(ia, la, ma, 1, 2, ca, Ha); p.copy(ia, la); p.copy(la, ma)
                  } if (W) p.set(ma, ra[3], ra[4], ra[5]), aa && p.transformMat4(ma, ma, aa), Ha = Ca(ia, la, Ba), Oa(ia, la, ma, 0, -1, sa, Ha), Oa(ia, la, ma, 0, 1, sa, Ha); else for (Ha = Ca(ia, la, Ba), Oa(ia, la, ma, 0, -5, Ba, Ha), Oa(ia, la, ma, 0, 5, Ba, Ha), ra = 0; ra < Z; ++ra)Aa = (ra + 1) / Z, Oa(ia, la, ma, Aa, -5, Ba, Ha), Oa(ia, la, ma, Aa, 5, Ba, Ha); A(wa, X + U, wa, X, U); Ia = A(wa, Ia - U, wa, Ia, U)
            }; return ea
          }(); const H = l.create(), J = l.create(), M = l.create(),
            F = l.create(), K = l.create(), P = y.createRenderScreenPointArray3(), L = y.createRenderScreenPointArray3(), N = l.create(), G = l.create(), I = h.create(), O = h.create(), R = l.create(), S = l.create(), Q = l.create(), T = [y.createRenderScreenPointArray3(), y.createRenderScreenPointArray3(), y.createRenderScreenPointArray3(), y.createRenderScreenPointArray3()], da = [l.create(), l.create(), l.create(), l.create()], Y = b.create(), fa = b.create(), ha = b.create(), ka = b.create(); a.RibbonLineMaterial = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/webgl-engine/materials/VisualVariableMaterialParameters": function () {
      define(["../../../../chunks/mat3f64", "../../../../chunks/vec3f32"], function (a, w) {
        var c; (c || (c = {})).Default = {
          vvSizeEnabled: !1, vvSizeMinSize: w.fromValues(1, 1, 1), vvSizeMaxSize: w.fromValues(100, 100, 100), vvSizeOffset: w.fromValues(0, 0, 0), vvSizeFactor: w.fromValues(1, 1, 1), vvSizeValue: w.fromValues(1, 1, 1), vvColorEnabled: !1, vvColorValues: [0, 0, 0, 0, 0, 0, 0, 0], vvColorColors: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
            1, 0, 0, 0], vvOpacityEnabled: !1, vvOpacityValues: [0, 0, 0, 0, 0, 0, 0, 0], vvOpacityOpacities: [1, 1, 1, 1, 1, 1, 1, 1], vvSymbolAnchor: [0, 0, 0], vvSymbolRotationMatrix: a.create()
        }; return c
      })
    }, "esri/chunks/RibbonLine.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          function f(v) {
            const m = new d.ShaderBuilder, e = v.stippleEnabled && v.roundCaps, g = v.falloffEnabled || e, x = v.innerColorEnabled, k = v.stippleEnabled && v.stippleScaleWithLineWidth || v.roundCaps, r = v.stippleEnabled && v.stippleScaleWithLineWidth; m.extensions.add("GL_OES_standard_derivatives"); m.include(p.PiUtils); m.include(c.RibbonVertexPosition, v); m.include(y.LineStipple, { ...v, stippleRequiresStretchMeasure: e }); 1 === v.output && m.include(q.OutputDepth, v); m.vertex.uniforms.add("proj", "mat4").add("view",
              "mat4").add("cameraNearFar", "vec2").add("pixelRatio", "float").add("miterLimit", "float").add("screenSize", "vec2"); m.attributes.add("position", "vec3"); m.attributes.add("subdivisionFactor", "float"); m.attributes.add("uv0", "vec2"); m.attributes.add("auxpos1", "vec3"); m.attributes.add("auxpos2", "vec3"); m.varyings.add("vColor", "vec4"); m.varyings.add("vpos", "vec3"); m.varyings.add("linearDepth", "float"); v.multipassTerrainEnabled && m.varyings.add("depth", "float"); k && m.varyings.add("vLineWidth", "float"); r && m.varyings.add("vLineSizeInv",
                "float"); x && m.varyings.add("vLineDistance", "float"); g && m.varyings.add("vLineDistanceNorm", "float"); v.falloffEnabled && m.fragment.uniforms.add("falloff", "float"); v.innerColorEnabled && (m.fragment.uniforms.add("innerColor", "vec4"), m.fragment.uniforms.add("innerWidth", "float")); v.roundCaps && m.varyings.add("vCapPosition", "vec2"); e && m.varyings.add("vStipplePatternStretch", "float"); m.vertex.code.add(b.glsl`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`); m.vertex.code.add(b.glsl`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= screenSize / posNdc.w;
return posNdc;
}`); m.vertex.code.add(b.glsl`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = cameraNearFar[0] * 0.99;

      //current pos behind ncp --> we need to clip
      if(pos.z > -cameraNearFar[0]) {
        if (!isStartVertex) {
          //previous in front of ncp
          if(prev.z < -cameraNearFar[0]) {
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
        //next in front of ncp
        if(isStartVertex) {
          if(next.z < -cameraNearFar[0]) {
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        //previous behind ncp
        if (prev.z > -cameraNearFar[0]) {
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        //next behind ncp
        if (next.z > -cameraNearFar[0]) {
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${v.multipassTerrainEnabled ? "depth \x3d pos.z;" : ""}
      linearDepth = (-pos.z - cameraNearFar[0]) / (cameraNearFar[1] - cameraNearFar[0]);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
`); m.vertex.code.add(b.glsl`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;
    vpos = position;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;

      ${k ? b.glsl`vLineWidth = lineWidth;` : ""}
      ${r ? b.glsl`vLineSizeInv = 1.0 / lineSize;` : ""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);

      clipAndTransform(pos, prev, next, isStartVertex);

      vec2 left = (pos.xy - prev.xy);
      vec2 right = (next.xy - pos.xy);

      float leftLen = length(left);
      float rightLen = length(right);
  `); v.stippleEnabled && m.vertex.code.add(b.glsl`float isEndVertex = float(!isStartVertex);
vec4 segmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), isEndVertex);
vec2 segmentOrigin = segmentInfo.xy;
vec2 segment = segmentInfo.zw;`); m.vertex.code.add(b.glsl`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`); v.roundJoins ? m.vertex.code.add(b.glsl`
        vec2 startDir;
        vec2 endDir;

        if (leftLen < 0.001) {
          startDir = right;
        }
        else{
          startDir = left;
        }
        startDir = normalize(startDir);
        startDir = PERPENDICULAR(startDir);

        if (rightLen < 0.001) {
          endDir = left;
        }
        else{
          endDir = right;
        }
        endDir = normalize(endDir);
        endDir = PERPENDICULAR(endDir);

        float factor = ${v.stippleEnabled ? b.glsl`min(1.0, subdivisionFactor * ${b.glsl.float(1.5)})` : b.glsl`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `) : m.vertex.code.add(b.glsl`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = normalize(joinDisplacementDir);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`); m.vertex.code.add(b.glsl`displacementLen = lineWidth;
}
} else {
if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = isStartVertex ? right : left;
}
joinDisplacementDir = normalize(joinDisplacementDir);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
displacementLen = lineWidth;
capDisplacementDir = isStartVertex ? -right : left;
capDisplacementDir *= subdivisionFactor;
}`); m.vertex.code.add(b.glsl`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

    ${g || x ? b.glsl`float lineDistNorm = sign(uv0.y) * pos.w;` : ""}

    ${x ? b.glsl`vLineDistance = lineWidth * lineDistNorm;` : ""}
    ${g ? b.glsl`vLineDistanceNorm = lineDistNorm;` : ""}

    ${v.roundCaps ? b.glsl`vCapPosition = isJoin ? vec2(0.0) : dpos;` : ""}

    pos.xy += dpos;
  `); v.stippleEnabled && (v.draped || m.vertex.code.add(b.glsl`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), m.vertex.code.add(b.glsl`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));`), v.draped ? m.vertex.code.add(b.glsl`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`) : m.vertex.code.add(b.glsl`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), m.vertex.code.add(b.glsl`
      float patternLength = ${v.stippleScaleWithLineWidth ? "lineSize * " : ""} stipplePatternPixelSize;

      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
      // The 0.5 factor on the screen length is to correct for pixel ratio (it is calculated at double resolution)
      ${e ? b.glsl`
            vec3 stippleSegmentInfo = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);
            vStippleDistanceLimits = stippleSegmentInfo.xy;
            vStipplePatternStretch = stippleSegmentInfo.z;`: b.glsl`
            vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);`}

      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
      if (segmentLengthScreenDouble >= 0.001) {
        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
        // original vertex positions, and slightly outside of that range at the displaced positions
        vec2 stippleDisplacement = pos.xy - segmentOrigin;
        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);

        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
      }

      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
      vStippleDistanceLimits *= pos.w;
      vStippleDistance *= pos.w;
    `)); m.vertex.code.add(b.glsl`pos.xy = pos.xy / screenSize * pos.w;
vColor = getColor();
vColor.a *= coverage;
gl_Position = pos;
}
}`); v.multipassTerrainEnabled && (m.fragment.include(u.ReadLinearDepth), m.include(n.multipassTerrainTest, v)); m.include(w.Slice, v); m.fragment.uniforms.add("intrinsicColor", "vec4"); m.fragment.include(h.ColorConversion); m.fragment.code.add(b.glsl`
  void main() {
    discardBySlice(vpos);
    ${v.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
  `); v.roundCaps && m.fragment.code.add(b.glsl`
    float fragmentRadius = length(vCapPosition);
    float fragmentSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
    float capCoverage = clamp(0.5 - fragmentSDF, 0.0, 1.0);
    if (capCoverage < ${b.glsl.float(l.symbolAlphaCutoff)}) {
      discard;
    }
  `); e ? m.fragment.code.add(b.glsl`
      vec2 stipplePosition = vec2(
        max(1.0 - getStippleSDF() * 2.0 * vStipplePatternStretch, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${b.glsl.float(l.symbolAlphaCutoff)}, stippleCoverage);
    `) : m.fragment.code.add(b.glsl`float stippleAlpha = getStippleAlpha();`); m.fragment.code.add(b.glsl`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);
vec4 color = intrinsicColor * vColor;`); m.fragment.uniforms.add("pixelRatio", "float"); v.innerColorEnabled && m.fragment.code.add(b.glsl`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`); m.fragment.code.add(b.glsl`vec4 finalColor = blendStipple(color, stippleAlpha);`); v.falloffEnabled && m.fragment.code.add(b.glsl`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`); m.fragment.code.add(b.glsl`
    if (finalColor.a < ${b.glsl.float(l.symbolAlphaCutoff)}) {
      discard;
    }

    ${7 === v.output ? b.glsl`gl_FragColor = vec4(finalColor.a);` : ""}
    ${0 === v.output ? b.glsl`gl_FragColor = highlightSlice(finalColor, vpos);` : ""}
    ${0 === v.output && v.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}
    ${4 === v.output ? b.glsl`gl_FragColor = vec4(1.0);` : ""}
    ${1 === v.output ? b.glsl`outputDepth(linearDepth);` : ""}
  }
  `); return m
          } const t = Object.freeze({ __proto__: null, NUM_ROUND_JOIN_SUBDIVISIONS: 1, build: f }); a.NUM_ROUND_JOIN_SUBDIVISIONS = 1; a.RibbonLineShader = t; a.build = f
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.RibbonVertexPosition = function (c, q) {
        c.vertex.uniforms.add("intrinsicWidth", "float"); q.vvSize ? (c.attributes.add("sizeFeatureAttribute", "float"), c.vertex.uniforms.add("vvSizeMinSize",
          "vec3"), c.vertex.uniforms.add("vvSizeMaxSize", "vec3"), c.vertex.uniforms.add("vvSizeOffset", "vec3"), c.vertex.uniforms.add("vvSizeFactor", "vec3"), c.vertex.code.add(w.glsl`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)) : (c.attributes.add("size", "float"), c.vertex.code.add(w.glsl`float getSize(){
return intrinsicWidth * size;
}`)); q.vvOpacity ? (c.attributes.add("opacityFeatureAttribute", "float"), c.vertex.constants.add("vvOpacityNumber", "int", 8), c.vertex.code.add(w.glsl`uniform float vvOpacityValues[vvOpacityNumber];
uniform float vvOpacityOpacities[vvOpacityNumber];
float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)) : c.vertex.code.add(w.glsl`vec4 applyOpacity( vec4 color ){
return color;
}`); q.vvColor ? (c.attributes.add("colorFeatureAttribute", "float"), c.vertex.constants.add("vvColorNumber", "int", 8), c.vertex.code.add(w.glsl`uniform float vvColorValues[vvColorNumber];
uniform vec4 vvColorColors[vvColorNumber];
vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)) : (c.attributes.add("color", "vec4"), c.vertex.code.add(w.glsl`vec4 getColor(){
return applyOpacity(color);
}`))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl": function () {
      define(["exports", "../util/RgbaFloatEncoding.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.OutputDepth = function (q, u) {
        q.fragment.include(w.RgbaFloatEncoding); 3 === u.output ? (q.extensions.add("GL_OES_standard_derivatives"), q.fragment.code.add(c.glsl`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 2.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`)) : 1 === u.output && q.fragment.code.add(c.glsl`void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_linearDepth);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl": function () {
      define(["exports", "../util/RgbaFloatEncoding.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
        const q = c.glsl.float(.4); a.LineStipple = function (u, y) {
          u.constants.add("stippleAlphaColorDiscard", "float", .001); u.constants.add("stippleAlphaHighlightDiscard", "float", .5); if (y.stippleEnabled) {
            {
              const n = !(y.draped && y.stipplePreferContinuous); u.fragment.include(w.RgbaFloatEncoding);
              u.vertex.uniforms.add("stipplePatternPixelSize", "float"); u.vertex.uniforms.add("pixelRatio", "float"); y.draped ? u.vertex.uniforms.add("worldToScreenRatio", "float") : (u.vertex.uniforms.add("worldToScreenPerDistanceRatio", "float"), u.vertex.uniforms.add("camPos", "vec3"), u.vertex.code.add(c.glsl`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - camPos);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)); u.varyings.add("vStippleDistance", "float"); y.stippleRequiresClamp && u.varyings.add("vStippleDistanceLimits", "vec2"); u.vertex.code.add(c.glsl`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${q};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `); u.vertex.code.add(c.glsl`
  ${y.stippleRequiresStretchMeasure ? c.glsl`vec3` : c.glsl`vec2`} computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {
  `); n && u.vertex.code.add(c.glsl`
      if (segmentLengthPseudoScreen >= patternLength) {

        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${y.stippleRequiresStretchMeasure ? c.glsl`return vec3(0.0, segmentLengthScreenRounded, repetitions / flooredRepetitions);` : c.glsl`return vec2(0.0, segmentLengthScreenRounded);`}
      }
    `); u.vertex.code.add(c.glsl`
      ${y.stippleRequiresStretchMeasure ? c.glsl`return vec3(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen, 1.0)` : c.glsl`return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen)`};
    }
  `); u.fragment.uniforms.add("stipplePatternTexture", "sampler2D"); u.fragment.uniforms.add("stipplePatternSDFNormalizer", "float"); u.fragment.uniforms.add("stipplePatternTextureSize", "float"); u.fragment.uniforms.add("stipplePatternPixelSizeInv", "float"); y.stippleOffColorEnabled && u.fragment.uniforms.add("stippleOffColor", "vec4"); u.fragment.code.add(c.glsl`float padTexture(float u) {
return (u * stipplePatternTextureSize + 1.0)/(stipplePatternTextureSize + 2.0);
}`); u.fragment.code.add(c.glsl`
    float getStippleSDF(out bool isClamped) {
      ${y.stippleRequiresClamp ? c.glsl`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`: c.glsl`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${y.stippleScaleWithLineWidth ? c.glsl`u *= vLineSizeInv;` : ""}
      u = padTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      return (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${y.stippleScaleWithLineWidth ? c.glsl`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);` : c.glsl`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `); y.stippleOffColorEnabled ? u.fragment.code.add(c.glsl`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`) : u.fragment.code.add(c.glsl`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)
            }
          } else u.fragment.code.add(c.glsl`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/RibbonLineTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/maybe ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/shading/VisualVariables.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../../../../chunks/RibbonLine.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
          const x = new Map([["position", 0], ["subdivisionFactor", 1], ["uv0", 2], ["auxpos1", 3], ["auxpos2", 4], ["size", 6], ["sizeFeatureAttribute", 6], ["color", 5], ["colorFeatureAttribute", 5], ["opacityFeatureAttribute", 7]]); d = function (r) {
            function A(B, C, D) { C = r.call(this, B, C, D) || this; C.stippleTextureRepository = B.stippleTextureRepository; return C } c._inheritsLoose(A, r); var z = A.prototype; z.initializeProgram = function (B) {
              var C = A.shader.get(); const D = this.configuration; C = C.build({
                OITEnabled: 0 ===
                  D.transparencyPassType, output: D.output, slicePlaneEnabled: D.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, draped: D.draped, stippleEnabled: this.stippleEnabled, stippleOffColorEnabled: D.stippleOffColorEnabled, stippleRequiresClamp: !0, stippleScaleWithLineWidth: D.stippleScaleWithLineWidth, stipplePreferContinuous: D.stipplePreferContinuous, roundCaps: D.roundCaps, roundJoins: D.roundJoins, vvColor: D.vvColor, vvSize: D.vvSize, vvInstancingEnabled: !0, vvOpacity: D.vvOpacity, falloffEnabled: D.falloffEnabled,
                innerColorEnabled: D.innerColorEnabled, multipassTerrainEnabled: D.multipassTerrainEnabled, cullAboveGround: D.cullAboveGround
              }); return new v.Program(B.rctx, C, x)
            }; z.dispose = function () { r.prototype.dispose.call(this); this.stippleTextureRepository.release(this.stipplePattern); this.stippleTextureBind = this.stipplePattern = null }; z.bindPass = function (B, C) {
              h.bindProjectionMatrix(this.program, C.camera.projectionMatrix); 4 === this.configuration.output && n.bindOutputHighlight(this.program, C); C.multipassTerrainEnabled &&
                (this.program.setUniform2fv("inverseViewport", C.inverseViewport), p.bindMultipassTerrainTexture(this.program, C)); this.program.setUniform1f("intrinsicWidth", B.width); this.program.setUniform4fv("intrinsicColor", B.color); this.program.setUniform1f("miterLimit", "miter" !== B.join ? 0 : B.miterLimit); this.program.setUniform2fv("cameraNearFar", C.camera.nearFar); this.program.setUniform1f("pixelRatio", C.camera.pixelRatio); this.program.setUniform2f("screenSize", C.camera.fullViewport[2], C.camera.fullViewport[3]); l.bindVisualVariablesUniformsWithOpacity(this.program,
                  B); if (this.stipplePattern !== B.stipplePattern) { var D = B.stipplePattern; this.stippleTextureBind = this.stippleTextureRepository.swap(this.stipplePattern, D); this.stipplePattern = D } if (this.stippleEnabled) {
                    const { pixelSize: E, sdfNormalizer: H, pixels: J } = u.isSome(this.stippleTextureBind) ? this.stippleTextureBind(this.program) : { pixelSize: 1, sdfNormalizer: 1, pixels: 1 }; this.program.setUniform1f("stipplePatternSDFNormalizer", H); this.program.setUniform1f("stipplePatternTextureSize", J); this.program.setUniform1f("stipplePatternPixelSize",
                      E); this.program.setUniform1f("stipplePatternPixelSizeInv", 1 / E); this.configuration.draped ? this.program.setUniform1f("worldToScreenRatio", 1 / C.screenToPCSRatio) : this.program.setUniform1f("worldToScreenPerDistanceRatio", 1 / C.camera.perScreenPixelRatio); this.configuration.stippleOffColorEnabled && (D = u.unwrap(B.stippleOffColor), this.program.setUniform4f("stippleOffColor", D[0], D[1], D[2], 3 < D.length ? D[3] : 1))
                  } this.configuration.falloffEnabled && this.program.setUniform1f("falloff", B.falloff); this.configuration.innerColorEnabled &&
                    (this.program.setUniform4fv("innerColor", u.unwrapOr(B.innerColor, B.color)), this.program.setUniform1f("innerWidth", B.innerWidth * C.camera.pixelRatio))
            }; z.bindDraw = function (B) { h.bindView(this.program, B); this.stippleEnabled && !this.configuration.draped && h.bindCameraPosition(this.program, B.origin, B.camera.viewInverseTransposeMatrix); y.bindSliceUniformsWithOrigin(this.program, this.configuration, B); this.program.rebindTextures() }; z.makePipelineState = function (B, C) {
              const D = this.configuration, E = 3 === B, H = 2 === B;
              return g.makePipelineState({ blending: 0 === D.output || 7 === D.output ? E ? t.blendingDefault : t.OITBlending(B) : null, depthTest: { func: t.OITDepthTest(B) }, depthWrite: E ? !D.transparent && D.writeDepth && g.defaultDepthWriteParams : t.OITDepthWrite(B), colorWrite: g.defaultColorWriteParams, stencilWrite: D.sceneHasOcludees ? m.stencilWriteMaskOn : null, stencilTest: D.sceneHasOcludees ? C ? m.stencilToolMaskBaseParams : m.stencilBaseAllZerosParams : null, polygonOffset: E || H ? D.polygonOffset && k : t.OITPolygonOffset })
            }; z.initializePipeline = function () {
              const B =
                this.configuration, C = B.polygonOffset && k; B.occluder && (this._occluderPipelineTransparent = g.makePipelineState({ blending: t.blendingDefault, polygonOffset: C, depthTest: m.depthCompareAlways, depthWrite: null, colorWrite: g.defaultColorWriteParams, stencilWrite: null, stencilTest: m.stencilToolTransparentOccluderParams }), this._occluderPipelineOpaque = g.makePipelineState({
                  blending: t.blendingDefault, polygonOffset: C, depthTest: m.depthCompareAlways, depthWrite: null, colorWrite: g.defaultColorWriteParams, stencilWrite: m.stencilWriteMaskOff,
                  stencilTest: m.stencilToolMaskOccluderParams
                }), this._occluderPipelineMaskWrite = g.makePipelineState({ blending: null, polygonOffset: C, depthTest: m.depthCompareLess, depthWrite: null, colorWrite: null, stencilWrite: m.stencilWriteMaskOn, stencilTest: m.stencilToolMaskBaseParams })); this._occludeePipelineState = this.makePipelineState(this.configuration.transparencyPassType, !0); return this.makePipelineState(this.configuration.transparencyPassType, !1)
            }; z.getPipelineState = function (B, C) {
              return C ? this._occludeePipelineState :
                this.configuration.occluder ? 10 === B ? this._occluderPipelineTransparent : 9 === B ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : r.prototype.getPipelineState.call(this, B, C)
            }; c._createClass(A, [{ key: "stippleEnabled", get: function () { return this.configuration.stippleEnabled && 4 !== this.configuration.output } }, { key: "primitiveType", get: function () { return 5 } }]); return A
          }(d.ShaderTechnique); d.shader = new b.ReloadableShaderModule(e.RibbonLineShader, () => new Promise((r, A) => a(["./RibbonLine.glsl"], r, A))); const k =
            { factor: 0, units: -4 }; b = function (r) {
              function A() {
                var z = r.apply(this, arguments) || this; z.output = 0; z.occluder = !1; z.slicePlaneEnabled = !1; z.transparent = !1; z.polygonOffset = !1; z.writeDepth = !1; z.draped = !1; z.stippleEnabled = !1; z.stippleOffColorEnabled = !1; z.stippleScaleWithLineWidth = !1; z.stipplePreferContinuous = !0; z.roundCaps = !1; z.roundJoins = !1; z.vvSize = !1; z.vvColor = !1; z.vvOpacity = !1; z.falloffEnabled = !1; z.innerColorEnabled = !1; z.sceneHasOcludees = !1; z.transparencyPassType = 3; z.multipassTerrainEnabled = !1; z.cullAboveGround =
                  !1; return z
              } c._inheritsLoose(A, r); return A
            }(f.ShaderTechniqueConfiguration); q.__decorate([f.parameter({ count: 8 })], b.prototype, "output", void 0); q.__decorate([f.parameter()], b.prototype, "occluder", void 0); q.__decorate([f.parameter()], b.prototype, "slicePlaneEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "transparent", void 0); q.__decorate([f.parameter()], b.prototype, "polygonOffset", void 0); q.__decorate([f.parameter()], b.prototype, "writeDepth", void 0); q.__decorate([f.parameter()], b.prototype,
              "draped", void 0); q.__decorate([f.parameter()], b.prototype, "stippleEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "stippleOffColorEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "stippleScaleWithLineWidth", void 0); q.__decorate([f.parameter()], b.prototype, "stipplePreferContinuous", void 0); q.__decorate([f.parameter()], b.prototype, "roundCaps", void 0); q.__decorate([f.parameter()], b.prototype, "roundJoins", void 0); q.__decorate([f.parameter()], b.prototype, "vvSize", void 0); q.__decorate([f.parameter()],
                b.prototype, "vvColor", void 0); q.__decorate([f.parameter()], b.prototype, "vvOpacity", void 0); q.__decorate([f.parameter()], b.prototype, "falloffEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "innerColorEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "sceneHasOcludees", void 0); q.__decorate([f.parameter({ count: 4 })], b.prototype, "transparencyPassType", void 0); q.__decorate([f.parameter()], b.prototype, "multipassTerrainEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "cullAboveGround",
                  void 0); w.RibbonLineTechnique = d; w.RibbonLineTechniqueConfiguration = b; w.ribbonVertexAttributeLocations = x; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/StencilUtils": function () {
      define(["exports"], function (a) {
      a.depthCompareAlways = { func: 519 }; a.depthCompareLess = { func: 513 }; a.renderWhenBitIsNotSet = w => ({ function: { func: 517, ref: w, mask: w }, operation: { fail: 7680, zFail: 7680, zPass: 7680 } }); a.replaceBitWhenDepthTestPasses = w => ({
        function: { func: 519, ref: w, mask: w }, operation: {
          fail: 7680,
          zFail: 7680, zPass: 7681
        }
      }); a.stencilBaseAllZerosParams = { function: { func: 519, ref: 2, mask: 2 }, operation: { fail: 7680, zFail: 7680, zPass: 0 } }; a.stencilToolMaskBaseParams = { function: { func: 519, ref: 2, mask: 2 }, operation: { fail: 7680, zFail: 7680, zPass: 7681 } }; a.stencilToolMaskOccluderParams = { function: { func: 514, ref: 2, mask: 2 }, operation: { fail: 7680, zFail: 7680, zPass: 7680 } }; a.stencilToolTransparentOccluderParams = { function: { func: 517, ref: 2, mask: 2 }, operation: { fail: 7680, zFail: 7680, zPass: 7680 } }; a.stencilWriteMaskOff = { mask: 0 }; a.stencilWriteMaskOn =
        { mask: 255 }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/RenderContext": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "./Camera"], function (a, w, c) {
        let q = function () {
          function y(n) { this.rctx = n; this.camera = null; this.lastFrameCamera = new c; this.pass = 0; this.slot = 2; this.highlightDepthTexture = null; this.renderOccludedMask = 13; this.hasOccludees = !1 } y.prototype.resetRenderOccludedMask = function () { this.renderOccludedMask = 13 }; w._createClass(y, [{
            key: "isHighlightPass",
            get: function () { return 5 === this.pass }
          }]); return y
        }(), u = function (y) { function n(p, l, h, b, d, f) { p = y.call(this, p) || this; p.offscreenRenderingHelper = l; p.scenelightingData = h; p.shadowMap = b; p.ssaoHelper = d; p.sliceHelper = f; return p } w._inheritsLoose(n, y); return n }(q); a.OverlayRenderContext = q; a.RenderContext = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/SortedRenderGeometryRenderer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/MapUtils ../../../../core/PooledArray ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ./ChangeSet ./rendererUtils ../materials/renderers/MergedRenderer".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        a.SortedRenderGeometryRenderer = function (m) {
          function e() { var x = m.apply(this, arguments) || this; x._pending = new v; x._changes = new d.ChangeSet; x._materialRenderers = new Map; x._sortedMaterialRenderers = new y; x._hasHighlights = !1; x._hasWater = !1; return x } w._inheritsLoose(e, m); var g = e.prototype; g.dispose = function () { this._changes.prune(); this._materialRenderers.forEach(x => x.dispose()); this._materialRenderers.clear(); this._sortedMaterialRenderers.clear() }; g.commitChanges = function () {
            if (!this.updating) return !1;
            this._processAddsRemoves(); let x = !1, k = !1, r = !1; f.splitRenderGeometryChangeSetByMaterial(this._changes).forEach((A, z) => { let B = this._materialRenderers.get(z); !B && 0 < A.adds.length && (B = new t.MergedRenderer(this.rctx, this.materialRepository, z), this._materialRenderers.set(z, B), r = k = x = !0); if (B) { var C = k || B.hasHighlights, D = r || B.hasWater; B.modify(A); k = k || C !== B.hasHighlights; r = r || D !== B.hasWater; B.isEmpty && (this._materialRenderers.delete(z), B.dispose(), x = !0) } }); this._changes.clear(); x && this.updateSortedMaterialRenderers();
            k && (this._hasHighlights = u.someMap(this._materialRenderers, A => A.hasHighlights)); r && (this._hasWater = u.someMap(this._materialRenderers, A => A.hasWater)); this.notifyChange("updating"); return !0
          }; g.add = function (x) { if (0 !== x.length) { var k = this._pending.empty; for (const r of x) this._pending.adds.add(r); k && this.notifyChange("updating") } }; g.remove = function (x) {
            const k = this._pending.empty; for (const r of x) this._pending.adds.has(r) ? (this._pending.removed.add(r), this._pending.adds.delete(r)) : this._pending.removed.has(r) ||
              this._pending.removes.add(r); k && !this._pending.empty && this.notifyChange("updating")
          }; g.modify = function (x, k) { const r = 0 === this._changes.updates.length; for (const A of x) x = this._changes.updates.pushNew(), x.renderGeometry = A, x.updateType = k; r && 0 < this._changes.updates.length && this.notifyChange("updating") }; g.updateLogic = function (x) { let k = !1; this._sortedMaterialRenderers.forAll(({ materialRenderer: r }) => k = r.updateLogic(x) || k); return k }; g.render = function (x, k) {
            for (let r = 0; r < this._sortedMaterialRenderers.length; r++) {
              const A =
                this._sortedMaterialRenderers.data[r]; A.material.shouldRender(x) && A.materialRenderer.render(k.slot, x.pass, k)
            }
          }; g.updateSortedMaterialRenderers = function () { this._sortedMaterialRenderers.clear(); let x = 0; this._materialRenderers.forEach((k, r) => { r.insertOrder = x++; this._sortedMaterialRenderers.push({ material: r, materialRenderer: k }) }); this._sortedMaterialRenderers.sort((k, r) => { const A = r.material.renderPriority - k.material.renderPriority; return 0 !== A ? A : k.material.insertOrder - r.material.insertOrder }) }; g._processAddsRemoves =
            function () { this._changes.adds.clear(); this._changes.removes.clear(); this._changes.adds.pushArray(Array.from(this._pending.adds)); this._changes.removes.pushArray(Array.from(this._pending.removes)); for (let x = 0; x < this._changes.updates.length;)this._pending.has(this._changes.updates.data[x].renderGeometry) ? this._changes.updates.removeUnorderedIndex(x) : x++; this._pending.clear() }; w._createClass(e, [{ key: "updating", get: function () { return !this._pending.empty || 0 < this._changes.updates.length } }, {
              key: "hasHighlights",
              get: function () { return this._hasHighlights }
            }, { key: "hasWater", get: function () { return this._hasWater } }, { key: "rendersOccluded", get: function () { return u.someMap(this._materialRenderers, x => x.rendersOccluded) } }, { key: "isEmpty", get: function () { return !this.updating && 0 === this._materialRenderers.size } }, { key: "test", get: function () { return { sortedMaterialRenderers: this._sortedMaterialRenderers } } }]); return e
        }(q); c.__decorate([n.property()], a.SortedRenderGeometryRenderer.prototype, "rctx", void 0); c.__decorate([n.property()],
          a.SortedRenderGeometryRenderer.prototype, "materialRepository", void 0); c.__decorate([n.property()], a.SortedRenderGeometryRenderer.prototype, "updating", null); a.SortedRenderGeometryRenderer = c.__decorate([b.subclass("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")], a.SortedRenderGeometryRenderer); let v = function () {
            function m() { this.adds = new Set; this.removes = new Set; this.removed = new Set } var e = m.prototype; e.has = function (g) { return this.adds.has(g) || this.removes.has(g) || this.removed.has(g) };
            e.clear = function () { this.adds.clear(); this.removes.clear(); this.removed.clear() }; w._createClass(m, [{ key: "empty", get: function () { return 0 === this.adds.size && 0 === this.removes.size && 0 === this.removed.size } }]); return m
          }(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/ChangeSet": function () {
      define(["exports", "../../../../core/PooledArray"], function (a, w) {
        let c = function () {
          function u() {
          this.adds = new w; this.removes = new w; this.updates = new w({
            allocator: n => n || new q, deallocator: n => { n.renderGeometry = null; return n }
          })
          } var y = u.prototype; y.clear = function () { this.adds.clear(); this.removes.clear(); this.updates.clear() }; y.prune = function () { this.adds.prune(); this.removes.prune(); this.updates.prune() }; return u
        }(), q = function () { }; a.ChangeSet = c; a.MaterialChangeSet = function () { this.adds = []; this.removes = []; this.updates = [] }; a.RenderGeometryUpdate = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/rendererUtils": function () {
      define(["exports", "./ChangeSet"], function (a,
        w) { a.splitRenderGeometryChangeSetByMaterial = function (c) { const q = new Map, u = y => { let n = q.get(y); n || (n = new w.MaterialChangeSet, q.set(y, n)); return n }; c.adds.forAll(y => { 1 <= y.data.indexCount && u(y.material).adds.push(y) }); c.removes.forAll(y => { 1 <= y.data.indexCount && u(y.material).removes.push(y) }); c.updates.forAll(y => { 1 <= y.renderGeometry.data.indexCount && u(y.renderGeometry.material).updates.push(y) }); return q }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/materials/renderers/MergedRenderer": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/MapUtils ../../../../../core/maybe ../../../../../core/PooledArray ../../../../../chunks/mat4 ../../../../../chunks/mat4f64 ../../../support/buffer/glUtil ../../lib/GLMaterials ../../lib/Util ../WaterMaterial ./Instance ./MergedGeometryBuffer ./MergedGeometryBufferPool ./utils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(H, J) { const M = new Map; for (const F of H) e(M, F, !0); for (const F of J) e(M, F, !1); return M } function e(H, J, M) { const F = J.origin; if (!q.isNone(F)) { var K = H.get(F.id); null == K && (K = new r(F.vec3), H.set(F.id, K)); M ? K.toAdd.push(J) : K.toRemove.push(J) } } function g(H, J) { let M; if (!H.some(K => { if (K.to - K.from < J) return !1; M = K; return !0 })) return null; const F = M.from; M.from += J; M.from >= M.to && H.removeUnordered(M); return F } function x(H) {
            const J = new Map; H.forAll(F => J.set(F.from, F));
            let M = !0; for (; M;)M = !1, H.forEach(F => { const K = J.get(F.to); K && (F.to = K.to, J.delete(K.from), H.removeUnordered(K), M = !0) })
          } let k = function () {
            function H(M, F, K) {
            this._rctx = M; this._materialRepository = F; this._material = K; this.type = "MergedRenderer"; this._dataByOrigin = new Map; this._renderCommandData = new u; this._hasOccludees = this._hasHighlights = !1; this._glMaterials = new l.GLMaterials(this._material, this._materialRepository); this._bufferWriter = K.createBufferWriter(); this._bufferPool = new t.MergedGeometryBufferPool(M,
              K.vertexAttributeLocations, p.glLayout(this._bufferWriter.vertexBufferLayout))
            } var J = H.prototype; J.dispose = function () { this._glMaterials.destroy(); this._dataByOrigin.forEach(M => M.buffer.dispose()); this._dataByOrigin.clear(); this._bufferPool.dispose() }; J.modify = function (M) { this.updateGeometries(M.updates); this.addAndRemoveGeometries(M.adds, M.removes); this.updateRenderCommands() }; J.addAndRemoveGeometries = function (M, F) {
              const K = this._bufferWriter, P = K.vertexBufferLayout.stride / 4, L = this._dataByOrigin, N = m(M,
                F); N.forEach((G, I) => {
                  N.delete(I); var O = G.toAdd.reduce((T, da) => T + K.elementCount(da.data), 0); let R = L.get(I); if (null == R) h.assert(0 === G.toRemove.length), R = new A(G.origin, new f.MergedGeometryBuffer(this._bufferPool, O * P)), L.set(I, R); else if (0 === G.toAdd.length && R.instances.size === G.toRemove.length) { R.buffer.dispose(); L.delete(I); return } let S = 0; R.instances.forEach(T => S += T.to - T.from); I = G.toRemove.reduce((T, da) => T + K.elementCount(da.data), 0); I = (S + O - I) * P; O = B; I < R.buffer.size / 2 ? this.removeAndRebuild(R, G.toRemove,
                    P, I, O) : 0 < G.toRemove.length && this.remove(R, G.toRemove, P, O); 0 < G.toAdd.length && (I = C, h.setMatrixTranslation3(I, -G.origin[0], -G.origin[1], -G.origin[2]), this.add(R, G.toAdd, P, I, O)); const Q = R.buffer.vao.vertexBuffers.geometry; x(O); O.forAll(({ from: T, to: da }) => { T < da && (T *= 4, Q.setSubData(R.buffer.array, T, T, 4 * da)) }); O.clear(); R.drawCommandsDirty = !0
                })
            }; J.updateGeometries = function (M) {
              const F = this._bufferWriter, K = F.vertexBufferLayout.stride / 4; for (const P of M) {
                M = P.renderGeometry; const L = this._dataByOrigin.get(M.origin.id),
                  N = L && L.instances.get(M.id); if (!N) break; const G = P.updateType; G & 1 && (N.isVisible = M.instanceParameters.visible); if (G & 9) { const I = M.instanceParameters.visible; N.hasHighlights = !!M.instanceParameters.highlights && I } G & 16 && (N.hasOccludees = !!M.instanceParameters.occludees); if (G & 6) {
                    const { array: I, vao: O } = L.buffer; v.calculateTransformRelativeToOrigin(M, D, E); F.write({ transformation: D, invTranspTransformation: E }, M.data, F.vertexBufferLayout.createView(I.buffer), N.from); h.assert(N.from + F.elementCount(M.data) === N.to,
                      "material VBO layout has changed"); O.vertexBuffers.geometry.setSubData(I, N.from * K * 4, N.from * K * 4, N.to * K * 4)
                  } L.drawCommandsDirty = !0
              }
            }; J.updateRenderCommands = function () {
            this._hasOccludees = this._hasHighlights = !1; this._dataByOrigin.forEach(F => {
            F.hasHiddenInstances = !1; F.hasHighlights = !1; F.hasOccludees = !1; c.someMap(F.instances, K => {
              K.isVisible ? (K.hasHighlights && (this._hasHighlights = !0, F.hasHighlights = !0), K.hasOccludees && (this._hasOccludees = !0, F.hasOccludees = !0)) : F.hasHiddenInstances = !0; return F.hasHiddenInstances &&
                F.hasHighlights && F.hasOccludees
            })
            }); const M = F => {
            F.drawCommandsDefault = null; F.drawCommandsHighlight = null; F.drawCommandsOccludees = null; F.drawCommandsShadowHighlightRest = null; if (0 !== F.instances.size) if (F.hasOccludees || F.hasHighlights || F.hasHiddenInstances) {
              var K = d.sortInstancesByRange(F.instances); F.drawCommandsDefault = []; F.drawCommandsHighlight = []; F.drawCommandsOccludees = []; F.drawCommandsShadowHighlightRest = []; for (const P of K) P.isVisible && (P.hasOccludees ? d.addOrMerge(F.drawCommandsOccludees, P) : d.addOrMerge(F.drawCommandsDefault,
                P), P.hasHighlights ? d.addOrMerge(F.drawCommandsHighlight, P) : d.addOrMerge(F.drawCommandsShadowHighlightRest, P))
            } else F.drawCommandsDefault = [{ first: 0, count: 4 * F.buffer.size / this._bufferWriter.vertexBufferLayout.stride }]
            }; this._dataByOrigin.forEach(F => { F.drawCommandsDirty && (M(F), F.drawCommandsDirty = !1) })
            }; J.updateLogic = function (M) { return this._material.update(M) }; J.render = function (M, F, K) {
              if (null != M && !this._material.requiresSlot(M, F)) return !1; const P = 5 === F || 7 === F; if (P && !this._hasHighlights) return !1; const L =
                6 === F, N = !(P || L); this._dataByOrigin.forEach(O => { if (!P || O.hasHighlights) { var R = (P ? O.drawCommandsHighlight : L && (O.hasOccludees || O.hasHighlights || O.hasHiddenInstances) ? O.drawCommandsShadowHighlightRest : O.drawCommandsDefault) || null, S = N && O.drawCommandsOccludees || null; (q.isSome(R) || q.isSome(S)) && this._renderCommandData.push(new z(O.origin, O.buffer, R, S)) } }); if (0 === this._renderCommandData.length) return !1; const G = this._rctx; F = this._glMaterials.load(G, F); if (q.isNone(F)) return this._renderCommandData.clear(),
                  !1; const I = F.beginSlot(K); I.bindPipelineState(G, M, !1); G.useProgram(I.program); F.bind(K, I); this._renderCommandData.forAll(({ origin: O, buffer: R, renderCommands: S, occludeeCommands: Q }) => { K.origin = O; I.bindDraw(K); I.ensureAttributeLocations(R.vao); G.bindVAO(R.vao); O = I.primitiveType; q.isSome(S) && this.renderCommands(G, O, S); q.isSome(Q) && (I.bindPipelineState(G, M, !0), this.renderCommands(G, O, Q), I.bindPipelineState(G, M, !1)) }); this._renderCommandData.clear(); return !0
            }; J.renderCommands = function (M, F, K) {
              for (let P = 0; P <
                K.length; P++)M.drawArrays(F, K[P].first, K[P].count)
            }; J.removeAndRebuild = function (M, F, K, P, L) { for (var N of F) M.instances.delete(N.id); var G = d.sortInstancesByRange(M.instances); M.instances.clear(); F = M.buffer.size; P = M.buffer.alloc(P); N = 0; for (const I of G) { G = I.from * K; const O = I.to * K; P.copy(N, G, O); I.from = N / K; N += O - G; I.to = N / K; M.instances.set(I.id, I) } L.push(new d.BufferRange(0, P.hasNewBuffer ? M.buffer.array.length : F)); P.dispose(); M.buffer.erase(N, L.back().to); M.holes.clear() }; J.remove = function (M, F, K, P) {
              for (const L of F) {
                F =
                L.id; const N = M.instances.get(F), G = N.from * K, I = N.to * K; M.buffer.erase(G, I); M.holes.push(new d.BufferRange(N.from, N.to)); M.instances.delete(F); P.push(new d.BufferRange(G, I))
              } x(M.holes)
            }; J.add = function (M, F, K, P, L) {
              const N = this._bufferWriter; let G = N.vertexBufferLayout.createView(M.buffer.array.buffer); for (const O of F) {
                var I = q.isSome(O.transformation) ? y.multiply(D, P, O.transformation) : P; y.invert(E, I); const R = y.transpose(E, E); F = N.elementCount(O.data); const S = F * K; let Q = g(M.holes, F); q.isNone(Q) && (Q = M.buffer.size /
                  K, M.buffer.grow(S), G = N.vertexBufferLayout.createView(M.buffer.array.buffer)); N.write({ transformation: I, invTranspTransformation: R }, O.data, G, Q); I = O.instanceParameters.visible; F = new d.Instance(O.id, Q, Q + F, I, !!O.instanceParameters.highlights && I, !!O.instanceParameters.occludees); h.assert(null == M.instances.get(O.id)); M.instances.set(O.id, F); L.push(new d.BufferRange(F.from * K, F.to * K))
              }
            }; w._createClass(H, [{ key: "isEmpty", get: function () { return 0 === this._dataByOrigin.size } }, { key: "hasHighlights", get: function () { return this._hasHighlights } },
            { key: "hasOccludees", get: function () { return this._hasOccludees } }, { key: "hasWater", get: function () { return !this.isEmpty && this._material instanceof b.WaterMaterial } }, { key: "rendersOccluded", get: function () { return !this.isEmpty && 1 !== this._material.renderOccluded } }, { key: "test", get: function () { return { material: this._material, glMaterials: this._glMaterials } } }]); return H
          }(), r = function (H) { this.origin = H; this.toAdd = []; this.toRemove = [] }, A = function (H, J) {
          this.origin = H; this.buffer = J; this.instances = new Map; this.holes = new u({ deallocator: null });
            this.drawCommandsDirty = this.hasOccludees = this.hasHighlights = this.hasHiddenInstances = !1
          }, z = function (H, J, M, F) { this.origin = H; this.buffer = J; this.renderCommands = M; this.occludeeCommands = F }; const B = new u({ deallocator: null }), C = n.create(), D = n.create(), E = n.create(); a.MergedRenderer = k; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/WaterMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../lib/AnimationTimer ../lib/GLMaterials ../lib/Material ../lib/OrderIndependentTransparency ./WaterGLMaterial ./WaterTechnique ./internal/DefaultBufferWriter ./internal/MaterialUtil ./internal/waterMaterialUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          u = function (d) {
            function f(v) { v = d.call(this, v, b.defaultWaterMaterialParameters) || this; v._techniqueConfig = new p.WaterTechniqueConfiguration; v.animation = new c.AnimationTimer; return v } w._inheritsLoose(f, d); var t = f.prototype; t.getTechniqueConfig = function (v, m) {
              this._techniqueConfig.output = v; this._techniqueConfig.writeDepth = this.parameters.writeDepth; this._techniqueConfig.receiveShadows = this.parameters.receiveShadows; this._techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled;
              this._techniqueConfig.transparent = this.parameters.transparent; this._techniqueConfig.useSSR = this.parameters.ssrEnabled; this._techniqueConfig.isDraped = this.parameters.isDraped; this._techniqueConfig.transparencyPassType = m.transparencyPassType; this._techniqueConfig.enableOffset = m.camera.relativeElevation < y.OITPolygonOffsetLimit; this._techniqueConfig.multipassTerrainEnabled = m.multipassTerrainEnabled; this._techniqueConfig.cullAboveGround = m.cullAboveGround; return this._techniqueConfig
            }; t.update = function (v) {
              this.animation.enabled =
              35E3 > Math.sqrt(this.parameters.waveTextureRepeat / this.parameters.waveStrength) * Math.min(v.camera.relativeElevation, v.camera.distance); v = this.animation.advance(v); return this.animation.enabled && v
            }; t.intersect = function (v, m, e, g, x, k, r) { h.intersectTriangleGeometry(v, m, g, x, k, void 0, r) }; t.requiresSlot = function (v, m) {
              switch (q.outputFromPass(m)) { case 2: return 21 === v; case 0: if (this.parameters.isDraped) return 20 === v; break; case 4: return 2 === v || 20 === v }m = 2; this.parameters.transparent && (m = this.parameters.writeDepth ?
                4 : 7); return v === m
            }; t.createGLMaterial = function (v) { if (0 === v.output && this.parameters.isDraped) return v.output = 5, new n.WaterGLMaterial(v); switch (v.output) { case 0: case 2: case 4: case 7: return new n.WaterGLMaterial(v) }return null }; t.createBufferWriter = function () { return new l.DefaultBufferWriter(l.PositionUVLayout) }; return f
          }(u.Material); a.WaterMaterial = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/AnimationTimer": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers",
        "../../../../core/maybe", "../../../../core/time"], function (a, w, c, q) { let u = function () { function y() { this.enabled = !0; this._time = 0 } y.prototype.advance = function (n) { if (c.isSome(n.forcedTime)) { if (this._time === n.forcedTime) return !1; this._time = n.forcedTime; return !0 } return this.enabled && 0 !== n.dt ? (this._time += n.dt, !0) : !1 }; w._createClass(y, [{ key: "time", get: function () { return q.Milliseconds(this._time) } }]); return y }(); a.AnimationTimer = u; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/materials/WaterGLMaterial": function () {
      define(["exports",
        "../../../../chunks/_rollupPluginBabelHelpers", "../lib/GLMaterial", "./WaterTechnique"], function (a, w, c, q) {
          c = function (u) {
            function y() { return u.apply(this, arguments) || this } w._inheritsLoose(y, u); var n = y.prototype; n.updateParameters = function (p) { return this.ensureTechnique(q.WaterTechnique, p) }; n.setElapsedTimeUniform = function (p) { p.setUniform1f("timeElapsed", .001 * this._material.animation.time * this._material.parameters.animationSpeed) }; n._updateShadowState = function (p) {
            p.shadowMappingEnabled !== this._material.parameters.receiveShadows &&
              this._material.setParameters({ receiveShadows: p.shadowMappingEnabled })
            }; n._updateSSRState = function (p) { p.ssrEnabled !== this._material.parameters.ssrEnabled && this._material.setParameters({ ssrEnabled: p.ssrEnabled }) }; n.ensureResources = function (p) { const l = this._techniqueRep.constructionContext.waterTextureRepository; l.ready || l.updating || l.loadTextures(p); return l.ready ? 2 : 1 }; n.beginSlot = function (p) { 0 === this._output && (this._updateShadowState(p), this._updateSSRState(p)); return this.updateParameters(p) }; n.bind =
              function (p, l) { l.bindPass(this._material.parameters, p); 2 !== this._output && 0 !== this._output || this.setElapsedTimeUniform(l.program) }; return y
          }(c); a.WaterGLMaterial = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/WaterTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/shading/ReadShadowMap.glsl ../core/shaderLibrary/shading/ScreenSpaceReflections.glsl ../core/shaderLibrary/shading/WaterDistortion.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/OrderIndependentTransparency ../lib/Program ../../../../chunks/WaterSurface.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
          f = function (k) {
            function r(z, B, C) { B = k.call(this, z, B, C) || this; B._textureRepository = z.waterTextureRepository; return B } c._inheritsLoose(r, k); var A = r.prototype; A.initializeProgram = function (z) {
              var B = r.shader.get(); const C = this.configuration; B = B.build({
                OITEnabled: 0 === C.transparencyPassType, output: C.output, viewingMode: z.viewingMode, slicePlaneEnabled: C.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, receiveShadows: C.receiveShadows,
                pbrMode: 3, useCustomDTRExponentForWater: !0, ssrEnabled: C.useSSR, highStepCount: !0, multipassTerrainEnabled: C.multipassTerrainEnabled, cullAboveGround: C.cullAboveGround
              }); return new e.Program(z.rctx, B, v.Default3D)
            }; A.bindPass = function (z, B) {
              b.bindProjectionMatrix(this.program, B.camera.projectionMatrix); B.multipassTerrainEnabled && (this.program.setUniform2fv("cameraNearFar", B.camera.nearFar), this.program.setUniform2fv("inverseViewport", B.inverseViewport), n.bindMultipassTerrainTexture(this.program, B)); 0 ===
                this.configuration.output && (B.lighting.setUniforms(this.program, !1), l.bindSSRUniforms(this.program, B)); if (0 === this.configuration.output || 2 === this.configuration.output) h.bindWaterDistortionUniforms(this.program, z), this._textureRepository.bind(this.program); this.program.setUniform4fv("waterColor", z.color); 4 === this.configuration.output && y.bindOutputHighlight(this.program, B)
            }; A.bindDraw = function (z) {
              b.bindView(this.program, z); this.program.rebindTextures(); 0 !== this.configuration.output && 7 !== this.configuration.output ||
                b.bindCameraPosition(this.program, z.origin, z.camera.viewInverseTransposeMatrix); 0 === this.configuration.output && p.bindReadShadowMapUniforms(this.program, z); 0 !== this.configuration.output && 7 !== this.configuration.output && 4 !== this.configuration.output || u.bindSliceUniformsWithOrigin(this.program, this.configuration, z)
            }; A.setPipelineState = function (z) {
              const B = this.configuration, C = 3 === z, D = 2 === z; return x.makePipelineState({
                blending: 2 !== B.output && 4 !== B.output && B.transparent ? C ? m.blendingDefault : m.OITBlending(z) :
                  null, depthTest: { func: m.OITDepthTest(z) }, depthWrite: C ? B.writeDepth && x.defaultDepthWriteParams : m.OITDepthWrite(z), colorWrite: x.defaultColorWriteParams, polygonOffset: C || D ? null : m.getOITPolygonOffset(B.enableOffset)
              })
            }; A.initializePipeline = function () { return this.setPipelineState(this.configuration.transparencyPassType) }; return r
          }(f.ShaderTechnique); f.shader = new d.ReloadableShaderModule(g.WaterSurface, () => new Promise((k, r) => a(["../shaders/WaterSurface.glsl"], k, r))); d = function (k) {
            function r() {
              var A = k.apply(this,
                arguments) || this; A.output = 0; A.receiveShadows = !1; A.slicePlaneEnabled = !1; A.transparent = !1; A.enableOffset = !0; A.writeDepth = !1; A.useSSR = !1; A.isDraped = !1; A.transparencyPassType = 3; A.multipassTerrainEnabled = !1; A.cullAboveGround = !1; return A
            } c._inheritsLoose(r, k); return r
          }(t.ShaderTechniqueConfiguration); q.__decorate([t.parameter({ count: 8 })], d.prototype, "output", void 0); q.__decorate([t.parameter()], d.prototype, "receiveShadows", void 0); q.__decorate([t.parameter()], d.prototype, "slicePlaneEnabled", void 0); q.__decorate([t.parameter()],
            d.prototype, "transparent", void 0); q.__decorate([t.parameter()], d.prototype, "enableOffset", void 0); q.__decorate([t.parameter()], d.prototype, "writeDepth", void 0); q.__decorate([t.parameter()], d.prototype, "useSSR", void 0); q.__decorate([t.parameter()], d.prototype, "isDraped", void 0); q.__decorate([t.parameter({ count: 4 })], d.prototype, "transparencyPassType", void 0); q.__decorate([t.parameter()], d.prototype, "multipassTerrainEnabled", void 0); q.__decorate([t.parameter()], d.prototype, "cullAboveGround", void 0);
          w.WaterTechnique = f; w.WaterTechniqueConfiguration = d; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl": function () {
      define(["exports", "../util/RgbaFloatEncoding.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.ReadShadowMap = function (q) {
        q.fragment.include(w.RgbaFloatEncoding); q.fragment.uniforms.add("uShadowMapTex", "sampler2D"); q.fragment.uniforms.add("uShadowMapNum", "int"); q.fragment.uniforms.add("uShadowMapDistance",
          "vec4"); q.fragment.uniforms.add("uShadowMapMatrix", "mat4", 4); q.fragment.uniforms.add("uDepthHalfPixelSz", "float"); q.fragment.code.add(c.glsl`int chooseCascade(float _linearDepth, out mat4 mat) {
vec4 distance = uShadowMapDistance;
float depth = _linearDepth;
int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;
mat = i == 0 ? uShadowMapMatrix[0] : i == 1 ? uShadowMapMatrix[1] : i == 2 ? uShadowMapMatrix[2] : uShadowMapMatrix[3];
return i;
}
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, vec3 lvpos) {
return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;
}
float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {
return rgba2float(texture2D(_depthTex, uv));
}
float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {
return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
}
float filterShadow(vec2 uv, vec3 lvpos, float halfPixelSize, sampler2D _depthTex) {
float texSize = 0.5 / halfPixelSize;
vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);
float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);
float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);
float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);
float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);
return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
}
float readShadowMap(const in vec3 _vpos, float _linearDepth) {
mat4 mat;
int i = chooseCascade(_linearDepth, mat);
if (i >= uShadowMapNum) { return 0.0; }
vec3 lvpos = lightSpacePosition(_vpos, mat);
if (lvpos.z >= 1.0) { return 0.0; }
if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }
vec2 uv = cascadeCoordinates(i, lvpos);
return filterShadow(uv, lvpos, uDepthHalfPixelSz, uShadowMapTex);
}`)
      }; a.bindReadShadowMapUniforms = function (q, u) { u.shadowMappingEnabled && (u.shadowMap.bind(q), u.shadowMap.bindView(q, u.origin)) }; a.bindReadShadowMapView = function (q, u) { u.shadowMappingEnabled && u.shadowMap.bindView(q, u.origin) }; a.bindReadShadowMapViewCustomOrigin = function (q, u, y) { u.shadowMappingEnabled && u.shadowMap.bindView(q, y) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceReflections.glsl": function () {
      define(["exports", "../output/ReadLinearDepth.glsl",
        "./Reprojection.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
        a.ScreenSpaceReflections = function (u, y) {
          u.fragment.uniforms.add("nearFar", "vec2"); u.fragment.uniforms.add("depthMapView", "sampler2D"); u.fragment.uniforms.add("ssrViewMat", "mat4"); u.fragment.uniforms.add("invResolutionHeight", "float"); u.fragment.include(w.ReadLinearDepth); u.include(c.Reprojection); u.fragment.code.add(q.glsl`
  const int maxSteps = ${y.highStepCount ? "150;" : "75;"}

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(rpProjectionMat, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(rpProjectionMat, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(rpProjectionMat, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMapView, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
          return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)
        }; a.bindSSRUniforms = function (u, y) { y.ssrEnabled && (u.bindTexture(y.linearDepthTexture, "depthMapView"), u.setUniform2fv("nearFar", y.camera.nearFar), u.setUniformMatrix4fv("ssrViewMat", y.camera.viewMatrix), u.setUniform1f("invResolutionHeight", 1 / y.camera.height), c.bindReprojectionUniforms(u, y)) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/Reprojection.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.Reprojection =
        function (c) {
          c.fragment.uniforms.add("lastFrameColorMap", "sampler2D"); c.fragment.uniforms.add("reprojectionMat", "mat4"); c.fragment.uniforms.add("rpProjectionMat", "mat4"); c.fragment.code.add(w.glsl`vec2 reprojectionCoordinate(vec3 projectionCoordinate)
{
vec4 zw = rpProjectionMat * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
vec4 reprojectedCoord = reprojectionMat * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
reprojectedCoord.xy /= reprojectedCoord.w;
return reprojectedCoord.xy * 0.5 + 0.5;
}`)
        }; a.bindReprojectionUniforms = function (c, q) { c.bindTexture(q.lastFrameColorTexture, "lastFrameColorMap"); c.setUniformMatrix4fv("reprojectionMat", q.reprojectionMatrix); c.setUniformMatrix4fv("rpProjectionMat", q.camera.projectionMatrix) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl": function () {
      define(["exports", "./FoamRendering.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.WaterDistortion = function (q) {
        q.fragment.uniforms.add("texWaveNormal",
          "sampler2D"); q.fragment.uniforms.add("texWavePerturbation", "sampler2D"); q.fragment.uniforms.add("waveParams", "vec4"); q.fragment.uniforms.add("waveDirection", "vec2"); q.include(w.FoamIntensity); q.fragment.code.add(c.glsl`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture2D(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)
      }; a.bindWaterDistortionUniforms = function (q, u) { q.setUniform4f("waveParams", u.waveStrength, u.waveTextureRepeat, u.flowStrength, u.flowOffset); q.setUniform2f("waveDirection", u.waveDirection[0] * u.waveVelocity, u.waveDirection[1] * u.waveVelocity) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/FoamRendering.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.FoamColor = function (c) {
        c.fragment.code.add(w.glsl`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)
      }; a.FoamIntensity = function (c) {
        c.fragment.code.add(w.glsl`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/WaterSurface.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(g) {
            const x = new v.ShaderBuilder; x.include(q.Transform, { linearDepth: !1 }); x.attributes.add("position", "vec3"); x.attributes.add("uv0", "vec2"); x.vertex.uniforms.add("proj", "mat4").add("view", "mat4").add("localOrigin", "vec3"); x.vertex.uniforms.add("waterColor", "vec4"); if (0 === g.output || 7 === g.output) x.include(p.NormalUtils, g), x.include(w.ForwardLinearDepth, g), x.varyings.add("vuv", "vec2"), x.varyings.add("vpos", "vec3"), x.varyings.add("vnormal", "vec3"), x.varyings.add("vtbnMatrix",
              "mat3"), g.multipassTerrainEnabled && x.varyings.add("depth", "float"), x.vertex.code.add(t.glsl`
      void main(void) {
        if (waterColor.a < ${t.glsl.float(d.symbolAlphaCutoff)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${g.multipassTerrainEnabled ? "depth \x3d (view * vec4(vpos, 1.0)).z;" : ""}

        gl_Position = transformPosition(proj, view, vpos);
        ${0 === g.output ? "forwardLinearDepth();" : ""}
      }
    `); g.multipassTerrainEnabled && (x.fragment.include(y.ReadLinearDepth), x.include(n.multipassTerrainTest, g)); 7 === g.output && (x.include(c.Slice, g), x.fragment.uniforms.add("waterColor", "vec4"), x.fragment.code.add(t.glsl`
        void main() {
          discardBySlice(vpos);
          ${g.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

          gl_FragColor = vec4(waterColor.a);
        }
      `)); 0 === g.output && (x.include(b.WaterDistortion, g), x.include(c.Slice, g), g.receiveShadows && x.include(l.ReadShadowMap, g), x.include(h.Water, g), x.fragment.uniforms.add("waterColor", "vec4").add("lightingMainDirection", "vec3").add("lightingMainIntensity", "vec3").add("camPos", "vec3").add("timeElapsed", "float").add("view", "mat4"), x.fragment.include(f.ColorConversion), x.fragment.code.add(t.glsl`
      void main() {
        discardBySlice(vpos);
        ${g.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - camPos);
        float shadow = ${g.receiveShadows ? t.glsl`1.0 - readShadowMap(vpos, linearDepth)` : "1.0"};
        vec4 vPosView = view*vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, lightingMainDirection, waterColor.rgb, lightingMainIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz), waterColor.w);

        // gamma correction
        gl_FragColor = delinearizeGamma(final);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${g.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)); 2 === g.output && (x.include(p.NormalUtils, g), x.include(b.WaterDistortion, g), x.include(c.Slice, g), x.varyings.add("vpos", "vec3"), x.varyings.add("vuv", "vec2"), x.vertex.code.add(t.glsl`
        void main(void) {
          if (waterColor.a < ${t.glsl.float(d.symbolAlphaCutoff)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `), x.fragment.uniforms.add("timeElapsed", "float"), x.fragment.code.add(t.glsl`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
gl_FragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`)); 5 === g.output && (x.varyings.add("vpos", "vec3"), x.vertex.code.add(t.glsl`
        void main(void) {
          if (waterColor.a < ${t.glsl.float(d.symbolAlphaCutoff)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `), x.fragment.uniforms.add("waterColor", "vec4"), x.fragment.code.add(t.glsl`void main() {
gl_FragColor = waterColor;
}`)); 4 === g.output && (x.include(u.OutputHighlight), x.varyings.add("vpos", "vec3"), x.vertex.code.add(t.glsl`
      void main(void) {
        if (waterColor.a < ${t.glsl.float(d.symbolAlphaCutoff)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `), x.include(c.Slice, g), x.fragment.code.add(t.glsl`void main() {
discardBySlice(vpos);
outputHighlight();
}`)); return x
          } const e = Object.freeze({ __proto__: null, build: m }); a.WaterSurface = e; a.build = m
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl": function () {
      define(["exports", "../shaderModules/interfaces"], function (a, w) {
      a.ForwardLinearDepth = function (c, q) {
      0 === q.output && q.receiveShadows ? (c.varyings.add("linearDepth", "float"), c.vertex.code.add(w.glsl`void forwardLinearDepth() { linearDepth = gl_Position.w; }`)) : 1 === q.output || 3 === q.output ? (c.varyings.add("linearDepth", "float"), c.vertex.uniforms.add("cameraNearFar",
        "vec2"), c.vertex.code.add(w.glsl`void forwardLinearDepth() {
linearDepth = (-position_view().z - cameraNearFar[0]) / (cameraNearFar[1] - cameraNearFar[0]);
}`)) : c.vertex.code.add(w.glsl`void forwardLinearDepth() {}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.NormalUtils = function (c, q) {
        1 === q.viewingMode ? c.vertex.code.add(w.glsl`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`) : c.vertex.code.add(w.glsl`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`); 1 === q.viewingMode ? c.vertex.code.add(w.glsl`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`) : c.vertex.code.add(w.glsl`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl": function () {
      define("exports ./FoamRendering.glsl ./Gamma.glsl ./PhysicallyBasedRendering.glsl ./ScreenSpaceReflections.glsl ../../shaderModules/interfaces".split(" "), function (a, w, c, q, u, y) {
      a.Water = function (n, p) {
        n.include(q.PhysicallyBasedRendering, p); n.include(c.Gamma); n.include(w.FoamColor); p.ssrEnabled && n.include(u.ScreenSpaceReflections, p); n.fragment.constants.add("fresnelSky",
          "vec3", [.02, 1, 15]).add("fresnelMaterial", "vec2", [.02, .1]).add("roughness", "float", .015).add("foamIntensityExternal", "float", 1.7).add("ssrIntensity", "float", .65).add("ssrHeightFadeStart", "float", 3E5).add("ssrHeightFadeEnd", "float", 5E5).add("waterDiffusion", "float", .775).add("waterSeeColorMod", "float", .8).add("correctionViewingPowerFactor", "float", .4).add("skyZenitColor", "vec3", [.52, .68, .9]).add("skyColor", "vec3", [.67, .79, .9]); n.fragment.code.add(y.glsl`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`); n.fragment.code.add(y.glsl`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 positionView) {
float reflectionHit = 0.;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}`); p.ssrEnabled ? n.fragment.code.add(y.glsl`vec4 viewPosition = vec4(positionView.xyz, 1.0);
vec3 viewDir = normalize(viewPosition.xyz);
vec4 viewNormalVectorCoordinate = ssrViewMat *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = ssrViewMat *vec4(localUp, 0.0);
float correctionViewingFactor = pow(max(dot(-viewDir, viewUp.xyz), 0.0), correctionViewingPowerFactor);
vec3 viewNormalCorrected = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrected));
vec3 hitCoordinate = screenSpaceIntersection( normalize(reflected), viewPosition.xyz, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -positionView.z);
reflectionHit = waterDiffusion * clamp(1.0 - (1.3*dCoords.y), 0.0, 1.0) * heightMod;
reflectedColor = linearizeGamma(texture2D(lastFrameColorMap, reprojectedCoordinate).xyz)* reflectionHit * fresnelModifier.y * ssrIntensity;
}
float seeColorMod =  mix(waterSeeColorMod, waterSeeColorMod*0.5, reflectionHit);
return tonemapACES((1. - reflectionHit) * reflSky + reflectedColor + reflSea * seeColorMod + specular + foam);
}`) : n.fragment.code.add(y.glsl`return tonemapACES(reflSky + reflSea * waterSeeColorMod + specular + foam);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl": function () {
      define(["exports", "./AnalyticalSkyModel.glsl", "./PiUtils.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
      a.PhysicallyBasedRendering = function (u, y) {
        const n = u.fragment.code; u.include(c.PiUtils); if (3 === y.pbrMode || 4 === y.pbrMode) n.add(q.glsl`
    struct PBRShadingWater
    {
        float NdotL;   // cos angle between normal and light direction
        float NdotV;   // cos angle between normal and view direction
        float NdotH;   // cos angle between normal and half vector
        float VdotH;   // cos angle between view direction and half vector
        float LdotH;   // cos angle between light direction and half vector
        float VdotN;   // cos angle between view direction and normal vector
    };

    float dtrExponent = ${y.useCustomDTRExponentForWater ? "2.2" : "2.0"};
    `), n.add(q.glsl`vec3 fresnelReflection(float angle, vec3 f0, float f90) {
return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);
}`), n.add(q.glsl`float normalDistributionWater(float NdotH, float roughness)
{
float r2 = roughness * roughness;
float NdotH2 = NdotH * NdotH;
float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;
return r2 / denom;
}`), n.add(q.glsl`float geometricOcclusionKelemen(float LoH)
{
return 0.25 / (LoH * LoH);
}`), n.add(q.glsl`vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)
{
vec3  F = fresnelReflection(props.VdotH, F0, F0Max);
float dSun = normalDistributionWater(props.NdotH, roughness);
float V = geometricOcclusionKelemen(props.LdotH);
float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);
float strengthSunHaze  = 1.2;
float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze)*strengthSunHaze;
return ((dSun + dSunHaze) * V) * F;
}
vec3 tonemapACES(const vec3 x) {
return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);
}`); else if (1 === y.pbrMode || 2 === y.pbrMode) u.include(w.AnalyticalSkyModel), n.add(q.glsl`struct PBRShadingInfo
{
float NdotL;
float NdotV;
float NdotH;
float VdotH;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), n.add(q.glsl`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), n.add(q.glsl`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`), n.add(q.glsl`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), n.add(q.glsl`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), n.add(q.glsl`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.AnalyticalSkyModel = function (c) {
        c = c.fragment.code; c.add(w.glsl`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`); c.add(w.glsl`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`); c.add(w.glsl`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/internal/DefaultBufferWriter": function () {
      define(["exports", "../../../support/buffer/InterleavedLayout", "./bufferWriterUtils"], function (a, w, c) {
        const q = w.newLayout().vec3f("position"), u = w.newLayout().vec3f("position").vec2f("uv0"); w = w.newLayout().vec3f("position").vec4u8("color"); let y = function () {
          function n(l) { this.vertexBufferLayout = l } var p = n.prototype; p.allocate = function (l) { return this.vertexBufferLayout.createBuffer(l) };
          p.elementCount = function (l) { return l.indices.get("position").length }; p.write = function (l, h, b, d) { c.writeDefaultAttributes(h, this.vertexBufferLayout, l.transformation, l.invTranspTransformation, b, d) }; return n
        }(); a.DefaultBufferWriter = y; a.PositionColorLayout = w; a.PositionLayout = q; a.PositionUVLayout = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/internal/waterMaterialUtils": function () {
      define(["exports", "../../../../../chunks/vec2f64", "../../lib/Material"], function (a,
        w, c) {
          w = { waveStrength: .06, waveTextureRepeat: 32, waveDirection: w.fromValues(1, 0), waveVelocity: .05, flowStrength: .015, flowOffset: -.5, animationSpeed: .35, color: [0, 0, 0, 0], transparent: !0, writeDepth: !0, slicePlaneEnabled: !1, isDraped: !1, receiveShadows: !0, ssrEnabled: !1, ...c.materialParametersDefaults }; a.defaultWaterMaterialParameters = w; a.wavePresets = {
            "calm-small": { waveStrength: .005, perturbationStrength: .02, textureRepeat: 12, waveVelocity: .01 }, "rippled-small": {
              waveStrength: .02, perturbationStrength: .09, textureRepeat: 32,
              waveVelocity: .07
            }, "slight-small": { waveStrength: .05, perturbationStrength: .07, textureRepeat: 28, waveVelocity: .1 }, "moderate-small": { waveStrength: .075, perturbationStrength: .07, textureRepeat: 24, waveVelocity: .1 }, "calm-medium": { waveStrength: .003125, perturbationStrength: .01, textureRepeat: 8, waveVelocity: .02 }, "rippled-medium": { waveStrength: .035, perturbationStrength: .015, textureRepeat: 12, waveVelocity: .07 }, "slight-medium": { waveStrength: .06, perturbationStrength: .015, textureRepeat: 8, waveVelocity: .12 }, "moderate-medium": {
              waveStrength: .09,
              perturbationStrength: .03, textureRepeat: 4, waveVelocity: .12
            }, "calm-large": { waveStrength: .01, perturbationStrength: 0, textureRepeat: 4, waveVelocity: .05 }, "rippled-large": { waveStrength: .025, perturbationStrength: .01, textureRepeat: 8, waveVelocity: .11 }, "slight-large": { waveStrength: .06, perturbationStrength: .02, textureRepeat: 3, waveVelocity: .13 }, "moderate-large": { waveStrength: .14, perturbationStrength: .03, textureRepeat: 2, waveVelocity: .15 }
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/renderers/Instance": function () {
      define(["exports",
        "../../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
          function c(n, p) { return n.from === p.from ? n.to - p.to : n.from - p.from } let q = function (n) { this.first = n.from; this.count = n.to - n.from }, u = function (n = 0, p = 0) { this.from = n; this.to = p }, y = function (n) { function p(l, h, b, d, f, t) { h = n.call(this, h, b) || this; h.id = l; h.isVisible = d; h.hasHighlights = f; h.hasOccludees = t; return h } w._inheritsLoose(p, n); return p }(u); a.BufferRange = u; a.DrawCommand = q; a.Instance = y; a.addOrMerge = function (n, p) {
            if (0 === n.length) n.push(new q(p)); else {
              var l =
                n[n.length - 1]; l.first + l.count >= p.from ? l.count = p.from - l.first + p.to - p.from : n.push(new q(p))
            }
          }; a.sortInstancesByRange = function (n) { return Array.from(n.values()).sort(c) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/renderers/MergedGeometryBuffer": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        function c(u, y, n) { return y <= n ? u >= n ? u : 65536 * Math.ceil(Math.max(2 * u, n) / 65536) : u <= 2 * n ? u : 65536 * Math.ceil(n / 65536) } let q = function () {
          function u(n,
            p) { this._pool = n; this._size = 0; this._buffer = n.newBuffer(65536 * Math.ceil(p / 65536)) } var y = u.prototype; y.dispose = function () { this._buffer = this._pool.deleteBuffer(this._buffer); this._size = 0 }; y.release = function () { this.erase(0, this._size); this.dispose() }; y.grow = function (n) { this._resize(this._size + n, !0).dispose() }; y.alloc = function (n) { return this._resize(n, !1) }; y._resize = function (n, p) {
              let l; const h = c(this._buffer.length, this._size, n); if (this._buffer.length !== h) {
                const d = this._pool.newBuffer(h); p && (d.array.set(this._buffer.array.subarray(0,
                  Math.min(this._size, h))), d.vao.vertexBuffers.geometry.setSubData(d.array, 0, 0, d.array.byteLength)); l = this._buffer; this._buffer = d
              } const b = this._size; this._size = n; return l ? { dispose: () => { l.array.fill(0, 0, b); this._pool.deleteBuffer(l) }, copy: (d, f, t) => this._buffer.array.set(l.array.subarray(f, t), d), hasNewBuffer: !0 } : { dispose: () => { }, copy: (d, f, t) => { d !== f && this._buffer.array.copyWithin(d, f, t) }, hasNewBuffer: !1 }
            }; y.erase = function (n, p) { this._buffer.array.fill(0, n, p) }; w._createClass(u, [{ key: "vao", get: function () { return this._buffer.vao } },
            { key: "array", get: function () { return this._buffer.array } }, { key: "size", get: function () { return this._size } }]); return u
        }(); a.MergedGeometryBuffer = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/renderers/MergedGeometryBufferPool": function () {
      define(["exports", "../../../../../core/maybe", "../../../../../core/MemCache", "../../../../../core/uid", "../../lib/StaticFloat32ArrayObject"], function (a, w, c, q, u) {
        function y(p, l) {
          if (0 === l) p.forEach(h => h.dispose()); else return l =
            p.pop(), p = p.length * l.array.byteLength, l.dispose(), p
        } const n = c.MIN_PRIORITY + 1; c = function () {
          function p(h, b, d) { this._rctx = h; this._locations = b; this._layout = d; this._cache = h.newCache(`MergedRenderer pool ${q.generateUID()}`, y) } var l = p.prototype; l.dispose = function () { this._cache.destroy() }; l.newBuffer = function (h) {
            const b = h.toString(), d = this._cache.pop(b); return w.isSome(d) ? (h = d.pop(), 0 < d.length && this._cache.put(b, d, h.array.byteLength * d.length, n), h) : new u.StaticFloat32ArrayObject(this._rctx, this._locations,
              this._layout, h)
          }; l.deleteBuffer = function (h) { const b = h.array.byteLength, d = h.array.length.toString(), f = this._cache.pop(d); w.isSome(f) ? (f.push(h), this._cache.put(d, f, b * f.length, -1)) : this._cache.put(d, [h], b, -1); return null }; return p
        }(); a.MergedGeometryBufferPool = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/StaticFloat32ArrayObject": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../../core/has ../../../webgl/checkWebGLError ../../../webgl/enums ../../../../chunks/builtins ../../../webgl/Texture ../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) { q = function () { function b(d, f, t, v) { this.vao = new h(d, f, { geometry: t }, { geometry: c.createVertex(d, 35044) }); this.array = new Float32Array(v); this.vao.vertexBuffers.geometry.setData(this.array) } b.prototype.dispose = function () { this.vao.dispose(!0) }; w._createClass(b, [{ key: "length", get: function () { return this.array.length } }]); return b }(); a.StaticFloat32ArrayObject = q; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/lib/TextureTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../chunks/TextureOnly.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ./DefaultVertexAttributeLocations ./Program ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          n = function (d) { function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build(); return new h.Program(v.rctx, m, l.Default3D) }; t.initializePipeline = function () { return this.configuration.hasAlpha ? b.makePipelineState({ blending: b.separateBlendingParams(770, 1, 771, 771), colorWrite: b.defaultColorWriteParams }) : b.makePipelineState({ colorWrite: b.defaultColorWriteParams }) }; return f }(n.ShaderTechnique);
          n.shader = new y.ReloadableShaderModule(u.TextureOnlyShader, () => new Promise((d, f) => a(["../core/shaderLibrary/util/TextureOnly.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.hasAlpha = !1; return t } c._inheritsLoose(f, d); return f }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter()], u.prototype, "hasAlpha", void 0); w.TextureTechnique = n; w.TextureTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/TextureOnly.glsl": function () {
      define(["exports",
        "../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass", "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c, q) {
          function u() {
            const n = new q.ShaderBuilder; n.include(w.ScreenSpacePass); n.fragment.uniforms.add("tex", "sampler2D"); n.fragment.uniforms.add("color", "vec4"); n.fragment.code.add(c.glsl`void main() {
vec4 texColor = texture2D(tex, uv);
gl_FragColor = texColor * color;
}`); return n
          } const y = Object.freeze({ __proto__: null, build: u }); a.TextureOnlyShader = y; a.build = u
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass": function () {
      define(["exports", "../shaderModules/interfaces"], function (a, w) {
      a.ScreenSpacePass = function (c) {
        c.attributes.add("position", "vec2"); c.varyings.add("uv", "vec2"); c.vertex.code.add(w.glsl`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      uv = position * 0.5 + vec2(0.5);
    }
  `)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lighting/SceneLighting": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/vec3 ../../../../chunks/vec3f64 ./Lightsources ./SphericalHarmonics".split(" "), function (a, w, c, q, u, y) {
        let n = function () {
          function l() {
          this._shOrder = 2; this._ambientBoost = .4; this._oldSunlight = { direction: q.create(), ambient: { color: q.create(), intensity: 1 }, diffuse: { color: q.create(), intensity: 1 } }; this.groundLightingFactor =
            this.globalFactor = .5; this._sphericalHarmonics = new u.SphericalHarmonicsAmbientLight; this._mainLight = { intensity: q.create(), direction: q.fromValues(1, 0, 0), castShadows: !1 }
          } var h = l.prototype; h.setLightDirectionUniform = function (b) { b.setUniform3fv("lightingMainDirection", this._mainLight.direction) }; h.setUniforms = function (b, d = !1) {
            b.setUniform1f("lightingFixedFactor", d ? (1 - this.groundLightingFactor) * (1 - this.globalFactor) : 0); b.setUniform1f("lightingGlobalFactor", this.globalFactor); this.setLightDirectionUniform(b);
            b.setUniform3fv("lightingMainIntensity", this._mainLight.intensity); b.setUniform1f("ambientBoostFactor", this._ambientBoost); d = this._sphericalHarmonics; 0 === this._shOrder ? b.setUniform3f("lightingAmbientSH0", d.r[0], d.g[0], d.b[0]) : 1 === this._shOrder ? (b.setUniform4f("lightingAmbientSH_R", d.r[0], d.r[1], d.r[2], d.r[3]), b.setUniform4f("lightingAmbientSH_G", d.g[0], d.g[1], d.g[2], d.g[3]), b.setUniform4f("lightingAmbientSH_B", d.b[0], d.b[1], d.b[2], d.b[3])) : 2 === this._shOrder && (b.setUniform3f("lightingAmbientSH0", d.r[0],
              d.g[0], d.b[0]), b.setUniform4f("lightingAmbientSH_R1", d.r[1], d.r[2], d.r[3], d.r[4]), b.setUniform4f("lightingAmbientSH_G1", d.g[1], d.g[2], d.g[3], d.g[4]), b.setUniform4f("lightingAmbientSH_B1", d.b[1], d.b[2], d.b[3], d.b[4]), b.setUniform4f("lightingAmbientSH_R2", d.r[5], d.r[6], d.r[7], d.r[8]), b.setUniform4f("lightingAmbientSH_G2", d.g[5], d.g[6], d.g[7], d.g[8]), b.setUniform4f("lightingAmbientSH_B2", d.b[5], d.b[6], d.b[7], d.b[8]))
          }; h.set = function (b) {
            y.combineLights(b, this._shOrder, this._mainLight, this._sphericalHarmonics);
            c.copy(this._oldSunlight.direction, this._mainLight.direction); b = 1 / Math.PI; this._oldSunlight.ambient.color[0] = .282095 * this._sphericalHarmonics.r[0] * b; this._oldSunlight.ambient.color[1] = .282095 * this._sphericalHarmonics.g[0] * b; this._oldSunlight.ambient.color[2] = .282095 * this._sphericalHarmonics.b[0] * b; c.scale(this._oldSunlight.diffuse.color, this._mainLight.intensity, b); c.copy(p, this._oldSunlight.diffuse.color); c.scale(p, p, this._ambientBoost * this.globalFactor); c.add(this._oldSunlight.ambient.color, this._oldSunlight.ambient.color,
              p)
          }; w._createClass(l, [{ key: "lightingMainDirection", get: function () { return this._mainLight.direction } }, { key: "old", get: function () { return this._oldSunlight } }]); return l
        }(); const p = q.create(); a.SceneLighting = n; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lighting/SphericalHarmonics": function () {
      define("exports ../../../../core/mathUtils ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../lib/LongVectorMath ./Lightsources".split(" "), function (a, w, c, q, u, y) {
        function n(k) {
          return (k +
            1) * (k + 1)
        } function p(k) { return w.clamp(Math.floor(Math.sqrt(k) - 1), 0, 2) } function l(k, r, A) { const z = k[0], B = k[1]; k = k[2]; A = A || []; A.length = n(r); 0 <= r && (A[0] = .28209479177); 1 <= r && (A[1] = .4886025119 * z, A[2] = .4886025119 * k, A[3] = .4886025119 * B); 2 <= r && (A[4] = 1.09254843059 * z * B, A[5] = 1.09254843059 * B * k, A[6] = .31539156525 * (3 * k * k - 1), A[7] = 1.09254843059 * z * k, A[8] = .54627421529 * (z * z - B * B)); return A } function h(k, r) { k = n(k); r = r || { r: [], g: [], b: [] }; r.r.length = r.g.length = r.b.length = k; for (let A = 0; A < k; A++)r.r[A] = r.g[A] = r.b[A] = 0; return r }
        function b(k, r) { const A = p(r.r.length); for (const z of k) c.negate(g, z.direction), l(g, A, m), u.elementwiseProduct(m, x), u.scalarProduct(m, z.intensity[0], e), u.add(r.r, e), u.scalarProduct(m, z.intensity[1], e), u.add(r.g, e), u.scalarProduct(m, z.intensity[2], e), u.add(r.b, e); return r } function d(k, r) { l(g, 0, m); for (const A of k) r.r[0] += m[0] * x[0] * A.intensity[0] * 4 * Math.PI, r.g[0] += m[0] * x[0] * A.intensity[1] * 4 * Math.PI, r.b[0] += m[0] * x[0] * A.intensity[2] * 4 * Math.PI; return r } const f = [], t = [], v = [], m = [0], e = [0], g = q.create(), x = [3.141593,
          2.094395, 2.094395, 2.094395, .785398, .785398, .785398, .785398, .785398]; a.combineLights = function (k, r, A, z) {
            h(r, z); c.set(A.intensity, 0, 0, 0); r = !1; f.length = 0; t.length = 0; v.length = 0; for (const B of k) B instanceof y.MainLight && !r ? (c.copy(A.direction, B.direction), A.intensity[0] = B.intensity[0], A.intensity[1] = B.intensity[1], A.intensity[2] = B.intensity[2], A.castShadows = B.castShadows, r = !0) : B instanceof y.MainLight || B instanceof y.FillLight ? f.push(B) : B instanceof y.AmbientLight ? t.push(B) : B instanceof y.SphericalHarmonicsAmbientLight &&
              v.push(B); b(f, z); d(t, z); for (const B of v) u.add(z.r, B.r), u.add(z.g, B.g), u.add(z.b, B.b)
          }; a.computeCoefficients = l; a.initSHCoefficients = h; a.numberOfCoefficients = n; a.orderFromNumberOfCoefficients = p; a.projectAmbientLights = d; a.projectFillLights = b; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/LongVectorMath": function () {
      define(["exports"], function (a) {
      a.add = function (w, c, q) { q = q || w; q.length = w.length; for (let u = 0; u < w.length; u++)q[u] = w[u] + c[u]; return q }; a.dotProduct = function (w,
        c) { let q = 0; for (let u = 0; u < w.length; u++)q += w[u] * c[u]; return q }; a.elementwiseProduct = function (w, c, q) { q = q || w; q.length = w.length; for (let u = 0; u < w.length; u++)q[u] = w[u] * c[u]; return q }; a.scalarProduct = function (w, c, q) { q = q || w; q.length = w.length; for (let u = 0; u < w.length; u++)q[u] = w[u] * c; return q }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/StippleTextureRepository": function () {
      define("exports ../../../../core/floatRGBA ../../../../core/maybe ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/has ../../../webgl/checkWebGLError ../../../webgl/enums ../../../../chunks/builtins ../../../webgl/Texture ../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          function f(t, v) {
            var m = t.map(A => Math.round(A * v)), e = 1 / v; t = Math.floor(m.reduce((A, z) => A + z)); var g = m.reduce((A, z) => Math.max(A, z)); g = (Math.floor(.5 * (g - 1)) + .5) * e; var x = []; let k = 1; for (var r of m) { for (let A = 0; A < r; A++)x.push(k * (Math.min(A, r - 1 - A) + .5) * e / g * .5 + .5); k = -k } r = Math.round(m[0] / 2); r = [...x.slice(r), ...x.slice(0, r)]; m = t + 2; e = new Uint8Array(4 * m); x = 4; for (const A of r) w.packFloatRGBA(A, e, x), x += 4; e.copyWithin(0, x - 4, x); e.copyWithin(x, 4, 8); return {
              encodedData: e, sdfNormalizer: g,
              paddedPixels: m, pixels: t
            }
          } q = function () {
            function t(m) { this._rctx = m; this.cache = new Map } var v = t.prototype; v.dispose = function () { this.cache.forEach(m => m.texture = c.disposeMaybe(m.texture)); this.cache.clear() }; v.acquire = function (m) {
              if (c.isNone(m)) return null; const e = this.patternId(m); var g = this.cache.get(e); if (g) return g.refCount++ , g.bind; g = m.pixelRatio; const { encodedData: x, sdfNormalizer: k, pixels: r, paddedPixels: A } = f(m.pattern, g), z = r / g, B = {
                refCount: 1, texture: null, bind: C => {
                  c.isNone(B.texture) && (B.texture = new b(this._rctx,
                    { width: A, height: 1, internalFormat: 6408, pixelFormat: 6408, dataType: 5121, wrapMode: 33071 }, x)); C.bindTexture(B.texture, "stipplePatternTexture"); return { pixelSize: z, sdfNormalizer: k, pixels: r }
                }
              }; this.cache.set(e, B); return B.bind
            }; v.release = function (m) { if (!c.isNone(m)) { m = this.patternId(m); var e = this.cache.get(m); e && (e.refCount-- , 0 === e.refCount && (c.isSome(e.texture) && e.texture.dispose(), this.cache.delete(m))) } }; v.swap = function (m, e) { e = this.acquire(e); this.release(m); return e }; v.patternId = function (m) { return `${m.pattern.join(",")}-r${m.pixelRatio}` };
            return t
          }(); a.StippleTextureRepository = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/floatRGBA": function () {
      define(["exports", "./mathUtils"], function (a, w) {
        function c(p, l = 0) { let h = 0; for (let b = 0; 4 > b; b++)h += p[l + b] * y[b]; return h } function q(p) { return p - Math.floor(p) } const u = [1, 256, 65536, 16777216], y = [1 / 256, 1 / 65536, 1 / 16777216, 1 / 4294967296], n = c(new Uint8ClampedArray([255, 255, 255, 255])); a.packFloatRGBA = function (p, l, h = 0) { p = w.clamp(p, 0, n); for (let b = 0; 4 > b; b++)l[h + b] = Math.floor(256 * q(p * u[b])) };
        a.unpackFloatRGBA = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/materials/DefaultMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/mat3f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../support/buffer/InterleavedLayout ../core/shaderLibrary/util/AlphaDiscard.glsl ../lib/GLMaterialTexture ../lib/Material ../lib/OrderIndependentTransparency ../lib/verticalOffsetUtils ./internal/bufferWriterUtils ./internal/MaterialUtil ../shaders/DefaultMaterialTechnique ../shaders/RealisticTreeTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(H) { let J = y.newLayout(); J = H.instancedDoublePrecision ? J.vec3f("modelOriginHi").vec3f("modelOriginLo").mat3f("model").mat3f("modelNormal") : J.mat4f("model").mat4f("modelNormal"); H.instanced && -1 < H.instanced.indexOf("color") && (J = J.vec4f("instanceColor")); H.instanced && -1 < H.instanced.indexOf("featureAttribute") && (J = J.vec4f("instanceFeatureAttribute")); return J } let e = function (H) {
            function J(F) {
              var K = H.call(this, F, x) || this; K.supportsEdges = !0; K.techniqueConfig =
                new t.DefaultMaterialTechniqueConfiguration; { var P = K.parameters; const L = P.textureId || P.normalTextureId || P.metallicRoughnessTextureId || P.emissiveTextureId || P.occlusionTextureId, N = y.newLayout().vec3f("position").vec3f("normal"); P.vertexTangents && N.vec4f("tangent"); L && N.vec2f("uv0"); P.vertexColors && N.vec4u8("color"); P.symbolColors && N.vec4u8("symbolColor"); P = N } K.vertexBufferLayout = P; K.instanceBufferLayout = F.instanced ? m(K.parameters) : null; return K
            } w._inheritsLoose(J, H); var M = J.prototype; M.isVisibleInPass =
              function (F) { return 4 === F || 6 === F || 7 === F ? this.parameters.castShadows : !0 }; M.isVisible = function () { var F = this.parameters; if (!H.prototype.isVisible.call(this) || 0 === F.layerOpacity) return !1; var K = F.instanced; const P = F.vertexColors, L = F.symbolColors; K = !!K && -1 < K.indexOf("color"); const N = F.vvColorEnabled, G = "replace" === F.colorMixMode, I = 0 < F.opacity; F = F.externalColor && 0 < F.externalColor[3]; return P && (K || N || L) ? G ? !0 : I : P ? G ? F : I : K || N || L ? G ? !0 : I : G ? F : I }; M.getTechniqueConfig = function (F, K) {
                this.techniqueConfig.output = F; this.techniqueConfig.hasNormalTexture =
                  !!this.parameters.normalTextureId; this.techniqueConfig.hasColorTexture = !!this.parameters.textureId; this.techniqueConfig.vertexTangents = this.parameters.vertexTangents; this.techniqueConfig.instanced = !!this.parameters.instanced; this.techniqueConfig.instancedDoublePrecision = this.parameters.instancedDoublePrecision; this.techniqueConfig.vvSize = this.parameters.vvSizeEnabled; this.techniqueConfig.verticalOffset = null !== this.parameters.verticalOffset; this.techniqueConfig.screenSizePerspective = null !== this.parameters.screenSizePerspective;
                this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this.techniqueConfig.sliceHighlightDisabled = this.parameters.sliceHighlightDisabled; this.techniqueConfig.alphaDiscardMode = this.parameters.textureAlphaMode; this.techniqueConfig.normalsTypeDerivate = "screenDerivative" === this.parameters.normals ? !0 : !1; this.techniqueConfig.transparent = this.parameters.transparent; this.techniqueConfig.writeDepth = this.parameters.writeDepth; this.techniqueConfig.sceneHasOcludees = this.parameters.sceneHasOcludees;
                this.techniqueConfig.cullFace = this.parameters.slicePlaneEnabled ? 0 : this.parameters.cullFace; this.techniqueConfig.multipassTerrainEnabled = K.multipassTerrainEnabled; this.techniqueConfig.cullAboveGround = K.cullAboveGround; if (0 === F || 7 === F) this.techniqueConfig.vertexColors = this.parameters.vertexColors, this.techniqueConfig.symbolColors = this.parameters.symbolColors, this.techniqueConfig.doubleSidedMode = this.parameters.treeRendering ? 2 : this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? 1 :
                  this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? 2 : 0, this.techniqueConfig.instancedColor = !!this.parameters.instanced && -1 < this.parameters.instanced.indexOf("color"), this.techniqueConfig.receiveShadows = this.parameters.receiveShadows && this.parameters.shadowMappingEnabled, this.techniqueConfig.receiveAmbientOcclusion = K.ssaoEnabled ? this.parameters.receiveSSAO : !1, this.techniqueConfig.vvColor = this.parameters.vvColorEnabled, this.techniqueConfig.textureAlphaPremultiplied = !!this.parameters.textureAlphaPremultiplied,
                  this.techniqueConfig.usePBR = this.parameters.usePBR, this.techniqueConfig.hasMetalnessAndRoughnessTexture = !!this.parameters.metallicRoughnessTextureId, this.techniqueConfig.hasEmissionTexture = !!this.parameters.emissiveTextureId, this.techniqueConfig.hasOcclusionTexture = !!this.parameters.occlusionTextureId, this.techniqueConfig.offsetBackfaces = !(!this.parameters.transparent || !this.parameters.offsetTransparentBackfaces), this.techniqueConfig.isSchematic = this.parameters.usePBR && this.parameters.isSchematic,
                  this.techniqueConfig.transparencyPassType = K.transparencyPassType, this.techniqueConfig.enableOffset = K.camera.relativeElevation < h.OITPolygonOffsetLimit; return this.techniqueConfig
              }; M.intersect = function (F, K, P, L, N, G, I) {
                if (null !== this.parameters.verticalOffset) {
                  const R = L.camera; q.set(D, P[12], P[13], P[14]); P = null; switch (L.viewingMode) { case 1: P = q.normalize(B, D); break; case 2: P = q.copy(B, z) }let S = 0; if (null !== this.parameters.verticalOffset) {
                    var O = q.subtract(E, D, R.eye); const Q = q.length(O); O = q.scale(O, O, 1 / Q); let T =
                      null; this.parameters.screenSizePerspective && (T = q.dot(P, O)); S += f.verticalOffsetAtDistance(R, Q, this.parameters.verticalOffset, T, this.parameters.screenSizePerspective)
                  } q.scale(P, P, S); q.transformMat3(C, P, L.transform.inverseRotation); N = q.subtract(r, N, C); G = q.subtract(A, G, C)
                } f.intersectTriangleGeometry(F, K, L, N, G, b.getVerticalOffsetObject3D(L.verticalOffset), I)
              }; M.requiresSlot = function (F) { return F === (this.parameters.transparent ? this.parameters.writeDepth ? 4 : 7 : 2) || 20 === F }; M.createGLMaterial = function (F) {
                return 0 ===
                  F.output || 7 === F.output || 1 === F.output || 2 === F.output || 3 === F.output || 4 === F.output ? new g(F) : null
              }; M.createBufferWriter = function () { return new k(this.vertexBufferLayout, this.instanceBufferLayout) }; return J
          }(l.Material), g = function (H) {
            function J(F) { return H.call(this, { ...F, ...F.material.parameters }) || this } w._inheritsLoose(J, H); var M = J.prototype; M.updateParameters = function (F) {
              const K = this._material.parameters; this.updateTexture(K.textureId); return this.ensureTechnique(K.treeRendering ? v.RealisticTreeTechnique :
                t.DefaultMaterialTechnique, F)
            }; M._updateShadowState = function (F) { F.shadowMappingEnabled !== this._material.parameters.shadowMappingEnabled && this._material.setParameters({ shadowMappingEnabled: F.shadowMappingEnabled }) }; M._updateOccludeeState = function (F) { F.hasOccludees !== this._material.parameters.sceneHasOcludees && this._material.setParameters({ sceneHasOcludees: F.hasOccludees }) }; M.beginSlot = function (F) { if (0 === this._output || 7 === this._output) this._updateShadowState(F), this._updateOccludeeState(F); return this.updateParameters(F) };
            M.bind = function (F, K) { K.bindPass(this._material.parameters, F); this.bindTextures(K.program) }; return J
          }(p); const x = {
            textureId: void 0, initTextureTransparent: !1, isSchematic: !1, usePBR: !1, normalTextureId: void 0, vertexTangents: !1, occlusionTextureId: void 0, emissiveTextureId: void 0, metallicRoughnessTextureId: void 0, emissiveFactor: [0, 0, 0], mrrFactors: [0, 1, .5], ambient: [.2, .2, .2], diffuse: [.8, .8, .8], externalColor: [1, 1, 1, 1], colorMixMode: "multiply", opacity: 1, layerOpacity: 1, vertexColors: !1, symbolColors: !1, doubleSided: !1,
            doubleSidedType: "normal", cullFace: 2, instanced: void 0, instancedDoublePrecision: !1, normals: "default", receiveSSAO: !0, receiveShadows: !0, castShadows: !0, shadowMappingEnabled: !1, verticalOffset: null, screenSizePerspective: null, slicePlaneEnabled: !1, sliceHighlightDisabled: !1, offsetTransparentBackfaces: !1, vvSizeEnabled: !1, vvSizeMinSize: [1, 1, 1], vvSizeMaxSize: [100, 100, 100], vvSizeOffset: [0, 0, 0], vvSizeFactor: [1, 1, 1], vvSizeValue: [1, 1, 1], vvColorEnabled: !1, vvColorValues: [0, 0, 0, 0, 0, 0, 0, 0], vvColorColors: [1, 0, 0, 0, 1, 0,
              0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], vvSymbolAnchor: [0, 0, 0], vvSymbolRotationMatrix: c.create(), transparent: !1, writeDepth: !0, textureAlphaMode: 0, textureAlphaCutoff: n.defaultMaskAlphaCutoff, textureAlphaPremultiplied: !1, sceneHasOcludees: !1, ...l.materialParametersDefaults
          }; let k = function () {
            function H(M, F) { this.vertexBufferLayout = M; this.instanceBufferLayout = F } var J = H.prototype; J.allocate = function (M) { return this.vertexBufferLayout.createBuffer(M) }; J.elementCount = function (M) { return M.indices.get("position").length };
            J.write = function (M, F, K, P) { d.writeDefaultAttributes(F, this.vertexBufferLayout, M.transformation, M.invTranspTransformation, K, P) }; return H
          }(); const r = u.create(), A = u.create(), z = u.fromValues(0, 0, 1), B = u.create(), C = u.create(), D = u.create(), E = u.create(); a.DefaultMaterial = e; a.getInstanceBufferLayout = m; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/shaders/DefaultMaterialTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../chunks/vec3f64 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/attributes/InstancedDoublePrecision.glsl ../core/shaderLibrary/attributes/VerticalOffset.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../core/shaderLibrary/shading/ReadShadowMap.glsl ../core/shaderLibrary/shading/VisualVariables.glsl ../core/shaderLibrary/util/DoublePrecision.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../materials/internal/MaterialUtil ../../../../chunks/DefaultMaterial.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          e = function (D) {
            function E() { return D.apply(this, arguments) || this } c._inheritsLoose(E, D); var H = E.prototype; H.initializeProgram = function (J) {
              var M = E.shader.get(); const F = this.configuration; M = M.build({
                OITEnabled: 0 === F.transparencyPassType, output: F.output, viewingMode: J.viewingMode, receiveShadows: F.receiveShadows, slicePlaneEnabled: F.slicePlaneEnabled, sliceHighlightDisabled: F.sliceHighlightDisabled, sliceEnabledForVertexPrograms: !1, symbolColor: F.symbolColors,
                vvSize: F.vvSize, vvColor: F.vvColor, vvInstancingEnabled: !0, instanced: F.instanced, instancedColor: F.instancedColor, instancedDoublePrecision: F.instancedDoublePrecision, pbrMode: F.usePBR ? F.isSchematic ? 2 : 1 : 0, hasMetalnessAndRoughnessTexture: F.hasMetalnessAndRoughnessTexture, hasEmissionTexture: F.hasEmissionTexture, hasOcclusionTexture: F.hasOcclusionTexture, hasNormalTexture: F.hasNormalTexture, hasColorTexture: F.hasColorTexture, receiveAmbientOcclusion: F.receiveAmbientOcclusion, useCustomDTRExponentForWater: !1, normalType: F.normalsTypeDerivate ?
                  3 : 0, doubleSidedMode: F.doubleSidedMode, vertexTangents: F.vertexTangents, attributeTextureCoordinates: F.hasMetalnessAndRoughnessTexture || F.hasEmissionTexture || F.hasOcclusionTexture || F.hasNormalTexture || F.hasColorTexture ? 1 : 0, textureAlphaPremultiplied: F.textureAlphaPremultiplied, attributeColor: F.vertexColors, screenSizePerspectiveEnabled: F.screenSizePerspective, verticalOffsetEnabled: F.verticalOffset, offsetBackfaces: F.offsetBackfaces, doublePrecisionRequiresObfuscation: t.doublePrecisionRequiresObfuscation(J.rctx),
                alphaDiscardMode: F.alphaDiscardMode, supportsTextureAtlas: !1, multipassTerrainEnabled: F.multipassTerrainEnabled, cullAboveGround: F.cullAboveGround
              }); return new r.Program(J.rctx, M, x.Default3D)
            }; H.bindPass = function (J, M) {
              var F, K; v.bindProjectionMatrix(this.program, M.camera.projectionMatrix); const P = this.configuration.output; (1 === this.configuration.output || M.multipassTerrainEnabled || 3 === P) && this.program.setUniform2fv("cameraNearFar", M.camera.nearFar); M.multipassTerrainEnabled && (this.program.setUniform2fv("inverseViewport",
                M.inverseViewport), h.bindMultipassTerrainTexture(this.program, M)); 7 === P && (this.program.setUniform1f("opacity", J.opacity), this.program.setUniform1f("layerOpacity", J.layerOpacity), this.program.setUniform4fv("externalColor", J.externalColor), this.program.setUniform1i("colorMixMode", z.colorMixModes[J.colorMixMode])); 0 === P ? (M.lighting.setUniforms(this.program, !1), this.program.setUniform3fv("ambient", J.ambient), this.program.setUniform3fv("diffuse", J.diffuse), this.program.setUniform4fv("externalColor", J.externalColor),
                  this.program.setUniform1i("colorMixMode", z.colorMixModes[J.colorMixMode]), this.program.setUniform1f("opacity", J.opacity), this.program.setUniform1f("layerOpacity", J.layerOpacity), this.configuration.usePBR && b.bindPBRUniforms(this.program, J, this.configuration.isSchematic)) : 4 === P && l.bindOutputHighlight(this.program, M); f.bindVisualVariablesUniformsForSymbols(this.program, J); p.bindVerticalOffsetUniforms(this.program, J, M); z.bindScreenSizePerspective(J.screenSizePerspective, this.program, "screenSizePerspectiveAlignment");
              2 !== J.textureAlphaMode && 3 !== J.textureAlphaMode || this.program.setUniform1f("textureAlphaCutoff", J.textureAlphaCutoff); null == (F = M.shadowMap) ? void 0 : F.bind(this.program); null == (K = M.ssaoHelper) ? void 0 : K.bind(this.program, M.camera)
            }; H.bindDraw = function (J) {
              const M = this.configuration.instancedDoublePrecision ? u.fromValues(J.camera.viewInverseTransposeMatrix[3], J.camera.viewInverseTransposeMatrix[7], J.camera.viewInverseTransposeMatrix[11]) : J.origin; v.bindViewCustomOrigin(this.program, M, J.camera.viewMatrix);
              this.program.rebindTextures(); (0 === this.configuration.output || 7 === this.configuration.output || 1 === this.configuration.output && this.configuration.screenSizePerspective || 2 === this.configuration.output && this.configuration.screenSizePerspective || 4 === this.configuration.output && this.configuration.screenSizePerspective) && v.bindCameraPosition(this.program, M, J.camera.viewInverseTransposeMatrix); 2 === this.configuration.output && this.program.setUniformMatrix4fv("viewNormal", J.camera.viewInverseTransposeMatrix); this.configuration.instancedDoublePrecision &&
                n.InstancedDoublePrecision.bindCustomOrigin(this.program, M); y.bindSliceUniforms(this.program, this.configuration, J.slicePlane, M); 0 === this.configuration.output && d.bindReadShadowMapViewCustomOrigin(this.program, J, M)
            }; H.setPipeline = function (J, M) {
              const F = this.configuration, K = 3 === J, P = 2 === J; return C.makePipelineState({
                blending: 0 !== F.output && 7 !== F.output || !F.transparent ? null : K ? k.blendingDefault : k.OITBlending(J), culling: (F.cullFace ? 0 !== F.cullFace : F.slicePlaneEnabled ? !1 : !F.transparent && !F.doubleSidedMode) &&
                  C.cullingParams(F.cullFace), depthTest: { func: k.OITDepthTest(J) }, depthWrite: K || P ? F.writeDepth && C.defaultDepthWriteParams : null, colorWrite: C.defaultColorWriteParams, stencilWrite: F.sceneHasOcludees ? A.stencilWriteMaskOn : null, stencilTest: F.sceneHasOcludees ? M ? A.stencilToolMaskBaseParams : A.stencilBaseAllZerosParams : null, polygonOffset: K || P ? null : k.getOITPolygonOffset(F.enableOffset)
              })
            }; H.initializePipeline = function () {
            this._occludeePipelineState = this.setPipeline(this.configuration.transparencyPassType, !0); return this.setPipeline(this.configuration.transparencyPassType,
              !1)
            }; H.getPipelineState = function (J, M) { return M ? this._occludeePipelineState : D.prototype.getPipelineState.call(this, J, M) }; return E
          }(e.ShaderTechnique); e.shader = new m.ReloadableShaderModule(B.DefaultMaterialShader, () => new Promise((D, E) => a(["./DefaultMaterial.glsl"], D, E))); m = function (D) {
            function E() {
              var H = D.apply(this, arguments) || this; H.output = 0; H.alphaDiscardMode = 1; H.doubleSidedMode = 0; H.isSchematic = !1; H.vertexColors = !1; H.offsetBackfaces = !1; H.symbolColors = !1; H.vvSize = !1; H.vvColor = !1; H.verticalOffset =
                !1; H.receiveShadows = !1; H.slicePlaneEnabled = !1; H.sliceHighlightDisabled = !1; H.receiveAmbientOcclusion = !1; H.screenSizePerspective = !1; H.textureAlphaPremultiplied = !1; H.hasColorTexture = !1; H.usePBR = !1; H.hasMetalnessAndRoughnessTexture = !1; H.hasEmissionTexture = !1; H.hasOcclusionTexture = !1; H.hasNormalTexture = !1; H.instanced = !1; H.instancedColor = !1; H.instancedDoublePrecision = !1; H.vertexTangents = !1; H.normalsTypeDerivate = !1; H.writeDepth = !0; H.sceneHasOcludees = !1; H.transparent = !1; H.enableOffset = !0; H.cullFace = 0; H.transparencyPassType =
                  3; H.multipassTerrainEnabled = !1; H.cullAboveGround = !1; return H
            } c._inheritsLoose(E, D); return E
          }(g.ShaderTechniqueConfiguration); q.__decorate([g.parameter({ count: 8 })], m.prototype, "output", void 0); q.__decorate([g.parameter({ count: 4 })], m.prototype, "alphaDiscardMode", void 0); q.__decorate([g.parameter({ count: 3 })], m.prototype, "doubleSidedMode", void 0); q.__decorate([g.parameter()], m.prototype, "isSchematic", void 0); q.__decorate([g.parameter()], m.prototype, "vertexColors", void 0); q.__decorate([g.parameter()],
            m.prototype, "offsetBackfaces", void 0); q.__decorate([g.parameter()], m.prototype, "symbolColors", void 0); q.__decorate([g.parameter()], m.prototype, "vvSize", void 0); q.__decorate([g.parameter()], m.prototype, "vvColor", void 0); q.__decorate([g.parameter()], m.prototype, "verticalOffset", void 0); q.__decorate([g.parameter()], m.prototype, "receiveShadows", void 0); q.__decorate([g.parameter()], m.prototype, "slicePlaneEnabled", void 0); q.__decorate([g.parameter()], m.prototype, "sliceHighlightDisabled", void 0); q.__decorate([g.parameter()],
              m.prototype, "receiveAmbientOcclusion", void 0); q.__decorate([g.parameter()], m.prototype, "screenSizePerspective", void 0); q.__decorate([g.parameter()], m.prototype, "textureAlphaPremultiplied", void 0); q.__decorate([g.parameter()], m.prototype, "hasColorTexture", void 0); q.__decorate([g.parameter()], m.prototype, "usePBR", void 0); q.__decorate([g.parameter()], m.prototype, "hasMetalnessAndRoughnessTexture", void 0); q.__decorate([g.parameter()], m.prototype, "hasEmissionTexture", void 0); q.__decorate([g.parameter()],
                m.prototype, "hasOcclusionTexture", void 0); q.__decorate([g.parameter()], m.prototype, "hasNormalTexture", void 0); q.__decorate([g.parameter()], m.prototype, "instanced", void 0); q.__decorate([g.parameter()], m.prototype, "instancedColor", void 0); q.__decorate([g.parameter()], m.prototype, "instancedDoublePrecision", void 0); q.__decorate([g.parameter()], m.prototype, "vertexTangents", void 0); q.__decorate([g.parameter()], m.prototype, "normalsTypeDerivate", void 0); q.__decorate([g.parameter()], m.prototype, "writeDepth",
                  void 0); q.__decorate([g.parameter()], m.prototype, "sceneHasOcludees", void 0); q.__decorate([g.parameter()], m.prototype, "transparent", void 0); q.__decorate([g.parameter()], m.prototype, "enableOffset", void 0); q.__decorate([g.parameter({ count: 3 })], m.prototype, "cullFace", void 0); q.__decorate([g.parameter({ count: 4 })], m.prototype, "transparencyPassType", void 0); q.__decorate([g.parameter()], m.prototype, "multipassTerrainEnabled", void 0); q.__decorate([g.parameter()], m.prototype, "cullAboveGround", void 0); w.DefaultMaterialTechnique =
                    e; w.DefaultMaterialTechniqueConfiguration = m; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl": function () {
      define(["exports", "../../../../../../chunks/vec3f64", "../util/DoublePrecision.glsl", "../../shaderModules/interfaces", "../../../../../webgl/doublePrecisionUtils"], function (a, w, c, q, u) {
        function y(l, h) {
        h.instanced && h.instancedDoublePrecision && (l.attributes.add("modelOriginHi", "vec3"), l.attributes.add("modelOriginLo",
          "vec3"), l.attributes.add("model", "mat3"), l.attributes.add("modelNormal", "mat3")); h.instancedDoublePrecision && (l.vertex.include(c.DoublePrecision, h), l.vertex.uniforms.add("viewOriginHi", "vec3"), l.vertex.uniforms.add("viewOriginLo", "vec3")); const b = [q.glsl`
    vec3 calculateVPos() {
      ${h.instancedDoublePrecision ? "return model * localPosition().xyz;" : "return localPosition().xyz;"}
    }
    `, q.glsl`
    vec3 subtractOrigin(vec3 _pos) {
      ${h.instancedDoublePrecision ? q.glsl`
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);
          return _pos - originDelta;`: "return vpos;"}
    }
    `, q.glsl`
    vec3 dpNormal(vec4 _normal) {
      ${h.instancedDoublePrecision ? "return normalize(modelNormal * _normal.xyz);" : "return normalize(_normal.xyz);"}
    }
    `, q.glsl`
    vec3 dpNormalView(vec4 _normal) {
      ${h.instancedDoublePrecision ? "return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);" : "return normalize((viewNormal * _normal).xyz);"}
    }
    `, h.vertexTangents ? q.glsl`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${h.instancedDoublePrecision ? "return vec4(modelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}

    }
    `: q.glsl``]; l.vertex.code.add(b[0]); l.vertex.code.add(b[1]); l.vertex.code.add(b[2]); 2 === h.output && l.vertex.code.add(b[3]); l.vertex.code.add(b[4])
        } (function (l) { l.Uniforms = function () { }; l.bindCustomOrigin = function (h, b) { u.encodeDoubleArraySplit(b, n, p, 3); h.setUniform3fv("viewOriginHi", n); h.setUniform3fv("viewOriginLo", p) } })(y || (y = {})); const n = w.create(), p = w.create(); a.InstancedDoublePrecision = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl": function () {
      define(["exports",
        "../../../../../../core/has", "../../shaderModules/interfaces"], function (a, w, c) {
        a.DoublePrecision = function ({ code: q }, u) {
          u.doublePrecisionRequiresObfuscation ? q.add(c.glsl`vec3 dpPlusFrc(vec3 a, vec3 b) {
return mix(a, a + b, vec3(notEqual(b, vec3(0))));
}
vec3 dpMinusFrc(vec3 a, vec3 b) {
return mix(vec3(0), a - b, vec3(notEqual(a, b)));
}
vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = dpPlusFrc(hiA, hiB);
vec3 e = dpMinusFrc(t1, hiA);
vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
return t1 + t2;
}`) : q.add(c.glsl`vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = hiA + hiB;
vec3 e = t1 - hiA;
vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
return t1 + t2;
}`)
        }; a.doublePrecisionRequiresObfuscation = function (q) { return w("force-double-precision-obfuscation") ? !0 : q.driverTest.doublePrecisionRequiresObfuscation }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl": function () {
      define(["exports", "../../../../../../chunks/vec3f32", "../attributes/VertexTextureCoordinates.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
        w = w.fromValues(0, .6, .2); a.PBRSchematicMRRValues =
          w; a.PhysicallyBasedRenderingParameters = function (u, y) {
            const n = u.fragment, p = y.hasMetalnessAndRoughnessTexture || y.hasEmissionTexture || y.hasOcclusionTexture; 1 === y.pbrMode && p && u.include(c.VertexTextureCoordinates, y); 2 === y.pbrMode ? n.code.add(q.glsl`const vec3 mrr = vec3(0.0, 0.6, 0.2);
const vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`) : (0 === y.pbrMode && n.code.add(q.glsl`float getBakedOcclusion() { return 1.0; }`), 1 === y.pbrMode && (n.uniforms.add("emissionFactor", "vec3"), n.uniforms.add("mrrFactors", "vec3"), n.code.add(q.glsl`vec3 mrr;
vec3 emission;
float occlusion;`), y.hasMetalnessAndRoughnessTexture && (n.uniforms.add("texMetallicRoughness", "sampler2D"), y.supportsTextureAtlas && n.uniforms.add("texMetallicRoughnessSize", "vec2"), n.code.add(q.glsl`void applyMetallnessAndRoughness(TextureLookupParameter params) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), y.hasEmissionTexture && (n.uniforms.add("texEmission", "sampler2D"), y.supportsTextureAtlas && n.uniforms.add("texEmissionSize", "vec2"), n.code.add(q.glsl`void applyEmission(TextureLookupParameter params) {
emission *= textureLookup(texEmission, params).rgb;
}`)), y.hasOcclusionTexture ? (n.uniforms.add("texOcclusion", "sampler2D"), y.supportsTextureAtlas && n.uniforms.add("texOcclusionSize", "vec2"), n.code.add(q.glsl`void applyOcclusion(TextureLookupParameter params) {
occlusion *= textureLookup(texOcclusion, params).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : n.code.add(q.glsl`float getBakedOcclusion() { return 1.0; }`), n.code.add(q.glsl`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;
      ${p ? "vtc.uv \x3d vuv0;" : ""}
      ${y.hasMetalnessAndRoughnessTexture ? y.supportsTextureAtlas ? "vtc.size \x3d texMetallicRoughnessSize; applyMetallnessAndRoughness(vtc);" : "applyMetallnessAndRoughness(vtc);" : ""}
      ${y.hasEmissionTexture ? y.supportsTextureAtlas ? "vtc.size \x3d texEmissionSize; applyEmission(vtc);" : "applyEmission(vtc);" : ""}
      ${y.hasOcclusionTexture ? y.supportsTextureAtlas ? "vtc.size \x3d texOcclusionSize; applyOcclusion(vtc);" : "applyOcclusion(vtc);" : ""}
    }
  `)))
          }; a.bindPBRUniforms = function (u, y, n = !1) { n || (u.setUniform3fv("mrrFactors", y.mrrFactors), u.setUniform3fv("emissionFactor", y.emissiveFactor)) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl": function () {
      define(["exports", "./TextureCoordinateAttribute.glsl", "../util/TextureAtlasLookup.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
      a.VertexTextureCoordinates = function (u, y) {
        u.include(w.TextureCoordinateAttribute,
          y); u.fragment.code.add(q.glsl`
  struct TextureLookupParameter {
    vec2 uv;
    ${y.supportsTextureAtlas ? "vec2 size;" : ""}
  } vtc;
  `); 1 === y.attributeTextureCoordinates && u.fragment.code.add(q.glsl`vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {
return texture2D(tex, params.uv);
}`); 2 === y.attributeTextureCoordinates && (u.include(c.TextureAtlasLookup), u.fragment.code.add(q.glsl`vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {
return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);
}`))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.TextureAtlasLookup = function (c) {
        c.extensions.add("GL_EXT_shader_texture_lod"); c.extensions.add("GL_OES_standard_derivatives"); c.fragment.code.add(w.glsl`#ifndef GL_EXT_shader_texture_lod
float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {
float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));
return max(0.0, 0.5 * log2(deltaMaxSqr));
}
#endif
vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
#ifdef GL_EXT_shader_texture_lod
return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);
#else
vec2 dUVdxAuto = dFdx(uvAtlas);
vec2 dUVdyAuto = dFdy(uvAtlas);
float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);
float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);
return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);
#endif
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/DefaultMaterial.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl ../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/HeaderComment.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          function M(K) {
            const P = new J.ShaderBuilder, L = P.vertex.code, N = P.fragment.code; P.include(D.HeaderComment, { name: "Default Material Shader", output: K.output }); P.vertex.uniforms.add("proj", "mat4").add("view", "mat4").add("camPos", "vec3").add("localOrigin", "vec3"); P.include(p.PositionAttribute); P.varyings.add("vpos", "vec3"); P.include(B.VisualVariables, K); P.include(y.InstancedDoublePrecision, K); P.include(f.VerticalOffset, K); if (0 === K.output ||
              7 === K.output) P.include(n.NormalAttribute, K), P.include(u.Transform, { linearDepth: !1 }), 0 === K.normalType && K.offsetBackfaces && P.include(c.Offset), P.include(m.ComputeNormalTexture, K), P.include(d.VertexNormal, K), K.instancedColor && P.attributes.add("instanceColor", "vec4"), P.varyings.add("localvpos", "vec3"), P.include(h.TextureCoordinateAttribute, K), P.include(w.ForwardLinearDepth, K), P.include(l.SymbolColor, K), P.include(b.VertexColor, K), P.vertex.uniforms.add("externalColor", "vec4"), P.varyings.add("vcolorExt",
                "vec4"), K.multipassTerrainEnabled && P.varyings.add("depth", "float"), L.add(H.glsl`
      void main(void) {
        forwardNormalizedVertexColor();
        vcolorExt = externalColor;
        ${K.instancedColor ? "vcolorExt *\x3d instanceColor;" : ""}
        vcolorExt *= vvColor();
        vcolorExt *= getSymbolColor();
        forwardColorMixMode();

        if (vcolorExt.a < ${H.glsl.float(C.symbolAlphaCutoff)}) {
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        }
        else {
          vpos = calculateVPos();
          localvpos = vpos - view[3].xyz;
          vpos = subtractOrigin(vpos);
          ${0 === K.normalType ? H.glsl`
          vNormalWorld = dpNormal(vvLocalNormal(normalModel()));`: ""}
          vpos = addVerticalOffset(vpos, localOrigin);
          ${K.vertexTangents ? "vTangent \x3d dpTransformVertexTangent(tangent);" : ""}
          gl_Position = transformPosition(proj, view, vpos);
          ${0 === K.normalType && K.offsetBackfaces ? "gl_Position \x3d offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);" : ""}
        }

        ${K.multipassTerrainEnabled ? "depth \x3d (view * vec4(vpos, 1.0)).z;" : ""}
        forwardLinearDepth();
        forwardTextureCoordinates();
      }
    `); 7 === K.output && (P.include(q.Slice, K), P.include(C.DiscardOrAdjustAlpha, K), K.multipassTerrainEnabled && (P.fragment.include(v.ReadLinearDepth), P.include(x.multipassTerrainTest, K)), P.fragment.uniforms.add("camPos", "vec3").add("localOrigin", "vec3").add("opacity", "float").add("layerOpacity", "float"), K.hasColorTexture && P.fragment.uniforms.add("tex", "sampler2D"), P.fragment.include(E.MixExternalColor), N.add(H.glsl`
      void main() {
        discardBySlice(vpos);
        ${K.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        ${K.hasColorTexture ? H.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        ${K.textureAlphaPremultiplied ? "texColor.rgb /\x3d texColor.a;" : ""}
        discardOrAdjustAlpha(texColor);`: H.glsl`vec4 texColor = vec4(1.0);`}
        ${K.attributeColor ? H.glsl`
        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`: H.glsl`
        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));
        `}
        gl_FragColor = vec4(opacity_);
      }
    `)); 0 === K.output && (P.include(q.Slice, K), P.include(g.EvaluateSceneLighting, K), P.include(e.EvaluateAmbientOcclusion, K), P.include(C.DiscardOrAdjustAlpha, K), K.receiveShadows && P.include(z.ReadShadowMap, K), K.multipassTerrainEnabled && (P.fragment.include(v.ReadLinearDepth), P.include(x.multipassTerrainTest, K)), P.fragment.uniforms.add("camPos", "vec3").add("localOrigin", "vec3").add("ambient", "vec3").add("diffuse", "vec3").add("opacity", "float").add("layerOpacity", "float"), K.hasColorTexture && P.fragment.uniforms.add("tex",
              "sampler2D"), P.include(A.PhysicallyBasedRenderingParameters, K), P.include(r.PhysicallyBasedRendering, K), P.fragment.include(E.MixExternalColor), P.include(k.Normals, K), N.add(H.glsl`
      void main() {
        discardBySlice(vpos);
        ${K.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        ${K.hasColorTexture ? H.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        ${K.textureAlphaPremultiplied ? "texColor.rgb /\x3d texColor.a;" : ""}
        discardOrAdjustAlpha(texColor);`: H.glsl`vec4 texColor = vec4(1.0);`}
        shadingParams.viewDirection = normalize(vpos - camPos);
        ${3 === K.normalType ? H.glsl`
        vec3 normal = screenDerivativeNormal(localvpos);`: H.glsl`
        shadingParams.normalView = vNormalWorld;
        vec3 normal = shadingNormal(shadingParams);`}
        ${1 === K.pbrMode ? "applyPBRFactors();" : ""}
        float ssao = evaluateAmbientOcclusionInverse();
        ssao *= getBakedOcclusion();

        float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        ${K.receiveShadows ? "float shadow \x3d readShadowMap(vpos, linearDepth);" : 1 === K.viewingMode ? "float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow \x3d 0.0;"}
        vec3 matColor = max(ambient, diffuse);
        ${K.attributeColor ? H.glsl`
        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`: H.glsl`
        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));
        `}
        ${K.hasNormalTexture ? H.glsl`
              mat3 tangentSpace = ${K.vertexTangents ? "computeTangentSpace(normal);" : "computeTangentSpace(normal, vpos, vuv0);"}
              vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);`: "vec3 shadedNormal \x3d normal;"}
        ${1 === K.pbrMode || 2 === K.pbrMode ? 1 === K.viewingMode ? H.glsl`vec3 normalGround = normalize(vpos + localOrigin);` : H.glsl`vec3 normalGround = vec3(0.0, 0.0, 1.0);` : H.glsl``}
        ${1 === K.pbrMode || 2 === K.pbrMode ? H.glsl`
            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];
            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);`: "vec3 shadedColor \x3d evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);"}
        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);
        ${K.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)); P.include(t.DefaultMaterialAuxiliaryPasses, K); return P
          } const F = Object.freeze({ __proto__: null, build: M }); a.DefaultMaterialShader = F; a.build = M
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl": function () {
      define(["exports", "../shaderModules/interfaces"], function (a, w) {
      a.Offset = function (c) {
        c.vertex.code.add(w.glsl`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl": function () {
      define(["exports", "../util/DecodeNormal.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.NormalAttribute = function (q, u) {
      0 === u.normalType && (q.attributes.add("normal", "vec3"), q.vertex.code.add(c.glsl`vec3 normalModel() {
return normal;
}`)); 1 === u.normalType && (q.include(w.DecodeNormal), q.attributes.add("normalCompressed", "vec2"), q.vertex.code.add(c.glsl`vec3 normalModel() {
return decodeNormal(normalCompressed);
}`)); 3 === u.normalType && (q.extensions.add("GL_OES_standard_derivatives"), q.fragment.code.add(c.glsl`vec3 screenDerivativeNormal(vec3 positionView) {
return normalize(cross(dFdx(positionView), dFdy(positionView)));
}`))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/DecodeNormal.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.DecodeNormal = function (c) {
        const q = w.glsl`vec3 decodeNormal(vec2 f) {
float z = 1.0 - abs(f.x) - abs(f.y);
return vec3(f + sign(f) * min(z, 0.0), z);
}`; c.fragment.code.add(q); c.vertex.code.add(q)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl": function () { define(["exports", "../../shaderModules/interfaces"], function (a, w) { a.PositionAttribute = function (c) { c.attributes.add("position", "vec3"); c.vertex.code.add(w.glsl`vec3 positionModel() { return position; }`) }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl": function () {
      define(["exports",
        "../../../collections/Component/Material/shader/DecodeSymbolColor.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
        a.SymbolColor = function (q, u) {
          u.symbolColor ? (q.include(w.DecodeSymbolColor), q.attributes.add("symbolColor", "vec4"), q.varyings.add("colorMixMode", "mediump float")) : q.fragment.uniforms.add("colorMixMode", "int"); u.symbolColor ? q.vertex.code.add(c.glsl`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`) : q.vertex.code.add(c.glsl`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl": function () {
      define(["exports", "../../../../core/shaderModules/interfaces"], function (a, w) {
      a.DecodeSymbolColor = function (c) {
        c.vertex.code.add(w.glsl`
    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {
      float symbolAlpha = 0.0;

      const float maxTint = 85.0;
      const float maxReplace = 170.0;
      const float scaleAlpha = 3.0;

      if (symbolColor.a > maxReplace) {
        colorMixMode = ${w.glsl.int(1)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);
      } else if (symbolColor.a > maxTint) {
        colorMixMode = ${w.glsl.int(3)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);
      } else if (symbolColor.a > 0.0) {
        colorMixMode = ${w.glsl.int(4)};
        symbolAlpha = scaleAlpha * symbolColor.a;
      } else {
        colorMixMode = ${w.glsl.int(1)};
        symbolAlpha = 0.0;
      }

      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);
    }
  `)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.VertexColor = function (c, q) {
        q.attributeColor ? (c.attributes.add("color", "vec4"), c.varyings.add("vColor", "vec4"), c.vertex.code.add(w.glsl`void forwardVertexColor() { vColor = color; }`), c.vertex.code.add(w.glsl`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)) : c.vertex.code.add(w.glsl`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl": function () {
      define(["exports", "./NormalAttribute.glsl", "./VertexPosition.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
        function u(y, n) {
        0 === n.normalType || 1 === n.normalType ? (y.include(w.NormalAttribute, n), y.varyings.add("vNormalWorld", "vec3"), y.varyings.add("vNormalView", "vec3"), y.vertex.uniforms.add("uTransformNormal_GlobalFromModel",
          "mat3"), y.vertex.uniforms.add("uTransformNormal_ViewFromGlobal", "mat3"), y.vertex.code.add(q.glsl`void forwardNormal() {
vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();
vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;
}`)) : 2 === n.normalType ? (y.include(c.VertexPosition, n), y.varyings.add("vNormalWorld", "vec3"), y.vertex.code.add(q.glsl`
    void forwardNormal() {
      vNormalWorld = ${1 === n.viewingMode ? q.glsl`normalize(vPositionWorldCameraRelative);` : q.glsl`vec3(0.0, 0.0, 1.0);`}
    }
    `)) : y.vertex.code.add(q.glsl`void forwardNormal() {}`)
        } (function (y) { y.bindUniforms = function (n, p) { n.setUniformMatrix4fv("viewNormal", p) } })(u || (u = {})); a.VertexNormal = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl": function () {
      define("exports ../../../../../../chunks/mat3f64 ../../../../../../chunks/mat4f64 ../../../../../../chunks/vec3f64 ./PositionAttribute.glsl ../util/DoublePrecision.glsl ../../shaderModules/interfaces".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(l, h) {
            l.include(u.PositionAttribute); l.vertex.include(y.DoublePrecision, h); l.varyings.add("vPositionWorldCameraRelative", "vec3"); l.varyings.add("vPosition_view", "vec3"); l.vertex.uniforms.add("uTransform_WorldFromModel_RS", "mat3"); l.vertex.uniforms.add("uTransform_WorldFromModel_TH", "vec3"); l.vertex.uniforms.add("uTransform_WorldFromModel_TL", "vec3"); l.vertex.uniforms.add("uTransform_WorldFromView_TH", "vec3"); l.vertex.uniforms.add("uTransform_WorldFromView_TL", "vec3");
            l.vertex.uniforms.add("uTransform_ViewFromCameraRelative_RS", "mat3"); l.vertex.uniforms.add("uTransform_ProjFromView", "mat4"); l.vertex.code.add(n.glsl`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = uTransform_WorldFromModel_RS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
uTransform_WorldFromModel_TL,
uTransform_WorldFromModel_TH,
-uTransform_WorldFromView_TL,
-uTransform_WorldFromView_TH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}
vec3 position_view() {
return uTransform_ViewFromCameraRelative_RS * positionWorldCameraRelative();
}
void forwardPosition() {
vPositionWorldCameraRelative = positionWorldCameraRelative();
vPosition_view = position_view();
gl_Position = uTransform_ProjFromView * vec4(vPosition_view, 1.0);
}
vec3 positionWorld() {
return uTransform_WorldFromView_TL + vPositionWorldCameraRelative;
}`); l.fragment.uniforms.add("uTransform_WorldFromView_TL", "vec3"); l.fragment.code.add(n.glsl`vec3 positionWorld() {
return uTransform_WorldFromView_TL + vPositionWorldCameraRelative;
}`)
          } (function (l) {
          l.ModelTransform = function () { this.worldFromModel_RS = w.create(); this.worldFromModel_TH = q.create(); this.worldFromModel_TL = q.create() }; l.ViewProjectionTransform = function () { this.worldFromView_TH = q.create(); this.worldFromView_TL = q.create(); this.viewFromCameraRelative_RS = w.create(); this.projFromView = c.create() }; l.bindModelTransform = function (h, b) {
            h.setUniformMatrix3fv("uTransform_WorldFromModel_RS", b.worldFromModel_RS); h.setUniform3fv("uTransform_WorldFromModel_TH", b.worldFromModel_TH); h.setUniform3fv("uTransform_WorldFromModel_TL",
              b.worldFromModel_TL)
          }; l.bindViewProjTransform = function (h, b) { h.setUniform3fv("uTransform_WorldFromView_TH", b.worldFromView_TH); h.setUniform3fv("uTransform_WorldFromView_TL", b.worldFromView_TL); h.setUniformMatrix4fv("uTransform_ProjFromView", b.projFromView); h.setUniformMatrix3fv("uTransform_ViewFromCameraRelative_RS", b.viewFromCameraRelative_RS) }
          })(p || (p = {})); a.VertexPosition = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl": function () {
      define("exports ../Slice.glsl ../Transform.glsl ../attributes/NormalAttribute.glsl ../attributes/TextureCoordinateAttribute.glsl ../attributes/VertexNormal.glsl ../output/OutputDepth.glsl ../output/OutputHighlight.glsl ../shading/VisualVariables.glsl ../util/AlphaDiscard.glsl ../../shaderModules/interfaces".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
        a.DefaultMaterialAuxiliaryPasses = function (d, f) {
          const t = d.vertex.code, v = d.fragment.code; if (1 === f.output || 3 === f.output) d.include(c.Transform, { linearDepth: !0 }), d.include(u.TextureCoordinateAttribute, f), d.include(l.VisualVariables, f), d.include(n.OutputDepth, f), d.include(w.Slice, f), d.vertex.uniforms.add("cameraNearFar", "vec2"), d.varyings.add("depth", "float"), f.hasColorTexture && d.fragment.uniforms.add("tex", "sampler2D"), t.add(b.glsl`void main(void) {
vpos = calculateVPos();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, cameraNearFar, depth);
forwardTextureCoordinates();
}`), d.include(h.DiscardOrAdjustAlpha, f), v.add(b.glsl`
      void main(void) {
        discardBySlice(vpos);
        ${f.hasColorTexture ? b.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        discardOrAdjustAlpha(texColor);`: ""}
        outputDepth(depth);
      }
    `); 2 === f.output && (d.include(c.Transform, { linearDepth: !1 }), d.include(q.NormalAttribute, f), d.include(y.VertexNormal, f), d.include(u.TextureCoordinateAttribute, f), d.include(l.VisualVariables, f), f.hasColorTexture && d.fragment.uniforms.add("tex", "sampler2D"), d.vertex.uniforms.add("viewNormal", "mat4"), d.varyings.add("vPositionView", "vec3"), t.add(b.glsl`
      void main(void) {
        vpos = calculateVPos();
        vpos = subtractOrigin(vpos);
        ${0 === f.normalType ? b.glsl`
        vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));`: ""}
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPosition(proj, view, vpos);
        forwardTextureCoordinates();
      }
    `), d.include(w.Slice, f), d.include(h.DiscardOrAdjustAlpha, f), v.add(b.glsl`
      void main() {
        discardBySlice(vpos);
        ${f.hasColorTexture ? b.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        discardOrAdjustAlpha(texColor);`: ""}

        ${3 === f.normalType ? b.glsl`
            vec3 normal = screenDerivativeNormal(vPositionView);`: b.glsl`
            vec3 normal = normalize(vNormalWorld);
            if (gl_FrontFacing == false) normal = -normal;`}
        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
      }
    `)); 4 === f.output && (d.include(c.Transform, { linearDepth: !1 }), d.include(u.TextureCoordinateAttribute, f), d.include(l.VisualVariables, f), f.hasColorTexture && d.fragment.uniforms.add("tex", "sampler2D"), t.add(b.glsl`void main(void) {
vpos = calculateVPos();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();
}`), d.include(w.Slice, f), d.include(h.DiscardOrAdjustAlpha, f), d.include(p.OutputHighlight), v.add(b.glsl`
      void main() {
        discardBySlice(vpos);
        ${f.hasColorTexture ? b.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        discardOrAdjustAlpha(texColor);`: ""}
        outputHighlight();
      }
    `))
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl": function () {
      define(["exports", "../attributes/VertexTextureCoordinates.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.ComputeNormalTexture = function (q, u) {
        const y = q.fragment; u.vertexTangents ? (q.attributes.add("tangent", "vec4"), q.varyings.add("vTangent", "vec4"), 2 === u.doubleSidedMode ? y.code.add(c.glsl`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;
vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`) : y.code.add(c.glsl`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = vTangent.w;
vec3 tangent = normalize(vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`)) : (q.extensions.add("GL_OES_standard_derivatives"), y.code.add(c.glsl`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {
vec3 Q1 = dFdx(pos);
vec3 Q2 = dFdy(pos);
vec2 stx = dFdx(st);
vec2 sty = dFdy(st);
float det = stx.t * sty.s - sty.t * stx.s;
vec3 T = stx.t * Q2 - sty.t * Q1;
T = T - normal * dot(normal, T);
T *= inversesqrt(max(dot(T,T), 1.e-10));
vec3 B = sign(det) * cross(normal, T);
return mat3(T, B, normal);
}`)); 0 !== u.attributeTextureCoordinates && (q.include(w.VertexTextureCoordinates, u), y.uniforms.add("normalTexture", "sampler2D"), y.uniforms.add("normalTextureSize", "vec2"), y.code.add(c.glsl`
    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {
      vtc.uv = uv;
      ${u.supportsTextureAtlas ? "vtc.size \x3d normalTextureSize;" : ""}
      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;
      return tangentSpace * rawNormal;
    }
  `))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.EvaluateAmbientOcclusion = function (c, q) {
        c = c.fragment; q.receiveAmbientOcclusion ? (c.uniforms.add("ssaoTex", "sampler2D"), c.uniforms.add("viewportPixelSz", "vec4"), c.code.add(w.glsl`float evaluateAmbientOcclusion() {
return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;
}
float evaluateAmbientOcclusionInverse() {
float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;
return viewportPixelSz.z < 0.0 ? 1.0 : ssao;
}`)) : c.code.add(w.glsl`float evaluateAmbientOcclusion() { return 0.0; }
float evaluateAmbientOcclusionInverse() { return 1.0; }`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl": function () {
      define("exports ./EvaluateAmbientLighting.glsl ./EvaluateAmbientOcclusion.glsl ./EvaluateMainLighting.glsl ./PhysicallyBasedRendering.glsl ./PiUtils.glsl ./ReadShadowMap.glsl ../../shaderModules/interfaces".split(" "), function (a, w, c, q, u, y, n, p) {
      a.EvaluateSceneLighting = function (l, h) {
        const b = l.fragment;
        l.include(q.EvaluateMainLighting); l.include(c.EvaluateAmbientOcclusion, h); 0 !== h.pbrMode && l.include(u.PhysicallyBasedRendering, h); l.include(w.EvaluateAmbientLighting, h); h.receiveShadows && l.include(n.ReadShadowMap, h); b.uniforms.add("lightingGlobalFactor", "float"); b.uniforms.add("ambientBoostFactor", "float"); l.include(y.PiUtils); b.code.add(p.glsl`
    const float GAMMA_SRGB = 2.1;
    const float INV_GAMMA_SRGB = 0.4761904;
    ${0 === h.pbrMode ? "" : "const vec3 GROUND_REFLECTANCE \x3d vec3(0.2);"}
  `); b.code.add(p.glsl`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${1 === h.viewingMode ? p.glsl`normalize(vPosWorld)` : p.glsl`vec3(0.0, 0.0, 1.0)`}, lightingMainDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `); b.code.add(p.glsl`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;
}`); if (0 === h.pbrMode || 4 === h.pbrMode) b.code.add(p.glsl`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)
{
vec3 mainLighting = evaluateMainLighting(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`); else if (1 === h.pbrMode || 2 === h.pbrMode) b.code.add(p.glsl`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)
{
vec3 viewDirection = -viewDir;
vec3 mainLightDirection = lightingMainDirection;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);
inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);
inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), b.code.add(p.glsl`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), b.code.add(p.glsl`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);
ambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = abs(dot(normal, ambientDir));
vec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), b.code.add(p.glsl`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
vec3 mainLightRadianceComponent = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight;
inputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;
inputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), b.code.add(p.glsl`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;
        ${2 === h.pbrMode ? p.glsl`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : p.glsl`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.Normals = function (c, q) {
        c = c.fragment; c.code.add(w.glsl`struct ShadingNormalParameters {
vec3 normalView;
vec3 viewDirection;
} shadingParams;`); 1 === q.doubleSidedMode ? c.code.add(w.glsl`vec3 shadingNormal(ShadingNormalParameters params) {
return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);
}`) : 2 === q.doubleSidedMode ? c.code.add(w.glsl`vec3 shadingNormal(ShadingNormalParameters params) {
return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);
}`) : c.code.add(w.glsl`vec3 shadingNormal(ShadingNormalParameters params) {
return normalize(params.normalView);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/HeaderComment.glsl": function () {
      define(["exports", "../../shaderModules/interfaces", "../../../../../webgl/checkWebGLError"], function (a, w, c) {
      a.HeaderComment = function (q, u) {
        u = w.glsl`
  /*
  *  ${u.name}
  *  ${0 === u.output ? "RenderOutput: Color" : 1 === u.output ? "RenderOutput: Depth" : 3 === u.output ? "RenderOutput: Shadow" : 2 === u.output ? "RenderOutput: Normal" : 4 === u.output ? "RenderOutput: Highlight" : ""}
  */
  `; c.webglValidateShadersEnabled() && (q.fragment.code.add(u), q.vertex.code.add(u))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl": function () {
      define(["exports", "./ColorConversion.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.MixExternalColor = function (q) {
        q.include(w.ColorConversion); q.code.add(c.glsl`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${c.glsl.int(1)}) {
        return allMixed;
      }
      else if (mode == ${c.glsl.int(2)}) {
        return internalMixed;
      }
      else if (mode == ${c.glsl.int(3)}) {
        return externalColor;
      }
      else {
        // tint (or something invalid)
        float vIn = rgb2v(internalMixed);
        vec3 hsvTint = rgb2hsv(externalColor);
        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
        return hsv2rgb(hsvOut);
      }
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${c.glsl.int(2)}) {
        return internalMixed;
      }
      else if (mode == ${c.glsl.int(3)}) {
        return externalOpacity;
      }
      else {
        // multiply or tint (or something invalid)
        return allMixed;
      }
    }
  `)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/RealisticTreeTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/RealisticTree.glsl ../core/shaderLibrary/util/DoublePrecision.glsl ../core/shaderTechnique/ReloadableShaderModule ../lib/DefaultVertexAttributeLocations ../lib/Program ./DefaultMaterialTechnique".split(" "), function (a, w, c, q, u, y, n, p, l) {
        l = function (h) {
          function b() {
            return h.apply(this, arguments) ||
              this
          } c._inheritsLoose(b, h); b.prototype.initializeProgram = function (d) {
            var f = b.shader.get(); const t = this.configuration; f = f.build({
              OITEnabled: 0 === t.transparencyPassType, output: t.output, viewingMode: d.viewingMode, receiveShadows: t.receiveShadows, slicePlaneEnabled: t.slicePlaneEnabled, sliceHighlightDisabled: t.sliceHighlightDisabled, sliceEnabledForVertexPrograms: !1, symbolColor: t.symbolColors, vvSize: t.vvSize, vvColor: t.vvColor, vvInstancingEnabled: !0, instanced: t.instanced, instancedColor: t.instancedColor, instancedDoublePrecision: t.instancedDoublePrecision,
              pbrMode: t.usePBR ? 1 : 0, hasMetalnessAndRoughnessTexture: !1, hasEmissionTexture: !1, hasOcclusionTexture: !1, hasNormalTexture: !1, hasColorTexture: t.hasColorTexture, receiveAmbientOcclusion: t.receiveAmbientOcclusion, useCustomDTRExponentForWater: !1, normalType: 0, doubleSidedMode: 2, vertexTangents: !1, attributeTextureCoordinates: t.hasColorTexture ? 1 : 0, textureAlphaPremultiplied: t.textureAlphaPremultiplied, attributeColor: t.vertexColors, screenSizePerspectiveEnabled: t.screenSizePerspective, verticalOffsetEnabled: t.verticalOffset,
              offsetBackfaces: t.offsetBackfaces, doublePrecisionRequiresObfuscation: u.doublePrecisionRequiresObfuscation(d.rctx), alphaDiscardMode: t.alphaDiscardMode, supportsTextureAtlas: !1, multipassTerrainEnabled: t.multipassTerrainEnabled, cullAboveGround: t.cullAboveGround
            }); return new p.Program(d.rctx, f, n.Default3D)
          }; return b
        }(l.DefaultMaterialTechnique); l.shader = new y.ReloadableShaderModule(q.RealisticTreeShader, () => new Promise((h, b) => a(["../core/shaderLibrary/default/RealisticTree.glsl"], h, b))); w.RealisticTreeTechnique =
          l; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/chunks/RealisticTree.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl ../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          function D(H) {
            const J = new C.ShaderBuilder, M = J.vertex.code, F = J.fragment.code; J.vertex.uniforms.add("proj", "mat4").add("view", "mat4").add("camPos", "vec3").add("localOrigin", "vec3"); J.include(p.PositionAttribute); J.varyings.add("vpos", "vec3"); J.include(r.VisualVariables, H); J.include(y.InstancedDoublePrecision, H); J.include(d.VerticalOffset, H); if (0 === H.output || 7 === H.output) J.include(n.NormalAttribute, H), J.include(u.Transform, { linearDepth: !1 }),
              H.offsetBackfaces && J.include(c.Offset), H.instancedColor && J.attributes.add("instanceColor", "vec4"), J.varyings.add("vNormalWorld", "vec3"), J.varyings.add("localvpos", "vec3"), H.multipassTerrainEnabled && J.varyings.add("depth", "float"), J.include(h.TextureCoordinateAttribute, H), J.include(w.ForwardLinearDepth, H), J.include(l.SymbolColor, H), J.include(b.VertexColor, H), J.vertex.uniforms.add("externalColor", "vec4"), J.varyings.add("vcolorExt", "vec4"), M.add(B.glsl`
        void main(void) {
          forwardNormalizedVertexColor();
          vcolorExt = externalColor;
          ${H.instancedColor ? "vcolorExt *\x3d instanceColor;" : ""}
          vcolorExt *= vvColor();
          vcolorExt *= getSymbolColor();
          forwardColorMixMode();

          if (vcolorExt.a < ${B.glsl.float(A.symbolAlphaCutoff)}) {
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          }
          else {
            vpos = calculateVPos();
            localvpos = vpos - view[3].xyz;
            vpos = subtractOrigin(vpos);
            vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            ${H.offsetBackfaces ? "gl_Position \x3d offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);" : ""}
          }
          ${H.multipassTerrainEnabled ? B.glsl`depth = (view * vec4(vpos, 1.0)).z;` : ""}
          forwardLinearDepth();
          forwardTextureCoordinates();
        }
      `); 7 === H.output && (J.include(q.Slice, H), J.include(A.DiscardOrAdjustAlpha, H), H.multipassTerrainEnabled && (J.fragment.include(t.ReadLinearDepth), J.include(e.multipassTerrainTest, H)), J.fragment.uniforms.add("camPos", "vec3").add("localOrigin", "vec3").add("opacity", "float").add("layerOpacity", "float"), J.fragment.uniforms.add("view", "mat4"), H.hasColorTexture && J.fragment.uniforms.add("tex", "sampler2D"), J.fragment.include(z.MixExternalColor), F.add(B.glsl`
      void main() {
        discardBySlice(vpos);
        ${H.multipassTerrainEnabled ? B.glsl`terrainDepthTest(gl_FragCoord, depth);` : ""}
        ${H.hasColorTexture ? B.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        ${H.textureAlphaPremultiplied ? "texColor.rgb /\x3d texColor.a;" : ""}
        discardOrAdjustAlpha(texColor);`: B.glsl`vec4 texColor = vec4(1.0);`}
        ${H.attributeColor ? B.glsl`
        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`: B.glsl`
        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));
        `}

        gl_FragColor = vec4(opacity_);
      }
    `)); 0 === H.output && (J.include(q.Slice, H), J.include(m.EvaluateSceneLighting, H), J.include(v.EvaluateAmbientOcclusion, H), J.include(A.DiscardOrAdjustAlpha, H), H.receiveShadows && J.include(k.ReadShadowMap, H), H.multipassTerrainEnabled && (J.fragment.include(t.ReadLinearDepth), J.include(e.multipassTerrainTest, H)), J.fragment.uniforms.add("camPos", "vec3").add("localOrigin", "vec3").add("ambient", "vec3").add("diffuse", "vec3").add("opacity", "float").add("layerOpacity", "float"), J.fragment.uniforms.add("view", "mat4"),
              H.hasColorTexture && J.fragment.uniforms.add("tex", "sampler2D"), J.include(x.PhysicallyBasedRenderingParameters, H), J.include(g.PhysicallyBasedRendering, H), J.fragment.include(z.MixExternalColor), F.add(B.glsl`
      void main() {
        discardBySlice(vpos);
        ${H.multipassTerrainEnabled ? B.glsl`terrainDepthTest(gl_FragCoord, depth);` : ""}
        ${H.hasColorTexture ? B.glsl`
        vec4 texColor = texture2D(tex, vuv0);
        ${H.textureAlphaPremultiplied ? "texColor.rgb /\x3d texColor.a;" : ""}
        discardOrAdjustAlpha(texColor);`: B.glsl`vec4 texColor = vec4(1.0);`}
        vec3 viewDirection = normalize(vpos - camPos);
        ${1 === H.pbrMode ? "applyPBRFactors();" : ""}
        float ssao = evaluateAmbientOcclusionInverse();
        ssao *= getBakedOcclusion();

        float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        ${H.receiveShadows ? "float shadow \x3d readShadowMap(vpos, linearDepth);" : 1 === H.viewingMode ? "float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow \x3d 0.0;"}
        vec3 matColor = max(ambient, diffuse);
        ${H.attributeColor ? B.glsl`
        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`: B.glsl`
        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));
        `}
        ${B.glsl`
        vec3 shadedNormal = normalize(vNormalWorld);
        albedo_ *= 1.2;
        vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
        float alignmentLightView = clamp(dot(viewForward, -lightingMainDirection), 0.0, 1.0);
        float transmittance = 1.0 - clamp(dot(viewForward, shadedNormal), 0.0, 1.0);
        float treeRadialFalloff = vColor.r;
        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
        additionalLight += backLightFactor * lightingMainIntensity;`}
        ${1 === H.pbrMode || 2 === H.pbrMode ? 1 === H.viewingMode ? B.glsl`vec3 normalGround = normalize(vpos + localOrigin);` : B.glsl`vec3 normalGround = vec3(0.0, 0.0, 1.0);` : B.glsl``}
        ${1 === H.pbrMode || 2 === H.pbrMode ? B.glsl`
            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];
            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);`: "vec3 shadedColor \x3d evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);"}
        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);
        ${H.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)); J.include(f.DefaultMaterialAuxiliaryPasses, H); return J
          } const E = Object.freeze({ __proto__: null, build: D }); a.RealisticTreeShader = E; a.build = D
        })
    }, "esri/views/3d/layers/graphics/Graphics3DIconSymbolLayer": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../symbols ../../../../core/asyncUtils ../../../../core/has ../../../../core/Error ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/screenUtils ../../../../core/urlUtils ../../../../chunks/mat4f64 ../../../../chunks/vec2f64 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../support/arcadeOnDemand ../../../../symbols/support/IconSymbol3DLayerResource ../../../../symbols/support/utils ../../../2d/arcade/callExpressionWithFeature ./constants ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DDrapedGraphicLayer ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ./pointUtils ./sdfPrimitives ../support/FastSymbolUpdates ../../terrain/OverlayRenderer ../../webgl-engine/lib/GeometryUtil ../../webgl-engine/lib/RenderGeometry ../../webgl-engine/lib/Texture ../../webgl-engine/materials/HUDMaterial ../../../../symbols/CIMSymbol".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S) {
          function Q(ka) { return l.isSome(ka) ? "cross" === ka || "x" === ka : !1 } const T = f.create(), da = v.fromValues(0, 0, 1), Y = [.25, .25, .75, .75]; u = function (ka) {
            function ea(aa, W, U, X) {
              aa = ka.call(this, aa, W, U, X) || this; aa._cimLayers = null; aa._cimSymbolMaterials = new Map; aa._cimSymbolTextures = new Map; aa._cimMaterialParametersInfo = null; aa._cimRequiredFields = null; aa._cimScaleFactorOrFunction = null; aa._size = null; aa._symbolTextureRatio = 1; aa._outlineSize =
                0; aa._elevationOptions = { supportsOffsetAdjustment: !0, supportsOnTheGround: !0 }; return aa
            } c._inheritsLoose(ea, ka); var ba = ea.prototype; ba.getCachedSize = function () { return { size: this._getIconSize() } }; ba.doLoad = function () {
              var aa = c._asyncToGenerator(function* (W) {
                this._validateOrThrow(); const U = this._prepareMaterialParameters(); var X = this._getPrimitive(); if (l.isSome(X)) this._prepareResourcesPrimitive(U, X); else {
                  X = A.getIconHref(this.symbol, this.symbolLayer); const Z = d.dataComponents(X); Z && "application/json" ===
                    Z.mediaType ? yield this._prepareResourcesCIM(U, JSON.parse(Z.data), W) : yield this._prepareResourcesHref(U, X, W)
                }
              }); return function (W) { return aa.apply(this, arguments) }
            }(); ba._validateOrThrow = function () { if (!this._drivenProperties.size) { var aa = F.validateSymbolLayerSize(this._getIconSize()); if (aa) throw new p("graphics3diconsymbollayer:invalid-size", aa); } }; ba._getIconSize = function () {
              var aa = this.symbolLayer; aa = Math.round(null != aa.size ? b.pt2px(aa.size) : 16); return this._drivenProperties.size ? Math.max(aa, 64) :
                aa
            }; ba._generateTextureCIM = function (aa) {
              const W = this._getGraphicHash(aa); let U = "" === W ? null : this._cimSymbolTextures.get(W); U || (aa = this._context.sharedResources.cimSymbolRasterizer.rasterizeCIMSymbol(this._cimLayers, aa, "esriGeometryPoint", { scaleFactor: this._cimScaleFactorOrFunction }, null, null), this._cimMaterialParametersInfo.anchorPos = this._getAnchorPos("relative", aa.anchorPosition), U = new O.Texture(aa.imageData, { width: aa.imageData.width, height: aa.imageData.height, powerOfTwoResizeMode: 2 }), this._cimSymbolTextures.set(W,
                U), this._context.stage.add(U)); return U
            }; ba._computeSize = function (aa, W) { aa = aa.width / aa.height; return 1 < aa ? [W, Math.round(W / aa)] : [Math.round(W * aa), W] }; ba._prepareMaterialParameters = function () {
              const aa = { anchorPos: this._getAnchorPos(this.symbolLayer.anchor, this.symbolLayer.anchorPosition) }, W = this.symbol; if (W && "point-3d" === W.type && W.hasVisibleVerticalOffset()) {
                const { screenLength: U, minWorldLength: X, maxWorldLength: Z } = W.verticalOffset; aa.verticalOffset = {
                  screenLength: b.pt2px(U), minWorldLength: X || 0, maxWorldLength: null !=
                    Z ? Z : Infinity
                }
              } this._context.screenSizePerspectiveEnabled && (aa.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings); aa.occlusionTest = !0; aa.slicePlaneEnabled = this._context.slicePlaneEnabled; return aa
            }; ba._prepareResourcesPrimitive = function (aa, W) {
              var U = this._getOutlineSize(); if (Q(W) && 0 === U) throw Error("Nothing to render"); this._outlineSize = U; aa.color = this._getFillColor(); aa.outlineColor = this._getOutlineColor(); aa.outlineSize = this._outlineSize; U = this._context.sharedResources.textures.fromData(W,
                () => { switch (W) { case "circle": var X = P.createCircle(128, 64); break; case "square": X = P.createSquare(128, 64); break; case "kite": X = P.createKite(128, 64); break; case "cross": X = P.createCross(128, 64); break; case "x": X = P.createX(128, 64); break; case "triangle": X = P.createTriangle(128, 64) }return X = new O.Texture(X, { mipmap: !1, wrap: { s: 33071, t: 33071 }, width: 128, height: 128, components: 4, noUnpackFlip: !0 }) }); this._texture = U.texture; this._releaseTexture = U; aa.textureIsSignedDistanceField = !0; aa.distanceFieldBoundingBox = Y; aa.textureId =
                  this._texture.id; U = this._getIconSize(); this._size = [U, U]; this._symbolTextureRatio = 2; this._createMaterialAndAddToStage(aa, this._context.stage)
            }; ba._prepareResourcesHref = function () {
              var aa = c._asyncToGenerator(function* (W, U, X) {
                if (!n("esri-canvas-svg-support") && d.isSVG(U)) throw new p("graphics3diconsymbollayer:unsupported-image-format", "IconSymbol3DLayer failed to load (SVG symbols are not supported in IE11)"); this._outlineSize = this._getOutlineSize(); W.color = this._getFillColor(); W.outlineColor = this._getOutlineColor();
                W.outlineSize = this._outlineSize; W.textureIsSignedDistanceField = !1; const Z = this._getIconSize(); X = yield y.result(this._context.sharedResources.textures.fromUrl(U, Z * this._context.layerView.view.pixelRatio, { signal: X })); if (!1 === X.ok) throw h.throwIfAbortError(X.error), new p("graphics3diconsymbollayer:request-failed", `Failed to load (Request for icon resource failed: ${U})`); this._releaseTexture = X.value; U = X.value.texture; this._size = this._computeSize(U.params, Z); W.textureId = U.id; this._createMaterialAndAddToStage(W,
                  this._context.stage)
              }); return function (W, U, X) { return aa.apply(this, arguments) }
            }(); ba._prepareResourcesCIM = function () {
              var aa = c._asyncToGenerator(function* (W, U, X) {
                U = new S({ data: U }); if (!this._context.sharedResources.cimSymbolRasterizer) {
                  var Z = (yield new Promise((ra, Aa) => a(["../../../../symbols/cim/CIMSymbolRasterizer"], ra, Aa))).CIMSymbolRasterizer; h.throwIfAborted(X); this._context.sharedResources.cimSymbolRasterizer || (this._context.sharedResources.cimSymbolRasterizer = new Z(this._context.renderCoordsHelper.spatialReference,
                    !0))
                } Z = this._context.layer.fields ? this._context.layer.fields.map(ra => ra.toJSON()) : null; this._cimLayers = yield this._context.sharedResources.cimSymbolRasterizer.analyzeCIMSymbol(U, Z, this._context.renderer && "dictionary" === this._context.renderer.type ? this._context.renderer.fieldMap : null, "esriGeometryPoint", { signal: X }); let ia; if (this._context.renderer && "dictionary" === this._context.renderer.type && this._context.renderer.scaleExpression) if (U = this._context.renderer, isNaN(U.scaleExpression)) {
                  const ra = yield k.createRendererExpression(U.scaleExpression,
                    this._context.layer.spatialReference, Z); ia = (Aa, za, Ka) => { Aa = z(ra, Aa, { $view: Ka }, "esriGeometryPoint", za); return null !== Aa ? Aa : 1 }
                } else var la = Number(U.scaleExpression); this._cimScaleFactorOrFunction = la || ia || 1; la = this._context.renderer ? yield this._context.renderer.getRequiredFields(this._context.layer.fieldsIndex) : []; h.throwIfAborted(X); const ma = this._context.layer.fieldsIndex; this._cimRequiredFields = la.map(ra => ma.get(ra).name); this._cimMaterialParametersInfo = W; this._cimMaterialParametersInfo.color = this._getFillColor();
                this._cimMaterialParametersInfo.outlineColor = [0, 0, 0, 0]; this._cimMaterialParametersInfo.outlineSize = 0; this._cimMaterialParametersInfo.textureIsSignedDistanceField = !1
              }); return function (W, U, X) { return aa.apply(this, arguments) }
            }(); ba._getPrimitive = function () { return this.symbolLayer.resource && this.symbolLayer.resource.href ? null : this.symbolLayer.resource && this.symbolLayer.resource.primitive || r.defaultPrimitive }; ba._getOutlineSize = function () {
              var aa = 0; aa = this.symbolLayer; if (l.isSome(aa.outline) && null != aa.outline.size) return Math.max(b.pt2px(aa.outline.size),
                0); aa = this._getPrimitive(); aa = Q(aa) ? 1.5 : 0; return Math.max(aa, 0)
            }; ba._getOutlineColor = function () { const aa = this._getLayerOpacity(), W = l.get(this.symbolLayer, "outline", "color"); if (l.isSome(W)) { const U = q.toUnitRGB(W); return [U[0], U[1], U[2], W.a * aa] } return [0, 0, 0, 0] }; ba._getFillColor = function () { if (Q(this._getPrimitive())) return B.TRANSPARENT_UNIT; const aa = l.isNone(this._getPrimitive()), W = l.get(this.symbolLayer, "material", "color"); return this._getCombinedOpacityAndColor(W, { hasIntrinsicColor: aa }) }; ba._getAnchorPos =
              function (aa, W) { return "relative" === aa ? t.fromValues((W.x || 0) + .5, -(W.y || 0) + .5) : aa in F.namedAnchorToHUDMaterialAnchorPos ? F.namedAnchorToHUDMaterialAnchorPos[aa] : F.namedAnchorToHUDMaterialAnchorPos.center }; ba._createMaterialAndAddToStage = function (aa, W) {
              this._fastUpdates = this._cimLayers ? { enabled: !1 } : L.initFastSymbolUpdatesState(this._context.renderer, this._fastVisualVariableConvertOptions()); this._fastUpdates.enabled && Object.assign(aa, this._fastUpdates.materialParameters); if (this._cimLayers) {
                let U = this._cimSymbolMaterials.get(aa.textureId);
                U || (U = new R.HUDMaterial(aa), this._cimSymbolMaterials.set(aa.textureId, U), W.add(U)); return U
              } this._material = new R.HUDMaterial(aa); W.add(this._material); return this._material
              }; ba._setDrapingDependentMaterialParameters = function () { this.draped && (this._forEachMaterial(aa => { aa.setParameters({ verticalOffset: null, screenSizePerspective: null, occlusionTest: !1, slicePlaneEnabled: !1, shaderPolygonOffset: 0, isDraped: this.draped }) }), this.layerOpacityChanged()) }; ba.destroy = function () {
                ka.prototype.destroy.call(this);
                this._forEachMaterial(aa => this._context.stage.remove(aa)); this._material = null; this._cimSymbolMaterials.clear(); this._cimSymbolTextures.forEach(aa => this._context.stage.remove(aa)); this._cimSymbolTextures.clear(); this._releaseTexture = l.releaseMaybe(this._releaseTexture)
              }; ba._getScaleFactor = function (aa, W) {
                if (this._drivenProperties.size && aa.size) {
                  for (let U = 0; 3 > U; U++) { const X = aa.size[U]; X && "symbol-value" !== X && "proportional" !== X && (aa.size[U] = b.pt2px(X)) } if ("symbol-value" === aa.size[0]) return 1; if (isFinite(+aa.size[0])) return +aa.size[0] /
                    W; if (isFinite(+aa.size[2])) return +aa.size[2] / W
                } return 1
              }; ba.createGraphics3DGraphic = function (aa) {
                const W = aa.graphic; if (!this._validateGeometry(W.geometry)) return null; let U; if (this._cimLayers) { if (!this._cimLayers.length) return null; var X = this._generateTextureCIM(W); U = this._createMaterialAndAddToStage({ textureId: X.id, ...this._cimMaterialParametersInfo }, this._context.stage); var Z = [X.params.width, X.params.height] } else Z = this._size, U = l.unwrap(this._material); X = K.placePointOnGeometry(W.geometry); if (l.isNone(X)) return this.logger.warn(`unsupported geometry type for icon symbol: ${W.geometry.type}`),
                  null; var ia = aa.renderingInfo; const la = this._getVertexOpacityAndColor(ia); let ma = 1; this._fastUpdates.enabled && this._fastUpdates.visualVariables.size || (ma = this._getScaleFactor(ia, Z[0] > Z[1] ? Z[0] : Z[1])); ma *= this._symbolTextureRatio; Z = [Z[0] * ma, Z[1] * ma]; ia = this.setGraphicElevationContext(W, new E.ElevationContext); this.ensureDrapedStatus("on-the-ground" === ia.mode) && this._setDrapingDependentMaterialParameters(); return this.draped ? this._createAsOverlay(W, X, U, la, Z, aa.layer.uid) : this._createAs3DShape(W, X, U,
                    la, Z, ia, W.uid)
              }; ba.layerOpacityChanged = function () { const aa = this._getFillColor(), W = this._getOutlineColor(); this._forEachMaterial(U => { U.setParameters({ color: aa }); U.setParameters({ outlineColor: W }) }); return !0 }; ba.layerElevationInfoChanged = function (aa, W, U) {
                const X = this._elevationContext.mode; U = D.elevationModeChangeUpdateType(ea.elevationModeChangeTypes, U, X); if (U !== D.SymbolUpdateType.UPDATE) return U; const Z = D.needsElevationUpdates2D(X) || "absolute-height" === X; return this.updateGraphics3DGraphicElevationInfo(aa,
                  W, () => Z)
              }; ba.slicePlaneEnabledChanged = function () { this.draped || this._forEachMaterial(aa => { aa.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }) }); return !0 }; ba.physicalBasedRenderingChanged = function () { return !0 }; ba.pixelRatioChanged = function () { return this._getPrimitive() ? !0 : !1 }; ba.applyRendererDiff = function (aa, W) {
                for (const U in aa.diff) switch (U) {
                  case "visualVariables": if (L.updateFastSymbolUpdatesState(this._fastUpdates, W, this._fastVisualVariableConvertOptions())) l.isSome(this._material) &&
                    this._material.setParameters(this._fastUpdates.materialParameters); else return 0; break; default: return 0
                }return 2
              }; ba._defaultElevationInfoNoZ = function () { return fa }; ba._createAs3DShape = function (aa, W, U, X, Z, ia, la) {
                const ma = this.getFastUpdateAttrValues(aa); aa = ma ? Aa => L.evaluateModelTransform(this._fastUpdates.materialParameters, ma, Aa) : null; X = [G.createPointGeometry(da, null, X, Z, ha, null, ma)]; la = K.createStageObjectForHUD(this._context, W, X, [U], ia, this._context.layer.uid, la, aa); if (null === la) return null; const ra =
                  new J.Graphics3DObject3DGraphicLayer(this, la.object, X, null, null, C.perObjectElevationAligner, ia); ra.alignedSampledElevation = la.sampledElevation; ra.needsElevationUpdates = D.needsElevationUpdates2D(ia.mode) || "absolute-height" === ia.mode; ra.getScreenSize = this._createScreenSizeGetter(Z, aa); ra.calculateRelativeScreenBounds = Aa => U.calculateRelativeScreenBounds(ra.getScreenSize(), 1, Aa); K.extendPointGraphicElevationContext(ra, W, this._context.elevationProvider); return ra
              }; ba._createAsOverlay = function (aa, W, U, X,
                Z, ia) {
                U.renderPriority = this._renderPriority; const la = e.create(); g.projectPointToVector(W, la, this._context.overlaySR); la[2] = N.DRAPED_Z; W = this._context.clippingExtent; if (l.isSome(W) && !x.containsPoint(W, la)) return null; const ma = this.getFastUpdateAttrValues(aa); W = ma ? Aa => L.evaluateModelTransform(this._fastUpdates.materialParameters, ma, Aa) : null; X = G.createPointGeometry(da, la, X, Z, null, null, ma); aa = new I.RenderGeometry(X, U, ia, aa.uid); la[3] = 0; m.copy(aa.boundingSphere, la); aa.calculateShaderTransformation = W; const ra =
                  new H(this, [aa], null); ra.getScreenSize = this._createScreenSizeGetter(Z, W); ra.calculateRelativeScreenBounds = Aa => U.calculateRelativeScreenBounds(ra.getScreenSize(), 1, Aa); return ra
              }; ba._createScreenSizeGetter = function (aa, W) {
                const U = this._outlineSize + 2; if (this._fastUpdates.enabled) { const X = aa[0] / this._symbolTextureRatio, Z = aa[1] / this._symbolTextureRatio; return (ia = t.create()) => { const la = W(T); ia[0] = la[0] * X + U; ia[1] = la[5] * Z + U; return ia } } {
                  const X = aa[0] / this._symbolTextureRatio + U, Z = aa[1] / this._symbolTextureRatio +
                    U; return (ia = t.create()) => { ia[0] = X; ia[1] = Z; return ia }
                }
              }; ba._fastVisualVariableConvertOptions = function () { var aa = this._size[0] > this._size[1] ? this._size[0] : this._size[1]; const W = v.fromValues(aa, aa, aa), U = b.px2pt(1); aa *= U; aa = v.fromValues(aa, aa, aa); return { modelSize: W, symbolSize: aa, unitInMeters: U, transformation: { anchor: v.ZEROS, scale: v.ONES, rotation: v.ZEROS } } }; ba._getGraphicHash = function (aa) { let W = ""; for (const U of this._cimRequiredFields) W += U + aa.attributes[U]; return W }; ba._forEachMaterial = function (aa) {
                l.isSome(this._material) &&
                aa(this._material); this._cimSymbolMaterials.forEach(aa)
              }; return ea
          }(M.Graphics3DSymbolLayer); u.PRIMITIVE_SIZE = [64, 64]; u.elevationModeChangeTypes = { definedChanged: D.SymbolUpdateType.UPDATE, staysOnTheGround: D.SymbolUpdateType.NONE, onTheGroundChanged: D.SymbolUpdateType.RECREATE }; const fa = { mode: "relative-to-ground", offset: 0 }, ha = e.fromValues(0, 0, 0, 1); w.Graphics3DIconSymbolLayer = u; w.default = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/2d/arcade/callExpressionWithFeature": function () {
      define(["../../../core/Error",
        "../../../core/Logger", "../../../geometry/support/quantizationUtils"], function (a, w, c) {
          function q(y) {
            const n = {}; switch (y) {
              case "esriGeometryPoint": return (p, l, h, b) => c.unquantizePoint(l, n, p, h, b); case "esriGeometryPolygon": return (p, l, h, b) => c.unquantizePolygon(l, n, p, h, b); case "esriGeometryPolyline": return (p, l, h, b) => c.unquantizePolyline(l, n, p, h, b); case "esriGeometryMultipoint": return (p, l, h, b) => c.unquantizeMultipoint(l, n, p, h, b); default: return w.getLogger("esri.views.2d.support.arcadeOnDemand").error(new a("mapview-arcade",
                `Unable to handle geometryType: ${y}`)), p => p
            }
          } const u = new Map; return function (y, n, p, l, h) { if (y.referencesGeometry() && h) { { const { transform: b, hasZ: d, hasM: f } = h; u.has(l) || u.set(l, q(l)); l = u.get(l)(n.geometry, b, d, f); n = { ...n, geometry: l } } } n = y.repurposeFeature(n); try { return y.evaluate({ ...p, $feature: n }) } catch (b) { return w.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", b), null } }
        })
    }, "esri/views/3d/layers/graphics/constants": function () {
      define(["exports", "../../../../chunks/vec4f64"],
        function (a, w) { const c = w.ZEROS; w = w.ONES; a.SUSPEND_RESUME_EXTENT_OPTIMISM = 1.2; a.TRANSPARENT_UNIT = c; a.WHITE_UNIT = w; a.defaultIconElevationOffset = 1; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/layers/graphics/Graphics3DDrapedGraphicLayer": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ./graphicUtils".split(" "),
        function (a, w, c, q, u, y, n) {
          let p = function () {
            function d(t, v, m) { this.graphics3DSymbolLayer = t; this.renderGeometries = v; this.boundingBox = m; this.type = "draped"; this.stage = null; this._addedToStage = this._visible = !1; this._layerView = null; this.isElevationSource = !1 } var f = d.prototype; f.initialize = function (t, v, m) { this.stage = t; this._layerView = m; this._overlayRenderer = this._layerView.view.basemapTerrain.overlayManager.renderer }; f.setVisibility = function (t) {
              if (null != this.stage && this._visible !== t) if ((this._visible = t) && !this._addedToStage) this._addedToStage =
                !0, this._overlayRenderer.addGeometries(this.renderGeometries, this._layerView, 1); else if (t || this._addedToStage) { for (const v of this.renderGeometries) v.instanceParameters.visible = this._visible; this._overlayRenderer.updateGeometries(this.renderGeometries, this._layerView, 1) }
            }; f.destroy = function () { this.stage && this._addedToStage && this._overlayRenderer.removeGeometries(this.renderGeometries, this._layerView, 4); this._visible = this._addedToStage = !1; this.stage = null }; f.getCenterObjectSpace = function (t = q.create()) {
              return c.set(t,
                0, 0, 0)
            }; f.getBoundingBoxObjectSpace = function (t = u.create()) { return u.empty(t) }; f.addObjectState = function (t, v) { 0 === t && (this.renderGeometries.forEach(m => { const e = m.addHighlight(); v.addRenderGeometry(m, e, this) }), this._addedToStage && this._overlayRenderer.updateHighlights(this.renderGeometries, this._layerView)) }; f.removeObjectState = function (t) { this.renderGeometries.forEach(v => { t.removeRenderGeometry(v) }) }; f.removeRenderGeometryObjectState = function (t, v) {
              t.removeHighlight(v); this._addedToStage && this._overlayRenderer.updateHighlights(this.renderGeometries,
                this._layerView)
            }; f.computeAttachmentOrigin = function (t) { for (const v of this.renderGeometries) v.computeAttachmentOrigin(b) && (t.draped.origin[0] += b[0], t.draped.origin[1] += b[1], t.draped.num++) }; f.getProjectedBoundingBox = function () {
              var t = a._asyncToGenerator(function* (v, m, e, g, x) {
                u.empty(x); for (let k = 0; k < this.renderGeometries.length; k++)this._getRenderGeometryProjectedBoundingRect(this.renderGeometries[k], v, l, e), u.expandWithRect(x, l); if (m) {
                  u.center(x, b); let k; v = n.demResolutionForBoundingBox(x, m); try {
                    k =
                    yield m.service.queryElevation(b[0], b[1], g, v, "ground")
                  } catch (r) { } w.isSome(k) && (x[2] = Math.min(x[2], k), x[5] = Math.max(x[5], k))
                } return x
              }); return function (v, m, e, g, x) { return t.apply(this, arguments) }
            }(); f._getRenderGeometryProjectedBoundingRect = function (t, v, m, e) {
              if (this.boundingBox) u.set(h, this.boundingBox); else { t = t.boundingSphere; const g = t[3]; h[0] = t[0] - g; h[1] = t[1] - g; h[2] = t[2] - g; h[3] = t[0] + g; h[4] = t[1] + g; h[5] = t[2] + g } v(h, 0, 2); this.calculateRelativeScreenBounds && e.push({ location: u.center(h), screenSpaceBoundingRect: this.calculateRelativeScreenBounds() });
              return u.toRect(h, m)
            }; return d
          }(); const l = y.create(), h = u.create(), b = q.create(); return p
        })
    }, "esri/views/3d/layers/graphics/sdfPrimitives": function () {
      define(["exports", "../../../../core/has", "../../../../core/floatRGBA"], function (a, w, c) {
        function q(d, f) { const t = new Uint8Array(4 * d * d), v = d / 2 - .5; f /= 2; for (let e = 0; e < d; e++)for (let g = 0; g < d; g++) { const x = g + d * e; var m = g - v; const k = e - v; m = Math.sqrt(m * m + k * k) - f; m = m / d + .5; c.packFloatRGBA(m, t, 4 * x) } return t } function u(d, f) { return h(d, f, !1) } function y(d, f) { return h(d, f, !0) }
        function n(d, f) { return b(d, f, !1) } function p(d, f) { return b(d, f, !0) } function l(d, f) { const t = new Uint8Array(4 * d * d), v = Math.sqrt(1.25), m = (d - f) / 2; for (let e = 0; e < d; e++)for (let g = 0; g < d; g++) { const x = (g - m) / f, k = (e - m + .75) / f; c.packFloatRGBA(Math.max(-(1 * x + -.5 * k) / v, (x - 1 + -.5 * -k) / v, -k) * f / d + .5, t, 4 * (e * d + g)) } return t } function h(d, f, t) {
          t && (f /= Math.SQRT2); const v = new Uint8Array(4 * d * d); for (let e = 0; e < d; e++)for (let g = 0; g < d; g++) {
            var m = g - .5 * d + .25; let x = -e + .5 * d - .75; const k = e * d + g; if (t) {
              const r = (m + x) / Math.SQRT2; x = (x - m) / Math.SQRT2;
              m = r
            } m = Math.max(Math.abs(m), Math.abs(x)) - .5 * f; m = m / d + .5; c.packFloatRGBA(m, v, 4 * k)
          } return v
        } function b(d, f, t) { t && (f *= Math.SQRT2); f *= .5; const v = new Uint8Array(4 * d * d); for (let e = 0; e < d; e++)for (let g = 0; g < d; g++) { var m = g - .5 * d; let x = -e + .5 * d - 1; const k = e * d + g; if (t) { const r = (m + x) / Math.SQRT2; x = (x - m) / Math.SQRT2; m = r } m = Math.abs(m); x = Math.abs(x); m = m > x ? m > f ? Math.sqrt((m - f) * (m - f) + x * x) : x : x > f ? Math.sqrt(m * m + (x - f) * (x - f)) : m; m = m / d + .5; c.packFloatRGBA(m, v, 4 * k) } return v } a.createCircle = q; a.createCross = n; a.createKite = y; a.createSquare =
          u; a.createTriangle = l; a.createType = function (d, f, t) { switch (d) { case "circle": return q(f, t); case "square": return u(f, t); case "cross": return n(f, t); case "x": return p(f, t); case "kite": return y(f, t); case "triangle": return l(f, t); default: return q(f, t) } }; a.createX = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/FastSymbolUpdates": function () {
      define("exports ../../../../core/has ../../../../core/mathUtils ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../renderers/support/lengthUtils ../../support/debugFlags".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(F) { return null !== F && void 0 !== F } function f(F) { return "number" === typeof F } function t(F) { return "string" === typeof F } function v(F, K) { F && F.push(K) } function m(F, K, P, L = n.create()) { F = F || 0; K = K || 0; P = P || 0; 0 !== F && y.rotateZ(L, L, -F / 180 * Math.PI); 0 !== K && y.rotateX(L, L, K / 180 * Math.PI); 0 !== P && y.rotateY(L, L, P / 180 * Math.PI); return L } function e(F, K, P, L, N) {
            const G = F.minSize, I = F.maxSize; if (F.expression) return v(N, "Could not convert size info: expression not supported"), !1; if (F.useSymbolValue) return F =
              L.symbolSize[P], K.minSize[P] = F, K.maxSize[P] = F, K.offset[P] = K.minSize[P], K.factor[P] = 0, K.type[P] = 1, !0; if (d(F.field)) {
                if (d(F.stops)) { if (2 === F.stops.length && f(F.stops[0].size) && f(F.stops[1].size)) return g(F.stops[0].size, F.stops[1].size, F.stops[0].value, F.stops[1].value, K, P), K.type[P] = 1, !0; v(N, "Could not convert size info: stops only supported with 2 elements"); return !1 } if (f(G) && f(I) && d(F.minDataValue) && d(F.maxDataValue)) return g(G, I, F.minDataValue, F.maxDataValue, K, P), K.type[P] = 1, !0; if (null != h.meterIn[F.valueUnit]) return K.minSize[P] =
                  -Infinity, K.maxSize[P] = Infinity, K.offset[P] = 0, K.factor[P] = 1 / h.meterIn[F.valueUnit], K.type[P] = 1, !0; if ("unknown" === F.valueUnit) return v(N, "Could not convert size info: proportional size not supported"), !1; v(N, "Could not convert size info: scale-dependent size not supported"); return !1
              } if (!d(F.field)) {
                if (F.stops && F.stops[0] && f(F.stops[0].size)) return K.minSize[P] = F.stops[0].size, K.maxSize[P] = F.stops[0].size, K.offset[P] = K.minSize[P], K.factor[P] = 0, K.type[P] = 1, !0; if (f(G)) return K.minSize[P] = G, K.maxSize[P] =
                  G, K.offset[P] = G, K.factor[P] = 0, K.type[P] = 1, !0
              } v(N, "Could not convert size info: unsupported variant of sizeInfo"); return !1
          } function g(F, K, P, L, N, G) { L = 0 < Math.abs(L - P) ? (K - F) / (L - P) : 0; N.minSize[G] = 0 < L ? F : K; N.maxSize[G] = 0 < L ? K : F; N.offset[G] = F - P * L; N.factor[G] = L } function x(F, K, P, L) {
            if (F.normalizationField || F.valueRepresentation) return v(L, "Could not convert size info: unsupported property"), null; var N = F.field; if (null != N && !t(N)) return v(L, "Could not convert size info: field is not a string"), null; if (!K.size) K.size =
              { field: F.field, minSize: [0, 0, 0], maxSize: [0, 0, 0], offset: [0, 0, 0], factor: [0, 0, 0], type: [0, 0, 0] }; else if (F.field) if (!K.size.field) K.size.field = F.field; else if (F.field !== K.size.field) return v(L, "Could not convert size info: multiple fields in use"), null; switch (F.axis) {
                case "width": return (N = e(F, K.size, 0, P, L)) ? K : null; case "height": return (N = e(F, K.size, 2, P, L)) ? K : null; case "depth": return (N = e(F, K.size, 1, P, L)) ? K : null; case "width-and-depth": return (N = e(F, K.size, 0, P, L)) && e(F, K.size, 1, P, L), N ? K : null; case null: case void 0: case "all": return (N =
                  (N = (N = e(F, K.size, 0, P, L)) && e(F, K.size, 1, P, L)) && e(F, K.size, 2, P, L)) ? K : null; default: return v(L, `Could not convert size info: unknown axis "${F.axis}""`), null
              }
          } function k(F, K, P) {
            for (let L = 0; 3 > L; ++L) { let N = K.unitInMeters; 1 === F.type[L] && (N *= K.modelSize[L], F.type[L] = 2); F.minSize[L] /= N; F.maxSize[L] /= N; F.offset[L] /= N; F.factor[L] /= N } if (0 !== F.type[0]) K = 0; else if (0 !== F.type[1]) K = 1; else if (0 !== F.type[2]) K = 2; else return v(P, "No size axis contains a valid size or scale"), !1; for (P = 0; 3 > P; ++P)0 === F.type[P] && (F.minSize[P] =
              F.minSize[K], F.maxSize[P] = F.maxSize[K], F.offset[P] = F.offset[K], F.factor[P] = F.factor[K], F.type[P] = F.type[K]); return !0
          } function r(F, K, P) { F[4 * K] = P.r / 255; F[4 * K + 1] = P.g / 255; F[4 * K + 2] = P.b / 255; F[4 * K + 3] = P.a } function A(F, K, P) {
            if (F.normalizationField) return v(P, "Could not convert color info: unsupported property"), null; if (t(F.field)) if (F.stops) {
              if (8 < F.stops.length) return v(P, "Could not convert color info: too many color stops"), null; K.color = {
                field: F.field, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
              }; F = F.stops; for (P = 0; 8 > P; ++P) { const L = F[Math.min(P, F.length - 1)]; K.color.values[P] = L.value; r(K.color.colors, P, L.color) }
            } else return v(P, "Could not convert color info: missing stops or colors"), null; else if (F.stops && 0 <= F.stops.length) for (F = F.stops && 0 <= F.stops.length && F.stops[0].color, K.color = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, P = 0; 8 > P; P++)K.color.values[P] = Infinity, r(K.color.colors,
              P, F); else return v(P, "Could not convert color info: no field and no colors/stops"), null; return K
          } function z(F, K, P) {
            if (F.normalizationField) return v(P, "Could not convert opacity info: unsupported property"), null; if (t(F.field)) if (F.stops) {
              if (8 < F.stops.length) return v(P, "Could not convert opacity info: too many opacity stops"), null; K.opacity = { field: F.field, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] }; F = F.stops; for (P = 0; 8 > P; ++P) {
                const L = F[Math.min(P, F.length - 1)]; K.opacity.values[P] = L.value;
                K.opacity.opacityValues[P] = L.opacity
              }
            } else return v(P, "Could not convert opacity info: missing stops or opacities"), null; else if (F.stops && 0 <= F.stops.length) for (F = F.stops && 0 <= F.stops.length && F.stops[0].opacity, K.opacity = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] }, P = 0; 8 > P; P++)K.opacity.values[P] = Infinity, K.opacity.opacityValues[P] = F; else return v(P, "Could not convert opacity info: no field and no opacities/stops"), null; return K
          } function B(F, K, P) {
            F = 2 === P && "arithmetic" === F.rotationType;
            K.offset[P] = F ? 90 : 0; K.factor[P] = F ? -1 : 1; K.type[P] = 1
          } function C(F, K, P) {
            if (!t(F.field)) return v(P, "Could not convert rotation info: field is not a string"), null; if (!K.rotation) K.rotation = { field: F.field, offset: [0, 0, 0], factor: [1, 1, 1], type: [0, 0, 0] }; else if (F.field) if (!K.rotation.field) K.rotation.field = F.field; else if (F.field !== K.rotation.field) return v(P, "Could not convert rotation info: multiple fields in use"), null; switch (F.axis) {
              case "tilt": return B(F, K.rotation, 0), K; case "roll": return B(F, K.rotation,
                1), K; case null: case void 0: case "heading": return B(F, K.rotation, 2), K; default: return v(P, `Could not convert rotation info: unknown axis "${F.axis}""`), null
            }
          } function D(F, K, P) {
            if (!F) return null; const L = !K.supportedTypes || !!K.supportedTypes.size, N = !K.supportedTypes || !!K.supportedTypes.color, G = !K.supportedTypes || !!K.supportedTypes.rotation, I = !!K.supportedTypes && !!K.supportedTypes.opacity, O = F.reduce((R, S) => {
              if (!R) return R; if (S.valueExpression) return v(P, "Could not convert visual variables: arcade expressions not supported"),
                null; switch (S.type) { case "size": return L ? x(S, R, K, P) : R; case "color": return N ? A(S, R, P) : R; case "opacity": return I ? z(S, R, P) : null; case "rotation": return G ? C(S, R, P) : R; default: return null }
            }, { size: null, color: null, opacity: null, rotation: null }); return 0 < F.length && O && !O.size && !O.color && !O.opacity && !O.rotation || O && O.size && !k(O.size, K, P) ? null : O
          } function E(F, K, P) {
            if (!!F !== !!K || F && F.field !== K.field) return !1; if (F && "rotation" === P) for (P = 0; 3 > P; P++)if (F.type[P] !== K.type[P] || F.offset[P] !== K.offset[P] || F.factor[P] !== K.factor[P]) return !1;
            return !0
          } function H(F, K) {
            const P = { vvSizeEnabled: !1, vvSizeMinSize: null, vvSizeMaxSize: null, vvSizeOffset: null, vvSizeFactor: null, vvSizeValue: null, vvColorEnabled: !1, vvColorValues: null, vvColorColors: null, vvOpacityEnabled: !1, vvOpacityValues: null, vvOpacityOpacities: null, vvSymbolAnchor: null, vvSymbolRotationMatrix: null }, L = F && null != F.size; F && F.size ? (P.vvSizeEnabled = !0, P.vvSizeMinSize = F.size.minSize, P.vvSizeMaxSize = F.size.maxSize, P.vvSizeOffset = F.size.offset, P.vvSizeFactor = F.size.factor) : F && L && (P.vvSizeValue =
              K.transformation.scale); F && L && (P.vvSymbolAnchor = K.transformation.anchor, P.vvSymbolRotationMatrix = u.create(), y.identity(M), m(K.transformation.rotation[2], K.transformation.rotation[0], K.transformation.rotation[1], M), q.fromMat4(P.vvSymbolRotationMatrix, M)); F && F.color && (P.vvColorEnabled = !0, P.vvColorValues = F.color.values, P.vvColorColors = F.color.colors); F && F.opacity && (P.vvOpacityEnabled = !0, P.vvOpacityValues = F.opacity.values, P.vvOpacityOpacities = F.opacity.opacityValues); return P
          } var J; (function (F) {
            const K =
              n.create(), P = l.create(); F.evaluateModelTransform = function (L, N, G) { if (!L.vvSizeEnabled) return G; y.copy(K, G); G = L.vvSymbolRotationMatrix; y.set(M, G[0], G[1], G[2], 0, G[3], G[4], G[5], 0, G[6], G[7], G[8], 0, 0, 0, 0, 1); y.multiply(K, K, M); for (G = 0; 3 > G; ++G)P[G] = c.clamp(L.vvSizeOffset[G] + N[0] * L.vvSizeFactor[G], L.vvSizeMinSize[G], L.vvSizeMaxSize[G]); y.scale(K, K, P); y.translate(K, K, L.vvSymbolAnchor); return K }; F.evaluateModelTransformScale = function (L, N, G) {
                if (!N.vvSizeEnabled) return p.set(L, 1, 1, 1); for (let I = 0; 3 > I; ++I)L[I] = c.clamp(N.vvSizeOffset[I] +
                  G[0] * N.vvSizeFactor[I], N.vvSizeMinSize[I], N.vvSizeMaxSize[I]); return L
              }
          })(J || (J = {})); const M = n.create(); w = J.evaluateModelTransform; J = J.evaluateModelTransformScale; a.convertVisualVariables = D; a.evaluateModelTransform = w; a.evaluateModelTransformScale = J; a.getMaterialParams = H; a.initFastSymbolUpdatesState = function (F, K) { return !F || b.TESTS_DISABLE_FAST_UPDATES ? { enabled: !1 } : (F = D(F.visualVariables, K)) ? { enabled: !0, visualVariables: F, materialParameters: H(F, K), requiresShaderTransformation: F && null != F.size } : { enabled: !1 } };
          a.updateFastSymbolUpdatesState = function (F, K, P) { if (!K || !F.enabled) return !1; const L = F.visualVariables; K = D(K.visualVariables, P); if (!(K && E(L.size, K.size, "size") && E(L.color, K.color, "color") && E(L.rotation, K.rotation, "rotation") && E(L.opacity, K.opacity, "opacity"))) return !1; F.visualVariables = K; F.materialParameters = H(K, P); F.requiresShaderTransformation = K && null != K.size; return !0 }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/RenderGeometry": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/uid ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec4f64 ../../support/mathUtils ./geometryDataUtils ./Object3DStateID ../materials/renderers/utils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          let f = function () {
            function v(e, g, x = null, k = null, r = q.generateUID(), A = null, z = null, B = !1) { this.data = e; this.material = g; this.layerUid = x; this.graphicUid = k; this.id = r; this.boundingInfo = A; this.calculateShaderTransformation = z; this.castShadow = B; this.boundingSphere = p.create(); this.instanceParameters = { highlights: null, occludees: null, visible: !0 }; this._transformation = y.create(); this._shaderTransformationDirty = !0 } var m = v.prototype; m.updateTransformation = function (e) {
              e(this._transformation);
              this._shaderTransformationDirty = !0; this.computeBoundingSphere(this._transformation, this.boundingSphere)
            }; m.shaderTransformationChanged = function () { this._shaderTransformationDirty = !0 }; m.computeBoundingSphere = function (e, g, x = l.maxScale(e)) { c.isNone(this.boundingInfo) || (n.transformMat4(g, this.boundingInfo.getCenter(), e), g[3] = this.boundingInfo.getBSRadius() * x) }; m.getShaderTransformation = function () {
              if (c.isNone(this.calculateShaderTransformation)) return c.unwrapOr(this.transformation, y.IDENTITY); this._shaderTransformationDirty &&
                (this._shaderTransformation || (this._shaderTransformation = y.create()), u.copy(this._shaderTransformation, this.calculateShaderTransformation(c.unwrapOr(this.transformation, y.IDENTITY))), this._shaderTransformationDirty = !1); return this._shaderTransformation
            }; m.computeAttachmentOrigin = function (e) {
              if (this.material.computeAttachmentOrigin) return this.material.computeAttachmentOrigin(this, e) ? (c.isSome(this._transformation) && n.transformMat4(e, e, this._transformation), !0) : !1; const g = this.indices.get("position"),
                x = this.vertexAttributes.get("position"); return h.computeAttachmentOriginTriangles(x, g, e) ? (c.isSome(this._transformation) && n.transformMat4(e, e, this._transformation), !0) : !1
            }; m.addHighlight = function () { const e = new b.Object3DStateID(0), g = this.instanceParameters; g.highlights = d.addObject3DStateID(g.highlights, e); return e }; m.removeHighlight = function (e) { const g = this.instanceParameters; g.highlights = d.removeObject3DStateID(g.highlights, e) }; w._createClass(v, [{ key: "transformation", get: function () { return this._transformation } },
            { key: "hasShaderTransformation", get: function () { return c.isSome(this.calculateShaderTransformation) } }, { key: "primitiveType", get: function () { return this.data.primitiveType } }, { key: "indices", get: function () { return this.data.indices } }, { key: "vertexAttributes", get: function () { return this.data.vertexAttributes } }]); return v
          }(), t = function (v) { function m() { return v.apply(this, arguments) || this } w._inheritsLoose(m, v); return m }(f); a.RenderGeometry = f; a.ValidatedRenderGeometry = t; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/webgl-engine/lib/Texture": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/compilerUtils ../../../../core/Error ../../../../core/Evented ../../../../core/mathUtils ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/typedArrayUtil ../../../../core/urlUtils ../../../../support/requestImageUtils ../../../../support/requestUtils ./BasisUtil ./ContentObject ./DDSUtil ./glUtil3D ./Util ../../../webgl/FramebufferObject ../../../webgl/Texture ../../../webgl/Util ../../../webgl/capabilities/isWebGL2Context".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
          t = function (A) {
            function z(C, D) {
              var E = A.call(this) || this; E.data = C; E.type = 4; E._glTexture = null; E._powerOfTwoStretchInfo = null; E._loadingPromise = null; E._loadingController = null; E.events = new u; E.params = D || {}; E.params.mipmap = !1 !== E.params.mipmap; E.params.noUnpackFlip = E.params.noUnpackFlip || !1; E.params.preMultiplyAlpha = E.params.preMultiplyAlpha || !1; E.params.wrap = E.params.wrap || { s: 10497, t: 10497 }; E.params.powerOfTwoResizeMode = E.params.powerOfTwoResizeMode ||
                1; E.estimatedTexMemRequired = z.estimateTexMemRequired(E.data, E.params); E.startPreload(); return E
            } w._inheritsLoose(z, A); var B = z.prototype; B.startPreload = function () { const C = this.data; n.isNone(C) || (C instanceof HTMLVideoElement ? this.startPreloadVideoElement(C) : C instanceof HTMLImageElement && this.startPreloadImageElement(C)) }; B.startPreloadVideoElement = function (C) { h.isBlobProtocol(C.src) || "auto" === C.preload && C.crossOrigin || (C.preload = "auto", C.crossOrigin = "anonymous", C.src = C.src) }; B.startPreloadImageElement =
              function (C) { h.isDataProtocol(C.src) || h.isBlobProtocol(C.src) || C.crossOrigin || (C.crossOrigin = "anonymous", C.src = C.src) }; z.getDataDimensions = function (C) { return C instanceof HTMLVideoElement ? { width: C.videoWidth, height: C.videoHeight } : C }; z.estimateTexMemRequired = function (C, D) {
                if (n.isNone(C)) return 0; if (l.isArrayBuffer(C) || l.isUint8Array(C)) return D.encoding === z.KTX2_ENCODING ? f.estimateMemoryKTX2(C, D.mipmap) : D.encoding === z.BASIS_ENCODING ? f.estimateMemoryBasis(C, D.mipmap) : C.byteLength; const { width: E, height: H } =
                  C instanceof Image || C instanceof ImageData || C instanceof HTMLCanvasElement || C instanceof HTMLVideoElement ? z.getDataDimensions(C) : D; return (D.mipmap ? 4 / 3 : 1) * E * H * (D.components || 4) || 0
              }; B.dispose = function () { this.data = void 0 }; B.createDescriptor = function (C) {
                var D; return {
                  target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: this.params.wrap, flipped: !this.params.noUnpackFlip, samplingMode: this.params.mipmap ? 9987 : 9729, hasMipmap: this.params.mipmap, preMultiplyAlpha: this.params.preMultiplyAlpha, maxAnisotropy: null !=
                    (D = this.params.maxAnisotropy) ? D : this.params.mipmap ? C.parameters.maxMaxAnisotropy : 1
                }
              }; B.load = function (C, D) {
                if (n.isSome(this._glTexture)) return this._glTexture; if (n.isSome(this._loadingPromise)) return this._loadingPromise; const E = this.data; return n.isNone(E) ? this._glTexture = new x(C, this.createDescriptor(C), null) : "string" === typeof E ? this.loadFromURL(C, D, E) : E instanceof Image ? this.loadFromImageElement(C, D, E) : E instanceof HTMLVideoElement ? this.loadFromVideoElement(C, D, E) : E instanceof ImageData || E instanceof
                  HTMLCanvasElement ? this.loadFromImage(C, E, D) : (l.isArrayBuffer(E) || l.isUint8Array(E)) && this.params.encoding === z.DDS_ENCODING ? this.loadFromDDSData(C, E) : (l.isArrayBuffer(E) || l.isUint8Array(E)) && this.params.encoding === z.KTX2_ENCODING ? this.loadFromKTX2(C, E) : (l.isArrayBuffer(E) || l.isUint8Array(E)) && this.params.encoding === z.BASIS_ENCODING ? this.loadFromBasis(C, E) : l.isUint8Array(E) ? this.loadFromPixelData(C, E) : l.isArrayBuffer(E) ? this.loadFromPixelData(C, new Uint8Array(E)) : null
              }; B.frameUpdate = function (C, D, E) {
                if (!(this.data instanceof
                  HTMLVideoElement) || n.isNone(this._glTexture) || 2 > this.data.readyState || E === this.data.currentTime) return E; if (n.isSome(this._powerOfTwoStretchInfo)) { const { framebuffer: H, vao: J, sourceTexture: M } = this._powerOfTwoStretchInfo; M.setData(this.data); this.drawStretchedTexture(C, D, H, J, M, this._glTexture) } else { const { width: H, height: J } = this.data, { width: M, height: F } = this._glTexture.descriptor; H !== M || J !== F ? this._glTexture.updateData(0, 0, 0, Math.min(H, M), Math.min(J, F), this.data) : this._glTexture.setData(this.data) } this._glTexture.descriptor.hasMipmap &&
                    this._glTexture.generateMipmap(); return this.data.currentTime
              }; B.loadFromDDSData = function (C, D) { return this._glTexture = v.createDDSTexture(C, this.createDescriptor(C), D) }; B.loadFromKTX2 = function (C, D) { return this.loadAsync(() => f.createTextureKTX2(C, this.createDescriptor(C), D).then(E => this._glTexture = E)) }; B.loadFromBasis = function (C, D) { return this.loadAsync(() => f.createTextureBasis(C, this.createDescriptor(C), D).then(E => this._glTexture = E)) }; B.loadFromPixelData = function (C, D) {
                e.assert(0 < this.params.width &&
                  0 < this.params.height); const E = this.createDescriptor(C); E.pixelFormat = 1 === this.params.components ? 6409 : 3 === this.params.components ? 6407 : 6408; E.width = this.params.width; E.height = this.params.height; return this._glTexture = new x(C, E, D)
              }; B.loadFromURL = function (C, D, E) { var H = this; return this.loadAsync(function () { var J = w._asyncToGenerator(function* (M) { M = yield b.requestImage(E, { signal: M }); return H.loadFromImage(C, M, D) }); return function (M) { return J.apply(this, arguments) } }()) }; B.loadFromImageElement = function (C,
                D, E) { var H = this; return E.complete ? this.loadFromImage(C, E, D) : this.loadAsync(function () { var J = w._asyncToGenerator(function* (M) { M = yield d.loadImageAsync(E, E.src, !1, M); return H.loadFromImage(C, M, D) }); return function (M) { return J.apply(this, arguments) } }()) }; B.loadFromVideoElement = function (C, D, E) { return 2 <= E.readyState ? this.loadFromImage(C, E, D) : this.loadFromVideoElementAsync(C, D, E) }; B.loadFromVideoElementAsync = function (C, D, E) {
                  return this.loadAsync(H => new Promise((J, M) => {
                    const F = () => {
                      E.removeEventListener("loadeddata",
                        K); E.removeEventListener("error", P); n.removeMaybe(L)
                    }, K = () => { 2 <= E.readyState && (F(), J(this.loadFromImage(C, E, D))) }, P = N => { F(); M(N || new q("Failed to load video")) }; E.addEventListener("loadeddata", K); E.addEventListener("error", P); const L = p.onAbort(H, () => P(p.createAbortError()))
                  }))
                }; B.loadFromImage = function (C, D, E) {
                  const H = z.getDataDimensions(D); this.params.width = H.width; this.params.height = H.height; const J = this.createDescriptor(C); J.pixelFormat = 3 === this.params.components ? 6407 : 6408; if (this.requiresPowerOfTwo(C,
                    J) && (!y.isPowerOfTwo(H.width) || !y.isPowerOfTwo(H.height))) return this._glTexture = this.makePowerOfTwoTexture(C, D, H, J, E); J.width = H.width; J.height = H.height; return this._glTexture = new x(C, J, D)
                }; B.loadAsync = function (C) { const D = new AbortController; this._loadingController = D; const E = C(D.signal); this._loadingPromise = E; C = () => { this._loadingController === D && (this._loadingController = null); this._loadingPromise === E && (this._loadingPromise = null) }; E.then(C, C); return E }; B.requiresPowerOfTwo = function (C, D) {
                  const E = "number" ===
                    typeof D.wrapMode ? 33071 === D.wrapMode : 33071 === D.wrapMode.s && 33071 === D.wrapMode.t; return !r(C.gl) && (D.hasMipmap || !E)
                }; B.makePowerOfTwoTexture = function (C, D, E, H, J) {
                  const { width: M, height: F } = E; E = y.nextHighestPowerOfTwo(M); const K = y.nextHighestPowerOfTwo(F); H.width = E; H.height = K; let P; switch (this.params.powerOfTwoResizeMode) { case 2: H.textureCoordinateScaleFactor = [M / E, F / K]; P = new x(C, H); P.updateData(0, 0, 0, M, F, D); break; case 1: case null: case void 0: P = this.stretchToPowerOfTwo(C, D, H, J()); break; default: c.neverReached(this.params.powerOfTwoResizeMode) }H.hasMipmap &&
                    P.generateMipmap(); return P
                }; B.stretchToPowerOfTwo = function (C, D, E, H) {
                  const J = new x(C, E), M = new g(C, { colorTarget: 0, depthStencilTarget: 0 }, J); D = new x(C, { target: 3553, pixelFormat: E.pixelFormat, dataType: 5121, wrapMode: 33071, samplingMode: 9729, flipped: !!E.flipped, maxAnisotropy: 8, preMultiplyAlpha: E.preMultiplyAlpha }, D); E = m.createQuadVAO(C); const F = C.getBoundFramebufferObject(); this.drawStretchedTexture(C, H, M, E, D, J); this.requiresFrameUpdates ? this._powerOfTwoStretchInfo = { vao: E, sourceTexture: D, framebuffer: M } : (E.dispose(!0),
                    D.dispose(), M.detachColorTexture(), M.dispose()); C.bindFramebuffer(F); return J
                }; B.drawStretchedTexture = function (C, D, E, H, J, M) { C.bindFramebuffer(E); E = C.getViewport(); C.setViewport(0, 0, M.descriptor.width, M.descriptor.height); M = D.program; C.useProgram(M); M.setUniform4f("color", 1, 1, 1, 1); M.bindTexture(J, "tex"); C.bindVAO(H); D.bindPipelineState(C); C.drawArrays(5, 0, k.vertexCount(H, "geometry")); C.bindFramebuffer(null); C.setViewport(E.x, E.y, E.width, E.height) }; B.unload = function () {
                  if (n.isSome(this._powerOfTwoStretchInfo)) {
                    const { framebuffer: C,
                      vao: D, sourceTexture: E } = this._powerOfTwoStretchInfo; D.dispose(!0); E.dispose(); C.dispose(); this._powerOfTwoStretchInfo = this._glTexture = null
                  } n.isSome(this._glTexture) && (this._glTexture.dispose(), this._glTexture = null); if (n.isSome(this._loadingController)) { const C = this._loadingController; this._loadingPromise = this._loadingController = null; C.abort() } this.events.emit("unloaded")
                }; w._createClass(z, [{ key: "width", get: function () { return this.params.width } }, { key: "height", get: function () { return this.params.height } },
                { key: "glTexture", get: function () { return this._glTexture } }, { key: "requiresFrameUpdates", get: function () { return this.data instanceof HTMLVideoElement } }]); return z
          }(t.ContentObject); t.DDS_ENCODING = "image/vnd-ms.dds"; t.KTX2_ENCODING = "image/ktx2"; t.BASIS_ENCODING = "image/x.basis"; a.Texture = t; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/BasisUtil": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../libs/basisu/BasisU ../../../webgl/Texture ../../../webgl/Util".split(" "),
        function (a, w, c, q, u, y) {
          function n() { return p.apply(this, arguments) } function p() { p = w._asyncToGenerator(function* () { c.isNone(m) && (m = q.getBasisTranscoder(), v = yield m); return m }); return p.apply(this, arguments) } function l(e, g, x, k, r) { g = y.getBytesPerElementFormat(g ? 37496 : 37492); return Math.ceil(x * k * g * (r && 1 < e ? (4 ** e - 1) / (3 * 4 ** (e - 1)) : 1)) } function h(e) { return 1 <= e.getNumImages() && !e.isUASTC() } function b(e) { return 1 <= e.getFaces() && e.isETC1S() } function d() {
            d = w._asyncToGenerator(function* (e, g, x) {
              c.isNone(v) && (v =
                yield n()); const k = new v.BasisFile(new Uint8Array(x)); if (!h(k)) return null; k.startTranscoding(); e = t(e, g, k.getNumLevels(0), k.getHasAlpha(), k.getImageWidth(0, 0), k.getImageHeight(0, 0), (r, A) => k.getImageTranscodedSizeInBytes(0, r, A), (r, A, z) => k.transcodeImage(z, 0, r, A, 0, 0)); k.close(); k.delete(); return e
            }); return d.apply(this, arguments)
          } function f() {
            f = w._asyncToGenerator(function* (e, g, x) {
              c.isNone(v) && (v = yield n()); const k = new v.KTX2File(new Uint8Array(x)); if (!b(k)) return null; k.startTranscoding(); e = t(e, g,
                k.getLevels(), k.getHasAlpha(), k.getWidth(), k.getHeight(), (r, A) => k.getImageTranscodedSizeInBytes(r, 0, 0, A), (r, A, z) => k.transcodeImage(z, r, 0, 0, A, 0, -1, -1)); k.close(); k.delete(); return e
            }); return f.apply(this, arguments)
          } function t(e, g, x, k, r, A, z, B) {
            const { compressedTextureETC: C, compressedTextureS3TC: D } = e.capabilities, [E, H] = C ? k ? [1, 37496] : [0, 37492] : D ? k ? [3, 33779] : [2, 33776] : [13, 6408]; k = g.hasMipmap ? x : Math.min(1, x); x = []; for (let J = 0; J < k; J++)x.push(new Uint8Array(z(J, E))), B(J, E, x[J]); z = 1 < x.length; return new u(e,
              { ...g, samplingMode: z ? 9987 : 9729, hasMipmap: z, internalFormat: H, width: r, height: A }, { type: "compressed", levels: x })
          } let v = null, m = null; a.createTextureBasis = function (e, g, x) { return d.apply(this, arguments) }; a.createTextureKTX2 = function (e, g, x) { return f.apply(this, arguments) }; a.estimateMemoryBasis = function (e, g) { if (c.isNone(v)) return e.byteLength; e = new v.BasisFile(new Uint8Array(e)); g = h(e) ? l(e.getNumLevels(0), e.getHasAlpha(), e.getImageWidth(0, 0), e.getImageHeight(0, 0), g) : 0; e.close(); e.delete(); return g }; a.estimateMemoryKTX2 =
            function (e, g) { if (c.isNone(v)) return e.byteLength; e = new v.KTX2File(new Uint8Array(e)); g = b(e) ? l(e.getLevels(), e.getHasAlpha(), e.getWidth(), e.getHeight(), g) : 0; e.close(); e.delete(); return g }; a.loadBasis = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/libs/basisu/BasisU": function () {
      define(["require", "exports", "../../assets", "../../core/maybe"], function (a, w, c, q) {
        let u; w.getBasisTranscoder = function () {
          if (q.isNone(u)) {
            const y = n => c.getAssetUrl(`esri/libs/basisu/${n}`); u = (new Promise((n, p) => a(["../../chunks/basis_transcoder"],
              n, p))).then(n => n.basis_transcoder).then(({ default: n }) => n({ locateFile: y }).then(p => { p.initializeBasis(); delete p.then; return p }))
          } return u
        }; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/DDSUtil": function () {
      define(["exports", "../../../../core/Logger", "../../../../core/mathUtils", "../../../webgl/Texture"], function (a, w, c, q) {
        function u(b) { return b.charCodeAt(0) + (b.charCodeAt(1) << 8) + (b.charCodeAt(2) << 16) + (b.charCodeAt(3) << 24) } function y(b, d) {
          var f = new Int32Array(b, 0,
            31); if (542327876 !== f[0]) return n.error("Invalid magic number in DDS header"), null; if (!(f[20] & 4)) return n.error("Unsupported format, must contain a FourCC code"), null; var t = f[21]; let v; switch (t) { case p: t = 8; v = 33776; break; case l: t = 16; v = 33778; break; case h: t = 16; v = 33779; break; default: return n.error("Unsupported FourCC code:", String.fromCharCode(t & 255, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255)), null }let m = 1, e = f[4], g = f[3]; if (0 !== (e & 3) || 0 !== (g & 3)) n.warn("Rounding up compressed texture size to nearest multiple of 4."),
              e = e + 3 & -4, g = g + 3 & -4; const x = e, k = g; f[2] & 131072 && !1 !== d && (m = Math.max(1, f[7])); 1 === m || c.isPowerOfTwo(e) && c.isPowerOfTwo(g) || (n.warn("Ignoring mipmaps of non power of two sized compressed texture."), m = 1); let r = f[1] + 4; const A = []; for (let z = 0; z < m; ++z)f = (e + 3 >> 2) * (g + 3 >> 2) * t, d = new Uint8Array(b, r, f), A.push(d), r += f, e = Math.max(1, e >> 1), g = Math.max(1, g >> 1); return { textureData: { type: "compressed", levels: A }, internalFormat: v, width: x, height: k }
        } const n = w.getLogger("esri.views.3d.webgl-engine.lib.DDSUtil"), p = u("DXT1"), l = u("DXT3"),
          h = u("DXT5"); a.createDDSTexture = function (b, d, f) { const { textureData: t, internalFormat: v, width: m, height: e } = y(f, d.hasMipmap); d.samplingMode = 1 < t.levels.length ? 9987 : 9729; d.hasMipmap = 1 < t.levels.length; d.internalFormat = v; d.width = m; d.height = e; return new q(b, d, t) }; a.createDDSTextureData = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DLineSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../geometry ../../../../core/Error ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/mat4f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/support/aaBoundingBox ../../../../renderers/support/renderingInfoUtils ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DDrapedGraphicLayer ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./lineUtils ../support/FastSymbolUpdates ../../webgl-engine/lib/Object3D ../../webgl-engine/lib/RenderGeometry ../../webgl-engine/materials/lineStippleUtils ../../webgl-engine/materials/RibbonLineMaterial ../../../../geometry/Extent ../../../../geometry/Polygon".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          const D = ["polyline", "polygon", "extent"]; c = function (E) {
            function H(M, F, K, P) { M = E.call(this, M, F, K, P) || this; M._uniformSize = 1; return M } w._inheritsLoose(H, E); var J = H.prototype; J.doLoad = function () {
              var M = w._asyncToGenerator(function* () {
              this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [1, 1, 1], unitInMeters: 1, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: !0, color: !0, opacity: !0, rotation: !1 } }; this._fastUpdates =
                this._context.renderer && this._context.renderer.visualVariables && 0 < this._context.renderer.visualVariables.length ? x.initFastSymbolUpdatesState(this._context.renderer, this._vvConvertOptions) : { enabled: !1 }; if (!this._drivenProperties.size) { const F = null != this.symbolLayer.size ? this.symbolLayer.size : y.px2pt(1); if (0 > F) throw new q("graphics3dlinesymbollayer:invalid-size", "Symbol sizes may not be negative values"); this._uniformSize = F }
              }); return function () { return M.apply(this, arguments) }
            }(); J.getMaterialParameters =
              function (M) {
                var F = u.get(this.symbolLayer, "material", "color"); F = this._getCombinedOpacityAndColor(F); this._patternHidesLine && (F[3] = 0); const K = F[3]; M = { width: 1, color: F, polygonOffset: !0, join: this.symbolLayer.join || "miter", cap: g.parseCapType(this.symbolLayer.cap || "butt"), transparent: 1 > K || this.needsDrivenTransparentPass, slicePlaneEnabled: this._context.slicePlaneEnabled, isClosed: M, stipplePattern: A.getStipplePatternForLinePattern(this.symbolLayer.pattern), stippleScaleWithLineWidth: !0 }; this._drivenProperties.size ?
                  this._fastUpdates.enabled && this._fastUpdates.visualVariables.size && (M.width = y.pt2px(1)) : (F = null != this.symbolLayer.size ? this.symbolLayer.size : y.px2pt(1), M.width = y.pt2px(F)); return this._fastUpdates && this._fastUpdates.visualVariables ? { ...M, ...this._fastUpdates.materialParameters } : M
              }; J.destroy = function () { E.prototype.destroy.call(this); this._context.stage.remove(this._lineMaterial); this._lineMaterial = null; this._context.stage.remove(this._ringMaterial); this._ringMaterial = null }; J.getDrivenSize = function (M) {
                return this._drivenProperties.size &&
                  M.size ? y.pt2px(b.getDriverAxisSizeValueAny(M.size)) : 1
              }; J.getSizeFeatureAttributeData = function (M) { return this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? e.getAttributeValue(this._fastUpdates.visualVariables.size.field, M) : null }; J.getDrivenColor = function (M) { const F = l.fromValues(1, 1, 1, 1); this._drivenProperties.color && M.color && (F[0] = M.color[0], F[1] = M.color[1], F[2] = M.color[2], 0 < M.color.length && (F[3] = M.color[3])); this._drivenProperties.opacity && M.opacity && (F[3] = M.opacity); return F }; J.getColorFeatureAttributeData =
                function (M) { return this._fastUpdates.enabled && this._fastUpdates.visualVariables.color ? e.getAttributeValue(this._fastUpdates.visualVariables.color.field, M) : null }; J.getOpacityFeatureAttributeData = function (M) { return this._fastUpdates.enabled && this._fastUpdates.visualVariables.opacity ? e.getAttributeValue(this._fastUpdates.visualVariables.opacity.field, M) : null }; J.createGraphics3DGraphic = function (M) {
                  const F = M.graphic; if (!this._validateGeometry(F.geometry, D, this.symbolLayer.type)) return null; const K = this.setGraphicElevationContext(F,
                    new t.ElevationContext); this.ensureDrapedStatus("on-the-ground" === K.mode); return this.draped ? this._createAsOverlay(M, this._context.layer.uid) : this._createAs3DShape(M, K, F.uid)
                }; J.applyRendererDiff = function (M, F) {
                  for (const K in M.diff) switch (K) {
                    case "visualVariables": if (x.updateFastSymbolUpdatesState(this._fastUpdates, F, this._vvConvertOptions)) u.isSome(this._lineMaterial) && this._lineMaterial.setParameters(this._fastUpdates.materialParameters), u.isSome(this._ringMaterial) && this._ringMaterial.setParameters(this._fastUpdates.materialParameters);
                    else return 0; break; default: return 0
                  }return 2
                }; J.layerOpacityChanged = function () { u.isSome(this._lineMaterial) && this.updateMaterialLayerOpacity(this._lineMaterial); u.isSome(this._ringMaterial) && this.updateMaterialLayerOpacity(this._ringMaterial); return !0 }; J.updateMaterialLayerOpacity = function (M) { const F = M.parameters.color; var K = u.get(this.symbolLayer, "material", "color"); K = this._patternHidesLine ? 0 : this._getCombinedOpacity(K); M.setParameters({ color: [F[0], F[1], F[2], K], transparent: 1 > K || this.needsDrivenTransparentPass }) };
            J.layerElevationInfoChanged = function (M, F, K) { const P = this._elevationContext.mode; K = f.elevationModeChangeUpdateType(H.elevationModeChangeTypes, K, P); if (K !== f.SymbolUpdateType.UPDATE) return K; const L = f.needsElevationUpdates2D(P); return this.updateGraphics3DGraphicElevationInfo(M, F, () => L) }; J.slicePlaneEnabledChanged = function () {
              u.isSome(this._lineMaterial) && this._lineMaterial.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); u.isSome(this._ringMaterial) && this._ringMaterial.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled });
              return !0
            }; J.physicalBasedRenderingChanged = function () { return !0 }; J.pixelRatioChanged = function () { return !0 }; J._getGeometryAsPolygonOrPolyline = function (M) { switch (M.type) { case "extent": if (M instanceof B) return C.fromExtent(M); break; case "polygon": case "polyline": return M }return null }; J._createAs3DShape = function (M, F, K) {
              const P = this._getGeometryAsPolygonOrPolyline(M.graphic.geometry); var L = "polygon" === P.type ? P.rings : P.paths, N = []; const G = [], I = [], O = h.create(), R = g.geometryToRenderInfo(P, this._context.elevationProvider,
                this._context.renderCoordsHelper, F); this._logGeometryCreationWarnings(R, L, "polygon" === P.type ? "rings" : "paths", "LineSymbol3DLayer"); for (L = 0; L < R.lines.length; L++) { const { position: S, mapPosition: Q } = R.lines[L]; if (u.isSome(this._context.clippingExtent) && (h.empty(O), h.expandWithBuffer(O, Q), !h.intersectsClippingArea(O, this._context.clippingExtent))) continue; const T = this._createGeometry(M, S, Q, P.type, 1); N.push(T); G.push("polygon" === P.type ? this.ringMaterial : this.lineMaterial); I.push(n.IDENTITY) } if (0 === N.length) return null;
              M = new k.Object3D({ geometries: N, materials: G, transformations: I, castShadow: !1, metadata: { layerUid: this._context.layer.uid, graphicUid: K } }); N = new m.Graphics3DObject3DGraphicLayer(this, M, N, null, null, d.perVertexElevationAligner, F); N.alignedSampledElevation = R.sampledElevation; N.needsElevationUpdates = f.needsElevationUpdates2D(F.mode); return N
            }; J._createGeometry = function (M, F, K, P, L) {
              const N = this._fastUpdates.enabled && this._fastUpdates.visualVariables.color; return g.createGeometry({
                overlayInfo: 0 === L ? {
                  spatialReference: this._context.overlaySR,
                  renderCoordsHelper: this._context.renderCoordsHelper
                } : null, removeDuplicateStartEnd: "polygon" === P ? 1 : 0, uniformSize: this._uniformSize, attributeData: { position: F, mapPosition: K, size: this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? null : this.getDrivenSize(M.renderingInfo), color: N ? null : this.getDrivenColor(M.renderingInfo), sizeFeature: this.getSizeFeatureAttributeData(M.graphic), colorFeature: this.getColorFeatureAttributeData(M.graphic), opacityFeature: this.getOpacityFeatureAttributeData(M.graphic) }
              })
            };
            J._createAsOverlay = function (M, F) {
              const K = M.graphic, P = this._getGeometryAsPolygonOrPolyline(K.geometry); var L = "polygon" === P.type ? P.rings : P.paths; const N = "polygon" === P.type ? this.ringMaterial : this.lineMaterial; N.renderPriority = this._renderPriority; const G = [], I = h.create(), O = h.empty(), R = g.geometryToRenderInfoDraped(P, this._context.overlaySR); this._logGeometryCreationWarnings(R, L, "polygon" === P.type ? "rings" : "paths", "LineSymbol3DLayer"); for (const S of R.lines) h.empty(I), h.expandWithBuffer(I, S.position), h.intersectsClippingArea(I,
                this._context.clippingExtent) && (h.expandWithAABB(O, I), L = this._createGeometry(M, S.position, null, P.type, 0), L = new r.RenderGeometry(L, N, F, K.uid), p.set(L.boundingSphere, .5 * (I[0] + I[3]), .5 * (I[1] + I[4]), 0, .5 * Math.sqrt((I[3] - I[0]) * (I[3] - I[0]) + (I[4] - I[1]) * (I[4] - I[1]))), G.push(L)); return new v(this, G, O)
            }; w._createClass(H, [{ key: "lineMaterial", get: function () { u.isNone(this._lineMaterial) && (this._lineMaterial = new z.RibbonLineMaterial(this.getMaterialParameters(!1)), this._context.stage.add(this._lineMaterial)); return this._lineMaterial } },
            { key: "ringMaterial", get: function () { u.isNone(this._ringMaterial) && (this._ringMaterial = new z.RibbonLineMaterial(this.getMaterialParameters(!0)), this._context.stage.add(this._ringMaterial)); return this._ringMaterial } }, { key: "_patternHidesLine", get: function () { const M = this.symbolLayer.pattern; return u.isSome(M) && "style" === M.type && "none" === M.style } }]); return H
          }(e.Graphics3DSymbolLayer); c.elevationModeChangeTypes = { definedChanged: f.SymbolUpdateType.RECREATE, staysOnTheGround: f.SymbolUpdateType.NONE, onTheGroundChanged: f.SymbolUpdateType.RECREATE };
          a.Graphics3DLineSymbolLayer = c; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/lineUtils": function () {
      define("exports ../../../../core/has ../../../../core/mathUtils ../../../../core/maybe ../../../../core/typedArrayUtil ../../../../chunks/vec2 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/projectionEllipsoid ../../../../geometry/support/triangulationUtils ./constants ./elevationAlignmentUtils ../../terrain/OverlayRenderer ../../webgl-engine/lib/Geometry".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(k, r, A) { const z = []; for (const { index: B, count: C } of k) { if (1 >= C) continue; k = 3 * B; const D = k + 3 * C; z.push({ position: r.subarray(k, D), mapPosition: A ? A.subarray(k, D) : void 0 }) } return z } const e = p.create(), g = p.create(), x = 4 / Math.PI; a.createGeometry = function (k) {
            const r = [], A = []; {
              const { attributeData: { position: M }, removeDuplicateStartEnd: F } = k; var z = M.length; z = (z = M[0] === M[z - 3] && M[1] === M[z - 2] && M[2] === M[z - 1]) && 1 === F; var B = M.length / 3 - (z ? 1 : 0), C = new Uint32Array(2 * (B - 1)), D = z ?
                u.slice(M, 0, M.length - 3) : M, E = 0; for (var H = 0; H < B - 1; H++)C[E++] = H, C[E++] = H + 1; A.push(["position", { size: 3, data: D, exclusive: z }]); r.push(["position", C])
            } z = A[0][1].data; B = new Uint16Array(r[0][1].length); C = k.attributeData.mapPosition; q.isNone(C) || (r.push(["mapPos", r[0][1]]), A.push(["mapPos", { size: 3, data: C }])); q.isSome(k.attributeData.colorFeature) || (A.push(["color", { size: 4, data: q.unwrapOr(k.attributeData.color, d.WHITE_UNIT) }]), r.push(["color", B])); q.isSome(k.attributeData.sizeFeature) || (A.push(["size", {
              size: 1,
              data: [q.unwrapOr(k.attributeData.size, 1)]
            }]), r.push(["size", B])); C = k.attributeData.colorFeature; q.isNone(C) || (A.push(["colorFeatureAttribute", { size: 1, data: new Float32Array([C]) }]), r.push(["color", B])); C = k.attributeData.sizeFeature; q.isNone(C) || (A.push(["sizeFeatureAttribute", { size: 1, data: new Float32Array([C]) }]), r.push(["sizeFeatureAttribute", B])); C = k.attributeData.opacityFeature; q.isNone(C) || (A.push(["opacityFeatureAttribute", { size: 1, data: new Float32Array([C]) }]), r.push(["opacityFeatureAttribute",
              B])); if ("round" === k.join) { B = z.length / 3; C = new Float32Array(B); n.set(e, 0, 0, 0); D = q.unwrapOr(k.uniformSize, 1); for (E = -1; E < B; ++E) { H = 0 > E ? B + E : E; var J = (E + 1) % B; n.set(g, z[3 * J] - z[3 * H], z[3 * J + 1] - z[3 * H + 1], z[3 * J + 2] - z[3 * H + 2]); n.normalize(g, g); 0 <= E && (H = (Math.PI - c.acosClamped(n.dot(e, g))) * x * (1.863798 + -2.0062872 / (1 + D / 18.2313) ** .8856294), C[E] = Math.max(Math.floor(H), 0)); n.scale(e, g, -1) } A.push(["subdivisions", { size: 1, data: C }]); r.push(["subdivisions", r[0][1]]) } if (!q.isNone(k.overlayInfo) && 1 === k.overlayInfo.renderCoordsHelper.viewingMode &&
                k.overlayInfo.spatialReference.isGeographic) { B = new Float64Array(z.length); k = h.getReferenceEllipsoid(k.overlayInfo.spatialReference); for (C = 0; C < B.length; C += 3)l.lonLatToWebMercatorComparable(z, C, B, C, k); k = z.length / 3; z = new Float32Array(k + 1); C = e; D = g; H = E = 0; n.set(C, B[H++], B[H++], B[H++]); z[0] = 0; for (J = 1; J < k + 1; ++J)J === k && (H = 0), n.set(D, B[H++], B[H++], B[H++]), E += y.dist(C, D), z[J] = E, [C, D] = [D, C]; A.push(["distanceToStart", { size: 1, data: z }]); r.push(["distanceToStart", r[0][1]]) } return new v.Geometry(A, r, 2)
          }; a.geometryToRenderInfo =
            function (k, r, A, z) { const { position: B, outlines: C } = b.pathsToTriangulationInfo("polygon" === k.type ? k.rings : k.paths, k.hasZ, "polygon" === k.type ? 1 : 0), D = new Float64Array(B.length); k = f.applyPerVertexElevationAlignment(B, k.spatialReference, 0, D, 0, B, 0, B.length / 3, r, A, z); r = null != k; return { lines: r ? m(C, B, D) : [], projectionSuccess: r, sampledElevation: k } }; a.geometryToRenderInfoDraped = function (k, r) {
              const { position: A, outlines: z } = b.pathsToTriangulationInfo("polygon" === k.type ? k.rings : k.paths, !1, "polygon" === k.type ? 1 : 0); k = l.projectBuffer(A,
                k.spatialReference, 0, A, r, 0, A.length / 3); for (r = 2; r < A.length; r += 3)A[r] = t.DRAPED_Z; return { lines: k ? m(z, A) : [], projectionSuccess: k }
            }; a.parseCapType = function (k) { switch (k) { case "butt": return 0; case "square": return 1; case "round": return 2; default: return null } }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/lineStippleUtils": function () {
      define(["exports", "../../../../core/maybe"], function (a, w) {
        function c(y, n = 2) { return w.isNone(y) ? y : { pattern: y.slice(), pixelRatio: n } } const q =
          { dash: [4, 3], dot: [1, 3], "long-dash": [8, 3], "short-dash": [4, 1], "short-dot": [1, 1] }, u = { dash: q.dash, "dash-dot": [...q.dash, ...q.dot], dot: q.dot, "long-dash": q["long-dash"], "long-dash-dot": [...q["long-dash"], ...q.dot], "long-dash-dot-dot": [...q["long-dash"], ...q.dot, ...q.dot], none: null, "short-dash": q["short-dash"], "short-dash-dot": [...q["short-dash"], ...q["short-dot"]], "short-dash-dot-dot": [...q["short-dash"], ...q["short-dot"], ...q["short-dot"]], "short-dot": q["short-dot"], solid: null }; a.createStipplePattern = c;
        a.createStipplePatternSimple = function (y, n = 2) { return { pattern: [y, y], pixelRatio: n } }; a.getStipplePatternForLinePattern = function (y) { return w.isSome(y) && "style" === y.type ? c(u[y.style], 8) : null }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DMeshFillSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/has ../../../../core/maybe ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/MeshComponent ../../../../geometry/support/MeshMaterialMetallicRoughness ../../../../geometry/support/buffer/BufferView ../../../../chunks/vec32 ../../../../geometry/support/meshUtils/projection ../../../../layers/graphics/dehydratedFeatures ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ../support/edgeUtils ../support/symbolColorUtils ../../support/debugFlags ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/geometryDataUtils ../../webgl-engine/lib/Object3D ../../webgl-engine/lib/Texture ../../webgl-engine/materials/DefaultMaterial ../../webgl-engine/materials/NativeLineMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L) {
          const N = ["mesh"]; q = function (fa) {
            function ha(ea, ba, aa, W) { ea = fa.call(this, ea, ba, aa, W) || this; ea._materials = new Map; ea._textures = new Map; ea.ensureDrapedStatus(!1); return ea } w._inheritsLoose(ha, fa); var ka = ha.prototype; ka.doLoad = function () {
              var ea = w._asyncToGenerator(function* () {
              H.DRAW_MESH_GEOMETRY_NORMALS && (this._debugVertexNormalMaterial = new L.NativeLineMaterial({ color: [1, 0, 1, 1] }), this._debugFaceNormalMaterial = new L.NativeLineMaterial({
                color: [0,
                  1, 1, 1]
              }))
              }); return function () { return ea.apply(this, arguments) }
            }(); ka.destroy = function () { fa.prototype.destroy.call(this); this._context.stage.removeMany(Array.from(this._materials.values(), ea => ea.material)); this._context.stage.removeMany(Array.from(this._textures.values())); this._materials.clear(); this._textures.clear() }; ka.createGraphics3DGraphic = function (ea) {
              const ba = ea.graphic; if (!this._validateGeometry(ba.geometry, N, "fill on mesh-3d")) return null; const aa = this.setGraphicElevationContext(ba, new z.ElevationContext);
              return this._createAs3DShape(ba, ea.renderingInfo, aa, ba.uid)
            }; ka.layerOpacityChanged = function (ea, ba) { const aa = this._getLayerOpacity(); this._materials.forEach(W => { W.material.setParameters({ layerOpacity: aa }); const U = W.material.parameters; this._setMaterialTransparentParameter(U, W); W.material.setParameters({ transparent: U.transparent }) }); ea.forEach(W => { W = ba(W); u.isSome(W) && W.layerOpacityChanged(aa, this._context.isAsync) }); return !0 }; ka.layerElevationInfoChanged = function (ea, ba) {
              return this.updateGraphics3DGraphicElevationInfo(ea,
                ba, A.needsElevationUpdates3D)
            }; ka.slicePlaneEnabledChanged = function (ea, ba) { this._materials.forEach(aa => { aa.material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }) }); ea.forEach(aa => { aa = ba(aa); u.isSome(aa) && aa.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync) }); return !0 }; ka.physicalBasedRenderingChanged = function () { const ea = this._usePBR(); this._materials.forEach(ba => ba.material.setParameters({ usePBR: ea })); return !0 }; ka.pixelRatioChanged = function () { return !0 };
            ka._requiresSymbolVertexColors = function () { return this._drivenProperties.color || this._drivenProperties.opacity }; ka._colorOrTextureUid = function (ea) { return u.isNone(ea) ? "-" : ea instanceof c ? ea.toHex() : ea.contentHash }; ka._materialPropertiesDefault = function (ea, ba) { const aa = this._requiresSymbolVertexColors(), W = !!ea.vertexAttributes.color; ea = !!ea.vertexAttributes.tangent; return { hasSymbolVertexColors: aa, hasVertexColors: W, hasVertexTangents: ea, uid: `vc:${W},vt:${ea},vct${ba},svc:${aa}` } }; ka._materialProperties =
              function (ea, ba, aa) {
                ea = this._materialPropertiesDefault(ea, aa); if (!ba.material) return ea; const { color: W, colorTexture: U, normalTexture: X, doubleSided: Z, alphaCutoff: ia, alphaMode: la } = ba.material; aa = this._colorOrTextureUid(W); var ma = this._colorOrTextureUid(U), ra = this._colorOrTextureUid(X); ea.color = W; ea.colorTexture = U; ea.normalTexture = X; ea.uid = `${ea.uid},cmuid:${aa},ctmuid:${ma},ntmuid:${ra},ds:${Z},ac:${ia},am:${la}`; if (ba.material instanceof m) {
                  const { metallic: Aa, roughness: za, metallicRoughnessTexture: Ka,
                    emissiveColor: Ea, emissiveTexture: Ua, occlusionTexture: Na } = ba.material; ba = this._colorOrTextureUid(Ka); aa = this._colorOrTextureUid(Ea); ma = this._colorOrTextureUid(Ua); ra = this._colorOrTextureUid(Na); ea.metallic = Aa; ea.roughness = za; ea.metallicRoughnessTexture = Ka; ea.emissiveColor = Ea; ea.emissiveTexture = Ua; ea.occlusionTexture = Na; ea.uid = `${ea.uid},mrm:${Aa},mrr:${za},mrt:${ba},emuid:${aa},etmuid:${ma},otmuid:${ra}`
                } return ea
              }; ka._setInternalColorValueParameters = function (ea, ba) {
              ba.diffuse = c.toUnitRGB(ea); ba.opacity =
                ea.a
              }; ka._getLoadableTextureResource = function (ea) { return ea.data ? ea.data : ea.url }; ka._getInternalTextureId = function (ea) { ea = this._getInternalTexture(ea, 1); return u.isSome(ea) ? ea.id : null }; ka._getInternalTexture = function (ea, ba) {
                const aa = this._getLoadableTextureResource(ea); if (!aa) return null; const W = `${ea.contentHash}/${ba}`; let U = this._textures.get(W); U || (U = new K.Texture(aa, { mipmap: !0, wrap: this._castTextureWrap(ea.wrap), noUnpackFlip: !0, preMultiplyAlpha: 1 !== ba }), this._textures.set(W, U), this._context.stage.add(U),
                  this._context.stage.loadSynchronous(U)); return U
              }; ka._castTextureWrap = function (ea = "repeat") { return "string" === typeof ea ? (ea = this._castTextureWrapIndividual(ea), { s: ea, t: ea }) : { s: this._castTextureWrapIndividual(ea.horizontal), t: this._castTextureWrapIndividual(ea.vertical) } }; ka._castTextureWrapIndividual = function (ea) { switch (ea) { case "clamp": return 33071; case "mirror": return 33648; default: return 10497 } }; ka._setInternalMaterialParameters = function (ea, ba) {
                u.isSome(ea.color) && this._setInternalColorValueParameters(ea.color,
                  ba); if (u.isSome(ea.colorTexture)) { const aa = this._getInternalTexture(ea.colorTexture, ba.textureAlphaMode); u.isSome(aa) ? (ba.textureId = aa.id, ba.textureAlphaPremultiplied = !!aa.params.preMultiplyAlpha) : ba.textureId = void 0 } u.isSome(ea.normalTexture) && (ba.normalTextureId = this._getInternalTextureId(ea.normalTexture)); u.isSome(ea.emissiveColor) && (ba.emissiveFactor = c.toUnitRGB(ea.emissiveColor)); u.isSome(ea.emissiveTexture) && (ba.emissiveTextureId = this._getInternalTextureId(ea.emissiveTexture)); u.isSome(ea.occlusionTexture) &&
                    (ba.occlusionTextureId = this._getInternalTextureId(ea.occlusionTexture)); u.isSome(ea.metallicRoughnessTexture) && (ba.metallicRoughnessTextureId = this._getInternalTextureId(ea.metallicRoughnessTexture))
              }; ka._setExternalMaterialParameters = function (ea) {
                var ba = this._drivenProperties.color; let aa = u.isSome(this.symbolLayer.material) ? this.symbolLayer.material.colorMixMode : null; ba ? ea.externalColor = d.ONES : (ba = u.isSome(this.symbolLayer.material) ? this.symbolLayer.material.color : null, u.isSome(ba) ? ea.externalColor =
                  c.toUnitRGBA(ba) : (aa = null, ea.externalColor = d.ONES)); aa && (ea.colorMixMode = aa); ea.castShadows = !!this.symbolLayer.castShadows
              }; ka._hasTransparentVertexColors = function (ea) { ea = ea.vertexAttributes.color; if (u.isNone(ea)) return !1; for (let ba = 3; ba < ea.length; ba += 4)if (255 !== ea[ba]) return !0; return !1 }; ka._getOrCreateMaterial = function (ea, ba) {
                var aa, W, U, X = null == (aa = ba.material) ? void 0 : aa.color; aa = null == (W = ba.material) ? void 0 : W.colorTexture; W = null == (U = ba.material) ? void 0 : U.alphaMode; U = "blend" === W; X = "opaque" !== W &&
                  (this._hasTransparentVertexColors(ea) || u.isSome(X) && 1 > X.a || u.isSome(aa) && aa.transparent || U); ea = this._materialProperties(ea, ba, X); if (U = this._materials.get(ea.uid)) return U.material; X = { material: null, isComponentTransparent: X, alphaMode: ba.material ? ba.material.alphaMode : "opaque" }; U = null == ea.metallicRoughnessTexture && null == ea.metallic && null == ea.roughness; aa = {
                    usePBR: this._usePBR(), isSchematic: U, vertexColors: ea.hasVertexColors, symbolColors: ea.hasSymbolVertexColors, vertexTangents: ea.hasVertexTangents, ambient: b.ZEROS,
                    diffuse: b.ONES, opacity: 1, doubleSided: !0, doubleSidedType: "winding-order", cullFace: 0, layerOpacity: this._getLayerOpacity(), slicePlaneEnabled: this._context.slicePlaneEnabled, initTextureTransparent: !0
                  }; U || (aa.mrrFactors = [null != ea.metallic ? ea.metallic : 1, null != ea.roughness ? ea.roughness : 1, .5]); ba.material && (aa.doubleSided = ba.material.doubleSided, aa.cullFace = ba.material.doubleSided ? 0 : 2, aa.textureAlphaCutoff = ba.material.alphaCutoff); this._setExternalMaterialParameters(aa); this._setMaterialTransparentParameter(aa,
                    X); this._setInternalMaterialParameters(ea, aa); ba = new P.DefaultMaterial(aa); X.material = ba; this._materials.set(ea.uid, X); this._context.stage.add(ba); return ba
              }; ka._usePBR = function () { return this._context.physicalBasedRenderingEnabled }; ka._setMaterialTransparentParameter = function (ea, ba) {
              ea.transparent = this.needsDrivenTransparentPass || ba.isComponentTransparent || 1 > ea.layerOpacity || 1 > ea.opacity || ea.externalColor && 1 > ea.externalColor[3]; ea.textureAlphaMode = "auto" === ba.alphaMode ? ea.transparent ? 3 : 1 : "opaque" ===
                ba.alphaMode ? 1 : "mask" === ba.alphaMode ? 2 : 0
              }; ka._addDebugNormals = function (ea, ba, aa, W) {
                var U = ba.length, X = ea.spatialReference.isGeographic ? 20015077 / 180 : 1; const Z = .1 * Math.max(ea.extent.width * X, ea.extent.height * X, ea.extent.zmax - ea.extent.zmin), ia = [], la = []; ea = []; X = []; for (let Ea = 0; Ea < U; Ea++) {
                  var ma = ba[Ea], ra = ma.vertexAttributes.get("position"), Aa = ma.vertexAttributes.get("normal"); const Ua = ma.indices.get("position"); ma = ma.indices.get("normal"); ra = ra.data; Aa = Aa.data; for (let Na = 0; Na < Ua.length; Na++) {
                    var za = 3 *
                      Ua[Na]; const ya = 3 * ma[Na]; for (var Ka = 0; 3 > Ka; Ka++)ia.push(ra[za + Ka]); for (Ka = 0; 3 > Ka; Ka++)ia.push(ra[za + Ka] + Aa[ya + Ka] * Z); la.push(la.length); la.push(la.length); if (0 === Na % 3) { this._calculateFaceNormal(ra, Ua, Na, S); this._getFaceVertices(ra, Ua, Na, I, O, R); h.add(I, I, O); h.add(I, I, R); h.scale(I, I, 1 / 3); for (za = 0; 3 > za; za++)ea.push(I[za]); for (za = 0; 3 > za; za++)ea.push(I[za] + S[za] * Z); X.push(X.length); X.push(X.length) }
                  }
                } U = new J.Geometry([["position", { data: ia, size: 3, exclusive: !0 }]], [["position", new Uint32Array(la)]], 2); ba.push(U);
                aa.push(this._debugVertexNormalMaterial); W.push(l.clone(W[0])); U = new J.Geometry([["position", { data: ea, size: 3, exclusive: !0 }]], [["position", new Uint32Array(X)]], 2); ba.push(U); aa.push(this._debugFaceNormalMaterial); W.push(l.clone(W[0]))
              }; ka._createAs3DShape = function (ea, ba, aa, W) {
                ea = ea.geometry; if ("mesh" !== ea.type) return null; ba = this._createGeometryInfo(ea, ba); if (!ba) return null; const { geometries: U, materials: X, transformations: Z, objectTransformation: ia } = ba; H.DRAW_MESH_GEOMETRY_NORMALS && this._addDebugNormals(ea,
                  U, X, Z); W = new F.Object3D({ geometries: U, materials: X, transformations: Z, metadata: { layerUid: this._context.layer.uid, graphicUid: W } }); W.transformation = ia; ba = this._createEdgeMaterial(); ba = u.isSome(ba) ? { baseMaterial: X[0], edgeMaterials: [ba], properties: { mergeGeometries: !0, slicePlaneEnabled: this._context.slicePlaneEnabled } } : null; ba = new B.Graphics3DObject3DGraphicLayer(this, W, U, null, null, r.perObjectElevationAligner, aa, ba); ba.needsElevationUpdates = A.needsElevationUpdates3D(aa.mode); ba.useObjectOriginAsAttachmentOrigin =
                    !0; ba.elevationContext.centerPointInElevationSR = this.getCenterPointInElevationSR(W); ba.alignedSampledElevation = r.perObjectElevationAligner(ba, ba.elevationContext, this._context.elevationProvider, this._context.renderCoordsHelper); return ba
              }; ka.getCenterPointInElevationSR = function (ea) {
                const ba = k.makeDehydratedPoint(0, 0, 0, this._context.elevationProvider.spatialReference); f.projectVectorToDehydratedPoint([ea.transformation[12], ea.transformation[13], ea.transformation[14]], this._context.renderCoordsHelper.spatialReference,
                  ba); return ba
              }; ka._createComponentNormals = function (ea, ba, aa, W) { switch (aa.shading || "flat") { case "source": return this._createComponentNormalsSource(ea, ba, aa, W); case "flat": return this._createComponentNormalsFlat(ea, W); case "smooth": return this._createComponentNormalsSmooth(ea, W) } }; ka._createComponentNormalsSource = function (ea, ba, aa, W) {
                if (u.isNone(ba)) return this._createComponentNormalsFlat(ea, W); let U = !1; if (!aa.trustSourceNormals) for (aa = 0; aa < W.length; aa += 3) {
                  this._calculateFaceNormal(ea, W, aa, S); for (let X =
                    0; 3 > X; X++) { const Z = 3 * W[aa + X]; I[0] = ba[Z + 0]; I[1] = ba[Z + 1]; I[2] = ba[Z + 2]; 0 > h.dot(S, I) && (ba[Z + 0] = -ba[Z + 0], ba[Z + 1] = -ba[Z + 1], ba[Z + 2] = -ba[Z + 2], U = !0) }
                } return { normals: ba, indices: W, didFlipNormals: U }
              }; ka._createComponentNormalsFlat = function (ea, ba) { const aa = new Float32Array(ba.length), W = new Uint32Array(3 * ba.length); for (let U = 0; U < ba.length; U += 3) { const X = this._calculateFaceNormal(ea, ba, U, S); for (let Z = 0; 3 > Z; Z++)aa[U + Z] = X[Z], W[U + Z] = U / 3 } return { normals: aa, indices: W, didFlipNormals: !1 } }; ka._createComponentNormalsSmooth =
                function (ea, ba) { const aa = {}; for (var W = 0; W < ba.length; W += 3) { var U = this._calculateFaceNormal(ea, ba, W, S); for (var X = 0; 3 > X; X++) { var Z = ba[W + X]; let ia = aa[Z]; ia || (ia = { normal: b.create(), count: 0 }, aa[Z] = ia); h.add(ia.normal, ia.normal, U); ia.count++ } } ea = new Float32Array(3 * ba.length); W = new Uint32Array(3 * ba.length); for (U = 0; U < ba.length; U++) { X = aa[ba[U]]; 1 !== X.count && (h.normalize(X.normal, X.normal), X.count = 1); for (Z = 0; 3 > Z; Z++)ea[3 * U + Z] = X.normal[Z]; W[U] = U } return { normals: ea, indices: W, didFlipNormals: !1 } }; ka._getFaceVertices =
                  function (ea, ba, aa, W, U, X) { const Z = 3 * ba[aa + 0], ia = 3 * ba[aa + 1]; ba = 3 * ba[aa + 2]; W[0] = ea[Z + 0]; W[1] = ea[Z + 1]; W[2] = ea[Z + 2]; U[0] = ea[ia + 0]; U[1] = ea[ia + 1]; U[2] = ea[ia + 2]; X[0] = ea[ba + 0]; X[1] = ea[ba + 1]; X[2] = ea[ba + 2] }; ka._calculateFaceNormal = function (ea, ba, aa, W) { this._getFaceVertices(ea, ba, aa, I, O, R); h.subtract(O, O, I); h.subtract(R, R, I); h.cross(I, O, R); h.normalize(W, I); return W }; ka._getOrCreateComponents = function (ea) { return ea.components ? ea.components : Y }; ka._createPositionBuffer = function (ea, ba) {
                    let aa = ea.vertexAttributes.position;
                    const W = 1 === ba.reprojection ? ba.transformBeforeProject : null; u.isSome(W) && (aa = x.transformPosition(aa, new Float64Array(aa.length), W)); if (0 === ba.reprojection) return ba.needsBufferCopy ? new Float64Array(aa) : aa; ba = u.isSome(W) ? aa : new Float64Array(aa.length); f.projectBuffer(aa, ea.spatialReference, 0, ba, this._context.renderCoordsHelper.spatialReference, 0, aa.length / 3); return ba
                  }; ka._createNormalBuffer = function (ea, ba, aa) {
                    let W = ea.vertexAttributes.normal; if (u.isNone(W)) return null; var U = 1 === aa.reprojection ? aa.transformBeforeProject :
                      null; u.isSome(U) && (W = x.transformNormal(W, new Float32Array(W.length), U)); if ("local" === this._context.layerView.view.viewingMode || 0 === aa.reprojection) return aa.needsBufferCopy && ea.vertexAttributes.normal === W ? new Float32Array(W) : W; aa = ea.vertexAttributes.position; U = u.isSome(U) ? W : new Float32Array(W.length); return x.projectNormalToPCPF(W, aa, ba, ea.spatialReference, U)
                  }; ka._createTangentBuffer = function (ea, ba, aa) {
                    let W = ea.vertexAttributes.tangent; if (u.isNone(W)) return null; var U = 1 === aa.reprojection ? aa.transformBeforeProject :
                      null; u.isSome(U) && (W = x.transformTangent(W, new Float32Array(W.length), U)); if ("local" === this._context.layerView.view.viewingMode || 0 === aa.reprojection) return aa.needsBufferCopy && ea.vertexAttributes.normal === W ? new Float32Array(W) : W; aa = ea.vertexAttributes.position; U = u.isSome(U) ? W : new Float32Array(W.length); return x.projectTangentToPCPF(W, aa, ba, ea.spatialReference, U)
                  }; ka._createColorBuffer = function (ea) { return ea.vertexAttributes.color }; ka._createSymbolColorBuffer = function (ea) {
                    if (this._requiresSymbolVertexColors()) {
                      ea =
                      this._getVertexOpacityAndColor(ea); const ba = E.parseColorMixMode(u.get(this.symbolLayer, "material", "colorMixMode")), aa = new Uint8Array(4); E.encodeSymbolColor(ea, ba, aa); return aa
                    } return null
                  }; ka._createBuffers = function (ea, ba) {
                    var aa = ea.vertexAttributes && ea.vertexAttributes.position; if (!aa) return this.logger.warn("Mesh geometry must contain position vertex attributes"), null; var W = ea.vertexAttributes.normal; const U = ea.vertexAttributes.uv; var X = ea.vertexAttributes.tangent; if (u.isSome(W) && W.length !== aa.length) return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),
                      null; if (u.isSome(X) && X.length / 4 !== aa.length / 3) return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"), null; if (u.isSome(U) && U.length / 2 !== aa.length / 3) return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"), null; X = this._computeReprojectionInfo(ea); aa = this._createPositionBuffer(ea, X); W = this._createColorBuffer(ea); ba = this._createSymbolColorBuffer(ba); const Z = this._createNormalBuffer(ea,
                        aa, X), ia = this._createTangentBuffer(ea, aa, X); ea = 0 === X.reprojection && u.isSome(X.objectTransformation) ? X.objectTransformation : this._transformOriginLocal(ea, aa, Z, ia); X = 0 === X.reprojection && u.isSome(X.geometryTransformation) ? X.geometryTransformation : l.create(); return { positionBuffer: aa, normalBuffer: Z, tangentBuffer: ia, uvBuffer: U, colorBuffer: W, symbolColorBuffer: ba, objectTransformation: ea, geometryTransformation: X }
                  }; ka._computeReprojectionInfo = function (ea) {
                    const ba = u.isSome(ea.transform) && ea.transform.geographic ?
                      0 : 2 === this._context.renderCoordsHelper.viewingMode ? 0 : 1; var aa = null; if (u.isSome(ea.transform)) {
                        if (0 === ba) return aa = l.create(), f.computeTranslationToOriginAndRotation(ea.spatialReference, ea.transform.origin, aa, this._context.renderCoordsHelper.spatialReference), ea = l.clone(ea.transform.localMatrix), { reprojection: ba, objectTransformation: aa, geometryTransformation: ea, needsBufferCopy: !1 }; aa = p.fromTranslation(l.create(), ea.transform.origin); p.multiply(aa, aa, ea.transform.localMatrix); return {
                          reprojection: ba,
                          transformBeforeProject: aa, needsBufferCopy: !0
                        }
                      } return { reprojection: ba, needsBufferCopy: !0 }
                  }; ka._transformOriginLocal = function (ea, ba, aa, W) {
                    const U = this._context.renderCoordsHelper.spatialReference; var X = ea.anchor; G[0] = X.x; G[1] = X.y; G[2] = X.z; X = l.create(); f.computeTranslationToOriginAndRotation(ea.spatialReference, G, X, U); ea = e.BufferViewVec3f64.fromTypedArray(ba); p.invert(Q, X); g.transformMat4(ea, ea, Q); if (u.isSome(aa) || u.isSome(W)) y.fromMat4(T, X), y.transpose(T, T), u.isSome(aa) && (aa = e.BufferViewVec3f.fromTypedArray(aa),
                      g.transformMat3(aa, aa, T)), u.isSome(W) && (W = e.BufferViewVec3f.fromTypedArray(W, 4 * W.BYTES_PER_ELEMENT), g.transformMat3(W, W, T)); return X
                  }; ka._validateFaces = function (ea, ba) {
                    ea = ea.vertexAttributes.position.length / 3; if (ba = ba.faces) { let aa = -1; for (let W = 0; W < ba.length; W++) { const U = ba[W]; U > aa && (aa = U) } if (ea <= aa) return this.logger.warn(`Vertex index ${aa} is out of bounds of the mesh position buffer`), !1 } else if (0 !== ea % 3) return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),
                      !1; return !0
                  }; ka._getOrCreateFaces = function (ea, ba) { return ba.faces ? ba.faces : M.generateDefaultIndexArray(ea.vertexAttributes.position.length / 3) }; ka._isOutsideClippingArea = function (ea) {
                    if (!this._context.clippingExtent) return !1; var ba = ea.vertexAttributes && ea.vertexAttributes.position; if (!ba) return !1; const aa = this._context.elevationProvider.spatialReference, W = ba.length / 3; ea.spatialReference.equals(aa) || (ba = new Float64Array(ba.length), f.projectBuffer(ea.vertexAttributes.position, ea.spatialReference, 0, ba,
                      aa, 0, W)); t.empty(da); t.expandWithBuffer(da, ba, 0, W); return !t.intersectsClippingArea(da, this._context.clippingExtent)
                  }; ka._createGeometryInfo = function (ea, ba) {
                    if (!f.canProjectWithoutEngine(ea.spatialReference, this._context.layerView.view.spatialReference)) return this.logger.warn("Geometry spatial reference is not compatible with the view"), null; if (this._isOutsideClippingArea(ea)) return null; ba = this._createBuffers(ea, ba); if (u.isNone(ba)) return null; const { positionBuffer: aa, uvBuffer: W, colorBuffer: U, symbolColorBuffer: X,
                      normalBuffer: Z, tangentBuffer: ia, objectTransformation: la, geometryTransformation: ma } = ba; var ra = this._getOrCreateComponents(ea); ba = []; const Aa = [], za = []; let Ka = !1; for (const Ua of ra) {
                        if (!this._validateFaces(ea, Ua)) return null; ra = this._getOrCreateFaces(ea, Ua); if (0 === ra.length) continue; var Ea = this._createComponentNormals(aa, Z, Ua, ra); Ea.didFlipNormals && (Ka = !0); const Na = [["position", { size: 3, data: aa, exclusive: !0 }], ["normal", { size: 3, data: Ea.normals, exclusive: !0 }]]; Ea = [["position", ra], ["normal", Ea.indices]];
                        u.isSome(U) && (Na.push(["color", { size: 4, data: U, exclusive: !0 }]), Ea.push(["color", ra])); u.isSome(X) && (Na.push(["symbolColor", { size: 4, data: X, exclusive: !0 }]), Ea.push(["symbolColor", new Uint16Array(ra.length)])); u.isSome(W) && (Na.push(["uv0", { size: 2, data: W, exclusive: !0 }]), Ea.push(["uv0", ra])); u.isSome(ia) && (Na.push(["tangent", { size: 4, data: ia, exclusive: !0 }]), Ea.push(["tangent", ra])); ra = new J.Geometry(Na, Ea); ba.push(ra); Aa.push(ma); za.push(this._getOrCreateMaterial(ea, Ua))
                      } Ka && this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals.");
                    return { geometries: ba, transformations: Aa, materials: za, objectTransformation: la }
                  }; ka._createEdgeMaterial = function () { const ea = { opacity: this._getLayerOpacity() }; return D.createMaterial(this.symbolLayer, ea) }; return ha
          }(C.Graphics3DSymbolLayer); const G = b.create(), I = b.create(), O = b.create(), R = b.create(), S = b.create(), Q = l.create(), T = n.create(), da = t.create(), Y = [new v]; a.Graphics3DMeshFillSymbolLayer = q; a.default = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/support/MeshComponent": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/lang ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/ensureType ./MeshMaterial ./MeshMaterialMetallicRoughness ./MeshVertexAttributes".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          var f; const t = u.getLogger("esri.geometry.support.MeshComponent"); c = f = function (v) {
            function m(g) { g = v.call(this, g) || this; g.faces = null; g.material = null; g.shading = "source"; g.trustSourceNormals = !1; return g } a._inheritsLoose(m, v); m.from = function (g) { return l.ensureClass(f, g) }; var e = m.prototype; e.castFaces = function (g) { return d.castArray(g, Uint32Array, [Uint16Array], { loggerTag: ".faces\x3d", stride: 3 }, t) }; e.castMaterial = function (g) {
              return g && "object" === typeof g && ("metallic" in g ||
                "roughness" in g || "metallicRoughnessTexture" in g) ? l.ensureClass(b, g) : l.ensureClass(h, g)
            }; e.clone = function () { return new f({ faces: q.clone(this.faces), shading: this.shading, material: q.clone(this.material), trustSourceNormals: this.trustSourceNormals }) }; e.cloneWithDeduplication = function (g, x) { g = { faces: q.clone(this.faces), shading: this.shading, material: this.material ? this.material.cloneWithDeduplication(g, x) : null, trustSourceNormals: this.trustSourceNormals }; return new f(g) }; return m
          }(c.JSONSupport); w.__decorate([y.property({ json: { write: !0 } })],
            c.prototype, "faces", void 0); w.__decorate([n.cast("faces")], c.prototype, "castFaces", null); w.__decorate([y.property({ type: h, json: { write: !0 } })], c.prototype, "material", void 0); w.__decorate([n.cast("material")], c.prototype, "castMaterial", null); w.__decorate([y.property({ type: String, json: { write: !0 } })], c.prototype, "shading", void 0); w.__decorate([y.property({ type: Boolean })], c.prototype, "trustSourceNormals", void 0); return c = f = w.__decorate([p.subclass("esri.geometry.support.MeshComponent")], c)
        })
    }, "esri/geometry/support/MeshMaterial": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./MeshTexture".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          var d; q = d = function (f) {
            function t(m) { m = f.call(this, m) || this; m.color = null; m.colorTexture = null; m.normalTexture = null; m.alphaMode = "auto"; m.alphaCutoff = .5; m.doubleSided = !0; return m } a._inheritsLoose(t, f); var v = t.prototype; v.clone = function () { return this.cloneWithDeduplication(null, new Map) }; v.cloneWithDeduplication = function (m, e) { const g = u.isSome(m) ? m.get(this) : null; if (g) return g; e = new d(this.clonePropertiesWithDeduplication(e)); u.isSome(m) && m.set(this, e); return e }; v.clonePropertiesWithDeduplication =
              function (m) { return { color: u.isSome(this.color) ? this.color.clone() : null, colorTexture: u.isSome(this.colorTexture) ? this.colorTexture.cloneWithDeduplication(m) : null, normalTexture: u.isSome(this.normalTexture) ? this.normalTexture.cloneWithDeduplication(m) : null, alphaMode: this.alphaMode, alphaCutoff: this.alphaCutoff, doubleSided: this.doubleSided } }; return t
          }(q.JSONSupport); w.__decorate([y.property({ type: c, json: { write: !0 } })], q.prototype, "color", void 0); w.__decorate([y.property({ type: b, json: { write: !0 } })], q.prototype,
            "colorTexture", void 0); w.__decorate([y.property({ type: b, json: { write: !0 } })], q.prototype, "normalTexture", void 0); w.__decorate([y.property({ nonNullable: !0, json: { write: !0 } })], q.prototype, "alphaMode", void 0); w.__decorate([y.property({ nonNullable: !0, json: { write: !0 } })], q.prototype, "alphaCutoff", void 0); w.__decorate([y.property({ nonNullable: !0, json: { write: !0 } })], q.prototype, "doubleSided", void 0); return q = d = w.__decorate([h.subclass("esri.geometry.support.MeshMaterial")], q)
        })
    }, "esri/geometry/support/MeshTexture": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/has ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../chunks/persistableUrlUtils ../../views/support/screenshotUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          var f; const t = new WeakMap; let v = 0; c = f = function (m) {
            function e(x) { x = m.call(this, x) || this; x.wrap = "repeat"; return x } a._inheritsLoose(e, m); var g = e.prototype; g.writeData = function (x, k, r, A) {
              x instanceof HTMLImageElement ? (x = { type: "image-element", src: b.toJSON(x.src, A), crossOrigin: x.crossOrigin }, k[r] = x) : x instanceof HTMLCanvasElement ? (x = x.getContext("2d").getImageData(0, 0, x.width, x.height), x = { type: "canvas-element", imageData: this.encodeImageData(x) }, k[r] = x) : x instanceof HTMLVideoElement ?
                (x = { type: "video-element", src: b.toJSON(x.src, A), autoplay: x.autoplay, loop: x.loop, muted: x.muted, crossOrigin: x.crossOrigin, preload: x.preload }, k[r] = x) : (x = { type: "image-data", imageData: this.encodeImageData(x) }, k[r] = x)
            }; g.readData = function (x) {
              switch (x.type) {
                case "image-element": var k = new Image; k.src = x.src; k.crossOrigin = x.crossOrigin; return k; case "canvas-element": return x = this.decodeImageData(x.imageData), k = document.createElement("canvas"), k.width = x.width, k.height = x.height, k.getContext("2d").putImageData(x,
                  0, 0), k; case "image-data": return this.decodeImageData(x.imageData); case "video-element": return k = document.createElement("video"), k.src = x.src, k.crossOrigin = x.crossOrigin, k.autoplay = x.autoplay, k.loop = x.loop, k.muted = x.muted, k.preload = x.preload, k
              }
            }; g.clone = function () { const x = { url: this.url, data: this.data, wrap: this.cloneWrap() }; return new f(x) }; g.cloneWithDeduplication = function (x) { var k = x.get(this); if (k) return k; k = this.clone(); x.set(this, k); return k }; g.cloneWrap = function () {
              return "string" === typeof this.wrap ?
                this.wrap : { horizontal: this.wrap.horizontal, vertical: this.wrap.vertical }
            }; g.encodeImageData = function (x) { let k = ""; for (let r = 0; r < x.data.length; r++)k += String.fromCharCode(x.data[r]); return { data: btoa(k), width: x.width, height: x.height } }; g.decodeImageData = function (x) { const k = atob(x.data), r = new Uint8ClampedArray(k.length); for (let A = 0; A < k.length; A++)r[A] = k.charCodeAt(A); return d.wrapImageData(r, x.width, x.height) }; g.imageDataContainsTransparent = function (x) {
              for (let k = 3; k < x.data.length; k += 4)if (255 !== x.data[k]) return !0;
              return !1
            }; e.from = function (x) { return "string" === typeof x ? new f({ url: x }) : x instanceof HTMLImageElement || x instanceof HTMLCanvasElement || x instanceof ImageData || x instanceof HTMLVideoElement ? new f({ data: x }) : n.ensureClass(f, x) }; a._createClass(e, [{ key: "url", get: function () { return this._get("url") || null }, set: function (x) { this._set("url", x); x && this._set("data", null) } }, { key: "data", get: function () { return this._get("data") || null }, set: function (x) { this._set("data", x); x && this._set("url", null) } }, {
              key: "transparent",
              get: function () { var x = this.data, k = this.url; return x instanceof HTMLCanvasElement ? this.imageDataContainsTransparent(x.getContext("2d").getImageData(0, 0, x.width, x.height)) : x instanceof ImageData ? this.imageDataContainsTransparent(x) : k && (x = k.substr(k.length - 4, 4).toLowerCase(), k = k.substr(0, 15).toLocaleLowerCase(), ".png" === x || "data:image/png;" === k) ? !0 : !1 }, set: function (x) { null != x ? this._override("transparent", x) : this._clearOverride("transparent") }
            }, {
              key: "contentHash", get: function () {
                const x = "string" === typeof this.wrap ?
                  this.wrap : "object" === typeof this.wrap ? `${this.wrap.horizontal}/${this.wrap.vertical}` : "", k = (r = "") => `d:${r},t:${this.transparent},w:${x}`; if (null != this.url) return k(this.url); if (null != this.data) { if (this.data instanceof HTMLImageElement || this.data instanceof HTMLVideoElement) return k(this.data.src); t.has(this.data) || t.set(this.data, ++v); return k(t.get(this.data)) } return k()
              }
            }]); return e
          }(q.JSONSupport); w.__decorate([u.property({ type: String, json: { write: b.write } })], c.prototype, "url", null); w.__decorate([u.property({ json: { write: { overridePolicy() { return { enabled: !this.url } } } } }),
          u.property()], c.prototype, "data", null); w.__decorate([h.writer("data")], c.prototype, "writeData", null); w.__decorate([p.reader("data")], c.prototype, "readData", null); w.__decorate([u.property({ type: Boolean, json: { write: { overridePolicy() { return { enabled: this._isOverridden("transparent") } } } } })], c.prototype, "transparent", null); w.__decorate([u.property({ json: { write: !0 } })], c.prototype, "wrap", void 0); w.__decorate([u.property({ readOnly: !0 })], c.prototype, "contentHash", null); return c = f = w.__decorate([l.subclass("esri.geometry.support.MeshTexture")],
            c)
        })
    }, "esri/views/support/screenshotUtils": function () {
      define(["exports", "../../core/has", "../../core/mathUtils"], function (a, w, c) {
        function q(m, e) {
          const { format: g, quality: x, rotation: k, disableDecorations: r } = m || {}; var A = l(m, e.padding); var z = e.width - A.left - A.right; e = e.height - A.top - A.bottom; A = { x: 0, y: 0, width: z, height: e }; if (m && m.area) {
          null != m.area.x && (A.x = Math.floor(m.area.x)); null != m.area.y && (A.y = Math.floor(m.area.y)); var B = null != m.area.width ? Math.floor(m.area.width) : null, C = null != m.area.height ? Math.floor(m.area.height) :
            null; A.width = z - A.x; A.height = e - A.y; null != B && null != C ? (A.width = Math.min(A.width, B), A.height = Math.min(A.height, C)) : null == B && null != C ? (B = Math.min(A.width, B), A.height *= B / A.width, A.width = B) : null != B && null == C && (B = Math.min(A.height, C), A.width *= B / A.height, A.height = B)
          } A = p(A, m); B = Math.floor(Math.max(A.x, 0)); C = Math.floor(Math.max(A.y, 0)); z = { x: B, y: C, width: Math.floor(Math.min(A.width, z - B)), height: Math.floor(Math.min(A.height, e - C)) }; e = z.width / z.height; A = A.width / A.height; A !== e && (A > e ? (e = Math.floor(z.width / A), z = {
            x: z.x,
            y: Math.floor(z.y + (z.height - e) / 2), width: z.width, height: e
          }) : (e = Math.floor(z.height * A), z = { x: Math.floor(z.x + (z.width - e) / 2), y: z.y, width: e, height: z.height })); const { width: D, height: E } = n(m, z); e = h(g); A = t[e]; A = c.clamp(null != x ? x : A, 0, 100); return { format: e, quality: A, area: z, width: D, height: E, rotation: k, disableDecorations: !!r, ignoreBackground: !(!m || !m.ignoreBackground), ignorePadding: !(!m || !m.ignorePadding) }
        } function u(m, e) { return m.toDataURL(f[e.format], e.quality / 100) } function y(m, e, g) {
          g || (b || (b = document.createElement("canvas"),
            b.width = 1, b.height = 1), g = b); return g.getContext("2d").createImageData(m, e)
        } function n(m, e) { if (!m) return e; const g = m.width; m = m.height; if (null != g && null != m) return { width: Math.floor(g), height: Math.floor(m) }; if (null == g && null == m) return e; e = e.width / e.height; return null == m ? { width: Math.floor(g), height: Math.floor(g / e) } : { width: Math.floor(m * e), height: Math.floor(m) } } function p(m, e) {
          if (!e || null == e.width || null == e.height) return m; e = e.width / e.height; const g = m.width / m.height; if (g === e) return m; if (g < e) return e = Math.floor(m.height *
            e), m.x -= (e - m.width) / 2, m.width = e, m; e = Math.floor(m.width / e); m.y -= (e - m.height) / 2; m.height = e; return m
        } function l(m, e) { return !e || m && m.ignorePadding ? v : e } function h(m) { switch (m) { case "png": case "jpg": case "jpeg": return m; case null: case void 0: return "png"; default: return "png" } } let b = null, d = !0; const f = { png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg" }, t = { png: 100, jpg: 98, jpeg: 98 }, v = { top: 0, right: 0, bottom: 0, left: 0 }; a.completeUserSettings = q; a.createEmptyImageData = function (m, e, g) {
          if (!m || !e) throw Error("Cannot construct image data without dimensions");
          if (d) try { return new ImageData(m, e) } catch (x) { d = !1 } return y(m, e, g)
        }; a.encodeResult = function (m, e, g, x) {
          if (x.premultipliedAlpha) { { var k = m.data; const A = k.length; for (let z = 0; z < A; z += 4) { var r = k[z + 3]; 0 < r && (r /= 255, k[z + 0] /= r, k[z + 1] /= r, k[z + 2] /= r) } } } g.width = m.width; g.height = m.height; k = g.getContext("2d"); k.putImageData(m, 0, 0); x.flipY && (k.save(), k.globalCompositeOperation = "copy", k.scale(1, -1), k.translate(0, -k.canvas.height), k.drawImage(k.canvas, 0, 0), k.restore()); m = k.getImageData(0, 0, m.width, m.height); e = u(g, e); g.width =
            0; g.height = 0; return { dataUrl: e, data: m }
        }; a.getFormatAndQuality = function (m, e) { m = h(m); const g = t[m]; e = c.clamp(null != e ? e : g, 0, 100); return { format: m, quality: e } }; a.getMaximumResolutionScale = function (m, e) { return e / Math.max(m[0], m[1]) }; a.resampleHermite = function (m, e, g, x = 0, k = 0, r = m.width - x, A = m.height - k, z = !1) {
          const { data: B } = m, { width: C, height: D, data: E } = e; r /= C; A /= D; const H = Math.ceil(r / 2), J = Math.ceil(A / 2); m = m.width; for (let K = 0; K < D; K++)for (let P = 0; P < C; P++) {
            const L = 4 * (P + (z ? D - K - 1 : K) * C); let N = 0, G = 0, I = 0, O = 0, R = 0, S = 0; const Q =
              (K + .5) * A; for (let T = Math.floor(K * A); T < (K + 1) * A; T++) { var M = Math.abs(Q - (T + .5)) / J; const da = (P + .5) * r; M *= M; for (let Y = Math.floor(P * r); Y < (P + 1) * r; Y++) { var F = Math.abs(da - (Y + .5)) / H; F = Math.sqrt(M + F * F); if (1 <= F) continue; F = 2 * F * F * F - 3 * F * F + 1; const fa = 4 * (x + Y + (k + T) * m); S += F * B[fa + 3]; G += F; !g && 255 > B[fa + 3] && (F = F * B[fa + 3] / 255); I += F * B[fa]; O += F * B[fa + 1]; R += F * B[fa + 2]; N += F } } E[L] = I / N; E[L + 1] = O / N; E[L + 2] = R / N; E[L + 3] = S / G
          } return e
        }; a.screenshotSuperSampleSettings = function (m, e, g) {
          if (!e) return m; const { framebufferWidth: x, framebufferHeight: k,
            pixelRatio: r, region: A } = m; e = l(m, g); g = e.left + e.right; const z = e.top + e.bottom, B = x - g, C = k - z, D = Math.min(8, Math.min((2048 - g) / B, (2048 - z) / C)); return 1.5 > D ? m : { ...m, framebufferWidth: Math.round(B * D) + g, framebufferHeight: Math.round(C * D) + z, pixelRatio: r * D, resample: { region: { x: Math.round((A.x - e.left) * D) + e.left, y: Math.round((A.y - e.top) * D) + e.top, width: Math.round(A.width * D), height: Math.round(A.height * D) }, width: x, height: k } }
        }; a.toDataUrl = u; a.toRenderSettings = function (m, e) {
          const g = q(m, e), x = g.area, k = g.width / x.width, r = l(g,
            e.padding), A = r.left + r.right, z = r.top + r.bottom; return { framebufferWidth: Math.floor((e.width - A) * k + A), framebufferHeight: Math.floor((e.height - z) * k + z), region: { x: Math.floor(x.x * k) + r.left, y: Math.floor(x.y * k) + r.top, width: g.width, height: g.height }, format: g.format, quality: g.quality, rotation: g.rotation, pixelRatio: k, layers: m && m.layers ? m.layers : [], disableDecorations: g.disableDecorations, ignoreBackground: g.ignoreBackground, ignorePadding: g.ignorePadding }
        }; a.wrapImageData = function (m, e, g, x) {
          if (!e || !g) throw Error("Cannot construct image data without dimensions");
          if (d) try { return new ImageData(m, e, g) } catch (k) { d = !1 } e = y(e, g, x); e.data.set(m, 0); return e
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/MeshMaterialMetallicRoughness": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./MeshMaterial ./MeshTexture".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          var d; y = d = function (f) {
            function t(m) { m = f.call(this, m) || this; m.emissiveColor = null; m.emissiveTexture = null; m.occlusionTexture = null; m.metallic = 1; m.roughness = 1; m.metallicRoughnessTexture = null; return m } a._inheritsLoose(t, f); var v = t.prototype; v.clone = function () { return this.cloneWithDeduplication(null, new Map) }; v.cloneWithDeduplication = function (m, e) {
              const g = q.isSome(m) ? m.get(this) : null; if (g) return g; e = new d(this.clonePropertiesWithDeduplication(e)); q.isSome(m) && m.set(this, e);
              return e
            }; v.clonePropertiesWithDeduplication = function (m) {
              return {
                ...f.prototype.clonePropertiesWithDeduplication.call(this, m), emissiveColor: q.isSome(this.emissiveColor) ? this.emissiveColor.clone() : null, emissiveTexture: q.isSome(this.emissiveTexture) ? this.emissiveTexture.cloneWithDeduplication(m) : null, occlusionTexture: q.isSome(this.occlusionTexture) ? this.occlusionTexture.cloneWithDeduplication(m) : null, metallic: this.metallic, roughness: this.roughness, metallicRoughnessTexture: q.isSome(this.metallicRoughnessTexture) ?
                  this.metallicRoughnessTexture.cloneWithDeduplication(m) : null
              }
            }; return t
          }(h); w.__decorate([u.property({ type: c, json: { write: !0 } })], y.prototype, "emissiveColor", void 0); w.__decorate([u.property({ type: b, json: { write: !0 } })], y.prototype, "emissiveTexture", void 0); w.__decorate([u.property({ type: b, json: { write: !0 } })], y.prototype, "occlusionTexture", void 0); w.__decorate([u.property({ type: Number, nonNullable: !0, json: { write: !0 }, range: { min: 0, max: 1 } })], y.prototype, "metallic", void 0); w.__decorate([u.property({
            type: Number,
            nonNullable: !0, json: { write: !0 }, range: { min: 0, max: 1 }
          })], y.prototype, "roughness", void 0); w.__decorate([u.property({ type: b, json: { write: !0 } })], y.prototype, "metallicRoughnessTexture", void 0); return y = d = w.__decorate([l.subclass("esri.geometry.support.MeshMaterialMetallicRoughness")], y)
        })
    }, "esri/geometry/support/MeshVertexAttributes": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/lang ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(v, m, e, g) { const { loggerTag: x, stride: k } = m; return 0 !== v.length % k ? (g.error(x, `Invalid array length, expected a multiple of ${k}`), new e([])) : v } function b(v, m, e, g, x) { if (!v) return v; if (v instanceof m) return h(v, g, m, x); for (const k of e) if (v instanceof k) return h(new m(v), g, m, x); if (Array.isArray(v)) return h(new m(v), g, m, x); e = e.map(k => `'${k.name}'`); x.error(`Failed to set property, expected one of ${e}, but got ${v.constructor.name}`); return new m([]) } function d(v, m,
            e) { { const g = Array(v.length); for (let x = 0; x < v.length; x++)g[x] = v[x]; v = g } m[e] = v } var f; const t = y.getLogger("esri.geometry.support.MeshVertexAttributes"); a.MeshVertexAttributes = f = function (v) {
              function m(g) { g = v.call(this, g) || this; g.color = null; g.position = new Float64Array(0); g.uv = null; g.normal = null; g.tangent = null; return g } w._inheritsLoose(m, v); var e = m.prototype; e.castColor = function (g) { return b(g, Uint8Array, [Uint8ClampedArray], { loggerTag: ".color\x3d", stride: 4 }, t) }; e.castPosition = function (g) {
              g && g instanceof Float32Array &&
                t.warn(".position\x3d", "Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array"); return b(g, Float64Array, [Float32Array], { loggerTag: ".position\x3d", stride: 3 }, t)
              }; e.castUv = function (g) { return b(g, Float32Array, [Float64Array], { loggerTag: ".uv\x3d", stride: 2 }, t) }; e.castNormal = function (g) { return b(g, Float32Array, [Float64Array], { loggerTag: ".normal\x3d", stride: 3 }, t) }; e.castTangent = function (g) {
                return b(g, Float32Array, [Float64Array],
                  { loggerTag: ".tangent\x3d", stride: 4 }, t)
              }; e.clone = function () { const g = { position: u.clone(this.position), uv: u.clone(this.uv), normal: u.clone(this.normal), tangent: u.clone(this.tangent), color: u.clone(this.color) }; return new f(g) }; e.clonePositional = function () { const g = { position: u.clone(this.position), normal: u.clone(this.normal), tangent: u.clone(this.tangent), uv: this.uv, color: this.color }; return new f(g) }; return m
            }(q.JSONSupport); c.__decorate([n.property({ json: { write: d } })], a.MeshVertexAttributes.prototype, "color",
              void 0); c.__decorate([p.cast("color")], a.MeshVertexAttributes.prototype, "castColor", null); c.__decorate([n.property({ nonNullable: !0, json: { write: d } })], a.MeshVertexAttributes.prototype, "position", void 0); c.__decorate([p.cast("position")], a.MeshVertexAttributes.prototype, "castPosition", null); c.__decorate([n.property({ json: { write: d } })], a.MeshVertexAttributes.prototype, "uv", void 0); c.__decorate([p.cast("uv")], a.MeshVertexAttributes.prototype, "castUv", null); c.__decorate([n.property({ json: { write: d } })], a.MeshVertexAttributes.prototype,
                "normal", void 0); c.__decorate([p.cast("normal")], a.MeshVertexAttributes.prototype, "castNormal", null); c.__decorate([n.property({ json: { write: d } })], a.MeshVertexAttributes.prototype, "tangent", void 0); c.__decorate([p.cast("tangent")], a.MeshVertexAttributes.prototype, "castTangent", null); a.MeshVertexAttributes = f = c.__decorate([l.subclass("esri.geometry.support.MeshVertexAttributes")], a.MeshVertexAttributes); c = a.MeshVertexAttributes; a.castArray = b; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/geometry/support/meshUtils/projection": function () {
      define("exports ../../../core/Logger ../../../core/maybe ../../../chunks/mat3 ../../../chunks/mat3f64 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../projection ../../projectionEllipsoid ../spatialReferenceUtils ../webMercatorUtils ../buffer/BufferView ../../../chunks/vec32".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        function v(z, B, C, D, E, H) {
          if (B) {
            var J = C.count, M = h.getSphericalPCPF(E); if (e(E)) for (C = 0; C < J; C++)D.getVec(C,
              x), B.getVec(C, k), l.computeTranslationToOriginAndRotation(M, x, r, M), q.fromMat4(A, r), 1 === z && q.transpose(A, A), n.transformMat3(k, k, A), H.setVec(C, k); else for (E = 0; E < J; E++) { D.getVec(E, x); B.getVec(E, k); l.computeTranslationToOriginAndRotation(M, x, r, M); q.fromMat4(A, r); var F = d.y2lat(C.get(E, 1)); F = Math.cos(F); 0 === z && (F = 1 / F); A[0] *= F; A[1] *= F; A[2] *= F; A[3] *= F; A[4] *= F; A[5] *= F; 1 === z && q.transpose(A, A); n.transformMat3(k, k, A); n.normalize(k, k); H.setVec(E, k) } return H
          }
        } function m(z) { return e(z) || z.isWebMercator } function e(z) {
          return z.isWGS84 ||
            b.isCGCS2000(z) || b.isMars(z) || b.isMoon(z)
        } const g = w.getLogger("esri.geometry.support.meshUtils.normalProjection"), x = p.create(), k = p.create(), r = y.create(), A = u.create(); a.projectFromPCPF = function (z, B, C) { l.projectBuffer(z, h.getSphericalPCPF(C), 0, B, C, 0, z.length / 3); return B }; a.projectNormalFromPCPF = function (z, B, C, D, E) {
          if (!m(D)) return g.error("Cannot convert to spatial reference from PCPF"), E; v(1, f.BufferViewVec3f.fromTypedArray(z), f.BufferViewVec3f64.fromTypedArray(B), f.BufferViewVec3f64.fromTypedArray(C),
            D, f.BufferViewVec3f.fromTypedArray(E)); return E
        }; a.projectNormalToPCPF = function (z, B, C, D, E) { if (!m(D)) return g.error("Cannot convert spatial reference to PCPF"), E; v(0, f.BufferViewVec3f.fromTypedArray(z), f.BufferViewVec3f64.fromTypedArray(B), f.BufferViewVec3f64.fromTypedArray(C), D, f.BufferViewVec3f.fromTypedArray(E)); return E }; a.projectTangentFromPCPF = function (z, B, C, D, E) {
          if (!m(D)) return g.error("Cannot convert to spatial reference from PCPF"), E; v(1, f.BufferViewVec3f.fromTypedArray(z, 16), f.BufferViewVec3f64.fromTypedArray(B),
            f.BufferViewVec3f64.fromTypedArray(C), D, f.BufferViewVec3f.fromTypedArray(E, 16)); for (B = 3; B < z.length; B += 4)E[B] = z[B]; return E
        }; a.projectTangentToPCPF = function (z, B, C, D, E) { if (!m(D)) return g.error("Cannot convert spatial reference to PCPF"), E; v(0, f.BufferViewVec3f.fromTypedArray(z, 4 * Float32Array.BYTES_PER_ELEMENT), f.BufferViewVec3f64.fromTypedArray(B), f.BufferViewVec3f64.fromTypedArray(C), D, f.BufferViewVec3f.fromTypedArray(E, 4 * Float32Array.BYTES_PER_ELEMENT)); for (B = 3; B < z.length; B += 4)E[B] = z[B]; return E };
        a.projectToPCPF = function (z, B, C) { l.projectBuffer(z, B, 0, C, h.getSphericalPCPF(B), 0, z.length / 3); return C }; a.transformNormal = function (z, B, C) { if (c.isNone(z)) return B; q.normalFromMat4(A, C); z = f.BufferViewVec3f.fromTypedArray(z); C = f.BufferViewVec3f.fromTypedArray(B); t.transformMat3(C, z, A); q.isOrthoNormal(A) || t.normalize(C, C); return B }; a.transformPosition = function (z, B, C) { if (c.isNone(z)) return B; z = f.BufferViewVec3f64.fromTypedArray(z); const D = f.BufferViewVec3f64.fromTypedArray(B); t.transformMat4(D, z, C); return B };
        a.transformTangent = function (z, B, C) { if (c.isNone(z)) return B; q.normalFromMat4(A, C); C = f.BufferViewVec3f.fromTypedArray(z, 4 * Float32Array.BYTES_PER_ELEMENT); const D = f.BufferViewVec3f.fromTypedArray(B, 4 * Float32Array.BYTES_PER_ELEMENT); t.transformMat3(D, C, A); q.isOrthoNormal(A) || t.normalize(D, D); if (z !== B) for (C = 3; C < z.length; C += 4)B[C] = z[C]; return B }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/symbolColorUtils": function () {
      define(["exports", "../../../../core/mathUtils", "../../../../core/maybe"],
        function (a, w, c) {
        a.encodeSymbolColor = function (q, u, y) { if (c.isNone(q) || 2 === u) y[0] = 255, y[1] = 255, y[2] = 255, y[3] = 255; else { var n = w.clamp(Math.round(85 * q[3]), 0, 85); u = 0 === n || 4 === u ? 0 : 3 === u ? 85 : 170; y[0] = w.clamp(Math.round(255 * q[0]), 0, 255); y[1] = w.clamp(Math.round(255 * q[1]), 0, 255); y[2] = w.clamp(Math.round(255 * q[2]), 0, 255); y[3] = n + u } }; a.parseColorMixMode = function (q) { switch (q) { case "multiply": return 1; case "ignore": return 2; case "replace": return 3; case "tint": return 4; default: return 1 } }; Object.defineProperty(a, "__esModule",
          { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/NativeLineMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Logger ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/vec2 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/lineSegment ../../../../geometry/support/plane ../../../../geometry/support/buffer/BufferView ../lib/geometryDataUtils ../lib/GLMaterial ../lib/Material ../lib/Util ./internal/bufferWriterUtils ./internal/DefaultBufferWriter ./internal/MaterialUtil ./renderers/utils ../shaders/NativeLineTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k) {
          const r = c.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial"); c = function (T) {
            function da(fa) { fa = T.call(this, fa, B) || this; fa._techniqueConfig = new k.NativeLineTechniqueConfiguration; return fa } w._inheritsLoose(da, T); var Y = da.prototype; Y.getTechniqueConfig = function (fa, ha) {
              this._techniqueConfig.output = fa; this._techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this._techniqueConfig.vertexColors = this.parameters.vertexColors;
              this._techniqueConfig.transparent = 1 > this.parameters.color[3] || 1 > this.parameters.width; this._techniqueConfig.draped = 20 === ha.slot; fa = q.isSome(this.parameters.stipplePattern); this._techniqueConfig.stippleEnabled = fa; this._techniqueConfig.stippleOffColorEnabled = fa && q.isSome(this.parameters.stippleOffColor); this._techniqueConfig.sceneHasOcludees = this.parameters.sceneHasOcludees; this._techniqueConfig.stipplePreferContinuous = this.parameters.stipplePreferContinuous; return this._techniqueConfig
            }; Y.getPassParameters =
              function () { return this.parameters }; Y.intersect = function (fa, ha, ka, ea, ba, aa, W, U, X) { q.isSome(X) ? g.intersectDrapedRenderLineGeometry(fa, ea, X, aa, 1, W) : this.intersectLineGeometry(fa, ha, ka, ea, W) }; Y.intersectLineGeometry = function (fa, ha, ka, ea, ba) {
                if (ea.options.selectionMode && !x.isInstanceHidden(ha)) if (v.isTranslationMatrix(ka)) {
                  var aa = fa.vertexAttributes.get("position").data, W = ea.camera, U = N; y.copy(U, ea.point); n.set(G[0], U[0] - 2, U[1] + 2, 0); n.set(G[1], U[0] + 2, U[1] + 2, 0); n.set(G[2], U[0] + 2, U[1] - 2, 0); n.set(G[3], U[0] -
                    2, U[1] - 2, 0); for (fa = 0; 4 > fa; fa++)if (!W.unprojectFromRenderScreen(G[fa], I[fa])) return; h.fromPoints(W.eye, I[0], I[1], O); h.fromPoints(W.eye, I[1], I[2], R); h.fromPoints(W.eye, I[2], I[3], S); h.fromPoints(W.eye, I[3], I[0], Q); ha = Number.MAX_VALUE; fa = 0; for (let Z = 0; Z < aa.length - 5; Z += 3)if (C[0] = aa[Z] + ka[12], C[1] = aa[Z + 1] + ka[13], C[2] = aa[Z + 2] + ka[14], D[0] = aa[Z + 3] + ka[12], D[1] = aa[Z + 4] + ka[13], D[2] = aa[Z + 5] + ka[14], !(0 > h.signedDistance(O, C) && 0 > h.signedDistance(O, D) || 0 > h.signedDistance(R, C) && 0 > h.signedDistance(R, D) || 0 > h.signedDistance(S,
                      C) && 0 > h.signedDistance(S, D) || 0 > h.signedDistance(Q, C) && 0 > h.signedDistance(Q, D))) {
                        W.projectToRenderScreen(C, J); W.projectToRenderScreen(D, M); if (0 > J[2] && 0 < M[2]) { n.subtract(E, C, D); var X = W.frustum; X = -h.signedDistance(X[4], C) / n.dot(E, h.normal(X[4])); n.scale(E, E, X); n.add(C, C, E); W.projectToRenderScreen(C, J) } else if (0 < J[2] && 0 > M[2]) n.subtract(E, D, C), X = W.frustum, X = -h.signedDistance(X[4], D) / n.dot(E, h.normal(X[4])), n.scale(E, E, X), n.add(D, D, E), W.projectToRenderScreen(D, M); else if (0 > J[2] && 0 > M[2]) continue; J[2] = 0;
                      M[2] = 0; X = l.distance2(l.fromPoints(J, M, P), U); X < ha && (ha = X, n.copy(F, C), n.copy(K, D), fa = Z / 3)
                    } ka = ea.rayBegin; ea = ea.rayEnd; 4 > ha && (ha = Number.MAX_VALUE, l.closestLineSegmentPoint(l.fromPoints(F, K, P), l.fromPoints(ka, ea, L), H) && (n.subtract(H, H, ka), ha = n.length(H), n.scale(H, H, 1 / ha), ha /= n.distance(ka, ea)), ba(ha, H, fa, !1))
                } else r.error("intersection assumes a translation-only matrix")
              }; Y.computeAttachmentOrigin = function (fa, ha) {
                fa = fa.vertexAttributes; if (!fa) return !1; fa = fa.get("position"); return d.computeAttachmentOriginLines(fa,
                  null, !1, ha)
              }; Y.requiresSlot = function (fa) { return 2 === fa || 20 === fa }; Y.createGLMaterial = function (fa) { return 0 === fa.output || 4 === fa.output ? new A(fa) : null }; Y.createBufferWriter = function () { const fa = this.parameters.vertexColors ? e.PositionColorLayout : e.PositionLayout; return q.isNone(this.parameters.stipplePattern) ? new e.DefaultBufferWriter(fa) : new z(fa.clone().vec3f("auxpos1").vec2f("uv0")) }; return da
          }(t.Material); let A = function (T) {
            function da() { return T.apply(this, arguments) || this } w._inheritsLoose(da, T); var Y =
              da.prototype; Y.updateParameters = function (fa) { return this.ensureTechnique(k.NativeLineTechnique, fa) }; Y._updateOccludeeState = function (fa) { fa.hasOccludees !== this._material.parameters.sceneHasOcludees && this._material.setParameters({ sceneHasOcludees: fa.hasOccludees }) }; Y.beginSlot = function (fa) { 0 === this._output && this._updateOccludeeState(fa); return this.updateParameters(fa) }; Y.bind = function (fa, ha) { ha.bindPass(this._material.getPassParameters(), fa) }; return da
          }(f), z = function () {
            function T(Y) {
            this.vertexBufferLayout =
              Y
            } var da = T.prototype; da.allocate = function (Y) { return this.vertexBufferLayout.createBuffer(Y) }; da.elementCount = function (Y) { return Y.indices.get("position").length }; da.write = function (Y, fa, ha, ka) { m.writeDefaultAttributes(fa, this.vertexBufferLayout, Y.transformation, Y.invTranspTransformation, ha, ka); this.writeAuxpos1(Y, fa, ha, ka); this.writeUV0(Y, fa, ha, ka) }; da.writeAuxpos1 = function (Y, fa, ha, ka) {
              var ea = ha.getField("auxpos1", b.BufferViewVec3f); ha = fa.indices.get("position"); fa = fa.vertexAttributes.get("position").data;
              Y = Y.transformation; const ba = ea.typedBufferStride; ea = ea.typedBuffer; ka *= ba; for (let W = 0; W < ha.length - 1; W += 2)for (const U of [1, 0]) { var aa = 3 * ha[W + U]; const X = fa[aa], Z = fa[aa + 1]; aa = fa[aa + 2]; const ia = Y[1] * X + Y[5] * Z + Y[9] * aa + Y[13], la = Y[2] * X + Y[6] * Z + Y[10] * aa + Y[14]; ea[ka] = Y[0] * X + Y[4] * Z + Y[8] * aa + Y[12]; ea[ka + 1] = ia; ea[ka + 2] = la; ka += ba }
            }; da.writeUV0 = function (Y, fa, ha, ka) {
              var ea, ba = ha.getField("uv0", b.BufferViewVec2f), aa = fa.indices.get("position"); ha = fa.vertexAttributes.get("position").data; const W = null == (ea = fa.vertexAttributes.get("distanceToStart")) ?
                void 0 : ea.data; Y = Y.transformation; fa = ba.typedBufferStride; ba = ba.typedBuffer; ka *= fa; let U = 0; ba[ka] = 0; ba[ka + 1] = U; ka += fa; ea = 3 * aa[0]; ea = n.set(C, ha[ea], ha[ea + 1], ha[ea + 2]); Y && n.transformMat4(ea, ea, Y); const X = D, Z = aa.length - 1; let ia = 1; const la = W ? (ra, Aa, za) => U = W[za] : (ra, Aa, za) => U += n.distance(ra, Aa); for (let ra = 1; ra < Z; ra += 2) { var ma = 3 * aa[ra]; n.set(X, ha[ma], ha[ma + 1], ha[ma + 2]); Y && n.transformMat4(X, X, Y); la(ea, X, ia++); for (ma = 0; 2 > ma; ++ma)ba[ka] = 1 - ma, ba[ka + 1] = U, ka += fa; n.copy(ea, X) } aa = 3 * aa[Z]; n.set(X, ha[aa], ha[aa + 1],
                  ha[aa + 2]); Y && n.transformMat4(X, X, Y); la(ea, X, ia); ba[ka] = 1; ba[ka + 1] = U
            }; return T
          }(); const B = { color: [1, 1, 1, 1], vertexColors: !1, slicePlaneEnabled: !1, width: 1, stipplePattern: null, stippleOffColor: null, stipplePreferContinuous: !0, sceneHasOcludees: !1, ...t.materialParametersDefaults }, C = p.create(), D = p.create(), E = p.create(), H = p.create(), J = u.createRenderScreenPointArray3(), M = u.createRenderScreenPointArray3(), F = p.create(), K = p.create(), P = l.create(), L = l.create(), N = p.create(), G = [u.createRenderScreenPointArray3(), u.createRenderScreenPointArray3(),
          u.createRenderScreenPointArray3(), u.createRenderScreenPointArray3()], I = [p.create(), p.create(), p.create(), p.create()], O = h.create(), R = h.create(), S = h.create(), Q = h.create(); a.NativeLineMaterial = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/shaders/NativeLineTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/maybe ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/Program ../lib/StencilUtils ../../../../chunks/NativeLine.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          h = function (e) {
            function g(k, r, A) { r = e.call(this, k, r, A) || this; r.stipplePattern = null; r.stippleTextureBind = null; r.stippleTextureRepository = k.stippleTextureRepository; return r } c._inheritsLoose(g, e); var x = g.prototype; x.initializeProgram = function (k) {
              var r = g.shader.get(); const A = this.configuration; r = r.build({
                output: A.output, attributeColor: A.vertexColors, slicePlaneEnabled: A.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, draped: A.draped,
                stippleEnabled: this.stippleEnabled, stippleOffColorEnabled: A.stippleOffColorEnabled, stippleRequiresClamp: !1, stippleScaleWithLineWidth: !1, stipplePreferContinuous: A.stipplePreferContinuous
              }); return new f.Program(k.rctx, r, d.Default3D)
            }; x.dispose = function () { e.prototype.dispose.call(this); this.stippleTextureRepository.release(this.stipplePattern); this.stippleTextureBind = this.stipplePattern = null }; x.bindPass = function (k, r) {
              p.bindProjectionMatrix(this.program, r.camera.projectionMatrix); if (this.stipplePattern !==
                k.stipplePattern) { const A = k.stipplePattern; this.stippleTextureBind = this.stippleTextureRepository.swap(this.stipplePattern, A); this.stipplePattern = A } if (this.stippleEnabled) {
                  const { pixelSize: A, sdfNormalizer: z, pixels: B } = u.isSome(this.stippleTextureBind) ? this.stippleTextureBind(this.program) : { pixelSize: 1, sdfNormalizer: 1, pixels: 1 }; this.program.setUniform1f("stipplePatternSDFNormalizer", z); this.program.setUniform1f("stipplePatternTextureSize", B); this.program.setUniform1f("stipplePatternPixelSize", A); this.program.setUniform1f("stipplePatternPixelSizeInv",
                    1 / A); this.program.setUniform1f("pixelRatio", r.camera.pixelRatio); this.configuration.draped ? this.program.setUniform1f("worldToScreenRatio", 1 / r.screenToPCSRatio) : this.program.setUniform1f("worldToScreenPerDistanceRatio", 1 / r.camera.perScreenPixelRatio); this.program.setUniform2f("ndcToPixel", r.camera.fullViewport[2] / 2, r.camera.fullViewport[3] / 2)
                } this.program.setUniform4fv("constantColor", k.color); this.program.setUniform1f("alphaCoverage", Math.min(1, k.width * r.camera.pixelRatio)); this.configuration.stippleOffColorEnabled &&
                  (k = u.unwrap(k.stippleOffColor), this.program.setUniform4f("stippleOffColor", k[0], k[1], k[2], 3 < k.length ? k[3] : 1)); 4 === this.configuration.output && n.bindOutputHighlight(this.program, r)
            }; x.bindDraw = function (k) { p.bindView(this.program, k); this.stippleEnabled && !this.configuration.draped && p.bindCameraPosition(this.program, k.origin, k.camera.viewInverseTransposeMatrix); y.bindSliceUniformsWithOrigin(this.program, this.configuration, k); this.program.rebindTextures() }; x.initializePipeline = function () {
              const k = this.configuration,
              r = m.separateBlendingParams(770, 1, 771, 771), A = (z, B = null, C = null) => m.makePipelineState({ blending: B, depthTest: t.depthCompareLess, depthWrite: C, colorWrite: m.defaultColorWriteParams, stencilWrite: k.sceneHasOcludees ? t.stencilWriteMaskOn : null, stencilTest: k.sceneHasOcludees ? z ? t.stencilToolMaskBaseParams : t.stencilBaseAllZerosParams : null }); return 0 === k.output ? (this._occludeePipelineState = A(!0, k.transparent || this.stippleEnabled ? r : null, m.defaultDepthWriteParams), A(!1, k.transparent || this.stippleEnabled ? r : null, m.defaultDepthWriteParams)) :
                A(!1)
            }; x.getPipelineState = function (k, r) { return r ? this._occludeePipelineState : e.prototype.getPipelineState.call(this, k, r) }; c._createClass(g, [{ key: "stippleEnabled", get: function () { return this.configuration.stippleEnabled && 4 !== this.configuration.output } }, { key: "primitiveType", get: function () { return 1 } }]); return g
          }(h.ShaderTechnique); h.shader = new l.ReloadableShaderModule(v.NativeLineShader, () => new Promise((e, g) => a(["./NativeLine.glsl"], e, g))); l = function (e) {
            function g() {
              var x = e.apply(this, arguments) || this;
              x.output = 0; x.slicePlaneEnabled = !1; x.vertexColors = !1; x.transparent = !1; x.draped = !1; x.stippleEnabled = !1; x.stippleOffColorEnabled = !1; x.stipplePreferContinuous = !0; x.sceneHasOcludees = !1; return x
            } c._inheritsLoose(g, e); return g
          }(b.ShaderTechniqueConfiguration); q.__decorate([b.parameter({ count: 8 })], l.prototype, "output", void 0); q.__decorate([b.parameter()], l.prototype, "slicePlaneEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "vertexColors", void 0); q.__decorate([b.parameter()], l.prototype, "transparent",
            void 0); q.__decorate([b.parameter()], l.prototype, "draped", void 0); q.__decorate([b.parameter()], l.prototype, "stippleEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "stippleOffColorEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "stipplePreferContinuous", void 0); q.__decorate([b.parameter()], l.prototype, "sceneHasOcludees", void 0); w.NativeLineTechnique = h; w.NativeLineTechniqueConfiguration = l; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/NativeLine.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(d) {
            const f = new l.ShaderBuilder; f.include(c.Transform, { linearDepth: !1 }); f.include(q.VertexColor, d); f.include(y.LineStipple, { ...d, stippleRequiresStretchMeasure: !1 }); f.vertex.uniforms.add("proj", "mat4").add("view", "mat4"); d.stippleEnabled && (f.vertex.uniforms.add("ndcToPixel", "vec2"), f.attributes.add("uv0", "vec2"), f.attributes.add("auxpos1", "vec3")); f.attributes.add("position", "vec3"); f.varyings.add("vpos", "vec3"); f.vertex.code.add(p.glsl`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`); d.stippleEnabled && (f.vertex.code.add(p.glsl`vec4 vpos2 = transformPosition(proj, view, auxpos1);
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`), d.draped || f.vertex.code.add(p.glsl`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), f.vertex.code.add(p.glsl`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`), d.draped ? f.vertex.code.add(p.glsl`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`) : f.vertex.code.add(p.glsl`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), f.vertex.code.add(p.glsl`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)); f.vertex.code.add(p.glsl`}`); 4 === d.output && f.include(u.OutputHighlight); f.include(w.Slice, d); f.fragment.uniforms.add("constantColor", "vec4").add("alphaCoverage", "float"); f.fragment.code.add(p.glsl`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${d.attributeColor ? "vColor" : "constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${p.glsl.float(n.symbolAlphaCutoff)}) {
      discard;
    }

    ${0 === d.output ? p.glsl`gl_FragColor = highlightSlice(finalColor, vpos);` : ""}
    ${4 === d.output ? p.glsl`outputHighlight();` : ""}
  }
  `); return f
          } const b = Object.freeze({ __proto__: null, build: h }); a.NativeLineShader = b; a.build = h
        })
    }, "esri/views/3d/layers/graphics/Graphics3DObjectSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../symbols/support/ObjectSymbol3DLayerResource ../../../../symbols/support/symbolLayerUtils3D ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DLodInstanceGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ./lodResourceUtils ./objectResourceUtils ./pointUtils ./primitiveObjectSymbolUtils ./symbolComplexity ../support/FastSymbolUpdates ../../webgl-engine/lib/lodRendering/LodRenderer ../../webgl-engine/lib/lodRendering/LodResources ../../webgl-engine/materials/DefaultMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          x = function (N) {
            function G(O, R, S, Q) { O = N.call(this, O, R, S, Q) || this; O._resources = null; O._optionalFields = []; O._instanceIndexToGraphicUid = new Map; O.hasLoadedPBRTextures = !1; O.ensureDrapedStatus(!1); O.hasLoadedPBRTextures = S.physicalBasedRenderingEnabled; return O } w._inheritsLoose(G, N); var I = G.prototype; I.getCachedSize = function () { const [O, R, S] = q.isSome(this._resources) ? this._resources.symbolSize : [1, 1, 1]; return { width: O, depth: R, height: S } }; I.doLoad =
              function () {
                var O = w._asyncToGenerator(function* (R) { if (!this._drivenProperties.size && k.validateSymbolLayerSize(this.symbolLayer)) throw Error(); const S = this.symbolLayer; this._resources = this.isPrimitive ? yield this._createResourcesForPrimitive(S.resource ? S.resource.primitive : f.defaultPrimitive, R) : yield this._createResourcesForUrl(S.resource.href, R); this.layerOpacityChanged(); this.slicePlaneEnabledChanged(); this.physicalBasedRenderingChanged(); this.complexity = this.computeComplexity() }); return function (R) {
                  return O.apply(this,
                    arguments)
                }
              }(); I.setMaterialTransparencyParams = function (O, R = q.get(this.symbolLayer, "material", "color")) { R = this._getCombinedOpacity(R); const S = 1 > R || this.needsDrivenTransparentPass; O.transparent = S; O.opacity = R; O.cullFace = S ? 0 : 2; return O }; I._createResourcesForPrimitive = function () {
                var O = w._asyncToGenerator(function* (R, S) {
                  if (!B.isValidPrimitive(R)) throw Error(`Unknown object symbol primitive: ${R}`); var Q = this.symbolLayer; const T = d.create(t.objectSymbolLayerPrimitiveBoundingBox(R)), da = l.fromArray(d.size(T)),
                    Y = l.fromArray(t.objectSymbolLayerSizeWithResourceSize(da, Q)), fa = p.length(Y); var ha = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0, instanced: ["transformation"], ambient: l.ONES, diffuse: l.ONES, slicePlaneEnabled: this._context.slicePlaneEnabled, sliceHighlightDisabled: !0, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: !this.symbolLayer.isPrimitive }; const ka = ha.usePBR; this.setMaterialTransparencyParams(ha); const ea = this.symbol; if ("point-3d" === ea.type && ea.verticalOffset) {
                      const { screenLength: ba,
                        minWorldLength: aa, maxWorldLength: W } = ea.verticalOffset; ha.verticalOffset = { screenLength: u.pt2px(ba), minWorldLength: aa || 0, maxWorldLength: null != W ? W : Infinity }; ha.castShadows = !1
                    } this._context.screenSizePerspectiveEnabled && (ha.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings); this._drivenProperties.color ? ha.externalColor = h.ONES : (Q = q.isSome(Q.material) && Q.material.color, Q = q.isSome(Q) ? c.toUnitRGBA(Q) : h.ONES, ha.externalColor = Q); this._fastUpdates = D.initFastSymbolUpdatesState(this._context.renderer,
                      this._fastVisualVariableConvertOptions(T, Y, da, q.none)); this._fastUpdates.enabled ? (Object.assign(ha, this._fastUpdates.materialParameters), ha.instanced.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (ha.instanced.push("color"), this._optionalFields.push("color")); ha = new J.DefaultMaterial(ha); ha = B.primitiveLodResources(R, ha); if (!ha) throw Error(`Unknown object symbol primitive: ${R}`); R = H.materialsFromLodResources(ha).map(ba => ({ opacity: 1, transparent: ba.parameters.transparent }));
                  Q = yield this._createStageResources(ha, ka); S = yield this._createLodRenderer(ha, S); return { lodResources: ha, lodRenderer: S, stageResources: Q, symbolSize: Y, extentPadding: fa, isEsriSymbolResource: !1, isWosr: !1, originalMaterialParameters: R, physicalBasedRenderingEnabled: ka, resourceBoundingBox: T, resourceSize: da, dispose: q.none, pivotOffset: q.none }
                }); return function (R, S) { return O.apply(this, arguments) }
              }(); I._createResourcesForUrl = function () {
                var O = w._asyncToGenerator(function* (R, S) {
                  var Q = ["transformation"], T = {
                    materialParamsMixin: {
                      instanced: Q,
                      slicePlaneEnabled: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows
                    }, streamDataRequester: this._context.streamDataRequester, cache: this._context.sharedResources.objectResourceCache
                  }; this._fastUpdates = D.initFastSymbolUpdatesState(this._context.renderer, this._fastVisualVariableConvertOptions(q.none, q.none, q.none, q.none)); this._fastUpdates.enabled ? (Object.assign(T.materialParamsMixin, this._fastUpdates.materialParameters), Q.push("featureAttribute"), this._optionalFields.push("featureAttribute")) :
                    this._hasPerInstanceColor() && (Q.push("color"), this._optionalFields.push("color")); Q = this.symbol; if ("point-3d" === Q.type && Q.verticalOffset) { const { screenLength: la, minWorldLength: ma, maxWorldLength: ra } = Q.verticalOffset; T.materialParamsMixin.verticalOffset = { screenLength: u.pt2px(la), minWorldLength: ma || 0, maxWorldLength: null != ra ? ra : Infinity }; T.materialParamsMixin.castShadows = !1 } T.signal = S; T.usePBR = this._context.physicalBasedRenderingEnabled; Q = T.usePBR; var da = yield A.fetch(R, T); R = da.isEsriSymbolResource; T =
                      da.isWosr; const Y = da.remove, fa = r.makeLodResources(da.lods); r.fillEstimatedMinScreenSpaceRadius(fa); fa.levels.sort((la, ma) => la.minScreenSpaceRadius - ma.minScreenSpaceRadius); fa.levels[0].minScreenSpaceRadius = Math.min(2, fa.levels[0].minScreenSpaceRadius); const ha = this._context, ka = this._getExternalColorParameters(this.symbolLayer.material); var ea = q.get(this.symbolLayer, "material", "color"); const ba = this._getCombinedOpacity(ea, { hasIntrinsicColor: !0 }), aa = this.needsDrivenTransparentPass; var W = H.materialsFromLodResources(fa);
                  ea = H.materialsFromLodResources(fa).map(la => ({ opacity: la.parameters.opacity || 1, transparent: la.parameters.transparent })); W.forEach(la => { const ma = la.parameters; la.setParameters(ka); const ra = ma.opacity * ba; la.setParameters({ opacity: ra, transparent: 1 > ra || aa || ma.transparent }); ha.screenSizePerspectiveEnabled && la.setParameters({ screenSizePerspective: ha.sharedResources.screenSizePerspectiveSettings }) }); da = da.referenceBoundingBox; const U = l.fromArray(d.size(da)), X = l.fromArray(fa.levels[0].pivotOffset), Z = l.fromArray(t.objectSymbolLayerSizeWithResourceSize(U,
                    this.symbolLayer)), ia = p.length(Z); D.updateFastSymbolUpdatesState(this._fastUpdates, this._context.renderer, this._fastVisualVariableConvertOptions(da, Z, U, X)) && W.forEach(la => la.setParameters(this._fastUpdates.materialParameters)); W = yield this._createStageResources(fa, Q); S = yield this._createLodRenderer(fa, S); return {
                      lodResources: fa, lodRenderer: S, stageResources: W, symbolSize: Z, extentPadding: ia, isEsriSymbolResource: R, isWosr: T, originalMaterialParameters: ea, physicalBasedRenderingEnabled: Q, resourceBoundingBox: da,
                      resourceSize: U, dispose: Y, pivotOffset: X
                    }
                }); return function (R, S) { return O.apply(this, arguments) }
              }(); I._createStageResources = function () {
                var O = w._asyncToGenerator(function* (R, S) { const Q = this._context.stage, T = H.materialsFromLodResources(R); S !== this._context.physicalBasedRenderingEnabled && this.physicalBasedRenderingChanged(); Q.addMany(T); S = H.texturesFromLodResources(R); Q.addMany(S); yield Q.load(S); R = H.geometriesFromLodResources(R); Q.addMany(R); return { materials: T, textures: S, geometries: R } }); return function (R,
                  S) { return O.apply(this, arguments) }
              }(); I._createLodRenderer = function () {
                var O = w._asyncToGenerator(function* (R, S) {
                  const Q = this._context.stage; R = new E.LodRenderer(R, this._optionalFields, { layerUid: this._context.layer.uid, graphicUid: T => this._instanceIndexToGraphicUid.get(T), notifyGraphicGeometryChanged: T => this._context.notifyGraphicGeometryChanged(this._instanceIndexToGraphicUid.get(T)), notifyGraphicVisibilityChanged: T => this._context.notifyGraphicVisibilityChanged(this._instanceIndexToGraphicUid.get(T)) },
                    this._fastUpdates.enabled ? { applyTransform: (T, da, Y) => { T.getFeatureAttribute(da, P); y.copy(Y, D.evaluateModelTransform(this._fastUpdates.materialParameters, P, Y)) }, scaleFactor: (T, da, Y) => { da.getFeatureAttribute(Y, P); return D.evaluateModelTransformScale(T, this._fastUpdates.materialParameters, P) } } : null); R.slicePlaneEnabled = this._context.slicePlaneEnabled; yield Q.addRenderPlugin(R.slots, R, S); return R
                }); return function (R, S) { return O.apply(this, arguments) }
              }(); I._getExternalColorParameters = function (O) {
                const R =
                  {}; this._drivenProperties.color ? R.externalColor = h.ONES : q.isSome(O) && q.isSome(O.color) ? R.externalColor = c.toUnitRGBA(O.color) : (R.externalColor = h.ONES, R.colorMixMode = "ignore"); return R
              }; I.destroy = function () {
                N.prototype.destroy.call(this); if (q.isSome(this._resources)) {
                  const O = this._context.stage; O.removeRenderPlugin(this._resources.lodRenderer); const R = this._resources.stageResources; O.removeMany(R.materials); O.removeMany(R.textures); O.removeMany(R.geometries); q.isSome(this._resources.dispose) && this._resources.dispose();
                  this._resources = null
                }
              }; I.createGraphics3DGraphic = function (O) { const R = O.graphic; if (!this._validateGeometry(R.geometry)) return null; const S = z.placePointOnGeometry(R.geometry); if (q.isNone(S)) return this.logger.warn(`unsupported geometry type for icon symbol: ${R.geometry.type}`), null; const Q = this.setGraphicElevationContext(R, new e.ElevationContext); return this._createAs3DShape(R, S, O.renderingInfo, Q, R.uid) }; I.notifyDestroyGraphicLayer = function (O) { this._instanceIndexToGraphicUid.delete(O.instanceIndex) };
            I.graphicLayerToGraphicId = function () { return 0 }; I.layerOpacityChanged = function () {
              if (q.isNone(this._resources)) return !0; const O = this._drivenProperties.opacity, R = !this.isPrimitive, S = this._resources.stageResources.materials, Q = this._resources.originalMaterialParameters; for (let Y = 0; Y < S.length; Y++) {
                const fa = S[Y]; var T = q.get(this.symbolLayer, "material", "color"), da = Q[Y]; T = this._getCombinedOpacity(T, { hasIntrinsicColor: R }) * da.opacity; da = 1 > T || O || da.transparent; fa.setParameters({ opacity: T, transparent: da }); this.isPrimitive &&
                  fa.setParameters({ cullFace: da ? 0 : 2 })
              } return !0
            }; I.layerElevationInfoChanged = function (O, R) { return this.updateGraphics3DGraphicElevationInfo(O, R, m.needsElevationUpdates3D) }; I.slicePlaneEnabledChanged = function () { if (q.isNone(this._resources)) return !0; this._resources.lodRenderer.slicePlaneEnabled = this._context.slicePlaneEnabled; for (const O of this._resources.stageResources.materials) O.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); return !0 }; I.physicalBasedRenderingChanged = function () {
              if (q.isNone(this._resources)) return !0;
              const { stageResources: O, isWosr: R } = this._resources; for (const S of O.materials) this.isPrimitive ? S.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0 }) : R || S.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !1 }); return !1 === this.hasLoadedPBRTextures && !0 === this._context.physicalBasedRenderingEnabled ? (this.hasLoadedPBRTextures = !0, !1) : !0
            }; I.pixelRatioChanged = function () { return !0 }; I.applyRendererDiff = function (O, R) {
              if (q.isNone(this._resources)) return 0;
              const { stageResources: { materials: S }, lodRenderer: Q, resourceBoundingBox: T, symbolSize: da, resourceSize: Y, pivotOffset: fa } = this._resources; for (const ha in O.diff) switch (ha) { case "visualVariables": if (D.updateFastSymbolUpdatesState(this._fastUpdates, R, this._fastVisualVariableConvertOptions(T, da, Y, fa))) { for (const ka of S) ka.setParameters(this._fastUpdates.materialParameters); Q.notifyShaderTransformationChanged() } else return 0; break; default: return 0 }return 2
            }; I.computeComplexity = function () {
              if (q.isNone(this._resources)) return N.prototype.computeComplexity.call(this);
              const O = H.geometriesFromLodLevelResources(this._resources.lodResources.levels[0]).reduce((S, Q) => S + Q.indices.get("position").length, 0) / 3, R = C.defaultSymbolLayerMemoryComplexity(this.symbol, this.symbolLayer); return { primitivesPerFeature: O, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: !1, memory: R }
            }; I.hasLodRenderer = function () { return q.isSome(this._resources) }; I._createAs3DShape = function (O, R, S, Q, T) {
              if (!this.hasLodRenderer() || q.isNone(this._resources)) return null; O = this.getFastUpdateAttrValues(O);
              const da = !this._fastUpdates.enabled && this._hasPerInstanceColor() ? k.mixinColorAndOpacity(S.color, S.opacity) : null; var Y = this._context.clippingExtent; b.projectPointToVector(R, M, this._context.elevationProvider.spatialReference); if (q.isSome(Y) && !d.containsPoint(Y, M)) return null; Y = this._requiresTerrainElevation(Q); const fa = this._computeGlobalTransform(R, Q, K, L); S = this._computeLocalTransform(this._resources, this.symbolLayer, S, F); const ha = this._resources.lodRenderer.instanceData, ka = ha.addInstance(); this._instanceIndexToGraphicUid.set(ka,
                T); ha.setLocalTransform(ka, S, !1); ha.setGlobalTransform(ka, fa); O && ha.setFeatureAttribute(ka, O); da && ha.setColor(ka, da); T = new g(this, ka, v.perLodInstanceElevationAligner, Q); Y && (T.alignedSampledElevation = L.sampledElevation); T.needsElevationUpdates = m.needsElevationUpdates3D(Q.mode); z.extendPointGraphicElevationContext(T, R, this._context.elevationProvider); return T
            }; I._computeGlobalTransform = function (O, R, S, Q) {
              m.evaluateElevationInfoAtPoint(O, this._context.elevationProvider, R, this._context.renderCoordsHelper,
                Q); M[0] = O.x; M[1] = O.y; M[2] = Q.z; b.computeTranslationToOriginAndRotation(O.spatialReference, M, S, this._context.renderCoordsHelper.spatialReference); return S
            }; I._computeLocalTransform = function (O, R, S, Q) { y.identity(Q); this._applyObjectRotation(S, !1, Q); this._applyObjectRotation(R, !0, Q); this._applyObjectScale(O, S, Q); this._applyAnchor(O, R, Q); return Q }; I._applyObjectScale = function (O, R, S) {
              this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation || (O = k.computeObjectScale(this._drivenProperties.size &&
                R.size ? R.size : O.symbolSize, O.symbolSize, O.resourceSize, this._context.renderCoordsHelper.unitInMeters), 1 === O[0] && 1 === O[1] && 1 === O[2] || y.scale(S, S, O))
            }; I.prepareSymbolLayerPatch = function (O) { if ("partial" === O.diff.type) { var R = O.diff.diff; this._preparePatchTransform(O, R); this._preparePatchColor(O, R) } }; I.updateGeometry = function (O, R) {
              if (q.isNone(this._resources)) return !0; const S = R && z.placePointOnGeometry(R); if (q.isNone(S)) return !1; R = this.getGeometryElevationMode(R); if (O.elevationContext.mode !== R) return !1;
              this._computeGlobalTransform(S, O.elevationContext, K, L); this._requiresTerrainElevation(O.elevationContext) && (O.alignedSampledElevation = L.sampledElevation); this._resources.lodRenderer.instanceData.setGlobalTransform(O.instanceIndex, K, !0); z.extendPointGraphicElevationContext(O, S, this._context.elevationProvider); return !0
            }; I._preparePatchTransform = function (O, R) {
              if ((R.heading || R.tilt || R.roll || R.width || R.height || R.depth || R.anchor || R.anchorPosition) && !q.isNone(this._resources)) {
                var S = (aa, W, U) => q.unwrapOr(null !=
                  aa && "complete" === aa.type ? aa.newValue : W, U), Q = S(R.heading, this.symbolLayer.heading, 0), T = S(R.tilt, this.symbolLayer.tilt, 0), da = S(R.roll, this.symbolLayer.roll, 0), Y = S(R.width, this.symbolLayer.width, void 0), fa = S(R.height, this.symbolLayer.height, void 0), ha = S(R.depth, this.symbolLayer.depth, void 0), ka = S(R.anchor, this.symbolLayer.anchor, void 0); S = S(R.anchorPosition, this.symbolLayer.anchorPosition, void 0); delete R.heading; delete R.tilt; delete R.roll; delete R.width; delete R.height; delete R.depth; delete R.anchor;
                delete R.anchorPosition; var ea = { heading: Q, tilt: T, roll: da, anchor: ka, anchorPosition: S }, ba = this._resources; 1 === this.loadStatus && O.symbolLayerStatePatches.push(() => { ba.symbolSize = l.fromArray(t.objectSymbolLayerSizeWithResourceSize(ba.resourceSize, { width: Y, height: fa, depth: ha, isPrimitive: this.symbolLayer.isPrimitive })) }); O.graphics3DGraphicPatches.push((aa, W) => { W = this._computeLocalTransform(ba, ea, W, F); ba.lodRenderer.instanceData.setLocalTransform(aa.instanceIndex, W, !0) })
              }
            }; I._preparePatchColor = function (O,
              R) { if (R.material && "partial" === R.material.type && (R = R.material.diff, R.color && "complete" === R.color.type && null != R.color.newValue && null != R.color.oldValue)) { var S = R.color.newValue, Q = q.isSome(S) ? c.toUnitRGBA(S) : h.ONES; delete R.color; var T = this._resources; q.isNone(T) || O.graphics3DGraphicPatches.push(da => { this._hasPerInstanceColor() ? (T.lodRenderer.instanceData.setColor(da.instanceIndex, Q), da = this.setMaterialTransparencyParams({}, S)) : da = this.setMaterialTransparencyParams({ externalColor: Q }, S); for (const Y of T.stageResources.materials) Y.setParameters(da) }) } };
            I._requiresTerrainElevation = function (O) { return "absolute-height" !== O.mode }; I._applyObjectRotation = function (O, R, S) { if (!(this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation && R)) return k.computeObjectRotation(O.heading, O.tilt, O.roll, S) }; I._computeAnchor = function (O, R, S) {
              const Q = l.create(); switch (S.anchor) {
                case "center": p.copy(Q, d.center(O)); p.negate(Q, Q); break; case "top": R = d.center(O); p.set(Q, -R[0], -R[1], -O[5]); break; case "bottom": R = d.center(O); p.set(Q, -R[0], -R[1], -O[2]); break; case "relative": R =
                  d.center(O); O = d.size(O); S = (S = S.anchorPosition) ? l.fromValues(S.x, S.y, S.z) : l.ZEROS; p.multiply(Q, O, S); p.add(Q, Q, R); p.negate(Q, Q); break; default: q.isSome(R) ? p.negate(Q, R) : p.copy(Q, l.ZEROS)
              }return Q
            }; I._applyAnchor = function (O, R, S) { this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation || (O = this._computeAnchor(O.resourceBoundingBox, O.pivotOffset, R)) && y.translate(S, S, O) }; I._hasPerInstanceColor = function () { return this._drivenProperties.color || this._drivenProperties.opacity }; I._fastVisualVariableConvertOptions =
              function (O, R, S, Q) { const T = q.isSome(O) ? l.fromArray(d.size(O)) : l.ONES; O = q.isSome(O) ? this._computeAnchor(O, Q, this.symbolLayer) : l.ZEROS; Q = this._context.renderCoordsHelper.unitInMeters; S = k.computeObjectScale(q.isSome(R) ? R : void 0, R, S, Q); const da = l.fromValues(this.symbolLayer.tilt || 0, this.symbolLayer.roll || 0, this.symbolLayer.heading || 0); return { modelSize: T, symbolSize: q.isSome(R) ? R : l.ONES, unitInMeters: Q, transformation: { anchor: O, scale: S, rotation: da } } }; w._createClass(G, [{
                key: "extentPadding", get: function () {
                  return q.isSome(this._resources) ?
                    this._resources.extentPadding : 0
                }
              }, { key: "isPrimitive", get: function () { return !(this.symbolLayer.resource && this.symbolLayer.resource.href) } }, { key: "lodRenderer", get: function () { return q.get(this._resources, "lodRenderer") } }]); return G
          }(x.Graphics3DSymbolLayer); const M = l.create(), F = n.create(), K = n.create(), P = h.create(), L = new m.SampleElevationInfo; a.Graphics3DObjectSymbolLayer = x; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DLodInstanceGraphicLayer": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingBox ./featureExpressionInfoUtils ./graphicUtils ../../webgl-engine/lib/Object3DStateID".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          let h = function () {
            function m(g, x, k, r) { this.graphics3DSymbolLayer = g; this.instanceIndex = x; this.elevationAligner = k; this.elevationContext = r; this.type = "lod-instance"; this._highlights = new Set; this.alignedSampledElevation = 0; this.needsElevationUpdates = this.isElevationSource = !1 } var e = m.prototype; e.initialize = function () { }; e.setVisibility = function (g) { const x = this.lodRenderer.instanceData; g !== x.getVisible(this.instanceIndex) && x.setVisible(this.instanceIndex, g) }; e.destroy = function () {
            null !=
              this.instanceIndex && (this.lodRenderer.instanceData.removeInstance(this.instanceIndex), this.graphics3DSymbolLayer.notifyDestroyGraphicLayer(this))
            }; e.alignWithElevation = function (g, x, k) { this.elevationAligner && (n.setContextFeature(this.elevationContext.featureExpressionInfoContext, k), g = this.elevationAligner(this, this.elevationContext, g, x), w.isSome(g) && (this.alignedSampledElevation = g)) }; e.getCenterObjectSpace = function (g = u.create()) {
              this.lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex,
                v); return q.transformMat4(g, this.lodRenderer.baseBoundingSphere.center, v)
            }; e.getBoundingBoxObjectSpace = function (g = y.create()) { this.lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, v); const x = this.lodRenderer.baseBoundingBox; y.empty(g); for (let k = 0; 8 > k; ++k)q.set(d, 0 === (k & 1) ? x[0] : x[3], 0 === (k & 2) ? x[1] : x[4], 0 === (k & 4) ? x[2] : x[5]), q.transformMat4(d, d, v), y.expandWithVec3(g, d); return g }; e.computeAttachmentOrigin = function (g) {
              this.lodRenderer.instanceData.getGlobalTransform(this.instanceIndex,
                v); g.render.origin[0] += v[12]; g.render.origin[1] += v[13]; g.render.origin[2] += v[14]; g.render.num++
            }; e.getProjectedBoundingBox = function () {
              var g = a._asyncToGenerator(function* (x, k, r, A, z) {
                z = this.getBoundingBoxObjectSpace(z); var B = t; const C = y.isPoint(z) ? 1 : B.length; this.lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, v); for (var D = 0; D < C; D++) { const E = B[D]; d[0] = z[E[0]]; d[1] = z[E[1]]; d[2] = z[E[2]]; q.transformMat4(d, d, v); b[3 * D] = d[0]; b[3 * D + 1] = d[1]; b[3 * D + 2] = d[2] } if (!x(b, 0, C)) return null; y.empty(z); x =
                  null; this.calculateRelativeScreenBounds && (x = this.calculateRelativeScreenBounds()); for (B = 0; B < 3 * C; B += 3) { for (D = 0; 3 > D; D++)z[D] = Math.min(z[D], b[B + D]), z[D + 3] = Math.max(z[D + 3], b[B + D]); x && r.push({ location: b.slice(B, B + 3), screenSpaceBoundingRect: x }) } if (k && (y.center(z, f), "absolute-height" !== this.elevationContext.mode)) { let E; r = p.demResolutionForBoundingBox(z, k); try { E = yield k.service.queryElevation(f[0], f[1], A, r, "ground") } catch (H) { } w.isSome(E) && y.offset(z, 0, 0, -this.alignedSampledElevation + E) } return z
              }); return function (x,
                k, r, A, z) { return g.apply(this, arguments) }
            }(); e.addObjectState = function (g, x) { 0 === g && (g = new l.Object3DStateID(g), this.addHighlightId(g), x.addExternal(k => { this.removeHighlightId(k) }, g)) }; e.removeObjectState = function (g) { this._highlights.forEach(x => g.remove(x)) }; e.addHighlightId = function (g) { this._highlights.add(g); this.lodRenderer.instanceData.setHighlight(this.instanceIndex, !0) }; e.removeHighlightId = function (g) { this._highlights.delete(g); this.lodRenderer.instanceData.setHighlight(this.instanceIndex, 0 < this._highlights.size) };
            a._createClass(m, [{ key: "lodRenderer", get: function () { return this.graphics3DSymbolLayer.lodRenderer } }]); return m
          }(); const b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], d = u.create(), f = u.create(), t = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]], v = c.create(); return h
        })
    }, "esri/views/3d/layers/graphics/lodResourceUtils": function () {
      define(["exports", "../../webgl-engine/lib/lodRendering/LodResources"], function (a, w) {
        function c(u) {
          const y = []; u.stageResources.geometries.forEach((n, p) => { y.push({ material: u.stageResources.materials[p], geometry: n, textures: u.stageResources.textures }) }); return { components: y, minScreenSpaceRadius: u.lodThreshold, pivotOffset: u.pivotOffset }
        } function q(u, y = .05) { u = w.computeFaceCount(u); return Math.sqrt(u / (y * Math.PI)) } a.estimateMinScreenSpaceRadius = q; a.fillEstimatedMinScreenSpaceRadius = function (u) { u.levels.forEach(y => { y.minScreenSpaceRadius || (y.minScreenSpaceRadius = q(y)) }) }; a.makeLodLevelResources = c; a.makeLodResources = function (u) { return { levels: u.map(y => c(y)) } };
        Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/objectResourceUtils": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/devEnvironmentUtils ../../../../core/maybe ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/buffer/BufferView ../../../../chunks/vec32 ../../../../chunks/vec42 ../../../../geometry/support/buffer/utils ../../glTF/DefaultLoadingContext ../../glTF/loader ../../glTF/internal/indexUtils ./wosrLoader ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/Texture ../../webgl-engine/materials/DefaultMaterial ../../webgl-engine/materials/DefaultMaterial_COLOR_GAMMA ../../../../chunks/vec22 ../../../../chunks/vec43 ../../../../chunks/vec33".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D) {
          function E() {
            E = w._asyncToGenerator(function* (M, F) {
              var K = H(c.adjustStaticAGOUrl(M)); if ("wosr" === K.fileType) return M = yield F.cache ? F.cache.loadWOSR(K.url, F) : x.load(K.url, F), K = x.processLoadResult(M, F), { lods: [K], referenceBoundingBox: K.boundingBox, isEsriSymbolResource: !1, isWosr: !0, remove: M.remove }; M = yield F.cache ? F.cache.loadGLTF(K.url, F, F.usePBR) : e.load(new m.DefaultLoadingContext(F.streamDataRequester), K.url, F, F.usePBR); var P = q.get(M.model.meta,
                "ESRI_proxyEllipsoid"); if (M.meta.isEsriSymbolResource && q.isSome(P) && -1 !== M.meta.uri.indexOf("/RealisticTrees/")) a: for (var L = 0; L < M.model.lods.length; ++L) {
                  var N = M.model.lods[L]; M.customMeta.esriTreeRendering = !0; for (var G of N.parts) {
                    N = G.attributes.normal; if (q.isNone(N)) break a; const O = G.attributes.position, R = O.count, S = h.create(), Q = h.create(), T = h.create(), da = v.createBuffer(d.BufferViewVec4u8, R), Y = v.createBuffer(d.BufferViewVec3f, R), fa = n.invert(p.create(), G.transform); for (let ha = 0; ha < R; ha++) {
                      O.getVec(ha,
                        Q); N.getVec(ha, S); l.transformMat4(Q, Q, G.transform); l.subtract(T, Q, P.center); l.divide(T, T, P.radius); const ka = T[2]; var I = l.length(T); I = Math.min(.45 + .55 * I * I, 1); l.divide(T, T, P.radius); l.transformMat4(T, T, fa); l.normalize(T, T); L + 1 !== M.model.lods.length && 1 < M.model.lods.length && (-1 < ka ? l.lerp(T, T, S, .2) : l.lerp(T, T, S, Math.min(-4 * ka - 3.8, 1))); Y.setVec(ha, T); da.set(ha, 0, 255 * I); da.set(ha, 1, 255 * I); da.set(ha, 2, 255 * I); da.set(ha, 3, 255)
                    } G.attributes.normal = Y; G.attributes.color = da
                  }
                } G = M.meta.isEsriSymbolResource ? {
                  usePBR: F.usePBR,
                  isSchematic: !1, treeRendering: M.customMeta.esriTreeRendering, mrrFactors: [0, 1, .2]
                } : { usePBR: F.usePBR, isSchematic: !1, mrrFactors: [0, 1, .5] }; F = { ...F.materialParamsMixin, treeRendering: M.customMeta.esriTreeRendering }; if (null != K.specifiedLodIndex) return P = J(M, G, F, K.specifiedLodIndex), L = P[0].boundingBox, 0 !== K.specifiedLodIndex && (L = J(M, G, F, 0)[0].boundingBox), { lods: P, referenceBoundingBox: L, isEsriSymbolResource: M.meta.isEsriSymbolResource, isWosr: !1, remove: M.remove }; K = J(M, G, F); return {
                  lods: K, referenceBoundingBox: K[0].boundingBox,
                  isEsriSymbolResource: M.meta.isEsriSymbolResource, isWosr: !1, remove: M.remove
                }
            }); return E.apply(this, arguments)
          } function H(M) { const F = M.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/); return F ? { fileType: "gltf", url: F[1], specifiedLodIndex: null != F[4] ? Number(F[4]) : null } : M.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: M, specifiedLodIndex: null } : { fileType: "unknown", url: M, specifiedLodIndex: null } } function J(M, F, K, P) {
            const L = M.model, N = y.create(), G = [], I = new Map, O = new Map; L.lods.forEach((R, S) => {
              if (void 0 === P ||
                S === P) {
                  var Q = { name: R.name, stageResources: { textures: [], materials: [], geometries: [] }, lodThreshold: q.isSome(R.lodThreshold) ? R.lodThreshold : null, pivotOffset: [0, 0, 0], numberOfVertices: 0, boundingBox: b.empty() }; G.push(Q); R.parts.forEach(T => {
                    var da = T.material + (T.attributes.normal ? "_normal" : "") + (T.attributes.color ? "_color" : "") + (T.attributes.texCoord0 ? "_texCoord0" : "") + (T.attributes.tangent ? "_tangent" : ""); const Y = L.materials.get(T.material), fa = q.isSome(T.attributes.texCoord0); var ha = q.isSome(T.attributes.normal);
                    a: { switch (Y.alphaMode) { case "BLEND": var ka = 0; break a; case "MASK": ka = 2; break a; case "OPAQUE": case null: case void 0: ka = 1; break a }ka = void 0 } if (!I.has(da)) {
                      if (fa) {
                        if (q.isSome(Y.textureColor) && !O.has(Y.textureColor)) { var ea = L.textures.get(Y.textureColor); O.set(Y.textureColor, new r.Texture(ea.data, { ...ea.parameters, preMultiplyAlpha: 1 !== ka })) } q.isSome(Y.textureNormal) && !O.has(Y.textureNormal) && (ea = L.textures.get(Y.textureNormal), O.set(Y.textureNormal, new r.Texture(ea.data, ea.parameters))); q.isSome(Y.textureOcclusion) &&
                          !O.has(Y.textureOcclusion) && (ea = L.textures.get(Y.textureOcclusion), O.set(Y.textureOcclusion, new r.Texture(ea.data, ea.parameters))); q.isSome(Y.textureEmissive) && !O.has(Y.textureEmissive) && (ea = L.textures.get(Y.textureEmissive), O.set(Y.textureEmissive, new r.Texture(ea.data, ea.parameters))); q.isSome(Y.textureMetallicRoughness) && !O.has(Y.textureMetallicRoughness) && (ea = L.textures.get(Y.textureMetallicRoughness), O.set(Y.textureMetallicRoughness, new r.Texture(ea.data, ea.parameters)))
                      } ea = Y.color[0] ** (1 / z.COLOR_GAMMA);
                      var ba = Y.color[1] ** (1 / z.COLOR_GAMMA), aa = Y.color[2] ** (1 / z.COLOR_GAMMA), W = Y.emissiveFactor[0] ** (1 / z.COLOR_GAMMA); const U = Y.emissiveFactor[1] ** (1 / z.COLOR_GAMMA), X = Y.emissiveFactor[2] ** (1 / z.COLOR_GAMMA), Z = q.isSome(Y.textureColor) && fa ? O.get(Y.textureColor) : null; I.set(da, new A.DefaultMaterial({
                        ...F, transparent: 0 === ka, textureAlphaMode: ka, textureAlphaCutoff: Y.alphaCutoff, diffuse: [ea, ba, aa], ambient: [ea, ba, aa], opacity: Y.opacity, doubleSided: Y.doubleSided, doubleSidedType: "winding-order", cullFace: Y.doubleSided ?
                          0 : 2, vertexColors: !!T.attributes.color, vertexTangents: !!T.attributes.tangent, normals: ha ? "default" : "screenDerivative", castShadows: !0, receiveSSAO: !0, textureId: q.isSome(Z) ? Z.id : void 0, colorMixMode: Y.colorMixMode, normalTextureId: q.isSome(Y.textureNormal) && fa ? O.get(Y.textureNormal).id : void 0, textureAlphaPremultiplied: q.isSome(Z) && !!Z.params.preMultiplyAlpha, occlusionTextureId: q.isSome(Y.textureOcclusion) && fa ? O.get(Y.textureOcclusion).id : void 0, emissiveTextureId: q.isSome(Y.textureEmissive) && fa ? O.get(Y.textureEmissive).id :
                            void 0, metallicRoughnessTextureId: q.isSome(Y.textureMetallicRoughness) && fa ? O.get(Y.textureMetallicRoughness).id : void 0, emissiveFactor: [W, U, X], mrrFactors: [Y.metallicFactor, Y.roughnessFactor, F.mrrFactors[2]], isSchematic: !1, ...K
                      }))
                    } a: { ha = T.indices || T.attributes.position.count; switch (T.primitiveType) { case 4: ha = g.trianglesToTriangles(ha); break a; case 5: ha = g.triangleStripToTriangles(ha); break a; case 6: ha = g.triangleFanToTriangles(ha); break a }ha = void 0 } ka = ha; ha = T.attributes.position.count; ea = v.createBuffer(d.BufferViewVec3f,
                      ha); f.transformMat4(ea, T.attributes.position, T.transform); ea = [["position", { data: ea.typedBuffer, size: ea.elementCount, exclusive: !0 }]]; ba = [["position", ka]]; q.isSome(T.attributes.normal) && (aa = v.createBuffer(d.BufferViewVec3f, ha), u.normalFromMat4(N, T.transform), f.transformMat3(aa, T.attributes.normal, N), ea.push(["normal", { data: aa.typedBuffer, size: aa.elementCount, exclusive: !0 }]), ba.push(["normal", ka])); q.isSome(T.attributes.tangent) && (aa = v.createBuffer(d.BufferViewVec4f, ha), u.normalFromMat4(N, T.transform),
                        t.transformMat3(aa, T.attributes.tangent, N), ea.push(["tangent", { data: aa.typedBuffer, size: aa.elementCount, exclusive: !0 }]), ba.push(["tangent", ka])); q.isSome(T.attributes.texCoord0) && (aa = v.createBuffer(d.BufferViewVec2f, ha), B.normalizeIntegerBuffer(aa, T.attributes.texCoord0), ea.push(["uv0", { data: aa.typedBuffer, size: aa.elementCount, exclusive: !0 }]), ba.push(["uv0", ka])); q.isSome(T.attributes.color) && (aa = v.createBuffer(d.BufferViewVec4u8, ha), 4 === T.attributes.color.elementCount ? T.attributes.color instanceof
                          d.BufferViewVec4f ? t.scale(aa, T.attributes.color, 255) : T.attributes.color instanceof d.BufferViewVec4u8 ? C.copy(aa, T.attributes.color) : T.attributes.color instanceof d.BufferViewVec4u16 && t.scale(aa, T.attributes.color, 1 / 256) : (C.fill(aa, 255, 255, 255, 255), W = new d.BufferViewVec3u8(aa.buffer, 0, 4), T.attributes.color instanceof d.BufferViewVec3f ? f.scale(W, T.attributes.color, 255) : T.attributes.color instanceof d.BufferViewVec3u8 ? D.copy(W, T.attributes.color) : T.attributes.color instanceof d.BufferViewVec3u16 && f.scale(W,
                            T.attributes.color, 1 / 256)), ea.push(["color", { data: aa.typedBuffer, size: aa.elementCount, exclusive: !0 }]), ba.push(["color", ka])); T = new k.Geometry(ea, ba); Q.stageResources.geometries.push(T); Q.stageResources.materials.push(I.get(da)); fa && (q.isSome(Y.textureColor) && Q.stageResources.textures.push(O.get(Y.textureColor)), q.isSome(Y.textureNormal) && Q.stageResources.textures.push(O.get(Y.textureNormal)), q.isSome(Y.textureOcclusion) && Q.stageResources.textures.push(O.get(Y.textureOcclusion)), q.isSome(Y.textureEmissive) &&
                              Q.stageResources.textures.push(O.get(Y.textureEmissive)), q.isSome(Y.textureMetallicRoughness) && Q.stageResources.textures.push(O.get(Y.textureMetallicRoughness))); Q.numberOfVertices += ha; da = T.boundingInfo; q.isSome(da) && (b.expandWithVec3(Q.boundingBox, da.getBBMin()), b.expandWithVec3(Q.boundingBox, da.getBBMax()))
                  })
              }
            }); return G
          } a.fetch = function (M, F) { return E.apply(this, arguments) }; a.gltfToEngineResources = J; a.parseUrl = H; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/devEnvironmentUtils": function () {
      define(["exports"],
        function (a) {
          const w = /^devext.arcgis.com$/, c = /^qaext.arcgis.com$/, q = /^[\w-]*\.mapsdevext.arcgis.com$/, u = /^[\w-]*\.mapsqa.arcgis.com$/, y = [/^([\w-]*\.)?[\w-]*\.zrh-dev-local.esri.com$/, w, c, /^jsapps.esri.com$/, q, u]; a.adjustStaticAGOUrl = function (n, p) { return n ? (p = p || globalThis.location.hostname) ? null != p.match(w) || null != p.match(q) ? n.replace("static.arcgis.com", "staticdev.arcgis.com") : null != p.match(c) || null != p.match(u) ? n.replace("static.arcgis.com", "staticqa.arcgis.com") : n : n : n }; a.isDevEnvironment = function (n) {
            n =
            n || globalThis.location.hostname; return y.some(p => { var l; return null != (null == (l = n) ? void 0 : l.match(p)) })
          }; a.isTelemetryDevEnvironment = function (n) { n = n || globalThis.location.hostname; return [/^zrh-.+?\.esri\.com$/].concat(y).some(p => { var l; return null != (null == (l = n) ? void 0 : l.match(p)) }) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/vec42": function () {
      define(["exports", "../geometry/support/buffer/math/common"], function (a, w) {
        function c(p, l, h) {
          if (p.count !== l.count) w.logger.error("source and destination buffers need to have the same number of elements");
          else { var b = p.count, d = h[0], f = h[1], t = h[2], v = h[3], m = h[4], e = h[5], g = h[6], x = h[7], k = h[8], r = h[9], A = h[10], z = h[11], B = h[12], C = h[13], D = h[14]; h = h[15]; var E = p.typedBuffer; p = p.typedBufferStride; var H = l.typedBuffer; l = l.typedBufferStride; for (let M = 0; M < b; M++) { const F = M * p; var J = M * l; const K = H[J], P = H[J + 1], L = H[J + 2]; J = H[J + 3]; E[F] = d * K + m * P + k * L + B * J; E[F + 1] = f * K + e * P + r * L + C * J; E[F + 2] = t * K + g * P + A * L + D * J; E[F + 3] = v * K + x * P + z * L + h * J } }
        } function q(p, l, h) {
          if (p.count !== l.count) w.logger.error("source and destination buffers need to have the same number of elements");
          else { var b = p.count, d = h[0], f = h[1], t = h[2], v = h[3], m = h[4], e = h[5], g = h[6], x = h[7]; h = h[8]; var k = p.typedBuffer; p = p.typedBufferStride; var r = l.typedBuffer; l = l.typedBufferStride; for (let z = 0; z < b; z++) { const B = z * p; var A = z * l; const C = r[A], D = r[A + 1], E = r[A + 2]; A = r[A + 3]; k[B] = d * C + v * D + g * E; k[B + 1] = f * C + m * D + x * E; k[B + 2] = t * C + e * D + h * E; k[B + 3] = A } }
        } function u(p, l, h) {
          const b = Math.min(p.count, l.count), d = p.typedBuffer; p = p.typedBufferStride; const f = l.typedBuffer; l = l.typedBufferStride; for (let t = 0; t < b; t++) {
            const v = t * p, m = t * l; d[v] = h * f[m]; d[v +
              1] = h * f[m + 1]; d[v + 2] = h * f[m + 2]; d[v + 3] = h * f[m + 3]
          }
        } function y(p, l, h) { const b = Math.min(p.count, l.count), d = p.typedBuffer; p = p.typedBufferStride; const f = l.typedBuffer; l = l.typedBufferStride; for (let t = 0; t < b; t++) { const v = t * p, m = t * l; d[v] = f[m] >> h; d[v + 1] = f[m + 1] >> h; d[v + 2] = f[m + 2] >> h; d[v + 3] = f[m + 3] >> h } } const n = Object.freeze({ __proto__: null, transformMat4: c, transformMat3: q, scale: u, shiftRight: y }); a.scale = u; a.shiftRight = y; a.transformMat3 = q; a.transformMat4 = c; a.vec4 = n
      })
    }, "esri/geometry/support/buffer/utils": function () {
      define("exports ./types ../../../chunks/mat32 ../../../chunks/mat42 ../../../chunks/scalar ../../../chunks/vec22 ../../../chunks/vec33 ../../../chunks/vec43".split(" "),
        function (a, w, c, q, u, y, n, p) { a.mat3 = c.mat3; a.mat4 = q.mat4; a.scalar = u.scalar; a.vec2 = y.vec2; a.vec3 = n.vec3; a.vec4 = p.vec4; a.createBuffer = function (l, h) { return new l(new ArrayBuffer(h * l.ElementCount * w.elementTypeSize(l.ElementType))) }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/chunks/mat32": function () {
      define(["exports"], function (a) {
        function w(q, u, y) {
          const n = q.typedBuffer; q = q.typedBufferStride; const p = u.typedBuffer, l = u.typedBufferStride; u = y ? y.count : u.count; let h = (y && y.dstIndex ? y.dstIndex : 0) * q;
          y = (y && y.srcIndex ? y.srcIndex : 0) * l; for (let b = 0; b < u; ++b) { for (let d = 0; 9 > d; ++d)n[h + d] = p[y + d]; h += q; y += l }
        } const c = Object.freeze({ __proto__: null, copy: w }); a.copy = w; a.mat3 = c
      })
    }, "esri/chunks/mat42": function () {
      define(["exports"], function (a) {
        function w(q, u, y) { const n = q.typedBuffer; q = q.typedBufferStride; const p = u.typedBuffer, l = u.typedBufferStride; u = y ? y.count : u.count; let h = (y && y.dstIndex ? y.dstIndex : 0) * q; y = (y && y.srcIndex ? y.srcIndex : 0) * l; for (let b = 0; b < u; ++b) { for (let d = 0; 16 > d; ++d)n[h + d] = p[y + d]; h += q; y += l } } const c = Object.freeze({
          __proto__: null,
          copy: w
        }); a.copy = w; a.mat4 = c
      })
    }, "esri/chunks/scalar": function () {
      define(["exports"], function (a) {
        function w(u, y, n) { const p = u.typedBuffer; u = u.typedBufferStride; const l = y.typedBuffer, h = y.typedBufferStride; y = n ? n.count : y.count; let b = (n && n.dstIndex ? n.dstIndex : 0) * u; n = (n && n.srcIndex ? n.srcIndex : 0) * h; for (let d = 0; d < y; ++d)p[b] = l[n], b += u, n += h } function c(u, y) { const n = u.count; y || (y = new u.TypedArrayConstructor(n)); for (let p = 0; p < n; p++)y[p] = u.get(p); return y } const q = Object.freeze({ __proto__: null, copy: w, makeDense: c });
        a.copy = w; a.makeDense = c; a.scalar = q
      })
    }, "esri/chunks/vec22": function () {
      define(["exports", "../geometry/support/buffer/types"], function (a, w) {
        function c(n, p, l) { const h = n.typedBuffer; n = n.typedBufferStride; const b = p.typedBuffer, d = p.typedBufferStride; p = l ? l.count : p.count; let f = (l && l.dstIndex ? l.dstIndex : 0) * n; l = (l && l.srcIndex ? l.srcIndex : 0) * d; for (let t = 0; t < p; ++t)h[f] = b[l], h[f + 1] = b[l + 1], f += n, l += d } function q(n, p, l) {
          const h = n.typedBuffer, b = n.typedBufferStride, d = p.typedBuffer, f = p.typedBufferStride, t = l ? l.count : p.count;
          let v = (l && l.dstIndex ? l.dstIndex : 0) * b, m = (l && l.srcIndex ? l.srcIndex : 0) * f; if (w.isInteger(p.elementType)) if (l = w.maximumValue(p.elementType), w.isSigned(p.elementType)) for (p = 0; p < t; ++p)h[v] = Math.max(d[m] / l, -1), h[v + 1] = Math.max(d[m + 1] / l, -1), v += b, m += f; else for (p = 0; p < t; ++p)h[v] = d[m] / l, h[v + 1] = d[m + 1] / l, v += b, m += f; else c(n, p, l); return n
        } function u(n, p, l, h) {
          var b, d; const f = n.typedBuffer, t = n.typedBufferStride; n = null != (b = null == h ? void 0 : h.count) ? b : n.count; h = (null != (d = null == h ? void 0 : h.dstIndex) ? d : 0) * t; for (d = 0; d < n; ++d)f[h] =
            p, f[h + 1] = l, h += t
        } const y = Object.freeze({ __proto__: null, copy: c, normalizeIntegerBuffer: q, fill: u }); a.copy = c; a.fill = u; a.normalizeIntegerBuffer = q; a.vec2 = y
      })
    }, "esri/chunks/vec33": function () {
      define(["exports"], function (a) {
        function w(u, y, n) { const p = u.typedBuffer; u = u.typedBufferStride; const l = y.typedBuffer, h = y.typedBufferStride; y = n ? n.count : y.count; let b = (n && n.dstIndex ? n.dstIndex : 0) * u; n = (n && n.srcIndex ? n.srcIndex : 0) * h; for (let d = 0; d < y; ++d)p[b] = l[n], p[b + 1] = l[n + 1], p[b + 2] = l[n + 2], b += u, n += h } function c(u, y, n, p, l) {
          var h,
          b; const d = u.typedBuffer, f = u.typedBufferStride; u = null != (h = null == l ? void 0 : l.count) ? h : u.count; l = (null != (b = null == l ? void 0 : l.dstIndex) ? b : 0) * f; for (b = 0; b < u; ++b)d[l] = y, d[l + 1] = n, d[l + 2] = p, l += f
        } const q = Object.freeze({ __proto__: null, copy: w, fill: c }); a.copy = w; a.fill = c; a.vec3 = q
      })
    }, "esri/chunks/vec43": function () {
      define(["exports"], function (a) {
        function w(u, y, n) {
          const p = u.typedBuffer; u = u.typedBufferStride; const l = y.typedBuffer, h = y.typedBufferStride; y = n ? n.count : y.count; let b = (n && n.dstIndex ? n.dstIndex : 0) * u; n = (n && n.srcIndex ?
            n.srcIndex : 0) * h; for (let d = 0; d < y; ++d)p[b] = l[n], p[b + 1] = l[n + 1], p[b + 2] = l[n + 2], p[b + 3] = l[n + 3], b += u, n += h
        } function c(u, y, n, p, l, h) { var b, d; const f = u.typedBuffer, t = u.typedBufferStride; u = null != (b = null == h ? void 0 : h.count) ? b : u.count; h = (null != (d = null == h ? void 0 : h.dstIndex) ? d : 0) * t; for (d = 0; d < u; ++d)f[h] = y, f[h + 1] = n, f[h + 2] = p, f[h + 3] = l, h += t } const q = Object.freeze({ __proto__: null, copy: w, fill: c }); a.copy = w; a.fill = c; a.vec4 = q
      })
    }, "esri/views/3d/glTF/DefaultLoadingContext": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../request ../../../core/asyncUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/urlUtils".split(" "),
        function (a, w, c, q, u, y, n, p) {
          let l = function () {
            function b(f) { this.streamDataRequester = f } var d = b.prototype; d.loadJSON = function () { var f = w._asyncToGenerator(function* (t, v) { return this.load("json", t, v) }); return function (t, v) { return f.apply(this, arguments) } }(); d.loadBinary = function () { var f = w._asyncToGenerator(function* (t, v) { return p.isDataProtocol(t) ? (n.throwIfAborted(v), p.dataToArrayBuffer(t)) : this.load("binary", t, v) }); return function (t, v) { return f.apply(this, arguments) } }(); d.loadImage = function () {
              var f = w._asyncToGenerator(function* (t,
                v) { return this.load("image", t, v) }); return function (t, v) { return f.apply(this, arguments) }
            }(); d.load = function () { var f = w._asyncToGenerator(function* (t, v, m) { if (y.isNone(this.streamDataRequester)) return (yield c(v, { responseType: h[t] })).data; t = yield q.result(this.streamDataRequester.request(v, t, m)); if (!0 === t.ok) return t.value; n.throwIfAbortError(t.error); throw new u("", `Request for resource failed: ${t.error}`); }); return function (t, v, m) { return f.apply(this, arguments) } }(); return b
          }(); const h = {
            image: "image",
            binary: "array-buffer", json: "json"
          }; a.DefaultLoadingContext = l; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/glTF/loader": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../chunks/mat4f64 ./DefaultErrorContext ./LoaderResult ./internal/Resource".split(" "), function (a, w, c, q, u, y, n) {
        function p() {
          p = w._asyncToGenerator(function* (e, g, x = {}, k = !0) {
            const r = yield n.Resource.load(e, t, g, x), A = `gltf_${f++}`, z = {
              lods: [], materials: new Map, textures: new Map,
              meta: l(r)
            }; e = !(!r.json.asset.extras || "symbolResource" !== r.json.asset.extras.ESRI_type); const B = new Map; yield h(r, function () {
              var C = w._asyncToGenerator(function* (D, E, H, J) {
                var M; const F = null != (M = B.get(H)) ? M : 0; B.set(H, F + 1); var K = void 0 !== D.mode ? D.mode : 4; M = 4 === K || 5 === K || 6 === K ? K : null; if (c.isNone(M)) t.warnUnsupported("Unsupported primitive mode (" + m[K] + "). Skipping primitive."); else if (r.hasPositions(D)) {
                  K = r.getPositionData(D, x); var P = r.getMaterial(D, x, k), L = r.hasNormals(D) ? r.getNormalData(D, x) : null, N = r.hasTangents(D) ?
                    r.getTangentData(D, x) : null, G = r.hasTextureCoordinates(D) ? r.getTextureCoordinates(D, x) : null, I = r.hasVertexColors(D) ? r.getVertexColors(D, x) : null; D = r.getIndexData(D, x); E = { transform: q.clone(E), attributes: { position: yield K, normal: L ? yield L : null, texCoord0: G ? yield G : null, color: I ? yield I : null, tangent: N ? yield N : null }, indices: yield D, primitiveType: M, material: d(z, yield P, A) }; D = null; c.isSome(z.meta) && c.isSome(z.meta.ESRI_lod) && "screenSpaceRadius" === z.meta.ESRI_lod.metric && (D = z.meta.ESRI_lod.thresholds[H]); z.lods[H] =
                      z.lods[H] || { parts: [], name: J, lodThreshold: D }; z.lods[H].parts[F] = E
                } else t.warn("Skipping primitive without POSITION vertex attribute.")
              }); return function (D, E, H, J) { return C.apply(this, arguments) }
            }()); for (const C of z.lods) C.parts = C.parts.filter(D => !!D); return { model: z, meta: { isEsriSymbolResource: e, uri: r.uri }, customMeta: {} }
          }); return p.apply(this, arguments)
        } function l(e) { let g = null; e.json.nodes.forEach(x => { x = x.extras; c.isSome(x) && (x.ESRI_proxyEllipsoid || x.ESRI_lod) && (g = x) }); return g } function h(e, g) {
          return b.apply(this,
            arguments)
        } function b() {
          b = w._asyncToGenerator(function* (e, g) {
            function x(C, D) { return k.apply(this, arguments) } function k() { k = w._asyncToGenerator(function* (C, D) { const E = r.nodes[C]; C = e.getNodeTransform(C); t.warnUnsupportedIf(null != E.weights, "Morph targets are not supported."); if (null != E.mesh) { const H = r.meshes[E.mesh]; for (const J of H.primitives) B.push(g(J, C, D, H.name)) } for (const H of E.children || []) B.push(x(H, D)) }); return k.apply(this, arguments) } const r = e.json; var A = r.scenes[r.scene || 0].nodes; const z =
              1 < A.length, B = []; for (const C of A) A = r.nodes[C], B.push(x(C, 0)), A.extensions && A.extensions.MSFT_lod && Array.isArray(A.extensions.MSFT_lod.ids) && !z && A.extensions.MSFT_lod.ids.forEach((D, E) => x(D, E + 1)); yield Promise.all(B)
          }); return b.apply(this, arguments)
        } function d(e, g, x) {
          const k = A => { const z = `${x}_tex_${A && A.id}${A && A.name ? "_" + A.name : ""}`; if (A && !e.textures.has(z)) { const B = y.makeTextureSource(A.data, { wrap: { s: A.wrapS, t: A.wrapT }, mipmap: v.some(C => C === A.minFilter), noUnpackFlip: !0 }); e.textures.set(z, B) } return z },
          r = `${x}_mat_${g.id}_${g.name}`; e.materials.has(r) || (g = y.makeMaterialParameters({
            color: [g.color[0], g.color[1], g.color[2]], opacity: g.color[3], alphaMode: g.alphaMode, alphaCutoff: g.alphaCutoff, doubleSided: g.doubleSided, colorMixMode: g.ESRI_externalColorMixMode, textureColor: g.colorTexture ? k(g.colorTexture) : void 0, textureNormal: g.normalTexture ? k(g.normalTexture) : void 0, textureOcclusion: g.occlusionTexture ? k(g.occlusionTexture) : void 0, textureEmissive: g.emissiveTexture ? k(g.emissiveTexture) : void 0, textureMetallicRoughness: g.metallicRoughnessTexture ?
              k(g.metallicRoughnessTexture) : void 0, emissiveFactor: [g.emissiveFactor[0], g.emissiveFactor[1], g.emissiveFactor[2]], metallicFactor: g.metallicFactor, roughnessFactor: g.roughnessFactor
          }), e.materials.set(r, g)); return r
        } let f = 0; const t = new u.DefaultErrorContext, v = [9987, 9985], m = "POINTS LINES LINE_LOOP LINE_STRIP TRIANGLES TRIANGLE_STRIP TRIANGLE_FAN".split(" "); a.load = function (e, g) { return p.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/glTF/DefaultErrorContext": function () {
      define(["exports",
        "../../../core/Error", "../../../core/Logger"], function (a, w, c) {
          const q = c.getLogger("esri.views.3d.glTF"); c = function () {
            function u() { } var y = u.prototype; y.error = function (n) { throw new w("gltf-loader-error", n); }; y.errorUnsupported = function (n) { throw new w("gltf-loader-unsupported-feature", n); }; y.errorUnsupportedIf = function (n, p) { n && this.errorUnsupported(p) }; y.assert = function (n, p) { n || this.error(p) }; y.warn = function (n) { q.warn(n) }; y.warnUnsupported = function (n) { this.warn("[Unsupported Feature] " + n) }; y.warnUnsupportedIf =
              function (n, p) { n && this.warnUnsupported(p) }; return u
          }(); a.DefaultErrorContext = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/glTF/LoaderResult": function () {
      define(["exports"], function (a) {
      a.makeMaterialParameters = function (w = {}) {
        return {
          color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: .5, doubleSided: !1, castShadows: !0, receiveShadows: !0, receiveAmbientOcclustion: !0, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, emissiveFactor: [0,
            0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...w
        }
      }; a.makeTextureSource = function (w, c = {}) { return { data: w, parameters: { wrap: { s: 10497, t: 10497, ...c.wrap }, noUnpackFlip: !0, mipmap: !1, ...c } } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/glTF/internal/Resource": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/compilerUtils ../../../../core/MapUtils ../../../../core/urlUtils ../../../../core/Version ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/quat ../../../../chunks/quatf64 ../../../../geometry/support/buffer/BufferView ../../../../chunks/scalar ./BinaryStreamReader ./fillDefaults ./pathUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(H) {
            switch (H.componentType) {
              case 5120: return new b.BufferViewVec2i8(H.raw, H.byteOffset, H.byteStride, H.byteOffset + H.byteStride * H.entryCount); case 5121: return new b.BufferViewVec2u8(H.raw, H.byteOffset, H.byteStride, H.byteOffset + H.byteStride * H.entryCount); case 5122: return new b.BufferViewVec2i16(H.raw, H.byteOffset, H.byteStride, H.byteOffset + H.byteStride * H.entryCount); case 5123: return new b.BufferViewVec2u16(H.raw, H.byteOffset, H.byteStride, H.byteOffset +
                H.byteStride * H.entryCount); case 5125: return new b.BufferViewVec2u32(H.raw, H.byteOffset, H.byteStride, H.byteOffset + H.byteStride * H.entryCount); case 5126: return new b.BufferViewVec2f(H.raw, H.byteOffset, H.byteStride, H.byteOffset + H.byteStride * H.entryCount); default: c.neverReached(H.componentType)
            }
          } function e(H) { return g.apply(this, arguments) } function g() {
            g = w._asyncToGenerator(function* (H) {
              return new Promise((J, M) => {
                const F = new Blob([H]), K = new FileReader; K.onload = () => { J(JSON.parse(K.result)) }; K.onerror = P => { M(P) }; K.readAsText(F)
              })
            }); return g.apply(this, arguments)
          } function x(H, J) { return k.apply(this, arguments) } function k() { k = w._asyncToGenerator(function* (H, J) { return new Promise((M, F) => { const K = new Blob([H], { type: J }), P = URL.createObjectURL(K), L = new Image; L.addEventListener("load", () => { URL.revokeObjectURL(P); "decode" in L ? L.decode().then(() => M(L), () => M(L)) : M(L) }); L.addEventListener("error", N => { URL.revokeObjectURL(P); F(N) }); L.src = P }) }); return k.apply(this, arguments) } let r = function () {
            function H(M, F, K, P, L) {
            this.context =
              M; this.errorContext = F; this.uri = K; this.json = P; this.glbBuffer = L; this.bufferLoaders = new Map; this.textureLoaders = new Map; this.textureCache = new Map; this.materialCache = new Map; this.nodeParentMap = new Map; this.nodeTransformCache = new Map; this.baseUri = v.splitURI(this.uri).dirPart; this.checkVersionSupported(); this.checkRequiredExtensionsSupported(); F.errorUnsupportedIf(null == P.scenes, "Scenes must be defined."); F.errorUnsupportedIf(null == P.meshes, "Meshes must be defined"); F.errorUnsupportedIf(null == P.nodes, "Nodes must be defined.");
              this.computeNodeParents()
            } H.load = function () {
              var M = w._asyncToGenerator(function* (F, K, P, L) {
                if (u.isDataProtocol(P)) { var N = u.dataComponents(P); if ("model/gltf-binary" !== N.mediaType) try { const G = JSON.parse(N.isBase64 ? atob(N.data) : N.data); return new H(F, K, P, G) } catch{ } N = u.dataToArrayBuffer(P); if (H.isGLBData(N)) return this.fromGLBData(F, K, P, N) } if (P.endsWith(".gltf")) return L = yield F.loadJSON(P, L), new H(F, K, P, L); N = yield F.loadBinary(P, L); if (H.isGLBData(N)) return this.fromGLBData(F, K, P, N); L = yield F.loadJSON(P,
                  L); return new H(F, K, P, L)
              }); return function (F, K, P, L) { return M.apply(this, arguments) }
            }(); H.isGLBData = function (M) { M = new f.BinaryStreamReader(M); return 4 <= M.remainingBytes() && 1179937895 === M.readUint32() }; H.fromGLBData = function () { var M = w._asyncToGenerator(function* (F, K, P, L) { L = yield H.parseGLBData(K, L); return new H(F, K, P, L.json, L.binaryData) }); return function (F, K, P, L) { return M.apply(this, arguments) } }(); H.parseGLBData = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = new f.BinaryStreamReader(K);
                F.assert(12 <= P.remainingBytes(), "GLB binary data is insufficiently large."); var L = P.readUint32(), N = P.readUint32(); const G = P.readUint32(); F.assert(1179937895 === L, "Magic first 4 bytes do not fit to expected GLB value."); F.assert(K.byteLength >= G, "GLB binary data is smaller than header specifies."); F.errorUnsupportedIf(2 !== N, "An unsupported GLB container version was detected. Only version 2 is supported."); K = 0; let I, O; for (; 8 <= P.remainingBytes();)L = P.readUint32(), N = P.readUint32(), 0 === K ? (F.assert(1313821514 ===
                  N, "First GLB chunk must be JSON."), F.assert(0 <= L, "No JSON data found."), I = yield e(P.readUint8Array(L))) : 1 === K ? (F.errorUnsupportedIf(5130562 !== N, "Second GLB chunk expected to be BIN."), O = P.readUint8Array(L)) : F.warnUnsupported("More than 2 GLB chunks detected. Skipping."), K += 1; I || F.error("No GLB JSON chunk detected."); return { json: I, binaryData: O }
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); var J = H.prototype; J.getBuffer = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.json.buffers[F],
                L = this.errorContext; if (null == P.uri) return L.assert(null != this.glbBuffer, "GLB buffer not present"), this.glbBuffer; F = yield this.getBufferLoader(F, K); L.assert(F.byteLength === P.byteLength, "Buffer byte lengths should match."); return F
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getBufferLoader = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.bufferLoaders.get(F); if (P) return P; K = this.context.loadBinary(this.resolveUri(this.json.buffers[F].uri), K).then(L => new Uint8Array(L));
                this.bufferLoaders.set(F, K); return K
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getAccessor = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                var P = this.errorContext; P.errorUnsupportedIf(!this.json.accessors, "Accessors missing."); F = this.json.accessors[F]; P.errorUnsupportedIf(null == (null == F ? void 0 : F.bufferView), "Some accessor does not specify a bufferView."); P.errorUnsupportedIf(F.type in ["MAT2", "MAT3", "MAT4"], `AttributeType ${F.type} is not supported`); P = this.json.bufferViews[F.bufferView];
                K = yield this.getBuffer(P.buffer, K); const L = C[F.type], N = D[F.componentType], G = L * N, I = P.byteStride || G; return { raw: K.buffer, byteStride: I, byteOffset: K.byteOffset + (P.byteOffset || 0) + (F.byteOffset || 0), entryCount: F.count, isDenselyPacked: I === G, componentCount: L, componentByteSize: N, componentType: F.componentType, min: F.min, max: F.max, normalized: !!F.normalized }
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getIndexData = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                if (null == F.indices) return null;
                F = yield this.getAccessor(F.indices, K); if (F.isDenselyPacked) switch (F.componentType) { case 5121: return new Uint8Array(F.raw, F.byteOffset, F.entryCount); case 5123: return new Uint16Array(F.raw, F.byteOffset, F.entryCount); case 5125: return new Uint32Array(F.raw, F.byteOffset, F.entryCount) } else switch (F.componentType) {
                  case 5121: return d.makeDense(this.wrapAccessor(b.BufferViewUint8, F)); case 5123: return d.makeDense(this.wrapAccessor(b.BufferViewUint16, F)); case 5125: return d.makeDense(this.wrapAccessor(b.BufferViewUint32,
                    F))
                }
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getPositionData = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.errorContext; P.errorUnsupportedIf(null == F.attributes.POSITION, "No POSITION vertex data found."); F = yield this.getAccessor(F.attributes.POSITION, K); P.errorUnsupportedIf(5126 !== F.componentType, "Expected type FLOAT for POSITION vertex attribute, but found " + E[F.componentType]); P.errorUnsupportedIf(3 !== F.componentCount, "POSITION vertex attribute must have 3 components, but found " +
                  F.componentCount.toFixed()); return this.wrapAccessor(b.BufferViewVec3f, F)
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getNormalData = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.errorContext; P.assert(null != F.attributes.NORMAL, "No NORMAL vertex data found."); F = yield this.getAccessor(F.attributes.NORMAL, K); P.errorUnsupportedIf(5126 !== F.componentType, "Expected type FLOAT for NORMAL vertex attribute, but found " + E[F.componentType]); P.errorUnsupportedIf(3 !== F.componentCount,
                  "NORMAL vertex attribute must have 3 components, but found " + F.componentCount.toFixed()); return this.wrapAccessor(b.BufferViewVec3f, F)
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getTangentData = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.errorContext; P.assert(null != F.attributes.TANGENT, "No TANGENT vertex data found."); F = yield this.getAccessor(F.attributes.TANGENT, K); P.errorUnsupportedIf(5126 !== F.componentType, "Expected type FLOAT for TANGENT vertex attribute, but found " +
                  E[F.componentType]); P.errorUnsupportedIf(4 !== F.componentCount, "TANGENT vertex attribute must have 4 components, but found " + F.componentCount.toFixed()); return new b.BufferViewVec4f(F.raw, F.byteOffset, F.byteStride, F.byteOffset + F.byteStride * F.entryCount)
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getTextureCoordinates = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.errorContext; P.assert(null != F.attributes.TEXCOORD_0, "No TEXCOORD_0 vertex data found."); F = yield this.getAccessor(F.attributes.TEXCOORD_0,
                  K); P.errorUnsupportedIf(2 !== F.componentCount, "TEXCOORD_0 vertex attribute must have 2 components, but found " + F.componentCount.toFixed()); if (5126 === F.componentType) return this.wrapAccessor(b.BufferViewVec2f, F); P.errorUnsupportedIf(!F.normalized, "Integer component types are only supported for a normalized accessor for TEXCOORD_0."); return m(F)
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.getVertexColors = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                const P = this.errorContext; P.assert(null !=
                  F.attributes.COLOR_0, "No COLOR_0 vertex data found."); F = yield this.getAccessor(F.attributes.COLOR_0, K); P.errorUnsupportedIf(4 !== F.componentCount && 3 !== F.componentCount, "COLOR_0 attribute must have 3 or 4 components, but found " + F.componentCount.toFixed()); if (4 === F.componentCount) { if (5126 === F.componentType) return this.wrapAccessor(b.BufferViewVec4f, F); if (5121 === F.componentType) return this.wrapAccessor(b.BufferViewVec4u8, F); if (5123 === F.componentType) return this.wrapAccessor(b.BufferViewVec4u16, F) } else if (3 ===
                    F.componentCount) { if (5126 === F.componentType) return this.wrapAccessor(b.BufferViewVec3f, F); if (5121 === F.componentType) return this.wrapAccessor(b.BufferViewVec3u8, F); if (5123 === F.componentType) return this.wrapAccessor(b.BufferViewVec3u16, F) } P.errorUnsupported("Unsupported component type for COLOR_0 attribute: " + E[F.componentType])
              }); return function (F, K) { return M.apply(this, arguments) }
            }(); J.hasPositions = function (M) { return void 0 !== M.attributes.POSITION }; J.hasNormals = function (M) { return void 0 !== M.attributes.NORMAL };
            J.hasVertexColors = function (M) { return void 0 !== M.attributes.COLOR_0 }; J.hasTextureCoordinates = function (M) { return void 0 !== M.attributes.TEXCOORD_0 }; J.hasTangents = function (M) { return void 0 !== M.attributes.TANGENT }; J.getMaterial = function () {
              var M = w._asyncToGenerator(function* (F, K, P) {
                var L = this.materialCache.get(F.material); if (!L) {
                  L = null != F.material ? t.material(this.json.materials[F.material]) : t.material(); const N = L.pbrMetallicRoughness, G = this.hasVertexColors(F), I = this.getTexture(N.baseColorTexture, K), O = this.getTexture(L.normalTexture,
                    K), R = P ? this.getTexture(L.occlusionTexture, K) : null, S = P ? this.getTexture(L.emissiveTexture, K) : null; K = P ? this.getTexture(N.metallicRoughnessTexture, K) : null; F = null != F.material ? F.material : -1; L = {
                      alphaMode: L.alphaMode, alphaCutoff: L.alphaCutoff, color: N.baseColorFactor, doubleSided: !!L.doubleSided, colorTexture: yield I, normalTexture: yield O, name: L.name, id: F, occlusionTexture: yield R, emissiveTexture: yield S, emissiveFactor: L.emissiveFactor, metallicFactor: N.metallicFactor, roughnessFactor: N.roughnessFactor, metallicRoughnessTexture: yield K,
                      vertexColors: G, ESRI_externalColorMixMode: L.extras.ESRI_externalColorMixMode
                    }
                } return L
              }); return function (F, K, P) { return M.apply(this, arguments) }
            }(); J.getTexture = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                if (!F) return null; this.errorContext.errorUnsupportedIf(0 !== (F.texCoord || 0), "Only TEXCOORD with index 0 is supported."); const P = F.index, L = this.errorContext; F = this.json.textures[P]; const N = t.textureSampler(null != F.sampler ? this.json.samplers[F.sampler] : {}); L.errorUnsupportedIf(null == F.source,
                  "Source is expected to be defined for a texture."); const G = this.json.images[F.source], I = yield this.loadTextureImageData(P, F, K); return q.getOrCreateMapValue(this.textureCache, P, () => { const O = S => 33071 === S || 33648 === S || 10497 === S, R = S => { L.error(`Unexpected TextureSampler WrapMode: ${S}. Using default REPEAT(10497).`); return 10497 }; return { data: I, wrapS: O(N.wrapS) ? N.wrapS : R(N.wrapS), wrapT: O(N.wrapT) ? N.wrapT : R(N.wrapT), minFilter: N.minFilter, name: G.name, id: P } })
              }); return function (F, K) { return M.apply(this, arguments) }
            }();
            J.getNodeTransform = function (M) { if (void 0 === M) return z; var F = this.nodeTransformCache.get(M); if (!F) { F = this.getNodeTransform(this.getNodeParent(M)); const K = this.json.nodes[M]; if (K.matrix) F = n.multiply(p.create(), F, K.matrix); else if (K.translation || K.rotation || K.scale) F = p.clone(F), K.translation && n.translate(F, F, K.translation), K.rotation && (B[3] = l.getAxisAngle(B, K.rotation), n.rotate(F, F, B[3], B)), K.scale && n.scale(F, F, K.scale); this.nodeTransformCache.set(M, F) } return F }; J.wrapAccessor = function (M, F) {
              return new M(F.raw,
                F.byteOffset, F.byteStride, F.byteOffset + F.byteStride * (F.entryCount - 1) + F.componentByteSize * F.componentCount)
            }; J.resolveUri = function (M) { return u.makeAbsolute(M, this.baseUri) }; J.getNodeParent = function (M) { return this.nodeParentMap.get(M) }; J.checkVersionSupported = function () { const M = y.Version.parse(this.json.asset.version, "glTF"); A.validate(M) }; J.checkRequiredExtensionsSupported = function () {
              const M = this.json, F = this.errorContext; M.extensionsRequired && 0 !== M.extensionsRequired.length && F.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: " +
                M.extensionsRequired.join(", "))
            }; J.computeNodeParents = function () { this.json.nodes.forEach((M, F) => { M.children && M.children.forEach(K => { this.nodeParentMap.set(K, F) }) }) }; J.loadTextureImageData = function () { var M = w._asyncToGenerator(function* (F, K, P) { const L = this.textureLoaders.get(F); if (L) return L; K = this.createTextureLoader(K, P); this.textureLoaders.set(F, K); return K }); return function (F, K, P) { return M.apply(this, arguments) } }(); J.createTextureLoader = function () {
              var M = w._asyncToGenerator(function* (F, K) {
                F = this.json.images[F.source];
                if (F.uri) return this.context.loadImage(this.resolveUri(F.uri), K); const P = this.errorContext; P.errorUnsupportedIf(null == F.bufferView, "Image bufferView must be defined."); P.errorUnsupportedIf(null == F.mimeType, "Image mimeType must be defined."); const L = this.json.bufferViews[F.bufferView]; K = yield this.getBuffer(L.buffer, K); P.errorUnsupportedIf(null != L.byteStride, "byteStride not supported for image buffer"); return x(new Uint8Array(K.buffer, K.byteOffset + (L.byteOffset || 0), L.byteLength), F.mimeType)
              }); return function (F,
                K) { return M.apply(this, arguments) }
            }(); return H
          }(); const A = new y.Version(2, 0, "glTF"), z = n.fromXRotation(p.create(), Math.PI / 2), B = h.create(), C = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4 }, D = { [5120]: 1, [5121]: 1, [5122]: 2, [5123]: 2, [5126]: 4, [5125]: 4 }, E = { 5120: "BYTE", 5121: "UNSIGNED_BYTE", 5122: "SHORT", 5123: "UNSIGNED_SHORT", 5125: "UNSIGNED_INT", 5126: "FLOAT" }; a.Resource = r; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/Version": function () {
      define(["exports", "./Error"], function (a, w) {
        let c = function () {
          function q(y,
            n, p = "") { this.major = y; this.minor = n; this._context = p } var u = q.prototype; u.lessThan = function (y, n) { return this.major < y || y === this.major && this.minor < n }; u.since = function (y, n) { return !this.lessThan(y, n) }; u.validate = function (y) { if (this.major !== y.major) throw new w((this._context && this._context + ":") + "unsupported-version", `Required major ${this._context && this._context + " "}version is '${this.major}', but got '\${version.major}.\${version.minor}'`, { version: y }); }; u.clone = function () {
              return new q(this.major, this.minor,
                this._context)
            }; q.parse = function (y, n = "") { const [p, l] = y.split("."); var h = /^\s*\d+\s*$/; if (!p || !p.match || !p.match(h)) throw new w((n && n + ":") + "invalid-version", "Expected major version to be a number, but got '${version}'", { version: y }); if (!l || !l.match || !l.match(h)) throw new w((n && n + ":") + "invalid-version", "Expected minor version to be a number, but got '${version}'", { version: y }); y = parseInt(p, 10); h = parseInt(l, 10); return new q(y, h, n) }; return q
        }(); a.Version = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    },
    "esri/views/3d/glTF/internal/BinaryStreamReader": function () {
      define(["exports"], function (a) {
        let w = function () {
          function c(u) { this.data = u; this.offset4 = 0; this.dataUint32 = new Uint32Array(this.data, 0, Math.floor(this.data.byteLength / 4)) } var q = c.prototype; q.readUint32 = function () { const u = this.offset4; this.offset4 += 1; return this.dataUint32[u] }; q.readUint8Array = function (u) { const y = 4 * this.offset4; this.offset4 += u / 4; return new Uint8Array(this.data, y, u) }; q.remainingBytes = function () {
            return this.data.byteLength - 4 *
              this.offset4
          }; return c
        }(); a.BinaryStreamReader = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/glTF/internal/fillDefaults": function () {
      define(["exports", "../../../../core/compilerUtils"], function (a, w) {
        const c = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 }, q = { pbrMetallicRoughness: c, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: .5, doubleSided: !1 }, u = { ESRI_externalColorMixMode: "tint" }, y = { magFilter: 9729, minFilter: 9987, wrapS: 10497, wrapT: 10497 }; a.material = (n = {}) => { const p = { ...c, ...n.pbrMetallicRoughness }; var l = { ...u, ...n.extras }; switch (l.ESRI_externalColorMixMode) { case "multiply": case "tint": case "ignore": case "replace": break; default: w.neverReached(l.ESRI_externalColorMixMode), l.ESRI_externalColorMixMode = "tint" }return { ...q, ...n, pbrMetallicRoughness: p, extras: l } }; a.textureSampler = n => ({ ...y, ...n }); Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/glTF/internal/pathUtils": function () {
      define(["exports"], function (a) {
      a.splitURI = function (w) {
        let c,
        q; w.replace(/^(.*\/)?([^/]*)$/, (u, y, n) => { c = y || ""; q = n || ""; return "" }); return { dirPart: c, filePart: q }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/glTF/internal/indexUtils": function () {
      define(["exports", "../../../../core/typedArrayUtil", "../../webgl-engine/lib/geometryDataUtils"], function (a, w, c) {
      a.triangleFanToTriangles = function (q) {
        var u = "number" === typeof q ? q : q.length; if (3 > u) return new Uint16Array(0); u -= 2; const y = 65536 >= u ? new Uint16Array(3 * u) : new Uint32Array(3 * u); if ("number" === typeof q) {
          q =
          0; for (var n = 0; n < u; ++n)y[q++] = 0, y[q++] = n + 1, y[q++] = n + 2; return y
        } { n = q[0]; let p = q[1], l = 0; for (let h = 0; h < u; ++h) { const b = q[h + 2]; y[l++] = n; y[l++] = p; p = y[l++] = b } return y }
      }; a.triangleStripToTriangles = function (q) {
        var u = "number" === typeof q ? q : q.length; if (3 > u) return new Uint16Array(0); u -= 2; const y = 65536 >= u ? new Uint16Array(3 * u) : new Uint32Array(3 * u); if ("number" === typeof q) { q = 0; for (var n = 0; n < u; n += 1)0 === n % 2 ? (y[q++] = n, y[q++] = n + 1) : (y[q++] = n + 1, y[q++] = n), y[q++] = n + 2 } else {
          n = 0; for (let b = 0; b < u; b += 1)if (0 === b % 2) {
            var p = q[b], l =
              q[b + 1], h = q[b + 2]; y[n++] = p; y[n++] = l; y[n++] = h
          } else p = q[b + 1], l = q[b], h = q[b + 2], y[n++] = p, y[n++] = l, y[n++] = h
        } return y
      }; a.trianglesToTriangles = function (q, u = c.generateDefaultIndexArray) { return "number" === typeof q ? u(q) : w.isUint16Array(q) || w.isUint8Array(q) ? new Uint32Array(q) : q }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/wosrLoader": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../request ../../../../core/asyncUtils ../../../../core/Error ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/Version ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingBox ../../../../support/requestImageUtils ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/Texture ../../webgl-engine/materials/DefaultMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m() { m = w._asyncToGenerator(function* (H, J) { H = yield e(H, J); J = yield z(H.textureDefinitions, J); return { resource: H, textures: J } }); return m.apply(this, arguments) } function e(H, J) { return g.apply(this, arguments) } function g() { g = w._asyncToGenerator(function* (H, J) { const M = n.isSome(J) && J.streamDataRequester; if (M) return x(H, M, J); H = yield q.result(c(H, n.unwrap(J))); if (!0 === H.ok) return H.value.data; p.throwIfAbortError(H.error); r(H.error) }); return g.apply(this, arguments) }
          function x(H, J, M) { return k.apply(this, arguments) } function k() { k = w._asyncToGenerator(function* (H, J, M) { H = yield q.result(J.request(H, "json", M)); if (!0 === H.ok) return H.value; p.throwIfAbortError(H.error); r(H.error.details.url) }); return k.apply(this, arguments) } function r(H) { throw new u("", `Request for object resource failed: ${H}`); } function A(H) { const J = b.empty(); H.forEach(M => { M = M.boundingInfo; n.isSome(M) && (b.expandWithVec3(J, M.getBBMin()), b.expandWithVec3(J, M.getBBMax())) }); return J } function z(H, J) {
            return B.apply(this,
              arguments)
          } function B() {
            B = w._asyncToGenerator(function* (H, J) {
              const M = []; for (const P in H) {
                var F = H[P], K = F.images[0].data; if (!K) { D.warn("Externally referenced texture data is not yet supported"); continue } K = F.encoding + ";base64," + K; const L = "/textureDefinitions/" + P, N = "rgba" === F.channels ? F.alphaChannelUsage || "transparency" : "none", G = { noUnpackFlip: !0, wrap: { s: 10497, t: 10497 }, preMultiplyAlpha: 1 !== C(N) }; F = n.isSome(J) && J.disableTextures ? Promise.resolve(null) : d.requestImage(K, J); M.push(F.then(I => ({
                  refId: L, image: I,
                  params: G, alphaChannelUsage: N
                })))
              } H = yield Promise.all(M); J = {}; for (const P of H) J[P.refId] = P; return J
            }); return B.apply(this, arguments)
          } function C(H) { switch (H) { case "mask": return 2; case "maskAndTransparency": return 3; case "none": return 1; case "transparency": return 0; default: return 0 } } const D = y.getLogger("esri.views.3d.layers.graphics.objectResourceUtils"), E = new l.Version(1, 2, "wosr"); a.createTextureResources = z; a.load = function (H, J) { return m.apply(this, arguments) }; a.processLoadResult = function (H, J) {
            const M =
              [], F = [], K = [], P = [], L = H.resource; var N = l.Version.parse(L.version || "1.0", "wosr"); E.validate(N); N = L.model.name; const G = L.model.geometries, I = L.materialDefinitions; H = H.textures; let O = 0; const R = new Map; for (let ka = 0; ka < G.length; ka++) {
                var S = G[ka], Q = S, T = Q.params, da = T.topology; var Y = !0; T.vertexAttributes || (D.warn("Geometry must specify vertex attributes"), Y = !1); switch (T.topology) {
                  case "PerAttributeArray": break; case "Indexed": case null: case void 0: da = T.faces; if (!da) D.warn("Indexed geometries must specify faces"),
                    Y = !1; else if (T.vertexAttributes) for (const ea in T.vertexAttributes) (T = da[ea]) && T.values ? (null != T.valueType && "UInt32" !== T.valueType && (D.warn(`Unsupported indexed geometry indices type '${T.valueType}', only UInt32 is currently supported`), Y = !1), null != T.valuesPerElement && 1 !== T.valuesPerElement && (D.warn(`Unsupported indexed geometry values per element '${T.valuesPerElement}', only 1 is currently supported`), Y = !1)) : (D.warn(`Indexed geometry does not specify face indices for '${ea}' attribute`), Y = !1);
                    break; default: D.warn(`Unsupported topology '${da}'`), Y = !1
                }Q.params.material || (D.warn("Geometry requires material"), Y = !1); Q = Q.params.vertexAttributes; for (const ea in Q) Q[ea].values || (D.warn("Geometries with externally defined attributes are not yet supported"), Y = !1); if (Y) {
                  Y = S.params; Y = { id: 1, material: Y.material, texture: Y.texture, region: Y.texture }; T = S.params.vertexAttributes; Q = []; for (const ea in T) da = T[ea], Q.push([ea, { data: da.values, size: da.valuesPerElement, exclusive: !0 }]); T = []; if ("PerAttributeArray" !==
                    S.params.topology) { S = S.params.faces; for (const ea in S) T.push([ea, new Uint32Array(S[ea].values)]) } if ((S = H && H[Y.texture]) && !R.has(Y.texture)) { const { image: ea, params: ba } = S; da = new t.Texture(ea, ba); P.push(da); R.set(Y.texture, da) } da = (da = R.get(Y.texture)) ? da.id : void 0; var fa = K[Y.material] ? K[Y.material][Y.texture] : null; if (!fa) {
                      fa = Y.material.substring(Y.material.lastIndexOf("/") + 1); fa = I[fa].params; 1 === fa.transparency && (fa.transparency = 0); var ha = S && S.alphaChannelUsage; ha = 0 < fa.transparency || "transparency" ===
                        ha || "maskAndTransparency" === ha; const ea = S ? C(S.alphaChannelUsage) : void 0; S = { ambient: h.fromArray(fa.diffuse), diffuse: h.fromArray(fa.diffuse), opacity: 1 - (fa.transparency || 0), transparent: ha, textureAlphaMode: ea, textureAlphaCutoff: .33, textureId: da, initTextureTransparent: !0, doubleSided: !0, cullFace: 0, colorMixMode: fa.externalColorMixMode || "tint", textureAlphaPremultiplied: S ? !!S.params.preMultiplyAlpha : !1 }; n.isSome(J) && J.materialParamsMixin && Object.assign(S, J.materialParamsMixin); fa = new v.DefaultMaterial(S);
                      K[Y.material] || (K[Y.material] = {}); K[Y.material][Y.texture] = fa
                    } F.push(fa); Y = new f.Geometry(Q, T); O += T.position ? T.position.length : 0; M.push(Y)
                }
              } return { name: N, stageResources: { textures: P, materials: F, geometries: M }, pivotOffset: L.model.pivotOffset, boundingBox: A(M), numberOfVertices: O, lodThreshold: null }
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA": function () {
      define(["exports"], function (a) {
      a.COLOR_GAMMA = 2.1; Object.defineProperty(a, "__esModule",
        { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/LodRenderer": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/maybe ../../../../../core/promiseUtils ../../../../../chunks/mat4f64 ../../../../../chunks/vec2f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/vec4f64 ../../../support/debugFlags ../../../support/buffer/glUtil ../../core/shaderLibrary/output/OutputHighlight.glsl ../Camera ../DefaultVertexAttributeLocations ../Util ./InstanceData ./InstanceOctree ./LevelSelector ./LodLevel ./RenderInstanceData ../../materials/DefaultMaterial ../../materials/internal/MaterialUtil ../../materials/renderers/utils ../../../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B) {
          function C(L, N, G) { const I = L.allocateHead(); L = L.view; z.encodeDoubleVec3(N.modelOrigin, G, L.modelOriginHi, L.modelOriginLo, I); L.model.copyFrom(I, N.model, G); L.modelNormal.copyFrom(I, N.modelNormal, G); N.color && L.color && L.color.copyFrom(I, N.color, G); N.featureAttribute && L.featureAttribute && L.featureAttribute.copyFrom(I, N.featureAttribute, G) } let D = function (L) {
            const N = L.baseBoundingSphere.radius; L = L.levels.map(G => G.minScreenSpaceRadius); return new g.LevelSelector(N,
              L)
          }, E = function () {
            function L(G, I, O, R) {
            this.type = 6; this.isGround = !1; this._inverseViewport = y.create(); this._levels = []; this._defaultRenderInstanceData = []; this._highlightRenderInstanceData = []; this._instanceIndex = 0; this._slicePlane = !1; this._enableLevelSelection = !0; this._lastCamera = new f; this._updateCyclesWithStaticCamera = -1; this._needFullCycle = !1; this.canRender = !0; this._symbol = G; this._optionalFields = I; this._metadata = O; this._instanceBufferLayout = r.getInstanceBufferLayout({ instancedDoublePrecision: !0, instanced: I });
              this._glInstanceBufferLayout = b.glLayout(this._instanceBufferLayout, 1); this._instanceData = new m.InstanceData(this._optionalFields, R); this._instanceData.on("instance-added", () => this.requestUpdateCycle()); this._instanceData.on("instance-removed", () => this.requestUpdateCycle()); this._instanceData.on("instance-transform-changed", S => { this.requestUpdateCycle(); this._metadata.notifyGraphicGeometryChanged(S.index) }); this._instanceData.on("instance-visibility-changed", S => { this.requestUpdateCycle(!0); this._metadata.notifyGraphicVisibilityChanged(S.index) });
              this._instanceData.on("instance-highlight-changed", () => this.requestUpdateCycle(!0)); this._enableLevelSelection = 1 < this._symbol.levels.length
            } var N = L.prototype; N.initializeRenderContext = function () {
              var G = w._asyncToGenerator(function* (I, O) {
              this._context = I; const R = I.renderContext.rctx, S = yield Promise.allSettled(this._symbol.levels.map(T => {
                this._defaultRenderInstanceData.push(new k.RenderInstanceData(R, this._instanceBufferLayout)); this._highlightRenderInstanceData.push(new k.RenderInstanceData(R, this._instanceBufferLayout));
                return x.LodLevel.create(I, T, O)
              })), Q = S.map(T => "fulfilled" === T.status ? T.value : null).filter(T => T); if (q.isAborted(O) || Q.length !== S.length) { Q.forEach(T => T.destroy()); q.throwIfAborted(O); for (const T of S) if ("rejected" === T.status) throw T.reason; } this._levels = Q; this._levelSelector = D(this)
              }); return function (I, O) { return G.apply(this, arguments) }
            }(); N.uninitializeRenderContext = function () {
              this.invalidateOctree(); this._levels.forEach(G => G.destroy()); this._defaultRenderInstanceData.forEach(G => G.destroy()); this._highlightRenderInstanceData.forEach(G =>
                G.destroy())
            }; N.prepareRender = function (G, I) { h.LOD_INSTANCE_RENDERER_DISABLE_UPDATES || (this._enableLevelSelection && (G = I.equals(this._lastCamera), this._lastCamera.copyFrom(I), G || this.requestUpdateCycle()), G = this._needFullCycle ? this._instanceData.size : 2E3, this._needFullCycle = !1, this.updateInstances(I, G), this.needsUpdates && this._context.requestRender()) }; N.render = function (G) {
              var I, O; const R = 3 === G.slot ? 2 : 5 === G.slot ? 4 : null; if (!R || !this.baseMaterial.isVisible() || !this.baseMaterial.isVisibleInPass(G.pass)) return !1;
              var S = G.camera; this._inverseViewport[0] = 1 / S.fullViewport[2]; this._inverseViewport[1] = 1 / S.fullViewport[3]; S = {
                slot: R, origin: [0, 0, 0], camera: S, inverseViewport: this._inverseViewport, shadowMap: G.shadowMap, shadowMappingEnabled: G.shadowMap.enabled, ssaoHelper: G.ssaoHelper, ssaoEnabled: G.ssaoHelper.enabled, screenToWorldRatio: null, screenToPCSRatio: null, slicePlane: G.sliceHelper && G.sliceHelper.plane, hudVisibilityTexture: G.offscreenRenderingHelper ? G.offscreenRenderingHelper.hudVisibilityTexture : null, highlightDepthTexture: null !=
                  (I = null == (O = G.offscreenRenderingHelper) ? void 0 : O.depthTexture) ? I : null, hasOccludees: !1, linearDepthTexture: null, lastFrameColorTexture: null, reprojectionMatrix: u.IDENTITY, ssrEnabled: !1, lighting: G.scenelightingData, transparencyPassType: G.transparencyPassType, terrainLinearDepthTexture: G.multipassTerrainParams.terrainLinearDepthTexture, geometryLinearDepthTexture: G.multipassGeometryParams.geometryLinearDepthTexture, multipassTerrainEnabled: G.multipassTerrainParams.multipassTerrainEnabled, cullAboveGround: G.multipassTerrainParams.cullAboveGround,
                multipassGeometryEnabled: G.multipassGeometryParams.multipassGeometryEnabled, highlightColorTexture: null
              }; G.rctx.bindVAO(); I = 5 !== G.pass && 7 !== G.pass; O = 6 !== G.pass; I && this._renderComponents(G, R, S, this._defaultRenderInstanceData); O && this._renderComponents(G, R, S, this._highlightRenderInstanceData); return I || O
            }; N.intersect = function (G, I, O, R) {
              if (this.baseMaterial.isVisible()) {
                var S = p.create(); n.subtract(S, R, O); var Q = T => {
                  this._instanceData.getCombinedModelTransform(T, M); G.transform.set(M); n.transformMat4(F, O,
                    G.transform.inverse); n.transformMat4(K, R, G.transform.inverse); const da = this._instanceData.getState(T), Y = this._instanceData.getLodLevel(T); v.assert(da & m.StateFlags.ACTIVE, "invalid instance state"); v.assert(0 <= Y && Y < this._levels.length, "invaid lod level"); this._levels[Y].intersect(G, I, F, K, T, this._metadata)
                }; this.baseMaterial.parameters.verticalOffset ? this.octree.forEach(Q) : this.octree.forEachAlongRay(O, S, Q)
              }
            }; N.queryDepthRange = function (G) { return this.queryDepthRangeOctree(G) }; N.notifyShaderTransformationChanged =
              function () { this.invalidateOctree() }; N.requestUpdateCycle = function (G = !1) { this._updateCyclesWithStaticCamera = -1; G && (this._needFullCycle = !0); this.needsUpdates && this._context.requestRender() }; N.invalidateOctree = function () { this._octree && (this._octree.destroy(), this._octree = null) }; N.buildOctree = function () {
                const G = new e.InstanceOctree(this._instanceData, this.baseBoundingSphere); var I = this._instanceData; I = I.view ? I.view.state : null; for (let O = 0; O < this._instanceData.capacity; ++O)I.get(O) & m.StateFlags.ACTIVE &&
                  G.addInstance(O); return G
              }; N.queryDepthRangeOctree = function (G) { var I = G.eye; const O = G.viewForward; var R = this.octree.findClosest(O, 1, G.frustum); const S = this.octree.findClosest(O, -1, G.frustum); return null != R && null != S ? (this._instanceData.view.boundingSphere.getVec(R, J), n.subtract(J, J, I), R = n.dot(J, O) - J[3], this._instanceData.view.boundingSphere.getVec(S, J), n.subtract(J, J, I), I = n.dot(J, O) + J[3], { near: Math.max(G.near, R), far: Math.min(G.far, I) }) : { near: Infinity, far: -Infinity } }; N.startUpdateCycle = function () {
              this._updateCyclesWithStaticCamera++;
                this._defaultRenderInstanceData.forEach(G => { G.startUpdateCylce() }); this._highlightRenderInstanceData.forEach(G => { G.startUpdateCylce() }); this.needsUpdates && this._context.requestRender()
              }; N.updateInstances = function (G, I) {
                const O = this._enableLevelSelection, R = this._levelSelector; R.updateCamera(G); this._defaultRenderInstanceData.forEach(fa => { fa.beginUpdate() }); this._highlightRenderInstanceData.forEach(fa => { fa.beginUpdate() }); G = this._instanceData; const S = this._instanceData.view, Q = G.capacity; let T = this._instanceIndex;
                I = Math.min(G.size, I); for (let fa = 0; fa < I; ++fa) {
                0 === T && this.startUpdateCycle(); const ha = S.state.get(T); var da = 0; if (ha & m.StateFlags.ALLOCATED) {
                  var Y = S.lodLevel.get(T); ha & m.StateFlags.DEFAULT_ACTIVE && this._defaultRenderInstanceData[Y].freeTail(); ha & m.StateFlags.HIGHLIGHT_ACTIVE && this._highlightRenderInstanceData[Y].freeTail(); ha & m.StateFlags.REMOVE ? G.freeInstance(T) : ha & m.StateFlags.VISIBLE ? (Y = 0, O && (S.modelOrigin.getVec(T, H), Y = R.selectLevel(H, G.getCombinedMedianScaleFactor(T))), da = ha & ~(m.StateFlags.ACTIVE |
                    m.StateFlags.TRANSFORM_CHANGED), 0 <= Y && (ha & m.StateFlags.HIGHLIGHT ? (C(this._highlightRenderInstanceData[Y], S, T), da |= m.StateFlags.HIGHLIGHT_ACTIVE) : (C(this._defaultRenderInstanceData[Y], S, T), da |= m.StateFlags.DEFAULT_ACTIVE)), S.state.set(T, da), S.lodLevel.set(T, Y)) : (da = ha & ~(m.StateFlags.ACTIVE | m.StateFlags.TRANSFORM_CHANGED), S.state.set(T, da)); this._octree && (Y = !!(ha & m.StateFlags.ACTIVE), da = !!(da & m.StateFlags.ACTIVE), !Y && da ? this._octree.addInstance(T) : Y && !da ? this._octree.removeInstance(T) : Y && da && ha & m.StateFlags.TRANSFORM_CHANGED &&
                      (this._octree.removeInstance(T), this._octree.addInstance(T))); T = (T + 1) % Q
                } else T = (T + 1) % Q, I++
                } this._instanceIndex = T; this._defaultRenderInstanceData.forEach(fa => { fa.endUpdate() }); this._highlightRenderInstanceData.forEach(fa => { fa.endUpdate() })
              }; N._renderComponents = function (G, I, O, R) { this.levels.forEach((S, Q) => { S.components.forEach(T => { this._renderComponent(G, I, O, R[Q], T, Q) }) }) }; N._renderComponent = function (G, I, O, R, S, Q) {
                if (0 !== R.size && S.material.requiresSlot(I)) {
                  var { rctx: T, pass: da } = G, Y = S.glMaterials.load(T,
                    da); if (!c.isNone(Y)) {
                      var fa = T.capabilities.instancing, ha = Y.beginSlot(O), ka = ha.program; ha.bindPipelineState(T, I); T.useProgram(ka); Y.bind(O, ha); T.bindVAO(S.vao); ha.ensureAttributeLocations(S.vao); G.isHighlightPass && d.bindOutputHighlight(ka, O); ha.bindDraw(O); h.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL && 0 === G.pass && (ka.setUniform4fv("externalColor", P[Math.min(Q, P.length - 1)]), ka.setUniform1i("colorMixMode", A.colorMixModes.replace)); G = R.capacity; I = R.headIndex; O = R.tailIndex; Q = R.firstIndex; var ea = this._glInstanceBufferLayout;
                      Y = (ba, aa) => { B.bindVertexBufferLayout(T, t.Default3D, R.buffer, ea, ba); fa.drawArraysInstanced(ha.primitiveType, 0, S.vertexCount, aa - ba); B.unbindVertexBufferLayout(T, t.Default3D, R.buffer, ea) }; S.material.parameters.transparent && null != Q ? I > O ? (v.assert(Q >= O && Q <= I, "invalid firstIndex"), Y(Q, I), Y(O, Q)) : I < O && (Q <= I ? (v.assert(0 <= Q && Q <= I, "invalid firstIndex"), Y(Q, I), Y(O, G), Y(0, Q)) : (v.assert(Q >= O && Q <= G, "invalid firstIndex"), Y(Q, G), Y(0, I), Y(O, Q))) : I > O ? Y(O, I) : I < O && (Y(0, I), Y(O, G)); T.bindVAO(null)
                    }
                }
              }; w._createClass(L, [{
                key: "levels",
                get: function () { return this._levels }
              }, { key: "baseBoundingBox", get: function () { return this._levels[this._levels.length - 1].boundingBox } }, { key: "baseBoundingSphere", get: function () { return this._levels[this._levels.length - 1].boundingSphere } }, { key: "baseMaterial", get: function () { return this._levels[this._levels.length - 1].components[0].material } }, { key: "slicePlaneEnabled", get: function () { return this._slicePlane }, set: function (G) { this._slicePlane = G } }, { key: "layerUid", get: function () { return this._metadata.layerUid } },
              { key: "instanceData", get: function () { return this._instanceData } }, { key: "memoryUsage", get: function () { const G = { cpu: 0, gpu: 0 }; this._defaultRenderInstanceData.forEach(I => { I = I.memoryUsage; G.cpu += I.cpu; G.gpu += I.gpu }); this._highlightRenderInstanceData.forEach(I => { I = I.memoryUsage; G.cpu += I.cpu; G.gpu += I.gpu }); return G } }, {
                key: "renderStats", get: function () {
                  const G = this._instanceData.size, I = []; this._levels.forEach((O, R) => {
                    R = this._defaultRenderInstanceData[R].size + this._highlightRenderInstanceData[R].size; O = O.triangleCount;
                    I.push({ renderedInstances: R, renderedTriangles: R * O, trianglesPerInstance: O })
                  }); return { totalInstances: G, renderedInstances: I.reduce((O, R) => O + R.renderedInstances, 0), renderedTriangles: I.reduce((O, R) => O + R.renderedTriangles, 0), levels: I }
                }
              }, { key: "slots", get: function () { return [3, 5] } }, { key: "needsHighlight", get: function () { return 0 < this._highlightRenderInstanceData.reduce((G, I) => G + I.size, 0) } }, { key: "needsUpdates", get: function () { return 0 < this._instanceData.size && 1 > this._updateCyclesWithStaticCamera } }, {
                key: "octree",
                get: function () { this._octree || (this._octree = this.buildOctree()); return this._octree }
              }]); return L
          }(); const H = p.create(), J = l.create(), M = u.create(), F = p.create(), K = p.create(), P = [[1, 0, 1, 1], [0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [1, 0, 0, 1]]; a.LodRenderer = E; a.setLevelSelectorFactory = function (L) { D = L }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/InstanceData": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/Evented ../../../../../chunks/mat3 ../../../../../chunks/mat3f64 ../../../../../chunks/mat4 ../../../../../chunks/mat4f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/buffer/BufferView ../../../support/mathUtils ../../../support/buffer/InterleavedLayout ../Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
        a.StateFlags = void 0; (function (x) { x[x.ALLOCATED = 1] = "ALLOCATED"; x[x.DEFAULT_ACTIVE = 2] = "DEFAULT_ACTIVE"; x[x.VISIBLE = 4] = "VISIBLE"; x[x.HIGHLIGHT = 8] = "HIGHLIGHT"; x[x.HIGHLIGHT_ACTIVE = 16] = "HIGHLIGHT_ACTIVE"; x[x.REMOVE = 32] = "REMOVE"; x[x.TRANSFORM_CHANGED = 64] = "TRANSFORM_CHANGED"; x[x.ACTIVE = 18] = "ACTIVE" })(a.StateFlags || (a.StateFlags = {})); let t = function (x) {
        this.localTransform = x.getField("localTransform", h.BufferViewMat4f64); this.globalTransform = x.getField("globalTransform",
          h.BufferViewMat4f64); this.modelOrigin = x.getField("modelOrigin", h.BufferViewVec3f64); this.model = x.getField("model", h.BufferViewMat3f); this.modelNormal = x.getField("modelNormal", h.BufferViewMat3f); this.modelScaleFactors = x.getField("modelScaleFactors", h.BufferViewVec2f); this.boundingSphere = x.getField("boundingSphere", h.BufferViewVec4f64); this.color = x.getField("color", h.BufferViewVec4f); this.featureAttribute = x.getField("featureAttribute", h.BufferViewVec4f); this.state = x.getField("state", h.BufferViewUint8);
          this.lodLevel = x.getField("lodLevel", h.BufferViewUint8)
        }; c = function (x) {
          function k(A, z) {
            var B = x.call(this) || this; B._capacity = 0; B._size = 0; B._next = 0; { let C = d.newLayout().mat4f64("localTransform").mat4f64("globalTransform").vec4f64("boundingSphere").vec3f64("modelOrigin").mat3f("model").mat3f("modelNormal").vec2f("modelScaleFactors"); 0 <= A.indexOf("color") && (C = C.vec4f("color")); 0 <= A.indexOf("featureAttribute") && (C = C.vec4f("featureAttribute")); A = C = C.u8("state").u8("lodLevel").alignTo(8) } B._layout = A; B._shaderTransformation =
              z; return B
          } w._inheritsLoose(k, x); var r = k.prototype; r.addInstance = function () { this._size + 1 > this._capacity && this.grow(); const A = this.findSlot(); this._view.state.set(A, a.StateFlags.ALLOCATED); this._size++; this.emit("instance-added", { index: A }); return A }; r.removeInstance = function (A) {
            const z = this._view.state; f.assert(0 <= A && A < this._capacity && z.get(A) & a.StateFlags.ALLOCATED, "invalid instance handle"); this.getStateFlag(A, a.StateFlags.ACTIVE) ? this.setStateFlags(A, a.StateFlags.REMOVE) : this.freeInstance(A); this.emit("instance-removed",
              { index: A })
          }; r.freeInstance = function (A) { const z = this._view.state; f.assert(0 <= A && A < this._capacity && z.get(A) & a.StateFlags.ALLOCATED, "invalid instance handle"); z.set(A, 0); this._size-- }; r.setLocalTransform = function (A, z, B = !0) { this._view.localTransform.setMat(A, z); B && this.updateModelTransform(A) }; r.getLocalTransform = function (A, z) { this._view.localTransform.getMat(A, z) }; r.setGlobalTransform = function (A, z, B = !0) { this._view.globalTransform.setMat(A, z); B && this.updateModelTransform(A) }; r.getGlobalTransform = function (A,
            z) { this._view.globalTransform.getMat(A, z) }; r.updateModelTransform = function (A) {
              const z = this._view; var B = v; const C = m; z.localTransform.getMat(A, e); z.globalTransform.getMat(A, g); const D = y.multiply(g, g, e); p.set(B, D[12], D[13], D[14]); z.modelOrigin.setVec(A, B); q.fromMat4(C, D); z.model.setMat(A, C); B = b.scaleFromMatrix(v, D); B.sort(); z.modelScaleFactors.set(A, 0, B[1]); z.modelScaleFactors.set(A, 1, B[2]); q.invert(C, C); q.transpose(C, C); z.modelNormal.setMat(A, C); this.setStateFlags(A, a.StateFlags.TRANSFORM_CHANGED);
              this.emit("instance-transform-changed", { index: A })
            }; r.getModelTransform = function (A, z) { const B = this._view; B.model.getMat(A, m); B.modelOrigin.getVec(A, v); z[0] = m[0]; z[1] = m[1]; z[2] = m[2]; z[3] = 0; z[4] = m[3]; z[5] = m[4]; z[6] = m[5]; z[7] = 0; z[8] = m[6]; z[9] = m[7]; z[10] = m[8]; z[11] = 0; z[12] = v[0]; z[13] = v[1]; z[14] = v[2]; z[15] = 1 }; r.applyShaderTransformation = function (A, z) { this._shaderTransformation && this._shaderTransformation.applyTransform(this, A, z) }; r.getCombinedModelTransform = function (A, z) {
              this.getModelTransform(A, z); this._shaderTransformation &&
                this._shaderTransformation.applyTransform(this, A, z); return z
            }; r.getCombinedLocalTransform = function (A, z) { this._view.localTransform.getMat(A, z); this._shaderTransformation && this._shaderTransformation.applyTransform(this, A, z); return z }; r.getCombinedMaxScaleFactor = function (A) { let z = this._view.modelScaleFactors.get(A, 1); this._shaderTransformation && (A = this._shaderTransformation.scaleFactor(v, this, A), z *= Math.max(A[0], A[1], A[2])); return z }; r.getCombinedMedianScaleFactor = function (A) {
              let z = this._view.modelScaleFactors.get(A,
                0); this._shaderTransformation && (A = this._shaderTransformation.scaleFactor(v, this, A), A.sort(), z *= A[1]); return z
            }; r.getModel = function (A, z) { this._view.model.getMat(A, z) }; r.setFeatureAttribute = function (A, z) { this._view.featureAttribute.setVec(A, z) }; r.getFeatureAttribute = function (A, z) { this._view.featureAttribute.getVec(A, z) }; r.setColor = function (A, z) { this._view.color.setVec(A, z) }; r.getColor = function (A, z) { this._view.color.getVec(A, z) }; r.setVisible = function (A, z) {
            z !== this.getVisible(A) && (this.setStateFlag(A,
              a.StateFlags.VISIBLE, z), this.emit("instance-visibility-changed", { index: A }))
            }; r.getVisible = function (A) { return this.getStateFlag(A, a.StateFlags.VISIBLE) }; r.setHighlight = function (A, z) { z !== this.getHighlight(A) && (this.setStateFlag(A, a.StateFlags.HIGHLIGHT, z), this.emit("instance-highlight-changed", { index: A })) }; r.getHighlight = function (A) { return this.getStateFlag(A, a.StateFlags.HIGHLIGHT) }; r.getState = function (A) { return this._view.state.get(A) }; r.getLodLevel = function (A) { return this._view.lodLevel.get(A) };
          r.countFlags = function (A) { let z = 0; for (let B = 0; B < this._capacity; ++B)this.getState(B) & A && ++z; return z }; r.setStateFlags = function (A, z) { const B = this._view.state; z |= B.get(A); B.set(A, z) }; r.clearStateFlags = function (A, z) { const B = this._view.state; z = B.get(A) & ~z; B.set(A, z) }; r.setStateFlag = function (A, z, B) { B ? this.setStateFlags(A, z) : this.clearStateFlags(A, z) }; r.getStateFlag = function (A, z) { return !!(this._view.state.get(A) & z) }; r.grow = function () {
            const A = Math.max(1024, Math.floor(2 * this._capacity)), z = this._layout.createBuffer(A);
            if (this._buffer) { const B = new Uint8Array(this._buffer.buffer); (new Uint8Array(z.buffer)).set(B) } this._capacity = A; this._buffer = z; this._view = new t(this._buffer)
          }; r.findSlot = function () { const A = this._view.state; let z = this._next; for (; A.get(z) & a.StateFlags.ALLOCATED;)z = (z + 1) % this._capacity; this._next = (z + 1) % this._capacity; return z }; w._createClass(k, [{ key: "capacity", get: function () { return this._capacity } }, { key: "size", get: function () { return this._size } }, { key: "buffer", get: function () { return this._buffer.buffer } },
          { key: "view", get: function () { return this._view } }]); return k
        }(c); const v = l.create(), m = u.create(), e = n.create(), g = n.create(); a.InstanceData = c; a.InstanceDataView = t; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/InstanceOctree": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/mat4f64 ../../../../../chunks/vec3 ../../../../../chunks/sphere ../../../support/mathUtils ../Octree".split(" "), function (a, w, c, q, u, y,
        n) {
          n = function (p) {
            function l(b, d) { var f = p.call(this, t => u.wrap(f._instanceData.view.boundingSphere.getVec(t, f._tmpSphere)), { maximumDepth: 25 }) || this; f._tmpSphere = u.create(); f._tmpMat4 = c.create(); f._instanceData = b; f._boundingSphere = d; return f } w._inheritsLoose(l, p); var h = l.prototype; h.addInstance = function (b) {
              const d = this._instanceData.view.boundingSphere, f = this._instanceData.getCombinedModelTransform(b, this._tmpMat4); q.transformMat4(this._tmpSphere, this._boundingSphere.center, f); this._tmpSphere[3] = this._boundingSphere.radius *
                y.maxScale(f); d.setVec(b, this._tmpSphere); this.add([b])
            }; h.removeInstance = function (b) { this.remove([b]) }; return l
          }(n); a.InstanceOctree = n; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/LevelSelector": function () {
      define(["exports", "../Camera"], function (a, w) {
        let c = function () {
          function q(y, n) { this.thresholdScale = 1; this._camera = new w; this._worldSpaceRadius = y; this._thresholds = n.map(p => p) } var u = q.prototype; u.updateCamera = function (y) { this._camera.copyFrom(y) };
          u.selectLevel = function (y, n) { y = this._camera.computeScreenPixelSizeAt(y); n = this._worldSpaceRadius * n / y; y = this._thresholds; let p = -1; for (let l = 0; l < y.length; ++l)n >= y[l] * this.thresholdScale && (p = l); return p }; return q
        }(); a.LevelSelector = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/LodLevel": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/maybe ../../../../../core/promiseUtils ../../../../../chunks/vec3f64 ../../../../../geometry/support/aaBoundingBox ./LodComponentData".split(" "),
        function (a, w, c, q, u, y, n) {
          let p = function () {
            function l(b, d) { this.minScreenSpaceRadius = b; this.components = d } l.create = function () {
              var b = w._asyncToGenerator(function* (d, f, t) {
                const v = yield Promise.allSettled(f.components.map(e => d.schedule(() => new n.LodComponentData(d, e), t))), m = v.map(e => "fulfilled" === e.status ? e.value : null).filter(e => e); if (q.isAborted(t) || m.length !== v.length) { m.forEach(e => e.destroy()); q.throwIfAborted(t); for (const e of v) if ("rejected" === e.status) throw e.reason; } return new l(f.minScreenSpaceRadius,
                  m)
              }); return function (d, f, t) { return b.apply(this, arguments) }
            }(); var h = l.prototype; h.destroy = function () { this.components.forEach(b => b.destroy()) }; h.intersect = function (b, d, f, t, v, m) { this.components.forEach(e => e.intersect(b, d, f, t, v, m)) }; w._createClass(l, [{ key: "boundingBox", get: function () { if (c.isNone(this._boundingBox)) { const b = y.empty(); this.components.forEach(d => { c.isSome(d.boundingInfo) && (y.expandWithVec3(b, d.boundingInfo.bbMin), y.expandWithVec3(b, d.boundingInfo.bbMax)) }); this._boundingBox = b } return this._boundingBox } },
            { key: "boundingSphere", get: function () { if (c.isNone(this._boundingSphere)) { const b = this.boundingBox, d = u.create(); y.center(b, d); this._boundingSphere = { center: d, radius: .5 * y.diameter(b) } } return this._boundingSphere } }, { key: "triangleCount", get: function () { return this.components.reduce((b, d) => b + d.triangleCount, 0) } }]); return l
          }(); a.LodLevel = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/LodComponentData": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../support/buffer/glUtil ../DefaultVertexAttributeLocations ../GLMaterials ../Intersector ../../../../webgl/BufferObject ../../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p) {
          let l = function () {
            function h(d, f) {
              const t = d.renderContext.rctx, { geometry: v, material: m } = f; this._materialRepository = d.materialRep; m.setParameters({ instancedDoublePrecision: !0 }); d = m.createBufferWriter(); f = d.vertexBufferLayout; const e = d.elementCount(v), g = d.allocate(e); d.write({}, v, g, 0); this.geometry = v; this.material = m; this.glMaterials = new u.GLMaterials(m, this._materialRepository); this.vertexBufferLayout = f; this.vbo = n.createVertex(t, 35044, g.buffer); this.vao = new p(t, q.Default3D, { geometry: c.glLayout(f) },
                { geometry: this.vbo }); this.vertexCount = e
            } var b = h.prototype; b.destroy = function () { this.glMaterials.destroy(); this.vbo.dispose(); this.vao.dispose() }; b.intersect = function (d, f, t, v, m, e) {
              const g = this.geometry.id; this.material.intersect(this.geometry, null, d.transform.transform, d, t, v, (x, k, r, A, z) => {
              0 <= x && (null == f || f(d.rayBegin, d.rayEnd, x)) && (r = { layerUid: e.layerUid, graphicUid: e.graphicUid(m), geometryId: g, triangleNr: r }, (null == d.results.min.drapedLayerOrder || z >= d.results.min.drapedLayerOrder) && (null == d.results.min.dist ||
                x < d.results.min.dist) && d.results.min.set(6, r, x, k, d.transform.transform, z), 0 !== d.options.store && (null == d.results.max.drapedLayerOrder || z >= d.results.max.drapedLayerOrder) && (null == d.results.max.dist || x > d.results.max.dist) && d.results.max.set(6, r, x, k, d.transform.transform, z), 2 === d.options.store && (A = y.newIntersectorResult(d.results.min.ray), A.set(6, r, x, k, d.transform.transform, z), d.results.all.push(A)))
              })
            }; w._createClass(h, [{ key: "boundingInfo", get: function () { return this.geometry.boundingInfo } }, {
              key: "triangleCount",
              get: function () { return this.vertexCount / 3 }
            }]); return h
          }(); a.LodComponentData = l; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/RenderInstanceData": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../geometry/support/buffer/BufferView", "../Util", "./BackedBufferObject"], function (a, w, c, q, u) {
        let y = function (p) {
        this.modelOriginHi = p.getField("modelOriginHi", c.BufferViewVec3f); this.modelOriginLo = p.getField("modelOriginLo",
          c.BufferViewVec3f); this.model = p.getField("model", c.BufferViewMat3f); this.modelNormal = p.getField("modelNormal", c.BufferViewMat3f); this.color = p.getField("instanceColor", c.BufferViewVec4f); this.featureAttribute = p.getField("instanceFeatureAttribute", c.BufferViewVec4f)
        }, n = function () {
          function p(h, b) { this._tailIndex = this._headIndex = 0; this._captureFirstIndex = !0; this._updating = !1; this._prevHeadIndex = 0; this._resized = !1; this._rctx = h; this._instanceBufferLayout = b; this._elementSize = b.stride; this._capacity = 1 } var l =
            p.prototype; l.destroy = function () { this._buffer && this._buffer.destroy() }; l.reset = function () { this._tailIndex = this._headIndex = 0; this._firstIndex = null }; l.startUpdateCylce = function () { this._captureFirstIndex = !0 }; l.beginUpdate = function () { q.assert(!this._updating, "already updating"); this._updating = !0; this._prevHeadIndex = this._headIndex }; l.endUpdate = function () {
              q.assert(this._updating, "not updating"); this.size < .3 * this.capacity && this.shrink(); this._resized ? (this._buffer.transferAll(), this._resized = !1) : this.transferRange(this._prevHeadIndex,
                this._headIndex); this._updating = !1
            }; l.allocateHead = function () { q.assert(this._updating, "not updating"); this.isFull && this.grow(); const h = this.headIndex; this._captureFirstIndex && (this._firstIndex = h, this._captureFirstIndex = !1); this.incrementHead(); q.assert(this._headIndex !== this._tailIndex, "invalid pointers"); return h }; l.freeTail = function () {
              q.assert(this._updating, "not updating"); q.assert(0 < this.size, "invalid size"); const h = this._tailIndex === this._firstIndex; this.incrementTail(); h && (this._firstIndex =
                this._tailIndex)
            }; l.grow = function () { this.resize(Math.max(1024, Math.floor(2 * this._capacity))) }; l.shrink = function () { this.resize(Math.max(1024, Math.floor(.5 * this._capacity))) }; l.resize = function (h) {
              q.assert(this._updating, "not updating"); if (h !== this._capacity) {
                var b = new u(this._rctx, this._elementSize, h); if (this._buffer) {
                this._firstIndex && (this._firstIndex = (this._firstIndex + this._capacity - this._tailIndex) % this._capacity); const d = this.size, f = this.compactInstances(b); q.assert(f === d, "invalid compaction");
                  this._buffer.destroy(); this._tailIndex = 0; this._headIndex = f; this._prevHeadIndex = 0
                } this._resized = !0; this._capacity = h; this._buffer = b; this._view = new y(this._instanceBufferLayout.createView(this._buffer.array))
              }
            }; l.compactInstances = function (h) { const b = this._headIndex, d = this._tailIndex; return d < b ? (this._buffer.copyRange(d, b, h), b - d) : d > b ? (this._buffer.copyRange(d, this._capacity, h), 0 < b && this._buffer.copyRange(0, b, h, this._capacity - d), b + (this._capacity - d)) : 0 }; l.incrementHead = function (h = 1) {
            this._headIndex = (this._headIndex +
              h) % this._capacity
            }; l.incrementTail = function (h = 1) { this._tailIndex = (this._tailIndex + h) % this._capacity }; l.transferRange = function (h, b) { h < b ? this._buffer.transferRange(h, b) : h > b && (0 < b && this._buffer.transferRange(0, b), this._buffer.transferRange(h, this._capacity)) }; w._createClass(p, [{ key: "buffer", get: function () { return this._buffer.buffer } }, { key: "view", get: function () { return this._view } }, { key: "capacity", get: function () { return this._capacity } }, {
              key: "size", get: function () {
                const h = this._headIndex, b = this._tailIndex;
                return h >= b ? h - b : h + this._capacity - b
              }
            }, { key: "isEmpty", get: function () { return this._headIndex === this._tailIndex } }, { key: "isFull", get: function () { return this._tailIndex === (this._headIndex + 1) % this._capacity } }, { key: "headIndex", get: function () { return this._headIndex } }, { key: "tailIndex", get: function () { return this._tailIndex } }, { key: "firstIndex", get: function () { return this._firstIndex } }, { key: "memoryUsage", get: function () { return this._buffer ? this._buffer.memoryUsage : { cpu: 0, gpu: 0 } } }]); return p
        }(); a.RenderInstanceData =
          n; a.RenderInstanceDataView = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/lodRendering/BackedBufferObject": function () {
      define(["../../../../../chunks/_rollupPluginBabelHelpers", "../../../../webgl/BufferObject"], function (a, w) {
        return function () {
          function c(u, y, n) { this._elementSize = y; this._buffer = w.createVertex(u, 35044); this.resize(n) } var q = c.prototype; q.destroy = function () { this._buffer.dispose() }; q.copyRange = function (u, y, n, p = 0) {
            u = new Uint8Array(this.array, u * this.elementSize,
              (y - u) * this.elementSize); (new Uint8Array(n.array, p * this.elementSize)).set(u)
          }; q.transferAll = function () { this._buffer.setData(this._array) }; q.transferRange = function (u, y) { u *= this._elementSize; this._buffer.setSubData(this._array, u, u, y * this._elementSize) }; q.resize = function (u) {
            const y = u * this._elementSize, n = new ArrayBuffer(y); this._array && (u >= this._capacity ? (new Uint8Array(n)).set(new Uint8Array(this._array)) : (new Uint8Array(n)).set((new Uint8Array(this._array)).subarray(0, u * this._elementSize))); this._array =
              n; this._buffer.setData(y); this._capacity = u
          }; a._createClass(c, [{ key: "elementSize", get: function () { return this._elementSize } }, { key: "capacity", get: function () { return this._capacity } }, { key: "array", get: function () { return this._array } }, { key: "buffer", get: function () { return this._buffer } }, { key: "memoryUsage", get: function () { return { cpu: this._capacity * this._elementSize, gpu: this._capacity * this._elementSize } } }]); return c
        }()
      })
    }, "esri/views/3d/layers/graphics/Graphics3DPathSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Error ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/mat2 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f32 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../layers/graphics/dehydratedFeatures ./elevationAlignmentUtils ./ElevationContext ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ../support/FastSymbolUpdates ../../webgl-engine/lib/Object3D ../../webgl-engine/lib/PathGeometry ../../webgl-engine/lib/pathGeometryUtils ../../webgl-engine/materials/DefaultMaterial ../../webgl-engine/materials/PathMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          function D(I, O, R) {
            switch (O) {
              case "world": for (const S of I.vertices) l.add(L, S.pos, I.offset), R.worldUpAtPosition(L, P), S.setFrameFromUpVector(P), S.computeRotationAxisAndAngleFromUpVector(); break; case "path": l.add(L, I.vertices[0].pos, I.offset); R.worldUpAtPosition(L, P); z.computeMinimumRotationTangentFrame(I, P); for (const S of I.vertices) I = Math.sign(l.dot(S.frame.right, S.vRight)), l.cross(S.rotationFrame.up, S.vRight, S.vLeft), l.scale(S.rotationFrame.up,
                S.rotationFrame.up, I), l.normalize(S.rotationFrame.up, S.rotationFrame.up), O = l.dot(S.rotationFrame.up, S.frame.up), R = l.dot(S.rotationFrame.up, S.frame.right), l.scale(L, S.frame.up, -R), l.scale(N, S.frame.right, O), l.add(L, L, N), l.normalize(S.rotationFrame.right, L), z.vertexSpaceToProfileSpace(S.rotationRight, S.frame, S.rotationFrame.right), l.negate(L, S.vLeft), S.rotationAngle = -I * (Math.PI - q.acosClamped(l.dot(L, S.vRight))), 0 < Math.abs(S.rotationAngle) && (I = q.reciprocalClamped(Math.cos(.5 * S.rotationAngle)), y.set(S.miterStretch,
                  1 + (I - 1) * S.rotationRight[0] * S.rotationRight[0], (I - 1) * S.rotationRight[0] * S.rotationRight[1], (I - 1) * S.rotationRight[0] * S.rotationRight[1], 1 + (I - 1) * S.rotationRight[1] * S.rotationRight[1])), S.maxStretchDistance = Math.abs(Math.min(S.vLeftLength, S.vRightLength) * q.reciprocalClamped(Math.cos(.5 * (Math.PI - S.rotationAngle))))
            }
          } function E(I, O, R) { switch (I) { case "symbol-value": return R; case "proportional": return O; default: return I } } function H(I, O, R, S) {
            I = I.stageObject; const Q = I.geometryRecords; var T = 0; F.spatialReference =
              S.spatialReference; for (const ka of Q) {
                const ea = ka.geometry; if (!A.isPathGeometry(ea)) continue; const ba = ea.path, aa = ba.builder.path; K.spatialReference = ea.geometrySR; { var da = aa; var Y = O, fa = R, ha = S; let W = 0; for (const U of da.vertices) v.evaluateElevationInfoAtPoint(U.posES, fa, Y, ha, G), W += G.sampledElevation, l.add(P, U.pos, da.offset), ha.setAltitude(P, G.z), l.subtract(U.pos, P, da.offset); da.updatePathVertexInformation(); da = W / da.vertices.length } T += da; "world" !== ea.upVectorAlignment && D(aa, ea.upVectorAlignment, S); ba.onPathChanged();
                ea.invalidateBoundingInfo(); I.geometryVertexAttrsUpdated(ka)
              } return T / Q.length
          } const J = ["polyline"]; let M = function (I) {
            function O(S, Q, T, da) { S = I.call(this, S, Q, T, da) || this; S._intrinsicSize = p.fromValues(1, 1); S.upVectorAlignment = "path"; S.stencilWidth = .1; S.ensureDrapedStatus(!1); return S } w._inheritsLoose(O, I); var R = O.prototype; R.doLoad = function () {
              var S = w._asyncToGenerator(function* () {
                const Q = u.isSome(this.symbolLayer.width) ? this.symbolLayer.width : this.symbolLayer.height, T = u.isSome(this.symbolLayer.height) ?
                  this.symbolLayer.height : Q; this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [Q, 1, T], unitInMeters: this._context.renderCoordsHelper.unitInMeters, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: !0, color: !0, opacity: !0, rotation: !1 } }; this._fastUpdates = this._context.renderer && this._context.renderer.visualVariables && 0 < this._context.renderer.visualVariables.length ? k.initFastSymbolUpdatesState(this._context.renderer, this._vvConvertOptions) : { enabled: !1 }; var da = this.symbolLayer.anchor ||
                    "center"; this.upVectorAlignment = "path"; "heading" === this.symbolLayer.profileRotation && (this.upVectorAlignment = "world"); var Y = this.symbolLayer.profile || "circle"; switch (Y) { default: this._profile = z.Profile.circle(10); break; case "quad": this._profile = z.Profile.rect() }var fa = [0, 0]; "center" !== da && (fa = { left: [.5, 0], right: [-.5, 0], top: [0, -.5], bottom: [0, .5] }[da], this._profile.translate(fa[0], fa[1])); switch (this.symbolLayer.join || "simple") {
                      case "round": this._extruder = new z.MiterExtruder(0, 3); break; case "bevel": this._extruder =
                        new z.MiterExtruder(0, 1); break; case "miter": this._extruder = new z.MiterExtruder(.8 * Math.PI, 1); break; default: this._extruder = new z.SimpleExtruder
                    }da = this.symbolLayer.cap || "butt"; switch (da) {
                      case "none": this._startCap = new z.NoCapBuilder; this._endCap = new z.NoCapBuilder; break; default: this._startCap = new z.TriangulationCapBuilder(this._profile, 0); this._endCap = new z.TriangulationCapBuilder(this._profile, 0, !0); break; case "square": this._startCap = new z.TriangulationCapBuilder(this._profile, -.5); this._endCap = new z.TriangulationCapBuilder(this._profile,
                        .5, !0); break; case "round": Y = "quad" === Y ? !0 : !1, this._startCap = new z.RoundCapBuilder({ profile: this._profile, flip: !1, breakNormals: Y, subdivisions: 3 }), this._endCap = new z.RoundCapBuilder({ profile: this._profile, flip: !0, breakNormals: Y, subdivisions: 3 })
                    }Y = u.get(this.symbolLayer, "material", "color"); fa = this._getCombinedOpacityAndColor(Y); Y = b.fromArray(fa); fa = fa[3]; const ha = 1 > fa || this.needsDrivenTransparentPass; da = {
                      diffuse: Y, ambient: Y, opacity: fa, transparent: ha, vertexColors: !1, slicePlaneEnabled: this._context.slicePlaneEnabled,
                      castShadows: this.symbolLayer.castShadows, cullFace: ha || "none" === da ? 0 : 2, offsetTransparentBackfaces: !0
                    }; if (!this._drivenProperties.size && (n.set(this._intrinsicSize, Q, T), !x.isValidSize(this._intrinsicSize[0]) || !x.isValidSize(this._intrinsicSize[1]))) throw new c("graphics3dpathsymbollayer:invalid-size", "Symbol sizes may not be negative values"); this._fastUpdates.enabled && this._fastUpdates.visualVariables.size || n.scale(this._intrinsicSize, this._intrinsicSize, 1 / this._context.renderCoordsHelper.unitInMeters);
                this._fastUpdates.enabled ? (Object.assign(da, this._fastUpdates.materialParameters, { size: [this._intrinsicSize[0], this._intrinsicSize[1], 0] }), this._material = new C.PathMaterial(da)) : (da.vertexColors = this._drivenProperties.color || this._drivenProperties.opacity, this._material = new B.DefaultMaterial(da)); this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0 }); this._context.stage.add(this._material)
              }); return function () { return S.apply(this, arguments) }
            }(); R.destroy =
              function () { I.prototype.destroy.call(this); this._context.stage.remove(this._material); this._material = null }; R.createGraphics3DGraphic = function (S) { const Q = S.graphic; if (!this._validateGeometry(Q.geometry, J, this.symbolLayer.type)) return null; const T = this.setGraphicElevationContext(Q, new m.ElevationContext); return this._createAs3DShape(Q, S.renderingInfo, T, Q.uid) }; R.layerOpacityChanged = function () {
                var S = u.get(this.symbolLayer, "material", "color"); S = this._getCombinedOpacity(S); this._material.setParameters({
                  opacity: S,
                  transparent: 1 > S || this.needsDrivenTransparentPass
                }); return !0
              }; R.layerElevationInfoChanged = function (S, Q) { return this.updateGraphics3DGraphicElevationInfo(S, Q, v.needsElevationUpdates3D) }; R.slicePlaneEnabledChanged = function () { this._material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); return !0 }; R.physicalBasedRenderingChanged = function () { this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: !0 }); return !0 }; R.pixelRatioChanged = function () { return !0 };
            R.applyRendererDiff = function (S, Q) { for (const T in S.diff) switch (T) { case "visualVariables": if (k.updateFastSymbolUpdatesState(this._fastUpdates, Q, this._vvConvertOptions)) this._material.setParameters(this._fastUpdates.materialParameters); else return 0; break; default: return 0 }return 2 }; R.getVertexData = function (S) {
              let Q = 0; const T = S.paths, da = [], Y = S.spatialReference, fa = this._context.elevationProvider.spatialReference, ha = this._context.renderCoordsHelper.spatialReference; for (var ka of T) Q += ka.length; ka = new Float64Array(3 *
                Q); const ea = new Float64Array(3 * Q), ba = new Float64Array(3 * Q); let aa = 0; for (const W of T) { da.push({ index: aa, numVertices: W.length }); for (const U of W) ka[aa++] = U[0], ka[aa++] = U[1], ka[aa++] = S.hasZ ? U[2] : 0 } S = !0; Y.equals(fa) ? this._copyVertices(ka, 0, ea, 0, Q) : S = d.projectBuffer(ka, Y, 0, ea, fa, 0, Q); fa.equals(ha) ? this._copyVertices(ea, 0, ba, 0, Q) : d.projectBuffer(ea, fa, 0, ba, ha, 0, Q); return { pathVertexDataInfos: da, vertexDataGS: ka, vertexDataES: ea, vertexDataRS: ba, projectionSuccess: S, terrainElevation: 0 }
            }; R._copyVertices = function (S,
              Q, T, da, Y) { Q *= 3; da *= 3; for (let fa = 0; fa < Y; ++fa)T[da++] = S[Q++], T[da++] = S[Q++], T[da++] = S[Q++] }; R._createAs3DShape = function (S, Q, T, da) {
                var Y = S.geometry, fa = []; const ha = [], ka = [], ea = Y.spatialReference, ba = f.create(), aa = this._context.renderCoordsHelper; K.spatialReference = ea; const W = this.getVertexData(Y); if (!W.projectionSuccess) return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"), null; if (0 < W.pathVertexDataInfos.length) {
                  for (Y = 0; Y < W.pathVertexDataInfos.length; ++Y) {
                    var U =
                      W.pathVertexDataInfos[Y], X = U.index; U = U.numVertices; if (2 > U) continue; if (u.isSome(this._context.clippingExtent) && (f.empty(ba), f.expandWithBuffer(ba, W.vertexDataES, 3 * X, U), !f.intersectsClippingArea(ba, this._context.clippingExtent))) continue; var Z = []; for (var ia = X; ia < X + 3 * U;) {
                        const ra = ia++, Aa = ia++, za = ia++, Ka = new z.PathVertex; l.set(Ka.posGS, W.vertexDataGS[ra], W.vertexDataGS[Aa], W.vertexDataGS[za]); l.set(Ka.posES, W.vertexDataES[ra], W.vertexDataES[Aa], W.vertexDataES[za]); const Ea = v.evaluateElevationAlignmentAtPoint(Ka.posES,
                          this._context.elevationProvider, T, aa); l.set(P, W.vertexDataRS[ra], W.vertexDataRS[Aa], W.vertexDataRS[za]); aa.setAltitude(P, Ea); l.set(Ka.pos, P[0], P[1], P[2]); Z.push(Ka)
                      } X = new z.Path(Z); D(X, this.upVectorAlignment, this._context.renderCoordsHelper); X = new z.Builder(X, this._profile, this._extruder, this._startCap, this._endCap); U = null; this._fastUpdates.enabled ? (ia = this._fastUpdates.visualVariables, U = ia.size ? g.getAttributeValue(ia.size.field, S) : 0, Z = ia.color ? g.getAttributeValue(ia.color.field, S) : 0, ia = ia.opacity ?
                        g.getAttributeValue(ia.opacity.field, S) : 0, U = new z.FastUpdatePathGeometry(X, U, Z, ia)) : (U = [this._intrinsicSize[0], this._intrinsicSize[1]], this._drivenProperties.size && (U[0] *= E(Q.size[0], "symbol-value" === Q.size[2] ? this.symbolLayer.height || 0 : Q.size[2], this.symbolLayer.width || 0), U[1] *= E(Q.size[2], "symbol-value" === Q.size[0] ? this.symbolLayer.width || 0 : Q.size[0], this.symbolLayer.height || 0)), Z = null, this._drivenProperties.color && (Z = Q.color), this._drivenProperties.opacity && null != Q.opacity && (Z = Z ? [Z[0], Z[1], Z[2],
                        Q.opacity] : [1, 1, 1, Q.opacity]), X = new z.StaticPathGeometry(X), X.bake(U), Z && X.bakeVertexColors(Z), U = X); const { vertexAttributes: la, indices: ma } = U.createGeometryData(); X = new A.PathGeometry(la, ma, U, ea, this.upVectorAlignment, this.stencilWidth); fa.push(X); ha.push(this._material); ka.push(U.xform)
                  } if (0 < fa.length) return S = new r.Object3D({ geometries: fa, materials: ha, transformations: ka, metadata: { layerUid: this._context.layer.uid, graphicUid: da } }), fa = new e.Graphics3DObject3DGraphicLayer(this, S, fa, null, null, H, T), fa.alignedSampledElevation =
                    W.terrainElevation, fa.needsElevationUpdates = v.needsElevationUpdates3D(T.mode), fa
                } else 0 !== Y.paths.length && Y.paths.some(la => 0 < la.length) || this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)"); return null
              }; return O
          }(g.Graphics3DSymbolLayer); const F = t.makeDehydratedPoint(0, 0, 0, null), K = t.makeDehydratedPoint(0, 0, 0, null), P = b.create(), L = h.create(), N = h.create(), G = new v.SampleElevationInfo; a.Graphics3DPathSymbolLayer = M; a.NUM_CIRCLE_PROFILE_SUBDIVISIONS = 10; a.NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS =
            3; a.NUM_ROUND_JOIN_SUBDIVISIONS = 3; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/mat2": function () {
      define(["exports", "./common"], function (a, w) {
        function c(C, D) { C[0] = D[0]; C[1] = D[1]; C[2] = D[2]; C[3] = D[3]; return C } function q(C) { C[0] = 1; C[1] = 0; C[2] = 0; C[3] = 1; return C } function u(C, D, E, H, J) { C[0] = D; C[1] = E; C[2] = H; C[3] = J; return C } function y(C, D) { if (C === D) { const E = D[1]; C[1] = D[2]; C[2] = E } else C[0] = D[0], C[1] = D[2], C[2] = D[1], C[3] = D[3]; return C } function n(C, D) {
          const E = D[0], H = D[1], J = D[2]; D = D[3]; let M =
            E * D - J * H; if (!M) return null; M = 1 / M; C[0] = D * M; C[1] = -H * M; C[2] = -J * M; C[3] = E * M; return C
        } function p(C, D) { const E = D[0]; C[0] = D[3]; C[1] = -D[1]; C[2] = -D[2]; C[3] = E; return C } function l(C) { return C[0] * C[3] - C[2] * C[1] } function h(C, D, E) { const H = D[0], J = D[1], M = D[2]; D = D[3]; const F = E[0], K = E[1], P = E[2]; E = E[3]; C[0] = H * F + M * K; C[1] = J * F + D * K; C[2] = H * P + M * E; C[3] = J * P + D * E; return C } function b(C, D, E) { const H = D[0], J = D[1], M = D[2]; D = D[3]; const F = Math.sin(E); E = Math.cos(E); C[0] = H * E + M * F; C[1] = J * E + D * F; C[2] = H * -F + M * E; C[3] = J * -F + D * E; return C } function d(C,
          D, E) { const H = D[1], J = D[2], M = D[3], F = E[0]; E = E[1]; C[0] = D[0] * F; C[1] = H * F; C[2] = J * E; C[3] = M * E; return C } function f(C, D) { const E = Math.sin(D); D = Math.cos(D); C[0] = D; C[1] = E; C[2] = -E; C[3] = D; return C } function t(C, D) { C[0] = D[0]; C[1] = 0; C[2] = 0; C[3] = D[1]; return C } function v(C) { return "mat2(" + C[0] + ", " + C[1] + ", " + C[2] + ", " + C[3] + ")" } function m(C) { return Math.sqrt(C[0] ** 2 + C[1] ** 2 + C[2] ** 2 + C[3] ** 2) } function e(C, D, E, H) { C[2] = H[2] / H[0]; E[0] = H[0]; E[1] = H[1]; E[3] = H[3] - C[2] * E[1]; return [C, D, E] } function g(C, D, E) {
          C[0] = D[0] + E[0]; C[1] = D[1] +
            E[1]; C[2] = D[2] + E[2]; C[3] = D[3] + E[3]; return C
          } function x(C, D, E) { C[0] = D[0] - E[0]; C[1] = D[1] - E[1]; C[2] = D[2] - E[2]; C[3] = D[3] - E[3]; return C } function k(C, D) { return C[0] === D[0] && C[1] === D[1] && C[2] === D[2] && C[3] === D[3] } function r(C, D) {
            const E = C[0], H = C[1], J = C[2]; C = C[3]; const M = D[0], F = D[1], K = D[2]; D = D[3]; return Math.abs(E - M) <= w.EPSILON * Math.max(1, Math.abs(E), Math.abs(M)) && Math.abs(H - F) <= w.EPSILON * Math.max(1, Math.abs(H), Math.abs(F)) && Math.abs(J - K) <= w.EPSILON * Math.max(1, Math.abs(J), Math.abs(K)) && Math.abs(C - D) <= w.EPSILON *
              Math.max(1, Math.abs(C), Math.abs(D))
          } function A(C, D, E) { C[0] = D[0] * E; C[1] = D[1] * E; C[2] = D[2] * E; C[3] = D[3] * E; return C } function z(C, D, E, H) { C[0] = D[0] + E[0] * H; C[1] = D[1] + E[1] * H; C[2] = D[2] + E[2] * H; C[3] = D[3] + E[3] * H; return C } const B = Object.freeze({ __proto__: null, copy: c, identity: q, set: u, transpose: y, invert: n, adjoint: p, determinant: l, multiply: h, rotate: b, scale: d, fromRotation: f, fromScaling: t, str: v, frob: m, LDU: e, add: g, subtract: x, exactEquals: k, equals: r, multiplyScalar: A, multiplyScalarAndAdd: z, mul: h, sub: x }); a.LDU = e; a.add = g;
        a.adjoint = p; a.copy = c; a.determinant = l; a.equals = r; a.exactEquals = k; a.frob = m; a.fromRotation = f; a.fromScaling = t; a.identity = q; a.invert = n; a.mat2 = B; a.mul = h; a.multiply = h; a.multiplyScalar = A; a.multiplyScalarAndAdd = z; a.rotate = b; a.scale = d; a.set = u; a.str = v; a.sub = x; a.subtract = x; a.transpose = y
      })
    }, "esri/views/3d/webgl-engine/lib/PathGeometry": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "./Geometry"], function (a, w, c) {
        c = function (q) {
          function u(y, n, p, l, h, b) {
            y = q.call(this, y, n) || this; y.path =
              p; y.geometrySR = l; y.upVectorAlignment = h; y.stencilWidth = b; return y
          } w._inheritsLoose(u, q); return u
        }(c.Geometry); a.PathGeometry = c; a.isPathGeometry = function (q) { return "upVectorAlignment" in q }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/pathGeometryUtils": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../../../chunks/mat2 ../../../../chunks/mat2f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/plane ../../../../geometry/support/ray ./GeometryUtil ../materials/internal/MaterialUtil".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m() { return { up: b.create(), right: b.create() } } let e = function () {
            function T() { this.pos = b.create(); this.posES = b.create(); this.posGS = b.create(); this.vRight = b.create(); this.vLeft = b.create(); this.frame = m(); this.rotationFrame = m(); this.rotationRight = l.create(); this.rotationAngle = 0; this.miterStretch = u.create() } var da = T.prototype; da.setFrameFromUpVector = function (Y) {
              h.copy(this.frame.up, Y); h.add(G, this.vLeft, this.vRight); h.normalize(G, G); h.scale(N, this.frame.up,
                h.dot(G, this.frame.up)); h.subtract(R, G, N); h.normalize(R, R); h.cross(this.frame.right, R, this.frame.up)
            }; da.computeRotationAxisAndAngleFromUpVector = function () {
              h.copy(this.rotationFrame.up, this.frame.up); h.copy(this.rotationFrame.right, this.frame.right); p.set(this.rotationRight, 1, 0); h.scale(N, this.frame.up, h.dot(this.frame.up, this.vLeft)); h.subtract(N, this.vLeft, N); h.negate(N, N); h.normalize(N, N); h.scale(G, this.frame.up, h.dot(this.frame.up, this.vRight)); h.subtract(G, this.vRight, G); h.normalize(G, G); h.cross(I,
                this.rotationFrame.up, this.vLeft); this.rotationAngle = Math.sign(h.dot(I, this.vRight)) * (Math.PI - c.acosClamped(h.dot(N, G))); if (0 < Math.abs(this.rotationAngle)) { const Y = c.reciprocalClamped(Math.cos(.5 * this.rotationAngle)); q.set(this.miterStretch, 1 + (Y - 1), 0, 0, 1) } this.maxStretchDistance = Math.abs(Math.min(this.vLeftLength, this.vRightLength) / Math.cos(.5 * (Math.PI - this.rotationAngle)))
            }; return T
          }(), g = function () {
            function T() {
            this.vertices = []; this.vertexIndices = []; this.vertexNormals = []; this.poles = []; this.poleIndices =
              []; this.uvIndices = this.uvs = null
            } var da = T.prototype; da.addVertex = function (Y, fa) { this.vertices.push(l.clone(Y)); this.vertexNormals.push(l.clone(fa)); return this.vertices.length - 1 }; da.addUV = function (Y) { this.uvs || (this.uvs = [], this.uvIndices = []); this.uvs.push(Y); return this.uvs.length - 1 }; da.addPole = function (Y, fa = null) { this.poles.push({ position: l.clone(Y), normal: fa ? l.clone(fa) : null }); return this.poles.length - 1 }; da.addSegment = function (Y, fa = null, ha = null) {
              this.vertexIndices.push(Y.v0); this.vertexIndices.push(Y.v1);
              fa && (this.uvIndices.push(fa.v0), this.uvIndices.push(fa.v1)); ha && (this.poleIndices.push(ha.v0), this.poleIndices.push(ha.v1))
            }; da.hasUV = function () { return null != this.uvs }; da.translate = function (Y, fa) { for (const ha of this.vertices) ha[0] += Y, ha[1] += fa; for (const ha of this.poles) ha.position[0] += Y, ha.position[1] += fa }; T.circle = function (Y = 20) {
              const fa = new T, ha = { v0: 0, v1: 0 }; fa.addPole(l.fromValues(0, 0)); for (var ka = 0; ka < Y; ++ka) {
                var ea = 2 * ka * Math.PI / Y, ba = Math.cos(ea); const aa = Math.sin(ea); ea = l.fromValues(.5 * ba, .5 *
                  aa); ba = l.fromValues(ba, aa); fa.addVertex(ea, ba); fa.addUV(ka / Y)
              } fa.addUV(1); for (ka = 0; ka < Y - 1; ++ka)ba = { v0: ka, v1: ka + 1 }, fa.addSegment(ba, ba, ha); fa.addSegment({ v0: Y - 1, v1: 0 }, { v0: Y - 1, v1: Y }, ha); return fa
            }; T.rect = function () {
              const Y = new T, fa = l.fromValues(-.5, -.5), ha = l.fromValues(.5, -.5), ka = l.fromValues(.5, .5), ea = l.fromValues(-.5, .5), ba = l.fromValues(0, -1), aa = l.fromValues(1, 0), W = l.fromValues(0, 1), U = l.fromValues(-1, 0); Y.addUV(0); Y.addUV(1); Y.addPole(l.fromValues(0, .5), W); Y.addPole(l.fromValues(0, .5)); Y.addPole(l.fromValues(0,
                -.5)); Y.addPole(l.fromValues(0, -.5), ba); const X = { v0: 0, v1: 1 }; Y.addVertex(fa, ba); Y.addVertex(ha, ba); Y.addSegment({ v0: 0, v1: 1 }, X, { v0: 3, v1: 3 }); Y.addVertex(ha, aa); Y.addVertex(ka, aa); Y.addSegment({ v0: 2, v1: 3 }, X, { v0: 2, v1: 1 }); Y.addVertex(ka, W); Y.addVertex(ea, W); Y.addSegment({ v0: 4, v1: 5 }, X, { v0: 0, v1: 0 }); Y.addVertex(ea, U); Y.addVertex(fa, U); Y.addSegment({ v0: 6, v1: 7 }, X, { v0: 1, v1: 2 }); return Y
            }; w._createClass(T, [{ key: "numSegments", get: function () { return this.vertexIndices.length / 2 } }]); return T
          }(), x = function () {
            function T(da) {
            this.vertices =
              []; this.offset = b.create(); this.xform = n.create(); this.vertices = da; h.copy(this.offset, this.vertices[Math.floor((da.length - 1) / 2)].pos); for (const Y of this.vertices) h.subtract(Y.pos, Y.pos, this.offset); y.translate(this.xform, this.xform, this.offset); this.updatePathVertexInformation()
            } T.prototype.updatePathVertexInformation = function () {
              const da = this.vertices.length; let Y = this.vertices[0]; Y.index = 0; h.set(Y.vLeft, 0, 0, 0); Y.vLeftLength = 0; h.subtract(Y.vRight, this.vertices[1].pos, Y.pos); Y.vRightLength = h.length(Y.vRight);
              h.normalize(Y.vRight, Y.vRight); let fa = Y; for (let ha = 1; ha < da; ++ha)Y = this.vertices[ha], Y.index = ha, h.copy(Y.vLeft, fa.vRight), Y.vLeftLength = fa.vRightLength, ha < da - 1 ? (h.subtract(Y.vRight, this.vertices[ha + 1].pos, Y.pos), Y.vRightLength = h.length(Y.vRight), h.normalize(Y.vRight, Y.vRight)) : (h.copy(Y.vRight, Y.vLeft), Y.vRightLength = Y.vLeftLength), fa = Y
            }; return T
          }(), k = function () {
            function T() { } var da = T.prototype; da.numProfilesPerJoin = function () { return 1 }; da.extrude = function (Y, fa, ha) {
              for (let ka = 0; ka < fa.vertices.length; ++ka)ha(Y.index,
                Y.frame, fa.vertices[ka], fa.vertexNormals[ka], !1)
            }; return T
          }(), r = function () {
            function T(Y = .8 * Math.PI, fa = 1) { this.cutoffAngle = Y; this.numBendSubdivisions = fa } var da = T.prototype; da.numProfilesPerJoin = function () { return this.numBendSubdivisions + 1 }; da.extrude = function (Y, fa, ha) {
              var ka = S; if (Math.abs(Y.rotationAngle) >= this.cutoffAngle) for (var ea = 0; ea < this.numBendSubdivisions + 1; ++ea) {
                y.identity(Q); y.rotate(Q, Q, .5 * -Y.rotationAngle + ea * Y.rotationAngle / this.numBendSubdivisions, Y.rotationFrame.up); var ba = ka, aa = Y.frame,
                  W = Q; h.transformMat4(ba.up, aa.up, W); h.transformMat4(ba.right, aa.right, W); for (ba = 0; ba < fa.vertices.length; ++ba)0 <= p.dot(fa.vertices[ba], Y.rotationRight) * Y.rotationAngle ? ha(Y.index, ka, fa.vertices[ba], fa.vertexNormals[ba], !1) : (p.transformMat2(K, fa.vertices[ba], Y.miterStretch), ha(Y.index, Y.frame, K, fa.vertexNormals[ba], !0))
              } else for (ka = 0; ka < this.numBendSubdivisions + 1; ++ka)for (ea = 0; ea < fa.vertices.length; ++ea)ba = 0 <= p.dot(fa.vertices[ea], Y.rotationRight) * Y.rotationAngle, p.transformMat2(K, fa.vertices[ea], Y.miterStretch),
                ha(Y.index, Y.frame, K, fa.vertexNormals[ea], ba ? !1 : !0)
            }; return T
          }(); const A = { generateUV: !1 }; let z = function () { function T() { } T.prototype.rebuildConnectingProfileGeometry = function (da, Y, fa) { for (let ha = 0; ha < Y.vertices.length; ++ha)fa(da.index, da.frame, Y.vertices[ha], Y.vertexNormals[ha], 0, 0) }; return T }(), B = function (T) {
            function da() { return T.call(this) || this } w._inheritsLoose(da, T); var Y = da.prototype; Y.getNumVertices = function () { return 0 }; Y.getNumIndices = function () { return 0 }; Y.rebuildCapGeometry = function () { };
            Y.buildTopology = function () { }; return da
          }(z), C = function (T) {
            function da(fa, ha = 0, ka = !1) { var ea = T.call(this) || this; ea.profile = fa; ea.profilePlaneOffset = ha; ea.flip = ka; return ea } w._inheritsLoose(da, T); var Y = da.prototype; Y.getNumVertices = function () { return this.profile.vertices.length }; Y.getNumIndices = function () { return 3 * this.profile.numSegments }; Y.rebuildConnectingProfileGeometry = function (fa, ha, ka) {
              for (let ea = 0; ea < ha.vertices.length; ++ea)ka(fa.index, fa.frame, ha.vertices[ea], ha.vertexNormals[ea], this.profilePlaneOffset,
                0)
            }; Y.rebuildCapGeometry = function (fa, ha) { const ka = P; p.set(ka, 0, 0); const ea = this.flip ? 1 : -1; for (let ba = 0; ba < this.profile.vertices.length; ++ba)ha(fa.index, fa.frame, this.profile.vertices[ba], ka, this.profilePlaneOffset, ea) }; Y.buildTopology = function (fa, ha) {
              fa = this.vertexBufferStart + this.profile.vertexIndices[0]; for (let ka = 1; ka < this.profile.numSegments; ++ka) {
                const ea = this.vertexBufferStart + this.profile.vertexIndices[2 * ka], ba = this.vertexBufferStart + this.profile.vertexIndices[2 * ka + 1]; this.flip ? ha(ba, ea, fa) :
                  ha(fa, ea, ba)
              }
            }; return da
          }(z), D = function (T) {
            function da(fa) { var ha = T.call(this) || this; ha.flip = !1; ha.sign = 0; ha.breakNormals = !1; ha.numSegments = 3; ha.profile = fa.profile; ha.flip = fa.flip; ha.sign = ha.flip ? 1 : -1; ha.breakNormals = fa.breakNormals; ha.numSegments = fa.subdivisions; return ha } w._inheritsLoose(da, T); var Y = da.prototype; Y.getNumVertices = function () { let fa = 0; fa = this.profile.vertices.length * (this.numSegments - 1); this.breakNormals && (fa += this.profile.vertices.length); return fa += this.profile.poles.length }; Y.getNumIndices =
              function () { let fa; fa = 2 * this.profile.numSegments * (this.numSegments - 1); for (let ha = 0; ha < this.profile.numSegments; ++ha)fa = this.profile.poleIndices[this.profile.vertexIndices[2 * ha]] === this.profile.poleIndices[this.profile.vertexIndices[2 * ha + 1]] ? fa + 1 : fa + 2; return 3 * fa }; Y.rebuildCapGeometry = function (fa, ha) {
                const ka = fa.frame, ea = .5 * this.sign, ba = K, aa = P; p.set(aa, 0, 0); for (var W = 0; W < this.profile.poles.length; ++W) {
                  var U = this.profile.poles[W]; U.normal ? ha(fa.index, ka, U.position, U.normal, ea, 0) : ha(fa.index, ka, U.position,
                    aa, ea, this.sign)
                } if (this.breakNormals) for (W = 0; W < this.profile.vertices.length; ++W)ha(fa.index, ka, this.profile.vertices[W], this.profile.vertexNormals[W], 0, 0); for (W = 0; W < this.numSegments - 1; ++W) {
                  var X = (1 - (W + 1) / this.numSegments) * Math.PI * .5; U = Math.sin(X); X = Math.cos(X); for (let Z = 0; Z < this.profile.vertices.length; ++Z) {
                    const ia = this.profile.poles[this.profile.poleIndices[Z]]; p.subtract(ba, this.profile.vertices[Z], ia.position); p.scale(ba, ba, U); ia.normal ? (p.add(ba, ba, ia.position), ha(fa.index, ka, ba, ia.normal, ea *
                      X, 0)) : (p.normalize(aa, ba), p.scale(aa, aa, U), p.add(ba, ba, ia.position), ha(fa.index, ka, ba, aa, ea * X, this.sign * X))
                  }
                }
              }; Y.buildTopology = function (fa, ha) {
                fa = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length : this.firstProfileVertexIndex; const ka = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length + this.profile.vertices.length : this.vertexBufferStart + this.profile.poles.length; for (let ea = 0; ea < this.profile.numSegments; ++ea) {
                  const ba = this.profile.vertexIndices[2 * ea], aa = this.profile.vertexIndices[2 *
                    ea + 1], W = this.vertexBufferStart + this.profile.poleIndices[ba], U = this.vertexBufferStart + this.profile.poleIndices[aa]; let X = fa + ba, Z = fa + aa; for (let ia = 0; ia < this.numSegments - 1; ++ia) { const la = ka + ia * this.profile.vertices.length + ba, ma = ka + ia * this.profile.vertices.length + aa; this.flip ? (ha(la, Z, X), ha(Z, la, ma)) : (ha(X, Z, la), ha(ma, la, Z)); X = la; Z = ma } this.flip ? (ha(W, Z, X), W !== U && ha(W, U, Z)) : (ha(X, Z, W), W !== U && ha(Z, U, W))
                }
              }; return da
          }(z), E = function () {
            function T(Y, fa, ha, ka, ea, ba = A) {
            this.options = ba; this.numUVTotal = this.numNormalsTotal =
              this.numVerticesTotal = this.numExtrusionProfiles = this._triangleCount = this._extrusionVertexCount = 0; this.profile = fa; this.path = Y; this.extruder = ha; this.startCap = ka; this.endCap = ea; Y = this.path.vertices.length - 2; this.numExtrusionProfiles = ha.numProfilesPerJoin() * Y + 2; this.numNormalsTotal = this.numVerticesTotal = fa.vertices.length * this.numExtrusionProfiles; this.startCap.vertexBufferStart = this.numVerticesTotal; fa = this.startCap.getNumVertices(); this.numVerticesTotal += fa; this.numNormalsTotal += fa; this.endCap.vertexBufferStart =
                this.numVerticesTotal; fa = this.endCap.getNumVertices(); this.numVerticesTotal += fa; this.numNormalsTotal += fa; this.pathVertexData = new Float32Array(1 * this.numVerticesTotal); this.profileRightAxisData = new Float32Array(4 * this.numVerticesTotal); this.profileUpAxisData = new Float32Array(4 * this.numVerticesTotal); this.profileVertexAndNormalData = new Float32Array(4 * this.numVerticesTotal); this.profile.hasUV() && this.options.generateUV && (this.numUVTotal = this.profile.uvs.length, this.uvData = new Float32Array(2 * this.numUVTotal));
              this.originData = new Float32Array(3 * this.path.vertices.length); this.rebuildGeometry(); this.buildTopology()
            } var da = T.prototype; da.emitVertex = function (Y, fa, ha, ka, ea) {
            this.profileRightAxisData[4 * this._extrusionVertexCount] = fa.right[0]; this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = fa.right[1]; this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = fa.right[2]; this.profileUpAxisData[4 * this._extrusionVertexCount] = fa.up[0]; this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = fa.up[1]; this.profileUpAxisData[4 *
              this._extrusionVertexCount + 2] = fa.up[2]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount] = ha[0]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = ha[1]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = ka[0]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = ka[1]; this.pathVertexData[this._extrusionVertexCount] = Y; ea ? (Y = this.path.vertices[Y], this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = Y.rotationRight[0] * Y.maxStretchDistance, this.profileUpAxisData[4 *
                this._extrusionVertexCount + 3] = Y.rotationRight[1] * Y.maxStretchDistance) : (this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = 0, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = 0); ++this._extrusionVertexCount
            }; da.emitCapVertex = function (Y, fa, ha, ka, ea, ba) {
            this.profileRightAxisData[4 * this._extrusionVertexCount] = fa.right[0]; this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = fa.right[1]; this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = fa.right[2]; this.profileUpAxisData[4 * this._extrusionVertexCount] =
              fa.up[0]; this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = fa.up[1]; this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = fa.up[2]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount] = ha[0]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = ha[1]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = ka[0]; this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = ka[1]; this.pathVertexData[this._extrusionVertexCount] = Y; this.profileRightAxisData[4 * this._extrusionVertexCount +
                3] = ea; this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = ba; ++this._extrusionVertexCount
            }; da.emitTriangle = function (Y, fa, ha) {
            this.vertexIndices[3 * this._triangleCount] = Y; this.vertexIndices[3 * this._triangleCount + 1] = fa; this.vertexIndices[3 * this._triangleCount + 2] = ha; this.pathVertexIndices[3 * this._triangleCount] = this.pathVertexData[Y]; this.pathVertexIndices[3 * this._triangleCount + 1] = this.pathVertexData[fa]; this.pathVertexIndices[3 * this._triangleCount + 2] = this.pathVertexData[ha]; this.normalIndices[3 * this._triangleCount] =
              Y; this.normalIndices[3 * this._triangleCount + 1] = fa; this.normalIndices[3 * this._triangleCount + 2] = ha; ++this._triangleCount
            }; da.rebuildGeometry = function () {
              var Y = (ka, ea, ba, aa, W) => this.emitVertex(ka, ea, ba, aa, W); const fa = (ka, ea, ba, aa, W, U) => this.emitCapVertex(ka, ea, ba, aa, W, U); this._extrusionVertexCount = 0; for (var ha of this.path.vertices) this.originData[3 * ha.index] = ha.pos[0], this.originData[3 * ha.index + 1] = ha.pos[1], this.originData[3 * ha.index + 2] = ha.pos[2]; this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],
                this.profile, fa); for (ha = 1; ha < this.path.vertices.length - 1; ++ha)this.extruder.extrude(this.path.vertices[ha], this.profile, Y); this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length - 1], this.profile, fa); this.startCap.rebuildCapGeometry(this.path.vertices[0], fa); this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length - 1], fa); if (this.profile.hasUV() && this.options.generateUV) for (Y = 0; Y < this.profile.uvs.length; ++Y)this.uvData[2 * Y] = this.profile.uvs[Y], this.uvData[2 *
                  Y + 1] = 0
            }; da.buildTopology = function () {
              const Y = (ba, aa, W) => this.emitTriangle(ba, aa, W); this._triangleCount = 0; const fa = this.profile.vertices.length, ha = this.profile.numSegments, ka = this.numExtrusionProfiles - 1; var ea = ha * ka * 6; this.startCap.indexBufferStart = ea; this.startCap.firstProfileVertexIndex = 0; ea += this.startCap.getNumIndices(); this.endCap.indexBufferStart = ea; this.endCap.firstProfileVertexIndex = fa * (this.numExtrusionProfiles - 1); ea += this.endCap.getNumIndices(); this.vertexIndices = new Uint32Array(ea); this.normalIndices =
                new Uint32Array(ea); this.pathVertexIndices = new Uint32Array(ea); this.profile.hasUV() && this.options.generateUV && (this.uvIndices = new Uint32Array(ea)); for (ea = 0; ea < ha; ++ea) { const ba = this.profile.vertexIndices[2 * ea], aa = this.profile.vertexIndices[2 * ea + 1]; for (let W = 0; W < ka; ++W) { const U = W * fa + ba, X = (W + 1) * fa + aa, Z = W * fa + aa; Y(U, (W + 1) * fa + ba, X); Y(U, X, Z) } } this.startCap.buildTopology(this.path.vertices[0], Y); this.endCap.buildTopology(this.path.vertices[this.path.vertices.length - 1], Y)
            }; da.onPathChanged = function () { this.rebuildGeometry() };
            return T
          }(), H = function () { function T(da) { this.builder = da } T.prototype.onPathChanged = function () { this.builder.onPathChanged() }; w._createClass(T, [{ key: "xform", get: function () { return this.builder.path.xform } }]); return T }(), J = function (T) {
            function da(fa) {
              fa = T.call(this, fa) || this; fa.vertexAttributePosition = null; fa.vertexAttributeNormal = null; fa.vertexAttributeColor = null; fa.vertexAttributePosition = new Float32Array(3 * fa.builder.numVerticesTotal); fa.vertexAttributeNormal = new Float32Array(3 * fa.builder.numNormalsTotal);
              fa.vertexAttributeColor = new Uint8Array(4); fa.vertexAttributeColor[0] = 255; fa.vertexAttributeColor[1] = 255; fa.vertexAttributeColor[2] = 255; fa.vertexAttributeColor[3] = 255; return fa
            } w._inheritsLoose(da, T); var Y = da.prototype; Y.bakeVertexColors = function (fa) { this.vertexAttributeColor[0] = 255 * fa[0]; this.vertexAttributeColor[1] = 255 * fa[1]; this.vertexAttributeColor[2] = 255 * fa[2]; this.vertexAttributeColor[3] = 255 * (3 < fa.length ? fa[3] : 1) }; Y.bake = function (fa) {
            this.size = fa; for (let ba = 0; ba < this.builder.numVerticesTotal; ++ba) {
              var ha =
                this.builder.pathVertexData[ba], ka = 0 === ha || ha === this.builder.path.vertices.length - 1; ha *= 3; var ea = F; h.set(ea, this.builder.originData[ha++], this.builder.originData[ha++], this.builder.originData[ha]); ha = 4 * ba; const aa = N, W = K, U = G, X = I, Z = O; let ia = 0, la = 0; h.set(X, this.builder.profileRightAxisData[ha], this.builder.profileRightAxisData[ha + 1], this.builder.profileRightAxisData[ha + 2]); h.set(Z, this.builder.profileUpAxisData[ha], this.builder.profileUpAxisData[ha + 1], this.builder.profileUpAxisData[ha + 2]); p.set(W, this.builder.profileVertexAndNormalData[ha] *
                  fa[0], this.builder.profileVertexAndNormalData[ha + 1] * fa[1]); if (ka) h.cross(U, Z, X), ia = this.builder.profileRightAxisData[ha + 3] * fa[0], la = this.builder.profileUpAxisData[ha + 3]; else { ka = P; const ma = L; p.set(ka, this.builder.profileRightAxisData[ha + 3], this.builder.profileUpAxisData[ha + 3]); const ra = p.length(ka); p.normalize(ka, ka); const Aa = p.dot(W, ka); if (Math.abs(Aa) > ra) { p.set(ma, -ka[1], ka[0]); const za = p.dot(W, ma); p.scale(ka, ka, ra * Math.sign(Aa)); p.scale(ma, ma, za); p.add(W, ka, ma) } h.set(U, 0, 0, 0) } h.set(aa, X[0] * W[0] +
                    Z[0] * W[1], X[1] * W[0] + Z[1] * W[1], X[2] * W[0] + Z[2] * W[1]); this.vertexAttributePosition[3 * ba] = ea[0] + aa[0] + U[0] * ia; this.vertexAttributePosition[3 * ba + 1] = ea[1] + aa[1] + U[1] * ia; this.vertexAttributePosition[3 * ba + 2] = ea[2] + aa[2] + U[2] * ia; ea = K; p.set(ea, this.builder.profileVertexAndNormalData[ha + 2], this.builder.profileVertexAndNormalData[ha + 3]); this.vertexAttributeNormal[3 * ba] = X[0] * ea[0] + Z[0] * ea[1] + U[0] * la; this.vertexAttributeNormal[3 * ba + 1] = X[1] * ea[0] + Z[1] * ea[1] + U[1] * la; this.vertexAttributeNormal[3 * ba + 2] = X[2] * ea[0] +
                      Z[2] * ea[1] + U[2] * la
            }
            }; Y.createGeometryData = function () { const fa = [["position", this.builder.vertexIndices], ["normal", this.builder.normalIndices]], ha = [["position", { size: 3, data: this.vertexAttributePosition, exclusive: !0 }], ["normal", { size: 3, data: this.vertexAttributeNormal, exclusive: !0 }]]; this.vertexAttributeColor && (fa.push(["color", new Uint32Array(this.builder.vertexIndices.length)]), ha.push(["color", { size: 4, data: this.vertexAttributeColor }])); return { vertexAttributes: ha, indices: fa } }; Y.onPathChanged = function () {
              T.prototype.onPathChanged.call(this);
              this.bake(this.size)
            }; Y.intersect = function (fa, ha, ka) { const ea = this.builder.vertexIndices; v.intersectTriangles(fa, ha, 0, ea.length / 3, ea, { size: 3, data: this.vertexAttributePosition }, void 0, void 0, ka) }; return da
          }(H), M = function (T) {
            function da(Y, fa, ha, ka) {
              var ea = T.call(this, Y) || this; ea.sizeAttributeValue = fa; ea.colorAttributeValue = ha; ea.opacityAttributeValue = ka; ea.vvData = null; ea.baked = new J(Y); ea.vvData = new Float32Array(4 * ea.builder.path.vertices.length); for (Y = 0; Y < ea.builder.path.vertices.length; ++Y)ea.vvData[4 *
                Y] = fa, ea.vvData[4 * Y + 1] = ha, ea.vvData[4 * Y + 2] = ka, ea.vvData[4 * Y + 3] = 0 === Y || Y === ea.builder.path.vertices.length - 1 ? 1 : 0; return ea
            } w._inheritsLoose(da, T); da.prototype.createGeometryData = function () {
              return {
                vertexAttributes: [["position", { size: 3, data: this.builder.originData, exclusive: !0 }], ["profileRight", { size: 4, data: this.builder.profileRightAxisData, exclusive: !0 }], ["profileUp", { size: 4, data: this.builder.profileUpAxisData, exclusive: !0 }], ["profileVertexAndNormal", {
                  size: 4, data: this.builder.profileVertexAndNormalData,
                  exclusive: !0
                }], ["featureValue", { size: 4, data: this.vvData, exclusive: !0 }]], indices: [["position", this.builder.pathVertexIndices], ["profileRight", this.builder.vertexIndices], ["profileUp", this.builder.vertexIndices], ["profileVertexAndNormal", this.builder.vertexIndices], ["featureValue", this.builder.pathVertexIndices]]
              }
            }; return da
          }(H); const F = b.create(), K = l.create(), P = l.create(), L = l.create(), N = b.create(), G = b.create(), I = b.create(), O = b.create(), R = b.create(), S = m(), Q = n.create(); a.Builder = E; a.CapBuilder = z; a.Extruder =
            function () { }; a.FastUpdatePathGeometry = M; a.MiterExtruder = r; a.NoCapBuilder = B; a.Path = x; a.PathGeometryData = H; a.PathVertex = e; a.Profile = g; a.RoundCapBuilder = D; a.SimpleExtruder = k; a.StaticPathGeometry = J; a.TriangulationCapBuilder = C; a.computeMinimumRotationTangentFrame = function (T, da) {
              let Y = null; const fa = T.vertices.length, ha = b.create(), ka = b.create(), ea = b.create(), ba = b.create(), aa = b.create(), W = b.create(), U = d.create(); let X = T.vertices[0]; h.copy(ka, da); h.set(ha, 0, 1, 0); t.makeOrthoBasisDirUpFallback(X.vRight, ka, ha,
                ha, ea, ka, .99619469809); h.copy(X.frame.up, ka); h.copy(X.frame.right, ea); Y = X; for (da = 1; da < fa; ++da) {
                  X = T.vertices[da]; h.add(aa, X.vLeft, X.vRight); let Z = h.length(aa); 0 < Z ? (Z = 1 / Math.sqrt(Z), aa[0] *= Z, aa[1] *= Z, aa[2] *= Z) : (aa[0] = X.vRight[0], aa[1] = X.vRight[1], aa[2] = X.vRight[2]); h.add(W, Y.pos, Y.frame.up); d.fromPositionAndNormal(X.pos, aa, U); d.intersectRay(U, f.wrap(W, X.vLeft), ba) ? (h.subtract(ba, ba, X.pos), h.normalize(ka, ba), h.cross(ea, aa, ka), h.normalize(ea, ea)) : t.makeOrthoBasisDirUpFallback(aa, Y.frame.up, Y.frame.right,
                    ha, ea, ka, .99619469809); h.copy(X.frame.up, ka); h.copy(X.frame.right, ea); Y = X
                }
            }; a.makeFrame = m; a.profileSpaceToVertexSpace = function (T, da, Y) { T[0] = Y[0] * da.right[0] + Y[1] * da.up[0]; T[1] = Y[0] * da.right[1] + Y[1] * da.up[1]; T[2] = Y[0] * da.right[2] + Y[1] * da.up[2] }; a.vertexSpaceToProfileSpace = function (T, da, Y) { p.set(T, h.dot(Y, da.right), h.dot(Y, da.up)) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/mat2f64": function () {
      define(["exports"], function (a) {
        function w() { return [1, 0, 0, 1] } function c(n) {
          return [n[0],
          n[1], n[2], n[3]]
        } function q(n, p, l, h) { return [n, p, l, h] } function u(n, p) { return new Float64Array(n, p, 4) } const y = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, createView: u }); a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.mat2f64 = y
      })
    }, "esri/views/3d/webgl-engine/materials/PathMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../../../core/maybe ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/buffer/BufferView ../../support/buffer/InterleavedLayout ../lib/geometryDataUtils ../lib/GLMaterial ../lib/Material ../lib/PathGeometry ../lib/Util ./PathTechnique ./VisualVariableMaterialParameters ./internal/bufferWriterUtils ./internal/MaterialUtil".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = d.assert; d = function (r) {
            function A(B) { B = r.call(this, B, x) || this; B.supportsEdges = !0; B._vertexAttributeLocations = f.pathVertexAttributeLocations; B.techniqueConfig = new f.PathTechniqueConfiguration; B.vertexBufferLayout = A.getVertexBufferLayout(B.parameters); return B } w._inheritsLoose(A, r); var z = A.prototype; z.getTechniqueConfig = function (B, C) {
              this.techniqueConfig.output = B; this.techniqueConfig.vvSize = this.parameters.vvSizeEnabled; this.techniqueConfig.vvColor =
                this.parameters.vvColorEnabled; this.techniqueConfig.vvOpacity = this.parameters.vvOpacityEnabled; this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this.techniqueConfig.transparent = this.parameters.transparent; this.techniqueConfig.sceneHasOcludees = this.parameters.sceneHasOcludees; if (0 === B || 7 === B) this.techniqueConfig.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? 1 : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ?
                  2 : 0, this.techniqueConfig.receiveShadows = this.parameters.receiveShadows, this.techniqueConfig.receiveSSAO = C.ssaoEnabled ? this.parameters.receiveSSAO : !1; this.techniqueConfig.transparencyPassType = C.transparencyPassType; this.techniqueConfig.multipassTerrainEnabled = C.multipassTerrainEnabled; this.techniqueConfig.cullAboveGround = C.cullAboveGround; return this.techniqueConfig
            }; z.getPassParameters = function () { return this.parameters }; z.isVisibleInPass = function (B) {
              return 4 === B || 6 === B || 7 === B ? this.parameters.castShadows :
                !0
            }; z.isVisible = function () { const B = this.parameters; return r.prototype.isVisible.call(this) ? 0 < B.opacity : !1 }; z.intersect = function (B, C, D, E, H, J, M) {
              if (b.isPathGeometry(B)) {
                C = B.path; D = [this.parameters.size[0], this.parameters.size[1]]; if (this.parameters.vvSizeEnabled) { var F = this.parameters.vvSizeOffset, K = this.parameters.vvSizeFactor; const P = this.parameters.vvSizeMinSize, L = this.parameters.vvSizeMaxSize, N = C.sizeAttributeValue; D[0] *= c.clamp(F[0] + N * K[0], P[0], L[0]); D[1] *= c.clamp(F[2] + N * K[2], P[2], L[2]) } F = Math.max(D[0],
                  D[1]); B = B.boundingInfo; q.isNone(B) ? this._intersectTriangles(C, D, H, J, M) : (B = u.fromValues(B.bbMin[0] - F, B.bbMin[1] - F, B.bbMin[2] - F, B.bbMax[0] + F, B.bbMax[1] + F, B.bbMax[2] + F), F = [J[0] - H[0], J[1] - H[1], J[2] - H[2]], K = Math.sqrt(F[0] * F[0] + F[1] * F[1] + F[2] * F[2]), m.intersectAabbInvDir(B, H, [K / F[0], K / F[1], K / F[2]], E.tolerance) && this._intersectTriangles(C, D, H, J, M))
              }
            }; z._intersectTriangles = function (B, C, D, E, H) { B.baked.size && B.baked.size[0] === C[0] && B.baked.size[1] === C[1] || B.baked.bake(C); B.baked.intersect(D, E, H) }; z.computeAttachmentOrigin =
              function (B, C) { B = B.vertexAttributes; if (!B) return null; B = B.get("position"); return p.computeAttachmentOriginLines(B, null, !1, C) }; z.createBufferWriter = function () { return new k(this.vertexBufferLayout) }; z.requiresSlot = function (B) { return B === (this.parameters.transparent ? 4 : 2) || 20 === B }; z.createGLMaterial = function (B) { return 0 === B.output || 7 === B.output || 1 === B.output || 2 === B.output || 4 === B.output || 3 === B.output && this.parameters.castShadows ? new g(B) : null }; A.getVertexBufferLayout = function (B) {
                let C = n.newLayout().vec3f("position").vec4f("profileRight").vec4f("profileUp").vec4f("profileVertexAndNormal");
                if (B.vvColorEnabled || B.vvSizeEnabled || B.vvOpacityEnabled) C = C.vec4f("featureValue"); return C
              }; return A
          }(h.Material); let g = function (r) {
            function A() { return r.apply(this, arguments) || this } w._inheritsLoose(A, r); var z = A.prototype; z.updateParameters = function (B) { return this.ensureTechnique(f.PathTechnique, B) }; z._updateOccludeeState = function (B) { B.hasOccludees !== this._material.parameters.sceneHasOcludees && this._material.setParameters({ sceneHasOcludees: B.hasOccludees }) }; z._updateShadowState = function (B) {
            (q.isNone(this.technique) ||
              B.shadowMappingEnabled !== this.technique.configuration.receiveShadows) && this._material.setParameters({ receiveShadows: B.shadowMappingEnabled })
            }; z.beginSlot = function (B) { if (0 === this._output || 7 === this._output) this._updateShadowState(B), this._updateOccludeeState(B); return this.updateParameters(B) }; z.bind = function (B, C) { C.bindPass(this._material.getPassParameters(), B) }; return A
          }(l); const x = {
            size: [1, 1, 1], ambient: [.2, .2, .2], diffuse: [.8, .8, .8], specular: [0, 0, 0], opacity: 1, doubleSided: !1, doubleSidedType: "normal",
            receiveSSAO: !0, receiveShadows: !1, castShadows: !0, slicePlaneEnabled: !1, transparent: !1, sceneHasOcludees: !1, ...t.Default, ...h.materialParametersDefaults
          }; let k = function () {
            function r(z) { this.vertexBufferLayout = z } var A = r.prototype; A.allocate = function (z) { return this.vertexBufferLayout.createBuffer(z) }; A.elementCount = function (z) { return z.indices.get("position").length }; A.write = function (z, B, C, D) {
              const E = H => {
                if (B.vertexAttributes.has(H)) {
                  const J = B.vertexAttributes.get(H), M = B.indices.get(H); e(4 === J.size); const F =
                    C.getField(H, y.BufferViewVec4f); if (F) v.writeBufferVec4(M, J.data, F, D); else throw Error("unable to acquire view for " + H);
                }
              }; E("profileRight"); E("profileUp"); E("profileVertexAndNormal"); this.vertexBufferLayout.hasField("featureValue") && E("featureValue"); v.writeDefaultAttributes(B, this.vertexBufferLayout, z.transformation, z.invTranspTransformation, C, D)
            }; return r
          }(); a.PathMaterial = d; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/PathTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/attributes/PathVertexPosition.glsl ../core/shaderLibrary/attributes/VertexNormal.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/shading/ReadShadowMap.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../../../../chunks/Path.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
          const x = new Map([["position", 0], ["profileRight", 1], ["profileUp", 2], ["profileVertexAndNormal", 3], ["featureValue", 4]]); d = function (k) {
            function r() { return k.apply(this, arguments) || this } c._inheritsLoose(r, k); var A = r.prototype; A.initializeProgram = function (z) {
              var B = r.shader.get(); const C = this.configuration; B = B.build({
                OITEnabled: 0 === C.transparencyPassType, output: C.output, viewingMode: z.viewingMode, slicePlaneEnabled: C.slicePlaneEnabled, sliceHighlightDisabled: !1,
                sliceEnabledForVertexPrograms: !1, receiveShadows: C.receiveShadows, vvSize: C.vvSize, vvColor: C.vvColor, vvInstancingEnabled: !0, vvOpacity: C.vvOpacity, pbrMode: 0, useCustomDTRExponentForWater: !1, receiveAmbientOcclusion: C.receiveSSAO, doubleSidedMode: C.doubleSidedMode, multipassTerrainEnabled: C.multipassTerrainEnabled, cullAboveGround: C.cullAboveGround
              }); return new v.Program(z.rctx, B, x)
            }; A.bindPass = function (z, B) {
              var C, D; h.bindProjectionMatrix(this.program, B.camera.projectionMatrix); this.program.setUniform3fv("size",
                z.size); B.multipassTerrainEnabled && (this.program.setUniform2fv("cameraNearFar", B.camera.nearFar), this.program.setUniform2fv("inverseViewport", B.inverseViewport), p.bindMultipassTerrainTexture(this.program, B)); 0 !== this.configuration.output && 7 !== this.configuration.output || this.program.setUniform1f("opacity", z.opacity); 0 === this.configuration.output ? (B.lighting.setUniforms(this.program, !1), this.program.setUniform3fv("ambient", z.ambient), this.program.setUniform3fv("diffuse", z.diffuse), this.program.setUniform3fv("specular",
                  z.specular), this.program.setUniform1f("opacity", z.opacity)) : 1 !== this.configuration.output && 3 !== this.configuration.output || h.bindNearFar(this.program, B.camera.nearFar); y.setVVUniforms(this.program, z); null == (C = B.shadowMap) ? void 0 : C.bind(this.program); null == (D = B.ssaoHelper) ? void 0 : D.bind(this.program, B.camera)
            }; A.bindDraw = function (z) {
              h.bindView(this.program, z); u.bindSliceUniformsWithOrigin(this.program, this.configuration, z); this.program.rebindTextures(); 0 !== this.configuration.output && 7 !== this.configuration.output ||
                h.bindCameraPosition(this.program, z.origin, z.camera.viewInverseTransposeMatrix); 0 === this.configuration.output && l.bindReadShadowMapView(this.program, z); 2 === this.configuration.output && n.VertexNormal.bindUniforms(this.program, z.camera.viewInverseTransposeMatrix)
            }; A.setPipelineState = function (z) {
              const B = this.configuration, C = 3 === z, D = 2 === z; return g.makePipelineState({
                blending: 0 !== B.output && 7 !== B.output || !B.transparent ? null : C ? t.blendingDefault : t.OITBlending(z), culling: (B.slicePlaneEnabled ? !1 : !B.transparent &&
                  0 !== B.doubleSidedMode) && g.frontFaceCullingParams, depthTest: { func: t.OITDepthTest(z) }, depthWrite: C || D ? g.defaultDepthWriteParams : null, colorWrite: g.defaultColorWriteParams, stencilWrite: B.sceneHasOcludees ? m.stencilWriteMaskOn : null, stencilTest: B.sceneHasOcludees ? m.stencilBaseAllZerosParams : null, polygonOffset: C || D ? null : t.OITPolygonOffset
              })
            }; A.initializePipeline = function () { return this.setPipelineState(this.configuration.transparencyPassType) }; return r
          }(d.ShaderTechnique); d.shader = new b.ReloadableShaderModule(e.PathShader,
            () => new Promise((k, r) => a(["../shaders/Path.glsl"], k, r))); b = function (k) { function r() { var A = k.apply(this, arguments) || this; A.output = 0; A.doubleSidedMode = 0; A.receiveShadows = !1; A.receiveSSAO = !1; A.vvSize = !1; A.vvColor = !1; A.vvOpacity = !1; A.slicePlaneEnabled = !1; A.transparent = !1; A.sceneHasOcludees = !1; A.transparencyPassType = 3; A.multipassTerrainEnabled = !1; A.cullAboveGround = !1; return A } c._inheritsLoose(r, k); return r }(f.ShaderTechniqueConfiguration); q.__decorate([f.parameter({ count: 8 })], b.prototype, "output", void 0);
          q.__decorate([f.parameter({ count: 3 })], b.prototype, "doubleSidedMode", void 0); q.__decorate([f.parameter()], b.prototype, "receiveShadows", void 0); q.__decorate([f.parameter()], b.prototype, "receiveSSAO", void 0); q.__decorate([f.parameter()], b.prototype, "vvSize", void 0); q.__decorate([f.parameter()], b.prototype, "vvColor", void 0); q.__decorate([f.parameter()], b.prototype, "vvOpacity", void 0); q.__decorate([f.parameter()], b.prototype, "slicePlaneEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "transparent",
            void 0); q.__decorate([f.parameter()], b.prototype, "sceneHasOcludees", void 0); q.__decorate([f.parameter({ count: 4 })], b.prototype, "transparencyPassType", void 0); q.__decorate([f.parameter()], b.prototype, "multipassTerrainEnabled", void 0); q.__decorate([f.parameter()], b.prototype, "cullAboveGround", void 0); w.PathTechnique = d; w.PathTechniqueConfiguration = b; w.pathVertexAttributeLocations = x; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl": function () {
      define(["exports",
        "./PositionAttribute.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
        a.PathVertexPosition = function (q, u) {
          q.attributes.add("featureValue", "vec4"); q.vertex.code.add(c.glsl`bool isCapVertex() {
return featureValue.w == 1.0;
}`); q.vertex.uniforms.add("size", "vec3"); u.vvSize ? (q.vertex.uniforms.add("vvSizeMinSize", "vec3"), q.vertex.uniforms.add("vvSizeMaxSize", "vec3"), q.vertex.uniforms.add("vvSizeOffset", "vec3"), q.vertex.uniforms.add("vvSizeFactor", "vec3"), q.vertex.code.add(c.glsl`vec2 getSize() {
return size.xy*clamp(vvSizeOffset + featureValue.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
}`)) : q.vertex.code.add(c.glsl`vec2 getSize(){
return size.xy;
}`); u.vvOpacity ? (q.vertex.constants.add("vvOpacityNumber", "int", 8), q.vertex.code.add(c.glsl`uniform float vvOpacityValues[vvOpacityNumber];
uniform float vvOpacityOpacities[vvOpacityNumber];
vec4 applyOpacity(vec4 color) {
float value = featureValue.z;
if (value <= vvOpacityValues[0]) {
return vec4( color.xyz, vvOpacityOpacities[0]);
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
}
}
return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);
}`)) : q.vertex.code.add(c.glsl`vec4 applyOpacity(vec4 color){
return color;
}`); u.vvColor ? (q.vertex.constants.add("vvColorNumber", "int", 8), q.vertex.code.add(c.glsl`uniform float vvColorValues[vvColorNumber];
uniform vec4 vvColorColors[vvColorNumber];
vec4 getColor() {
float value = featureValue.y;
if (value <= vvColorValues[0]) {
return applyOpacity(vvColorColors[0]);
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
}
}
return applyOpacity(vvColorColors[vvColorNumber - 1]);
}`)) : q.vertex.code.add(c.glsl`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`); q.include(w.PositionAttribute); q.attributes.add("profileRight", "vec4"); q.attributes.add("profileUp", "vec4"); q.attributes.add("profileVertexAndNormal", "vec4"); q.vertex.code.add(c.glsl`vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileVertex = profileVertexAndNormal.xy * size;
vec2 profileNormal = profileVertexAndNormal.zw;
float positionOffsetAlongProfilePlaneNormal = 0.0;
float normalOffsetAlongProfilePlaneNormal = 0.0;`); q.vertex.code.add(c.glsl`if(!isCapVertex()) {
vec2 rotationRight = vec2(profileRight.w, profileUp.w);
float maxDistance = length(rotationRight);`); q.vertex.code.add(c.glsl`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
}else{
positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
normalOffsetAlongProfilePlaneNormal = profileUp.w;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}`); q.vertex.code.add(c.glsl`vec3 localNormal() {
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileNormal = profileVertexAndNormal.zw;
vec3 normal = right * profileNormal.x + up * profileNormal.y;
if(isCapVertex()) {
normal += forward * profileUp.w;
}
return normal;
}`)
        }; a.setVVUniforms = function (q, u) { u.vvSizeEnabled && (q.setUniform3fv("vvSizeMinSize", u.vvSizeMinSize), q.setUniform3fv("vvSizeMaxSize", u.vvSizeMaxSize), q.setUniform3fv("vvSizeOffset", u.vvSizeOffset), q.setUniform3fv("vvSizeFactor", u.vvSizeFactor)); u.vvColorEnabled && (q.setUniform1fv("vvColorValues", u.vvColorValues), q.setUniform4fv("vvColorColors", u.vvColorColors)); u.vvOpacityEnabled && (q.setUniform1fv("vvOpacityValues", u.vvOpacityValues), q.setUniform1fv("vvOpacityOpacities", u.vvOpacityOpacities)) }; Object.defineProperty(a,
          "__esModule", { value: !0 })
        })
    }, "esri/chunks/Path.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          function g(k) {
            const r = new e.ShaderBuilder; r.vertex.uniforms.add("proj", "mat4").add("view", "mat4").add("camPos", "vec3").add("localOrigin", "vec3"); r.varyings.add("vpos", "vec3"); r.include(u.PathVertexPosition, k); if (0 === k.output || 7 === k.output) r.include(q.Transform, { linearDepth: !1 }), k.receiveShadows && r.include(t.ReadShadowMap, k), r.include(w.ForwardLinearDepth, k), r.varyings.add("vnormal", "vec3"), r.varyings.add("vcolor", "vec4"), k.multipassTerrainEnabled && r.varyings.add("depth",
              "float"), r.vertex.code.add(m.glsl`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${k.multipassTerrainEnabled ? "depth \x3d (view * vec4(vpos, 1.0)).z;" : ""}
        gl_Position = transformPosition(proj, view, vpos);

        ${0 === k.output ? "forwardLinearDepth();" : ""}

        vcolor = getColor();
      }
    `); k.multipassTerrainEnabled && (r.fragment.include(p.ReadLinearDepth), r.include(b.multipassTerrainTest, k)); 7 === k.output && (r.include(c.Slice, k), r.fragment.uniforms.add("camPos", "vec3"), r.fragment.uniforms.add("localOrigin", "vec3"), r.fragment.uniforms.add("opacity", "float"), r.fragment.code.add(m.glsl`
      void main() {
        discardBySlice(vpos);
        ${k.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        float combinedOpacity = vcolor.a * opacity;
        gl_FragColor = vec4(combinedOpacity);
      }
    `)); 0 === k.output && (r.include(c.Slice, k), r.include(h.EvaluateSceneLighting, k), r.include(l.EvaluateAmbientOcclusion, k), k.receiveShadows && r.include(t.ReadShadowMap, k), r.include(d.Normals, k), r.fragment.uniforms.add("camPos", "vec3").add("localOrigin", "vec3").add("ambient", "vec3").add("diffuse", "vec3").add("specular", "vec3").add("opacity", "float"), r.fragment.include(v.ColorConversion), r.fragment.code.add(m.glsl`
      void main() {
        discardBySlice(vpos);
        ${k.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

        shadingParams.viewDirection = normalize(vpos - camPos);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        ${k.receiveShadows ? "float shadow \x3d readShadowMap(vpos, linearDepth);" : 1 === k.viewingMode ? "float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow \x3d 0.0;"}
        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;
        albedo += 0.25 * specular; // don't completely ignore specular for now

        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
        gl_FragColor = vec4(shadedColor, combinedOpacity);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${k.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)); if (1 === k.output || 3 === k.output) r.include(q.Transform, { linearDepth: !0 }), r.vertex.uniforms.add("nearFar", "vec2"), r.varyings.add("depth", "float"), r.vertex.code.add(m.glsl`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`), r.include(c.Slice, k), r.include(y.OutputDepth, k), r.fragment.uniforms.add("timeElapsed", "float"), r.fragment.code.add(m.glsl`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`); 2 === k.output && (r.include(q.Transform, { linearDepth: !1 }), r.include(f.NormalUtils, k), r.vertex.uniforms.add("viewNormal", "mat4"), r.varyings.add("vnormal", "vec3"), r.vertex.code.add(m.glsl`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`), r.include(c.Slice, k), r.fragment.uniforms.add("waterColor", "vec4"), r.fragment.code.add(m.glsl`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`)); 4 === k.output && (r.include(q.Transform, { linearDepth: !1 }), r.include(f.NormalUtils, k), r.vertex.uniforms.add("viewNormal", "mat4"), r.varyings.add("vnormal", "vec3"), r.vertex.code.add(m.glsl`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`), r.include(c.Slice, k), r.include(n.OutputHighlight), r.fragment.code.add(m.glsl`void main() {
discardBySlice(vpos);
outputHighlight();
}`)); return r
          } const x = Object.freeze({ __proto__: null, build: g }); a.PathShader = x; a.build = g
        })
    }, "esri/views/3d/layers/graphics/Graphics3DPolygonFillSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/earcut ../../../../chunks/mat4f64 ../../../../chunks/vec4 ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/buffer/BufferView ./elevationAlignmentUtils ./ElevationContext ./Graphics3DDrapedGraphicLayer ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ./lineUtils ./polygonUtils ../support/patternUtils ../support/uvUtils ../../webgl-engine/lib/Object3D ../../webgl-engine/lib/RenderGeometry ../../webgl-engine/materials/lineStippleUtils ../../webgl-engine/materials/PatternMaterial ../../webgl-engine/materials/RibbonLineMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          const D = ["polyline", "polygon", "extent"]; v = function (M) {
            function F(P, L, N, G) { P = M.call(this, P, L, N, G) || this; P._needsUV = !1; P._hasOutline = !1; return P } w._inheritsLoose(F, M); var K = F.prototype; K.doLoad = function () { var P = w._asyncToGenerator(function* () { }); return function () { return P.apply(this, arguments) } }(); K.ensureMaterials = function () { this.ensureFillMaterial(); this.ensureOutlineMaterial() }; K.ensureFillMaterial = function () {
              if (!q.isSome(this._material)) {
                var P =
                  q.get(this.symbolLayer, "material", "color"); P = this._getCombinedOpacityAndColor(P); this._material = x.createMaterial(this.symbolLayer, { color: P, transparent: 1 > P[3] || this.needsDrivenTransparentPass, polygonOffset: !1, vertexColors: !0, writeLinearDepth: !0, slicePlaneEnabled: this._context.slicePlaneEnabled }, { isDraped: this.draped }); this._needsUV = this._material instanceof B.PatternMaterial; this._context.stage.add(this._material)
              }
            }; K.ensureOutlineMaterial = function () {
              const P = this.symbolLayer.outline; !q.isSome(this._outlineMaterial) &&
                this._isValidOutline(P) && (this._hasOutline = !0, this._outlineMaterial = (L => { const N = z.getStipplePatternForLinePattern(P.pattern); return new C.RibbonLineMaterial({ width: L, color: this._getOutlineColor(), polygonOffset: !0, slicePlaneEnabled: this._context.slicePlaneEnabled, isClosed: !0, stipplePattern: N, stippleScaleWithLineWidth: !0, cap: e.parseCapType(P.patternCap || "butt") }) })(u.pt2px(P.size)), this._context.stage.add(this._outlineMaterial))
            }; K._isValidOutline = function (P) {
              return q.isSome(P) && P.size && 0 < P.size &&
                q.isSome(P.color) && (q.isNone(P.pattern) || "style" !== P.pattern.type || "none" !== P.pattern.style)
            }; K.destroy = function () { M.prototype.destroy.call(this); this._context.stage.remove(this._material); this._material = null; this._context.stage.remove(this._outlineMaterial); this._outlineMaterial = null }; K.createGraphics3DGraphic = function (P) {
              const L = P.graphic; if (!this._validateGeometry(L.geometry, D, this.symbolLayer.type)) return null; P = this._getVertexOpacityAndColor(P.renderingInfo, 255); const N = this.setGraphicElevationContext(L,
                new d.ElevationContext); this.ensureDrapedStatus("on-the-ground" === N.mode); this.ensureMaterials(); return this.draped ? this._createAsOverlay(L, P) : this._createAs3DShape(L, P, N)
            }; K.layerOpacityChanged = function () {
              if (q.isSome(this._material)) { var P = this._material.parameters.color, L = q.get(this.symbolLayer, "material", "color"); L = this._getCombinedOpacity(L); this._material.setParameters({ color: [P[0], P[1], P[2], L], transparent: 1 > L || this.needsDrivenTransparentPass }) } q.isSome(this._outlineMaterial) && (P = this._outlineMaterial.parameters.color,
                this._outlineMaterial.setParameters({ color: [P[0], P[1], P[2], this._getOutlineOpacity()] })); return !0
            }; K.layerElevationInfoChanged = function (P, L, N) { const G = this._elevationContext.mode; N = b.elevationModeChangeUpdateType(F.elevationModeChangeTypes, N, G); if (N !== b.SymbolUpdateType.UPDATE) return N; const I = b.needsElevationUpdates2D(G); return this.updateGraphics3DGraphicElevationInfo(P, L, () => I) }; K.slicePlaneEnabledChanged = function () {
              q.isSome(this._material) && this._material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled });
              q.isSome(this._outlineMaterial) && this._outlineMaterial.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); return !0
            }; K.physicalBasedRenderingChanged = function () { return !0 }; K.pixelRatioChanged = function () { return !0 }; K._createAs3DShape = function (P, L, N) {
              const G = g.geometryAsPolygon(P.geometry); if (q.isNone(G)) return null; H.renderData = g.geometryToRenderInfo(G, this._context.elevationProvider, this._context.renderCoordsHelper, N); H.color = L; L = H.renderData.position.length / 3; this._needsUV && (H.uvMapSpace =
                new Float32Array(4 * L), H.boundingRect = new Float64Array(9 * L)); H.outNum = 0; H.outGeometries = []; H.outTransforms = []; H.outMaterials = []; this._createAs3DShapeFill(H); this._hasOutline && this._createAs3DShapeOutline(H); this._logGeometryCreationWarnings(H.renderData, G.rings, "rings", "FillSymbol3DLayer"); if (0 === H.outNum) return null; this._needsUV && k.createMapSpaceUVCoords(h.BufferViewVec4f.fromTypedArray(H.uvMapSpace), h.BufferViewVec3f64.fromTypedArray(H.renderData.position), this._context.renderCoordsHelper, h.BufferViewMat3f64.fromTypedArray(H.boundingRect));
              P = new r.Object3D({ geometries: H.outGeometries, materials: H.outMaterials, transformations: H.outTransforms, castShadow: !1, metadata: { layerUid: this._context.layer.uid, graphicUid: P.uid } }); P = new t.Graphics3DObject3DGraphicLayer(this, P, H.outGeometries, null, null, x.uvElevationAligner, N); P.alignedSampledElevation = H.renderData.sampledElevation; P.needsElevationUpdates = b.needsElevationUpdates2D(N.mode); return P
            }; K._createAs3DShapeFill = function (P) {
              var L = P.renderData.polygons; for (const { position: N, mapPosition: G, holeIndices: I,
                index: O, count: R } of L) {
                  if (q.isSome(this._context.clippingExtent) && (l.empty(E), l.expandWithBuffer(E, G), !l.intersectsClippingArea(E, this._context.clippingExtent))) continue; L = y.earcut(G, I, 3); 0 !== L.length && (L = new Uint32Array(L), L = g.createColorGeometry({
                    indices: L, attributeData: {
                      position: N, color: P.color, mapPosition: G, uvMapSpace: this._needsUV ? new Float32Array(P.uvMapSpace.buffer, 4 * O * P.uvMapSpace.BYTES_PER_ELEMENT, 4 * R) : null, boundingRect: this._needsUV ? new Float64Array(P.boundingRect.buffer, 9 * O * P.boundingRect.BYTES_PER_ELEMENT,
                        9 * R) : null
                    }
                  }), P.outGeometries.push(L), P.outMaterials.push(q.unwrap(this._material)), P.outTransforms.push(n.IDENTITY), P.outNum++)
              }
            }; K._createAs3DShapeOutline = function (P) {
              if (this._hasOutline) {
                var L = P.renderData.outlines; for (let N = 0; N < L.length; ++N) {
                  const { mapPosition: G, position: I } = L[N]; if (q.isSome(this._context.clippingExtent) && (l.empty(E), l.expandWithBuffer(E, G), !l.intersectsClippingArea(E, this._context.clippingExtent))) continue; const O = e.createGeometry({
                    overlayInfo: null, removeDuplicateStartEnd: 1, attributeData: {
                      position: I,
                      mapPosition: G
                    }
                  }), R = O.vertexAttributes.get("position"); R.data === I && (R.data = new Float64Array(I)); P.outGeometries.push(O); P.outMaterials.push(q.unwrap(this._outlineMaterial)); P.outTransforms.push(n.IDENTITY); P.outNum++
                }
              }
            }; K._createAsOverlay = function (P, L) {
              const N = g.geometryAsPolygon(P.geometry); if (q.isNone(N)) return null; q.unwrap(this._material).renderPriority = this._renderPriority + this._renderPriorityStep / 2; q.isSome(this._outlineMaterial) && (this._outlineMaterial.renderPriority = this._renderPriority); J.renderData =
                g.geometryToRenderInfoDraped(N, this._context.overlaySR); J.color = L; L = J.renderData.position.length / 3; this._needsUV && (J.uvMapSpace = new Float32Array(4 * L)); J.outNum = 0; J.outGeometries = []; J.outBoundingBox = l.empty(); J.layerUid = this._context.layer.uid; J.graphicsUid = P.uid; this._createAsOverlayFill(J); this._hasOutline && this._createAsOverlayOutline(J); this._logGeometryCreationWarnings(J.renderData, N.rings, "rings", "FillSymbol3DLayer"); if (0 === J.outNum) return null; this._needsUV && k.createMapSpaceUVCoordsDraped(h.BufferViewVec4f.fromTypedArray(J.uvMapSpace),
                  h.BufferViewVec3f64.fromTypedArray(J.renderData.position), this._context.overlaySR, this._context.layerView.view.state.viewingMode); return 0 < J.outNum ? new f(this, J.outGeometries, J.outBoundingBox) : null
            }; K._createAsOverlayFill = function (P) {
              var L = P.renderData.polygons; for (const { position: N, holeIndices: G, index: I, count: O } of L) {
                l.empty(E); l.expandWithBuffer(E, N); if (!l.intersectsClippingArea(E, this._context.clippingExtent)) continue; L = y.earcut(N, G, 3); if (0 === L.length) continue; l.expandWithAABB(P.outBoundingBox,
                  E); L = new Uint32Array(L); L = g.createColorGeometry({ indices: L, attributeData: { position: N, color: P.color, uvMapSpace: this._needsUV ? new Float32Array(P.uvMapSpace.buffer, 4 * I * P.uvMapSpace.BYTES_PER_ELEMENT, 4 * O) : null } }); L = new A.RenderGeometry(L, q.unwrap(this._material), P.layerUid, P.graphicsUid); const R = E; p.set(L.boundingSphere, .5 * (R[0] + R[3]), .5 * (R[1] + R[4]), 0, .5 * Math.sqrt((R[3] - R[0]) * (R[3] - R[0]) + (R[4] - R[1]) * (R[4] - R[1]))); P.outGeometries.push(L); P.outNum++
              }
            }; K._createAsOverlayOutline = function (P) {
              if (this._hasOutline) {
                var L =
                  P.renderData.outlines; for (let G = 0; G < L.length; ++G) {
                    var { position: N } = L[G]; l.empty(E); l.expandWithBuffer(E, N); if (!l.intersectsClippingArea(E, this._context.clippingExtent)) continue; l.expandWithAABB(P.outBoundingBox, E); N = e.createGeometry({ overlayInfo: { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper }, removeDuplicateStartEnd: 1, attributeData: { position: N } }); N = new A.RenderGeometry(N, q.unwrap(this._outlineMaterial), P.layerUid, P.graphicsUid); const I = E; p.set(N.boundingSphere,
                      .5 * (I[0] + I[3]), .5 * (I[1] + I[4]), 0, .5 * Math.sqrt((I[3] - I[0]) * (I[3] - I[0]) + (I[4] - I[1]) * (I[4] - I[1]))); P.outGeometries.push(N); P.outNum++
                  }
              }
            }; K._getOutlineOpacity = function () { const P = q.get(this.symbolLayer, "outline", "color"); return (this.draped ? 1 : this._getLayerOpacity()) * (q.isSome(P) ? P.a : 0) }; K._getOutlineColor = function () { const P = q.get(this.symbolLayer, "outline", "color"), L = this._getOutlineOpacity(); return m.mixinColorAndOpacity(q.isSome(P) ? c.toUnitRGB(P) : null, L) }; w._createClass(F, [{
              key: "test", get: function () {
                return {
                  createAsOverlay: (P,
                    L) => this._createAsOverlay(P, L), createAs3DShape: (P, L, N) => this._createAs3DShape(P, L, N)
                }
              }
            }]); return F
          }(v.Graphics3DSymbolLayer); v.elevationModeChangeTypes = { definedChanged: b.SymbolUpdateType.RECREATE, staysOnTheGround: b.SymbolUpdateType.NONE, onTheGroundChanged: b.SymbolUpdateType.RECREATE }; const E = l.create(), H = { renderData: null, color: null, uvMapSpace: null, boundingRect: null, outNum: 0, outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null }, J = {
            renderData: null, color: null, uvMapSpace: null, outNum: 0,
            outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null
          }; a.Graphics3DPolygonFillSymbolLayer = v; a.default = v; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/patternUtils": function () {
      define("exports ../../../../core/has ../../../../core/maybe ../../../../chunks/vec4f64 ../../../../geometry/support/buffer/BufferView ../graphics/ElevationAligners ./uvUtils ../../webgl-engine/materials/ColorMaterial ../../webgl-engine/materials/PatternMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(t, v, m) { if (c.isSome(t)) { if ("none" === t.style || "solid" === t.style) return "none" === t.style && (v.color = q.fromValues(0, 0, 0, 0), v.transparent = !0), new p.ColorMaterial(v); v.style = b(t.style); v.draped = m.isDraped; return new l.PatternMaterial(v) } return new p.ColorMaterial(v) } function b(t) { switch (t) { case "horizontal": return 0; case "vertical": return 1; case "cross": return 2; case "forward-diagonal": return 3; case "backward-diagonal": return 4; case "diagonal-cross": return 5 } } function d(t) {
            return t.material instanceof
              l.PatternMaterial && !t.material.parameters.draped
          } function f(t, v) { if (d(t)) { var m = t.geometry.vertexAttributes; t = m.get("position").data; const e = m.get("uvMapSpace").data; m = m.get("boundingRect").data; n.createMapSpaceUVCoords(u.BufferViewVec4f.fromTypedArray(e), u.BufferViewVec3f64.fromTypedArray(t), v, u.BufferViewMat3f64.fromTypedArray(m)) } } a.createMaterial = function (t, v, m) { return h(t && t.pattern || null, v, m) }; a.createMaterialFromPattern = h; a.parsePatternStyle = b; a.requiresUVUpdates = d; a.updateMapSpaceUVCoords =
            f; a.uvElevationAligner = function (t, v, m, e) { v = y.perVertexElevationAligner(t, v, m, e); t = t.stageObject.geometryRecords; for (m = 0; m < t.length; m++)f(t[m], e); return v }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/uvUtils": function () {
      define("exports ../../../../core/maybe ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/projectionEllipsoid ../../../../geometry/support/plane ../../../../geometry/support/buffer/BufferView".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(M, F, K, P, L, N, G) { y.set(M, F * L[0] + K * N[0] + P * G[0], F * L[1] + K * N[1] + P * G[1], F * L[2] + K * N[2] + P * G[2]) } const f = n.create(), t = n.create(), v = h.create(), m = n.create(), e = n.create(), g = n.create(), x = u.create(), k = u.create(), r = u.create(), A = n.create(), z = n.create(), B = n.create(), C = c.create(), D = n.create(), E = n.create(), H = n.create(), J = n.create(); a.createMapSpaceUVCoords = function (M, F, K, P, L = 1) {
            y.set(m, 1, 0, 0); y.set(e, 0, 1, 0); y.set(g, 0, 0, 1); y.set(J, 0, 0, 0); for (var N = 0; N < F.count - 1; N++)F.getVec(N,
              t), y.add(J, J, t); y.scale(f, J, 1 / (F.count - 1)); N = F.count - 1; if (N = h.fromManyPointsSampleAt(F, v, 0, Math.floor(N / 3), Math.floor(2 / 3 * N))) {
                w.isSome(K) ? (K.basisMatrixAtPosition(f, C), y.set(D, C[0], C[1], C[2]), y.set(E, C[4], C[5], C[6]), y.set(H, C[8], C[9], C[10])) : (y.set(D, 1, 0, 0), y.set(E, 0, 1, 0), y.set(H, 0, 0, 1)); K = h.normal(v); 0 > y.dot(K, H) && y.scale(K, K, -1); y.copy(g, K); N = y.dot(K, E); var G = y.dot(K, D); Math.abs(N) < Math.abs(G) ? (y.scaleAndAdd(m, D, K, -G), y.normalize(m, m), y.cross(e, m, K), y.normalize(e, e), y.scale(e, e, -1)) : (y.scaleAndAdd(e,
                  E, K, -N), y.normalize(e, e), y.cross(m, e, K), y.normalize(m, m))
              } q.set(x, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY); q.set(k, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY); for (K = 0; K < F.count; K++)F.getVec(K, t), N = y.dot(m, t), G = y.dot(e, t), x[0] = Math.min(x[0], N), x[1] = Math.min(x[1], G), k[0] = Math.max(k[0], N), k[1] = Math.max(k[1], G); K = y.dot(g, f); d(A, x[0], x[1], K, m, e, g); d(z, k[0], x[1], K, m, e, g); d(B, x[0], k[1], K, m, e, g); y.subtract(z, z, A); y.scale(z, z, .5); y.subtract(B, B, A); y.scale(B, B, .5); y.add(A, A, z); y.add(A, A, B);
            K = x[1] % L; r[0] = x[0] - x[0] % L; r[1] = x[1] - K; for (K = 0; K < F.count; K++)for (F.getVec(K, t), M.setValues(K, (y.dot(m, t) - r[0]) / L, (y.dot(e, t) - r[1]) / L, r[0] / L, r[1] / L), N = 0; 3 > N; N++)P.set(K, N, A[N]), P.set(K, N + 3, z[N]), P.set(K, N + 6, B[N])
          }; a.createMapSpaceUVCoordsDraped = function (M, F, K, P, L = 1) {
            if (K.isGeographic && 2 !== P) { P = new Float64Array(F.typedBuffer.length); const N = 3 * F.count; K = l.getReferenceEllipsoid(K); for (let G = 0; G < N; G += 3)p.lonLatToWebMercatorComparable(F.typedBuffer, G, P, G, K); F = b.BufferViewVec3f64.fromTypedArray(P) } q.set(x,
              Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY); for (P = 0; P < F.count; P++)F.getVec(P, t), x[0] = Math.min(x[0], t[0]), x[1] = Math.min(x[1], t[1]); P = x[1] % L; r[0] = x[0] - x[0] % L; r[1] = x[1] - P; for (P = 0; P < F.count; P++)F.getVec(P, t), M.setValues(P, (t[0] - r[0]) / L, (t[1] - r[1]) / L, r[0] / L, r[1] / L)
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/ColorMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../lib/GLMaterial ../lib/GLMaterials ../lib/Material ../lib/OrderIndependentTransparency ./internal/DefaultBufferWriter ./internal/MaterialUtil ../shaders/ColorMaterialTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          let h = function (f) {
            function t(m) { m = f.call(this, m, d) || this; m.supportsEdges = !0; m.techniqueConfig = new l.ColorMaterialTechniqueConfiguration; return m } w._inheritsLoose(t, f); var v = t.prototype; v.getTechniqueConfig = function (m, e) {
              this.techniqueConfig.output = m; this.techniqueConfig.cullFace = this.parameters.cullFace; this.techniqueConfig.vertexColors = this.parameters.vertexColors; this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled; this.techniqueConfig.transparent =
                this.parameters.transparent; this.techniqueConfig.polygonOffset = this.parameters.polygonOffset; this.techniqueConfig.writeDepth = this.parameters.writeDepth; this.techniqueConfig.sceneHasOcludees = this.parameters.sceneHasOcludees; this.techniqueConfig.transparencyPassType = e.transparencyPassType; this.techniqueConfig.enableOffset = e.camera.relativeElevation < y.OITPolygonOffsetLimit; this.techniqueConfig.multipassTerrainEnabled = e.multipassTerrainEnabled; this.techniqueConfig.cullAboveGround = e.cullAboveGround; return this.techniqueConfig
            };
            v.getPassParameters = function () { return this.parameters }; v.intersect = function (m, e, g, x, k, r, A) { p.intersectTriangleGeometry(m, e, x, k, r, void 0, A) }; v.requiresSlot = function (m, e) { return 20 === m ? !0 : 4 === q.outputFromPass(e) ? 2 === m : m === (this.parameters.transparent ? this.parameters.writeDepth ? 4 : 7 : 2) }; v.createGLMaterial = function (m) { return 0 === m.output || 7 === m.output || 4 === m.output || 1 === m.output && this.parameters.writeLinearDepth ? new b(m) : null }; v.createBufferWriter = function () { return new n.DefaultBufferWriter(n.PositionColorLayout) };
            return t
          }(u.Material), b = function (f) {
            function t() { return f.apply(this, arguments) || this } w._inheritsLoose(t, f); var v = t.prototype; v.updateParameters = function (m) { return this.ensureTechnique(l.ColorMaterialTechnique, m) }; v._updateOccludeeState = function (m) { m.hasOccludees !== this._material.parameters.sceneHasOcludees && this._material.setParameters({ sceneHasOcludees: m.hasOccludees }) }; v.beginSlot = function (m) { 0 !== this._output && 7 !== this._output || this._updateOccludeeState(m); return this.updateParameters(m) }; v.bind =
              function (m, e) { e.bindPass(this._material.getPassParameters(), m) }; return t
          }(c); const d = { color: [1, 1, 1, 1], transparent: !1, writeDepth: !0, writeLinearDepth: !1, vertexColors: !1, polygonOffset: !1, slicePlaneEnabled: !1, cullFace: 0, sceneHasOcludees: !1, ...u.materialParametersDefaults }; a.ColorMaterial = h; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/shaders/ColorMaterialTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../../../../chunks/ColorMaterial.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          h = function (x) {
            function k() { return x.apply(this, arguments) || this } c._inheritsLoose(k, x); var r = k.prototype; r.initializeProgram = function (A) {
              var z = k.shader.get(); const B = this.configuration; z = z.build({ output: B.output, OITEnabled: 0 === B.transparencyPassType, attributeColor: B.vertexColors, slicePlaneEnabled: B.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, multipassTerrainEnabled: B.multipassTerrainEnabled, cullAboveGround: B.cullAboveGround });
              return new t.Program(A.rctx, z, d.Default3D)
            }; r.bindPass = function (A, z) {
              p.bindProjectionMatrix(this.program, z.camera.projectionMatrix); this.program.setUniform4fv("eColor", A.color); 4 === this.configuration.output && y.bindOutputHighlight(this.program, z); (1 === this.configuration.output || z.multipassTerrainEnabled) && this.program.setUniform2fv("cameraNearFar", z.camera.nearFar); z.multipassTerrainEnabled && (this.program.setUniform2fv("inverseViewport", z.inverseViewport), n.bindMultipassTerrainTexture(this.program,
                z))
            }; r.bindDraw = function (A) { p.bindView(this.program, A); this.program.rebindTextures(); u.bindSliceUniformsWithOrigin(this.program, this.configuration, A) }; r.createPipeline = function (A, z) {
              const B = this.configuration, C = 3 === A, D = 2 === A; return e.makePipelineState({
                blending: 0 !== B.output && 7 !== B.output || !B.transparent ? null : C ? f.blendingDefault : f.OITBlending(A), culling: e.cullingParams(B.cullFace), depthTest: { func: f.OITDepthTest(A) }, depthWrite: C || D ? B.writeDepth && e.defaultDepthWriteParams : null, colorWrite: e.defaultColorWriteParams,
                stencilWrite: B.sceneHasOcludees ? v.stencilWriteMaskOn : null, stencilTest: B.sceneHasOcludees ? z ? v.stencilToolMaskBaseParams : v.stencilBaseAllZerosParams : null, polygonOffset: C || D ? B.polygonOffset && g : f.getOITPolygonOffset(B.enableOffset)
              })
            }; r.initializePipeline = function () { this._occludeePipelineState = this.createPipeline(this.configuration.transparencyPassType, !0); return this.createPipeline(this.configuration.transparencyPassType, !1) }; r.getPipelineState = function (A, z) {
              return z ? this._occludeePipelineState : x.prototype.getPipelineState.call(this,
                A, z)
            }; return k
          }(h.ShaderTechnique); h.shader = new l.ReloadableShaderModule(m.ColorMaterialShader, () => new Promise((x, k) => a(["./ColorMaterial.glsl"], x, k))); const g = { factor: 1, units: 1 }; l = function (x) {
            function k() { var r = x.apply(this, arguments) || this; r.output = 0; r.cullFace = 0; r.slicePlaneEnabled = !1; r.vertexColors = !1; r.transparent = !1; r.polygonOffset = !1; r.enableOffset = !0; r.writeDepth = !0; r.sceneHasOcludees = !1; r.transparencyPassType = 3; r.multipassTerrainEnabled = !1; r.cullAboveGround = !1; return r } c._inheritsLoose(k,
              x); return k
          }(b.ShaderTechniqueConfiguration); q.__decorate([b.parameter({ count: 8 })], l.prototype, "output", void 0); q.__decorate([b.parameter({ count: 3 })], l.prototype, "cullFace", void 0); q.__decorate([b.parameter()], l.prototype, "slicePlaneEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "vertexColors", void 0); q.__decorate([b.parameter()], l.prototype, "transparent", void 0); q.__decorate([b.parameter()], l.prototype, "polygonOffset", void 0); q.__decorate([b.parameter()], l.prototype, "enableOffset", void 0);
          q.__decorate([b.parameter()], l.prototype, "writeDepth", void 0); q.__decorate([b.parameter()], l.prototype, "sceneHasOcludees", void 0); q.__decorate([b.parameter({ count: 4 })], l.prototype, "transparencyPassType", void 0); q.__decorate([b.parameter()], l.prototype, "multipassTerrainEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "cullAboveGround", void 0); w.ColorMaterialTechnique = h; w.ColorMaterialTechniqueConfiguration = l; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/ColorMaterial.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          function f(v) {
            const m = new d.ShaderBuilder, e = 1 === v.output; m.include(c.Transform, { linearDepth: e }); m.include(q.VertexColor, v); m.vertex.uniforms.add("proj", "mat4").add("view", "mat4"); m.attributes.add("position", "vec3"); m.varyings.add("vpos", "vec3"); v.multipassTerrainEnabled && m.varyings.add("depth", "float"); e && (m.include(u.OutputDepth, v), m.vertex.uniforms.add("cameraNearFar", "vec2"), m.varyings.add("linearDepth", "float")); m.vertex.code.add(b.glsl`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${v.multipassTerrainEnabled ? "depth \x3d (view * vec4(vpos, 1.0)).z;" : ""}
      gl_Position = ${e ? b.glsl`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);` : b.glsl`transformPosition(proj, view, vpos);`}
    }
  `); m.include(w.Slice, v); m.fragment.include(h.ColorConversion); v.multipassTerrainEnabled && (m.fragment.include(n.ReadLinearDepth), m.include(p.multipassTerrainTest, v)); m.fragment.uniforms.add("eColor", "vec4"); 4 === v.output && m.include(y.OutputHighlight); m.fragment.code.add(b.glsl`
  void main() {
    discardBySlice(vpos);
    ${v.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
    vec4 color = ${v.attributeColor ? "vColor * eColor;" : "eColor;"}

    if (color.a < ${b.glsl.float(l.symbolAlphaCutoff)}) {
      discard;
    }

    ${7 === v.output ? b.glsl`gl_FragColor = vec4(color.a);` : ""}

    ${0 === v.output ? b.glsl`gl_FragColor = highlightSlice(color, vpos); ${v.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}` : ""}
    ${4 === v.output ? b.glsl`outputHighlight();` : ""};
    ${1 === v.output ? b.glsl`outputDepth(linearDepth);` : ""};
  }
  `); return m
          } const t = Object.freeze({ __proto__: null, build: f }); a.ColorMaterialShader = t; a.build = f
        })
    }, "esri/views/3d/webgl-engine/materials/PatternMaterial": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../geometry/support/buffer/BufferView ../../support/buffer/InterleavedLayout ../lib/GLMaterial ../lib/GLMaterials ../lib/Material ../lib/OrderIndependentTransparency ../lib/Util ./internal/bufferWriterUtils ./internal/DefaultBufferWriter ./internal/MaterialUtil ../shaders/PatternTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          let t = function (g) {
            function x(r) { r = g.call(this, r, e) || this; r.supportsEdges = !0; r._vertexAttributeLocations = f.patternVertexAttributeLocations; r.techniqueConfig = new f.PatternTechniqueConfiguration; return r } w._inheritsLoose(x, g); var k = x.prototype; k.getTechniqueConfig = function (r, A) {
              this.techniqueConfig.output = r; this.techniqueConfig.cullFace = this.parameters.cullFace; this.techniqueConfig.vertexColors = this.parameters.vertexColors; this.techniqueConfig.slicePlaneEnabled = this.parameters.slicePlaneEnabled;
              this.techniqueConfig.polygonOffset = this.parameters.polygonOffset; this.techniqueConfig.writeDepth = this.parameters.writeDepth; this.techniqueConfig.style = this.parameters.style; this.techniqueConfig.patternSpacing = this.parameters.patternSpacing; this.techniqueConfig.lineWidth = this.parameters.lineWidth; this.techniqueConfig.draped = this.parameters.draped; this.techniqueConfig.transparencyPassType = A.transparencyPassType; this.techniqueConfig.enableOffset = A.camera.relativeElevation < p.OITPolygonOffsetLimit; this.techniqueConfig.multipassTerrainEnabled =
                A.multipassTerrainEnabled; this.techniqueConfig.cullAboveGround = A.cullAboveGround; return this.techniqueConfig
            }; k.getPassParameters = function () { return this.parameters }; k.intersect = function (r, A, z, B, C, D, E) { d.intersectTriangleGeometry(r, A, B, C, D, void 0, E) }; k.requiresSlot = function (r, A) { return 20 === r ? !0 : 4 === y.outputFromPass(A) ? 2 === r : r === (this.parameters.writeDepth ? 4 : 7) }; k.createGLMaterial = function (r) { return 0 === r.output || 7 === r.output || 4 === r.output || 1 === r.output && this.parameters.writeLinearDepth ? new v(r) : null };
            k.createBufferWriter = function () { const r = q.newLayout().vec3f("position").vec4u8("color").vec4f("uvMapSpace"); this.parameters.draped || r.mat3f("boundingRect"); return new m(r) }; return x
          }(n.Material), v = function (g) {
            function x() { return g.apply(this, arguments) || this } w._inheritsLoose(x, g); var k = x.prototype; k.updateParameters = function (r) { return this.ensureTechnique(f.PatternTechnique, r) }; k._updateOccludeeState = function (r) { r.hasOccludees !== this._material.parameters.sceneHasOcludees && this._material.setParameters({ sceneHasOcludees: r.hasOccludees }) };
            k.beginSlot = function (r) { 0 !== this._output && 7 !== this._output || this._updateOccludeeState(r); return this.updateParameters(r) }; k.bind = function (r, A) { A.bindPass(this._material.getPassParameters(), r) }; return x
          }(u), m = function (g) {
            function x() { return g.apply(this, arguments) || this } w._inheritsLoose(x, g); var k = x.prototype; k.write = function (r, A, z, B) {
              for (const D of this.vertexBufferLayout.fieldNames) {
                const E = A.vertexAttributes.get(D), H = A.indices.get(D); if (E && H) switch (D) {
                  case "position": l.assert(3 === E.size); var C =
                    z.getField(D, c.BufferViewVec3f); C && h.writePosition(H, E.data, r.transformation, C, B); break; case "color": l.assert(3 === E.size || 4 === E.size); (C = z.getField(D, c.BufferViewVec4u8)) && h.writeColor(H, E.data, E.size, C, B); break; case "uvMapSpace": l.assert(4 === E.size); (C = z.getField(D, c.BufferViewVec4f)) && h.writeBufferVec4(H, E.data, C, B); break; case "boundingRect": l.assert(9 === E.size), (C = z.getField(D, c.BufferViewMat3f)) && this.writeBoundingRect(H, E.data, r.transformation, C, B)
                }
              }
            }; k.writeBoundingRect = function (r, A, z, B, C) {
              const D =
                B.typedBuffer; B = B.typedBufferStride; const E = r.length; C *= B; for (let J = 0; J < E; ++J) { const M = 9 * r[J]; var H = A[M]; const F = A[M + 1], K = A[M + 2]; D[C] = z[0] * H + z[4] * F + z[8] * K + z[12]; D[C + 1] = z[1] * H + z[5] * F + z[9] * K + z[13]; D[C + 2] = z[2] * H + z[6] * F + z[10] * K + z[14]; for (H = 3; 9 > H; ++H)D[C + H] = A[M + H]; C += B }
            }; return x
          }(b.DefaultBufferWriter); const e = { color: [1, 1, 1, 1], writeDepth: !0, writeLinearDepth: !1, vertexColors: !1, polygonOffset: !1, slicePlaneEnabled: !1, cullFace: 0, sceneHasOcludees: !1, style: 2, patternSpacing: 10, lineWidth: 1, draped: !0, ...n.materialParametersDefaults };
          a.PatternMaterial = t; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/shaders/PatternTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../core/shaderLibrary/util/View.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../../../../chunks/Pattern.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          h = function (x) {
            function k() { return x.apply(this, arguments) || this } c._inheritsLoose(k, x); var r = k.prototype; r.initializeProgram = function (A) {
              var z = k.shader.get(); const B = this.configuration; z = z.build({
                output: B.output, attributeColor: B.vertexColors, slicePlaneEnabled: B.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, style: B.style, patternSpacing: B.patternSpacing, lineWidth: B.lineWidth, draped: B.draped, OITEnabled: 0 === B.transparencyPassType,
                multipassTerrainEnabled: B.multipassTerrainEnabled, cullAboveGround: B.cullAboveGround
              }); return new f.Program(A.rctx, z, g)
            }; r.bindPass = function (A, z) {
              p.bindProjectionMatrix(this.program, z.camera.projectionMatrix); this.program.setUniform4fv("matColor", A.color); this.configuration.draped ? (this.program.setUniform1f("worldToScreenRatio", 1 / z.screenToPCSRatio), this.program.setUniform1f("texelSize", 1 / z.camera.pixelRatio)) : this.program.setUniform1f("worldToScreenPerDistanceRatio", 1 / z.camera.perScreenPixelRatio);
              4 === this.configuration.output && y.bindOutputHighlight(this.program, z); (1 === this.configuration.output || z.multipassTerrainEnabled) && this.program.setUniform2fv("cameraNearFar", z.camera.nearFar); z.multipassTerrainEnabled && (this.program.setUniform2fv("inverseViewport", z.inverseViewport), n.bindMultipassTerrainTexture(this.program, z))
            }; r.bindDraw = function (A) {
              p.bindView(this.program, A); p.bindCameraPosition(this.program, A.origin, A.camera.viewInverseTransposeMatrix); u.bindSliceUniformsWithOrigin(this.program,
                this.configuration, A); this.program.rebindTextures()
            }; r.setPipelineState = function (A, z) {
              const B = this.configuration, C = 3 === A, D = 2 === A; return m.makePipelineState({
                blending: 0 === B.output || 7 === B.output ? C ? d.blendingDefault : d.OITBlending(A) : null, culling: m.cullingParams(B.cullFace), depthTest: { func: d.OITDepthTest(A) }, depthWrite: C ? B.writeDepth && m.defaultDepthWriteParams : d.OITDepthWrite(A), colorWrite: m.defaultColorWriteParams, stencilWrite: B.sceneHasOcludees ? t.stencilWriteMaskOn : null, stencilTest: B.sceneHasOcludees ?
                  z ? t.stencilToolMaskBaseParams : t.stencilBaseAllZerosParams : null, polygonOffset: C || D ? B.polygonOffset && e : d.getOITPolygonOffset(B.enableOffset)
              })
            }; r.initializePipeline = function () { this._occludeePipelineState = this.setPipelineState(this.configuration.transparencyPassType, !0); return this.setPipelineState(this.configuration.transparencyPassType, !1) }; r.getPipelineState = function (A, z) { return z ? this._occludeePipelineState : x.prototype.getPipelineState.call(this, A, z) }; return k
          }(h.ShaderTechnique); h.shader = new l.ReloadableShaderModule(v.PatternShader,
            () => new Promise((x, k) => a(["./Pattern.glsl"], x, k))); const e = { factor: 1, units: 1 }; l = function (x) { function k() { var r = x.apply(this, arguments) || this; r.output = 0; r.cullFace = 0; r.slicePlaneEnabled = !1; r.vertexColors = !1; r.polygonOffset = !1; r.writeDepth = !0; r.sceneHasOcludees = !1; r.enableOffset = !0; r.transparencyPassType = 3; r.multipassTerrainEnabled = !1; r.cullAboveGround = !1; return r } c._inheritsLoose(k, x); return k }(b.ShaderTechniqueConfiguration); q.__decorate([b.parameter({ count: 8 })], l.prototype, "output", void 0); q.__decorate([b.parameter({ count: 3 })],
              l.prototype, "cullFace", void 0); q.__decorate([b.parameter()], l.prototype, "slicePlaneEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "vertexColors", void 0); q.__decorate([b.parameter()], l.prototype, "polygonOffset", void 0); q.__decorate([b.parameter()], l.prototype, "writeDepth", void 0); q.__decorate([b.parameter()], l.prototype, "sceneHasOcludees", void 0); q.__decorate([b.parameter({ count: 6 })], l.prototype, "style", void 0); q.__decorate([b.parameter()], l.prototype, "patternSpacing", void 0); q.__decorate([b.parameter()],
                l.prototype, "lineWidth", void 0); q.__decorate([b.parameter()], l.prototype, "enableOffset", void 0); q.__decorate([b.parameter()], l.prototype, "draped", void 0); q.__decorate([b.parameter({ count: 4 })], l.prototype, "transparencyPassType", void 0); q.__decorate([b.parameter()], l.prototype, "multipassTerrainEnabled", void 0); q.__decorate([b.parameter()], l.prototype, "cullAboveGround", void 0); const g = new Map([["position", 0], ["color", 3], ["uvMapSpace", 4], ["boundingRect", 5]]); w.PatternTechnique = h; w.PatternTechniqueConfiguration =
                  l; w.patternVertexAttributeLocations = g; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/Pattern.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          function f(m) {
            const e = new d.ShaderBuilder; m.draped || e.extensions.add("GL_OES_standard_derivatives"); const g = 1 === m.output; e.include(c.Transform, { linearDepth: g }); e.include(q.VertexColor, m); e.vertex.uniforms.add("proj", "mat4"); e.vertex.uniforms.add("view", "mat4"); g && (e.include(u.OutputDepth, m), e.vertex.uniforms.add("cameraNearFar", "vec2"), e.varyings.add("linearDepth", "float")); m.draped ? e.vertex.uniforms.add("worldToScreenRatio", "float") : (e.vertex.uniforms.add("worldToScreenPerDistanceRatio",
              "float"), e.vertex.uniforms.add("camPos", "vec3"), e.attributes.add("boundingRect", "mat3")); e.attributes.add("position", "vec3"); e.attributes.add("uvMapSpace", "vec4"); e.varyings.add("vpos", "vec3"); e.varyings.add("vuv", "vec2"); m.multipassTerrainEnabled && e.varyings.add("depth", "float"); const x = 3 === m.style || 4 === m.style || 5 === m.style; x && e.vertex.code.add(b.glsl`
      const mat2 rotate45 = mat2(${b.glsl.float(.70710678118)}, ${b.glsl.float(-.70710678118)},
                                 ${b.glsl.float(.70710678118)}, ${b.glsl.float(.70710678118)});
    `); m.draped || (e.vertex.code.add(b.glsl`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {
float projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);
return center + halfVector * clamp(projectedLength, -1.0, 1.0);
}`), e.vertex.code.add(b.glsl`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {
float d = dot(planeNormal, planePoint);
float t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);
return rayOrigin + t * rayDir;
}`), e.vertex.code.add(b.glsl`
      float boundingRectDistanceToCamera() {
        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);
        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);
        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);
        vec3 n = normalize(cross(halfU, halfV));

        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);

        float viewAngle = dot(viewDir, n);
        float minViewAngle = ${b.glsl.float(.08715574274)};

        if (abs(viewAngle) < minViewAngle) {
          // view direction is (almost) parallel to plane -> clamp it to min angle
          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;
          viewDir = normalize(viewDir + normalComponent * n);
        }

        // intersect view direction with infinite plane that contains bounding rect
        vec3 planeProjected = intersectRayPlane(viewDir, camPos, n, center);

        // clip to bounds by projecting to u and v line segments individually
        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);
        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);

        // use to calculate the closest point to camera on bounding rect
        vec3 closestPoint = uProjected + vProjected - center;

        return length(closestPoint - camPos);
      }
    `)); e.vertex.code.add(b.glsl`
    vec2 scaledUV() {
      vec2 uv = uvMapSpace.xy ${x ? " * rotate45" : ""};
      vec2 uvCellOrigin = uvMapSpace.zw ${x ? " * rotate45" : ""};

      ${m.draped ? "" : b.glsl`
            float distanceToCamera = boundingRectDistanceToCamera();
            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;
          `}

      // Logarithmically discretize ratio to avoid jittering
      float step = 0.1;
      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);

      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${b.glsl.float(m.patternSpacing)});
      return uvOffset + (uv * discreteWorldToScreenRatio);
    }
  `); e.vertex.code.add(b.glsl`
    void main(void) {
      vuv = scaledUV();
      vpos = position;
      ${m.multipassTerrainEnabled ? "depth \x3d (view * vec4(vpos, 1.0)).z;" : ""}
      forwardNormalizedVertexColor();
      gl_Position = ${g ? b.glsl`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);` : b.glsl`transformPosition(proj, view, vpos);`}
    }
  `); e.include(w.Slice, m); e.fragment.include(h.ColorConversion); e.fragment.uniforms.add("matColor", "vec4"); m.draped && e.fragment.uniforms.add("texelSize", "float"); 4 === m.output && e.include(y.OutputHighlight); m.multipassTerrainEnabled && (e.fragment.include(n.ReadLinearDepth), e.include(p.multipassTerrainTest, m)); 4 !== m.output && (e.fragment.code.add(b.glsl`
      const float lineWidth = ${b.glsl.float(m.lineWidth)};
      const float spacing = ${b.glsl.float(m.patternSpacing)};
      const float spacingINV = ${b.glsl.float(1 / m.patternSpacing)};

      float coverage(float p, float txlSize) {
        p = mod(p, spacing);

        float halfTxlSize = txlSize / 2.0;

        float start = p - halfTxlSize;
        float end = p + halfTxlSize;

        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;
        coverage -= min(lineWidth, mod(start, spacing));
        coverage -= max(lineWidth - mod(end, spacing), 0.0);

        return coverage / txlSize;
      }
    `), m.draped || e.fragment.code.add(b.glsl`const int maxSamples = 5;
float sample(float p) {
vec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));
float fwidth = dxdy.x + dxdy.y;
ivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));
vec2 invSamples = 1.0 / vec2(samples);
float accumulator = 0.0;
for (int j = 0; j < maxSamples; j++) {
if(j >= samples.y) {
break;
}
for (int i = 0; i < maxSamples; i++) {
if(i >= samples.x) {
break;
}
vec2 step = vec2(i,j) * invSamples - 0.5;
accumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);
}
}
accumulator /= float(samples.x * samples.y);
return accumulator;
}`)); e.fragment.code.add(b.glsl`
    void main() {
      discardBySlice(vpos);
      ${m.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
      vec4 color = ${m.attributeColor ? "vColor * matColor;" : "matColor;"}
      color = highlightSlice(color, vpos);

      ${4 !== m.output ? b.glsl`color.a *= ${t(m)};` : ""}

      if (color.a < ${b.glsl.float(l.symbolAlphaCutoff)}) {
        discard;
      }

      ${7 === m.output ? b.glsl`gl_FragColor = vec4(color.a);` : ""}

      ${0 === m.output ? b.glsl`gl_FragColor = color; ${m.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}` : ""}
      ${4 === m.output ? b.glsl`outputHighlight();` : ""}
      ${1 === m.output ? b.glsl`outputDepth(linearDepth);` : ""};
    }
  `); return e
          } function t(m) {
            function e(g) { return m.draped ? b.glsl`coverage(vuv.${g}, texelSize)` : b.glsl`sample(vuv.${g})` } switch (m.style) {
              case 3: case 0: return e("y"); case 4: case 1: return e("x"); case 5: case 2: return b.glsl`
        1.0 - (1.0 - ${e("x")}) * (1.0 - ${e("y")})
      `; default: return "0.0"
            }
          } const v = Object.freeze({ __proto__: null, build: f }); a.PatternShader = v; a.build = f
        })
    }, "esri/views/3d/layers/graphics/Graphics3DTextSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Error ../../../../core/maybe ../../../../core/screenUtils ../../../../chunks/vec2f64 ../../../../symbols/callouts/calloutUtils ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./graphicUtils ./pointUtils ../../webgl-engine/lib/GeometryUtil ../../webgl-engine/lib/TextRenderParameters ../../webgl-engine/lib/TextTexture ../../webgl-engine/materials/HUDMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
          function x(z, B, C) { z && z.forEach(D => { const E = B(D); q.isSome(E) && C(E, D.graphic) }) } const k = [0, 0, 1]; d = function (z) {
            function B(D, E, H, J) { D = z.call(this, D, E, H, J) || this; D._elevationOptions = { supportsOffsetAdjustment: !0, supportsOnTheGround: !1 }; D.ensureDrapedStatus(!1); return D } w._inheritsLoose(B, z); var C = B.prototype; C.doLoad = function () {
              var D = w._asyncToGenerator(function* () {
                if (!this._drivenProperties.size) {
                  const E = f.validateSymbolLayerSize(this.symbolLayer.size); if (E) throw new c("graphics3dtextsymbollayer:invalid-size",
                    E);
                } this._createTextRenderParameters()
              }); return function () { return D.apply(this, arguments) }
            }(); C._createTextRenderParameters = function () { this._textRenderParameters = m.TextRenderParameters.fromSymbol(this.symbolLayer, this._context.layerView.view.pixelRatio) }; C.destroy = function () { z.prototype.destroy.call(this) }; C.createGraphics3DGraphic = function (D) {
              D = D.graphic; const E = t.placePointOnGeometry(D.geometry); if (q.isNone(E)) return this.logger.warn(`unsupported geometry type for text symbol: ${D.geometry.type}`),
                null; const H = this.symbolLayer.text; if (!H) return null; const J = n.isCalloutSupport(this.symbol) && this.symbol.hasVisibleVerticalOffset() ? this.symbol : null; return this._createAs3DShape(D, E, H, J)
            }; C.createLabel = function (D, E, H, J) { D = D.graphic; const M = t.placePointOnGeometry(D.geometry); if (q.isNone(M)) return this.logger.warn(`unsupported geometry type for label: ${D.geometry.type}`), null; const F = E.text; return !F || /^\s+$/.test(F) ? null : this._createAs3DShape(D, M, F, E, E, H, J) }; C.setGraphicElevationContext = function (D,
              E, H = 0) { D = z.prototype.setGraphicElevationContext.call(this, D, E); D.addOffsetRenderUnits(H); return D }; C.layerOpacityChanged = function () { this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"); return !1 }; C.layerElevationInfoChanged = function (D, E) { x(D, E, (H, J) => { this.updateGraphicElevationContext(J, H) }); return l.SymbolUpdateType.UPDATE }; C.slicePlaneEnabledChanged = function (D, E) {
                x(D, E, H => { for (const J of H.stageObject.geometryRecords) J.material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }) });
                return !0
              }; C.physicalBasedRenderingChanged = function () { return !0 }; C.pixelRatioChanged = function () { return !1 }; C.updateGraphicElevationContext = function (D, E) { this.setGraphicElevationContext(D, E.elevationContext, E.metadata.elevationOffset); E.needsElevationUpdates = l.needsElevationUpdates2D(E.elevationContext.mode) || "absolute-height" === E.elevationContext.mode }; C._defaultElevationInfoNoZ = function () { return r }; C._createAs3DShape = function (D, E, H, J, M = A, F, K) {
                const P = this.setGraphicElevationContext(D, new h.ElevationContext,
                  M.elevationOffset); var L = "polyline" === q.get(D.geometry, "type"), N = D.uid; D = this._context.stage.renderView.renderingContext; var G = f.namedAnchorToHUDMaterialAnchorPos[M.anchor in f.namedAnchorToHUDMaterialAnchorPos ? M.anchor : "center"]; D = q.isNone(K) ? new e(D, H, this._textRenderParameters) : null; G = { occlusionTest: !0, screenOffset: M.screenOffset, anchorPos: G, polygonOffset: !0, color: [1, 1, 1, 1], centerOffsetUnits: M.centerOffsetUnits, debugDrawBorder: M.debugDrawBorder, drawInSecondSlot: !0 }; q.isSome(D) && (G.textureId = D.id,
                    G.texCoordScale = D.texcoordScale); q.isSome(K) && (G.textureId = K.id); if (q.isSome(J) && q.isSome(J.verticalOffset)) { const { screenLength: R, minWorldLength: S, maxWorldLength: Q } = J.verticalOffset; G.verticalOffset = { screenLength: u.pt2px(R), minWorldLength: S || 0, maxWorldLength: null != Q ? Q : Infinity } } if (this._context.screenSizePerspectiveEnabled) {
                      const { screenSizePerspectiveSettings: R, screenSizePerspectiveSettingsLabels: S } = this._context.sharedResources; G.screenSizePerspective = S.overridePadding(this._textRenderParameters.haloSize);
                      G.screenSizePerspectiveAlignment = R
                    } L && (G.shaderPolygonOffset = 1E-4); G.slicePlaneEnabled = this._context.slicePlaneEnabled; q.isSome(F) ? (K = JSON.stringify(G), J = F.get(K), q.isNone(J) && (J = new g.HUDMaterial(G), F.add(K, J))) : J = new g.HUDMaterial(G); J = [J]; K = M.translation; L = q.isSome(D) ? [D.displayWidth, D.displayHeight] : [0, 0]; K = [v.createPointGeometry(k, K, null, L, M.centerOffset, [0, 0], null)]; N = t.createStageObjectForHUD(this._context, E, K, J, P, this._context.layer.uid, N); if (null === N) return null; F = new b.Graphics3DObject3DGraphicLayer(this,
                      N.object, K, q.isNone(F) ? J : null, q.isSome(D) ? [D] : null, p.perObjectElevationAligner, P); F.alignedSampledElevation = N.sampledElevation; F.needsElevationUpdates = l.needsElevationUpdates2D(P.mode) || "absolute-height" === P.mode; const { displayWidth: I, displayHeight: O } = q.isSome(D) ? D : M; F.getScreenSize = (R = y.create()) => { R[0] = I; R[1] = O; return R }; F.metadata = { labelText: H, elevationOffset: M.elevationOffset }; t.extendPointGraphicElevationContext(F, E, this._context.elevationProvider); return F
              }; return B
          }(d.Graphics3DSymbolLayer);
          const r = { mode: "relative-to-ground", offset: 0 }, A = { text: null, translation: [0, 0, 0], elevationOffset: 0, centerOffset: [0, 0, 0, 1], screenOffset: [0, 0], anchor: "center", verticalOffset: null, centerOffsetUnits: null, debugDrawBorder: !1, displayWidth: 0, displayHeight: 0 }; a.Graphics3DTextSymbolLayer = d; a.default = d; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/TextRenderParameters": function () {
      define(["exports", "../../../../Color", "../../../../core/maybe", "../../../../core/screenUtils",
        "../../../../chunks/vec4f64"], function (a, w, c, q, u) {
          let y = function () {
            function n(l) { this.definition = l; this.key = JSON.stringify(l); this.haloSize = Math.round(l.halo.size); this.fillStyle = this.colorToRGBA(l.color); this.haloStyle = this.colorToRGB(l.halo.color) } var p = n.prototype; p.colorToRGB = function (l) { return `rgb(${l.slice(0, 3).map(h => Math.floor(255 * h)).toString()})` }; p.colorToRGBA = function (l) { return `rgba(${l.slice(0, 3).map(h => Math.floor(255 * h)).toString()},${l[3]})` }; n.fromSymbol = function (l, h = 1) {
              var b = c.get(l,
                "material", "color"); b = c.isSome(b) ? w.toUnitRGBA(b) : u.ZEROS; var d = l.halo; const f = null != l.size ? q.pt2px(l.size) : 12; l = { family: l.font && l.font.family ? l.font.family : "sans-serif", weight: l.font && l.font.weight ? l.font.weight : "normal", style: l.font && l.font.style ? l.font.style : "normal" }; d = c.isSome(d) && c.isSome(d.color) && 0 < d.size ? { size: q.pt2px(d.size), color: w.toUnitRGBA(d.color) } : { size: 0, color: u.ZEROS }; return new n({ size: f, color: b, font: l, halo: d, pixelRatio: h })
            }; return n
          }(); a.TextRenderParameters = y; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/TextTexture": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Evented ../../../../core/mathUtils ../../../../core/maybe ./ContentObject ./TextRenderer ../../../webgl/Texture ../../../webgl/capabilities/isWebGL2Context".split(" "), function (a, w, c, q, u, y, n, p) {
        const l = { canvas: null }; return function (h) {
          function b(f, t, v) {
            var m = h.call(this) || this; m.type = 4; m._glTexture = null; m.events = new w; m._requiresPowerOfTwo = !p(f.gl);
            m._renderer = new y.TextRenderer(t, v); return m
          } a._inheritsLoose(b, h); var d = b.prototype; d.createDescriptor = function (f) { return { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, flipped: !0, samplingMode: 9987, hasMipmap: !0, preMultiplyAlpha: !0, maxAnisotropy: f.parameters.maxMaxAnisotropy } }; d.load = function (f) {
            if (q.isSome(this._glTexture)) return this._glTexture; const t = y.getTextHelperCanvas(l, this.textureWidth, this.textureHeight), v = t.getContext("2d"); v.save(); this._renderer.render(v, 0, this.textureHeight -
              this._renderer.renderedHeight); this._glTexture = new n(f, this.createDescriptor(f), t); v.restore(); return this._glTexture
          }; d.unload = function () { q.isSome(this._glTexture) && (this._glTexture.dispose(), this._glTexture = null); this.events.emit("unloaded") }; a._createClass(b, [{ key: "width", get: function () { return this._renderer.renderedWidth } }, { key: "height", get: function () { return this._renderer.renderedHeight } }, {
            key: "textureWidth", get: function () {
              const f = this.width; return this._requiresPowerOfTwo ? c.nextHighestPowerOfTwo(f) :
                f
            }
          }, { key: "textureHeight", get: function () { const f = this.height; return this._requiresPowerOfTwo ? c.nextHighestPowerOfTwo(f) : f } }, { key: "displayWidth", get: function () { return this._renderer.displayWidth } }, { key: "displayHeight", get: function () { return this._renderer.displayHeight } }, { key: "texcoordScale", get: function () { return [this._renderer.renderedWidth / this.textureWidth, this._renderer.renderedHeight / this.textureHeight] } }, { key: "requiresFrameUpdates", get: function () { return !1 } }, { key: "glTexture", get: function () { return this._glTexture } }]);
          return b
        }(u.ContentObject)
      })
    }, "esri/views/3d/webgl-engine/lib/TextRenderer": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe"], function (a, w, c) {
        function q(p, l, h) { p.canvas || (p.canvas = document.createElement("canvas")); p.canvas.width = l; p.canvas.height = h; return p.canvas } let u = function () {
          function p(h, b, d = 2048) {
          this.text = h; this._parameters = b; this.maxSize = d; this._lineWidths = []; this._displayWidth = this._renderPixelRatio = null; this.key = `${this._parameters.key}--${h}`;
            this._lines = h.split(/\r?\n/); this._lineHeight = this.computeLineHeight()
          } var l = p.prototype; l.getLineXOffset = function (h) { return Math.round((this.renderedWidth - this._lineWidths[h] * this.renderPixelRatio) / 2) }; l.render = function (h, b = 0, d = 0) {
            const f = this.renderedLineHeight; var t = this.renderedHaloSize, v = h.textAlign, m = this.renderedWidth; v = ("center" === v ? .5 * m : "right" === v ? m : 0) + t; m = t + 1; h.save(); 0 < t && this.renderHalo(h, v, m, b, d); this.setFontProperties(h, this.renderedFontSize); d += m; b += v; for (t = 0; t < this._lines.length; ++t)h.globalCompositeOperation =
              "destination-out", h.fillStyle = "rgb(0, 0, 0)", v = this._lines[t], m = this.getLineXOffset(t), h.fillText(v, b + m, d), h.globalCompositeOperation = "source-over", h.fillStyle = this._parameters.fillStyle, h.fillText(v, b + this.getLineXOffset(t), d), d += f; h.restore()
          }; l.renderHalo = function (h, b, d, f, t) {
            const v = this.renderedWidth, m = this.renderedHeight, e = q(n, Math.max(v, 512), Math.max(m, 512)), g = e.getContext("2d"); g.clearRect(0, 0, v, m); this.setFontProperties(g, this.renderedFontSize); g.fillStyle = this._parameters.haloStyle; g.strokeStyle =
              this._parameters.haloStyle; const x = 3 > this.renderedHaloSize; g.lineJoin = x ? "miter" : "round"; x ? this.renderHaloEmulated(g, b, d) : this.renderHaloNative(g, b, d); h.globalAlpha = this._parameters.definition.halo.color[3]; h.drawImage(e, 0, 0, v, m, f, t, v, m); h.globalAlpha = 1
          }; l.renderHaloEmulated = function (h, b, d) { const f = this.renderedLineHeight, t = this.renderedHaloSize; for (let v = 0; v < this._lines.length; ++v) { const m = this._lines[v], e = this.getLineXOffset(v); for (const [g, x] of y) h.fillText(m, b + e + t * g, d + t * x); d += f } }; l.renderHaloNative =
            function (h, b, d) { const f = this.renderedLineHeight, t = this.renderedHaloSize; for (let v = 0; v < this._lines.length; ++v) { const m = 2 * t, e = this._lines[v], g = this.getLineXOffset(v); for (let x = 0; 5 > x; x++)h.lineWidth = (.6 + .1 * x) * m, h.strokeText(e, b + g, d); d += f } }; l.setFontProperties = function (h, b) { const d = this._parameters.definition.font; h.font = `${d.style} ${d.weight} ${b}px ${d.family}, sans-serif`; h.textAlign = "left"; h.textBaseline = "top" }; l._ensureTextWidth = function () {
              if (c.isSome(this._displayWidth)) return this._displayWidth;
              const h = q(n, 512, 512).getContext("2d"); this.setFontProperties(h, this._parameters.definition.size); let b = 0, d = 2 * this._parameters.haloSize; this._lineWidths.length = 0; var f = this._parameters.definition.font; if ("italic" === f.style || "oblique" === f.style || "string" === typeof f.weight && ("bold" === f.weight || "bolder" === f.weight) || "number" === typeof f.weight && 600 < f.weight) d += .3 * h.measureText("A").width; for (const t of this._lines) f = Math.round(h.measureText(t).width + d), this._lineWidths.push(f), b = Math.max(b, f); return this._displayWidth =
                b
            }; l.computeLineHeight = function () { return Math.ceil(1.275 * this._parameters.definition.size + 2 * this._parameters.haloSize) + 1 }; w._createClass(p, [{ key: "displayWidth", get: function () { return this._ensureTextWidth() } }, { key: "displayHeight", get: function () { return this._lineHeight * this._lines.length } }, { key: "renderedWidth", get: function () { return Math.round(this.displayWidth * this.renderPixelRatio) } }, { key: "renderedHeight", get: function () { return Math.round(this.displayHeight * this.renderPixelRatio) } }, {
              key: "renderedLineHeight",
              get: function () { return Math.round(this._lineHeight * this.renderPixelRatio) }
            }, { key: "renderedFontSize", get: function () { return this._parameters.definition.size * this.renderPixelRatio } }, { key: "renderedHaloSize", get: function () { return this._parameters.haloSize * this.renderPixelRatio } }, {
              key: "renderPixelRatio", get: function () {
                if (c.isNone(this._renderPixelRatio)) {
                  const h = this._parameters.definition.pixelRatio; this._renderPixelRatio = 0 < this.maxSize ? Math.min(h, Math.min(this.maxSize / (this.displayWidth * h), this.maxSize /
                    (this.displayHeight * h))) : h
                } return this._renderPixelRatio
              }
            }]); return p
        }(); const y = []; for (let p = 0; 360 > p; p += 22.5)y.push([Math.cos(Math.PI * p / 180), Math.sin(Math.PI * p / 180)]); const n = { canvas: null }; a.TextRenderer = u; a.default = u; a.getTextHelperCanvas = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DWaterSymbolLayer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/maybe ../../../../core/unitUtils ../../../../chunks/earcut ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec4 ../../../../chunks/common ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DDrapedGraphicLayer ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ./polygonUtils ../../webgl-engine/lib/Object3D ../../webgl-engine/lib/RenderGeometry ../../webgl-engine/materials/WaterMaterial ../../webgl-engine/materials/internal/waterMaterialUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B) {
          const C = ["polyline", "polygon", "extent"]; x = function (K) {
            function P(N, G, I, O) { return K.call(this, N, G, I, O) || this } w._inheritsLoose(P, K); var L = P.prototype; L.doLoad = function () { var N = w._asyncToGenerator(function* () { }); return function () { return N.apply(this, arguments) } }(); L.destroy = function () { K.prototype.destroy.call(this); this._context.stage.remove(this._material); this._material = null }; L.createGraphics3DGraphic = function (N) {
              N = N.graphic; if (!this._validateGeometry(N.geometry,
                C, this.symbolLayer.type)) return null; const G = this.setGraphicElevationContext(N, new m.ElevationContext); this.ensureDrapedStatus("on-the-ground" === G.mode); this.ensureMaterial(); return this.draped ? this._createAsOverlay(N) : this._createAs3DShape(N, G, N.uid)
            }; L.ensureMaterial = function () {
              if (!q.isSome(this._material)) {
                var N = { ...B.defaultWaterMaterialParameters }, G = this.symbolLayer.color; q.isSome(G) && (N.color = c.toUnitRGBA(G)); G = this._getCombinedOpacity(G, { hasIntrinsicColor: !0 }); N.color = [N.color[0], N.color[1],
                N.color[2], G]; N.transparent = 1 > G || this.needsDrivenTransparentPass; N.waveDirection = q.isSome(this.symbolLayer.waveDirection) ? P.headingVectorFromAngle(this.symbolLayer.waveDirection) : l.fromValues(0, 0); G = B.wavePresets[this.symbolLayer.waveStrength + "-" + this.symbolLayer.waterbodySize]; N.waveStrength = G.waveStrength; N.waveTextureRepeat = G.textureRepeat; N.waveVelocity = G.waveVelocity; N.flowStrength = G.perturbationStrength; N.slicePlaneEnabled = this._context.slicePlaneEnabled; N.isDraped = this.draped; this._material =
                  new z.WaterMaterial(N); this._context.stage.add(this._material)
              }
            }; L.layerOpacityChanged = function () { if (q.isNone(this._material)) return !0; const N = this._material.parameters.color, G = this._getCombinedOpacity(this.symbolLayer.color, { hasIntrinsicColor: !0 }); this._material.setParameters({ color: [N[0], N[1], N[2], G], transparent: 1 > G || this.needsDrivenTransparentPass }); return !0 }; L.layerElevationInfoChanged = function (N, G, I) {
              const O = this._elevationContext.mode; I = v.elevationModeChangeUpdateType(P.elevationModeChangeTypes,
                I, O); if (I !== v.SymbolUpdateType.UPDATE) return I; const R = v.needsElevationUpdates2D(O); return this.updateGraphics3DGraphicElevationInfo(N, G, () => R)
            }; L.slicePlaneEnabledChanged = function () { q.isSome(this._material) && this._material.setParameters({ slicePlaneEnabled: this._context.slicePlaneEnabled }); return !0 }; L.physicalBasedRenderingChanged = function () { return !0 }; L.pixelRatioChanged = function () { return !0 }; L._createAs3DShape = function (N, G, I) {
              N = k.geometryAsPolygon(N.geometry); if (q.isNone(N)) return null; M.renderData =
                k.geometryToRenderInfo(N, this._context.elevationProvider, this._context.renderCoordsHelper, G); const O = M.renderData.position.length / 3; M.uvCoords = new Float64Array(2 * O); M.outNum = 0; M.outGeometries = []; M.outTransforms = []; M.outMaterials = []; this._create3DShapeGeometries(M); this._logGeometryCreationWarnings(M.renderData, N.rings, "rings", "WaterSymbol3DLayer"); if (0 === M.outNum) return null; this._createUVCoordsFromVertices(M.uvCoords, M.renderData.mapPosition, O, this._context.elevationProvider.spatialReference); I =
                  new r.Object3D({ geometries: M.outGeometries, materials: M.outMaterials, transformations: M.outTransforms, castShadow: !1, metadata: { layerUid: this._context.layer.uid, graphicUid: I } }); I = new g.Graphics3DObject3DGraphicLayer(this, I, M.outGeometries, null, null, t.perVertexElevationAligner, G); I.alignedSampledElevation = M.renderData.sampledElevation; I.needsElevationUpdates = v.needsElevationUpdates2D(G.mode); return I
            }; L._createUVCoordsFromVertices = function (N, G, I, O) {
              O = u.getMetersPerUnitForSR(O); f.empty(E); for (var R = 0; R <
                I; R++)p.set(H, G[3 * R], G[3 * R + 1]), f.expandPointInPlace(E, H); h.scale(E, E, O); R = E[1] % P.unitSizeOfTexture; D[0] = E[0] - E[0] % P.unitSizeOfTexture; D[1] = E[1] - R; for (R = 0; R < I; R++)N[2 * R] = (G[3 * R] * O - D[0]) / P.unitSizeOfTexture, N[2 * R + 1] = (G[3 * R + 1] * O - D[1]) / P.unitSizeOfTexture
            }; L._create3DShapeGeometries = function (N) {
              var G = N.renderData.polygons; const I = N.uvCoords; for (const { count: O, index: R, position: S, mapPosition: Q, holeIndices: T } of G) {
                if (q.isSome(this._context.clippingExtent) && (d.empty(J), d.expandWithBuffer(J, Q), !d.intersectsClippingArea(J,
                  this._context.clippingExtent))) continue; G = y.earcut(Q, T, 3); if (0 === G.length) continue; G = new Uint32Array(G); const da = new Float64Array(I.buffer, 2 * R * I.BYTES_PER_ELEMENT, 2 * O); G = k.createWaterGeometry({ indices: G, attributeData: { position: S, uv0: da, mapPosition: Q } }); N.outGeometries.push(G); N.outMaterials.push(q.unwrap(this._material)); N.outTransforms.push(n.IDENTITY); N.outNum++
              }
            }; L._createAsOverlay = function (N) {
              const G = k.geometryAsPolygon(N.geometry); if (q.isNone(G)) return null; q.unwrap(this._material).renderPriority =
                this._renderPriority; F.renderData = k.geometryToRenderInfoDraped(G, this._context.overlaySR); const I = F.renderData.position.length / 3; F.uvCoords = new Float64Array(2 * I); F.outNum = 0; F.outGeometries = []; F.outBoundingBox = d.empty(); F.layerUid = this._context.layer.uid; F.graphicsUid = N.uid; this._createAsOverlayWater(F); this._logGeometryCreationWarnings(F.renderData, G.rings, "rings", "WaterSymbol3DLayer"); if (0 === F.outNum) return null; this._createUVCoordsFromVertices(F.uvCoords, F.renderData.position, I, this._context.overlaySR);
              return 0 < F.outNum ? new e(this, F.outGeometries, F.outBoundingBox) : null
            }; L._createAsOverlayWater = function (N) {
              const G = N.uvCoords; var I = N.renderData.polygons; for (const { position: R, holeIndices: S, index: Q, count: T } of I) if (d.empty(J), d.expandWithBuffer(J, R), d.intersectsClippingArea(J, this._context.clippingExtent) && (d.expandWithAABB(N.outBoundingBox, J), I = y.earcut(R, S, 3), 0 !== I.length)) {
                I = new Uint32Array(I); var O = new Float64Array(G.buffer, 2 * Q * G.BYTES_PER_ELEMENT, 2 * T); I = k.createWaterGeometry({
                  indices: I, attributeData: {
                    position: R,
                    uv0: O
                  }
                }); I = new A.RenderGeometry(I, q.unwrap(this._material), N.layerUid, N.graphicsUid); O = J; h.set(I.boundingSphere, .5 * (O[0] + O[3]), .5 * (O[1] + O[4]), 0, .5 * Math.sqrt((O[3] - O[0]) * (O[3] - O[0]) + (O[4] - O[1]) * (O[4] - O[1]))); N.outGeometries.push(I); N.outNum++
              }
            }; P.headingVectorFromAngle = function (N) { const G = l.create(); N = b.toRadian(N); G[0] = Math.sin(N); G[1] = Math.cos(N); return G }; w._createClass(P, [{
              key: "test", get: function () {
                return {
                  create3DShape: N => this._createAs3DShape(N.graphic, N.elevationContext, N.graphicUid), ensureMaterial: () =>
                    this.ensureMaterial()
                }
              }
            }]); return P
          }(x.Graphics3DSymbolLayer); x.unitSizeOfTexture = 100; x.elevationModeChangeTypes = { definedChanged: v.SymbolUpdateType.RECREATE, staysOnTheGround: v.SymbolUpdateType.NONE, onTheGroundChanged: v.SymbolUpdateType.RECREATE }; const D = l.create(), E = f.create(), H = l.create(), J = d.create(), M = { renderData: null, uvCoords: null, outNum: 0, outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null }, F = {
            renderData: null, uvCoords: null, outNum: 0, outBoundingBox: null, outGeometries: null,
            outMaterials: null, outTransforms: null
          }; a.Graphics3DWaterSymbolLayer = x; a.default = x; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DWebStyleSymbol": function () {
      define(["../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "./Loadable", "./symbolComplexity"], function (a, w, c, q) {
        return function (u) {
          function y(p, l, h) { l = u.call(this, l) || this; l.symbol = p; l.convert = h; l.graphics3DSymbol = null; l.referenced = 0; return l } a._inheritsLoose(y, u); var n = y.prototype;
          n.getSymbolLayerSize = function (p) { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.getSymbolLayerSize(p) : null }; n.doLoad = function () { var p = a._asyncToGenerator(function* (l) { l = yield this.symbol.fetchSymbol({ signal: l }); l.id = this.symbol.id; this.graphics3DSymbol = this.convert(l); yield this.graphics3DSymbol.load() }); return function (l) { return p.apply(this, arguments) } }(); n.createGraphics3DGraphic = function (p) {
            return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.createGraphics3DGraphic(p, this) :
              null
          }; n.globalPropertyChanged = function (p, l) { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.globalPropertyChanged(p, l) : !1 }; n.applyRendererDiff = function (p, l) { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.applyRendererDiff(p, l) : 0 }; n.prepareSymbolPatch = function (p) { w.isSome(this.graphics3DSymbol) && this.graphics3DSymbol.prepareSymbolPatch(p) }; n.updateGeometry = function (p, l) { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.updateGeometry(p, l) : !1 }; n.onRemoveGraphic =
            function () { }; n.getFastUpdateStatus = function () { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.getFastUpdateStatus() : { loading: 1, fast: 0, slow: 0 } }; n.destroy = function () { w.isSome(this.graphics3DSymbol) && this.graphics3DSymbol.destroy(); this.graphics3DSymbol = void 0; u.prototype.destroy.call(this) }; a._createClass(y, [{ key: "symbolLayers", get: function () { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.symbolLayers : [] } }, {
              key: "extentPadding", get: function () {
                return w.isSome(this.graphics3DSymbol) ?
                  this.graphics3DSymbol.extentPadding : 0
              }
            }, { key: "complexity", get: function () { return w.isSome(this.graphics3DSymbol) ? this.graphics3DSymbol.complexity : q.emptySymbolComplexity } }, { key: "destroyed", get: function () { return void 0 === this.graphics3DSymbol } }]); return y
        }(c.Loadable)
      })
    }, "esri/views/3d/layers/graphics/labelPlacement": function () {
      define("exports ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../../geometry/support/aaBoundingBox ./graphicSymbolUtils ../../webgl-engine/materials/HUDMaterial".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(C) { C = h.getGraphics3DSymbol(C.graphics3DGraphic.graphics3DSymbol); return q.isSome(C) ? C.symbol.symbolLayers.getItemAt(0) : null } function f(C, D) {
            var E = D.graphics3DGraphic.graphic.geometry; if (q.isNone(E)) return null; if (q.isSome(D.disablePlacement)) return D.labelClass.labelPlacement ? (k.warnOncePerTick(t(C.placement, D.disablePlacement.logEntityDescription)), v(D)) : C; E = E.type; switch (E) {
              case "polyline": case "polygon": case "extent": case "multipoint": if (D.labelClass.labelPlacement) return k.warnOncePerTick(t(C.placement,
                `'${E}' geometries`)), v(D)
            }return C
          } function t(C, D) { return `the requested label placement '${C}' is currently unsupported for ${D} in SceneView` } function v(C) {
            const D = C.graphics3DGraphic.graphic.geometry; if (q.isNone(D)) return null; switch (D.type) {
              case "polyline": case "extent": case "multipoint": return { placement: "center-center", normalizedOffset: null, anchor: "center" }; case "polygon": return C = d(C), q.isSome(C) && "extrude" === C.type ? r["above-center"] : { placement: "center-center", normalizedOffset: null, anchor: "center" };
              case "point": return r["above-center"]; case "mesh": return r["above-center"]
            }
          } function m(C, D = z) { ({ graphics3DGraphic: C } = C); C = C.graphics[0]; (C = q.isSome(C) ? C.stageObject.geometryRecords[0].material : null) && C instanceof b.HUDMaterial ? (C = C.parameters.anchorPos, D[0] = 2 * (C[0] - .5), D[1] = 2 * (C[1] - .5)) : (D[0] = 0, D[1] = 0); return D } function e(C, D, E) {
            E = q.isSome(E) ? E.getBoundingBoxObjectSpace(B) : B; E = n.fromValues(E[3] - E[0], E[4] - E[1], E[5] - E[2]); C.centerOffset[0] = Math.sqrt(E[0] * E[0] + E[1] * E[1]) / 2 * D.normalizedOffset[0]; const H =
              C.translation[2], J = E[2] / 2 * D.normalizedOffset[1]; C.translation[2] = 0; C.elevationOffset = H + J; E = y.length(E); C.centerOffset[2] = E / 2 * D.normalizedOffset[2]
          } function g(C) {
            const D = C.labelClass.labelPlacement, { labelSymbol: E, graphics3DGraphic: H } = C; var J = h.getGraphics3DSymbol(H.graphics3DSymbol); J = q.isSome(J) ? J.symbol : null; C = r[D] || v(C); if ("point-3d" === J.type && J.supportsCallout() && J.hasVisibleVerticalOffset() && !H.isDraped) return {
              placement: null, hasLabelVerticalOffset: !1, verticalOffset: x(J.verticalOffset), anchor: null,
              normalizedOffset: null
            }; if (E && E.hasVisibleVerticalOffset() && ("point-3d" !== J.type || !J.supportsCallout() || !J.verticalOffset || H.isDraped)) {
              a: switch (C.placement) { case "above-center": J = !0; break a; default: J = !1 }return J ? { placement: "above-center", verticalOffset: x(E.verticalOffset), anchor: "bottom", normalizedOffset: [0, C.normalizedOffset[1], 0], hasLabelVerticalOffset: !0 } : (k.errorOncePerTick("Callouts and vertical offset on labels are currently only supported with 'above-center' label placement (not with " + D + " placement)"),
                null)
            } return { placement: null, verticalOffset: null, anchor: null, normalizedOffset: null, hasLabelVerticalOffset: !1 }
          } function x(C) { const { screenLength: D, minWorldLength: E, maxWorldLength: H } = C; return { screenLength: D, minWorldLength: E, maxWorldLength: H } } const k = c.getLogger("esri.views.3d.layers.graphics.labelPlacement"), r = {
            "above-center": { placement: "above-center", normalizedOffset: [0, 1, 0], anchor: "bottom" }, "above-left": { placement: "above-left", normalizedOffset: [-1, 1, 0], anchor: "bottom-right" }, "above-right": {
              placement: "above-right",
              normalizedOffset: [1, 1, 0], anchor: "bottom-left"
            }, "below-center": { placement: "below-center", normalizedOffset: [0, -1, 2], anchor: "top" }, "below-left": { placement: "below-left", normalizedOffset: [-1, -1, 0], anchor: "top-right" }, "below-right": { placement: "below-right", normalizedOffset: [1, -1, 0], anchor: "top-left" }, "center-center": { placement: "center-center", normalizedOffset: [0, 0, 1], anchor: "center" }, "center-left": { placement: "center-left", normalizedOffset: [-1, 0, 0], anchor: "right" }, "center-right": {
              placement: "center-right",
              normalizedOffset: [1, 0, 0], anchor: "left"
            }
          }; w = {
            "above-center": ["default", "esriServerPointLabelPlacementAboveCenter"], "above-left": ["esriServerPointLabelPlacementAboveLeft"], "above-right": ["esriServerPointLabelPlacementAboveRight"], "below-center": ["esriServerPointLabelPlacementBelowCenter"], "below-left": ["esriServerPointLabelPlacementBelowLeft"], "below-right": ["esriServerPointLabelPlacementBelowRight"], "center-center": ["esriServerPointLabelPlacementCenterCenter"], "center-left": ["esriServerPointLabelPlacementCenterLeft"],
            "center-right": ["esriServerPointLabelPlacementCenterRight"]
          }; for (const C in w) { const D = r[C]; w[C].forEach(E => { r[E] = D }) } Object.freeze && (Object.freeze(r), Object.keys(r).forEach(function (C) { Object.freeze(r[C]); Object.freeze(r[C].normalizedOffset) })); const A = [0, 0], z = [0, 0], B = l.create(); a.get = function (C) {
            var D = g(C); if (q.isNone(D)) return null; if (D.anchor) var E = D; else {
              E = C.labelClass.labelPlacement; var H = r[E], J = H || v(C); E && !H && k.warnOncePerTick(`the requested label placement '${E}' is not currently supported in SceneView`);
              E = f(J, C)
            } if (q.isNone(E)) return null; H = !!D.hasLabelVerticalOffset; D = { anchor: E.anchor, verticalOffset: D.verticalOffset, screenOffset: u.create(), centerOffset: p.fromValues(0, 0, 0, -1), centerOffsetUnits: "world", translation: n.create(), elevationOffset: 0, hasLabelVerticalOffset: H }; H = C.graphics3DGraphic.graphic.geometry; if (q.isNone(H)) C = null; else {
              switch (H.type) {
                case "point": J = d(C); if (!q.isNone(J)) switch (H = C.graphics3DGraphic.graphics[0], q.isSome(H) ? H.getCenterObjectSpace(D.translation) : y.set(D.translation, 0, 0,
                  0), J.type) {
                    case "icon": case "text": ({ graphics3DGraphic: J } = C); H = q.isSome(H) ? H.getScreenSize() : null; !J.isDraped && q.isSome(H) ? (C = m(C), A[0] = H[0] / 2 * (E.normalizedOffset[0] - C[0]), A[1] = H[1] / 2 * (E.normalizedOffset[1] - C[1]), D.screenOffset[0] = A[0], D.hasLabelVerticalOffset ? (D.centerOffset[1] = A[1], D.centerOffsetUnits = "screen") : D.screenOffset[1] = A[1]) : D.hasLabelVerticalOffset || "center" === D.anchor || (r[C.labelClass.labelPlacement] && k.warnOncePerTick(`the requested placement '${E.placement}' is currently unsupported for draped graphics`),
                      D.anchor = "center"); break; case "object": e(D, E, H)
                  }break; case "polygon": H = d(C); if (!q.isNone(H)) switch (H.type) { case "extrude": C = C.graphics3DGraphic.graphics[0], q.isSome(C) ? (C.getBoundingBoxObjectSpace(B), l.center(B, D.translation), D.translation[2] = l.height(B) / 2) : y.set(D.translation, 0, 0, 0), e(D, E, C) }break; case "mesh": e(D, E, C.graphics3DGraphic.graphics[0])
              }C = D
            } return C
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/MaterialCollection": function () {
      define(["exports"], function (a) {
        let w =
          function () { function c(u) { this._stage = u; this._materials = new Map } var q = c.prototype; q.get = function (u) { return this._materials.get(u) }; q.add = function (u, y) { this._materials.set(u, y); this._stage.add(y) }; q.dispose = function () { this._stage.removeMany(Array.from(this._materials.values())); this._materials.clear() }; return c }(); a.MaterialCollection = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/TextTextureAtlas": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/MapUtils ../../../../core/mathUtils ../../../../core/maybe ../../../../core/uid ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../support/Scheduler ../../../webgl/Texture".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          var e; a.TextTextureAtlas = e = function (g) {
            function x(r) { r = g.call(this, r) || this; r.type = 4; r.id = l.generateUID(); r.events = new u; r._glTexture = null; r.needsClear = !1; r.elementsToAddOrUpdate = new Map; r.elementsToRemove = new Map; r.elementsToRender = new Map; r.elements = new Map; r.stageObjects = new Map; r.updating = !1; return r } w._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () {
            this.stage = this.view._stage; this.canvas = this.create2DCanvas(); this.ctx = this.canvas.getContext("2d");
              this.stage.add(this); const r = this.computeAtlasResolution(this.view.width, this.view.height); this.createAtlasRegion(r); this.update2DCanvasSize(); this.resetAtlasCursor()
            }; k.unload = function () { this._glTexture = p.disposeMaybe(this._glTexture); this.updating = !1; this.events.emit("unloaded") }; k.createDescriptor = function (r) { return { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, flipped: !0, samplingMode: 9987, hasMipmap: !0, preMultiplyAlpha: !0, maxAnisotropy: r.parameters.maxMaxAnisotropy } }; k.load = function (r) {
              if (p.isSome(this._glTexture)) return this._glTexture;
              this._glTexture = new m(r, this.createDescriptor(r), this.canvas); this.frameWorker = this.view.resourceController.scheduler.registerTask(v.TaskPriority.TEXT_TEXTURE_ATLAS, this); this.setDirty(); return this._glTexture
            }; k.dispose = function () {
            this.elementsToRender = this.elementsToRemove = this.elementsToAddOrUpdate = this.elements = null; this.frameWorker = p.removeMaybe(this.frameWorker); this._glTexture && (this.stage.remove(this), this._glTexture = p.disposeMaybe(this._glTexture)); this.canvas.width = 0; this.canvas.height =
              0; this.ctx = this.canvas = null
            }; k.create2DCanvas = function () { const r = document.createElement("canvas"); r.setAttribute("id", "canvas2d"); r.setAttribute("style", "display:none"); r.setAttribute("width", (512).toString()); r.setAttribute("height", (512).toString()); return r }; k.update2DCanvasSize = function () { this.canvas.setAttribute("width", this.atlas.size.width.toString()); this.canvas.setAttribute("height", this.atlas.size.height.toString()) }; k.createAtlasRegion = function (r = 512) {
            this.atlas = {
              size: { width: r, height: r },
              cursor: { x: 0, y: 0 }, lineHeight: 0
            }
            }; k.computeAtlasResolution = function (r, A) { r = Math.max(r, A); r = n.nextHighestPowerOfTwo(r + 256); return r = Math.min(r, 4096) }; k.resizeAtlas = function (r, A) { A = A || r; const z = this.atlas; z.size.width = r; z.size.height = A; p.isSome(this._glTexture) && this._glTexture.resize(r, A); this.update2DCanvasSize() }; k.resetAtlasCursor = function () { const r = this.atlas; r.cursor.x = 2; r.cursor.y = 4; r.lineHeight = 0; this.needsClear = !0 }; k.getAtlasUsage = function () {
              const r = this.atlas; return (r.cursor.x + r.cursor.y * r.size.width) /
                (r.size.width * r.size.height)
            }; k.getExpectedAtlasUsage = function () { const r = this.elementsToRemove.size, A = this.elementsToAddOrUpdate.size, z = this.elements.size; return this.getAtlasUsage() / z * (z + A - r) }; k.addAtlasElement = function (r, A, z, B) {
              const C = this.atlas, { renderedWidth: D, renderedHeight: E, displayWidth: H, displayHeight: J } = r.textRenderer; r.placement.offset.x = C.cursor.x; r.placement.offset.y = C.cursor.y; r.placement.size.width = D; r.placement.size.height = E; r.placement.size.displayWidth = H; r.placement.size.displayHeight =
                J; r.placement.uvMinMax = [r.placement.offset.x / C.size.width, 1 - (r.placement.offset.y + E) / C.size.height, (r.placement.offset.x + D) / C.size.width, 1 - r.placement.offset.y / C.size.height]; C.cursor.x += z; C.lineHeight = Math.max(C.lineHeight, B); this.elements.set(A, r)
            }; k.removeAtlasElement = function (r) { if (r && this.elements.has(r.textId)) { const A = r.placement.offset, z = r.placement.size; this.ctx.clearRect(A.x, A.y, z.width, z.height); this.elements.delete(r.textId) } }; k.ensureStageObjects = function (r) {
              var A = this.stageObjects.get(r);
              if (A) return A; A = new Set; this.stageObjects.set(r, A); return A
            }; k.addStageObject = function (r, A) { this.ensureStageObjects(r).add(A) }; k.removeStageObject = function (r, A) { (r = this.stageObjects.get(r)) && r.delete(A) && (A.geometries[0].vertexAttributes.get("size").data = [0, 0], A.geometryVertexAttrsUpdated(A.geometryRecords[0])) }; k._processAddition = function (r, A) {
              const z = this.atlas; var B = r.textId; const C = r.textRenderer.renderedWidth + 2, D = r.textRenderer.renderedHeight + 2 + 2; if (z.cursor.x + C < z.size.width && z.cursor.y + D < z.size.height) this.addAtlasElement(r,
                B, C, D), this.elementsToRender.set(B, r), this.elementsToAddOrUpdate.delete(B); else if (z.cursor.y + D + z.lineHeight < z.size.height) z.cursor.x = 2, z.cursor.y += z.lineHeight, z.lineHeight = 0, this.addAtlasElement(r, B, C, D), this.elementsToRender.set(B, r), this.elementsToAddOrUpdate.delete(B); else { r = this.getExpectedAtlasUsage(); (B = .85 < r && 4096 > z.size.width) && this.resizeAtlas(2 * z.size.width, 2 * z.size.height); if (!A || !B && .95 < r && 4096 === z.size.width) return this.processRemovals(), 0; this.repack(); return 1 } return 0
            }; k.processRemovals =
              function () { this.elementsToRemove.forEach((r, A) => { const z = this.stageObjects.get(A); z && 0 !== z.size || this.removeAtlasElement(r); z && 0 === z.size && this.stageObjects.delete(A) }); this.elementsToRemove.clear() }; k.repack = function () { this.processRemovals(); this.elements.forEach((r, A) => { r.rendered = !1; this.elementsToAddOrUpdate.set(A, r) }); this.elements.clear(); this.resetAtlasCursor(); this.elementsToRender.clear() }; k.processRenderingRequest = function (r) {
                this.ctx.clearRect(r.placement.offset.x, r.placement.offset.y,
                  r.placement.size.width, r.placement.size.height); r.textRenderer.render(this.ctx, r.placement.offset.x, r.placement.offset.y); const A = this.stageObjects.get(r.textId); A && A.forEach(z => { z.geometries[0].vertexAttributes.get("uv0").data = new Float32Array(r.placement.uvMinMax); z.geometries[0].vertexAttributes.get("size").data = [r.placement.size.displayWidth, r.placement.size.displayHeight]; z.geometryVertexAttrsUpdated(z.geometryRecords[0]) }); r.rendered = !0
              }; k.runTask = function (r, A = !0) {
                if (this._glTexture) {
                  var z =
                    !1; y.someMap(this.elementsToAddOrUpdate, (C, D) => (C = this.elements.get(D)) && C.rendered ? ((C = this.stageObjects.get(D)) && C.forEach(E => { const H = E.geometries[0].vertexAttributes, J = this.elements.get(D); H.get("uv0").data = new Float32Array(J.placement.uvMinMax); H.get("size").data = new Float32Array([J.placement.size.displayWidth, J.placement.size.displayHeight]); E.geometryVertexAttrsUpdated(E.geometryRecords[0]) }), this.elementsToAddOrUpdate.delete(D), !1) : 1 === this._processAddition(this.elementsToAddOrUpdate.get(D),
                      A) ? z = !0 : !1); if (z) this.runTask(v.noBudget, !1); else { var B = !1; 0 < this.elementsToRender.size && this.needsClear && (this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.needsClear = !1); y.someMap(this.elementsToRender, (C, D) => { this.processRenderingRequest(C); this.elementsToRender.delete(D); B = !0; r.madeProgress(); return r.done }); B && p.isSome(this._glTexture) && this._glTexture.setData(this.canvas); this.updating = 0 < this.elementsToRender.size; !this.updating && e.test.orderedRepackingEnabled && this.repackOrdered() }
                }
              };
            k.addTextTexture = function (r, A) { const z = r.key; this.elementsToAddOrUpdate.has(z) || this.elementsToAddOrUpdate.set(z, { textId: z, placement: { offset: { x: 0, y: 0 }, size: { width: 0, height: 0, displayWidth: 0, displayHeight: 0 }, uvMinMax: [] }, textRenderer: r, rendered: !1 }); this.addStageObject(z, A); this.elementsToRemove.delete(z); this.setDirty() }; k.removeTextTexture = function (r, A) { r = r.key; this.elementsToRemove.set(r, this.elements.get(r)); this.removeStageObject(r, A) }; k.setDirty = function () { this._glTexture && (this.updating = !0) };
            k.repackOrdered = function () { if (0 !== this.elements.size) { var r = []; this.elements.forEach((z, B) => r.push({ element: z, key: B })); var A = !0; for (let z = 0; z < r.length - 1; z++)if (0 < r[z].key.localeCompare(r[z + 1].key)) { A = !1; break } if (!A || this.elementsToRemove.size) { r.sort((z, B) => z.key.localeCompare(B.key)); this.elements.clear(); for (const { element: z, key: B } of r) this.elements.set(B, z); this.repack(); this.setDirty() } } }; w._createClass(x, [{ key: "width", get: function () { return this.atlas.size.width } }, { key: "height", get: function () { return this.atlas.size.height } },
            { key: "requiresFrameUpdates", get: function () { return !1 } }, { key: "glTexture", get: function () { return this._glTexture } }, { key: "running", get: function () { return this.updating } }, { key: "test", get: function () { const { elements: r, stageObjects: A, elementsToRemove: z, atlas: B } = this, C = this; return { elements: r, stageObjects: A, elementsToRemove: z, atlas: B, resizeAtlas: (D, E) => C.resizeAtlas(D, E), run: (D, E) => C.runTask(D, E) } } }]); return x
          }(q); a.TextTextureAtlas.test = { orderedRepackingEnabled: !1 }; c.__decorate([h.property({ constructOnly: !0 })],
            a.TextTextureAtlas.prototype, "view", void 0); c.__decorate([h.property({ type: Boolean })], a.TextTextureAtlas.prototype, "updating", void 0); a.TextTextureAtlas = e = c.__decorate([t.subclass("esri.views.3d.webgl-engine.lib.TextTextureAtlas")], a.TextTextureAtlas); a.default = a.TextTextureAtlas; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/ObjectResourceCache": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Handles ../../../../core/handleUtils ../../../../core/maybe ../../../../core/promiseUtils ../../glTF/DefaultLoadingContext ../../glTF/loader ./wosrLoader".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          let h = function () {
            function d() { this.gltfCache = new Map; this.wosrCache = new Map; this.evictHandles = new c } var f = d.prototype; f.loadGLTF = function (t, v, m) { return this.fromCache(this.gltfCache, m ? `gltfPBR:${t}` : `gltf:${t}`, e => p.load(new n.DefaultLoadingContext(e.streamDataRequester), t, e, m), v) }; f.loadWOSR = function (t, v) { return this.fromCache(this.wosrCache, `wosr:${t}:${v.disableTextures}`, m => l.load(t, m), v) }; f.destroy = function () { this.evictHandles.destroy(); this.gltfCache.clear(); this.wosrCache.clear() };
            f.fromCache = function (t, v, m, e) { return new Promise((g, x) => { if (y.isAborted(e)) x(y.createAbortError()); else { var k = y.onAbort(e, () => { this.remove(t, v); x(y.createAbortError()) }), r = t.get(v); if (r) this.evictHandles.remove(v), r.refCount++ , r.item.then(g, x); else { r = new AbortController; var A = { refCount: 1, abortController: r, item: m({ ...e, signal: r.signal }).then(z => { A.abortController = null; z.remove = () => this.remove(t, v); return z }) }; t.set(v, A); A.item.then(z => { u.isSome(k) && k.remove(); g(z) }, z => { u.isSome(k) && k.remove(); x(z) }) } } }) };
            f.remove = function (t, v) { const m = t.get(v); m && (m.refCount-- , 0 === m.refCount && this.evictHandles.add(q.timeoutHandle(() => { t.delete(v); u.isSome(m.abortController) && m.abortController.abort() }, b), v)) }; w._createClass(d, [{ key: "size", get: function () { return this.wosrCache.size + this.gltfCache.size } }]); return d
          }(), b = 1E4; a.ObjectResourceCache = h; a.test = { overrideEvictDelay(d) { b = d; return { remove() { b = 1E4 } } } }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/FeatureTileTree3D": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Collection ../../../../core/Handles ../../../../core/Logger ../../../../core/maybe ../../../../core/PooledArray ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/support/aaBoundingRect ./FeatureTileDescriptor3D ./FeatureTileMeasurements3D ../../support/extentUtils ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k) {
          const r = n.getLogger("esri.views.3d.layers.support.FeatureTileTree3D"); a.FeatureTileTree3D = function (B) {
            function C(E) { E = B.call(this, E) || this; E.tiles = new u; E.tileSize = 512; E._idToTile = new Map; E._handles = new y; E._clients = new Set; E._dirty = !1; E._newTiles = new l; return E } w._inheritsLoose(C, B); var D = C.prototype; D.initialize = function () {
              this._handles.add(this.watch(["tilingScheme", "tileSize"], () => this._reset(), !0)); this._handles.add(h.init(this, ["tileSize", "cameraOnSurface.location",
                "tilingScheme", "viewState.contentCamera", "focus.location"], () => this._setDirty(), !0)); this.scheduler && (this._frameWorker = this.scheduler.registerTask(k.TaskPriority.FEATURE_TILE_TREE, this))
            }; D.destroy = function () { this._frameWorker = p.removeMaybe(this._frameWorker); this._handles = p.destroyMaybe(this._handles) }; D.addClient = function () { const E = A++; this._clients.add(E); 1 === this._clients.size && this._setDirty(); return { remove: () => this._removeClient(E) } }; D._removeClient = function (E) {
              this._clients.delete(E); this._hasClients ||
                this._clear()
            }; D._setDirty = function () { !this._hasClients || this.suspended || this._dirty || (this._frameWorker ? (this._dirty = !0, this.notifyChange("updating")) : this.runTask(k.noBudget)) }; D._clear = function () { this.tiles.removeAll(); this._idToTile.clear(); this._reset(); this._dirty = !1; this.notifyChange("updating") }; D.runTask = function (E) {
            this._dirty = !1; this._pendingTiles || (this._startUpdate(), p.isSome(this._frameWorker) && (this._frameWorker.priority = k.TaskPriority.FEATURE_TILE_TREE_ACTIVE)); this._subdivideTilesForView(E);
              !this._pendingTiles && p.isSome(this._frameWorker) && (this._frameWorker.priority = k.TaskPriority.FEATURE_TILE_TREE); this.notifyChange("updating")
            }; D._startUpdate = function () {
            this.suspended || (this.tilingScheme ? (this._tileMeasurements || (this._tileMeasurements = new g.FeatureTileMeasurements3D({ renderCoordsHelper: this.renderCoordsHelper, tilingScheme: this.tilingScheme, tileSize: this.tileSize })), this._tileMeasurements.begin(this.viewState.contentCamera, this.focus.location, this.cameraOnSurface.location.z), this._pendingTiles =
              this._getRootTiles()) : this._clear())
            }; D._reset = function () { this._newTiles.clear(); this._pendingTiles = this._tileMeasurements = null; this._setDirty() }; D._getRootTiles = function () { return this.rootTileIds.map(E => new e.FeatureTileDescriptor3D(E[0], E[1], E[2], this.tilingScheme)) }; D._purgeHorizonTiles = function (E) {
              E.sort((H, J) => { H = H.measures.screenRect; J = J.measures.screenRect; return H[1] + H[3] - (J[1] + J[3]) }); m.empty(z); for (let H = 0; H < E.length; H++)if (m.expand(z, E.data[H].measures.screenRect, z), 10 < m.height(z)) return E.data.slice(H,
                E.length); return []
            }; D._subdivideTilesForView = function (E) {
              if (this._pendingTiles) {
                for (; 0 < this._pendingTiles.length && !E.done;) { const H = this._pendingTiles.pop(); E.madeProgress(); if (!this.filterExtentRect || m.intersects(this.filterExtentRect, H.extent)) this._tileMeasurements.updateTile(H), 0 !== H.measures.visibility && (H.measures.shouldSplit ? (this.tilingScheme.ensureMaxLod(H.lij[0] + 1), this._pendingTiles.push(...H.getChildren())) : this._newTiles.push(H)) } 0 === this._pendingTiles.length && (this._updateTiles(this._purgeHorizonTiles(this._newTiles)),
                  this._newTiles.clear(), this._tileMeasurements.end(), this._pendingTiles = null)
              }
            }; D._updateTiles = function (E) { for (var H of this.tiles.items) H.used = !1; E = E.filter(J => { const M = this._idToTile.get(J.id); M ? (M.copyMeasurementsFrom(J), M.used = !0) : this._idToTile.set(J.id, J); return !M }); H = this.tiles.items.filter(J => J.used ? !1 : (this._idToTile.delete(J.id), !0)); this.tiles.removeMany(H); this.tiles.addMany(E); this.sortTiles() }; D.sortTiles = function () {
              this.viewState.fixedContentCamera || this.tiles.sort((E, H) => E.measures.visibility !==
                H.measures.visibility ? 2 === E.measures.visibility ? -1 : 1 : E.measures.distance - H.measures.distance); this.tiles.forEach((E, H) => E.loadPriority = H)
            }; w._createClass(C, [{ key: "tilingScheme", get: function () { const E = this.tilingSchemeOwner.tilingScheme; return E ? E.clone() : null } }, {
              key: "filterExtent", set: function (E) {
                if (p.isSome(E) && !E.spatialReference.equals(this.viewState.spatialReference)) r.error("#extent", "extent spatial reference needs to be in the same spatial reference as the view"); else {
                  var H = this._get("filterExtent");
                  H === E || p.isSome(H) && E && H.equals(E) || (E = p.isSome(E) ? E.clone() : null, this._set("filterExtent", E), this._setDirty())
                }
              }
            }, { key: "filterExtentRect", get: function () { if (p.isNone(this.filterExtent) || !this.tilingScheme) return null; const E = m.create(); x.toBoundingRect(this.filterExtent, E, this.tilingScheme.spatialReference); return E } }, { key: "rootTileIds", get: function () { return this.filterExtentRect ? this.tilingScheme.rootTilesInExtent(this.filterExtentRect) : [[0, 0, 0]] } }, {
              key: "suspended", set: function (E) {
              E !== this._get("suspended") &&
                (this._set("suspended", E), this._setDirty())
              }
            }, { key: "updating", get: function () { return this._dirty || !!this._pendingTiles } }, { key: "_hasClients", get: function () { return 0 < this._clients.size } }, { key: "running", get: function () { return this.updating } }]); return C
          }(q); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype, "scheduler", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype, "renderCoordsHelper", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype,
            "tilingSchemeOwner", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype, "cameraOnSurface", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype, "focus", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype, "viewState", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.FeatureTileTree3D.prototype, "terrain", void 0); c.__decorate([b.property()], a.FeatureTileTree3D.prototype, "tiles", void 0); c.__decorate([b.property()],
              a.FeatureTileTree3D.prototype, "tileSize", void 0); c.__decorate([b.property({ readOnly: !0 })], a.FeatureTileTree3D.prototype, "tilingScheme", null); c.__decorate([b.property()], a.FeatureTileTree3D.prototype, "filterExtent", null); c.__decorate([b.property({ readOnly: !0 })], a.FeatureTileTree3D.prototype, "filterExtentRect", null); c.__decorate([b.property({ readOnly: !0 })], a.FeatureTileTree3D.prototype, "rootTileIds", null); c.__decorate([b.property({ value: !1 })], a.FeatureTileTree3D.prototype, "suspended", null); c.__decorate([b.property({ readOnly: !0 })],
                a.FeatureTileTree3D.prototype, "updating", null); a.FeatureTileTree3D = c.__decorate([v.subclass("esri.views.3d.layers.support.FeatureTileTree3D")], a.FeatureTileTree3D); let A = 0; const z = m.create(); a.default = a.FeatureTileTree3D; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/FeatureTileDescriptor3D": function () {
      define(["exports", "../../../../geometry/support/aaBoundingRect"], function (a, w) {
        let c = function () {
          function q(y, n, p, l = null) {
          this.lij = [0, 0, 0]; this.extent = w.create(); this.loadPriority =
            this.resolution = 0; this.measures = { visibility: 2, screenRect: w.create(), distance: 0, shouldSplit: !1 }; this.used = !1; l && this.acquire(y, n, p, l)
          } var u = q.prototype; u.acquire = function (y, n, p, l) { this.tilingScheme = l; this.id = q.id(y, n, p); this.lij[0] = y; this.lij[1] = n; this.lij[2] = p; l.getExtent(y, n, p, this.extent); this.resolution = l.resolutionAtLevel(y) }; u.release = function () { this.tilingScheme = null }; u.getChildren = function (y) {
            const n = this.lij[0] + 1, p = 2 * this.lij[1], l = 2 * this.lij[2]; if (!y) return [new q(n, p, l, this.tilingScheme),
            new q(n, p + 1, l, this.tilingScheme), new q(n, p, l + 1, this.tilingScheme), new q(n, p + 1, l + 1, this.tilingScheme)]; y[0].acquire(n, p, l, this.tilingScheme); y[1].acquire(n, p + 1, l, this.tilingScheme); y[2].acquire(n, p, l + 1, this.tilingScheme); y[3].acquire(n, p + 1, l + 1, this.tilingScheme); return y
          }; u.copyMeasurementsFrom = function (y) { this.measures.visibility = y.measures.visibility; this.measures.shouldSplit = y.measures.shouldSplit; this.measures.distance = y.measures.distance; w.copy(y.measures.screenRect, this.measures.screenRect) };
          q.id = function (y, n, p) { return `${y}/${n}/${p}` }; return q
        }(); a.FeatureTileDescriptor3D = c; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/FeatureTileMeasurements3D": function () {
      define("exports ../../../../core/screenUtils ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/plane ../../../../geometry/support/triangle ./FeatureTileVisibility3D ../../webgl-engine/lib/Camera".split(" "), function (a,
        w, c, q, u, y, n, p, l) {
          let h = function () {
            function g(k) { this.camera = new l; this.focusOnMap = [0, 0]; this.screenRect = u.create(); this.tileSize = k.tileSize; this.renderCoordsHelper = k.renderCoordsHelper; this.tilingScheme = k.tilingScheme; this.visibility = new p.FeatureTileVisibility3D(k.renderCoordsHelper) } var x = g.prototype; x.begin = function (k, r, A) {
              this.camera.copyFrom(k); this.surfaceElevation = A; this.focusOnMap[0] = r.x; this.focusOnMap[1] = r.y; u.fromValues(0, 0, k.fullWidth, k.fullHeight, this.screenRect); this.visibility.begin(this.camera,
                A)
            }; x.end = function () { this.visibility.end() }; x.updateTile = function (k) { k.measures.visibility = this.visibility.calculate(k); k.measures.distance = u.distance(k.extent, this.focusOnMap); 0 !== k.measures.visibility && this.updateScreenMeasure(k) }; x.updateScreenMeasure = function (k) {
              const r = k.measures.screenRect; u.empty(r); let A = 0; const z = k.lij[0] + 2, B = k.lij[1] << 2, C = k.lij[2] << 2; var D = this.tileSizeWithBias(k); D *= D; for (let E = 0; 4 > E; E++)for (let H = 0; 4 > H; H++)if (A += this.computeScreenArea(k, z, B + E, C + H, r), A > D) {
                k.measures.shouldSplit =
                !0; return
              } k.measures.shouldSplit = !1
            }; x.tileSizeWithBias = function (k) { return 1 === k.measures.visibility ? 5 * this.tileSize : this.tileSize }; x.computeScreenArea = function (k, r, A, z, B) { this.projectToScreen(r, A, z, 1 === k.measures.visibility, d); u.empty(b); for (k = 0; 4 > k; k++)u.expandPointInPlace(b, d[k]); u.expand(B, b, B); return n.areaPoints2d(d[0], d[1], d[2]) + n.areaPoints2d(d[0], d[2], d[3]) }; x.projectToScreen = function (k, r, A, z, B) {
              this.tilingScheme.ensureMaxLod(k); this.tilingScheme.getExtent(k, r, A, f); this.toRenderCoords(f,
                0, 3, v[0]); this.toRenderCoords(f, 2, 3, v[1]); this.toRenderCoords(f, 2, 1, v[2]); this.toRenderCoords(f, 0, 1, v[3]); z && (this.projectToPlane(v, this.camera.frustum[4]), this.projectToPlane(v, this.camera.frustum[3]), this.projectToPlane(v, this.camera.frustum[2])); for (k = 0; 4 > k; k++)this.camera.projectToRenderScreen(v[k], e), this.camera.renderToScreen(e, B[k])
            }; x.projectToPlane = function (k, r) {
              for (var A = 0; 4 > A; A++)m[A] = y.signedDistance(r, k[A]); A = Math.max(m[0], m[1], m[2], m[3]); if (0 < A) for (r = c.scale(t, y.normal(r), -A), A = 0; 4 >
                A; A++)c.add(k[A], k[A], r)
            }; x.toRenderCoords = function (k, r, A, z) { t[0] = k[r]; t[1] = k[A]; t[2] = this.surfaceElevation; this.renderCoordsHelper.toRenderCoords(t, this.tilingScheme.spatialReference, z); return z }; return g
          }(); const b = u.create(), d = [w.createScreenPointArray(), w.createScreenPointArray(), w.createScreenPointArray(), w.createScreenPointArray()], f = u.create(), t = q.create(), v = [q.create(), q.create(), q.create(), q.create()], m = [0, 0, 0, 0], e = w.createRenderScreenPointArray3(); a.FeatureTileMeasurements3D = h; a.default =
            h; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/FeatureTileVisibility3D": function () {
      define("exports ../../../../core/mathUtils ../../../../core/ObjectPool ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projectionEllipsoid ../../../../geometry/support/plane ../../../../geometry/support/ray ./FeatureTileDescriptor3D ../../state/Frustum ../../support/FrustumExtentIntersection".split(" "), function (a, w, c, q, u, y, n, p, l, h, b) {
        let d = function () {
          function e(x) {
          this.renderCoordsHelper =
            x; this.surfaceElevation = 0; this.cache = new Map; this.frustum = new h.Frustum(x); this.extendedFrustum = new h.Frustum(x); this.intersector = new b.FrustumExtentIntersection({ renderCoordsHelper: x }); this.renderCoordsHelper = x
          } var g = e.prototype; g.begin = function (x, k) { this.surfaceElevation = k; this.aboveGround = this.renderCoordsHelper.getAltitude(x.eye) > k; this.frustum.update(x); this.shortenFrustumFarPlane(this.frustum); this.updateExtendedFrustum(x) }; g.end = function () { this.cache.clear() }; g.calculate = function (x) {
            if (this.allTilesInvisible) return 0;
            const k = 1 === this.renderCoordsHelper.viewingMode && 2 <= x.lij[0] && 6 > x.lij[0], r = this.getOrCalculateSingleTileVisibility(x, !k); return 0 !== r && k ? this.calculateAggregatedChildrenVisibility(x) : r
          }; g.shortenFrustumFarPlane = function (x) { var k = h.Frustum.nearFarLineIndices; const r = x.mutablePoints; for (const A of k) { const [z, B] = A; k = r[z]; q.subtract(f, r[B], k); q.scale(f, f, .95); q.add(r[B], k, f) } x.updatePoints(r) }; g.calculateAggregatedChildrenVisibility = function (x) {
            let k = 0; var r = this.cache.get(x.id); if (null != r) return r;
            r = m.acquire(); x.getChildren(r); for (const A of r) { const z = this.calculate(A); if (0 !== z && (k = z, 2 === z)) break } m.release(r); this.cache.set(x.id, k); return k
          }; g.getOrCalculateSingleTileVisibility = function (x, k) { var r = this.cache.get(x.id); if (null != r) return r; r = this.calculateSingleTileVisibility(x); k && this.cache.set(x.id, r); return r }; g.calculateSingleTileVisibility = function (x) {
            if (!this.aboveGround && 1 === this.renderCoordsHelper.viewingMode && 12 > x.lij[0]) {
              if (0 === this.calculateSingleTileVisibilitySided(x, !1)) return this.calculateSingleTileVisibilitySided(x,
                !0)
            } else return this.calculateSingleTileVisibilitySided(x, this.aboveGround)
          }; g.calculateSingleTileVisibilitySided = function (x, k) { this.intersector.update(x.extent, x.tilingScheme.spatialReference, this.surfaceElevation, k); x = y.getReferenceEllipsoid(x.tilingScheme.spatialReference).radius; return this.intersector.isVisibleInFrustum(this.extendedFrustum, x) ? this.intersector.isVisibleInFrustum(this.frustum, x, !0) ? 2 : 1 : 0 }; g.updateExtendedFrustum = function (x) {
            this.extendedFrustum.update(x); this.shortenFrustumFarPlane(this.extendedFrustum);
            var k = this.renderCoordsHelper.worldUpAtPosition(x.eye, f); this.aboveGround || q.negate(k, k); k = w.acosClamped(-q.dot(k, x.viewForward)); this.allTilesInvisible = k > (Math.PI + x.fovY) / 2; if (!this.allTilesInvisible && (this.hasExtendedFrustum = k > x.fovY / 2)) {
              x = this.extendedFrustumParameters(); k = this.extendedFrustum.mutablePoints; for (let r = 0; 4 > r; r++) {
                const A = x.pointIndices[r], z = k[A], B = this.renderCoordsHelper.getAltitude(z); if (x.needsAltitudeAdjustment(B)) {
                  this.renderCoordsHelper.worldUpAtPosition(z, f); switch (A) {
                    case 4: case 7: case 0: case 3: n.projectVector(this.extendedFrustum.planes[0],
                      f, f); break; case 5: case 6: case 1: case 2: n.projectVector(this.extendedFrustum.planes[1], f, f)
                  }q.scale(f, f, x.direction); this.renderCoordsHelper.intersectInfiniteManifold(p.wrap(z, f), x.zWithMargin, z)
                }
              } this.extendedFrustum.updatePoints(k); n.fromPoints(k[0], k[1], k[2], t); n.fromPoints(k[1], k[2], k[3], v); 0 > q.dot(n.normal(t), n.normal(v)) && (x = this.extendedFrustum.mutablePoints, this.aboveGround ? [x[0], x[1]] = [x[1], x[0]] : [x[3], x[2]] = [x[2], x[3]], this.extendedFrustum.updatePoints(x))
            }
          }; g.extendedFrustumParameters = function () {
            return this.aboveGround ?
              this.extendedFrustumParametersAboveSurface() : this.extendedFrustumParametersBelowSurface()
          }; g.extendedFrustumParametersAboveSurface = function () { const x = this.surfaceElevation - 1; return { zWithMargin: x, pointIndices: h.Frustum.planePointIndices.bottom, direction: -1, needsAltitudeAdjustment(k) { return k > x } } }; g.extendedFrustumParametersBelowSurface = function () { const x = this.surfaceElevation + 1; return { zWithMargin: x, pointIndices: h.Frustum.planePointIndices.top, direction: 1, needsAltitudeAdjustment(k) { return k < x } } }; return e
        }();
        const f = u.create(), t = n.create(), v = n.create(), m = new c(Array, e => { 4 !== e.length && (e[0] = new l.FeatureTileDescriptor3D, e[1] = new l.FeatureTileDescriptor3D, e[2] = new l.FeatureTileDescriptor3D, e[3] = new l.FeatureTileDescriptor3D) }, e => { e[0].release(); e[1].release(); e[2].release(); e[3].release() }); a.FeatureTileVisibility3D = d; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/Frustum": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../chunks/vec3", "../../../chunks/vec3f64",
        "../../../geometry/support/frustum"], function (a, w, c, q, u) {
          function y(p, l, h) { p.origin = l; p.endpoint = h; c.direction(p.direction, l, h) } let n = function () {
            function p(h) { this.renderCoordsHelper = h; this.frustum = u.create(); this._points = u.createPoints(); this.lines = Array(12); this._origin = q.create(); this._direction = q.create(); this._altitude = null; for (h = 0; 12 > h; h++)this.lines[h] = { origin: null, direction: q.create(), endpoint: null } } var l = p.prototype; l.update = function (h) {
              u.fromMatrix(h.viewMatrix, h.projectionMatrix, this.frustum,
                this._points); c.copy(this._origin, h.eye); c.copy(this._direction, h.viewForward); this._altitude = this.renderCoordsHelper.getAltitude(this._origin); this.updateLines()
            }; l.updatePoints = function (h) { for (let b = 0; b < this._points.length; b++)c.copy(this._points[b], h[b]); u.computePlanes(this.frustum, this._points); this.updateLines() }; l.intersectsSphere = function (h) { return u.intersectsSphere(this.frustum, h) }; l.intersectsRay = function (h) { return u.intersectsRay(this.frustum, h) }; l.intersectsLineSegment = function (h, b) {
              return u.intersectsLineSegment(this.frustum,
                h, b)
            }; l.intersectsPoint = function (h) { return u.intersectsPoint(this.frustum, h) }; l.updateLines = function () { const h = this._points; for (let b = 0; 4 > b; b++) { const d = b + 4; y(this.lines[b], h[b], h[d]); y(this.lines[b + 4], h[b], 3 === b ? h[0] : h[b + 1]); y(this.lines[b + 8], h[d], 3 === b ? h[4] : h[d + 1]) } }; w._createClass(p, [{ key: "planes", get: function () { return this.frustum } }, { key: "points", get: function () { return this._points } }, { key: "mutablePoints", get: function () { return this._points } }, { key: "direction", get: function () { return this._direction } },
            { key: "altitude", get: function () { return this._altitude } }]); return p
          }(); n.planePointIndices = u.planePointIndices; n.nearFarLineIndices = [[0, 4], [1, 5], [2, 6], [3, 7]]; a.Frustum = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/FrustumExtentIntersection": function () {
      define("exports ../../../core/compilerUtils ../../../core/mathUtils ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/projectionEllipsoid ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ../../../geometry/support/lineSegment ../../../geometry/support/plane ../../../geometry/support/ray ./intersectionUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          const m = .5 * Math.PI, e = m / Math.PI * 180; let g = function () {
            function D(H) { this.renderCoordsHelper = H.renderCoordsHelper; this.extent = Array(4); this.planes = Array(6); this.maxSpan = 0; this.center = { origin: n.create(), direction: n.create() }; for (H = 0; 4 > H; H++)this.extent[H] = { origin: n.create(), direction: n.create(), cap: { next: null, direction: n.create() } }, this.planes[H] = f.create(); this.planes[4] = f.create(); this.planes[5] = f.create(); this.planesWithoutFar = this.planes.slice(0, 5) } var E = D.prototype;
            E.update = function (H, J, M, F = !0) {
              const K = this.extent; this.toRenderBoundingExtent(H, J, M); y.add(this.center.origin, K[0].origin, K[2].origin); y.scale(this.center.origin, this.center.origin, .5); this.renderCoordsHelper.worldUpAtPosition(this.center.origin, this.center.direction); F || y.scale(this.center.direction, this.center.direction, -1); for (M = 0; 4 > M; M++) {
                const P = K[M]; this.renderCoordsHelper.worldUpAtPosition(P.origin, P.direction); const L = K[3 === M ? 0 : M + 1]; P.cap.next = L.origin; y.direction(P.cap.direction, P.origin,
                  L.origin); f.fromVectorsAndPoint(P.direction, P.cap.direction, P.origin, this.planes[M]); F || y.scale(P.direction, P.direction, -1)
              } f.fromVectorsAndPoint(K[0].cap.direction, K[1].cap.direction, K[0].origin, this.planes[4]); F ? f.negate(this.planes[4], this.planes[5]) : (f.copy(this.planes[4], this.planes[5]), f.negate(this.planes[4], this.planes[4])); this.maxSpan = Math.max(Math.abs(H[0] - H[2]), Math.abs(H[1] - H[3])); this.maxSpanSpatialReference = J; this.minGlobalAltitude = .9 * l.getReferenceEllipsoid(this.maxSpanSpatialReference).radius
            };
            E.isVisibleInFrustum = function (H, J, M = !1) {
              if (null == H) return !1; if (1 === this.renderCoordsHelper.viewingMode) { if (this.maxSpan > (this.maxSpanSpatialReference.isGeographic ? e : m * J)) return !0; if (H.altitude >= this.minGlobalAltitude) return this.isVisibleInFrustumGlobal(H) } if (0 === this.maxSpan) return J = this.extent[0], !M && H.intersectsRay(t.wrap(J.origin, J.direction)) ? !0 : !1; for (J = 0; J < this.extent.length; J++) {
                var F = this.extent[J]; if (!M && H.intersectsRay(t.wrap(F.origin, F.direction)) || H.intersectsLineSegment(d.fromPoints(F.origin,
                  F.cap.next, C), F.cap.direction)) return !0
              } M = M ? this.planes : this.planesWithoutFar; for (J = 0; J < H.lines.length; J++)if (F = H.lines[J], v.frustumLineSegment(M, F.origin, F.endpoint, F.direction)) return !0; return !1
            }; E.toRenderBoundingExtentGlobal = function (H, J, M) {
              b.center(H, k); k[2] = M; p.computeTranslationToOriginAndRotation(J, k, r, this.renderCoordsHelper.spatialReference); q.invert(A, r); h.empty(z); for (const { x0: F, x1: K, y0: P, y1: L } of x) for (let N = 0; 5 > N; N++) {
                const G = N / 4; k[0] = c.lerp(H[F], H[K], G); k[1] = c.lerp(H[P], H[L], G); k[2] =
                  M; p.projectVectorToVector(k, J, k, this.renderCoordsHelper.spatialReference); y.transformMat4(k, k, A); h.expandWithVec3(z, k)
              } y.set(this.extent[0].origin, z[0], z[1], z[2]); y.set(this.extent[1].origin, z[3], z[1], z[2]); y.set(this.extent[2].origin, z[3], z[4], z[2]); y.set(this.extent[3].origin, z[0], z[4], z[2]); for (H = 0; 4 > H; ++H)y.transformMat4(this.extent[H].origin, this.extent[H].origin, r)
            }; E.toRenderBoundingExtentLocal = function (H, J, M) {
              p.projectBoundingRect(H, J, B, this.renderCoordsHelper.spatialReference); y.set(this.extent[0].origin,
                B[0], B[1], M); y.set(this.extent[1].origin, B[2], B[1], M); y.set(this.extent[2].origin, B[2], B[3], M); y.set(this.extent[3].origin, B[0], B[3], M)
            }; E.toRenderBoundingExtent = function (H, J, M) { switch (this.renderCoordsHelper.viewingMode) { case 1: this.toRenderBoundingExtentGlobal(H, J, M); break; case 2: this.toRenderBoundingExtentLocal(H, J, M); break; default: w.neverReached(this.renderCoordsHelper.viewingMode) } }; E.isVisibleInFrustumGlobal = function (H) {
              if (0 > y.dot(this.center.direction, H.direction)) return !0; for (let J = 0; 4 > J; J++)if (0 >
                y.dot(this.extent[J].direction, H.direction)) return !0; return !1
            }; return D
          }(); const x = [{ x0: 0, y0: 1, x1: 2, y1: 1 }, { x0: 0, y0: 3, x1: 2, y1: 3 }, { x0: 0, y0: 1, x1: 0, y1: 3 }, { x0: 2, y0: 1, x1: 2, y1: 3 }], k = n.create(), r = u.create(), A = u.create(), z = h.create(), B = b.create(), C = d.create(); a.FrustumExtentIntersection = g; a.default = g; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/extentUtils": function () {
      define(["exports", "../../../core/maybe", "../../../chunks/vec3f64", "../../../geometry/projection"], function (a,
        w, c, q) {
          const u = c.create(); a.projectToBoundingBox = function (y, n, p) {
            if (w.isNone(y) || w.isNone(p)) return !1; let l; u[0] = null != y.xmin ? y.xmin : 0; u[1] = null != y.ymin ? y.ymin : 0; u[2] = null != y.zmin ? y.zmin : 0; l = q.projectBuffer(u, y.spatialReference, 0, n, p, 0, 1); u[0] = null != y.xmax ? y.xmax : 0; u[1] = null != y.ymax ? y.ymax : 0; u[2] = null != y.zmax ? y.zmax : 0; l = l && q.projectBuffer(u, y.spatialReference, 0, n, p, 3, 1); null == y.xmin && (n[0] = -Infinity); null == y.ymin && (n[1] = -Infinity); null == y.zmin && (n[2] = -Infinity); null == y.xmax && (n[3] = Infinity); null ==
              y.ymax && (n[4] = Infinity); null == y.zmax && (n[5] = Infinity); return l
          }; a.toBoundingRect = function (y, n, p) {
            if (w.isNone(y) || w.isNone(p)) return !1; let l; u[0] = null != y.xmin ? y.xmin : 0; u[1] = null != y.ymin ? y.ymin : 0; u[2] = null != y.zmin ? y.zmin : 0; l = q.projectBuffer(u, y.spatialReference, 0, u, p, 0, 1); n[0] = u[0]; n[1] = u[1]; u[0] = null != y.xmax ? y.xmax : 0; u[1] = null != y.ymax ? y.ymax : 0; u[2] = null != y.zmax ? y.zmax : 0; l = l && q.projectBuffer(u, y.spatialReference, 0, u, p, 0, 1); n[2] = u[0]; n[3] = u[1]; null == y.xmin && (n[0] = -Infinity); null == y.ymin && (n[1] = -Infinity);
            null == y.xmax && (n[2] = Infinity); null == y.ymax && (n[3] = Infinity); return l
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/ViewState": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Evented ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/watch ../../../chunks/vec3f64 ../../../geometry/projectionEllipsoid ../../ViewAnimation ./Constraints ./controllers/AnimationController ./controllers/CameraController ../support/PropertiesPool ../webgl-engine/lib/Camera".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
          c = function (z) {
            function B() { var D = z.apply(this, arguments) || this; D._propertiesPool = new g.PropertiesPool({ camera: x }, a._assertThisInitialized(D)); D._lastSeenCameraProjectionValues = new x; D.events = new q; D.viewingMode = 1; D._cameraChanged = !1; D.updateQueue = []; D.processingUpdates = !1; return D } a._inheritsLoose(B, z); var C = B.prototype; C.init = function (D, E) { this._set("viewingMode", D); this._set("spatialReference", E); this._set("constraints", new v.default({ mode: this.viewingMode })) };
            C.exit = function () { this.cameraController = null; this._propertiesPool.destroy(); this._propertiesPool = new g.PropertiesPool({ camera: x }, this) }; C.createInitialCamera = function () { if (1 === this.viewingMode) { const D = f.getReferenceEllipsoid(this.spatialReference).radius; this.camera = new x(d.fromValues(4 * D, 0, 0), d.fromValues(D, 0, 0), d.fromValues(0, 0, 1)) } else this.camera = new x(d.fromValues(0, 0, 100), d.fromValues(0, 0, 0), d.fromValues(0, 1, 0)) }; C.switchCameraController = function (D) {
            this.cameraController = D; return D.state !==
              e.State.Rejected
            }; C.stopActiveCameraController = function () { return this.cameraController && !this.cameraController.stopController() ? !1 : !0 }; C.updateCamera = function (D) { this.updateQueue.push(D); this.processUpdateQueue() }; C.processUpdateQueue = function () { if (0 !== this.updateQueue.length && !this.processingUpdates) { this.processingUpdates = !0; var D = this.updateQueue.shift(); k.copyFrom(this._get("camera")); D(k); this.camera = k; this.processingUpdates = !1; this.processUpdateQueue() } }; C.cameraProjectionChanged = function (D,
              E) { return D.fov !== E.fov || D.fullViewport[0] !== E.fullViewport[0] || D.fullViewport[1] !== E.fullViewport[1] || D.fullViewport[2] !== E.fullViewport[2] || D.fullViewport[3] !== E.fullViewport[3] || D.padding[0] !== E.padding[0] || D.padding[1] !== E.padding[1] || D.padding[2] !== E.padding[2] || D.padding[3] !== E.padding[3] ? !0 : !1 }; a._createClass(B, [{ key: "animation", get: function () { return this.cameraController instanceof m.AnimationController && u.isSome(this.cameraController.viewAnimation) ? this.cameraController.viewAnimation : null } },
              {
                key: "camera", get: function () { return this._get("camera") }, set: function (D) {
                D !== k && k.copyFrom(D); k.computeUp(this.viewingMode); r.camera = k; this.events.emit("before-camera-change", r); D = this._get("camera"); this.cameraProjectionChanged(this._lastSeenCameraProjectionValues, k) && (this._lastSeenCameraProjectionValues.copyFrom(k), A.camera = this._lastSeenCameraProjectionValues, this.events.emit("camera-projection-changed", A)); if (!D || !D.equals(k)) if (this._set("camera", this._propertiesPool.get("camera").copyFrom(k)),
                  this._cameraChanged = !D || !D.almostEquals(k)) { const E = b.afterDispatch(() => { this._cameraChanged = !1; E.remove() }) }
                }
              }, { key: "contentCamera", get: function () { return u.isSome(this._contentCamera) ? this._contentCamera : this.camera }, set: function (D) { this._contentCamera = u.isSome(D) ? D.clone() : null } }, { key: "fixedContentCamera", get: function () { return !!u.isSome(this._contentCamera) } }, { key: "isGlobal", get: function () { return 1 === this.viewingMode } }, { key: "isLocal", get: function () { return 2 === this.viewingMode } }, {
                key: "navigating",
                get: function () { return !(!this.cameraController || !this.cameraController.isInteractive) }
              }, { key: "stationary", get: function () { return !this._cameraChanged && !this.navigating } }, {
                key: "cameraController", get: function () { return this._get("cameraController") }, set: function (D) {
                  this.stopActiveCameraController() ? (D && (D.watch("state", E => { if (E === e.State.Finished || E === e.State.Stopped) this._set("cameraController", null), this.updateCamera(H => D.onControllerEnd(H)) }, !0), D.onControllerStart(this.camera)), this._set("cameraController",
                    D)) : D && (D.state = e.State.Rejected)
                }
              }]); return B
          }(c); w.__decorate([y.property({ readOnly: !0, type: t })], c.prototype, "animation", null); w.__decorate([y.property({ type: x })], c.prototype, "camera", null); w.__decorate([y.property({})], c.prototype, "_contentCamera", void 0); w.__decorate([y.property({ type: x })], c.prototype, "contentCamera", null); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "fixedContentCamera", null); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "constraints", void 0); w.__decorate([y.property({ readOnly: !0 })],
            c.prototype, "events", void 0); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "isGlobal", null); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "isLocal", null); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "viewingMode", void 0); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "spatialReference", void 0); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "navigating", null); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "stationary", null); w.__decorate([y.property()], c.prototype,
              "_cameraChanged", void 0); w.__decorate([y.property()], c.prototype, "cameraController", null); w = c = w.__decorate([h.subclass("esri.views.3d.state.ViewState")], c); const k = new x, r = { camera: null }, A = { camera: null }; return w
        })
    }, "esri/views/3d/support/PropertiesPool": function () {
      define(["exports", "../../../core/ReentrantObjectPool", "../../../core/accessorSupport/watch"], function (a, w, c) {
        let q = function () {
          function u(n, p) {
          this.owner = p; this.properties = {}; this.afterDispatchHandle = null; for (const l in n) p = new w.ReentrantObjectPool(n[l],
            null, null, 2, 2), this.properties[l] = { pool: p, acquired: [] }; this.afterDispatchHandle = c.afterDispatch(() => this.release())
          } var y = u.prototype; y.destroy = function () { this.afterDispatchHandle && (this.afterDispatchHandle.remove(), this.afterDispatchHandle = null); for (const n in this.properties) { const p = this.properties[n]; for (const l of p.acquired) c.isValueInUse(l) || p.pool.release(l); p.pool.destroy(); p.pool = null; p.acquired = null } this.owner = this.properties = null }; y.get = function (n) {
            const p = this.owner._get(n); n = this.properties[n];
            let l = n.pool.acquire(); for (n.acquired.push(l); l === p;)n.acquired.push(l), l = n.pool.acquire(); return l
          }; y.release = function () { for (const n in this.properties) { const p = this.properties[n]; let l = 0; for (const h of p.acquired) c.isValueInUse(h) ? p.acquired[l++] = h : p.pool.release(h); p.acquired.length = l } }; return u
        }(); a.PropertiesPool = q; a.default = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/ViewStateManager": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Camera ../../../Viewpoint ../../../core/Accessor ../../../core/Handles ../../../core/Logger ../../../core/maybe ../../../core/scheduling ../../../core/screenUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4 ../../../chunks/vec4f64 ../../../geometry/Extent ../../../geometry/Point ../../../geometry/support/webMercatorUtils ../camera/constraintUtils ../camera/intersectionUtils ./ConstraintsManager ./Frustum ./GoToOperation ./controllers/SurfaceCollisionCorrectionController ../support/cameraUtils ../support/PropertiesPool ../support/viewpointUtils ../webgl-engine/lib/Camera".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P) {
          const L = n.getLogger("esri.views.3d.state.ViewStateManager"); u = function (Q) {
            function T(Y) { Y = Q.call(this, Y) || this; Y.propertiesPool = new F.PropertiesPool({ frustum: E.Frustum }, a._assertThisInitialized(Y)); Y.handles = new y; Y.cameraSetByUser = !1; Y.gotoOperation = null; Y.ready = !1; Y.updateDevicePixelRatio = null; Y.test = { contentCameraResetState: new Map }; return Y } a._inheritsLoose(T, Q); var da = T.prototype; da.installContentCameraReset = function (Y) {
              this.handles.remove("contentCameraReset");
              this.test.contentCameraResetState.clear(); if (!this.view.state.fixedContentCamera) return !1; const fa = this.zoom, ha = this.view.state.camera.distance ** 2, ka = g.fromArray(this.view.state.camera.center), ea = Y.sticky ? this.contentCamera.clone() : null; this.handles.add([this.watch("contentCamera", () => { Y.sticky || (this.handles.remove("contentCameraReset"), this.test.contentCameraResetState.clear()) }), this.watch("zoom", ba => {
                this.test.contentCameraResetState.set("view.zoom", Math.abs(ba - fa) / 2); 2 < Math.abs(ba - fa) ? this.contentCamera =
                  null : this.view.state.fixedContentCamera || (this.contentCamera = ea)
              }), this.view.state.watch("camera", ba => { ba = e.squaredDistance(ka, ba.center); this.test.contentCameraResetState.set("camera.center", ba / ha); ba > ha ? this.contentCamera = null : this.view.state.fixedContentCamera || (this.contentCamera = ea) })], "contentCameraReset"); return !0
            }; da.paddingToArray = function (Y, fa, ha) { Y ? x.set(ha, Y.top || 0, Y.right || 0, Y.bottom || 0, Y.left || 0) : x.set(ha, 0, 0, 0, 0); for (Y = 0; 4 > Y; Y++)ha[Y] = Math.round(ha[Y] * fa) }; da.initialize = function () {
              this.handles.add([b.on(this.view,
                "state.events", "before-camera-change", Y => this.updateElevation(Y.camera))]); b.once(this.view.state, "camera", Y => this.updateElevation(Y), !0); this.handles.add(l.addFrameTask({ prepare: () => this.prepareFrame() })); this.handles.add(this.view.state.watch("cameraController", () => { this.cameraSetByUser = !0; this.handles.remove("pending-initial-view") })); this.handles.add(b.on(this.view, "state.events", "camera-projection-changed", () => this.notifyChange("scale")))
            }; da.destroy = function () {
              this.deinit(); this.handles && (this.handles.destroy(),
                this.handles = null); this.propertiesPool && (this.propertiesPool.destroy(), this.propertiesPool = null)
            }; da.init = function () {
            this.constraintsManager = new D.default({ view: this.view }); this.prepareFrame(); var Y = this.getInitialProperties(); this.cameraSetByUser = !1; this._set("ready", !0); for (const fa of Y) this.set(fa.name, fa.value); this.cameraSetByUser || ((Y = this.view.get("map.initialViewProperties.viewpoint") || this.view.initialExtent) && this.isCompatible(Y) ? this.setInitialView(Y) : 2 === this.view.state.viewingMode &&
              this.handles.add(b.whenOnce(this.view.basemapTerrain, "ready", () => { this.handles.remove("pending-initial-view"); this.setInitialView(this.view.dataExtent) }), "pending-initial-view"))
            }; da.deinit = function () { this.cancelGoToOperation(); this.ready && (this._override("padding", this.padding), this._set("ready", !1), this._clearOverride("hasInitialView"), this.cameraSetByUser = !1, this.handles.remove("pending-initial-view"), this.constraintsManager && (this.constraintsManager.destroy(), this.constraintsManager = null)) }; da.goTo =
              function () { var Y = a._asyncToGenerator(function* (fa, ha) { ha = { animate: !0, ...ha }; p.isSome(this.gotoOperation) && this.gotoOperation.abort(ha.animate); this.gotoOperation = new H.GoToOperation(fa, ha, this.view); this.view.resourceController.scheduler.stopFrame(); return this.gotoOperation }); return function (fa, ha) { return Y.apply(this, arguments) } }(); da.debugSetCameraOnContent = function () { this.setStateCamera(C.cameraOnContentAlongViewDirection(this.view), { applyConstraints: !1 }) }; da.step = function (Y) {
                const fa = this.view.state,
                ha = fa && this.view.state.cameraController; ha && (fa.updateCamera(ka => { ha.stepController(Y, ka) }), ha.steppingFinished && ha.finishController())
              }; da.cancelGoToOperation = function () { p.isSome(this.gotoOperation) && (this.gotoOperation.abort(), this.gotoOperation = null) }; da.getInitialProperties = function () { const Y = new Set, fa = []; for (const { propertyName: ha, overrides: ka } of G) { const ea = Y.has(ha), ba = this._isOverridden(ha); !ea && ba && fa.push({ name: ha, value: this._get(ha) }); this._clearOverride(ha); (ea || ba) && ka.forEach(aa => Y.add(aa)) } return fa };
            da.setInitialView = function (Y) {
              if (!p.isNone(Y) && !this.cameraSetByUser) if (Y instanceof c) this.setStateCamera(M.externalToInternal(this.view, Y), { applyConstraints: !1 }); else if (Y instanceof q) if (Y.targetGeometry instanceof r) { var fa = M.fromExtent(this.view, Y.targetGeometry, 0, .5, 0); p.isSome(fa) && this.setStateCamera(M.externalToInternal(this.view, fa), { applyConstraints: !0 }) } else fa = { applyConstraints: !Y.camera }, Y = this.viewpointToCamera(Y), this.setStateCamera(Y, fa); else fa = M.fromExtent(this.view, Y, 0, .5, 0), p.isSome(fa) &&
                this.setStateCamera(M.externalToInternal(this.view, fa), { applyConstraints: !0 })
            }; da.updatePropertyBeforeReady = function (Y, fa) { if (this.ready) return !1; this._override(Y, fa); fa && -1 !== N.indexOf(Y) && this._override("hasInitialView", !0); return !0 }; da.isCompatible = function (Y) { return p.isNone(Y) ? !1 : Y instanceof q ? Y.camera ? this.isCompatible(Y.camera) : this.isCompatible(Y.targetGeometry) : Y instanceof c ? this.isCompatible(Y.position) : Y.spatialReference && z.canProject(Y.spatialReference, this.view.spatialReference) }; da.getPreservingHeadingTilt =
              function (Y = I) { this.cameraSetByUser ? (Y.heading = this.camera.heading, Y.tilt = this.camera.tilt) : (Y.heading = 0, Y.tilt = .5); return Y }; da.centerPointAtDistanceToCamera = function (Y, fa, ha = R) { const { heading: ka, tilt: ea } = this.getPreservingHeadingTilt(); Y = M.getObserverForPointAtDistance(this.view, ka, ea, Y, fa, 1); if (p.isNone(Y)) return null; ha.copyFrom(this.view.state.camera); ha.eye = Y.eye; ha.center = Y.center; ha.up = Y.up; return ha }; da.centerToCamera = function (Y) {
                const fa = this.view.pointsOfInterest.centerOnContent; fa.runTask();
                return this.centerPointAtDistanceToCamera(Y, fa.distance)
              }; da.extentToCamera = function (Y) { const { heading: fa, tilt: ha } = this.getPreservingHeadingTilt(); Y = M.fromExtent(this.view, Y, fa, ha, 1, O); return p.isSome(Y) ? M.externalToInternal(this.view, Y) : null }; da.scaleToCamera = function (Y) { if (null == Y) return null; const fa = this.view.pointsOfInterest.centerOnContent; fa.runTask(); const ha = fa.renderLocation; Y = M.scaleToDistance(this.view, Y, fa.location.latitude); return this.centerPointAtDistanceToCamera(ha, Y) }; da.zoomToCamera =
                function (Y) { return this.scaleToCamera(M.zoomToScale(this.view, Y)) }; da.viewpointToCamera = function (Y) { return M.externalToInternal(this.view, K.toCamera(this.view, Y)) }; da.setStateCamera = function (Y, fa) {
                  if (p.isNone(Y) || !this.view.state.stopActiveCameraController()) return !1; this.cameraSetByUser = !0; fa.doNotCancelGoToOperation || this.cancelGoToOperation(); this.view.state.updateCamera(ha => {
                    fa.positionAndOrientationOnly ? (ha.eye = Y.eye, ha.center = Y.center, ha.up = Y.up) : ha.copyFrom(Y); fa.applyConstraints && B.applyAll(this.view,
                      ha)
                  }); fa.applyConstraints || (this.view.state.cameraController = new J.SurfaceCollisionCorrectionController({ view: this.view, desiredCamera: Y })); return !0
                }; da.prepareFrame = function () {
                  const { container: Y, canvas: fa } = this.view; if (Y && fa) {
                    p.isSome(this.updateDevicePixelRatio) && this.updateDevicePixelRatio(); var ha = this.view.pixelRatio, ka = Math.round(Y.clientWidth * ha), ea = Math.round(Y.clientHeight * ha); if (0 !== ka && 0 !== ea) {
                      if (fa.width !== ka || fa.height !== ea) fa.width = ka, fa.height = ea; if (this.view.state) {
                        const ba = this.view.state.camera;
                        if (ba.fullWidth !== ka || ba.fullHeight !== ea || ba.pixelRatio !== ha) R.copyFrom(ba), R.pixelRatio !== ha && (this.paddingToArray(this.padding, ha, S), R.padding = S), R.fullWidth = ka, R.fullHeight = ea, R.pixelRatio = ha, this.view.state.camera = R
                      }
                    }
                  }
                }; da.updateElevation = function (Y) { var fa = this.view.basemapTerrain && this.view.basemapTerrain.spatialReference; const ha = this.view.renderCoordsHelper.getAltitude(Y.eye); fa = fa ? C.surfaceElevationBelowRenderLocation(this.view, Y.eye) : 0; Y.relativeElevation = ha - fa }; a._createClass(T, [{
                  key: "camera",
                  get: function () { const Y = this._get("camera"); if (!this.ready) return Y; const fa = M.internalToExternal(this.view, this.view.state.camera); return fa && Y && fa.equals(Y) ? Y : fa }, set: function (Y) { this.updatePropertyBeforeReady("camera", Y) || (this.view.elevationProvider.enableElevationCache(!0), this.setStateCamera(M.externalToInternal(this.view, Y), { applyConstraints: !1 }) || L.error("#camera\x3d", "Invalid camera", Y), this.view.elevationProvider.enableElevationCache(!1)) }
                }, {
                  key: "contentCamera", get: function () {
                    const Y = this._get("contentCamera");
                    if (!this.ready) return Y; const fa = M.internalToExternal(this.view, this.view.state.contentCamera); return fa && Y && fa.equals(Y) ? Y : fa
                  }, set: function (Y) { this.updatePropertyBeforeReady("contentCamera", Y) || (Y = M.externalToInternal(this.view, Y), p.isNone(Y) ? this.view.state.contentCamera = null : (this.updateElevation(Y), this.view.state.contentCamera = Y)) }
                }, {
                  key: "center", get: function () { return this.ready ? this.view.pointsOfInterest.centerOnContent.location : this._get("center") }, set: function (Y) {
                    this.updatePropertyBeforeReady("center",
                      Y) || (Y ? this.isCompatible(Y) ? this.setStateCamera(this.centerToCamera(Y), { applyConstraints: !0 }) ? this.view.pointsOfInterest.centerOnContent.runTask() : L.error("#center\x3d", "Invalid center", Y) : L.error("#center\x3d", "Center has an incompatible spatial reference (center: " + (Y.spatialReference ? Y.spatialReference.wkid : "none") + ", view: " + this.view.spatialReference.wkid + ")", Y) : L.error("#center\x3d", "Center may not be null or undefined"))
                  }
                }, {
                  key: "extent", get: function () {
                    if (!this.ready) return this._get("extent");
                    var Y = this.view; Y = M.toExtent(Y, Y.state.camera, Y.pointsOfInterest.centerOnContent.renderLocation); return p.isSome(Y) ? Y : this._get("extent")
                  }, set: function (Y) {
                    this.updatePropertyBeforeReady("extent", Y) || (Y ? this.isCompatible(Y) ? this.setStateCamera(this.extentToCamera(Y), { applyConstraints: !0 }) || L.error("#extent\x3d", "Invalid extent", Y) : L.error("#extent\x3d", "Extent has an incompatible spatial reference (extent: " + (Y.spatialReference ? Y.spatialReference.wkid : "none") + ", view: " + this.view.spatialReference.wkid +
                      ")", Y) : L.error("#extent\x3d", "Extent may not be null or undefined"))
                  }
                }, { key: "frustum", get: function () { const Y = this.propertiesPool.get("frustum"); Y.renderCoordsHelper = this.view.renderCoordsHelper; Y.update(this.view.state.camera); return Y } }, { key: "hasInitialView", get: function () { return !!this.view.get("map.initialViewProperties.viewpoint") } }, {
                  key: "scale", get: function () { if (this.ready) { const Y = this.view.pointsOfInterest.centerOnContent; return M.distanceToScale(this.view, Y.distance, Y.location.latitude) } return this._get("scale") },
                  set: function (Y) { this.updatePropertyBeforeReady("scale", Y) || this.setStateCamera(this.scaleToCamera(Y), { applyConstraints: !0 }) || L.error("#scale\x3d", "Invalid scale", Y) }
                }, {
                  key: "padding", get: function () {
                    if (!this.ready) return this._get("padding"); var Y = this.view.state.camera, fa = Y.padding; const ha = Y.pixelRatio; Y = this._get("padding"); const ka = Math.round(fa[0] / ha), ea = Math.round(fa[1] / ha), ba = Math.round(fa[2] / ha); fa = Math.round(fa[3] / ha); return null != Y && Y.top === ka && Y.right === ea && Y.bottom === ba && Y.left === fa ? Y : {
                      top: ka,
                      right: ea, bottom: ba, left: fa
                    }
                  }, set: function (Y) { this.updatePropertyBeforeReady("padding", Y) || (this.paddingToArray(Y, this.view.state.camera.pixelRatio, S), this.view.state.updateCamera(fa => fa.padding = S)) }
                }, { key: "screenCenter", get: function () { const Y = this.padding; return h.createScreenPoint((this.view.width - (Y.left + Y.right)) / 2 + Y.left, (this.view.height - (Y.top + Y.bottom)) / 2 + Y.top) } }, {
                  key: "viewpoint", get: function () { return this.ready ? K.fromCamera(this.view, this.camera) : this._get("viewpoint") }, set: function (Y) {
                    if (!this.updatePropertyBeforeReady("viewpoint",
                      Y)) if (Y) if (this.isCompatible(Y)) this.setStateCamera(this.viewpointToCamera(Y), { applyConstraints: !Y.camera }) || L.error("#viewpoint\x3d", "Invalid viewpoint", Y); else { var fa = p.isSome(Y.camera) ? Y.camera.position : Y.targetGeometry; fa = p.isSome(fa) && fa.spatialReference; L.error("#viewpoint\x3d", "Viewpoint has an incompatible spatial reference (viewpoint: " + (fa ? fa.wkid : "none") + ", view: " + this.view.spatialReference.wkid + ")", Y) } else L.error("#viewpoint\x3d", "Viewpoint may not be null or undefined")
                  }
                }, {
                  key: "zoom",
                  get: function () { return this.ready ? M.scaleToZoom(this.view, this.scale) : this._get("zoom") }, set: function (Y) { this.updatePropertyBeforeReady("zoom", Y) || this.setStateCamera(this.zoomToCamera(Y), { applyConstraints: !0 }) || L.error("#zoom\x3d", "Invalid zoom", Y) }
                }]); return T
          }(u); w.__decorate([d.property({ type: c, dependsOn: ["view.state.camera", "ready"] })], u.prototype, "camera", null); w.__decorate([d.property({ type: c, dependsOn: ["view.state.contentCamera", "ready"] })], u.prototype, "contentCamera", null); w.__decorate([d.property({ type: A })],
            u.prototype, "center", null); w.__decorate([d.property({ type: r })], u.prototype, "extent", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "frustum", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "hasInitialView", null); w.__decorate([d.property({ readOnly: !0, type: Boolean })], u.prototype, "ready", void 0); w.__decorate([d.property({ type: Number })], u.prototype, "scale", null); w.__decorate([d.property()], u.prototype, "padding", null); w.__decorate([d.property({ readOnly: !0 })], u.prototype, "screenCenter",
              null); w.__decorate([d.property({ constructOnly: !0 })], u.prototype, "view", void 0); w.__decorate([d.property({ type: q })], u.prototype, "viewpoint", null); w.__decorate([d.property({ type: Number })], u.prototype, "zoom", null); w.__decorate([d.property({ constructOnly: !0 })], u.prototype, "updateDevicePixelRatio", void 0); w = u = w.__decorate([m.subclass("esri.views.3d.state.ViewStateManager")], u); const N = "camera viewpoint extent scale center zoom".split(" "), G = [{ propertyName: "camera", overrides: ["viewpoint"] }, {
                propertyName: "viewpoint",
                overrides: ["extent"]
              }, { propertyName: "extent", overrides: ["center", "scale"] }, { propertyName: "center", overrides: [] }, { propertyName: "scale", overrides: ["zoom"] }, { propertyName: "zoom", overrides: [] }, { propertyName: "padding", overrides: [] }], I = { heading: 0, tilt: 0 }, O = new c, R = new P, S = k.create(); return w
        })
    }, "esri/views/3d/state/ConstraintsManager": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/mathUtils ../../../core/maybe ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../camera/constraintUtils ../camera/intersectionUtils ./NearFarHeuristic ./SurfaceCollisionConstraint".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
        a.ConstraintsManager = function (g) {
          function x(r) { var A = g.call(this, r) || this; A._handles = new u; A.nearFarHeuristic = m.createNearFarHeuristic(r.view.state.viewingMode, r.view.basemapTerrain, r.view.renderCoordsHelper.spatialReference); return A } w._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () {
            this._handles.add([this.view.watch(["constraints.clipDistance.near", "constraints.clipDistance.far"], () => this._clipDistanceNearFarChanged()), this.view.watch("constraints.clipDistance.mode",
              () => this._updateNearFar()), this.view.state.events.on("before-camera-change", r => this._updateCameraNearFar(r.camera)), this.view.watch("renderDataExtent", () => this._updateNearFar(), !0), this.view.watch(["constraints.altitude.min", "constraints.altitude.max"], () => this._updateAltitude(), !0), this.view.watch("constraints.tilt.max", () => this._updateTiltMax(), !0), this.view.watch("constraints.tilt.mode", () => this._updateTilt(), !0), this.view.watch("state.camera", () => this._updateTiltAutoMax(), !0), this.view.watch(["map.ground.navigationConstraint.type",
                "constraints.collision.enabled"], () => this._updateCollision(), !0)]); this.view.state.isLocal && this._handles.add(p.init(this.view, "renderDataExtent", r => this._updateLocalSurfaceDistance(r))); this._updateNearFar(); 2 !== this.view.state.viewingMode && this._updateAltitude(); this._updateTilt(); this._updateCollision(); this._set("surfaceCollisionConstraint", new e.default({ view: this.view }))
          }; k.destroy = function () {
          this._handles = n.destroyMaybe(this._handles); this.surfaceCollisionConstraint && (this.surfaceCollisionConstraint.destroy(),
            this._set("surfaceCollisionConstraint", null))
          }; k._clipDistanceNearFarChanged = function () { var r; const A = null == (r = this.view.constraints) ? void 0 : r.clipDistance; A && "auto" !== A.mode && this.view.state.updateCamera(z => { this._updateCameraNearFarManual(z, A); return !0 }) }; k._updateNearFar = function () { this.view.state.updateCamera(r => { this._updateCameraNearFar(r); return !0 }) }; k._updateCameraNearFar = function (r) {
            const A = this.view.constraints && this.view.constraints.clipDistance; "manual" === (A ? A.mode : "auto") ? this._updateCameraNearFarManual(r,
              A) : this._updateCameraNearFarAuto(r, A)
          }; k._updateCameraNearFarAuto = function (r, A) { this.nearFarHeuristic.compute(r.eye, r.center, this.view.renderDataExtent, v.surfaceElevationBelowRenderLocation(this.view, r.eye), r); A && A.autoUpdate(r.near, r.far) }; k._updateCameraNearFarManual = function (r, A) { A && (r.near = A.near, r.far = A.far) }; k._updateCollision = function () {
            var r, A, z; const B = null == (r = this.view.map) ? void 0 : null == (A = r.ground) ? void 0 : null == (z = A.navigationConstraint) ? void 0 : z.type; r = B ? "stay-above" === B : !0; A = this.view.state.constraints.collision;
            r !== A.enabled && ((A.enabled = r) && this._reapplyConstraints(8), (r = this.view.constraints && this.view.constraints.tilt) && "auto" !== r.mode || this._updateTiltAuto())
          }; k._updateAltitude = function () { const r = this.view.constraints && this.view.constraints.altitude; this.view.state.constraints.altitude = r && 2 !== this.view.state.viewingMode ? { min: r.min, max: r.max } : null; this._reapplyConstraints() }; k._updateTiltMax = function () {
            const r = this.view.constraints && this.view.constraints.tilt; r && "auto" !== r.mode && (this._updateTiltManual(r),
              this._reapplyConstraints())
          }; k._updateTilt = function () { const r = this.view.constraints && this.view.constraints.tilt; "manual" === (r ? r.mode : "auto") ? this._updateTiltManual(r) : this._updateTiltAuto(); this._reapplyConstraints() }; k._updateTiltManual = function (r) { const A = this.view.state.constraints; A.tilt = A.createConstantMaxTilt(y.deg2rad(r.max)) }; k._updateTiltAuto = function () { const r = this.view.state.constraints; r.tilt = r.createDefaultTilt(); this._updateTiltAutoMax() }; k._updateTiltAutoMax = function () {
            const r = this.view.constraints &&
              this.view.constraints.tilt; if (r && "auto" === r.mode) { var A = this.view.state.constraints; A.tilt && (A = A.tilt(this.view.state.camera.distance).max, r.autoUpdate(y.rad2deg(A))) }
          }; k._updateLocalSurfaceDistance = function (r) { if (!n.isNone(r)) { var A = Math.max(r.width, r.height); 0 >= A || (r.hasZ && (A = Math.max(A, r.zmax - r.zmin)), r = this.view.state, A = 3 * A / Math.atan(r.camera.fov / 2), A !== r.constraints.distance && (r.constraints.distance = A)) } }; k._reapplyConstraints = function (r = 15) {
            this.view.state.updateCamera(A => t.applyAll(this.view,
              A, { selection: r, interactionType: 0, interactionFactor: null, interactionStartCamera: null, interactionDirection: null, tiltMode: 0 }))
          }; return x
        }(q); c.__decorate([l.property({ constructOnly: !0 })], a.ConstraintsManager.prototype, "view", void 0); c.__decorate([l.property({ readOnly: !0 })], a.ConstraintsManager.prototype, "surfaceCollisionConstraint", void 0); a.ConstraintsManager = c.__decorate([f.subclass("esri.views.3d.state.ConstraintsManager")], a.ConstraintsManager); a.default = a.ConstraintsManager; Object.defineProperty(a,
          "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/NearFarHeuristic": function () {
      define("exports ../../../core/mathUtils ../../../core/maybe ../../../core/unitUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/Extent ../../../geometry/projectionEllipsoid".split(" "), function (a, w, c, q, u, y, n, p) {
        function l(t, v, m, e) { m = 2 / m; t / v > m ? (e.far = t, e.near = e.far / v) : (e.near = m, e.far = e.near * v); return e } let h = function () {
          function t(v, m) {
          this.elevationProvider = v; this._referenceEllipsoid = p.getReferenceEllipsoid(m);
            this.unitInMeters = q.getMetersPerUnitForSR(m, this._referenceEllipsoid.metersPerDegree)
          } t.prototype.compute = function (v, m, e, g, x) {
            x || (x = { near: 0, far: 0 }); var k = v[2] * this.unitInMeters, r = k; g = k - g; var A = this.elevationProvider ? this.elevationProvider.elevationBounds : null; A && (k = 0 <= g ? r - this.unitInMeters * A.min : this.unitInMeters * A.max - r); e = c.isSome(e) ? e : new n({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0 }); r = Math.max(e.xmax - e.xmin, e.ymax - e.ymin, 4 * Math.max(e.xmax - e.xmin, e.ymax - e.ymin)); u.subtract(f, m, v); d[0] = 0 < f[0] ?
              e.xmax : e.xmin; d[1] = 0 < f[1] ? e.ymax : e.ymin; d[2] = 0 < f[2] ? r / 2 : -r / 2; u.subtract(d, d, v); u.normalize(f, f); v = 1.1 * u.dot(d, f) * this.unitInMeters; m = Math.sqrt(k * (k + 2 * this._referenceEllipsoid.radius)); e = Math.max(e.xmax - e.xmin, e.ymax - e.ymin); A = 1E-4 * e * this.unitInMeters; k = w.clamp((k - A) / (.001 * e * this.unitInMeters - A), 0, 1); k = w.lerp(m, v, k * k * k); k *= Math.max(Math.log(Math.abs(g)), 1); k = Math.min(k, Math.max(34064E4, r)); k /= this.unitInMeters; return l(k, 2E4, this.unitInMeters, x)
          }; return t
        }(), b = function () {
          function t(v) {
          this._referenceEllipsoid =
            p.getReferenceEllipsoid(v)
          } t.prototype.compute = function (v, m, e, g, x) { x || (x = { near: 0, far: 0 }); v = u.length(v) - this._referenceEllipsoid.radius; v = Math.max(Math.abs(v - g), Math.abs(v)); g = Math.sqrt(v * (v + 2 * (this._referenceEllipsoid.radius + Math.min(0, g)))); v = w.clamp(2E4 - (Math.log(v) - 7.983) / 9.011 * 19E3, 1E3, 2E4); return l(1.2 * g, v, 1, x) }; return t
        }(); const d = y.create(), f = y.create(); a.createNearFarHeuristic = function (t, v, m) { return 1 === t ? new b(m) : new h(v, m) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/SurfaceCollisionConstraint": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../core/mathUtils ../../../geometry/support/ray ../../../chunks/sphere ../../../geometry/support/vectorStacks ../camera/constraintUtils/surfaceCollision ../../../geometry/projectionEllipsoid ../camera/intersectionUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
        a.SurfaceCollisionConstraint = function (g) {
          function x(r) { r = g.call(this, r) || this; r.handles = new u; return r } w._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this.handles.add(this.view.basemapTerrain.on("elevation-change", r => this.handleElevationChangeEvent(r))) }; k.destroy = function () { this.handles && (this.handles.destroy(), this.handles = null) }; k.handleElevationChangeEvent = function (r) {
            this.view.state.cameraController || e.eyeWithinExtent(this.view, this.view.state.camera,
              r.extent, r.spatialReference) && this.applyToCurrentCamera()
          }; k.applyToCurrentCamera = function () { this.view.state.updateCamera(r => { v.applySurfaceCollisionConstraint(this.view, r, 1) }) }; return x
        }(q); c.__decorate([y.property({ constructOnly: !0 })], a.SurfaceCollisionConstraint.prototype, "view", void 0); a.SurfaceCollisionConstraint = c.__decorate([h.subclass("esri.views.3d.state.ElevationCollisionConstraint")], a.SurfaceCollisionConstraint); a.default = a.SurfaceCollisionConstraint; Object.defineProperty(a, "__esModule",
          { value: !0 })
        })
    }, "esri/views/3d/state/GoToOperation": function () {
      define("exports ../../../Camera ../../../Viewpoint ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/watchUtils ../camera/constraintUtils ./controllers/CameraController ./controllers/PointToPointAnimationController ./controllers/SurfaceCollisionCorrectionController ../support/cameraUtils ../support/viewpointUtils ../camera/constraintUtils/surfaceCollision".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        let v =
          function () {
            function m(g, x, k) { this.target = g; this.options = x; this.view = k; this.state = "pending"; this.animationController = this.abortController = null; this.promise = new Promise((r, A) => { this.resolveCallback = r; this.rejectCallback = A; r = new AbortController; if (u.isSome(this.options.signal)) y.onAbort(this.options.signal, () => { this.abort() }); this.abortController = r; this.waitForReady() }) } var e = m.prototype; e.then = function (g, x) { return this.promise.then(g, x) }; e.catch = function (g) { return this.promise.catch(g) }; e.resolve = function (g) {
            this.state =
              "finished"; return this.resolveCallback(g)
            }; e.reject = function (g) { this.state = "finished"; return this.rejectCallback(g) }; e.abort = function (g = !1) { switch (this.state) { case "pending": case "wait-for-ready": case "wait-for-viewpoint": this.reject(y.createAbortError()); break; case "wait-for-animation-finish": !g && u.isSome(this.animationController) && this.view.state.cameraController === this.animationController && this.animationController.active && this.animationController.stopController(), this.reject(y.createAbortError()) } };
            e.waitForReady = function () { this.state = "wait-for-ready"; this.view.ready ? this.createViewPoint() : n.whenOnce(this.view, "ready", this.abortController.signal).then(() => { this.createViewPoint() }, g => { this.reject(g) }) }; e.createViewPoint = function () {
            "finished" !== this.state && (this.state = "wait-for-viewpoint", this.animationController = this.options.animate ? this.getAnimationController() : null, f.create(this.view, this.target, this.abortController.signal).then(g => {
            "finished" !== this.state && (g = this.getCameraFromViewpoint(g),
              u.isNone(g) || (this.options.animate ? u.isNone(this.animationController) || this.startAnimation(g, this.animationController) : (this.view.stateManager.setStateCamera(g.camera, { applyConstraints: !g.isFullySpecified, positionAndOrientationOnly: !0, doNotCancelGoToOperation: !0 }), this.resolve())))
            }, g => { this.reject(g) }))
            }; e.getCameraFromViewpoint = function (g) {
              const x = !!(this.target instanceof c && this.target.camera || this.target instanceof w); var k = g.camera; if (u.isNone(k)) return null; if (!this.view.stateManager.isCompatible(k)) return g =
                (g = k.position) && g.spatialReference, this.reject(new q("GotoAnimation:incompatible-spatialreference", `Resulting camera has an incompatible spatial reference (camera: ${g ? g.wkid : "none"}, view: ${this.view.spatialReference.wkid})`, { camera: k })), null; k = d.externalToInternal(this.view, k); return u.isNone(k) ? (this.reject(new q("GotoAnimation:invalid-camera", "Resulting camera is invalid")), null) : { viewpoint: g, camera: k, isFullySpecified: x }
            }; e.startAnimation = function (g, x) {
            this.state = "wait-for-animation-finish";
              const k = x.viewAnimation; if (u.isNone(k)) this.reject(new q("GotoAnimation:missing-animation", "Unreachable code in view.stateManager")); else {
                k.update(g.viewpoint, "running"); if (!x.active || u.isNone(x.viewAnimation) || x.viewAnimation.target !== g.viewpoint || this.view.state.cameraController !== x) return this.abort(); if (g.isFullySpecified) { var r = new b.SurfaceCollisionCorrectionController({ view: this.view, desiredCamera: g.camera }); t.applySurfaceCollisionConstraint(this.view, g.camera, 1) } else p.applyAll(this.view,
                  g.camera); x.begin(g.camera, this.options); var A = z => { if (!u.isNone(this.view.state)) switch (x.state) { case l.State.Finished: switch (this.state) { case "pending": case "wait-for-ready": case "wait-for-viewpoint": case "wait-for-animation-finish": this.resolve() }break; case l.State.Ready: case l.State.Rejected: case l.State.Running: case l.State.Stopped: switch (this.state) { case "pending": case "wait-for-ready": case "wait-for-viewpoint": case "wait-for-animation-finish": this.reject(z) } } }; k.when(() => {
                    const z = this.view.state.cameraController;
                    r && (z && z.active ? z instanceof h.PointToPointAnimationController && u.isSome(z.viewAnimation) && z.viewAnimation.target === g.viewpoint && (this.view.state.cameraController = r) : u.isSome(x.viewAnimation) && x.viewAnimation.target === g.viewpoint && "finished" === x.state && (this.view.state.cameraController = r))
                  }, z => A(z)); x.asyncResult = { resolve: () => A(), reject: z => A(z) }
              }
            }; e.getAnimationController = function () {
              let g; var x = null; x = this.view.state.cameraController; x instanceof h.PointToPointAnimationController && (x.updateStateFromViewAnimation(),
                x.active && (g = x, x = g.viewAnimation)); return null != g || (g = new h.PointToPointAnimationController({ view: this.view, mode: "animation" }), x = g.viewAnimation, this.view.state.switchCameraController(g)) ? g : (u.isSome(x) && x.stop(), this.reject(new q("GotoAnimation:goto-cannot-interrupt", "Cannot start an animation while interacting")), null)
            }; return m
          }(); a.GoToOperation = v; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/state/controllers/SurfaceCollisionCorrectionController": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Handles ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../core/mathUtils ../../../../geometry/support/ray ../../../../chunks/sphere ../../../../geometry/support/vectorStacks ../../camera/constraintUtils/surfaceCollision ../../../../geometry/projectionEllipsoid ../../camera/intersectionUtils ./CameraController".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
        a.SurfaceCollisionCorrectionController = function (g) {
          function x(r) { r = g.call(this, r) || this; r.handles = new q; return r } w._inheritsLoose(x, g); var k = x.prototype; k.onControllerStart = function () { this.state = e.State.Running; this.handles.add(this.view.basemapTerrain.on("elevation-change", r => this.handleElevationChangeEvent(r))); this.applyCorrection() }; k.onControllerEnd = function () { this.handles.removeAll() }; k.stepController = function () { }; k.handleElevationChangeEvent = function (r) {
            m.eyeWithinExtent(this.view,
              this.desiredCamera, r.extent, r.spatialReference) && this.applyCorrection()
          }; k.applyCorrection = function () { this.view.state.updateCamera(r => { r.copyViewFrom(this.desiredCamera); t.applySurfaceCollisionConstraint(this.view, r, 1) || this.constraintEnabled || (this.state = e.State.Stopped) }) }; w._createClass(x, [{ key: "desiredCamera", set: function (r) { this._set("desiredCamera", r.clone()) } }, { key: "canStop", get: function () { return !0 } }, { key: "constraintEnabled", get: function () { return this.view.state.constraints.collision.enabled } }]);
          return x
        }(e.CameraController); c.__decorate([u.property({ constructOnly: !0 })], a.SurfaceCollisionCorrectionController.prototype, "view", void 0); c.__decorate([u.property({ constructOnly: !0 })], a.SurfaceCollisionCorrectionController.prototype, "desiredCamera", null); a.SurfaceCollisionCorrectionController = c.__decorate([l.subclass("esri.views.3d.state.controllers.SurfaceCollisionCorrectionController")], a.SurfaceCollisionCorrectionController); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/viewpointUtils": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../Camera ../../../geometry ../../../Graphic ../../../Viewpoint ../../../core/asyncUtils ../../../core/has ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../chunks/mat3 ../../../chunks/mat3f64 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ../../../geometry/support/frustum ../../../geometry/support/webMercatorUtils ../camera/intersectionUtils ./cameraUtils ./ElevationProvider ./mathUtils ../../../geometry/Point ../../../geometry/SpatialReference ../../../geometry/Extent ../../../geometry/Geometry".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          function M(pa) { return 360 - C.cyclicalDeg.normalize(pa) } function F(pa) { return C.cyclicalDeg.normalize(360 - pa) } function K(pa) { h.isSome(pa) && pa.resolver && pa.resolver.reject(); return null } function P(pa, wa, Ia, Ha = null) {
            if (!wa) return K(Ha); var Oa = pa.spatialReference || E.WGS84; if (h.isSome(wa.camera)) {
              pa = r.project(wa.camera.position, Oa); if (h.isNone(pa)) return K(Ha); wa = wa.camera.clone(); wa.position = pa; pa = wa; h.isSome(Ha) && Ha.resolver && Ha.resolver.resolve(pa);
              return pa
            } if (h.isNone(wa.targetGeometry)) return K(Ha); var Ba = wa.get("targetGeometry.spatialReference"); if (Ba && !r.canProject(Ba, Oa)) return K(Ha); Oa = z.internalToExternal(pa, pa.state.camera); Ba = 1; null != wa.rotation && (Oa.heading = M(wa.rotation), Ba = 0); null != Ia && (Oa.tilt = Ia); if ("point" === wa.targetGeometry.type) { const sa = wa.targetGeometry; Ia = wa.targetGeometry.clone(); wa = null != wa.scale ? z.scaleToDistance(pa, wa.scale, sa.latitude) : pa.state.camera.distance; return z.fromCenterDistance(pa, Ia, wa, Oa, Ba, Ha) } return z.fromExtent(pa,
              wa.targetGeometry.extent, Oa.heading, Oa.tilt, Ba, Ha)
          } function L() {
            L = w._asyncToGenerator(function* (pa, wa, Ia) {
              if (wa && pa.spatialReference) { var Ha = { target: null }; if ("declaredClass" in wa || Array.isArray(wa)) Ha.target = wa; else { for (var Oa in wa) Ha[Oa] = wa[Oa]; wa.center && !Ha.target && (Ha.target = wa.center) } wa = Ha } else wa = null; if (!wa) throw new l("viewpointutils-create:no-target", "Missing target for creating viewpoint"); Ha = new c({ fov: pa.camera.fov }); Oa = new y({ camera: Ha }); if (wa.target instanceof y) return pa = yield da(pa,
                wa.target, wa, Ia, Oa), Z(pa); if (wa.target instanceof c) return Z(fa(pa, wa.target, Oa)); var Ba = null != wa.scale || null != wa.zoom; if (wa.target instanceof H) { var sa = wa.target.xmin === wa.target.xmax || wa.target.ymin === wa.target.ymax; return Ba || sa ? Z(yield ha(pa, wa, wa.target.center, Ha, Ia, Oa)) : Z(yield aa(pa, wa, wa.target, Ha, Ia, Oa)) } sa = { boundingBox: g.empty(), hasZ: !1, screenSpaceObjects: [] }; var Ca = Ba ? z.scaleToResolution(pa, N(pa, wa)) : void 0; yield Q(pa, wa.target, Ca, sa); if (isFinite(sa.boundingBox[0])) {
                  g.center(sa.boundingBox,
                    ia); Na.x = ia[0]; Na.y = ia[1]; Na.z = ia[2]; Na.spatialReference = pa.spatialReference; isFinite(Na.z) && sa.hasZ ? Ca = g.isPoint(sa.boundingBox) : (Na.z = void 0, Ca = x.isPoint(g.toRect(sa.boundingBox, Aa))); if (Ba || Ca) return Z(yield ha(pa, wa, Na, Ha, Ia, Oa)); Ba = sa.screenSpaceObjects; if (Ba.length) { Ca = Number.NEGATIVE_INFINITY; for (let Ja = 0; Ja < Ba.length; Ja++) { const ca = Ba[Ja].screenSpaceBoundingRect; Ca = Math.max(Ca, Math.abs(ca[0]), Math.abs(ca[1]), Math.abs(ca[2]), Math.abs(ca[3])) } Ba = .66 - Ca / Math.min(pa.width, pa.height) * 2 } else Ba =
                      .66; return Z(yield U(pa, wa, Na, sa.boundingBox, Ba, Ha, Ia, Oa))
                } return wa.position ? (Ia = A.cameraOnContentAlongViewDirection(pa), v.copy(za, Ia.viewForward), z.directionToHeadingTilt(pa, Ia.eye, za, Ia.up, Ua), Ha.position = new D(wa.position), Ha.heading = null != wa.heading ? wa.heading : Ua.heading, Ha.tilt = null != wa.tilt ? wa.tilt : Ua.tilt, pa = I(pa, null, Ha, Oa), Z(pa)) : Z(yield ea(pa, wa, Ha, Ia, Oa))
            }); return L.apply(this, arguments)
          } function N(pa, wa) { return null == wa.scale && null != wa.zoom ? z.zoomToScale(pa, wa.zoom) : wa.scale } function G(pa,
            wa) { let Ia = !1; null != wa.heading ? (pa.heading = wa.heading, Ia = !0) : null != wa.rotation && (pa.heading = M(wa.rotation), Ia = !0); null != wa.tilt && (pa.tilt = wa.tilt, Ia = !0); null != wa.fov && (pa.fov = wa.fov); return Ia } function I(pa, wa, Ia, Ha) { const Oa = pa.spatialReference || E.WGS84; wa = h.isSome(wa) ? wa : z.externalToInternal(pa, Ia); if (h.isNone(wa)) return Ha; Ha.targetGeometry = e.projectVectorToPoint(wa.center, pa.renderSpatialReference, Oa); Ha.scale = z.computeScale(pa, wa); Ha.rotation = F(Ia.heading); Ha.camera = Ia; return Ha } function O(pa,
              wa, Ia) {
                if (wa) {
                  if (!r.canProject(wa.spatialReference, pa.spatialReference)) throw new l("viewpointutils:incompatible-spatialreference", `Spatial reference (${wa.spatialReference ? wa.spatialReference.wkid : "unknown"}) is incompatible with the view (${pa.spatialReference.wkid})`, { geometry: wa }); var Ha = []; if (!wa.hasZ && pa.basemapTerrain) {
                    switch (wa.type) {
                      case "point": var Oa = wa; break; case "multipoint": case "polyline": Oa = wa.extent.center; break; case "mesh": Oa = wa.origin; break; case "extent": Oa = wa.center; break; case "polygon": Oa =
                        wa.centroid
                    }Oa && r.canProject(Oa, pa.basemapTerrain.spatialReference) ? ia[2] = h.unwrapOr(B.getElevationAtPoint(pa.elevationProvider, Oa), 0) : ia[2] = 0
                  } (0, ya[wa.type])(wa, sa => { Ha.push(sa[0], sa[1], sa[2]) }, ia); var Ba = Ha.length / 3; if (0 !== Ba && (Oa = Array(Ha.length), e.projectBuffer(Ha, wa.spatialReference, 0, Oa, pa.spatialReference, 0, Ba))) for (wa.hasZ && (Ia.hasZ = !0), pa = 0; pa < Oa.length; pa += 3)wa.hasZ ? (ia[0] = Oa[pa + 0], ia[1] = Oa[pa + 1], ia[2] = Oa[pa + 2]) : (ia[0] = Oa[pa + 0], ia[1] = Oa[pa + 1]), g.expandWithVec3(Ia.boundingBox, ia)
                }
          } function R(pa,
            wa, Ia, Ha) { return S.apply(this, arguments) } function S() {
              S = w._asyncToGenerator(function* (pa, wa, Ia, Ha) {
                const Oa = yield n.result(pa.whenViewForGraphic(wa)); if (!1 !== Oa.ok && !h.isNone(Oa.value) && "whenGraphicBounds" in Oa.value) if (Ia = yield n.result(Oa.value.whenGraphicBounds(wa, { minDemResolution: Ia })), !1 === Ia.ok) O(pa, wa.geometry, Ha); else { var { screenSpaceObjects: Ba, boundingBox: sa } = Ia.value; g.expandWithAABB(Ha.boundingBox, sa); Ba && Ba.forEach(Ca => { Ha.screenSpaceObjects.push(Ca) }); isFinite(sa[2]) && (Ha.hasZ = !0) } else O(pa,
                  wa.geometry, Ha)
              }); return S.apply(this, arguments)
            } function Q(pa, wa, Ia, Ha) { return T.apply(this, arguments) } function T() {
              T = w._asyncToGenerator(function* (pa, wa, Ia, Ha) {
                if (Array.isArray(wa) && 2 === wa.length) { const Oa = wa[0], Ba = wa[1]; if ("number" === typeof Oa && "number" === typeof Ba) { Na.x = Oa; Na.y = Ba; Na.z = void 0; Na.spatialReference = pa.spatialReference.isGeographic ? pa.spatialReference : E.WGS84; O(pa, Na, Ha); return } } wa && "function" === typeof wa.map ? yield b.eachAlways(wa.map(Oa => Q(pa, Oa, Ia, Ha))) : wa instanceof J ? O(pa, wa,
                  Ha) : wa instanceof u && (yield R(pa, wa, Ia, Ha))
              }); return T.apply(this, arguments)
            } function da(pa, wa, Ia, Ha, Oa) { return Y.apply(this, arguments) } function Y() {
              Y = w._asyncToGenerator(function* (pa, wa, Ia, Ha, Oa) {
                if (h.isSome(wa.camera)) return fa(pa, wa.camera, Oa); Oa.scale = wa.scale; Oa.rotation = wa.rotation; Oa.targetGeometry = h.isSome(wa.targetGeometry) ? wa.targetGeometry.clone() : null; Oa.camera = null; null != Ia.heading ? Oa.rotation = F(Ia.heading) : null != Ia.rotation && (Oa.rotation = Ia.rotation); wa = N(pa, Ia); null != wa && (Oa.scale =
                  wa); Ha = new z.AsyncContext(Ha); P(pa, Oa, Ia.tilt, Ha); Oa.camera = yield Ha.resolver.promise; return Oa
              }); return Y.apply(this, arguments)
            } function fa(pa, wa, Ia) { const Ha = r.project(wa.position, pa.spatialReference); if (h.isNone(Ha)) return null; wa = wa.clone(); wa.fov = pa.camera.fov; wa.position = Ha; return I(pa, null, wa, Ia) } function ha(pa, wa, Ia, Ha, Oa, Ba) { return ka.apply(this, arguments) } function ka() {
              ka = w._asyncToGenerator(function* (pa, wa, Ia, Ha, Oa, Ba) {
                if (h.isNone(Ia)) throw new l("createfromcenter", "invalid point"); Ba.targetGeometry =
                  Ia.clone(); const sa = A.cameraOnContentAlongViewDirection(pa); if (wa.position) return Ia = Ba.targetGeometry, Oa = pa.renderSpatialReference, e.projectPointToVector(wa.position, Ka, Oa), e.projectPointToVector(Ia, Ea, Oa), Ba.targetGeometry = new D(Ia), Ha.position = new D(wa.position), v.subtract(za, Ea, Ka), z.directionToHeadingTilt(pa, Ka, za, sa.up, Ha), Ba.scale = z.distanceToScale(pa, v.distance(Ka, Ea), Ba.targetGeometry.latitude), Ba.rotation = F(Ha.heading), Ba.camera = Ha, Ba; if (wa.zoomFactor) {
                    var Ca = sa.distance / wa.zoomFactor; const Ja =
                      v.scale(ia, sa.viewForward, -Ca); sa.eye = v.add(ia, sa.center, Ja); Ba.scale = z.distanceToScale(pa, Ca, Ia.latitude)
                  } z.internalToExternal(pa, sa, Ha); Ca = G(Ha, wa) ? 0 : 1; wa.zoomFactor || (Ba.scale = N(pa, wa), null == Ba.scale && (e.projectPointToVector(Ia, ia, pa.renderSpatialReference), k.intersectsPoint(sa.frustum, ia) ? Ba.scale = z.distanceToScale(pa, v.distance(sa.eye, ia), Ia.latitude) : Ba.scale = z.computeScale(pa, sa)), wa = new z.AsyncContext(Oa), z.fromCenterScale(pa, Ba.targetGeometry, Ba.scale, Ha, Ca, wa), Ba.camera = yield wa.resolver.promise);
                return Ba
              }); return ka.apply(this, arguments)
            } function ea(pa, wa, Ia, Ha, Oa) { return ba.apply(this, arguments) } function ba() { ba = w._asyncToGenerator(function* (pa, wa, Ia, Ha, Oa) { var Ba = A.cameraOnContentAlongViewDirection(pa); Ba = e.projectVectorToPoint(Ba.center, pa.renderSpatialReference, pa.spatialReference); return ha(pa, wa, Ba, Ia, Ha, Oa) }); return ba.apply(this, arguments) } function aa(pa, wa, Ia, Ha, Oa, Ba) { return W.apply(this, arguments) } function W() {
              W = w._asyncToGenerator(function* (pa, wa, Ia, Ha, Oa, Ba) {
              Ba.targetGeometry =
                Ia.clone(); const sa = A.cameraOnContentAlongViewDirection(pa); z.internalToExternal(pa, sa, Ha); wa = G(Ha, wa) ? 0 : 1; Oa = new z.AsyncContext(Oa); z.fromExtent(pa, Ia, Ha.heading, Ha.tilt, wa, Oa); Ba.camera = yield Oa.resolver.promise; return Ba
              }); return W.apply(this, arguments)
            } function U(pa, wa, Ia, Ha, Oa, Ba, sa, Ca) { return X.apply(this, arguments) } function X() {
              X = w._asyncToGenerator(function* (pa, wa, Ia, Ha, Oa, Ba, sa, Ca) {
              Ca.targetGeometry = Ia.clone(); const Ja = A.cameraOnContentAlongViewDirection(pa); var ca = 0; Ia.hasZ ? ca = Ia.z : pa.basemapTerrain &&
                (ca = h.unwrap(B.getElevationAtPoint(pa.elevationProvider, Ia))); v.set(ia, Ia.x, Ia.y, ca); e.computeTranslationToOriginAndRotation(pa.spatialReference, ia, la, pa.renderSpatialReference); d.fromMat4(ma, la); d.transpose(ma, ma); g.empty(ra); Ia = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]]; for (var qa = 0; qa < Ia.length; qa++) {
                  const Da = Ia[qa]; let na = Ha[Da[2]]; isFinite(na) || (na = ca); v.set(ia, Ha[Da[0]], Ha[Da[1]], na); e.projectVectorToVector(ia, pa.spatialReference, ia, pa.renderSpatialReference); g.expandWithVec3(ra,
                    v.transformMat3(ia, ia, ma))
                } Ha = g.width(ra); ca = g.height(ra); Ia = g.depth(ra); qa = 1 / Math.tan(Ja.fovY / 2); Oa = Math.max(.5 * Math.sqrt(Ha * Ha + Ia * Ia) * Math.max(qa, 1 / Math.tan(Ja.fovX / 2)) + .5 * ca, .5 * ca * qa + .5 * Math.max(Ha, Ia)) / Oa; z.internalToExternal(pa, Ja, Ba); wa = G(Ba, wa) ? 0 : 1; Ca.scale = z.distanceToScale(pa, Oa, Ca.targetGeometry.latitude); sa = new z.AsyncContext(sa); z.fromCenterScale(pa, Ca.targetGeometry, Ca.scale, Ba, wa, sa); Ca.camera = yield sa.resolver.promise; return Ca
              }); return X.apply(this, arguments)
            } function Z(pa) {
            pa && h.isSome(pa.camera) &&
              (pa.rotation = F(pa.camera.heading)); return pa
            } const ia = m.create(), la = t.create(), ma = f.create(), ra = g.create(), Aa = x.create(), za = m.create(), Ka = m.create(), Ea = m.create(), Ua = { heading: 0, tilt: 0 }, Na = new D, ya = {
              point(pa, wa, Ia) { Ia[0] = pa.x; Ia[1] = pa.y; pa.hasZ && (Ia[2] = pa.z); wa(Ia) }, polygon(pa, wa, Ia) { const Ha = pa.hasZ; for (let Oa = 0; Oa < pa.rings.length; Oa++) { const Ba = pa.rings[Oa]; for (let sa = 0; sa < Ba.length; sa++)Ia[0] = Ba[sa][0], Ia[1] = Ba[sa][1], Ha && (Ia[2] = Ba[sa][2]), wa(Ia) } }, polyline(pa, wa, Ia) {
                const Ha = pa.hasZ; for (let Oa =
                  0; Oa < pa.paths.length; Oa++) { const Ba = pa.paths[Oa]; for (let sa = 0; sa < Ba.length; sa++)Ia[0] = Ba[sa][0], Ia[1] = Ba[sa][1], Ha && (Ia[2] = Ba[sa][2]), wa(Ia) }
              }, multipoint(pa, wa, Ia) { const Ha = pa.points; pa = pa.hasZ; for (let Oa = 0; Oa < Ha.length; Oa++)Ia[0] = Ha[Oa][0], Ia[1] = Ha[Oa][1], pa && (Ia[2] = Ha[Oa][2]), wa(Ia) }, extent(pa, wa, Ia) {
                pa.hasZ ? (wa(v.set(Ia, pa.xmin, pa.ymin, pa.zmin)), wa(v.set(Ia, pa.xmax, pa.ymin, pa.zmin)), wa(v.set(Ia, pa.xmin, pa.ymax, pa.zmin)), wa(v.set(Ia, pa.xmax, pa.ymax, pa.zmin)), wa(v.set(Ia, pa.xmin, pa.ymin, pa.zmax)),
                  wa(v.set(Ia, pa.xmax, pa.ymin, pa.zmax)), wa(v.set(Ia, pa.xmin, pa.ymax, pa.zmax)), wa(v.set(Ia, pa.xmax, pa.ymax, pa.zmax))) : (wa(v.set(Ia, pa.xmin, pa.ymin, Ia[2])), wa(v.set(Ia, pa.xmax, pa.ymin, Ia[2])), wa(v.set(Ia, pa.xmin, pa.ymax, Ia[2])), wa(v.set(Ia, pa.xmax, pa.ymax, Ia[2])))
              }, mesh(pa, wa, Ia) { if (pa = pa.vertexAttributes && pa.vertexAttributes.position) for (let Ha = 0; Ha < pa.length; Ha += 3)wa(v.set(Ia, pa[Ha + 0], pa[Ha + 1], pa[Ha + 2])) }
            }; a.create = function (pa, wa, Ia) { return L.apply(this, arguments) }; a.fromCamera = function (pa, wa, Ia = null) {
              h.isNone(Ia) &&
              (Ia = new y); return I(pa, null, wa.clone(), Ia)
            }; a.headingToRotation = F; a.rotationToHeading = M; a.toCamera = P; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/state/helpers/SceneIntersectionHelper": function () {
      define("exports ../../../../core/maybe ../../../../core/PooledArray ../../../../core/screenUtils ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/ray ../../../../geometry/support/vectorStacks ../../support/geometryUtils/ray ../../webgl-engine/lib/Intersector ../../webgl-engine/lib/intersectorUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(g) { t && t.viewingMode === g || (t = h.newIntersector(g)); return t } let f = function () {
            function g(k, r, A) { this.viewingMode = k; this._forEachLayer = r; this.view = A; this.externalIntersectionHandlers = new c; this.tolerance = h.DEFAULT_TOLERANCE; this.tmpRay = n.create(); this.validateHUDIntersector = h.newIntersector(this.viewingMode); this.validateHUDIntersector.options.hud = !1 } var x = g.prototype; x.intersectScreen = function (k, r) {
              return this.intersectRay(this._getPickRay(k, this.tmpRay), d(this.viewingMode),
                r)
            }; x.intersectScreenFreePointFallback = function (k, r) { return this.intersectRayFreePointFallback(this._getPickRay(k, this.tmpRay), r) }; x.intersectRayFreePointFallback = function (k, r) { return this.intersectRay(k, d(this.viewingMode), r) || this._intersectRayFreePointLocal(k, r) }; x.intersectRay = function (k, r, A, z) { r.options.selectionMode = !1; r.options.store = 0; this.computeIntersection(k, r, z); return r.results.min ? r.results.min.getIntersectionPoint(A) : !1 }; x.getCenterRayWithSubpixelOffset = function (k, r, A = .5, z = .5) {
              k.getRenderCenter(e,
                A, z); e[0] += .0466; e[1] -= .0123; return l.fromRenderAtEye(k, e, r)
            }; x.intersectIntersectorScreen = function (k, r, A) { this.computeIntersection(this._getPickRay(k, this.tmpRay), r, A) }; x.intersectToolIntersectorScreen = function (k, r, A) { k = this._getPickRay(k, this.tmpRay); this.intersectToolIntersectorRay(k, r, A) }; x.intersectToolIntersectorRay = function (k, r, A) {
              r.options.selectionMode = !0; this.computeIntersection(k, r, A); const z = r.results.min; this.view.basemapTerrain && this.view.basemapTerrain.opaque || b.isValidIntersectorResult(z) &&
                2 !== z.intersector || (r.options.selectionMode = !1, this.computeIntersection(k, r, A))
            }; x.setTolerance = function (k = h.DEFAULT_TOLERANCE) { this.tolerance = k }; x.addIntersectionHandler = function (k) { this.externalIntersectionHandlers.push(k); this.externalIntersectionHandlers.sort((r, A) => 2 === r.type ? 1 : 2 === A.type ? -1 : 0) }; x.removeIntersectionHandler = function (k) { this.externalIntersectionHandlers.removeUnordered(k); this.externalIntersectionHandlers.sort((r, A) => 2 === r.type ? 1 : 2 === A.type ? -1 : 0) }; x._getPickRay = function (k, r) {
              return l.fromScreen(this.view.state.camera,
                k, r)
            }; x._intersectRayFreePointLocal = function (k, r) {
              if (2 !== this.viewingMode || w.isNone(k)) return !1; var A = this.view.renderDataExtent; if (w.isNone(A)) return u.add(r, k.origin, u.normalize(p.sv3d.get(), k.direction)), !0; var z = Math.max(A.xmax - A.xmin, A.ymax - A.ymin, 8 * Math.max(A.xmax - A.xmin, A.ymax - A.ymin)); if (0 === z) return u.add(r, k.origin, u.normalize(p.sv3d.get(), k.direction)), !0; var B = this.view.state.camera; const C = Math.max(0, A.xmin - B.eye[0], B.eye[0] - A.xmax); A = Math.max(0, A.ymin - B.eye[1], B.eye[1] - A.ymax); B = z / Math.max(1,
                Math.max(0, Math.log(z / (Math.abs(B.relativeElevation) + Number.MIN_VALUE))) ** 2); B = Math.max(B, Math.min(Math.sqrt(C * C + A * A), z)); z = u.scale(p.sv3d.get(), k.direction, B / u.length(k.direction)); u.add(r, k.origin, z); return !0
            }; x.intersectElevationFromScreen = function (k, r, A = 0, z = null) { return this.intersectElevation(this._getPickRay(k, this.tmpRay), r, A, z) }; x.intersectElevation = function (k, r, A = 0, z = null) {
              if (w.isNone(k)) return null; var B = w.isSome(r) ? r.mode : "absolute-height", C = w.isSome(r) ? w.unwrapOr(r.offset, 0) : 0, D = "on-the-ground" !==
                B ? C + A : 0; r = D / this.view.renderCoordsHelper.unitInMeters; if ("absolute-height" === B) return this.view.renderCoordsHelper.intersectInfiniteManifold(k, D, m) ? (A = this.view.computeMapPointFromVec3d(m), A.z -= C, A) : null; C = this.view.state.camera; const E = q.castRenderScreenPointArray3(p.sv3d.get()); C.projectToRenderScreen(k.origin, E); D = new v(null, this._forEachLayer); const H =this.view.cutPolygon || this.view.slicePlane, J = w.isSome(H) ? b.sliceFilterPredicate(H) : null, M = h.newIntersector(this.viewingMode); M.options.store = 0; M.options.verticalOffset =
                  r; r = k.origin; k = u.add(p.sv3d.get(), r, k.direction); M.reset(r, k, C); M.point = E; const F = w.isSome(z) ? "type" in z && "graphics" === z.type ? K => K.metadata.layerUid !== z.uid : K => K.metadata.graphicUid !== z.uid : null; switch (B) {
                    case "relative-to-scene": M.intersect(D.layers, E, this.tolerance, null, K => (w.isNone(F) || F(K)) && K.metadata && K.metadata.isElevationSource); this.externalIntersectionHandlers.forAll(K => { 4 !== K.type && 2 !== K.type || K.intersect(M, K.slicePlaneEnabled ? J : null, M.rayBegin, M.rayEnd, E) }); break; case "on-the-ground": case "relative-to-ground": this.externalIntersectionHandlers.forAll(K => { K.isGround && K.intersect(M, K.slicePlaneEnabled ? J : null, M.rayBegin, M.rayEnd, E) })
                  }return M.results.min.getIntersectionPoint(m) ? (B = this.view.computeMapPointFromVec3d(m), B.z = A, B) : null
            }; x.computeIntersection = function (k, r, A) {
              if (!w.isNone(k)) {
                var z = this.view.state.camera,
                 B = q.castRenderScreenPointArray3(p.sv3d.get()); z.projectToRenderScreen(k.origin, B); var C = new v(A, this._forEachLayer); r.options.selectOpaqueTerrainOnly = !A || !("include" in A || "exclude" in A); var D = k.origin, E = u.add(p.sv3d.get(), k.origin, k.direction);
                r.reset(D, E, z); r.intersect(C.layers, B, this.tolerance); k = this.view.cutPolygon || this.view.slicePlane; var H = w.isSome(k) ? b.sliceFilterPredicate(k) : null; r.intersect(C.sliceableLayers, B, this.tolerance, H); var J = A && (A.requiresGroundFeedback || A.enableDraped); this.externalIntersectionHandlers.forAll(M => { r.options.isFiltered = !C.filterLayerUid(M.layerUid); (M.isGround && J || !r.options.isFiltered) && M.intersect(r, M.slicePlaneEnabled ? H : null, D, E, B) }); k = p.sv3d.get(); if (A && A.enableDraped && r.results.ground.getIntersectionPoint(k)) {
                  A = this.view.basemapTerrain.overlayManager.renderer;
                  const M = this.view.renderCoordsHelper.spatialReference, F = p.sv3d.get(); this.view.renderCoordsHelper.fromRenderCoords(k, F, this.view.spatialReference); F[2] = w.unwrapOr(this.view.elevationProvider.getElevation(k[0], k[1], k[2], M, "ground"), 0); A.intersect(r, F, r.results.ground, K => C.filterRenderGeometry(K))
                } r.sortResults(); k = r.results.hud; if (b.isHudIntersectorResult(k)) {
                  const M = q.castRenderScreenPointArray3(p.sv3d.get()), F = p.sv3d.get(), K = p.sv3d.get(); this.unprojectHUDResultRay(k.target.center, M, F, K); A = u.distance(k.target.center,
                    F) / u.distance(F, K) * .99; this.validateHUDIntersector.reset(F, K, z); this.validateHUDIntersector.intersect(C.layers, M, this.tolerance); this.validateHUDIntersector.intersect(C.sliceableLayers, M, this.tolerance, H); this.externalIntersectionHandlers.forAll(P => { C.filterLayerUid(P.layerUid) && P.intersect(this.validateHUDIntersector, P.slicePlaneEnabled ? H : null, F, K, M) }); z = this.validateHUDIntersector.results.min; if (null == z.dist || A <= z.dist) r.results.min.copy(k), r.results.all.splice(0, 0, k)
                }
              }////
            }; x.unprojectHUDResultRay =
              function (k, r, A, z) { const B = this.view.state.camera; B.projectToRenderScreen(k, r); k = q.castRenderScreenPointArray3(p.sv3d.get()); k[0] = r[0]; k[1] = r[1]; k[2] = 0; B.unprojectFromRenderScreen(k, A); k[2] = 1; B.unprojectFromRenderScreen(k, z) }; return g
          }(), t, v = function () {
            function g(k, r) { this.layers = []; this.sliceableLayers = []; this.include = null == k ? void 0 : k.include; this.exclude = null == k ? void 0 : k.exclude; r(A => { A.isPickable && this.filterLayerUid(A.apiLayerUid) && (A.isSliceable ? this.sliceableLayers : this.layers).push(A) }) } var x =
              g.prototype; x.filterLayerUid = function (k) { const { include: r, exclude: A } = this; return w.isNone(k) ? null == r && null == A : (null == r || r.has(k)) && (null == A || !A.has(k)) }; x.filterRenderGeometry = function (k) { return this.filterLayerUid(k.layerUid) }; return g
          }(); const m = y.create(), e = q.createRenderScreenPointArray3(); a.SceneIntersectionHelper = f; a.isIntersectionHandler = function (g) { return "object" === typeof g && "intersect" in g }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/CombinedElevationProvider": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Evented ../../../core/maybe ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../layers/graphics/ElevationQuery".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(v, m, e, g, x, k, r) { for (const A of m) m = A.getElevation(e, g, x, k, r), y.isSome(m) && (v = y.isSome(v) ? Math.max(m, v) : m); return v } a.CombinedElevationProvider = function (v) {
            function m(g) { g = v.call(this, g) || this; g.im = []; g.ground = []; g.scene = []; g.handles = new Map; g.lastElevationQuery = null; g.elevationCacheEnabled = !1; return g } w._inheritsLoose(m, v); var e = m.prototype; e.destroy = function () { this._elevationQuery = y.destroyMaybe(this._elevationQuery) }; e.enableElevationCache = function (g) {
              g ||
              (this.lastElevationQuery = null); this.elevationCacheEnabled = g
            }; e.getElevation = function (g, x, k, r, A) {
              if (this.elevationCacheEnabled && null != this.lastElevationQuery) { var z = this.lastElevationQuery; if (g === z.x && x === z.y && k === z.z && r.equals(z.spatialReference) && A === z.queryContext) return z.result } z = t(null, this.im, g, x, k, r, A); y.isNone(z) && (z = t(z, this.ground, g, x, k, r, A)); "scene" === A && (z = t(z, this.scene, g, x, k, r, A)); this.elevationCacheEnabled && (this.lastElevationQuery = { x: g, y: x, z: k, spatialReference: r, queryContext: A, result: z });
              return z
            }; e.queryElevation = function (g, x, k, r, A, z = null, B = 0) { const C = n.createResolver(); this.elevationQuery.queryElevation(g, x, z, B).then(D => { "scene" === A && (D = t(D, this.scene, g, x, k, r, A)); C.resolve(D) }).catch(D => { n.isAbortError(D) ? C.reject(D) : C.resolve(this.getElevation(g, x, k, r, A)) }); return C.promise }; e.register = function (g, x) { this.handles.set(x, x.on("elevation-change", k => this.emit("elevation-change", k))); this[g].push(x) }; e.unregister = function (g) {
              this.handles.has(g) && (this.handles.get(g).remove(), this.handles.delete(g));
              for (const x of [this.im, this.ground, this.scene]) { const k = x.indexOf(g); -1 < k && x.splice(k, 1) }
            }; w._createClass(m, [{ key: "elevationQuery", get: function () { y.isNone(this._elevationQuery) && (this._elevationQuery = new f.ElevationQuery(this.view.resourceController.scheduler, this.view.spatialReference, () => this.view.map && this.view.map.ground, { maximumAutoTileRequests: 4 })); return this._elevationQuery } }]); return m
          }(u.EventedMixin(q)); c.__decorate([p.property({ constructOnly: !0 })], a.CombinedElevationProvider.prototype,
            "view", void 0); c.__decorate([p.property({ readOnly: !0, aliasOf: "view.basemapTerrain.spatialReference" })], a.CombinedElevationProvider.prototype, "spatialReference", void 0); a.CombinedElevationProvider = c.__decorate([d.subclass("esri.views.3d.support.CombinedElevationProvider")], a.CombinedElevationProvider); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/ElevationQuery": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../geometry ../../../../core/arrayUtils ../../../../core/maybe ../../../../core/promiseUtils ../../../support/Scheduler ../../../../geometry/Multipoint".split(" "),
        function (a, w, c, q, u, y, n, p) {
          c = function () { function h(d, f) { this.spatialReference = d; this.view = f } var b = h.prototype; b.getElevation = function (d, f, t) { return this.view.elevationProvider.getElevation(d, f, 0, this.spatialReference, t) }; b.queryElevation = function () { var d = w._asyncToGenerator(function* (f, t, v, m, e) { return this.view.elevationProvider.queryElevation(f, t, 0, this.spatialReference, e, v, m) }); return function (f, t, v, m, e) { return d.apply(this, arguments) } }(); return h }(); let l = function () {
            function h(d, f, t, v) {
            this.spatialReference =
              f; this._getElevationQueryProvider = t; this._queries = []; this._queryOptions = { ...v, ignoreInvisibleLayers: !0 }; this._frameTask = d.registerTask(n.TaskPriority.ELEVATION_QUERY, this)
            } var b = h.prototype; b.destroy = function () { this._frameTask.remove() }; b.queryElevation = function (d, f, t, v = 0) { return new Promise((m, e) => { const g = { x: d, y: f, minDemResolution: v, result: { resolve: m, reject: e }, signal: t }; this._queries.push(g); y.onAbort(t, () => { q.remove(this._queries, g); e(y.createAbortError()) }) }) }; b.runTask = function () {
              const d = this._queries;
              this._queries = []; const f = this._getElevationQueryProvider(); if (f) {
                var t = d.map(g => [g.x, g.y]), v = d.reduce((g, x) => Math.min(g, x.minDemResolution), Infinity); t = new p({ points: t, spatialReference: this.spatialReference }); var m = 1 < d.length && d.some(g => !!g.signal) ? new AbortController : null, e = u.isSome(m) ? m.signal : d[0].signal; if (u.isSome(m)) { let g = 0; d.forEach(x => y.onAbort(x.signal, () => { g++; x.result.reject(y.createAbortError()); g === d.length && m.abort() })) } f.queryElevation(t, { ...this._queryOptions, minDemResolution: v, signal: e }).then(g => { d.forEach((x, k) => { u.isSome(x.signal) && x.signal.aborted ? x.result.reject(y.createAbortError()) : x.result.resolve(g.geometry.points[k][2]) }) }).catch(g => { d.forEach(x => x.result.reject(g)) })
              } else d.forEach(g => g.result.reject())
            }; w._createClass(h, [{ key: "running", get: function () { return 0 < this._queries.length } }, { key: "test", get: function () { const d = this; return { update: () => 0 < d._queries.length && d.runTask() } } }]); return h
          }(); a.ElevationQuery = l; a.ViewElevationProvider = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/support/DisplayQualityProfile": function () {
      define(["../../../core/has"], function (a) {
        function w() {
          const q = !!a("esri-mobile"), u = !!a("ios"); return {
            low: {
              graphics3D: { maxTotalNumberOfFeatures: 25E3, maxTotalNumberOfPrimitives: 85E4, polygonLodFactor: .5, polylineLodFactor: 1, snapshotAvailable: !1 }, sceneService: { "3dObject": { lodFactor: .2, lodCrossfadeinDuration: 0, lodCrossfadeoutDuration: 0, lodCrossfadeUncoveredDuration: 0 }, point: { lodFactor: 1 }, integratedMesh: { lodFactor: .6 }, pointCloud: { lodFactor: .5 }, uncompressedTextureDownsamplingEnabled: !0 },
              tiledSurface: { lodBias: -1, angledSplitBias: .5, reduceTileLevelDifferences: !1, textureFadeDuration: 0 }, antialiasingEnabled: !1, physicalBasedRenderingEnabled: !1, highQualityTransparency: !1, memoryLimit: 200, additionalCacheMemory: 0, frameRate: 0, maximumRenderResolution: null, maximumPixelRatio: 1
            }, medium: {
              graphics3D: { maxTotalNumberOfFeatures: 5E4, maxTotalNumberOfPrimitives: 17E5, polygonLodFactor: q ? .8 : 1, polylineLodFactor: q ? 1.2 : 1.5, snapshotAvailable: !u }, sceneService: {
                "3dObject": {
                  lodFactor: 1, lodCrossfadeinDuration: 0, lodCrossfadeoutDuration: 0,
                  lodCrossfadeUncoveredDuration: 400
                }, point: { lodFactor: 1 }, integratedMesh: { lodFactor: 1 }, pointCloud: { lodFactor: 1 }, uncompressedTextureDownsamplingEnabled: q
              }, tiledSurface: { lodBias: 0, angledSplitBias: 1, reduceTileLevelDifferences: !a("disable-feature:reduce-map-tile-levels"), textureFadeDuration: 400 }, antialiasingEnabled: !0, physicalBasedRenderingEnabled: !0, highQualityTransparency: !0, memoryLimit: q ? 600 : 750, additionalCacheMemory: q ? 0 : 150, frameRate: 0, maximumRenderResolution: null, maximumPixelRatio: 1
            }, high: {
              graphics3D: {
                maxTotalNumberOfFeatures: 5E4,
                maxTotalNumberOfPrimitives: 17E5, polygonLodFactor: q ? 1.2 : 2, polylineLodFactor: q ? 1.2 : 2, snapshotAvailable: !u
              }, sceneService: { "3dObject": { lodFactor: 1, lodCrossfadeinDuration: 0, lodCrossfadeoutDuration: 0, lodCrossfadeUncoveredDuration: 400 }, point: { lodFactor: 1 }, integratedMesh: { lodFactor: 1 }, pointCloud: { lodFactor: 1 }, uncompressedTextureDownsamplingEnabled: !1 }, tiledSurface: { lodBias: 0, angledSplitBias: 1, reduceTileLevelDifferences: !a("disable-feature:reduce-map-tile-levels"), textureFadeDuration: 400 }, antialiasingEnabled: !0,
              physicalBasedRenderingEnabled: !0, highQualityTransparency: !0, memoryLimit: q ? 900 : 1500, additionalCacheMemory: 0, frameRate: 0, maximumRenderResolution: q ? null : 4096, maximumPixelRatio: q ? 1 : null
            }
          }
        } let c = function () {
          function q() { } q.isValidProfile = function (u) { return u in q.profiles }; q.getDefaultProfile = function () { return a("trident") || a("esri-iPhone") ? "low" : "medium" }; q.apply = function (u, y) {
            u = q.profiles[u]; y.graphics3D.maxTotalNumberOfFeatures = u.graphics3D.maxTotalNumberOfFeatures; y.graphics3D.maxTotalNumberOfPrimitives =
              u.graphics3D.maxTotalNumberOfPrimitives; y.graphics3D.polygonLodFactor = u.graphics3D.polygonLodFactor; y.graphics3D.polylineLodFactor = u.graphics3D.polylineLodFactor; y.graphics3D.snapshotAvailable = u.graphics3D.snapshotAvailable; { const n = y.sceneService["3dObject"], p = u.sceneService["3dObject"]; n.lodFactor = p.lodFactor; n.lodCrossfadeinDuration = p.lodCrossfadeinDuration; n.lodCrossfadeoutDuration = p.lodCrossfadeoutDuration; n.lodCrossfadeUncoveredDuration = p.lodCrossfadeUncoveredDuration } y.sceneService.point.lodFactor =
                u.sceneService.point.lodFactor; y.sceneService.integratedMesh.lodFactor = u.sceneService.integratedMesh.lodFactor; y.sceneService.pointCloud.lodFactor = u.sceneService.pointCloud.lodFactor; y.sceneService.uncompressedTextureDownsamplingEnabled = u.sceneService.uncompressedTextureDownsamplingEnabled; y.tiledSurface.lodBias = u.tiledSurface.lodBias; y.tiledSurface.angledSplitBias = u.tiledSurface.angledSplitBias; y.tiledSurface.reduceTileLevelDifferences = u.tiledSurface.reduceTileLevelDifferences; y.tiledSurface.textureFadeDuration =
                  u.tiledSurface.textureFadeDuration; y.antialiasingEnabled = u.antialiasingEnabled; y.physicallyBasedRenderingEnabled = u.physicalBasedRenderingEnabled; y.highQualityTransparency = u.highQualityTransparency; y.memoryLimit = u.memoryLimit; y.additionalCacheMemory = u.additionalCacheMemory; y.frameRate = u.frameRate; y.maximumRenderResolution = u.maximumRenderResolution; y.maximumPixelRatio = u.maximumPixelRatio
          }; return q
        }(); c.debug = { reset() { const q = w(); for (const u in q) c.profiles[u] = q[u] } }; (c || (c = {})).profiles = w(); return c
      })
    },
    "esri/views/3d/support/HighlightOptions": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/Accessor ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec4f32".split(" "), function (a, w, c, q, u, y, n, p, l, h, b) {
        q = function (d) {
          function f() {
            var t = d.apply(this, arguments) || this;
            t.color = new c([0, 255, 255]); t.haloColor = null; t.haloOpacity = 1; t.fillOpacity = .25; t.shadowOpacity = .4; t.shadowColor = new c([0, 0, 0]); t.shadowDifference = .2; return t
          } a._inheritsLoose(f, d); f.toEngineOptions = function (t) {
            const v = c.toUnitRGBA(t.color), m = u.isSome(t.haloColor) ? c.toUnitRGBA(t.haloColor) : v, e = c.toUnitRGBA(t.shadowColor); return {
              color: b.fromValues(v[0], v[1], v[2], v[3]), haloColor: b.fromValues(m[0], m[1], m[2], m[3]), haloOpacity: t.haloOpacity, haloOpacityOccluded: .25 * t.haloOpacity, fillOpacity: t.fillOpacity,
              fillOpacityOccluded: .25 * t.fillOpacity, shadowOpacity: t.shadowOpacity, shadowColor: b.fromValues(e[0], e[1], e[2], e[3]), occludedShadowOpacity: t.shadowOpacity * (1 - t.shadowDifference)
            }
          }; return f
        }(q); w.__decorate([y.property({ type: c })], q.prototype, "color", void 0); w.__decorate([y.property({ type: c })], q.prototype, "haloColor", void 0); w.__decorate([y.property()], q.prototype, "haloOpacity", void 0); w.__decorate([y.property()], q.prototype, "fillOpacity", void 0); w.__decorate([y.property()], q.prototype, "shadowOpacity",
          void 0); w.__decorate([y.property({ type: c })], q.prototype, "shadowColor", void 0); w.__decorate([y.property()], q.prototype, "shadowDifference", void 0); return q = w.__decorate([h.subclass("esri.views.3d.support.HighlightOptions")], q)
      })
    }, "esri/chunks/vec4f32": function () {
      define(["exports"], function (a) {
        function w() { return new Float32Array(4) } function c(x) { const k = new Float32Array(4); k[0] = x[0]; k[1] = x[1]; k[2] = x[2]; k[3] = x[3]; return k } function q(x, k, r, A) { const z = new Float32Array(4); z[0] = x; z[1] = k; z[2] = r; z[3] = A; return z }
        function u(x, k) { return new Float32Array(x, k, 4) } function y() { return w() } function n() { return q(1, 1, 1, 1) } function p() { return q(1, 0, 0, 0) } function l() { return q(0, 1, 0, 0) } function h() { return q(0, 0, 1, 0) } function b() { return q(0, 0, 0, 1) } const d = w(), f = n(), t = p(), v = l(), m = h(), e = b(), g = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, createView: u, zeros: y, ones: n, unitX: p, unitY: l, unitZ: h, unitW: b, ZEROS: d, ONES: f, UNIT_X: t, UNIT_Y: v, UNIT_Z: m, UNIT_W: e }); a.ONES = f; a.UNIT_W = e; a.UNIT_X = t; a.UNIT_Y = v; a.UNIT_Z = m; a.ZEROS =
          d; a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.ones = n; a.unitW = b; a.unitX = p; a.unitY = l; a.unitZ = h; a.vec4f32 = g; a.zeros = y
      })
    }, "esri/views/3d/support/MapCoordsHelper": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../geometry ../../../core/Error ../../../core/unitUtils ../../../geometry/projectionEllipsoid ../../../portal/support/geometryServiceUtils ../../../rest/geometryService/project ../../../rest/support/ProjectParameters ../../../geometry/Point ../../../geometry/SpatialReference".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          c = function () {
            function d(f, t) { this.spatialReference = t; this.unitInMeters = u.getMetersPerUnitForSR(this.spatialReference, y.getReferenceEllipsoid(this.spatialReference).metersPerDegree); this._geometryServiceURLPromise = n.getGeometryServiceURL(f && f.get("portalItem")).catch(() => { throw new q("mapcoordshelper:missing-geometry-service", "Must specify geometryService in esri/config"); }) } d.prototype.toGeographic = function () {
              var f = w._asyncToGenerator(function* (t) {
                var v = yield this._geometryServiceURLPromise;
                let m = !0; Array.isArray(t[0]) && "number" !== typeof t[0] || (t = [t], m = !1); t = t.map(e => e instanceof h ? e : new h(e, this.spatialReference)); t = new l({ geometries: t, outSpatialReference: b.WGS84 }); v = (yield p.project(v, t)).map(e => "point" === e.type ? [e.x, e.y] : void 0); return m ? v : v[0]
              }); return function (t) { return f.apply(this, arguments) }
            }(); return d
          }(); a.MapCoordsHelper = c; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/portal/support/geometryServiceUtils": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../config ../../core/Error ../Portal ../../rest/geometryService/project ../../rest/support/ProjectParameters".split(" "),
        function (a, w, c, q, u, y, n) {
          function p() { return l.apply(this, arguments) } function l() { l = w._asyncToGenerator(function* (b = null, d) { var f, t; if (c.geometryServiceUrl) return c.geometryServiceUrl; if (!b) throw new q("internal:geometry-service-url-not-configured"); b = "portal" in b ? b.portal || u.getDefault() : b; yield b.load({ signal: d }); d = null == (f = b.helperServices) ? void 0 : null == (t = f.geometry) ? void 0 : t.url; if (!d) throw new q("internal:geometry-service-url-not-configured"); return d }); return l.apply(this, arguments) } function h() {
            h =
            w._asyncToGenerator(function* (b, d, f = null, t) { f = yield p(f, t); const v = new n; v.geometries = [b]; v.outSpatialReference = d; if ((b = yield y.project(f, v, { signal: t })) && Array.isArray(b) && 1 === b.length) return b[0]; throw new q("internal:geometry-service-projection-failed"); }); return h.apply(this, arguments)
          } a.getGeometryServiceURL = p; a.projectGeometry = function (b, d) { return h.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/rest/geometryService/project": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../request ../../core/accessorSupport/ensureType ../../geometry/support/jsonUtils ../utils ./utils ../support/ProjectParameters".split(" "),
        function (a, w, c, q, u, y, n, p) { function l() { l = w._asyncToGenerator(function* (b, d, f) { d = h(d); b = y.parseUrl(b); const t = { ...b.query, f: "json", ...d.toJSON() }, v = d.outSpatialReference, m = u.getJsonType(d.geometries[0]); d = y.asValidOptions(t, f); return c(b.path + "/project", d).then(({ data: { geometries: e } }) => n.decodeGeometries(e, m, v)) }); return l.apply(this, arguments) } const h = q.ensureType(p); a.project = function (b, d, f) { return l.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/rest/geometryService/utils": function () {
      define(["exports",
        "../../geometry/support/jsonUtils"], function (a, w) { a.decodeGeometries = function (c, q, u) { const y = w.getGeometryType(q); return c.map(n => { n = y.fromJSON(n); n.spatialReference = u; return n }) }; a.encodeGeometries = function (c) { return { geometryType: w.getJsonType(c[0]), geometries: c.map(q => q.toJSON()) } }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/rest/support/ProjectParameters": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../geometry/support/jsonUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          c = function (h) {
            function b(d) { d = h.call(this, d) || this; d.geometries = null; d.outSpatialReference = null; d.transformation = null; d.transformForward = null; return d } a._inheritsLoose(b, h); b.prototype.toJSON = function () {
              const d = this.geometries.map(function (v) { return v.toJSON() }), f = this.geometries[0], t = {}; t.outSR = this.outSpatialReference.wkid || JSON.stringify(this.outSpatialReference.toJSON()); t.inSR = f.spatialReference.wkid || JSON.stringify(f.spatialReference.toJSON()); t.geometries = JSON.stringify({
                geometryType: l.getJsonType(f),
                geometries: d
              }); this.transformation && (t.transformation = this.transformation.wkid || JSON.stringify(this.transformation)); null != this.transformForward && (t.transformForward = this.transformForward); return t
            }; return b
          }(c.JSONSupport); w.__decorate([q.property()], c.prototype, "geometries", void 0); w.__decorate([q.property({ json: { read: { source: "outSR" } } })], c.prototype, "outSpatialReference", void 0); w.__decorate([q.property()], c.prototype, "transformation", void 0); w.__decorate([q.property()], c.prototype, "transformForward",
            void 0); return c = w.__decorate([p.subclass("esri.rest.support.ProjectParameters")], c)
        })
    }, "esri/views/3d/support/QualitySettings": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p) {
        let l = function (t) {
          function v() {
            var m = t.apply(this,
              arguments) || this; m.minTotalNumberOfFeatures = 2E3; m.maxTotalNumberOfFeatures = 5E4; m.maxTotalNumberOfPrimitives = 17E5; m.snapshotAvailable = !0; m.polygonLodFactor = 1; m.polylineLodFactor = 1; return m
          } a._inheritsLoose(v, t); return v
        }(c); w.__decorate([q.property()], l.prototype, "minTotalNumberOfFeatures", void 0); w.__decorate([q.property()], l.prototype, "maxTotalNumberOfFeatures", void 0); w.__decorate([q.property()], l.prototype, "maxTotalNumberOfPrimitives", void 0); w.__decorate([q.property()], l.prototype, "snapshotAvailable",
          void 0); w.__decorate([q.property()], l.prototype, "polygonLodFactor", void 0); w.__decorate([q.property()], l.prototype, "polylineLodFactor", void 0); l = w.__decorate([p.subclass("esri.views.3d.support.QualitySettings.Graphics3DSettings")], l); let h = function (t) { function v() { var m = t.apply(this, arguments) || this; m.lodFactor = 1; return m } a._inheritsLoose(v, t); return v }(c); w.__decorate([q.property()], h.prototype, "lodFactor", void 0); h = w.__decorate([p.subclass("esri.views.3d.support.QualitySettings.LoDFactorSettings")],
            h); let b = function (t) { function v() { var m = t.apply(this, arguments) || this; m.lodCrossfadeinDuration = 0; m.lodCrossfadeoutDuration = 0; m.lodCrossfadeUncoveredDuration = 0; return m } a._inheritsLoose(v, t); return v }(h); b = w.__decorate([p.subclass("esri.views.3d.support.QualitySettings.LoDFactor3DObjectSettings")], b); let d = function (t) {
              function v() { var m = t.apply(this, arguments) || this; m["3dObject"] = new b; m.point = new h; m.integratedMesh = new h; m.pointCloud = new h; m.uncompressedTextureDownsamplingEnabled = !1; return m } a._inheritsLoose(v,
                t); return v
            }(c); w.__decorate([q.property({ type: b })], d.prototype, "3dObject", void 0); w.__decorate([q.property({ type: h })], d.prototype, "point", void 0); w.__decorate([q.property({ type: h })], d.prototype, "integratedMesh", void 0); w.__decorate([q.property({ type: h })], d.prototype, "pointCloud", void 0); w.__decorate([q.property()], d.prototype, "uncompressedTextureDownsamplingEnabled", void 0); d = w.__decorate([p.subclass("esri.views.3d.support.QualitySettings.SceneServiceSettings")], d); let f = function (t) {
              function v() {
                var m =
                  t.apply(this, arguments) || this; m.lodBias = 0; m.angledSplitBias = 1; m.reduceTileLevelDifferences = !0; m.textureFadeDuration = 500; return m
              } a._inheritsLoose(v, t); return v
            }(c); w.__decorate([q.property()], f.prototype, "lodBias", void 0); w.__decorate([q.property()], f.prototype, "angledSplitBias", void 0); w.__decorate([q.property()], f.prototype, "reduceTileLevelDifferences", void 0); w.__decorate([q.property()], f.prototype, "textureFadeDuration", void 0); f = w.__decorate([p.subclass("esri.views.3d.support.QualitySettings.TiledSurfaceSettings")],
              f); c = function (t) { function v() { var m = t.apply(this, arguments) || this; m.graphics3D = new l; m.sceneService = new d; m.tiledSurface = new f; m.antialiasingEnabled = !0; m.physicallyBasedRenderingEnabled = !1; m.highQualityTransparency = !0; return m } a._inheritsLoose(v, t); return v }(c); w.__decorate([q.property({ type: l })], c.prototype, "graphics3D", void 0); w.__decorate([q.property({ type: d })], c.prototype, "sceneService", void 0); w.__decorate([q.property({ type: f })], c.prototype, "tiledSurface", void 0); w.__decorate([q.property()],
                c.prototype, "antialiasingEnabled", void 0); w.__decorate([q.property()], c.prototype, "physicallyBasedRenderingEnabled", void 0); w.__decorate([q.property()], c.prototype, "highQualityTransparency", void 0); w.__decorate([q.property()], c.prototype, "memoryLimit", void 0); w.__decorate([q.property()], c.prototype, "additionalCacheMemory", void 0); w.__decorate([q.property()], c.prototype, "frameRate", void 0); w.__decorate([q.property()], c.prototype, "maximumRenderResolution", void 0); w.__decorate([q.property()], c.prototype,
                  "maximumPixelRatio", void 0); return c = w.__decorate([p.subclass("esri.views.3d.support.QualitySettings.QualitySettings")], c)
      })
    }, "esri/views/3d/support/RenderCoordsHelper": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../core/unitUtils ../../../chunks/mat4 ../../../chunks/vec3 ../../../geometry/projection ../../../geometry/SpatialReference ../../../geometry/support/coordinateSystem ../../../geometry/support/plane ../../../geometry/support/vectorStacks ../../../layers/graphics/dehydratedFeatureUtils ../../support/spatialReferenceSupport".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(m) { if (f.isSpatialReferenceSupported(m, 1)) return 1; m = l.renderSRFromViewSR(!1, m); return q.getMetersPerUnitForSR(m) } let v = function () {
            function m(g, x, k, r) { this.viewingMode = g; this.spatialReference = x; this.unitInMeters = k; this.coordinateSystem = r; this._coordinateSystem = l.create(r) } var e = m.prototype; e.getAltitude = function (g) { return l.altitudeAt(this.coordinateSystem, g) }; e.setAltitude = function (g, x, k = g) { return l.setAltitudeAt(this.coordinateSystem, k, x, g) }; e.setAltitudeOfTransformation =
              function (g, x) { l.setAltitudeOfTransformation(this.coordinateSystem, x, g, x) }; e.worldUpAtPosition = function (g, x) { return l.normalAt(this.coordinateSystem, g, x) }; e.worldBasisAtPosition = function (g, x, k) { return l.axisAt(this.coordinateSystem, g, x, k) }; e.basisMatrixAtPosition = function (g, x) { const k = this.worldBasisAtPosition(g, 0, b.sv3d.get()), r = this.worldBasisAtPosition(g, 1, b.sv3d.get()); g = this.worldBasisAtPosition(g, 2, b.sv3d.get()); u.set(x, k[0], k[1], k[2], 0, r[0], r[1], r[2], 0, g[0], g[1], g[2], 0, 0, 0, 0, 1); return x }; e.intersectManifoldClosestSilhouette =
                function (g, x, k) { l.elevate(this.coordinateSystem, x, this._coordinateSystem); l.intersectRayClosestSilhouette(this._coordinateSystem, g, k); return k }; e.intersectManifold = function (g, x, k) { l.elevate(this.coordinateSystem, x, this._coordinateSystem); x = b.sv3d.get(); return l.intersectRay(this._coordinateSystem, g, x) ? y.copy(k, x) : null }; e.intersectInfiniteManifold = function (g, x, k) {
                  if (1 === this.viewingMode) return this.intersectManifold(g, x, k); l.elevate(this.coordinateSystem, x, this._coordinateSystem); x = this._coordinateSystem.value;
                  const r = b.sv3d.get(); return h.intersectRay(x.plane, g, r) ? y.copy(k, r) : null
                }; e.toRenderCoords = function (g, x, k) { return d.isDehydratedPoint(g) ? n.projectPointToVector(g, x, this.spatialReference) : n.projectVectorToVector(g, x, k, this.spatialReference) }; e.fromRenderCoords = function (g, x, k = null) {
                  return d.isDehydratedPoint(x) ? (c.isSome(k) && (x.spatialReference = k), n.projectVectorToDehydratedPoint(g, this.spatialReference, x)) : x instanceof p ? n.projectVectorToPoint(g, this.spatialReference, x) : n.projectVectorToVector(g, this.spatialReference,
                    x, k) ? x : null
                }; m.create = function (g, x) { switch (g) { case 2: return new m(2, x, q.getMetersPerUnitForSR(x), l.createLocal()); case 1: return new m(1, x, 1, l.createGlobal(x)) } }; m.renderUnitScaleFactor = function (g, x) { return t(g) / t(x) }; w._createClass(m, [{ key: "extent", set: function (g) { g && l.setExtent(this.coordinateSystem, g, this.coordinateSystem) } }]); return m
          }(); a.RenderCoordsHelper = v; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/ResourceController": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/maybe ../../../core/scheduling ../../../core/time ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./index ./MemoryController ./StreamDataLoader ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
        a.ResourceControllerMain = function (x) { function k() { var r = x.apply(this, arguments) || this; r.updating = !1; return r } w._inheritsLoose(k, x); return k }(q); c.__decorate([l.property({ readOnly: !0 })], a.ResourceControllerMain.prototype, "updating", void 0); a.ResourceControllerMain = c.__decorate([f.subclass("esri.views.3d.support.ResourceController")], a.ResourceControllerMain); var g; (function (x) {
          let k = function (r) {
            function A() {
              var B = r.apply(this, arguments) || this; B._scheduler =
                null; B._memoryController = null; B._streamDataLoader = null; B._cameraChangeTime = 0; B._handles = new u; B._frameTask = null; B._scheduleTask = e.ImmediateTask; B._state = 2; return B
            } w._inheritsLoose(A, r); var z = A.prototype; z.initialize = function () {
            this._cameraChangeTime = this.now(); this._scheduler = e.newScheduler(this.now); this._memoryController = v.newMemoryController(this.view); this._streamDataLoader = new m.default; this._streamDataLoader.setup(t.maxDownloadSlots, t.downloadSlotsPerClient, this._scheduler); this._handles.add([this.view.watch("state.camera",
              (B, C) => this._cameraChangedHandler(B, C), !0), this.view.watch("stationary", () => this._stationaryChangedHandler()), this._memoryController.events.on("updating-changed", () => this.notifyChange("updating"))]); this._frameTask = n.addFrameTask({ update: B => this.frame(B) }); this._scheduleTask = this._scheduler.registerTask(e.TaskPriority.RESOURCE_CONTROLLER)
            }; z.destroy = function () {
            this._handles = y.destroyMaybe(this._handles); this._scheduleTask.remove(); this._frameTask = y.removeMaybe(this._frameTask); this._streamDataLoader =
              y.destroyMaybe(this._streamDataLoader); this._memoryController = y.destroyMaybe(this._memoryController); this._scheduler = y.destroyMaybe(this._scheduler)
            }; z.schedule = function (B, C, D) { return this._scheduleTask.schedule(B, C, D) }; z.createStreamDataRequester = function (B) { const C = this._streamDataLoader; return { request(D, E, H) { return C.request(D, E, B, H) }, get busy() { return !C.hasDownloadSlots(B) } } }; z.frame = function (B) {
              if (!this.view.suspended) {
                if (this.view.stateManager && (this.view.stateManager.step(p.SecondsFromMilliseconds(B.deltaTime)),
                  !this._scheduler)) return; this._updateState(); this._scheduler.state = this._state; this._scheduler.updateBudget(B) ? (this._memoryController.update(), this._scheduler.frame()) : this._memoryController.updating && this._memoryController.update()
              }
            }; z._cameraChangedHandler = function (B, C) { B && C && B.almostEquals(C) || (this._cameraChangeTime = this._scheduler.now, this._updateState(), this._scheduler.state = this._state) }; z._stationaryChangedHandler = function () { this.memoryController.resetStableQuality() }; z._updateState = function () {
              this.view.animation ?
              this._state = 0 : this.view.interacting ? this._state = 1 : (0 === this._state && (this._cameraChangeTime = 0), this._state = 300 >= this._scheduler.now - this._cameraChangeTime ? 1 : 2)
            }; w._createClass(A, [{ key: "updating", get: function () { var B, C; return !!(null != (B = this._memoryController) && B.updating || null != (C = this._streamDataLoader) && C.updating) } }, { key: "scheduler", get: function () { return this._scheduler } }, { key: "memoryController", get: function () { return this._memoryController } }, {
              key: "test", get: function () {
                return {
                  getQueueStats: B => this._streamDataLoader.test.loadQueue.getStatsForType(B),
                  state: this._state
                }
              }
            }]); return A
          }(a.ResourceControllerMain); c.__decorate([l.property({ constructOnly: !0 })], k.prototype, "view", void 0); c.__decorate([l.property({ constructOnly: !0 })], k.prototype, "now", void 0); c.__decorate([l.property()], k.prototype, "_scheduler", void 0); c.__decorate([l.property()], k.prototype, "_memoryController", void 0); c.__decorate([l.property()], k.prototype, "_streamDataLoader", void 0); c.__decorate([l.property({ readOnly: !0 })], k.prototype, "updating", null); k = c.__decorate([f.subclass("esri.views.3d.support.ResourceController")],
            k); x.ResourceController = k
        })(g || (g = {})); a.newResourceController = function (x, k = () => performance.now()) { return new g.ResourceController({ view: x, now: k }) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/index": function () { define(["exports"], function (a) { a.downloadSlotsPerClient = [10, 10, 10, 10, 5]; a.maxDownloadSlots = 30; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/support/MemoryController": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Evented ../../../core/Logger ../../../core/maybe ../../../core/MemCache ../layers/support/MemoryManagedLayerView".split(" "),
        function (a, w, c, q, u, y, n) {
          const p = q.getLogger("esri.views.3d.support.MemoryController"); let l = function () {
            function h(d) { this._view = d; this.events = new c; this.minQuality = .1; this._maxMemory = 500; this._additionalCacheMemory = 100; this._quality = 1; this._downscaleMemoryUsed = this._stableQuality = 0; this._canFastRecover = !1; this._memoryPredicted = this._memoryUsed = 0; this._cacheStorage = new y.MemCacheStorage; this._numQualityChanges = 0; this._updating = !1 } var b = h.prototype; b.destroy = function () { this.events = null; this._cacheStorage.destroy() };
            b.newCache = function (d, f) { return new y.MemCache(d, this._cacheStorage, f) }; b.disableMemCache = function () { this._additionalCacheMemory = -4096 }; b.resetStableQuality = function () { this._stableQuality = 0 }; b.update = function () {
              this._updateMemory(); if (!(0 >= this._memoryPredicted) || this._updating) {
                var d = this._layersUpdating(); if (.6 > this._memoryPredicted && this._canFastRecover) this._stableQuality = this._downscaleMemoryUsed = 0, this._canFastRecover = !1, this._updateQuality(1); else if (d) {
                  if (1.1 < this._memoryPredicted || 1 < this._memoryUsed) 0 <
                    this._stableQuality ? (this._downscaleMemoryUsed = 0, this._updateQuality(this._stableQuality)) : this._quality > this.minQuality && this._downscaleMemoryUsed < this._memoryUsed && (this._updateQuality(this._quality / 1.3), this._downscaleMemoryUsed = this._memoryUsed, this._canFastRecover = !1)
                } else this._downscaleMemoryUsed = 0, 1 < this._memoryUsed ? (this._stableQuality = 0, this._canFastRecover = !1, d = this._updateQuality(this._quality / 1.3), this._downscaleMemoryUsed = this._memoryPredicted) : this._stableQuality !== this._quality && (.75 >
                  this._memoryUsed && 1 > this._quality ? (this._stableQuality = this._quality, d = this._updateQuality(this._quality + .05)) : 1 > this._quality && (this._canFastRecover = !0)); this.updating !== d && (this._updating = d, this.events.emit("updating-changed", this.updating))
              }
            }; b._updateQuality = function (d) { d = Math.min(Math.max(d, this.minQuality), 1); if (d === this._quality) return !1; this._quality = d; this.events.emit("quality-changed", this._quality); ++this._numQualityChanges; return !0 }; b._layersUpdating = function () {
              return this._view.allLayerViews.some(d =>
                !!d.updating)
            }; b._updateMemory = function () {
              let d = 0, f = 0; this._view.basemapTerrain && this._view.basemapTerrain.getUsedMemory && (d += this._view.basemapTerrain.getUsedMemory()); var t = this._view._stage && this._view._stage.renderView && this._view._stage.renderView.edgeView; u.isSome(t) && (d += t.usedMemory); this._view.allLayerViews && this._view.allLayerViews.forEach(m => { if (n.isMemoryManagedLayerView(m)) { const e = m.ignoresMemoryFactor() ? this._quality : 1; d += m.getUsedMemory() * e; f += m.getUnloadedMemory() * e } }); var v = null ==
                this._warnMemoryUsage || Math.round(10 * d) !== Math.round(10 * this._warnMemoryUsage); t = 1048576 * this._maxMemory; if (d > t && v) { this._warnMemoryUsage = d; v = e => (e / 1048576).toLocaleString(void 0, { maximumFractionDigits: 1 }) + " MB"; const m = Math.round(100 * this._quality); p.warn(`Memory Limit exceeded! Limit: ${v(t)} Current: ${v(d)} Projected: ${v(d + f)} Quality: ${m}%`) } this._memoryUsed = d / t; this._memoryPredicted = (d + f) / t; this._cacheStorage.maxSize = Math.max(0, t - d + 1048576 * this._additionalCacheMemory); this.events.emit("memory-used",
                  this._memoryUsed)
            }; w._createClass(h, [{ key: "maxMemory", get: function () { return this._maxMemory }, set: function (d) { null != d && 0 < d && (this._stableQuality = 0, this._canFastRecover = !1, this._maxMemory < d && this._updateQuality(1), this._maxMemory = d) } }, { key: "additionalCacheMemory", set: function (d) { null != d && 0 <= d && (this._additionalCacheMemory = d) } }, { key: "memoryFactor", get: function () { return this._quality } }, { key: "updating", get: function () { return this._updating } }, { key: "usedMemory", get: function () { return this._memoryUsed } }, {
              key: "test",
              get: function () { const d = this; return { cacheStorage: this._cacheStorage, resetQualityChanges: () => { const f = d._numQualityChanges; d._numQualityChanges = 0; return f } } }
            }]); return h
          }(); a.newMemoryController = function (h) { return new l(h) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/MemoryManagedLayerView": function () { define(["exports"], function (a) { a.isMemoryManagedLayerView = function (w) { return "function" === typeof w.getUsedMemory }; Object.defineProperty(a, "__esModule", { value: !0 }) }) },
    "esri/views/3d/support/StreamDataLoader": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../request ../../../core/Accessor ../../../core/arrayUtils ../../../core/Error ../../../core/lang ../../../core/maybe ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./AsyncWorkerQueue ./StreamDataLoaderTask ../webgl-engine/lib/Util ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          function g(k) { if (2 > k.byteLength) return "unknown"; k = new Uint8Array(k, 0, k.byteLength); return 137 === k[0] && 80 === k[1] ? "image/png" : 71 === k[0] && 73 === k[1] ? "image/gif" : 66 === k[0] && 77 === k[1] ? "image/bmp" : 255 === k[0] && 216 === k[1] ? "image/jpeg" : "unknown" } a.StreamDataLoader = function (k) {
            function r() { var z = k.apply(this, arguments) || this; z.tasks = new Map; z.onLoadQueue = []; z.doneQueue = []; z.updating = !1; return z } w._inheritsLoose(r, k); var A = r.prototype; A.setup = function (z, B, C) {
            this.loadQueue =
              new t.AsyncWorkerQueue((D, E) => this.startLoading(D, E), (D, E) => this.doneLoadingCallback(D, E), z, B); C && (this.taskHandle = C.registerTask(e.TaskPriority.STREAM_DATA_LOADER, this))
            }; A.destroy = function () { this.taskHandle = l.removeMaybe(this.taskHandle); this.tasks.forEach(z => { z.abortController && z.abortController.abort() }); this.loadQueue.destroy(); this.tasks = this.doneQueue = this.onLoadQueue = this.loadQueue = null }; A.hasDownloadSlots = function (z) { return this.loadQueue.hasQuota(z) }; A.request = function (z, B, C, D = {}) {
              const E =
                h.createResolver(); E.__signal = l.isSome(D) ? D.signal : null; const H = this.createOrUpdateTask(z, B, C, D, E); h.onAbort(D, () => this.cancelRequest(H, E)); return E.promise
            }; A.createTask = function (z, B, C, D, E, H) { z = new v(z, B, C, D, E); this.updateTask(z, H); this.tasks.set(E, z); 1 === this.tasks.size && this._set("updating", !0); this.loadQueue.push(z); return z }; A.cancelRequest = function (z, B) {
              y.removeUnordered(z.resolvers, B); B.reject(h.createAbortError()); 0 === z.resolvers.length && (2 === z.status && (z.status = 4, this.loadQueue.cancel(z),
                z.abortController.abort(), z.request = null, z.abortController = null), z.status = 4, this.tasks.delete(z.key), 0 === this.tasks.size && this._set("updating", !1))
            }; A.taskKey = function (z, B, C) { return `${z}:${B}:${C}` }; A.updateTask = function (z, B) { z.resolvers.push(B) }; A.createOrUpdateTask = function (z, B, C, D, E) { var H = l.isSome(D) && D.uid || z; H = this.taskKey(H, B, C); const J = this.tasks.get(H); return J ? (this.updateTask(J, E), J) : this.createTask(z, D, B, C, H, E) }; A.doneLoadingCallback = function (z, B) {
            this.loadQueue && (m.assert(2 === z.status),
              z.status = 3, this.taskHandle ? this.doneQueue.push({ task: z, err: B }) : this.doneLoading(z, B))
            }; A.runTask = function (z) { for (; !z.done && 0 < this.onLoadQueue.length;) { var B = this.onLoadQueue.shift(); h.throwIfAborted(B.task.abortController); B.task.abortController = null; B.callback(B.task); z.madeProgress() } for (; !z.done && 0 < this.doneQueue.length;)B = this.doneQueue.shift(), 3 !== B.task.status && (B.err = B.err || h.createAbortError()), this.doneLoading(B.task, B.err), z.madeProgress() }; A.doneLoading = function (z, B) {
              let C = z.result instanceof
                HTMLImageElement ? 0 : z.resolvers.length; for (const D of z.resolvers) if (B) h.isAbortError(B) ? D.reject(B) : D.reject(new n("stream-data-loader:request-error", `Failed to request resource at '${z.url}'. ${B}`, { url: z.url, error: B })); else { --C; const E = 0 >= C ? z.result : p.clone(z.result); D.resolve(E) } this.tasks.delete(z.key); 0 === this.tasks.size && this._set("updating", !1)
            }; A.startLoading = function (z, B) {
              if (4 === z.status) return !1; z.startTime = performance.now(); z.status = 2; let C, D; switch (z.docType) {
                case "binary": D = "array-buffer";
                  C = 0; break; case "image": D = "image"; break; case "image+type": D = "array-buffer"; break; default: D = "json"
              }z.abortController = new AbortController; const E = z.abortController.signal; z.request = q(z.url, { ...z.options, responseType: D, timeout: C, signal: E }); let H = () => { }; const J = F => { z.duration = performance.now() - z.startTime; z.size = F instanceof ArrayBuffer ? F.byteLength : z.size || 0; z.result = F; this.taskHandle ? this.onLoadQueue.push({ callback: B, task: z }) : (z.abortController = null, B(z)) }, M = F => { 2 === z.status && B(z, F); H() }; if ("image+type" !==
                z.docType) return z.request.then(F => J(F.data), M), !0; z.request.then(F => { F = F.data; const K = g(F); D = "image"; z.size = F.byteLength; if ("unknown" === K) z.request = q(z.url, { responseType: D, timeout: C, signal: E }), z.request.then(L => J(L.data), M); else { F = new Blob([F], { type: K }); var P = window.URL.createObjectURL(F); H = () => window.URL.revokeObjectURL(P); z.request = q(P, { responseType: D, timeout: C, signal: E }); z.request.then(L => J(new x(L.data, K, H)), M) } }, M); return !0
            }; w._createClass(r, [{
              key: "running", get: function () {
                return 0 < this.doneQueue.length ||
                  0 < this.onLoadQueue.length
              }
            }, { key: "test", get: function () { return { loadQueue: this.loadQueue } } }]); return r
          }(u); c.__decorate([b.property({ readOnly: !0 })], a.StreamDataLoader.prototype, "updating", void 0); a.StreamDataLoader = c.__decorate([f.subclass("esri.views.3d.support.StreamDataLoader")], a.StreamDataLoader); let x = function () { function k(r, A, z) { this.image = r; this.type = A; this.release = z } w._createClass(k, [{ key: "isOpaque", get: function () { return "image/jpeg" === this.type } }]); return k }(); c = a.StreamDataLoader; a.ImageWithType =
            x; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/AsyncWorkerQueue": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../webgl-engine/lib/Util"], function (a, w, c) {
        let q = function (n) { this.typeWorkerQuota = n; this.tasks = []; this.numWorkers = 0; this.statistics = new u }, u = function () { this.speed = this.duration = this.size = this.requests = 0 }, y = function () {
          function n(l, h, b, d) {
          this._workerFunc = l; this._callbackFunc = h; this._maxTotalNumWorkers = b; this._totalNumWorkers =
            0; this._clients = d.map(f => new q(f))
          } var p = n.prototype; p.hasQuota = function (l) { return (l = this._clients[l]) ? this._totalNumWorkers < this._maxTotalNumWorkers || l.numWorkers + l.tasks.length < l.typeWorkerQuota : !1 }; p.push = function (l) { const h = this._clients[l.client]; h && (this._totalNumWorkers < this._maxTotalNumWorkers ? (h.numWorkers++ , this._totalNumWorkers++ , this._workerFunc(l, (b, d) => this._taskCallback(b, d))) : h.tasks.push(l)) }; p.cancel = function (l) { this._taskFinished(l); l._cancelled = !0 }; p.destroy = function () {
            this._clients.length =
            0
          }; p._taskFinished = function (l) { const h = this._clients[l.client]; this._totalNumWorkers--; h.numWorkers--; h.statistics.requests++; h.statistics.size += l.size || 0; h.statistics.duration += l.duration || 0; h.statistics.speed = 0 < h.statistics.duration ? h.statistics.size / h.statistics.duration : 0; c.assert(0 <= h.numWorkers); this._next() }; p._next = function () { for (const l of this._clients) if (l && l.numWorkers < l.typeWorkerQuota && this._processQueue(l)) return; for (const l of this._clients) if (l && this._processQueue(l)) break }; p._processQueue =
            function (l) { for (; 0 < l.tasks.length;)if (this._workerFunc(l.tasks.shift(), (h, b) => this._taskCallback(h, b))) return l.numWorkers++ , this._totalNumWorkers++ , !0; return !1 }; p._taskCallback = function (l, h) { l._cancelled || (this._callbackFunc(l, h), this._taskFinished(l)) }; p.getStatsForType = function (l) { return (l = this._clients[l]) ? { quota: l.typeWorkerQuota, workers: l.numWorkers, queueSize: l.tasks.length, requestStats: l.statistics } : null }; w._createClass(n, [{
              key: "test", get: function () {
                const l = this; return {
                  set workerFunc(h) {
                  l._workerFunc =
                    h
                  }
                }
              }
            }]); return n
        }(); a.AsyncWorkerQueue = y; a.BaseTask = function (n) { this.client = n; this._cancelled = !1; this.duration = this.size = 0 }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/StreamDataLoaderTask": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers", "./AsyncWorkerQueue"], function (a, w) {
        return function (c) {
          function q(u, y, n, p, l) {
            p = c.call(this, p) || this; p.url = u; p.options = y; p.docType = n; p.key = l; p.result = null; p.status = 1; p.request = null; p.abortController = null; p.resolvers = [];
            p.startTime = 0; return p
          } a._inheritsLoose(q, c); return q
        }(w.BaseTask)
      })
    }, "esri/views/3d/support/SceneViewPerformanceInfo": function () {
      define(["../../../core/maybe", "../layers/support/MemoryManagedLayerView", "./LayerPerformanceInfo", "../terrain/terrainUtils"], function (a, w, c, q) {
        return function (u) {
        this.usedMemory = this.totalMemory = 0; this.quality = 1; this.edgesMemory = this.terrainMemory = this.load = 0; this.layerPerformanceInfos = []; var y = u.resourceController.memoryController; this.totalMemory = 1048576 * y.maxMemory;
          this.usedMemory = Math.round(y.usedMemory * this.totalMemory); this.quality = y.memoryFactor; this.load = u.resourceController.scheduler.load; this.terrainMemory = u.basemapTerrain ? u.basemapTerrain.getUsedMemory() : 0; y = u._stage && u._stage.renderView && u._stage.renderView.edgeView; this.edgesMemory = a.isSome(y) ? y.usedMemory : 0; u.allLayerViews.items.forEach(n => { (w.isMemoryManagedLayerView(n) || q.isSurfaceLayerView(n)) && this.layerPerformanceInfos.push(new c(n, u)) }); this.layerPerformanceInfos.sort((n, p) => p.memory - n.memory)
        }
      })
    },
    "esri/views/3d/support/LayerPerformanceInfo": function () {
      define(["../layers/support/PerformanceInfoLayerView", "../terrain/terrainUtils"], function (a, w) {
        return function (c, q) {
        this.layer = null; this.displayedNumberOfFeatures = this.memory = 0; this.totalNumberOfFeatures = this.maximumNumberOfFeatures = null; this.layer = c.layer; this.memory = w.isSurfaceLayerView(c) ? q.basemapTerrain.getUsedMemoryForLayerView(c) : c.getUsedMemory(); a.isPerformanceInfoLayerView(c) && (c = c.performanceInfo, this.displayedNumberOfFeatures = c.displayedNumberOfFeatures,
          this.maximumNumberOfFeatures = c.maximumNumberOfFeatures, this.totalNumberOfFeatures = c.totalNumberOfFeatures)
        }
      })
    }, "esri/views/3d/layers/support/PerformanceInfoLayerView": function () { define(["exports"], function (a) { a.isPerformanceInfoLayerView = function (w) { return "performanceInfo" in w }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/terrain/terrainUtils": function () {
      define(["exports", "../../../core/maybe", "../support/StreamDataLoader", "../../../chunks/terrainUtilsPlanar", "../../../chunks/terrainUtilsSpherical"],
        function (a, w, c, q, u) {
          function y(g) { return "vector-tile" === (null == g ? void 0 : g.type) } function n(g) { return "imagery-tile" === (null == g ? void 0 : g.type) || "wcs" === (null == g ? void 0 : g.type) } function p(g) { return "imagery-tile-3d" === (null == g ? void 0 : g.type) } function l(g) { return "tile-3d" === (null == g ? void 0 : g.type) } function h(g) { return "vector-tile-3d" === (null == g ? void 0 : g.type) } function b(g) { return "wmts-3d" === (null == g ? void 0 : g.type) } function d(g) { return "elevation-3d" === (null == g ? void 0 : g.type) } function f(g, x, k, r) {
            return t[r].checkIfTileInfoSupportedForViewSR(g,
              k, x)
          } const t = { [1]: u.terrainUtilsSpherical, [2]: q.terrainUtilsPlanar }, v = 80 / 180 * Math.PI, m = 110 / 180 * Math.PI, e = { force512VTL: !1 }; a.checkIfTileInfoSupportedForView = f; a.computeSkirtScale = function (g, x, k) {
            const r = t[g.viewingMode]; if (r.isInsideExtent(g, x)) var A = w.unwrapOr(g.getElevation(x[0], x[1], x[1], g.spatialReference), 0); else {
              if (!r.isInsideExtent(g, x, 1.2)) return 0; var z = g.getTileWithElevation(x[0], x[1], x[1], g.spatialReference); A = w.isSome(z) ? z.elevationBounds[0] : g.elevationBounds.min; z = w.isSome(z) ? z.elevationBounds[1] :
                g.elevationBounds.max; A = .5 * (A + z); g = r.tiltToExtentEdge(g, x, A); if (g > v && g < m) return 0
            } x = x[2] - A; return Math.abs(x) < k ? 0 : 0 > x ? -1 : 1
          }; a.getLayerWithExtentRange = function (g) { return p(g) ? { fullExtent: g.fullExtent, minScale: g.layer.minScale, maxScale: g.layer.maxScale, tilemapCache: null } : g.layer }; a.getTiledLayerInfo = function (g, x, k) {
            let r = null, A = null; if ("wmts" === g.type) {
              if (g = g.activeLayer) {
                const z = g.tileMatrixSet; if (z) r = z.tileInfo, A = z.fullExtent; else if (g = g.tileMatrixSets) if (g = g.find(B => null == f(B.tileInfo, B.fullExtent,
                  x, k))) return { tileInfo: g.tileInfo, fullExtent: g.fullExtent }
              }
            } else A = n(g) ? g.getCompatibleFullExtent(x) : g.fullExtent, r = y(g) && !e.force512VTL ? g.compatibleTileInfo256 : n(g) ? g.getCompatibleTileInfo(x, A, 2 === k) : g.tileInfo; return w.isSome(r) && w.isSome(A) && null == f(r, A, x, k) ? { tileInfo: r, fullExtent: A } : null
          }; a.isElevationLayerView = d; a.isImageryTileLayerView = p; a.isImageryTileRenderInfo = function (g) { var x; g = null == g ? void 0 : null == (x = g.sourceLayerInfo) ? void 0 : x.data; return w.isSome(g) && "type" in g && "raster-tile" === g.type };
          a.isProjectableRasterLayer = n; a.isRasterTileRenderInfo = function (g) { var x; g = null == g ? void 0 : null == (x = g.sourceLayerInfo) ? void 0 : x.data; return g instanceof HTMLImageElement || g instanceof c.ImageWithType || g instanceof HTMLCanvasElement || g instanceof ImageData }; a.isSurfaceLayerView = function (g) { return g && (l(g) || p(g) || d(g) || h(g) || b(g)) }; a.isTextureTileRenderInfo = function (g) { var x; g = null == g ? void 0 : null == (x = g.sourceLayerInfo) ? void 0 : x.data; return w.isSome(g) && "type" in g && "tile-texture" === g.type }; a.isTileLayerView =
            l; a.isVectorTileLayer = y; a.isVectorTileLayerView = h; a.isVectorTileRenderInfo = function (g) { var x; g = null == g ? void 0 : null == (x = g.sourceLayerInfo) ? void 0 : x.data; return w.isSome(g) && "type" in g && "vector-tile" === g.type }; a.isWMTSLayerView = b; a.releaseTileData = function (g) { w.isSome(g) && "release" in g && g.release(); return null }; a.test = e; a.useFetchTileForLayer = function (g) { return g.fetchTile && !1 !== g.hasOverriddenFetchTile }; a.weakAssert = function (g, x) { g || console.warn("Terrain: " + x) }; Object.defineProperty(a, "__esModule",
              { value: !0 })
        })
    }, "esri/chunks/terrainUtilsPlanar": function () {
      define("exports ../core/Error ../core/maybe ./vec3 ./vec3f64 ../geometry/projection ../geometry/support/aaBoundingRect ../views/3d/terrain/TerrainConst ../views/3d/terrain/TilingScheme".split(" "), function (a, w, c, q, u, y, n, p, l) {
        function h(g, x, k = 0) { g = g.extent; return c.isNone(g) ? !1 : 0 === k ? n.containsPoint(g, x) : n.containsPointWithMargin(g, x, k * Math.min(g[2] - g[0], g[3] - g[1])) } function b(g, x, k, r) {
          q.copy(t, k); t[r] = x[r]; r = q.subtract(t, t, x); var A = q.subtract(v,
            g, x); A = q.dot(A, r); const z = q.dot(r, r); x = 0 >= A ? x : z <= A ? k : q.add(t, x, q.scale(r, r, A / z)); g = q.subtract(t, g, x); return Math.PI / 2 - Math.atan(g[2] / Math.sqrt(g[0] * g[0] + g[1] * g[1]))
        } function d(g, x, k) { g = g.extent; if (c.isNone(g)) return 0; m[0] = g[0]; m[1] = g[1]; m[2] = k; e[0] = g[2]; e[1] = g[3]; e[2] = k; g = k = Infinity; x[0] < m[0] ? k = b(x, m, e, 0) : x[0] > e[0] && (k = b(x, e, m, 0)); x[1] < m[1] ? g = b(x, m, e, 1) : x[1] > e[1] && (g = b(x, e, m, 1)); return Math.min(k, g) } function f(g, x, k) {
          if (g.spatialReference.isGeographic && !y.canProjectToWGS84ComparableLonLat(g.spatialReference)) return new w("tilingscheme:local-unsupported-spatial-reference",
            "The tiling scheme spatial reference is not supported in local scenes"); var r = l.checkUnsupported(g); if (c.isSome(r)) return r; {
              var A = g.lods; r = A[0].resolution * 2 ** A[0].level; var z = [r * g.size[0], r * g.size[1]]; const B = [g.origin.x, g.origin.y]; k = n.fromExtent(k); const C = n.create(); l.computeRowColExtent(k, z, B, C); z = (C[2] - C[0]) * (C[3] - C[1]); z > p.MAX_ROOT_TILES ? (A = A[0].scale * 2 ** A[0].level, r = Math.max((k[3] - k[1]) / g.size[1], (k[2] - k[0]) / g.size[0]) * A / r, k = Math.floor(Math.log(r) / Math.log(10)), r = Math.ceil(r / 10 ** k) * 10 ** k,
                r = new w("tilingscheme:too-many-root-tiles", "Scale of level 0 of the tiling scheme (1:" + Math.floor(A).toLocaleString() + ") is too large for the layer's extent. Suggested scale: 1:" + r.toLocaleString() + ".", { level0Scale: A, suggestedLevel0Scale: r, requiredNumRootTiles: z, allowedNumRootTiles: p.MAX_ROOT_TILES })) : r = null
          } return r ? r : x && !g.spatialReference.equals(x) ? new w("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the local scene") : null
        } const t = u.create(),
          v = u.create(), m = u.create(), e = u.create(); u = Object.freeze({ __proto__: null, isInsideExtent: h, tiltToExtentEdge: d, checkIfTileInfoSupportedForViewSR: f }); a.checkIfTileInfoSupportedForViewSR = f; a.isInsideExtent = h; a.terrainUtilsPlanar = u; a.tiltToExtentEdge = d
      })
    }, "esri/chunks/terrainUtilsSpherical": function () {
      define(["exports", "../core/Error", "../geometry/projection", "../geometry/support/spatialReferenceUtils", "../views/3d/terrain/TilingScheme"], function (a, w, c, q, u) {
        function y() { return !0 } function n() { return 0 } function p(h,
          b) {
            const d = h.lods.length - 1, f = h.spatialReference, t = c.canProjectToWGS84ComparableLonLat(f) || q.isMars(f) || q.isMoon(f); if (f.isWebMercator) { if (!u.makeWebMercatorAuxiliarySphere(d).compatibleWith(h)) return new w("tilingscheme:incompatible-global-web-mercator", "The tiling scheme is not compatible with the ArcGIS Online Web Mercator tiling scheme") } else if (t) {
              if (!u.makeGCSWithTileSize(h.spatialReference, h.size[0], d).compatibleWith(h)) return h.spatialReference.isWGS84 ? new w("tilingscheme:incompatible-global-wgs84",
                "The tiling scheme is not compatible with the ArcGIS Online WGS84 tiling scheme") : new w("tilingscheme:incompatible-global", "The tiling scheme is not compatible with the ArcGIS Online tiling scheme")
            } else return new w("tilingscheme:global-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in global scenes"); if (b && !h.spatialReference.equals(b)) return new w("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the global scene")
        }
        const l = Object.freeze({ __proto__: null, isInsideExtent: y, tiltToExtentEdge: n, checkIfTileInfoSupportedForViewSR: p }); a.checkIfTileInfoSupportedForViewSR = p; a.isInsideExtent = y; a.terrainUtilsSpherical = l; a.tiltToExtentEdge = n
      })
    }, "esri/views/3d/support/SharedSymbolResources": function () {
      define("exports ../../../core/arrayUtils ../../../core/Handles ../../../geometry/projectionEllipsoid ./StreamTextureCollection ../webgl-engine/lib/screenSizePerspectiveUtils".split(" "), function (a, w, c, q, u, y) {
        let n = function () {
          function l(b) {
          this.streamDataRequester =
            this.textures = null; this.graphicsOwners = []; this.cimSymbolRasterizer = this.screenSizePerspectiveHandles = null; this.viewState = b.viewState; this.view = b.view; this.pointsOfInterest = b.pointsOfInterest; this.objectResourceCache = b.objectResourceCache; this.streamDataRequester = b.resourceController.createStreamDataRequester(4); this.textures = new u.StreamTextureCollection(this.streamDataRequester, b.view._stage, { preMultiplyAlpha: !0, wrap: { s: 33071, t: 33071 } }, b.resourceController.scheduler); const d = q.getReferenceEllipsoid(this.view.spatialReference).radius;
            this.screenSizePerspectiveSettings = y.getSettings(b.viewingMode, d); this.screenSizePerspectiveSettingsLabels = y.getLabelSettings(b.viewingMode, d)
          } var h = l.prototype; h.destroy = function () { this.textures.destroy(); this.streamDataRequester = this.textures = null }; h.addGraphicsOwner = function (b) {
            if (!b) return { remove() { } }; this.graphicsOwners.push(b); const d = "layer" in b ? b.watch("layer.screenSizePerspectiveEnabled", () => this.updateScreenSizePerspectiveEnabled()) : null; this.updateScreenSizePerspectiveEnabled(); return {
              remove: () => { d && (d.remove(), w.removeUnordered(this.graphicsOwners, b), this.updateScreenSizePerspectiveEnabled()) }
            }
          }; h.updateScreenSizePerspectiveEnabled = function () {
            var b = this.graphicsOwners.some(d => !0 === d.get("layer.screenSizePerspectiveEnabled")); b && !this.screenSizePerspectiveHandles ? (this.screenSizePerspectiveHandles = new c, b = () => this.updateScreenSizePerspectiveSettings(), this.screenSizePerspectiveHandles.add([this.pointsOfInterest.centerOnSurfaceInfrequent.watch("distance", b, !0), this.viewState.events.on("camera-projection-changed",
              b)]), this.updateScreenSizePerspectiveSettings()) : !b && this.screenSizePerspectiveHandles && (this.screenSizePerspectiveHandles.destroy(), this.screenSizePerspectiveHandles = null)
          }; h.updateScreenSizePerspectiveSettings = function () { p.distance = this.pointsOfInterest.centerOnSurfaceInfrequent.distance; p.fovY = this.viewState.camera.fovY; this.screenSizePerspectiveSettings.update(p); this.screenSizePerspectiveSettingsLabels.update(p); this.view._stage.renderView.requestRender() }; return l
        }(); const p = { distance: 0, fovY: 0 };
        a.SharedSymbolResources = n; a.default = n; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/StreamTextureCollection": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../core/promiseUtils ../../../core/urlUtils ./TextureCollection ../webgl-engine/lib/Texture".split(" "), function (a, w, c, q, u, y, n) {
        y = function (p) {
          function l(b, d, f, t) { d = p.call(this, d, t) || this; d._streamDataRequester = b; d._parameters = f; return d } w._inheritsLoose(l, p); var h = l.prototype;
          h.fromUrl = function () {
            var b = w._asyncToGenerator(function* (d, f, t) {
              var v = this; q.throwIfAborted(t); const m = c.isSome(t) && t.signal, e = this.makeUid(d, f); let g = this._textureRequests.get(e); if (!g) {
                t = new AbortController; const x = this._streamDataRequester.request(d, "image", { uid: e, signal: t.signal }); g = { referenceCount: 0, texture: null, textureAsync: null, abortController: t }; this._textureRequests.set(e, g); g.textureAsync = x.then(function () {
                  var k = w._asyncToGenerator(function* (r) {
                    r = v._createTexture(d, r, f); g.texture = r; g.abortController =
                      null; v._stage.add(r); yield v._stage.load(r); return { uid: e, texture: r, release: () => v._release(e) }
                  }); return function (r) { return k.apply(this, arguments) }
                }(), k => { g.abortController = null; throw k; })
              } g.referenceCount++; return (new Promise((x, k) => { q.onAbort(m, () => { k(q.createAbortError()) }); g.textureAsync.then(x, k) })).catch(x => { this._release(e); throw x; })
            }); return function (d, f, t) { return b.apply(this, arguments) }
          }(); h._createTexture = function (b, d, f) {
            const t = { ...this._parameters, powerOfTwoResizeMode: 2 }; if (u.isSVG(b)) {
              if (f ||
                0 === d.width && 0 === d.height) b = d.width ? d.height / d.width : 1, f = f || 64, 1 < b ? (d.width = Math.round(f / b), d.height = f) : (d.width = f, d.height = Math.round(f * b)); this._stage.renderView && this._stage.renderView.renderingContext.driverTest.svgAlwaysPremultipliesAlpha && (t.preMultiplyAlpha = !1)
            } t.width = d.width; t.height = d.height; return new n.Texture(d, t)
          }; return l
        }(y.TextureCollection); a.StreamTextureCollection = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/pointsOfInterest/PointsOfInterest": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/maybe ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/ray ../debugFlags ../debugUtils ../PropertiesPool ../geometryUtils/ray ./CameraOnSurface ./CenterOnSurface ./ContentGeometryUpdates ./Focus ./StableSurfaceCenter ./SurfaceGeometryUpdates ../../webgl-engine/lib/Intersector ../../webgl-engine/lib/verticalOffsetUtils ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H) {
        a.PointsOfInterest = function (P) {
          function L(G) { G = P.call(this, G) || this; G._handles = new u; G._tmpRay = v.create(); G._centerRayDirty = !0; G._surfaceAltitudeAtCenter = 0; G._surfaceAltitudeAtCenterDirty = !0; G._contentAltitudeAtCenter = 0; G._contentAltitudeAtCenterDirty = !0; G._propertiesPool = new g.PropertiesPool({ renderPointOfView: J }, w._assertThisInitialized(G)); G.renderPointOfView = t.create(); G._pois = []; G._debugCenters = new Map; return G } w._inheritsLoose(L,
            P); var N = L.prototype; N.initialize = function () {
              var G; const { state: I, basemapTerrain: O, renderCoordsHelper: R, map: S } = this.view; this._surfaceIntersector = D.newIntersector(I.viewingMode); this._surfaceIntersector.options.backfacesTerrain = I.isGlobal ? !1 : !0; this._surfaceIntersector.options.invisibleTerrain = !1; this._surfaceIntersector.options.store = 0; this._contentIntersector = D.newIntersector(I.viewingMode); var Q = () => this._estimateSurfaceAltitudeAtCenter(); const T = this.view.resourceController.scheduler, da = y.unwrap(null ==
                (G = this.view.basemapTerrain) ? void 0 : G.elevationQueryCache); G = { state: I, scheduler: T, surface: O, renderCoordsHelper: R }; this._set("centerOnSurfaceInfrequent", new r.default({ ...G, task: H.TaskPriority.POINT_OF_INTEREST_INFREQUENT, estimateSurfaceAltitudeAtCenter: Q })); this._set("centerOnSurfaceFrequent", new r.default({ ...G, task: H.TaskPriority.POINT_OF_INTEREST_FREQUENT, estimateSurfaceAltitudeAtCenter: Q })); this._set("contentCenterOnSurface", new r.default({
                  ...G, task: H.TaskPriority.POINT_OF_INTEREST_INFREQUENT,
                  estimateSurfaceAltitudeAtCenter: Q, cameraName: "contentCamera"
                })); this._set("centerOnContent", new r.default({ ...G, task: H.TaskPriority.POINT_OF_INTEREST_FREQUENT, estimateSurfaceAltitudeAtCenter: () => this._estimateContentAltitudeAtCenter() })); this._set("cameraOnSurface", new k.default({ ...G, cache: da, task: H.TaskPriority.POINT_OF_INTEREST_INFREQUENT, map: S })); this._set("contentCameraOnSurface", new k.default({ ...G, cache: da, task: H.TaskPriority.POINT_OF_INTEREST_INFREQUENT, map: S, cameraName: "contentCamera" }));
              this._set("surfaceGeometryUpdates", new C.SurfaceGeometryUpdates({ ...G, centerOnSurfaces: [this.centerOnSurfaceFrequent, this.centerOnContent, this.centerOnSurfaceInfrequent] })); this._set("contentGeometryUpdates", new A.ContentGeometryUpdates({ contentLayerViews: this.view.allLayerViews, renderCoordsHelper: R })); this._set("surfaceOrigin", new B.StableSurfaceCenter({ cache: da, view: this.view })); this._set("focus", new z.default({
                state: I, scheduler: T, surface: O, renderCoordsHelper: R, centerOnSurface: this.contentCenterOnSurface,
                estimateSurfaceIntersectionAtRenderPoint: (Y, fa) => this._estimateSurfaceIntersectionAtRenderPoint(Y, this.view.state.contentCamera, fa)
              })); this._pois.push(this.centerOnContent, this.centerOnSurfaceFrequent, this.centerOnSurfaceInfrequent, this.contentCenterOnSurface, this.cameraOnSurface, this.contentCameraOnSurface, this.focus); Q = this.view.graphics; this._debugCenters.set(this.centerOnContent, new e.PointGraphics(Q, "red", "CenterOnContent")); this._debugCenters.set(this.centerOnSurfaceFrequent, new e.PointGraphics(Q,
                "red", "CenterOnSurface")); this._debugCenters.set(this.centerOnSurfaceInfrequent, new e.PointGraphics(Q, "red", "CenterOnSurface")); this._debugCenters.set(this.contentCenterOnSurface, new e.PointGraphics(Q, "red", "ContentCenterOnSurface")); this._debugCenters.set(this.cameraOnSurface, new e.PointGraphics(Q, "blue", "CameraOnSurface")); this._debugCenters.set(this.contentCameraOnSurface, new e.PointGraphics(Q, "blue", "ContentCameraOnSurface")); this._debugCenters.set(this.focus, new e.PointGraphics(Q, "green", "Focus"));
              this._handles.add([I.watch("camera", Y => this._cameraChanged(Y), !0), O.watch("extent", () => this._updateCenterPointsOfInterest()), n.whenFalse(O, "updating", () => this._updateCenterPointsOfInterest(), !0), this.surfaceGeometryUpdates.events.on("request-update", () => this._updateCenterPointsOfInterest()), this.contentGeometryUpdates.events.on("request-update", () => this._updateCenterOnContent()), n.init(m, "SHOW_POI", Y => this._setDebug(Y))]); this._cameraChanged(this.view.state.camera); for (const Y of this._pois) Y.runTask()
            };
          N.destroy = function () { this._setDebug(!1); this._handles.destroy(); this._propertiesPool.destroy(); for (const G of this._pois) G.destroy(); this.surfaceOrigin.destroy() }; N._estimateContentAltitudeAtCenter = function () {
            if (!this._contentAltitudeAtCenterDirty) return this._contentAltitudeAtCenter; this._contentAltitudeAtCenterDirty = !1; const G = this.centerRay; if (y.isNone(G)) return this._contentAltitudeAtCenter; this.view.sceneIntersectionHelper.intersectRay(G, this._contentIntersector, M, K) ? this._contentAltitudeAtCenter =
              this.view.renderCoordsHelper.getAltitude(M) : this._contentAltitudeAtCenter = this._estimateSurfaceAltitudeAtCenter(); return this._contentAltitudeAtCenter
          }; N._estimateSurfaceAltitudeAtCenter = function () {
            if (!this.view.basemapTerrain) return 0; if (!this._surfaceAltitudeAtCenterDirty) return this._surfaceAltitudeAtCenter; this._surfaceAltitudeAtCenterDirty = !1; const G = this.centerRay; if (y.isNone(G)) return this._surfaceAltitudeAtCenter; const I = G.origin, O = f.add(M, G.origin, G.direction); this._surfaceIntersector.resetWithRay(G,
              this.view.state.camera); this.view.basemapTerrain.intersect(this._surfaceIntersector, null, I, O); this._surfaceIntersector.results.min.getIntersectionPoint(M) && (this._surfaceAltitudeAtCenter = this.view.renderCoordsHelper.getAltitude(M)); return this._surfaceAltitudeAtCenter
          }; N._estimateSurfaceIntersectionAtRenderPoint = function (G, I, O) {
            G = x.fromRenderAtEye(I, G, F); if (y.isNone(G)) return null; const R = G.origin, S = f.add(M, G.origin, G.direction); this._surfaceIntersector.resetWithRay(G, I); this.view.basemapTerrain.intersect(this._surfaceIntersector,
              null, R, S); return this._surfaceIntersector.results.min.getIntersectionPoint(O) ? O : null
          }; N._cameraChanged = function (G) { this._updateCenterPointsOfInterest(); G = G.eye; f.exactEquals(this.renderPointOfView, G) || this._set("renderPointOfView", f.copy(this._propertiesPool.get("renderPointOfView"), G)) }; N._updateCenterPointsOfInterest = function () { this._contentAltitudeAtCenterDirty = this._surfaceAltitudeAtCenterDirty = this._centerRayDirty = !0; for (const G of this._pois) G.updateRenderLocation() }; N._updateCenterOnContent =
            function () { this._contentAltitudeAtCenterDirty = !0; this.centerOnContent.updateRenderLocation() }; N._setDebug = function (G) { if (G) for (const I of this._pois) this._handles.add(n.init(I, "renderLocation", O => this._debugCenters.get(I).show(O, I.renderCoordsHelper.spatialReference)), "debug"); else this._debugCenters.forEach(I => I.hide()), this._handles.remove("debug") }; w._createClass(L, [{ key: "updating", get: function () { var G; return !!(null != (G = this.surfaceGeometryUpdates) && G.updating || this._pois.some(I => I.updating)) } },
            { key: "centerRay", get: function () { this._centerRayDirty && (this._centerRay = this.view.sceneIntersectionHelper.getCenterRayWithSubpixelOffset(this.view.state.camera, this._tmpRay), this._centerRayDirty = !1); return this._centerRay } }, { key: "test", get: function () { return { update: () => { this.surfaceGeometryUpdates.runTask(); for (const G of this._pois) G.runTask() }, surfaceGeometryUpdates: this.surfaceGeometryUpdates } } }]); return L
        }(q); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "centerOnContent",
          void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "centerOnSurfaceFrequent", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "centerOnSurfaceInfrequent", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "contentCenterOnSurface", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "cameraOnSurface", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "contentCameraOnSurface",
            void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "focus", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "renderPointOfView", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "surfaceOrigin", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "contentGeometryUpdates", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "surfaceGeometryUpdates", void 0); c.__decorate([p.property({ constructOnly: !0 })],
              a.PointsOfInterest.prototype, "view", void 0); c.__decorate([p.property({ readOnly: !0 })], a.PointsOfInterest.prototype, "updating", null); a.PointsOfInterest = c.__decorate([d.subclass("esri.views.3d.support.PointsOfInterest")], a.PointsOfInterest); const J = Array, M = t.create(), F = v.create(), K = { exclude: new Set([E.TERRAIN_ID]) }; a.default = a.PointsOfInterest; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/debugUtils": function () {
      define("exports ../../../geometry ../../../Graphic ../../../symbols ../../../core/maybe ../../../geometry/Polygon ../../../symbols/FillSymbol3DLayer ../../../symbols/PolygonSymbol3D ../../../geometry/Point ../../../symbols/PointSymbol3D ../../../symbols/IconSymbol3DLayer ../../../symbols/TextSymbol3DLayer".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          w = function () {
            function f(v, m, e = "") { this.graphics = v; this._symbol = new h({ symbolLayers: [new b({ material: { color: m }, outline: { color: [255, 255, 255], size: 1 }, resource: { primitive: "circle" } }), new d({ text: e, halo: { color: "white", size: 1 / .75 }, material: { color: m }, size: 12 })] }) } var t = f.prototype; t.show = function (v, m) { u.isNone(m) || (this.hide(), v = new l({ x: v[0], y: v[1], z: v[2], spatialReference: m }), this._graphic = new c({ geometry: v, symbol: this._symbol }), this.graphics.add(this._graphic)) }; t.hide =
              function () { u.isSome(this._graphic) && (this.graphics.remove(this._graphic), this._graphic = null) }; return f
          }(); q = function () {
            function f(v, m, e = "") { this.graphics = v; this._graphics = []; this._outline = new p({ symbolLayers: [new n({ material: { color: [0, 0, 0, 0] }, outline: { color: m, size: 2 } })] }); this._text = new h({ symbolLayers: [new d({ text: e, halo: { color: "white", size: 1 / .75 }, material: { color: m }, size: 12 })] }) } var t = f.prototype; t.show = function (v) {
              this.hide(); const m = new l({ x: v.xmin, y: v.ymin, z: v.zmax, spatialReference: v.spatialReference });
              this._graphics.push(new c({ geometry: y.fromExtent(v), symbol: this._outline })); this._graphics.push(new c({ geometry: m, symbol: this._text })); this.graphics.addMany(this._graphics)
            }; t.hide = function () { this.graphics.removeMany(this._graphics); this._graphics.length = 0 }; return f
          }(); a.ExtentGraphics = q; a.PointGraphics = w; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/CameraOnSurface": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/promiseUtils ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/Point ../cameraUtils ../PropertiesPool ./PointOfInterest".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = Array; a.CameraOnSurface = function (x) {
            function k(A) { A = x.call(this, A) || this; A._dirty = !1; A._propertiesPool = new v.PropertiesPool({ location: f, renderLocation: e }, w._assertThisInitialized(A)); A._estimatedSurfaceAltitude = 0; A._pendingElevationQueryController = null; A.cameraName = "camera"; A.renderLocation = d.create(); A.tmpPoint = new f; return A } w._inheritsLoose(k, x); var r = k.prototype; r.initialize = function () {
            this.scheduler && this.handles.add(this.scheduler.registerTask(this.task,
              this)); this.runTask(); if (this.map) { const A = () => this._setDirty(); this.handles.add(u.on(this.map, "ground.layers", "change", A, A, A)) } this._updateRenderLocation()
            }; r.destroy = function () { this._cancelPendingRequest(); this._propertiesPool.destroy(); this._propertiesPool = null }; r.updateRenderLocation = function () { this._setDirty(); this._updateRenderLocation() }; r._setDirty = function () { this._dirty || (this._dirty = !0, this.notifyChange("updating")) }; r._cancelPendingRequest = function () {
              const A = this._pendingElevationQueryController;
              A && (this._pendingElevationQueryController = null, A.abort(), this.notifyChange("updating"))
            }; r.runTask = function () {
              this._cancelPendingRequest(); this._dirty = !1; this.notifyChange("updating"); if (this.map && this.map.ground) {
                this.renderCoordsHelper.fromRenderCoords(this._camera.eye, this.tmpPoint, this.state.spatialReference); var A = new AbortController; this.map.ground.queryElevation(this.tmpPoint, { signal: A.signal, cache: this.cache }).then(z => this._updateSurfaceAltitude(z.geometry.z)).catch(z => {
                  q.isAbortError(z) ||
                  this._updateSurfaceAltitude(0)
                }).catch(() => { }).then(() => { this._pendingElevationQueryController === A && (this._pendingElevationQueryController = null, this.notifyChange("updating")); A = null }); this._pendingElevationQueryController = A
              } else this._updateSurfaceAltitude(0)
            }; r._updateSurfaceAltitude = function (A) { this._estimatedSurfaceAltitude !== A && (this._estimatedSurfaceAltitude = A, this._updateRenderLocation()) }; r._updateRenderLocation = function () {
              this.renderCoordsHelper.setAltitude(g, this._estimatedSurfaceAltitude,
                this._camera.eye); b.exactEquals(this._get("renderLocation"), g) || this._set("renderLocation", b.copy(this._propertiesPool.get("renderLocation"), g))
            }; w._createClass(k, [{ key: "_camera", get: function () { return this.state[this.cameraName] } }, { key: "location", get: function () { const A = this._propertiesPool.get("location"); this.renderCoordsHelper.fromRenderCoords(this.renderLocation, A, this.state.spatialReference); return A } }, {
              key: "scale", get: function () {
                const A = this._camera, z = b.distance(A.eye, this.renderLocation); return t.distanceToScale({
                  renderCoordsHelper: this.renderCoordsHelper,
                  state: { camera: A }
                }, z, 0)
              }
            }, { key: "updating", get: function () { return this._dirty || null != this._pendingElevationQueryController } }, { key: "running", get: function () { return !this._pendingElevationQueryController && this._dirty } }]); return k
          }(m.PointOfInterest); c.__decorate([y.property({ constructOnly: !0 })], a.CameraOnSurface.prototype, "scheduler", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.CameraOnSurface.prototype, "cache", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.CameraOnSurface.prototype,
            "task", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.CameraOnSurface.prototype, "cameraName", void 0); c.__decorate([y.property({ readOnly: !0 })], a.CameraOnSurface.prototype, "location", null); c.__decorate([y.property({ constructOnly: !0 })], a.CameraOnSurface.prototype, "map", void 0); c.__decorate([y.property({ readOnly: !0 })], a.CameraOnSurface.prototype, "renderLocation", void 0); c.__decorate([y.property({ readOnly: !0 })], a.CameraOnSurface.prototype, "scale", null); c.__decorate([y.property({ readOnly: !0 })],
              a.CameraOnSurface.prototype, "updating", null); a.CameraOnSurface = c.__decorate([h.subclass("esri.views.3d.support.CameraOnSurface")], a.CameraOnSurface); const g = d.create(); a.default = a.CameraOnSurface; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/PointOfInterest": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
        a.PointOfInterest = function (b) { function d(f) { f = b.call(this, f) || this; f.handles = new u; return f } w._inheritsLoose(d, b); d.prototype.destroy = function () { this.handles.destroy() }; return d }(q); c.__decorate([y.property({ constructOnly: !0 })], a.PointOfInterest.prototype, "renderCoordsHelper", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.PointOfInterest.prototype, "surface", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.PointOfInterest.prototype, "state", void 0); a.PointOfInterest =
          c.__decorate([h.subclass("esri.views.3d.support.PointOfInterest")], a.PointOfInterest); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/CenterOnSurface": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/mathUtils ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/Point ../../../../geometry/projection ../../../../geometry/projectionEllipsoid ../../../../geometry/support/aaBoundingRect ../debugFlags ../PropertiesPool ./PointOfInterest".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
          const k = Array; a.CenterOnSurface = function (B) {
            function C(E) { E = B.call(this, E) || this; E._propertiesPool = new g.PropertiesPool({ location: f, renderLocation: k }, w._assertThisInitialized(E)); E._currentSurfaceAltitude = 0; E._latestSurfaceAltitude = 0; E.cameraName = "camera"; E.distance = 0; E.renderLocation = d.create(); E.updating = !1; return E } w._inheritsLoose(C, B); var D = C.prototype; D.initialize = function () { this._frameWorker = this.scheduler.registerTask(this.task, this); this.runTask() };
            D.destroy = function () { this._frameWorker && (this._frameWorker.remove(), this._frameWorker = null); this._propertiesPool.destroy(); this._propertiesPool = null }; D.updateRenderLocation = function () { this.updating = !0; this._updateRenderLocation() }; D.runTask = function () { this._latestSurfaceAltitude = this.estimateSurfaceAltitudeAtCenter(); this._updateRenderLocation(); this.updating = !1 }; D._updateRenderLocation = function () {
              const E = r; let H = this.calculateSurfaceIntersection(this._currentSurfaceAltitude, E); var J = this._currentSurfaceAltitude !==
                this._latestSurfaceAltitude; !H && J && (H = this.calculateSurfaceIntersection(this._latestSurfaceAltitude, E)) && (this._currentSurfaceAltitude = this._latestSurfaceAltitude); J = A; H && this.latestSurfaceAltitudeChangesDistanceSignificantly(E, J) && (b.copy(E, J), this._currentSurfaceAltitude = this._latestSurfaceAltitude); H ? this.distance = b.distance(this._camera.eye, E) : (b.scale(E, this._camera.viewForward, this._get("distance")), b.add(E, E, this._camera.eye)); b.exactEquals(this._get("renderLocation"), E) || this._set("renderLocation",
                  b.copy(this._propertiesPool.get("renderLocation"), E))
            }; D.calculateSurfaceIntersection = function (E, H) {
              var J = this._camera; if (!this.renderCoordsHelper.intersectManifold(J.ray, E, H)) return !1; if (this.state.isGlobal) { const M = v.getReferenceEllipsoid(this.renderCoordsHelper.spatialReference).radius; E = M + E; const F = b.squaredLength(J.eye), K = F < E * E, P = b.distance(J.eye, H); K && P > M / 4 && (b.scale(H, J.viewForward, E - Math.sqrt(F)), b.add(H, H, J.eye)) } else J = this.surface.ready ? this.surface.extent : null, u.isSome(J) && t.projectBoundingRect(J,
                this.surface.spatialReference, z, this.renderCoordsHelper.spatialReference) && (H[0] = q.clamp(H[0], z[0], z[2]), H[1] = q.clamp(H[1], z[1], z[3])); return !0
            }; D.latestSurfaceAltitudeChangesDistanceSignificantly = function (E, H) { if (this._latestSurfaceAltitude === this._currentSurfaceAltitude || null == E) return !1; if (this.calculateSurfaceIntersection(this._latestSurfaceAltitude, H)) { if (e.TESTS_DISABLE_OPTIMIZATIONS) return !0; const J = this._camera.eye; E = b.distance(J, E); H = b.distance(J, H); if (.05 < Math.abs(H - E) / E) return !0 } return !1 };
            w._createClass(C, [{ key: "_camera", get: function () { return this.state[this.cameraName] } }, { key: "location", get: function () { const E = this._propertiesPool.get("location"); this.renderCoordsHelper.fromRenderCoords(this.renderLocation, E, this.state.spatialReference); return E } }, { key: "estimatedSurfaceAltitude", get: function () { return this._latestSurfaceAltitude } }, { key: "running", get: function () { return this.updating } }]); return C
          }(x.PointOfInterest); c.__decorate([y.property({ constructOnly: !0 })], a.CenterOnSurface.prototype,
            "scheduler", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.CenterOnSurface.prototype, "task", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.CenterOnSurface.prototype, "cameraName", void 0); c.__decorate([y.property()], a.CenterOnSurface.prototype, "distance", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.CenterOnSurface.prototype, "estimateSurfaceAltitudeAtCenter", void 0); c.__decorate([y.property({ readOnly: !0 })], a.CenterOnSurface.prototype, "location", null); c.__decorate([y.property({ readOnly: !0 })],
              a.CenterOnSurface.prototype, "renderLocation", void 0); c.__decorate([y.property()], a.CenterOnSurface.prototype, "updating", void 0); a.CenterOnSurface = c.__decorate([h.subclass("esri.views.3d.support.CenterOnSurface")], a.CenterOnSurface); const r = d.create(), A = d.create(), z = m.create(); a.default = a.CenterOnSurface; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/ContentGeometryUpdates": function () {
      define(["exports", "../../../../core/Evented", "../../../../core/Handles"],
        function (a, w, c) {
          let q = function () {
            function y(p) { this.handles = new c; this.events = new w; this.contentLayerViews = p.contentLayerViews; this.handles.add(this.contentLayerViews.on("change", l => this.layerViewsChanged(l))); this.layerViewsChanged({ added: this.contentLayerViews.toArray(), removed: [], moved: [], target: this.contentLayerViews }) } var n = y.prototype; n.destroy = function () { this.handles && (this.handles.destroy(), this.handles = null) }; n.layerViewsChanged = function (p) {
              p.added.forEach(l => {
              "esri.views.3d.layers.SceneLayerView3D" ===
                l.declaredClass && this.handles.add(l.on("visible-geometry-changed", () => this.contentChanged()), l.uid)
              }); p.removed.forEach(l => this.handles.remove(l.uid))
            }; n.contentChanged = function () { this.events.emit("request-update", u) }; return y
          }(); const u = {}; a.ContentGeometryUpdates = q; a.default = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/Focus": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/mathUtils ../../../../core/screenUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/Point ../../../../geometry/support/ray ../PropertiesPool ./PointOfInterest ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          const g = Array; a.Focus = function (A) {
            function z(C) { C = A.call(this, C) || this; C._propertiesPool = new v.PropertiesPool({ location: f, renderLocation: g }, w._assertThisInitialized(C)); C._dirty = !0; C.renderLocation = C._propertiesPool.get("renderLocation"); return C } w._inheritsLoose(z, A); var B = z.prototype; B.initialize = function () {
              this.handles.add([this.centerOnSurface.watch("renderLocation", () => this.updateRenderLocation()), this.state.watch("contentCamera", () => this.updateRenderLocation())]);
              this.scheduler && this.handles.add(this.scheduler.registerTask(e.TaskPriority.POINT_OF_INTEREST_FREQUENT, this))
            }; B.destroy = function () { this._propertiesPool.destroy(); this._propertiesPool = null }; B.runTask = function () {
              var C = this._get("renderLocation"); const D = this.centerOnSurface.renderLocation; var E = this.renderCoordsHelper, H = this.state.contentCamera; this._dirty = !1; E.worldUpAtPosition(D, x); E = Math.max(0, (Math.acos(b.dot(x, H.viewForward)) - .5 * Math.PI) * (H.aboveGround ? 1 : -1)); Number.isNaN(E) ? C && b.equals(C, D) ||
                (C = this._propertiesPool.get("renderLocation"), b.copy(C, D), this._set("renderLocation", C)) : (E = 1 - q.clamp(E / (.5 * Math.PI), 0, 1), E *= E * E, this._calculateScreenHorizontalEdgeOnSurface(r), H = this._propertiesPool.get("renderLocation"), b.lerp(H, D, r, E), C && b.equals(C, H) || this._set("renderLocation", H))
            }; B._calculateScreenHorizontalEdgeOnSurface = function (C) {
              const D = this.state.contentCamera; var E = D.getRenderCenter(u.createRenderScreenPointArray3()); E[1] = D.aboveGround ? D.padding[2] : D.fullHeight - D.padding[0]; if (this.estimateSurfaceIntersectionAtRenderPoint(E,
                C)) return C; const H = this.renderCoordsHelper.getAltitude(this.centerOnSurface.renderLocation); return D.unprojectFromRenderScreen(E, k) && (b.subtract(k, k, D.eye), E = b.normalize(k, k), this.renderCoordsHelper.intersectManifold(t.wrap(D.eye, E), H, C)) ? C : this.renderCoordsHelper.setAltitude(C, H, D.eye)
            }; B.updateRenderLocation = function () { this._dirty = !0 }; w._createClass(z, [{ key: "updating", get: function () { return this._dirty || this.centerOnSurface.updating } }, {
              key: "location", get: function () {
                const C = this._propertiesPool.get("location");
                this.renderCoordsHelper.fromRenderCoords(this.renderLocation, C, this.state.spatialReference); return C
              }
            }, { key: "running", get: function () { return this._dirty } }]); return z
          }(m.PointOfInterest); c.__decorate([y.property()], a.Focus.prototype, "_dirty", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.Focus.prototype, "scheduler", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.Focus.prototype, "centerOnSurface", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.Focus.prototype, "estimateSurfaceIntersectionAtRenderPoint",
            void 0); c.__decorate([y.property({ readOnly: !0 })], a.Focus.prototype, "updating", null); c.__decorate([y.property({ readOnly: !0 })], a.Focus.prototype, "location", null); c.__decorate([y.property({ readOnly: !0 })], a.Focus.prototype, "renderLocation", void 0); a.Focus = c.__decorate([h.subclass("esri.views.3d.support.CenterOnSurface")], a.Focus); const x = d.create(), k = d.create(), r = d.create(); a.default = a.Focus; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/StableSurfaceCenter": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3f64 ../../../../geometry/Point ../../../../geometry/support/aaBoundingRect".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
        a.StableSurfaceCenter = function (e) {
          function g(k) { k = e.call(this, k) || this; k.location = null; k._updateController = null; k._handles = new u; return k } w._inheritsLoose(g, e); var x = g.prototype; x.initialize = function () { this.view.state.isLocal && (this._handles.add([this.watch(["surfaceView.spatialReference", "surfaceView.extent"], () => this._update()), p.on(this, "surface.layers", "change", () => this._update())]), this._update()) }; x.destroy = function () { this._handles.destroy() }; x._update =
            function () {
            this._updateController && (this._updateController.abort(), this._updateController = null); if (this.surfaceView && !y.isNone(this.surfaceView.extent) && this.surfaceView.spatialReference) {
              var k = m.center(this.surfaceView.extent); k = new v({ x: k[0], y: k[1], z: 0, spatialReference: this.surfaceView.spatialReference }); this.surface && 0 < this.surface.layers.length ? (this._set("location", null), this._updateController = new AbortController, this.surface.queryElevation(k, {
                noDataValue: 0, signal: this._updateController.signal,
                cache: this.cache
              }).then(r => { this._updateController = null; this._set("location", r.geometry) }).catch(r => { n.isAbortError(r) || r && "elevation-query:invalid-layer" === r.name || console.error("StableSurfaceCenter failed to update: ", r) })) : this._set("location", k)
            } else this._set("location", null)
            }; w._createClass(g, [{ key: "renderLocation", get: function () { if (!this.location) return null; const k = t.create(); this.view.renderCoordsHelper.toRenderCoords(this.location, k); return k } }]); return g
        }(q); c.__decorate([l.property({ constructOnly: !0 })],
          a.StableSurfaceCenter.prototype, "view", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.StableSurfaceCenter.prototype, "cache", void 0); c.__decorate([l.property({ readOnly: !0, aliasOf: "view.map.ground" })], a.StableSurfaceCenter.prototype, "surface", void 0); c.__decorate([l.property({ readOnly: !0, aliasOf: "view.basemapTerrain" })], a.StableSurfaceCenter.prototype, "surfaceView", void 0); c.__decorate([l.property({ readOnly: !0 })], a.StableSurfaceCenter.prototype, "location", void 0); c.__decorate([l.property({ readOnly: !0 })],
            a.StableSurfaceCenter.prototype, "renderLocation", null); a.StableSurfaceCenter = c.__decorate([f.subclass("esri.views.3d.terrain.StableSurfaceCenter")], a.StableSurfaceCenter); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/pointsOfInterest/SurfaceGeometryUpdates": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/Handles ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingRect ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        a.SurfaceGeometryUpdates = function (x) {
          function k() { var A = x.apply(this, arguments) || this; A.handles = new y; A._tileGeometryUpdateExtent = f.empty(); A._tileGeometryUpdateSpatialReference = null; A.events = new u; A.updating = !1; return A } w._inheritsLoose(k, x); var r = k.prototype; r.initialize = function () { this.handles.add([this.surface.on("elevation-change", A => this._tileGeometryChanged(A)), this.scheduler.registerTask(t.TaskPriority.SURFACE_GEOMETRY_UPDATES, this)]) }; r.destroy = function () {
          this.handles &&
            (this.handles.destroy(), this.handles = null)
          }; r.runTask = function () { this.updating && (this._centerIntersectsExtent(this._tileGeometryUpdateExtent, this._tileGeometryUpdateSpatialReference) && this.events.emit("request-update", v), f.empty(this._tileGeometryUpdateExtent), this._set("updating", !1)) }; r._tileGeometryChanged = function (A) { this._tileGeometryUpdateSpatialReference = A.spatialReference; f.expand(this._tileGeometryUpdateExtent, A.tile.extent, this._tileGeometryUpdateExtent); this._set("updating", !0) }; r._furthestCenterOnSurface =
            function () { let A = this.centerOnSurfaces[0]; for (let z = 1; z < this.centerOnSurfaces.length; z++) { const B = this.centerOnSurfaces[z]; B.distance > A.distance && (A = B) } return A }; r._centerIntersectsExtent = function (A, z) {
              const B = this.state.camera.eye, C = g, D = this._furthestCenterOnSurface(); this.renderCoordsHelper.fromRenderCoords(B, m, z); this.renderCoordsHelper.fromRenderCoords(D.renderLocation, e, z); m[0] < e[0] ? (C[0] = m[0], C[2] = e[0]) : (C[0] = e[0], C[2] = m[0]); m[1] < e[1] ? (C[1] = m[1], C[3] = e[1]) : (C[1] = e[1], C[3] = m[1]); return f.intersects(C,
                A)
            }; w._createClass(k, [{ key: "running", get: function () { return this.updating } }]); return k
        }(q); c.__decorate([n.property({ constructOnly: !0 })], a.SurfaceGeometryUpdates.prototype, "state", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.SurfaceGeometryUpdates.prototype, "centerOnSurfaces", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.SurfaceGeometryUpdates.prototype, "renderCoordsHelper", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.SurfaceGeometryUpdates.prototype, "scheduler", void 0);
          c.__decorate([n.property({ constructOnly: !0 })], a.SurfaceGeometryUpdates.prototype, "surface", void 0); c.__decorate([n.property({ readOnly: !0 })], a.SurfaceGeometryUpdates.prototype, "updating", void 0); a.SurfaceGeometryUpdates = c.__decorate([b.subclass("esri.views.3d.support.SurfaceGeometryUpdates")], a.SurfaceGeometryUpdates); const v = {}, m = d.create(), e = d.create(), g = f.empty(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/TerrainSurface": function () {
      define("require ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/Accessor ../../../core/arrayUtils ../../../core/CollectionFlattener ../../../core/Evented ../../../core/Handles ../../../core/Logger ../../../core/mathUtils ../../../core/maybe ../../../core/ObjectPool ../../../core/PooledArray ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/aliasOf ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/decorators/subclass ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4f64 ../../../geometry/projection ../../../geometry/projectionEllipsoid ../../../geometry/support/aaBoundingRect ../../../geometry/support/frustum ../../../layers/mixins/RefreshableLayer ../../../layers/support/ElevationQueryTileCache ../../../layers/support/layerUtils ../../../layers/support/LercDecoder ../../2d/engine/vectorTiles/VectorTile ../layers/ElevationLayerView3D ../support/cameraUtils ../support/debugFlags ../support/extentUtils ../support/updatingProperties ./ElevationBounds ./ElevationData ./ExtentHelper ./LayerClass ./OverlayManager ./PlanarPatch ./SphericalPatch ./TerrainConst ./TerrainRenderer ./TerrainSurfacePerformanceInfo ./terrainUtils ./Tile ./TilePerLayerInfo ./tileUtils ./TilingSchemeLogic ./UpsampleInfo ../../support/Scheduler ../../support/WatchUpdatingTracking".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q, T, da, Y, fa, ha, ka, ea, ba, aa, W, U, X, Z, ia, la, ma, ra, Aa) {
          function za(Ha, Oa) { return Ha[0] === Oa[0] && Ha[1] === Oa[1] && Ha[2] === Oa[2] } function Ka(Ha) { return Ha.isLeaf ? !1 : Ha.children[0].shouldLoad || Ha.children[1].shouldLoad || Ha.children[2].shouldLoad || Ha.children[3].shouldLoad || Ka(Ha.children[0]) || Ka(Ha.children[1]) || Ka(Ha.children[2]) || Ka(Ha.children[3]) } const Ea = h.getLogger("esri.views.3d.terrain.TerrainSurface"); u = function (Ha) {
            function Oa(sa) {
              var Ca =
                Ha.call(this, sa) || this; Ca._elevationBounds = new T.ElevationBounds; Ca._iteratorPool = new f(ia.IteratorPreorder, Ja => Ja.remove = () => Ca._iteratorPool.release(Ja)); Ca._postorderIterator = new ia.IteratorPostorder; Ca._hasPendingUpdates = !1; Ca._pendingUpdates = 0; Ca._asyncWorkItems = 0; Ca._allTilesDirty = !0; Ca._allTilesSorted = !0; Ca._visible = !1; Ca._usedMemory = -1; Ca._performanceInfo = new W; Ca._viewChanged = !1; Ca._inFrameTask = !1; Ca._viewChangeUpdateDirty = !1; Ca._eyePosRenderSR = D.create(); Ca._eyePosSurfaceSR = D.create(); Ca._splitLimits =
                  new X.SplitLimits; Ca._snapLevel = Infinity; Ca._frustum = F.create(); Ca._viewProjectionMatrix = B.create(); Ca._layerViews = [[], []]; Ca._layerIndexByUid = [new Map, new Map]; Ca._basemapLayerViewHandles = new Map; Ca._handles = new l; Ca._watchUpdatingTracking = new Aa.WatchUpdatingTracking; Ca._frameTask = ra.ImmediateTask; Ca._allTiles = new t; Ca._upsampleInfoPool = new f(ma.UpsampleInfo); Ca._rootTilesExtent = M.create(); Ca._maxNumUpdating = 1; Ca.maxTextureScale = 1.2; Ca.backgroundImage = ba.DEFAULT_TILE_BACKGROUND; Ca.backgroundColor =
                    null; Ca._layerViewsDirty = !1; return Ca
            } w._inheritsLoose(Oa, Ha); var Ba = Oa.prototype; Ba.initialize = function () {
            this._lercDecoder = N.acquireDecoder(this.view.resourceController); this._tilePool = this.view.state.isLocal ? new f(ka.PlanarPatch) : new f(ea.SphericalPatch); var sa = this.view.resourceController.memoryController; this._upsampleMapCache = sa.newCache("esri.views.3d.terrain.upsample", Ca => Ca.unloadMapData()); this._elevationQueryCache = new P.ElevationQueryTileCache(sa.newCache("elevation-query")); this._set("overlayManager",
              new ha.OverlayManager({ surface: this })); this._handles.add([this.watch("overlayManager.hasHighlights", Ca => this._renderer.setNeedsHighlight(Ca)), this.watch("overlayManager.rendersOccluded", Ca => this._renderer.setRenderOccludedOverlay(Ca))], "overlayManager"); this._renderer = new aa({ overlayRenderer: this.overlayManager.renderer, ellipsoidRadius: J.getReferenceEllipsoid(this.view.spatialReference).radius, stage: this.view._stage, allTiles: this._allTiles }); this._handles.add([e.init(this, "baseOpacity", Ca => {
                this._handleLayerViewChanges();
                this._updateBaseOpacity(Ca)
              }, !0), e.init(this, "_background", () => { this._handleLayerViewChanges(); this._renderer.setTileBackground(this._background) }, !0), this.view.watch("pointsOfInterest", Ca => { this._renderer.pointsOfInterest = Ca; this._watchUpdatingTracking.removeAll(); Ca && this._watchUpdatingTracking.add(Ca.focus, "renderLocation", () => () => this._allTilesSorted = !1) }), e.init(R, "TERRAIN_TILE_TREE_SHOW_TILES", Ca => {
                Ca && !this._treeDebugger ? (new Promise((Ja, ca) => a(["../layers/support/TerrainTileTree3DDebugger"],
                  Ja, ca))).then(({ TerrainTileTree3DDebugger: Ja }) => { !this._treeDebugger && R.TERRAIN_TILE_TREE_SHOW_TILES && (this._treeDebugger = new Ja({ view: this.view })) }) : Ca || (this._treeDebugger = d.destroyMaybe(this._treeDebugger))
              })]); this._extentHelper = Y.create(this.viewingMode, { layers: this.view.map.allLayers, layerViews: this.view.allLayerViews, viewSpatialReference: this.view.spatialReference }); sa = this.view.defaultsFromMap ? new n({
                getCollections: () => {
                  var Ca, Ja, ca; return null == (Ca = this.view) ? void 0 : null == (Ja = Ca.defaultsFromMap) ?
                    void 0 : null == (ca = Ja.mapCollections) ? void 0 : ca.map(({ layers: qa }) => qa)
                }, getChildrenFunction: Ca => Ca && "layers" in Ca ? Ca.layers : null
              }) : this.view.map.allLayers; sa = new la.TilingSchemeLogic({ layers: sa, extentHelper: this._extentHelper, viewingMode: this.viewingMode, viewSpatialReference: this.view.spatialReference }); this._set("tilingSchemeLogic", sa); this._updateTilingScheme(); this._elevationDataRequester = this.view.resourceController.createStreamDataRequester(0); this._mapDataRequester = this.view.resourceController.createStreamDataRequester(1);
              this._frameTask = this.view.resourceController.scheduler.registerTask(ra.TaskPriority.TERRAIN_SURFACE, this); this.view.resourceController.memoryController.events.on("quality-changed", () => this._viewChangeUpdate()); this._handles.add([e.init(this._extentHelper, "stencilEnabledExtents", Ca => this._renderer.setStencilEnabledLayerExtents(Ca)), this.tilingSchemeLogic.watch("tilingScheme", () => this._updateTilingScheme(), !0), e.init(this, "extent", () => this._updateRootTiles()), this.view.on("resize", () => this._viewChangeUpdate()),
              this.view.watch("state.camera", () => this._viewChangeUpdate(), !0), this.view.watch("state.contentCamera", () => this.view.state.fixedContentCamera && this._viewChangeUpdate(), !0), this.view.watch("qualitySettings.tiledSurface.lodBias", () => this._viewChangeUpdate()), e.init(this.view, "qualitySettings.tiledSurface.textureFadeDuration", Ca => this._renderer.textureFadingEnabled = 0 < Ca), this.view.watch("lodSnapping", () => this._viewChangeUpdate()), m.react(() => this._userClippingExtent, () => this._updateClippingExtent(), m.sync)]);
              this._handles.add(this.view.allLayerViews.on("after-changes", () => this._layerViewsDirty = !0)); this._layerViewsDirty = !0; this._handleLayerViewChanges()
            }; Ba.destroy = function () {
              this._frameTask.remove(); this._handles.destroy(); this._watchUpdatingTracking.destroy(); this._lercDecoder = d.releaseMaybe(this._lercDecoder); this._removeAllTiles(); this._upsampleMapCache = d.destroyMaybe(this._upsampleMapCache); this._elevationQueryCache = d.destroyMaybe(this._elevationQueryCache); this._set("tilingSchemeLogic", d.destroyMaybe(this.tilingSchemeLogic));
              this._extentHelper = d.destroyMaybe(this._extentHelper); this._basemapLayerViewHandles.forEach((sa, Ca) => this._unregisterTiledLayerView(Ca)); this._mapDataRequester = this._elevationDataRequester = null; this._set("overlayManager", d.destroyMaybe(this.overlayManager)); this._tilePool = d.destroyMaybe(this._tilePool); X.Tile.prune(); this._treeDebugger && (this._treeDebugger.destroy(), this._treeDebugger = null); this._renderer = d.destroyMaybe(this._renderer); this._iteratorPool = d.destroyMaybe(this._iteratorPool); this._set("view",
                null); this._upsampleInfoPool = d.destroyMaybe(this._upsampleInfoPool); G.printAllocations(); Z.printAllocations()
            }; Ba.intersect = function (sa, Ca, Ja, ca) { this._renderer.intersect(sa, Ca, Ja, ca) }; Ba.getElevation = function (sa, Ca, Ja, ca) { const qa = Ua; sa = this.getTileWithElevation(sa, Ca, Ja, ca, qa); return d.isNone(sa) ? null : da.ElevationData.sample(qa[0], qa[1], sa.renderData.geometryState.samplerData) }; Ba.getTileWithElevation = function (sa, Ca, Ja, ca, qa = Ua) {
              var Da; const na = this.rootTiles; if (d.isNone(na) || !na.length || 0 === na[0].layerInfo[0].length) return null;
              qa[0] = sa; qa[1] = Ca; qa[2] = Ja; if (!H.projectVectorToVector(qa, ca, qa, null == (Da = this.tilingScheme) ? void 0 : Da.spatialReference)) return Ea.error("TerrainSurface.getElevation(): could not project given point to tiling scheme coordinate system"), null; for (let xa of na) if (xa.containsPoint(qa)) {
                for (; xa && !xa.rendered && !xa.isLeaf;)sa = 0, qa[0] > .5 * (xa.extent[0] + xa.extent[2]) && (sa += 1), qa[1] < .5 * (xa.extent[1] + xa.extent[3]) && (sa += 2), xa = xa.children[sa]; if ((qa = xa.renderData) && qa.geometryState && qa.geometryState.samplerData) return xa;
                break
              } return null
            }; Ba.getScale = function (sa) { if (this.tilingScheme) { if (!H.projectPointToVector(sa, Ua, this.spatialReference)) return Ea.error("TerrainSurface.getScale(): could not project given point to tiling scheme coordinate system"), null; sa = this.rootTiles; if (d.isSome(sa)) for (let Ca of sa) if (Ca.containsPoint(Ua)) { for (; null != Ca.children[0];)sa = 0, Ua[0] > Ca.children[0].extent[2] && (sa += 1), Ua[1] < Ca.children[0].extent[1] && (sa += 2), Ca = Ca.children[sa]; return this._getLodBiasCorrectedScale(Ca.level) } } return 1E100 };
            Ba.getSphereScale = function (sa, Ca) {
              if (!this.tilingScheme) return null; if (!H.projectPointToVector(sa, Ua, this.spatialReference)) return Ea.error("TerrainSurface.getSphereScale(): could not project given point to tiling scheme coordinate system"), null; Ua[3] = Ca; let Ja = null; const ca = qa => { if (qa && M.intersectsSphere(qa.extent, Ua)) if (null != qa.children[0]) for (const Da of qa.children) ca(Da); else qa = this._getLodBiasCorrectedScale(qa.level), Ja = null == Ja ? qa : Math.min(Ja, qa) }; sa = this.rootTiles; if (d.isSome(sa)) for (const qa of sa) ca(qa);
              return Ja
            }; Ba.queryVisibleScaleRange = function (sa, Ca, Ja, ca) { Ca = Ca ? this.tilingScheme.levelAtScale(Ca) : 0; Ja = Ja ? this.tilingScheme.levelAtScale(Ja) : Infinity; const qa = this.lodBias; this._renderer.queryVisibleLevelRange(sa, Ca + qa, Ja + qa, ca) }; Ba._updateBaseOpacity = function (sa) {
              const Ca = this._renderer.opaque; this._renderer.opaque = 1 <= sa; this._renderer.isTransparent = this._allTransparentSurfaceLayers(); sa = Ca === this._renderer.opaque ? 2 : 1; if (1 === sa) {
                var Ja, ca; null == (Ja = this.view) ? void 0 : null == (ca = Ja._stage) ? void 0 :
                  ca.renderView.setRenderParameters({ opaqueTerrain: this.opaque })
              } this._updateTileTextures(sa)
            }; Ba._updateTilingScheme = function () { const sa = this.tilingSchemeLogic.tilingScheme; sa !== this.tilingScheme && (U.weakAssert(!!sa, "tiling scheme cannot be reset to undefined"), this.tilingScheme && this._removeAllTiles(), this._set("tilingScheme", sa), this._updateClippingExtent(), sa && (this._updateTiledLayers(), this._renderer.setTileSize(sa.pixelSize), this.overlayManager.setSpatialReference(sa.spatialReference), this._updateRootTiles())) };
            Ba._acquireTile = function (sa, Ca, Ja, ca) { const qa = this._tilePool.acquire(); ya[0] = sa; ya[1] = Ca; ya[2] = Ja; qa.init(ya, ca, this); return qa }; Ba._updateRootTiles = function () {
              const { extent: sa, tilingScheme: Ca } = this; if (Ca) {
                var Ja = Na, ca = Ca.rootTilesInExtent(sa, Ja, 5 * ba.MAX_ROOT_TILES); if (d.isSome(this.rootTiles)) {
                  if (ca.length > ba.MAX_ROOT_TILES) { Ea.warn(ba.TOO_MANY_ROOT_TILES_AFTER_CHANGE_ERROR); return } const qa = this.rootTiles.map(na => na.lij), Da = y.difference(qa, ca, za); if (0 < Da.removed.length || 0 < Da.added.length) {
                    const na =
                      this.rootTiles.filter(xa => -1 < Da.removed.findIndex(Qa => za(Qa, xa.lij)) ? (this._purgeTile(xa), !1) : !0); Da.added.forEach(xa => na.push(this._newRootTile(xa))); this._setRootTiles(na)
                  }
                } else ca.length > ba.MAX_ROOT_TILES && (Ea.warn(ba.TOO_MANY_ROOT_TILES_FOR_LAYER_ERROR), ca = Ca.rootTilesInExtent(sa, Ja, ba.MAX_ROOT_TILES)), this._setRootTiles(ca.map(qa => this._newRootTile(qa))); M.equals(Ja, this._rootTilesExtent) || (this._rootTilesExtent = M.create(Ja)); this.visible = !0; this._viewChangeUpdate(); this.overlayManager.setPlacementDirty();
                this.notifyChange("ready")
              }
            }; Ba._newRootTile = function (sa) { sa = this._acquireTile(0, sa[1], sa[2], null); 2 === sa.shouldSplit(this._splitLimits, this._eyePosRenderSR, this.lodSnapping) && sa.setPendingUpdate(2); this._loadTile(sa); return sa }; Ba._setRootTiles = function (sa) { this._set("rootTiles", sa); this._allTiles.clear(); if (d.isSome(sa)) { const Ca = this._iteratorPool.acquire(); for (Ca.reset(sa); !Ca.done;)this._allTiles.push(Ca.next()); Ca.remove() } this._renderer.setRootTiles(this.rootTiles); this._updateTilesVisibility(sa) };
            Ba._runViewChangeUpdateIfDirty = function () { this._viewChangeUpdateDirty && (this._viewChangeUpdateDirty = !1, this._viewChangeUpdate()) }; Ba._viewChangeUpdate = function () { this.view && !this.suspended && this.tilingScheme && this._visible && (this._inFrameTask ? this._viewChangeUpdateDirty = !0 : (this._viewChangeUpdateDirty = !1, this._updateViewDependentParameters(), this._updateSkirts(), this._updateTilesVisibility(this.rootTiles))) }; Ba._updateClippingStatus = function (sa) {
              sa.updateClippingStatus(this.extent) && sa.resetPendingUpdate(32) &&
              this._updateTileGeometry(sa)
            }; Ba._updateTilesVisibility = function (sa) {
              if (!d.isNone(sa)) {
                var Ca = ia.hasLoadableSiblings(sa), Ja = Ca ? this._elevationBounds.min : Infinity; Ca = Ca ? this._elevationBounds.max : -Infinity; var ca = this.view.state.fixedContentCamera, qa = this.extent, Da = this._viewProjectionMatrix; this.setTileTreeDirty(); var na = this._iteratorPool.acquire(); for (na.reset(sa); !na.done;) {
                  sa = na.next(); sa.updateClippingStatus(qa) && sa.resetPendingUpdate(32) && this._updateTileGeometry(sa); sa.setPendingUpdate(16);
                  const xa = sa.updateVisibilityNow(); ca || xa ? (sa.updateScreenDepth(Da), sa.renderData && (Ja = Math.min(sa.elevationBounds[0], Ja), Ca = Math.max(sa.elevationBounds[1], Ca))) : na.skipSubtree()
                } na.remove(); this._allTilesDirty = this._viewChanged = !0; isFinite(Ja) && isFinite(Ca) && (this._elevationBounds.min !== Ja || this._elevationBounds.max !== Ca) && (this._elevationBounds.min = Ja, this._elevationBounds.max = Ca, this.emit("elevation-bounds-change", null))
              }
            }; Ba._updateViewDependentParameters = function () {
              const sa = this.view.state.camera,
              Ca = this.view.state.contentCamera, Ja = Math.tan(.5 * Ca.fovX), ca = Math.tan(.5 * Ca.fovY), qa = this.tilingScheme.pixelSize, Da = 2 ** -this.lodBias * sa.pixelRatio; this._splitLimits.aboveGround = sa.aboveGround; this._splitLimits.fovX = Ja; this._splitLimits.fovY = ca; this._splitLimits.relativeWidthLimit = qa / sa.width * this.maxTextureScale * Da; this._splitLimits.relativeHeightLimit = qa / sa.height * this.maxTextureScale * Da; this._splitLimits.maxLod = this.tilingScheme.getMaxLod(); this._splitLimits.angledSplitBias = this.view.qualitySettings.tiledSurface.angledSplitBias;
              this.view.state.fixedContentCamera ? (d.isNone(this._splitLimits.frustum) && (this._splitLimits.frustum = F.create()), F.copy(Ca.frustum, this._splitLimits.frustum)) : this._splitLimits.frustum = null; F.copy(sa.frustum, this._frustum); z.multiply(this._viewProjectionMatrix, Ca.projectionMatrix, Ca.viewMatrix); C.copy(this._eyePosRenderSR, Ca.eye); H.projectVectorToVector(sa.eye, this.view.renderSpatialReference, this._eyePosSurfaceSR, this.spatialReference)
            }; Ba._updateSkirts = function () {
              const sa = this.view.state.camera;
              this.skirtScale = U.computeSkirtScale(this, this._eyePosSurfaceSR, this.view.state.constraints.collision.enabled ? 0 : 1.11 * sa.near)
            }; Ba._updateRenderData = function (sa) { sa.rendered && !sa.shouldLoad && (Ka(sa) ? this._loadChildren(sa) : sa.isLeaf && sa.parent && sa.parent.shouldLoad && this._loadParent(sa)) }; Ba._updateTileGeometry = function (sa) { sa.updateVisibility(); this._renderer.updateTileGeometry(sa); this._elevationUpdate(sa); this._usedMemory = -1 }; Ba._updateTileTexture = function (sa, Ca) {
              const Ja = sa.resetPendingUpdate(128) ?
                128 : sa.resetPendingUpdate(64) ? 64 : !1; Ja && (this._renderer.updateTileTexture(sa, Ja), this._usedMemory = -1, Ca.madeProgress())
            }; Ba._elevationUpdate = function (sa) { wa.spatialReference = this.spatialReference; wa.tile = sa; wa.extent = sa.extent; this.emit("elevation-change", wa); M.containsPoint(sa.extent, this._eyePosSurfaceSR) && this._updateSkirts() }; Ba.runTask = function (sa) {
              this._handleLayerViewChanges(sa); this._frameTask.processQueue(sa); this._inFrameTask = !0; this._pendingUpdates = 0; this._hasPendingUpdates = !1; this._updateTileStatus(sa);
              this._sortTiles(sa); const Ca = !this.view.state.fixedContentCamera; this._mergeAndSplit(sa, Ca); sa.run(() => this._updateElevation(sa)); sa.run(() => this._updateTextures(sa)); Ca || this._mergeAndSplit(sa, !0); this._inFrameTask = !1; this._runViewChangeUpdateIfDirty(); sa.done && this.requestUpdate(); this.notifyChange("updatingProgressValue")
            }; Ba._updateTileStatus = function (sa) {
              if (this._viewChanged && this.rootTiles && !sa.done) {
              this._viewChanged = !1; var Ca = this._iteratorPool.acquire(); for (Ca.reset(this.rootTiles); !Ca.done;) {
                var Ja =
                  Ca.next(); if (Ja.loadable) { var ca = Ja.shouldSplit(this._splitLimits, this._eyePosRenderSR, this.lodSnapping); if (2 === ca) { Ja.resetPendingUpdate(8); Ja.isLeaf && (Ja.setPendingUpdate(2), Ca.skipSubtree()); continue } Ja.resetPendingUpdate(2) && Ja.updateAgentSuspension(); 4 === ca && Ja.updateAgents(0) } Ca.skipSubtree(); if (!Ja.isLeaf) {
                    Ja.setPendingUpdate(8); Ja.resetPendingUpdate(2); ca = this._iteratorPool.acquire(); ca.resetOne(Ja); for (Ja = ca.next(); !ca.done; Ja = ca.next())this._updateClippingStatus(Ja), Ja.updateVisibility(),
                      Ja.loadable && Ja.updateScreenDepth(this._viewProjectionMatrix); ca.remove()
                  }
              } Ca.remove(); this.requestUpdate(); sa.madeProgress()
              }
            }; Ba._sortTiles = function (sa) { sa.done || this._allTilesSorted || (ia.sortTilesByPOI(this._allTiles, this.view.pointsOfInterest.focus.renderLocation), this._allTilesSorted = !0, this._treeDebugger && this._treeDebugger.update(), sa.madeProgress()) }; Ba._mergeAndSplit = function (sa, Ca) {
              if (!this.suspended && !sa.done && this._allTilesDirty) {
              this._allTilesDirty = !1; this.requestUpdate(); for (var Ja =
                0; !sa.done;) {
                  let ca = !1; Ja = 0; const qa = !this._allTiles.some(Da => { Ja += Da.usedMemory; if (Da.resetPendingUpdate(8)) { if (!Ca) return Da.setPendingUpdate(8), sa.done; this._mergeTile(Da); ca = !0; sa.madeProgress() } else Da.resetPendingUpdate(2) && (this._splitTile(Da), ca = !0, sa.madeProgress()); !sa.done && Da.resetPendingUpdate(16) && (this._updateRenderData(Da), sa.madeProgress()); return sa.done }); ca && (this._allTilesSorted = !1, this._allTilesDirty = !0); if (qa) { this._usedMemory = Ja; if (!ca) break; this._updateTilesVisibility(this.rootTiles) } else this._allTilesDirty =
                    !0
              } 0 === Ja && (this._allTilesDirty = !0); this._sortTiles(sa)
              }
            }; Ba._updateElevation = function (sa) { this._allTiles.some(Ca => { Ca.resetPendingUpdate(32) && (this._updateTileGeometry(Ca), this._updateTileTexture(Ca, sa), sa.madeProgress()); return sa.done }); return sa.hasProgressed }; Ba._updateTextures = function (sa) { this._allTiles.some(Ca => { this._updateTileTexture(Ca, sa); return sa.done }); return sa.hasProgressed }; Ba._updateClippingExtent = function () {
            this.spatialReference && (this.updateTileOverlayParams(1), this.overlayManager.setPlacementDirty(),
              this._updateRootTiles())
            }; Ba._getLodBiasCorrectedScale = function (sa) { const Ca = this.tilingScheme.levels; sa = b.clamp(sa - this.lodBias, 0, Ca.length - 1); const Ja = sa - Math.floor(sa); return Ca[Math.floor(sa)].scale * (1 - Ja) + Ca[Math.ceil(sa)].scale * Ja }; Ba._removeAllTiles = function () { d.isSome(this.rootTiles) && (this.rootTiles.forEach(sa => this._purgeTile(sa)), this._setRootTiles(null), this.notifyChange("ready")); this._allTiles.clear(); this.visible = !1 }; Ba._purgeChildTiles = function (sa) {
              if (sa.isLeaf) return !1; let Ca = this._purgeTile(sa.children[0]);
              Ca = this._purgeTile(sa.children[1]) || Ca; Ca = this._purgeTile(sa.children[2]) || Ca; Ca = this._purgeTile(sa.children[3]) || Ca; sa.unsetChildren(); return Ca
            }; Ba._purgeTile = function (sa) { const Ca = this._purgeChildTiles(sa) || sa.rendered; this._allTiles.removeUnordered(sa); sa.unload(this._renderer); this._tilePool.release(sa); return Ca }; Ba._splitTile = function (sa) {
              U.weakAssert(sa.isLeaf, "tile that is already split should not be split again!"); const Ca = sa.level + 1, Ja = 2 * sa.lij[1], ca = 2 * sa.lij[2]; sa.setChildren(this._createTile(Ca,
                Ja, ca, sa), this._createTile(Ca, Ja, ca + 1, sa), this._createTile(Ca, Ja + 1, ca, sa), this._createTile(Ca, Ja + 1, ca + 1, sa)); sa.setPendingUpdate(16); sa.updateAgentSuspension(); this._allTiles.pushArray(sa.children); this._allTilesDirty = !0; this._emitTileScaleChange(sa, Ca); ++this._performanceInfo.numSplit
            }; Ba._emitTileScaleChange = function (sa, Ca = sa.level) { Ia.spatialReference = this.spatialReference; Ia.extent = sa.extent; Ia.scale = this._getLodBiasCorrectedScale(Ca); this.emit("scale-change", Ia) }; Ba._createTile = function (sa, Ca,
              Ja, ca) { U.weakAssert(!!ca, "_createTile sanity check"); sa = this._acquireTile(sa, Ca, Ja, ca); sa.updateClippingStatus(this.extent); sa.loadable && (sa.updateScreenDepth(this._viewProjectionMatrix), 2 === sa.shouldSplit(this._splitLimits, this._eyePosRenderSR, this.lodSnapping) && sa.setPendingUpdate(2)); return sa }; Ba._mergeTile = function (sa) {
                U.weakAssert(!sa.hasPendingUpdate(2), "_mergeTile sanity check"); this._purgeChildTiles(sa) && (U.weakAssert(!sa.renderData, "_mergeTile sanity check"), this._loadTile(sa)); this._allTilesDirty =
                  !0; ++this._performanceInfo.numMerged; this._emitTileScaleChange(sa)
              }; Ba._loadChildren = function (sa) { U.weakAssert(sa.rendered, "parent should be rendered"); sa.unload(this._renderer); this._loadTile(sa.children[0]); this._loadTile(sa.children[1]); this._loadTile(sa.children[2]); this._loadTile(sa.children[3]) }; Ba._loadParent = function (sa) { sa = sa.parent; this._unloadChildren(sa); this._loadTile(sa) }; Ba._unloadChildren = function (sa) {
              sa.isLeaf || (this._unloadChildren(sa.children[0]), sa.children[0].unload(this._renderer),
                this._unloadChildren(sa.children[1]), sa.children[1].unload(this._renderer), this._unloadChildren(sa.children[2]), sa.children[2].unload(this._renderer), this._unloadChildren(sa.children[3]), sa.children[3].unload(this._renderer))
              }; Ba._loadTile = function (sa) { sa.load(this._renderer); sa.setPendingUpdate(16); this.requestUpdate(); this._allTilesDirty = !0; this.overlayManager && this.overlayManager.hasOverlays && this.overlayManager.setTileParameters(sa); this._elevationUpdate(sa) }; Ba._elevationDataArrived = function (sa,
                Ca, Ja) { Ja = new da.ElevationData(sa.lij, sa.extent, Ja); sa.dataArrived(Ca, 0, Ja); Ja = [sa]; sa = sa.level; const ca = this._iteratorPool.acquire(); for (ca.reset(Ja); !ca.done;) { const qa = ca.next(); qa.findElevationBoundsForLayer(Ca, sa); qa.computeElevationBounds() } ca.remove(); this._updateTilesVisibility(Ja) }; Ba._handleLayerViewChanges = function (sa = ra.noBudget) {
                  if (this._layerViewsDirty) {
                    var Ca = this._layerViewsDirty = !1, Ja = new Set, ca = -1; for (const Da of this.view.allLayerViews.items) if (Ja.add(Da.uid), U.isSurfaceLayerView(Da)) if (this._basemapLayerViewHandles.has(Da.uid)) {
                      var qa =
                        this.layerClassFromLayerView(Da); qa = this._layerIndexByUid[qa].get(Da.uid); qa < ca && (Ca = !0); ca = qa
                    } else this._registerTiledLayerView(Da), Da.layer.loaded && (Ca = !0); this._basemapLayerViewHandles.forEach((Da, na) => { Ja.has(na) || (this._unregisterTiledLayerView(na), Ca = !0) }); Ca && this._updateTiledLayers(); this._renderer.isTransparent = this._allTransparentSurfaceLayers(); sa.madeProgress()
                  }
                }; Ba._allTransparentSurfaceLayers = function () {
                  let sa = 0 === this.view.map.ground.opacity; for (const Ca of this.view.allLayerViews.items) if (U.isSurfaceLayerView(Ca) &&
                    !U.isElevationLayerView(Ca) && !L.isBaseLayer(Ca.layer) && 0 !== Ca.fullOpacity) { sa = !1; break } return sa
                }; Ba.layerClassFromLayerView = function (sa) { return U.isElevationLayerView(sa) ? 0 : 1 }; Ba._registerTiledLayerView = function (sa) {
                  const Ca = [], Ja = this.layerClassFromLayerView(sa); Ca.push(sa.watch("suspended", () => this._updateTiledLayers())); Ca.push(sa.watch("fullOpacity", () => this._updateTileTextures(2))); Ca.push(sa.layer.watch("scaleRangeId", () => this._restartAllAgents(Ja))); sa.on("data-changed", () => {
                    const ca = this._layerIndexByUid[Ja].get(sa.uid);
                    null != ca && this._invalidateLayerData(ca, Ja)
                  }); this._basemapLayerViewHandles.set(sa.uid, Ca)
                }; Ba._unregisterTiledLayerView = function (sa) { const Ca = this._basemapLayerViewHandles.get(sa); if (Ca) { for (let Ja = 0; Ja < Ca.length; Ja++)Ca[Ja].remove(); this._basemapLayerViewHandles.delete(sa) } }; Ba._updateTiledLayers = function () {
                  if (this.tilingScheme && !this.view.suspended) {
                    var sa = this.view.allLayerViews, Ca = [[], []], Ja = null, ca = M.empty(); sa.forEach(Da => {
                      var na = Da.layer; if (na && !Da.suspended && U.isSurfaceLayerView(Da)) {
                        var xa =
                          Da.fullExtent; xa ? this.tilingScheme.compatibleWith(Da.tileInfo) ? (M.expand(ca, xa, ca), na = this.layerClassFromLayerView(Da), 1 === na && (xa = Da.displayLevelRange, Infinity !== xa.maxLevel && (null === Ja || xa.maxLevel > Ja) && (Ja = xa.maxLevel)), Ca[na].push(Da)) : Ea.warn("Terrain: tiling scheme of layer " + na.id + " is incompatible with other tiled layers, will not be drawn") : Ea.warn("Terrain: Map or elevation layer does not have fullExtent: " + na.id)
                      }
                    }); for (const Da of fa.LayerClasses) {
                      var qa = this._layerViews[Da]; sa = Ca[Da];
                      sa.reverse(); const na = sa.length; let xa = qa.length !== na; const Qa = Array(na), Wa = Array(qa.length); this._layerIndexByUid[Da].clear(); for (let Ra = 0; Ra < na; Ra++) { this._layerIndexByUid[Da].set(sa[Ra].uid, Ra); const ta = qa.indexOf(sa[Ra]); Qa[Ra] = ta; Ra !== ta && (xa = !0); -1 < ta && (Wa[ta] = Ra) } if (xa) { qa = this._postorderIterator; for (qa.reset(this.rootTiles); !qa.done;)qa.next().modifyLayers(Wa, Qa, Da); this._layerViews[Da] = sa; this._restartAllAgents(Da); this._updateTilesVisibility(this.rootTiles) }
                    } this.tilingScheme.ensureMaxLod(Ja) &&
                      this._viewChangeUpdate()
                  }
                }; Ba._restartAllAgents = function (sa) { const Ca = this._postorderIterator; for (Ca.reset(this.rootTiles); !Ca.done;) { const Ja = Ca.next(); Ja.restartAgents(sa); 0 === sa && Ja.computeElevationBounds() } }; Ba.layerViewByIndex = function (sa, Ca) { return this._layerViews[Ca][sa] }; Ba.numLayers = function (sa) { return this._layerViews[sa].length }; Ba._updateTileTextures = function (sa) {
                  this._allTiles.forAll(Ca => { Ca.updateAgents(1); 1 === sa ? this.renderer.updateTileTexture(Ca, 64) : Ca.updateRenderData(1, sa) }); this._renderer.isTransparent =
                    this._allTransparentSurfaceLayers()
                }; Ba._invalidateLayerData = function (sa, Ca) { this._allTiles.forAll(Ja => Ja.removeLayerAgent(sa, Ca)); this._allTiles.forAll(Ja => Ja.invalidateLayerData(sa, Ca)) }; Ba.setTileTreeDirty = function () { this._allTilesDirty = !0 }; Ba.requestRender = function (sa = 1) { this.renderer.setNeedsRender(sa) }; Ba.requestUpdate = function () { 1 === ++this._pendingUpdates && (this._hasPendingUpdates = !0) }; Ba.requestTileData = function (sa, Ca, Ja, ca) {
                  const qa = this.layerViewByIndex(Ca, Ja); Ca = qa.layer; if (!Ca.tilemapCache ||
                    U.isVectorTileLayerView(qa)) return this._requestTileData(sa, Ja, qa, ca); ++this._asyncWorkItems; return Ca.tilemapCache.fetchAvailability(sa.lij[0], sa.lij[1], sa.lij[2], { ...ca, timeout: 6E3 }).then(() => --this._asyncWorkItems).catch(Da => { --this._asyncWorkItems; v.isAbortError(Da) || this._dataMissing(sa, Ja, qa, { notInTilemap: !0 }); throw Da; }).then(() => this._frameTask.schedule(() => this._requestTileData(sa, Ja, qa, ca), ca.signal))
                }; Ba._requestTileData = function (sa, Ca, Ja, ca) {
                  return 0 === Ca ? this._requestElevationTileData(sa,
                    Ja, ca) : this._requestMapTileData(sa, Ja, ca)
                }; Ba._requestElevationTileData = function (sa, Ca, Ja) {
                  if (U.isElevationLayerView(Ca)) {
                    var ca = na => { --this._asyncWorkItems; if (!v.isAborted(Ja)) { var xa = this._layerIndexByUid[0].get(Ca.uid); null == xa ? Ea.warn("TerrainSurface: received data from unknown layer %d %s", 0, sa.lij.toString()) : (this._usedMemory = -1, this.requestUpdate(), this._elevationDataArrived(sa, xa, na)) } }, qa = na => { --this._asyncWorkItems; v.isAbortError(na) || (this._dataMissing(sa, 0, Ca, na), this.requestUpdate()) };
                    ++this._asyncWorkItems; if (U.useFetchTileForLayer(Ca.layer)) return Ca.layer.fetchTile(sa.lij[0], sa.lij[1], sa.lij[2], { noDataValue: ba.ELEVATION_NODATA_VALUE, signal: Ja.signal }).then(na => { v.isAborted(Ja) ? (Ea.warnOnce("A call to fetchTile resolved even though the request was aborted. fetchTile should not resolve if options.signal.aborted is true."), qa(v.createAbortError())) : this._frameTask.schedule(() => ca(na), Ja.signal, qa) }, qa); var Da = Ca.getTileUrl(sa.lij[0], sa.lij[1], sa.lij[2]); return this._elevationDataRequester.request(Da,
                      "binary", Ja).then(na => this._lercDecoder.decode(na, { noDataValue: ba.ELEVATION_NODATA_VALUE }, Ja.signal)).then(na => { ca({ values: na.pixelData, width: na.width, height: na.height, noDataValue: na.noDataValue, minValue: na.minValue, maxValue: na.maxValue }) }, qa)
                  } U.weakAssert(!1, "_requestElevationTileData can only be called for elevation layer views")
                }; Ba._requestMapTileData = function (sa, Ca, Ja) {
                  if (Ca instanceof I) return Promise.reject(); ++this._asyncWorkItems; const ca = (Qa, Wa) => {
                    --this._asyncWorkItems; U.releaseTileData(Wa);
                    v.isAborted(Ja) || (this._dataMissing(sa, 1, Ca, Qa), this.requestUpdate())
                  }, qa = Qa => Wa => ca(Wa, Qa), Da = Qa => this._frameTask.schedule(() => { --this._asyncWorkItems; this.requestUpdate(); v.isAborted(Ja) ? U.releaseTileData(Qa) : this._mapTileDataArrived(sa, Ca, Qa) }, Ja.signal, qa(Qa)).catch(qa(Qa)), na = (Qa, Wa = null) => this._frameTask.schedule(() => ca(Qa, Wa)); if (U.isVectorTileLayerView(Ca)) { var xa = Ca.schemaHelper.getLevelRowColumn(sa.lij); return Ca.fetchTile(xa[0], xa[1], xa[2], Ja).then(Da, na) } if (U.isImageryTileLayerView(Ca)) return Ca.fetchTile(sa.lij[0],
                    sa.lij[1], sa.lij[2], Ja).then(Da, na); if (U.isTileLayerView(Ca) && U.useFetchTileForLayer(Ca.layer)) return Ca.layer.fetchTile(sa.lij[0], sa.lij[1], sa.lij[2], Ja).then(Qa => { v.isAborted(Ja) ? (Ea.warnOnce("A call to fetchTile resolved even though the request was aborted. fetchTile should not resolve if options.signal.aborted is true."), na(v.createAbortError())) : Da(Qa) }, na); xa = Ca.getTileUrl(sa.lij[0], sa.lij[1], sa.lij[2]); K.isRefreshableLayer(Ca.layer) && Ca.layer.refreshTimestamp && (xa += `${xa.includes("?") ? "\x26" :
                      "?"}_ts=${Ca.layer.refreshTimestamp}`); return this._mapDataRequester.request(xa, Ca.hasMixedImageFormats ? "image+type" : "image", Ja).then(Da, na)
                }; Ba._mapTileDataArrived = function (sa, Ca, Ja) { Ca = this._layerIndexByUid[1].get(Ca.uid); null != Ca ? sa.dataArrived(Ca, 1, Ja) : (U.releaseTileData(Ja), Ea.warn("TerrainSurface: received data from unknown layer")) }; Ba._dataMissing = function (sa, Ca, Ja, ca) { Ja = this._layerIndexByUid[Ca].get(Ja.uid); null != Ja ? sa.dataMissing(Ja, Ca, ca) : Ea.warn("TerrainSurface: received data from unknown layer") };
            Ba.updateTileOverlayParams = function (sa) { this.rootTiles && this.overlayManager && (this._allTiles.forAll(Ca => { Ca.renderData && this.overlayManager.setTileParameters(Ca) }), this._renderer.setNeedsRender(sa)) }; Ba.getUsedMemory = function () { if (!this.tilingScheme) return 0; -1 === this._usedMemory && (this._usedMemory = 0, this._allTiles.forAll(sa => this._usedMemory += sa.usedMemory)); return this._usedMemory }; Ba.getUsedMemoryForLayerView = function (sa) {
              let Ca = 0; const Ja = this.layerClassFromLayerView(sa), ca = this._layerIndexByUid[Ja].get(sa.uid);
              this._allTiles.forAll(qa => Ca += qa.getUsedMemoryForLayer(Ja, ca)); return Ca
            }; Ba.getTile = function (sa) {
              if (d.isNone(sa) || d.isNone(this.rootTiles)) return null; const Ca = sa.split("/").map(Da => +Da); if (0 === Ca[0]) return this.rootTiles.find(Da => Da.lij[1] === Ca[1] && Da.lij[2] === Ca[2]); sa = 2 ** Ca[0]; const Ja = Math.floor(Ca[1] / sa), ca = Math.floor(Ca[2] / sa); let qa; this.rootTiles.some(Da => Da.lij[1] === Ja && Da.lij[2] === ca ? (qa = Da, !0) : !1); if (qa) {
                for (sa = 1 << Ca[0] - 1; qa.lij[0] < Ca[0];) {
                  let Da = Ca[1] & sa ? 2 : 0; 0 < (Ca[2] & sa) && Da++; if (!qa.children[Da]) return null;
                  qa = qa.children[Da]; sa >>= 1
                } U.weakAssert(qa.lij[0] === Ca[0] && qa.lij[1] === Ca[1] && qa.lij[2] === Ca[2], "not the right tile?"); return qa
              } return null
            }; w._createClass(Oa, [{ key: "renderer", get: function () { return this._renderer } }, { key: "frustum", get: function () { return this._frustum } }, {
              key: "snapLevel", get: function () {
                var sa, Ca, Ja = null == (sa = this.view.pointsOfInterest) ? void 0 : null == (Ca = sa.contentCameraOnSurface) ? void 0 : Ca.scale; Ja && (sa = this.view.state.contentCamera, sa = O.directionToHeadingTilt(this.view, sa.eye, sa.viewForward,
                  sa.up).tilt, 90 < sa && (sa = 180 - sa), sa = 2 * (sa / 90) ** 2, Ja = O.scaleToZoom(this.view, Ja) - sa, .25 < Math.abs(this._snapLevel - Ja) && (Math.round(Ja) !== Math.round(this._snapLevel) && (this._viewChanged = !0), this._snapLevel = Ja)); return Math.round(this._snapLevel)
              }
            }, { key: "lodSnapping", get: function () { return this.view.qualitySettings.tiledSurface.reduceTileLevelDifferences ? 1 : 0 } }, { key: "upsampleInfoPool", get: function () { return this._upsampleInfoPool } }, { key: "upsampleMapCache", get: function () { return this._upsampleMapCache } }, {
              key: "elevationQueryCache",
              get: function () { return this._elevationQueryCache }
            }, { key: "mapTileRequester", get: function () { return this._mapDataRequester } }, { key: "_userClippingExtent", get: function () { var { spatialReference: sa } = this, { clippingArea: Ca } = this.view; if (d.isNone(Ca) || d.isNone(sa)) return null; const Ja = M.create(); sa = S.toBoundingRect(Ca, Ja, sa) ? Ja : null; Ca = this._get("extent"); return M.equals(sa, Ca) ? Ca : sa } }, {
              key: "extent", get: function () {
                const sa = M.intersection(this.groundExtent, this._userClippingExtent, M.create()), Ca = this._get("extent");
                return M.equals(sa, Ca) ? Ca : sa
              }
            }, { key: "groundExtent", get: function () { return d.unwrapOr(this._tilingSchemeExtent, this._rootTilesExtent) } }, { key: "_tilingSchemeExtent", get: function () { var sa; return null == (sa = this.tilingSchemeLogic) ? void 0 : sa.extent } }, {
              key: "updating", get: function () {
              this._hasPendingUpdates || (this._maxNumUpdating = 1); return !!((this._watchUpdatingTracking.updating || this._hasPendingUpdates || this._viewChanged || this._allTilesDirty || 0 < this._asyncWorkItems || !this._allTilesSorted || this._renderer.updating ||
                this._layerViewsDirty) && this.ready && !this.suspended || this.overlayManager.updating || this._frameTask.updating)
              }
            }, { key: "updatingProgressValue", get: function () { this._maxNumUpdating = Math.max(this._pendingUpdates, this._maxNumUpdating); return 1 - this._pendingUpdates / this._maxNumUpdating } }, { key: "viewingMode", get: function () { return this.view.state.viewingMode } }, { key: "ready", get: function () { return d.isSome(this.rootTiles) } }, {
              key: "renderOrder", set: function (sa) {
                this._renderer.renderOrder = sa; this._set("renderOrder",
                  sa)
              }
            }, { key: "skirtScale", get: function () { return this._renderer.skirtScale }, set: function (sa) { this._renderer.skirtScale = sa } }, { key: "spatialReference", get: function () { var sa, Ca; return null != (sa = null == (Ca = this.tilingScheme) ? void 0 : Ca.spatialReference) ? sa : null } }, { key: "_background", get: function () { return null != this.backgroundColor ? this.backgroundColor : this.backgroundImage } }, {
              key: "slicePlaneEnabled", set: function (sa) {
                var Ca, Ja; this._renderer.slicePlaneEnabled = sa; this._set("slicePlaneEnabled", sa); null == (Ca = this.view) ?
                  void 0 : null == (Ja = Ca._stage) ? void 0 : Ja.renderView.setRenderParameters({ opaqueTerrain: this.opaque })
              }
            }, { key: "velvetOverground", set: function (sa) { sa !== this.velvetOverground && (this._renderer.velvetOverground = sa); this._set("velvetOverground", sa) } }, { key: "visible", set: function (sa) { sa !== this._visible && (this._visible = sa, this._renderer.setVisibility(sa), this.suspended = !sa) } }, { key: "opaque", get: function () { return this._renderer.opaque } }, { key: "suspended", set: function (sa) { this._set("suspended", sa); this._viewChangeUpdate() } },
            { key: "elevationBounds", get: function () { return this._elevationBounds } }, { key: "running", get: function () { return this.updating && this.ready && !this.suspended } }, { key: "lodBias", get: function () { return this.view.qualitySettings.tiledSurface.lodBias - (1 - this.view.resourceController.memoryController.memoryFactor) * ba.MAX_MEMORY_LOD_BIAS } }, {
              key: "performanceInfo", get: function () {
                const sa = this._performanceInfo; sa.numNodes = this._allTiles.length; sa.numLeaves = sa.numVisible = sa.numRendered = sa.numLoadedPerLevel.length = sa.numRenderedPerLevel.length =
                  0; this._allTiles.forAll(Ca => { Ca.isLeaf && sa.numLeaves++; const Ja = Ca.level; Ca.renderData && (sa.numLoadedPerLevel[Ja] = (sa.numLoadedPerLevel[Ja] || 0) + 1); Ca.visible && (sa.numVisible++ , Ca.rendered && (sa.numRenderedPerLevel[Ja] = (sa.numRenderedPerLevel[Ja] || 0) + 1, sa.numRendered++)) }); return sa
              }
            }, {
              key: "test", get: function () {
                const sa = this; return {
                  renderer: sa._renderer, lercDecoder: sa._lercDecoder, forceReload: () => { d.isSome(sa.rootTiles) && (sa._mergeTile(sa.rootTiles[0]), sa._viewChangeUpdate()) }, getTiles: () => sa._allTiles.toArray(),
                  getRenderedTiles() { pa.clear(); sa._allTiles.forAll(Ca => { Ca.visible && Ca.rendered && pa.push(Ca) }); ia.sortTiles(sa.renderOrder, pa); return pa.toArray() }, lockTilingScheme(Ca, Ja) { sa._extentHelper.defaultTiledLayersExtent = Ja; sa.tilingSchemeLogic.test.lockTilingScheme(Ca) }
                }
              }
            }]); return Oa
          }(p.EventedMixin(u)); c.__decorate([r.property()], u.prototype, "_renderer", void 0); c.__decorate([r.property()], u.prototype, "_hasPendingUpdates", void 0); c.__decorate([r.property()], u.prototype, "_asyncWorkItems", void 0); c.__decorate([r.property()],
            u.prototype, "_allTilesDirty", void 0); c.__decorate([r.property()], u.prototype, "_allTilesSorted", void 0); c.__decorate([r.property()], u.prototype, "_viewChanged", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "_watchUpdatingTracking", void 0); c.__decorate([r.property()], u.prototype, "_frameTask", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "snapLevel", null); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "lodSnapping", null); c.__decorate([r.property({ constructOnly: !0 })],
              u.prototype, "view", void 0); c.__decorate([r.property()], u.prototype, "_userClippingExtent", null); c.__decorate([r.property()], u.prototype, "_rootTilesExtent", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "extent", null); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "groundExtent", null); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "_tilingSchemeExtent", null); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "updating", null); c.__decorate([r.property(Q.updatingProgress)],
                u.prototype, "updatingProgress", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "updatingProgressValue", null); c.__decorate([r.property()], u.prototype, "_maxNumUpdating", void 0); c.__decorate([r.property({ aliasOf: "view.map.ground.opacity" })], u.prototype, "baseOpacity", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "overlayManager", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "viewingMode", null); c.__decorate([r.property()], u.prototype, "maxTextureScale", void 0);
          c.__decorate([r.property({ readOnly: !0 })], u.prototype, "ready", null); c.__decorate([r.property({ value: 1 })], u.prototype, "renderOrder", null); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "rootTiles", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "spatialReference", null); c.__decorate([r.property()], u.prototype, "backgroundImage", void 0); c.__decorate([r.property({ type: q, aliasOf: "view.map.ground.surfaceColor" })], u.prototype, "backgroundColor", void 0); c.__decorate([r.property()], u.prototype,
            "_background", null); c.__decorate([r.property({ value: !1 })], u.prototype, "slicePlaneEnabled", null); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "tilingScheme", void 0); c.__decorate([r.property({ readOnly: !0, aliasOf: "tilingSchemeLogic.tilingSchemeLocked" })], u.prototype, "tilingSchemeLocked", void 0); c.__decorate([r.property({ readOnly: !0, aliasOf: "tilingSchemeLogic.tilingSchemeDone" })], u.prototype, "tilingSchemeDone", void 0); c.__decorate([r.property({ readOnly: !0 })], u.prototype, "tilingSchemeLogic", void 0);
          c.__decorate([r.property({ value: !0 })], u.prototype, "velvetOverground", null); c.__decorate([g.aliasOf("_renderer.wireframe")], u.prototype, "wireframe", void 0); c.__decorate([r.property({ value: !1 })], u.prototype, "suspended", null); c.__decorate([r.property({ readOnly: !0, aliasOf: "view.qualitySettings.tiledSurface.textureFadeDuration" })], u.prototype, "textureFadeDuration", void 0); c.__decorate([r.property()], u.prototype, "_layerViewsDirty", void 0); c.__decorate([g.aliasOf("_renderer.renderPatchBorders")], u.prototype,
            "renderPatchBorders", void 0); c.__decorate([g.aliasOf("_renderer.renderingDisabled")], u.prototype, "renderingDisabled", void 0); c = u = c.__decorate([A.subclass("esri.views.3d.terrain.TerrainSurface")], u); const Ua = E.create(), Na = M.create(), ya = [0, 0, 0], pa = new t, wa = { spatialReference: null, tile: null, extent: null, context: "ground" }, Ia = { spatialReference: null, extent: null, scale: 0 }; return c
        })
    }, "esri/layers/support/ElevationQueryTileCache": function () {
      define(["exports"], function (a) {
        let w = function () {
          function c(u) {
          this.store =
            u
          } var q = c.prototype; q.destroy = function () { this.store.destroy() }; q.get = function (u) { return this.store.get(u) }; q.put = function (u, y) { this.store.put(u, y, y.values.byteLength + 256) }; return c
        }(); a.ElevationQueryTileCache = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/support/LercDecoder": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/maybe", "../../core/workers/WorkerHandle"], function (a, w, c, q) {
        let u = function (n) {
          function p(h = null) {
            var b = n.call(this, "LercWorker",
              "_decode", h, { strategy: "dedicated" }) || this; b.schedule = h; b.ref = 0; return b
          } w._inheritsLoose(p, n); var l = p.prototype; l.decode = function (h, b, d) { return h && 0 !== h.byteLength ? this.invoke({ buffer: h, options: b }, d) : Promise.resolve(null) }; l.getTransferList = function (h) { return [h.buffer] }; l.release = function () { 0 >= --this.ref && (y.forEach((h, b) => { h === this && y.delete(b) }), this.destroy()) }; return p
        }(q.WorkerHandle); const y = new Map; a.acquireDecoder = function (n = null) {
          let p = y.get(c.unwrap(n)); p || (c.isSome(n) ? (p = new u(l => n.schedule(l)),
            y.set(n, p)) : (p = new u, y.set(null, p))); ++p.ref; return p
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/workers/WorkerHandle": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../arrayUtils ../handleUtils ../Logger ../maybe ../promiseUtils ./workers".split(" "), function (a, w, c, q, u, y, n, p) {
        const l = u.getLogger("esri.core.workers.WorkerHandle"); u = function () {
          function h(d, f, t, v = {}) {
          this._mainMethod = f; this._listeners = []; this._promise = p.open(d, { ...v, schedule: t }).then(m => {
            if (void 0 ===
              this._thread) { this._thread = m; this._promise = null; v.hasInitialize && this.broadcast({}, "initialize"); for (const e of this._listeners) this._connectListener(e) } else m.close()
          }); this._promise.catch(m => l.error(`Failed to initialize ${d} worker: ${m}`))
          } var b = h.prototype; b.on = function (d, f) { const t = { removed: !1, eventName: d, callback: f, threadHandle: null }; this._listeners.push(t); this._connectListener(t); return q.makeHandle(() => { t.removed = !0; c.remove(this._listeners, t); this._thread && y.isSome(t.threadHandle) && t.threadHandle.remove() }) };
          b.destroy = function () { this._thread && (this._thread.close(), this._thread = null); this._promise = null }; b.invoke = function (d, f) { return this.invokeMethod(this._mainMethod, d, f) }; b.invokeMethod = function (d, f, t) { if (this._thread) { const v = this.getTransferList(f, d); return this._thread.invoke(d, f, { transferList: v, signal: t }) } return this._promise ? this._promise.then(() => { n.throwIfAborted(t); return this.invokeMethod(d, f, t) }) : Promise.reject(null) }; b.broadcast = function (d, f) {
            return this._thread ? Promise.all(this._thread.broadcast(f,
              d)).then(() => { }) : this._promise ? this._promise.then(() => this.broadcast(d, f)) : Promise.reject()
          }; b._connectListener = function (d) { this._thread && this._thread.on(d.eventName, d.callback).then(f => { d.removed || (d.threadHandle = f) }) }; w._createClass(h, [{ key: "promise", get: function () { return this._promise } }]); return h
        }(); a.WorkerHandle = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/2d/engine/vectorTiles/VectorTile": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/mat3 ../../../../chunks/mat3f32 ./RenderBucket ./decluttering/config ../webgl/TiledDisplayObject".split(" "),
        function (a, w, c, q, u, y, n, p) {
          p = function (h) {
            function b(f, t, v, m, e, g, x = null) {
              t = h.call(this, f, t, v, m, e, 4096, 4096) || this; t._memCache = x; t.type = "vector-tile"; t._referenced = 0; t._hasSymbolBuckets = !1; t._memoryUsedByLayerData = 0; t.layerData = new Map; t.layerCount = 0; t.status = "loading"; t.allSymbolsFadingOut = !1; t.lastOpacityUpdate = 0; t.symbols = new Map; t.isCoverage = !1; t.neededForCoverage = !1; t.decluttered = !1; t.invalidating = !1; t.parentTile = null; t.childrenTiles = new Set; t._processed = !1; t._referenced = 1; t.styleRepository = g; t.id =
                f.id; return t
            } w._inheritsLoose(b, h); var d = b.prototype; d.setData = function (f) { this.changeDataImpl(f); this.requestRender(); this.ready(); this.invalidating = !1; this._processed = !0 }; d.deleteLayerData = function (f) {
              let t = !1; for (const v of f) this.layerData.has(v) && (f = this.layerData.get(v), this._memoryUsedByLayerData -= f.memoryUsed, 3 === f.type && this.symbols.has(v) && (this.symbols.delete(v), t = !0), f.destroy(), this.layerData.delete(v), this.layerCount--); c.isSome(this._memCache) && this._memCache.updateSize(this.key.id,
                this, this._memoryUsedByLayerData); t && this.emit("symbols-changed"); this.requestRender()
            }; d.processed = function () { return this._processed }; d.hasData = function () { return 0 < this.layerCount }; d.dispose = function () { "unloaded" !== this.status && (l.delete(this), b._destroyRenderBuckets(this.layerData), this.layerData = null, this._memoryUsedByLayerData = this.layerCount = 0, this.destroy(), this.status = "unloaded") }; d.release = function () { return 0 === --this._referenced ? (this.dispose(), this.stage = null, !0) : !1 }; d.retain = function () { ++this._referenced };
            d.changeDataImpl = function (f) {
              let t = !1; if (f) { f = this._createRenderBuckets(f); for (const [v, m] of f) this.layerData.has(v) && (f = this.layerData.get(v), this._memoryUsedByLayerData -= m.memoryUsed, f.destroy(), this.layerData.delete(v), this.layerCount--), 3 === m.type && (this.symbols.set(v, m.symbols), t = !0), this._memoryUsedByLayerData += m.memoryUsed, this.layerData.set(v, m), this.layerCount++; c.isSome(this._memCache) && this._memCache.updateSize(this.key.id, this, this._memoryUsedByLayerData) } this._hasSymbolBuckets = !1; for (const [,
                v] of this.layerData) 3 === v.type && (this._hasSymbolBuckets = !0); t && this.emit("symbols-changed")
            }; d.attachWithContext = function (f) { this.stage = { context: f, trashDisplayObject(t) { t.processDetach() }, untrashDisplayObject() { return !1 } } }; d.setTransform = function (f, t) {
              h.prototype.setTransform.call(this, f, t); var v = t / (f.resolution * f.pixelRatio); t = this.width / this.rangeX * v; v *= this.height / this.rangeY; const m = [0, 0]; f.toScreen(m, [this.x, this.y]); const e = this.transforms.tileUnitsToPixels; q.identity(e); q.translate(e, e, m);
              q.rotate(e, e, Math.PI * f.rotation / 180); q.scale(e, e, [t, v, 1])
            }; d._createTransforms = function () { return { dvs: u.create(), tileMat3: u.create(), tileUnitsToPixels: u.create() } }; b._destroyRenderBuckets = function (f) { if (f) { var t = new Set; f.forEach(v => { t.has(v) || (v.destroy(), t.add(v)) }); f.clear() } }; d._createRenderBuckets = function (f) { const t = new Map, v = new Map; for (const m of f) { f = this._deserializeBucket(m, v); for (const e of f.layerUIDs) t.set(e, f) } return t }; d._deserializeBucket = function (f, t) {
              let v = t.get(f); if (v) return v;
              switch ((new Uint32Array(f))[0]) { case 1: v = new y.FillRenderBucket(f, this.styleRepository); break; case 2: v = new y.LineRenderBucket(f, this.styleRepository); break; case 3: v = new y.SymbolRenderBucket(f, this.styleRepository, this); break; case 4: v = new y.CircleRenderBucket(f, this.styleRepository) }t.set(f, v); return v
            }; w._createClass(b, [{ key: "hasSymbolBuckets", get: function () { return this._hasSymbolBuckets } }, { key: "isFading", get: function () { return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < n.FADE_DURATION } },
            { key: "isHoldingForFade", get: function () { return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < n.FADE_DURATION) } }, { key: "wasRequested", get: function () { return "errored" === this.status || "loaded" === this.status || "reloading" === this.status } }, { key: "referenced", get: function () { return this._referenced } }, { key: "memoryUsage", get: function () { return (this._memoryUsedByLayerData + 256) / (this._referenced || 1) } }]); return b
          }(p.TiledDisplayObject); const l = new Map; a.VectorTile = p; a.printAllocations =
            function () { l.forEach((h, b) => { console.log(`\n${b.key}:`); h[0].forEach(d => console.log(d)); console.log("\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d"); h[1].forEach(d => console.log(d)) }) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/chunks/mat3f32": function () {
      define(["exports"], function (a) {
        function w() { const n = new Float32Array(9); n[0] = 1; n[4] = 1; n[8] = 1; return n } function c(n) { const p = new Float32Array(9); p[0] = n[0]; p[1] = n[1]; p[2] = n[2]; p[3] = n[3]; p[4] = n[4]; p[5] = n[5]; p[6] = n[6]; p[7] = n[7]; p[8] = n[8]; return p } function q(n,
          p, l, h, b, d, f, t, v) { const m = new Float32Array(9); m[0] = n; m[1] = p; m[2] = l; m[3] = h; m[4] = b; m[5] = d; m[6] = f; m[7] = t; m[8] = v; return m } function u(n, p) { return new Float32Array(n, p, 9) } const y = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, createView: u }); a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.mat3f32 = y
      })
    }, "esri/views/2d/engine/vectorTiles/RenderBucket": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../../core/has ../../../webgl/checkWebGLError ../../../webgl/enums ../../../../chunks/builtins ../../../webgl/Texture ../../../webgl/VertexArrayObject ./decluttering/util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          u = function () {
            function f(v, m) { this.layerUIDs = []; this.isDestroyed = !1; this.data = v; this.memoryUsed = v.byteLength; let e = 1; v = new Uint32Array(v); this.layerUIDs = []; const g = v[e++]; for (let x = 0; x < g; x++)this.layerUIDs[x] = v[e++]; this.bufferDataOffset = e; m && (this.layer = m.getStyleLayerByUID(this.layerUIDs[0])) } var t = f.prototype; t.destroy = function () { this.isDestroyed || (this.doDestroy(), this.isDestroyed = !0) }; t.prepareForRendering = function (v) {
              c.isNone(this.data) || (this.doPrepareForRendering(v,
                this.data, this.bufferDataOffset), this.data = null)
            }; w._createClass(f, [{ key: "isPreparedForRendering", get: function () { return c.isNone(this.data) } }, { key: "offset", get: function () { return this.bufferDataOffset } }]); return f
          }(); y = function (f) {
            function t(m, e) {
              e = f.call(this, m, e) || this; e.type = 2; e.lineIndexStart = 0; e.lineIndexCount = 0; m = new Uint32Array(m); let g = e.bufferDataOffset; e.lineIndexStart = m[g++]; e.lineIndexCount = m[g++]; const x = m[g++]; if (0 < x) {
                const k = new Map; for (let r = 0; r < x; r++) {
                  const A = m[g++], z = m[g++], B = m[g++];
                  k.set(A, [z, B])
                } e.patternMap = k
              } e.bufferDataOffset = g; return e
            } w._inheritsLoose(t, f); var v = t.prototype; v.hasData = function () { return 0 < this.lineIndexCount }; v.triangleCount = function () { return this.lineIndexCount / 3 }; v.doDestroy = function () {
              c.isSome(this.lineVertexArrayObject) && this.lineVertexArrayObject.dispose(); c.isSome(this.lineVertexBuffer) && this.lineVertexBuffer.dispose(); c.isSome(this.lineIndexBuffer) && this.lineIndexBuffer.dispose(); this.lineIndexBuffer = this.lineVertexBuffer = this.lineVertexArrayObject =
                null; this.memoryUsed = 0
            }; v.doPrepareForRendering = function (m, e, g) { e = new Uint32Array(e); var x = new Int32Array(e.buffer); const k = e[g++]; this.lineVertexBuffer = q.createVertex(m, 35044, new Int32Array(x.buffer, 4 * g, k)); g += k; x = e[g++]; this.lineIndexBuffer = q.createIndex(m, 35044, new Uint32Array(e.buffer, 4 * g, x)); g += x; g = this.layer.lineMaterial; this.lineVertexArrayObject = new b(m, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: this.lineVertexBuffer }, this.lineIndexBuffer) }; return t
          }(u); n = function (f) {
            function t(m,
              e) { e = f.call(this, m, e) || this; e.type = 1; e.fillIndexStart = 0; e.fillIndexCount = 0; e.outlineIndexStart = 0; e.outlineIndexCount = 0; m = new Uint32Array(m); let g = e.bufferDataOffset; e.fillIndexStart = m[g++]; e.fillIndexCount = m[g++]; e.outlineIndexStart = m[g++]; e.outlineIndexCount = m[g++]; const x = m[g++]; if (0 < x) { const k = new Map; for (let r = 0; r < x; r++) { const A = m[g++], z = m[g++], B = m[g++]; k.set(A, [z, B]) } e.patternMap = k } e.bufferDataOffset = g; return e } w._inheritsLoose(t, f); var v = t.prototype; v.hasData = function () {
                return 0 < this.fillIndexCount ||
                  0 < this.outlineIndexCount
              }; v.triangleCount = function () { return (this.fillIndexCount + this.outlineIndexCount) / 3 }; v.doDestroy = function () {
                c.isSome(this.fillVertexArrayObject) && this.fillVertexArrayObject.dispose(); c.isSome(this.fillVertexBuffer) && this.fillVertexBuffer.dispose(); c.isSome(this.fillIndexBuffer) && this.fillIndexBuffer.dispose(); this.fillIndexBuffer = this.fillVertexBuffer = this.fillVertexArrayObject = null; c.isSome(this.outlineVertexArrayObject) && this.outlineVertexArrayObject.dispose(); c.isSome(this.outlineVertexBuffer) &&
                  this.outlineVertexBuffer.dispose(); c.isSome(this.outlineIndexBuffer) && this.outlineIndexBuffer.dispose(); this.outlineIndexBuffer = this.outlineVertexBuffer = this.outlineVertexArrayObject = null; this.memoryUsed = 0
              }; v.doPrepareForRendering = function (m, e, g) {
                e = new Uint32Array(e); var x = new Int32Array(e.buffer), k = e[g++]; this.fillVertexBuffer = q.createVertex(m, 35044, new Int32Array(x.buffer, 4 * g, k)); g += k; k = e[g++]; this.fillIndexBuffer = q.createIndex(m, 35044, new Uint32Array(e.buffer, 4 * g, k)); g += k; k = e[g++]; this.outlineVertexBuffer =
                  q.createVertex(m, 35044, new Int32Array(x.buffer, 4 * g, k)); g += k; x = e[g++]; this.outlineIndexBuffer = q.createIndex(m, 35044, new Uint32Array(e.buffer, 4 * g, x)); g += x; e = this.layer; g = e.fillMaterial; e = e.outlineMaterial; this.fillVertexArrayObject = new b(m, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: this.fillVertexBuffer }, this.fillIndexBuffer); this.outlineVertexArrayObject = new b(m, e.getAttributeLocations(), e.getLayoutInfo(), { geometry: this.outlineVertexBuffer }, this.outlineIndexBuffer)
              }; return t
          }(u); p = function (f) {
            function t(m,
              e, g) {
                e = f.call(this, m, e) || this; e.type = 3; e.iconPerPageElementsMap = new Map; e.glyphPerPageElementsMap = new Map; e.symbolInstances = []; e.isIconSDF = !1; e.opacityChanged = !1; e.lastOpacityUpdate = 0; e.symbols = []; const x = new Uint32Array(m), k = new Int32Array(m); m = new Float32Array(m); let r = e.bufferDataOffset; e.isIconSDF = !!x[r++]; var A = x[r++]; for (var z = 0; z < A; z++) { var B = x[r++], C = x[r++], D = x[r++]; e.iconPerPageElementsMap.set(B, [C, D]) } A = x[r++]; for (z = 0; z < A; z++)B = x[r++], C = x[r++], D = x[r++], e.glyphPerPageElementsMap.set(B, [C,
                  D]); A = x[r++]; z = x[r++]; e.iconOpacity = new Int32Array(A); e.textOpacity = new Int32Array(z); r = d.deserializeSymbols(x, k, m, r, e.symbols, g); e.bufferDataOffset = r; return e
            } w._inheritsLoose(t, f); var v = t.prototype; v.hasData = function () { return 0 < this.iconPerPageElementsMap.size || 0 < this.glyphPerPageElementsMap.size }; v.triangleCount = function () { let m = 0; for (const [, e] of this.iconPerPageElementsMap) m += e[1]; for (const [, e] of this.glyphPerPageElementsMap) m += e[1]; return m / 3 }; v.doDestroy = function () {
              c.isSome(this.iconVertexArrayObject) &&
              this.iconVertexArrayObject.dispose(); c.isSome(this.iconVertexBuffer) && this.iconVertexBuffer.dispose(); c.isSome(this.iconOpacityBuffer) && this.iconOpacityBuffer.dispose(); c.isSome(this.iconIndexBuffer) && this.iconIndexBuffer.dispose(); this.iconIndexBuffer = this.iconOpacityBuffer = this.iconVertexBuffer = this.iconVertexArrayObject = null; c.isSome(this.textVertexArrayObject) && this.textVertexArrayObject.dispose(); c.isSome(this.textVertexBuffer) && this.textVertexBuffer.dispose(); c.isSome(this.textOpacityBuffer) &&
                this.textOpacityBuffer.dispose(); c.isSome(this.textIndexBuffer) && this.textIndexBuffer.dispose(); this.textIndexBuffer = this.textOpacityBuffer = this.textVertexBuffer = this.textVertexArrayObject = null; this.memoryUsed = 0
            }; v.updateOpacityInfo = function () {
              if (this.opacityChanged) {
              this.opacityChanged = !1; var m = c.unwrap(this.iconOpacity), e = c.unwrap(this.iconOpacityBuffer); 0 < m.length && m.byteLength === e.size && e.setSubData(m); m = c.unwrap(this.textOpacity); e = c.unwrap(this.textOpacityBuffer); 0 < m.length && m.byteLength ===
                e.size && e.setSubData(m)
              }
            }; v.doPrepareForRendering = function (m, e, g) {
              e = new Uint32Array(e); var x = new Int32Array(e.buffer), k = e[g++]; this.iconVertexBuffer = q.createVertex(m, 35044, new Int32Array(x.buffer, 4 * g, k)); g += k; k = e[g++]; this.iconIndexBuffer = q.createIndex(m, 35044, new Uint32Array(e.buffer, 4 * g, k)); g += k; k = e[g++]; this.textVertexBuffer = q.createVertex(m, 35044, new Int32Array(x.buffer, 4 * g, k)); g += k; x = e[g++]; this.textIndexBuffer = q.createIndex(m, 35044, new Uint32Array(e.buffer, 4 * g, x)); g += x; this.iconOpacityBuffer =
                q.createVertex(m, 35044, c.unwrap(this.iconOpacity).buffer); this.textOpacityBuffer = q.createVertex(m, 35044, c.unwrap(this.textOpacity).buffer); e = this.layer; g = e.iconMaterial; e = e.textMaterial; this.iconVertexArrayObject = new b(m, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: this.iconVertexBuffer, opacity: this.iconOpacityBuffer }, this.iconIndexBuffer); this.textVertexArrayObject = new b(m, e.getAttributeLocations(), e.getLayoutInfo(), { geometry: this.textVertexBuffer, opacity: this.textOpacityBuffer }, this.textIndexBuffer)
            };
            return t
          }(u); l = function (f) {
            function t(m, e) { e = f.call(this, m, e) || this; e.type = 4; e.circleIndexStart = 0; e.circleIndexCount = 0; m = new Uint32Array(m); let g = e.bufferDataOffset; e.circleIndexStart = m[g++]; e.circleIndexCount = m[g++]; e.bufferDataOffset = g; return e } w._inheritsLoose(t, f); var v = t.prototype; v.hasData = function () { return 0 < this.circleIndexCount }; v.triangleCount = function () { return this.circleIndexCount / 3 }; v.doDestroy = function () {
              c.isSome(this.circleVertexArrayObject) && this.circleVertexArrayObject.dispose();
              c.isSome(this.circleVertexBuffer) && this.circleVertexBuffer.dispose(); c.isSome(this.circleIndexBuffer) && this.circleIndexBuffer.dispose(); this.circleIndexBuffer = this.circleVertexBuffer = this.circleVertexArrayObject = null; this.memoryUsed = 0
            }; v.doPrepareForRendering = function (m, e, g) {
              e = new Uint32Array(e); var x = new Int32Array(e.buffer); const k = e[g++]; this.circleVertexBuffer = q.createVertex(m, 35044, new Int32Array(x.buffer, 4 * g, k)); g += k; x = e[g++]; this.circleIndexBuffer = q.createIndex(m, 35044, new Uint32Array(e.buffer,
                4 * g, x)); g += x; g = this.layer.circleMaterial; this.circleVertexArrayObject = new b(m, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: this.circleVertexBuffer }, this.circleIndexBuffer)
            }; return t
          }(u); a.CircleRenderBucket = l; a.FillRenderBucket = n; a.LineRenderBucket = y; a.RenderBucketBase = u; a.SymbolRenderBucket = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/2d/engine/vectorTiles/decluttering/util": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../core/maybe",
        "./core"], function (a, w, c, q) {
          let u = function (l) { this.tile = l; this.parent = null; this.children = new Set }, y = function () {
            function l() { this.nodes = new Map; this.roots = new Set } var h = l.prototype; h.create = function (b) {
              const d = new u(b); let f; const t = []; this.nodes.forEach(v => { this._canConnectDirectly(d, v) && t.push(v); !f && this._canConnectDirectly(v, d) && (f = v) }); if (f) { for (const v of t) f.children.delete(v), d.children.add(v), v.parent = d; f.children.add(d); d.parent = f } else {
                this.roots.add(d); for (const v of t) d.children.add(v),
                  v.parent = d, this.roots.delete(v)
              } this.nodes.set(b.key.id, d); return d
            }; h.destroy = function (b) { c.isSome(b.parent) ? (b.parent.children.delete(b), b.children.forEach(d => { c.isSome(b.parent) && b.parent.children.add(d) })) : this.roots.delete(b); b.children.forEach(d => { (d.parent = b.parent) || this.roots.add(d) }); this.nodes.delete(b.tile.key.id) }; h.clear = function () { this.roots.clear(); this.nodes.clear() }; h._canConnectDirectly = function (b, d) {
              let { level: f, row: t, col: v } = d.tile.key; for ({ world: d } = d.tile.key; 0 < f;) {
                f--; t >>= 1;
                v >>= 1; if (b.tile.key.level === f && b.tile.key.row === t && b.tile.key.col === v && b.tile.key.world === d) return !0; if (this.nodes.has(`${f}/${t}/${v}/${d}`)) break
              } return !1
            }; return l
          }(), n = function () {
            function l() { this._tileGraph = new y; this._tileArray = null } var h = l.prototype; h.has = function (b) { return "string" === typeof b ? this._tileGraph.nodes.has(b) : this._tileGraph.nodes.has(b.key.id) }; h.getAll = function () { this._tileArray || (this._tileArray = [], this._tileGraph.nodes.forEach(b => { this._tileArray.push(b.tile) })); return this._tileArray };
            h.getRoots = function () { const b = []; this._tileGraph.roots.forEach(d => { b.push(d.tile) }); return b }; h.getParent = function (b) { b = this._tileGraph.nodes.get("string" === typeof b ? b : b.key.id); return c.isSome(b.parent) && b.parent.tile }; h.getChildren = function (b) { const d = []; this._tileGraph.nodes.get("string" === typeof b ? b : b.key.id).children.forEach(f => { d.push(f.tile) }); return d }; h.get = function (b) { return this._tileGraph.nodes.get(b).tile }; h.removeKey = function (b) {
              b = this._tileGraph.nodes.get(b); this._tileGraph.destroy(b);
              this._tileArray = null
            }; h.forEach = function (b) { this._tileGraph.nodes.forEach((d, f) => b(d.tile, f)) }; h.add = function (b) { this._tileGraph.create(b); this._tileArray = null }; h.remove = function (b) { b = this._tileGraph.nodes.get(b.key.id); this._tileGraph.destroy(b); this._tileArray = null }; h.clear = function () { this._tileGraph.clear(); this._tileArray = [] }; return l
          }(), p = function () {
            function l(b, d, f) {
            this._rows = Math.ceil(d / f); this._columns = Math.ceil(b / f); this._cellSize = f; this.cells = Array(this._rows); for (b = 0; b < this._rows; b++)for (this.cells[b] =
              Array(this._columns), d = 0; d < this._columns; d++)this.cells[b][d] = []
            } var h = l.prototype; h.getCell = function (b, d) { d = Math.min(Math.max(Math.floor(d / this._cellSize), 0), this._rows - 1); b = Math.min(Math.max(Math.floor(b / this._cellSize), 0), this._columns - 1); return this.cells[d] && this.cells[d][b] || null }; h.getCellSpan = function (b, d, f, t) {
              return [Math.min(Math.max(Math.floor(b / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(d / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(f / this._cellSize),
                0), this.columns - 1), Math.min(Math.max(Math.floor(t / this._cellSize), 0), this.rows - 1)]
            }; w._createClass(l, [{ key: "cellSize", get: function () { return this._cellSize } }, { key: "columns", get: function () { return this._columns } }, { key: "rows", get: function () { return this._rows } }]); return l
          }(); a.GridIndex = p; a.TileForest = n; a.TileGraph = y; a.TileNode = u; a.deserializeSymbols = function (l, h, b, d, f, t) {
            const v = h[d++]; for (let g = 0; g < v; g++) {
              const x = new q.VTLSymbol(t); x.xTile = h[d++]; x.yTile = h[d++]; x.hash = h[d++]; x.priority = h[d++]; var m =
                h[d++]; for (var e = 0; e < m; e++) { const k = h[d++], r = h[d++], A = h[d++], z = h[d++], B = !!h[d++], C = h[d++], D = b[d++], E = b[d++], H = h[d++], J = h[d++]; x.colliders.push({ xTile: k, yTile: r, dxPixels: A, dyPixels: z, hard: B, partIndex: C, width: H, height: J, minLod: D, maxLod: E }) } m = l[d++]; for (e = 0; e < m; e++)x.textVertexRanges.push([l[d++], l[d++]]); m = l[d++]; for (e = 0; e < m; e++)x.iconVertexRanges.push([l[d++], l[d++]]); f.push(x)
            } return d
          }; a.tileCoordChange = function (l, h, b, d, f, t) {
            b -= f; if (0 <= b) return (h >> b) + (d - (t << b)) * (l >> b); b = -b; return h - (t - (d << b)) * (l >>
              b) << b
          }; a.writeOpacityToBuffers = function (l, h, b) {
            for (const [g, x] of l.symbols) {
              {
                var d = l, f = h, t = b, v = x; const k = d.layerData.get(g); if (3 === k.type) {
                  for (const r of v) {
                    v = r.unique; var m = void 0; if (r.selectedForRendering) { var e = v.parts[0]; m = e.startOpacity; e = e.targetOpacity; d.allSymbolsFadingOut = d.allSymbolsFadingOut && 0 === e; m = t ? Math.floor(127 * m) | e << 7 : e ? 255 : 0; m |= m << 24 | m << 16 | m << 8 } else m = 0; for (const [A, z] of r.iconVertexRanges) for (e = A; e < A + z; e += 4)k.iconOpacity[e / 4] = m; r.selectedForRendering ? (m = v.parts[1], v = m.startOpacity,
                      m = m.targetOpacity, d.allSymbolsFadingOut = d.allSymbolsFadingOut && 0 === m, v = t ? Math.floor(127 * v) | m << 7 : m ? 255 : 0, m = v << 24 | v << 16 | v << 8 | v) : m = 0; for (const [A, z] of r.textVertexRanges) for (v = A; v < A + z; v += 4)k.textOpacity[v / 4] = m
                  } k.lastOpacityUpdate = f; k.opacityChanged = !0
                }
              }
            }
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/2d/engine/vectorTiles/decluttering/core": function () {
      define(["exports"], function (a) {
      a.VTLSymbol = function (w) {
      this.hash = this.yTile = this.xTile = 0; this.priority = 1; this.colliders = []; this.textVertexRanges =
        []; this.iconVertexRanges = []; this.tile = w
      }; a.VTLUniqueSymbol = function () { this.tileSymbols = []; this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: !1 }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: !1 }]; this.show = !1 }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/2d/engine/vectorTiles/decluttering/config": function () {
      define(["exports"], function (a) {
      a.COLLISION_GRID_CELL_SIZE = 32; a.DECLUTTER_BUDGET = 1.5; a.DECLUTTER_TILES = !0; a.FADE_DURATION = 200; Object.defineProperty(a, "__esModule",
        { value: !0 })
      })
    }, "esri/views/2d/engine/webgl/TiledDisplayObject": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../chunks/mat3", "../DisplayObject", "../../tiling/TileKey"], function (a, w, c, q, u) {
        q = function (y) {
          function n(l, h, b, d, f, t = d, v = f) { var m = y.call(this) || this; m.triangleCountReportedInDebug = 0; m.triangleCount = 0; m.texture = null; m.key = new u(l); m.x = h; m.y = b; m.width = d; m.height = f; m.rangeX = t; m.rangeY = v; return m } w._inheritsLoose(n, y); var p = n.prototype; p.destroy = function () {
          this.texture &&
            (this.texture.dispose(), this.texture = null)
          }; p.setTransform = function (l, h) { h /= l.resolution * l.pixelRatio; const b = this.transforms.tileMat3, [d, f] = l.toScreenNoRotation([0, 0], [this.x, this.y]); c.set(b, this.width / this.rangeX * h, 0, 0, 0, this.height / this.rangeY * h, 0, d, f, 1); c.multiply(this.transforms.dvs, l.displayViewMat3, b) }; return n
        }(q.DisplayObject); a.TiledDisplayObject = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/2d/engine/DisplayObject": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Evented ../../../core/has ../../../core/maybe ../../../core/promiseUtils".split(" "),
        function (a, w, c, q, u, y) {
          const n = 1 / q("mapview-transitions-duration"); c = function (p) {
            function l() { var b = p.apply(this, arguments) || this; b._fadeOutResolver = null; b._fadeInResolver = null; b._clips = null; b.computedVisible = !0; b.computedOpacity = 1; b.fadeTransitionEnabled = !1; b.inFadeTransition = !1; b._isReady = !1; b._opacity = 1; b._stage = null; b._visible = !0; return b } w._inheritsLoose(l, p); var h = l.prototype; h._getTransforms = function () { u.isNone(this._transforms) && (this._transforms = this._createTransforms()); return this._transforms };
            h.fadeIn = function () { if (this._fadeInResolver) return this._fadeInResolver.promise; this._fadeOutResolver && (this._fadeOutResolver(), this._fadeOutResolver = null); this.computedOpacity = 0; this.fadeTransitionEnabled = !0; this._fadeInResolver = y.createResolver(); this.requestRender(); return this._fadeInResolver.promise }; h.fadeOut = function () {
              if (this._fadeOutResolver) return this._fadeOutResolver.promise; this._fadeInResolver && (this._fadeInResolver(), this._fadeInResolver = null); this.fadeTransitionEnabled = !0; this._fadeOutResolver =
                y.createResolver(); this.requestRender(); return this._fadeOutResolver.promise
            }; h.beforeRender = function (b) { this.updateTransitionProperties(b.deltaTime, b.state.scale) }; h.afterRender = function (b) { this._fadeInResolver && this.computedOpacity === this.opacity ? (this._fadeInResolver(), this._fadeInResolver = null) : this._fadeOutResolver && 0 === this.computedOpacity && (this._fadeOutResolver(), this._fadeOutResolver = null) }; h.remove = function () { var b; null == (b = this.parent) ? void 0 : b.removeChild(this) }; h.setTransform = function (b) { };
            h.processRender = function (b) { this.stage && this.computedVisible && this.doRender(b) }; h.requestRender = function () { this.stage && this.stage.requestRender() }; h.processDetach = function () { this.onDetach(); this.emit("detach") }; h.updateTransitionProperties = function (b, d) {
              if (this.fadeTransitionEnabled) {
                d = this._fadeOutResolver || !this.visible ? 0 : this.opacity; const f = this.computedOpacity; f === d ? this.computedVisible = this.visible : (b *= n, this.computedOpacity = f > d ? Math.max(d, f - b) : Math.min(d, f + b), this.computedVisible = 0 < this.computedOpacity,
                  b = d === this.computedOpacity, this.inFadeTransition = !b, b || this.requestRender())
              } else this.computedOpacity = this.opacity, this.computedVisible = this.visible
            }; h.onAttach = function () { }; h.onDetach = function () { }; h.doRender = function (b) { }; h.ready = function () { this._isReady || (this._isReady = !0, this.emit("isReady"), this.requestRender()) }; w._createClass(l, [{ key: "clips", get: function () { return this._clips }, set: function (b) { this._clips = b; this.requestRender() } }, { key: "isReady", get: function () { return this._isReady } }, {
              key: "opacity",
              get: function () { return this._opacity }, set: function (b) { this._opacity !== b && (this._opacity = Math.min(1, Math.max(b, 0)), this.requestRender()) }
            }, { key: "stage", get: function () { return this._stage }, set: function (b) { if (this._stage !== b) { var d = this._stage; (this._stage = b) ? this._stage.untrashDisplayObject(this) || (this.onAttach(), this.emit("attach")) : d.trashDisplayObject(this) } } }, { key: "transforms", get: function () { return this._getTransforms() } }, {
              key: "visible", get: function () { return this._visible }, set: function (b) {
              this._visible !==
                b && (this._visible = b, this.requestRender())
              }
            }]); return l
          }(c); a.DisplayObject = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/2d/tiling/TileKey": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers", "../../../core/ObjectPool"], function (a, w) {
        let c = function () {
          function q(y, n, p, l) { this.set(y, n, p, l) } q.getId = function (y, n, p, l) { return "object" === typeof y ? `${y.level}/${y.row}/${y.col}/${y.world}` : `${y}/${n}/${p}/${l}` }; var u = q.prototype; u.acquire = function (y, n, p, l) { this.set(y, n, p, l) };
          u.contains = function (y) { const n = y.level - this.level; return this.row === y.row >> n && this.col === y.col >> n && this.world === y.world }; u.equals = function (y) { return this.level === y.level && this.row === y.row && this.col === y.col && this.world === y.world }; u.clone = function () { return new q(this) }; u.release = function () { this.world = this.col = this.row = this.level = 0 }; u.set = function (y, n, p, l) {
            if (null == y) this.world = this.col = this.row = this.level = 0; else if ("object" === typeof y) this.level = y.level || 0, this.row = y.row || 0, this.col = y.col || 0, this.world =
              y.world || 0; else if ("string" === typeof y) { const [h, b, d, f] = y.split("/"); this.level = parseFloat(h); this.row = parseFloat(b); this.col = parseFloat(d); this.world = parseFloat(f) } else this.level = +y, this.row = +n, this.col = +p, this.world = +l || 0; return this
          }; u.toString = function () { return `${this.level}/${this.row}/${this.col}/${this.world}` }; u.getParentKey = function () { return 0 >= this.level ? null : new q(this.level - 1, this.row >> 1, this.col >> 1, this.world) }; u.getChildKeys = function () {
            const y = this.level + 1, n = this.row << 1, p = this.col <<
              1, l = this.world; return [new q(y, n, p, l), new q(y, n, p + 1, l), new q(y, n + 1, p, l), new q(y, n + 1, p + 1, l)]
          }; u.compareRowMajor = function (y) { return this.row < y.row ? -1 : this.row > y.row ? 1 : this.col < y.col ? -1 : this.col > y.col ? 1 : 0 }; a._createClass(q, [{ key: "key", get: function () { return this } }, { key: "id", get: function () { return this.toString() }, set: function (y) { this.set(y) } }, { key: "hash", get: function () { return (this.world & 3) << 30 | (this.col & 4095) << 22 | (this.row & 4095) << 8 | this.level & 63 } }]); return q
        }(); c.pool = new w(c, null, null, 25, 50); return c
      })
    },
    "esri/views/3d/layers/ElevationLayerView3D": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Error ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./LayerView3D ./TiledLayerView3D ../../layers/LayerView".split(" "), function (a, w, c, q, u, y, n, p, l, h, b) {
        u = function (d) {
          function f() {
            var t = d.apply(this, arguments) || this; t.type =
              "elevation-3d"; return t
          } a._inheritsLoose(f, d); f.prototype.initialize = function () { var t = this.get("view.map.allLayers"); t = t && t.includes(this.layer); var v = this.get("view.map.ground.layers"); v = v && v.includes(this.layer); t && !v && (t = new c("layerview:elevation-layer-only", "3D elevation layer '" + this.layer.id + "' can only be added in the map ground"), this.addResolvingPromise(Promise.reject(t))); this._addTilingSchemeMatchPromise() }; return f
        }(h.TiledLayerView3D(l.LayerView3D(b))); w.__decorate([q.property({
          readOnly: !0,
          aliasOf: "layer.fullExtent"
        })], u.prototype, "fullExtent", void 0); w.__decorate([q.property()], u.prototype, "layer", void 0); w.__decorate([q.property({ readOnly: !0, aliasOf: "layer.tileInfo" })], u.prototype, "tileInfo", void 0); return u = w.__decorate([p.subclass("esri.views.3d.layers.ElevationLayerView3D")], u)
      })
    }, "esri/views/3d/layers/LayerView3D": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/support/heightModelInfoUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
        a.LayerView3D = b => {
          b = function (d) {
            function f() { var v = d.apply(this, arguments) || this; v.slicePlaneEnabled = !1; v.supportsHeightUnitConversion = !1; return v } w._inheritsLoose(f, d); var t = f.prototype; t.postscript = function (v) { d.prototype.postscript.call(this, v); h.mayHaveHeightModelInfo(this.layer) && this.addResolvingPromise(this._validateHeightModelInfo()) }; t._validateHeightModelInfo = function () {
              var v = w._asyncToGenerator(function* () {
                var m = q.whenTrueOnce(this.view.defaultsFromMap, "heightModelInfoReady");
                this.handles.add(m); yield m; if (m = h.rejectLayerError(this.layer, this.view.heightModelInfo, this.supportsHeightUnitConversion)) throw m;
              }); return function () { return v.apply(this, arguments) }
            }(); return f
          }(b); c.__decorate([u.property()], b.prototype, "view", void 0); c.__decorate([u.property()], b.prototype, "slicePlaneEnabled", void 0); return b = c.__decorate([l.subclass("esri.views.3d.layers.LayerView3D")], b)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/TiledLayerView3D": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Error ../../../core/maybe ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../support/updatingProperties ../terrain/terrainUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
        a.TiledLayerView3D = t => {
          t = function (v) {
            function m() { return v.apply(this, arguments) || this } w._inheritsLoose(m, v); var e = m.prototype; e.getTileUrl = function (g, x, k) { return this.layer.getTileUrl(g, x, k) }; e._addTilingSchemeMatchPromise = function () {
              if (u.isNone(this.layer.fullExtent)) return this.addResolvingPromise(Promise.reject(new q("tilingscheme:extent-not-defined", "This layer doesn't define a fullExtent."))); var g = this._getTileInfoSupportError(this.tileInfo, this.layer.fullExtent);
              if (g) return this.addResolvingPromise(Promise.reject(g)); g = y.whenTrueOnce(this.view, "basemapTerrain.tilingSchemeLocked").then(() => { const x = this._getTileInfoCompatibilityError(this.tileInfo, this.view.basemapTerrain.tilingScheme); if (x) throw x; }); this.addResolvingPromise(g)
            }; e._getTileInfoSupportError = function (g, x) {
              if (g = f.checkIfTileInfoSupportedForView(g, x, this.view.spatialReference, this.view.state.viewingMode)) {
                x = { layer: this.layer, error: g }; switch (g.name) {
                  case "tilingscheme:spatial-reference-mismatch": case "tilingscheme:global-unsupported-spatial-reference": case "tilingscheme:local-unsupported-spatial-reference": g =
                    new q("layerview:spatial-reference-incompatible", "The spatial reference of this layer does not meet the requirements of the view", x); break; default: g = new q("layerview:tiling-scheme-unsupported", "The tiling scheme of this layer is not supported by SceneView", x)
                }return g
              } return null
            }; e._getTileInfoCompatibilityError = function (g, x) { return x.compatibleWith(g) ? null : new q("layerview:tiling-scheme-incompatible", "The tiling scheme of this layer is incompatible with the tiling scheme of the surface") }; e.levelRangeFromScaleRange =
              function (g, x) { const k = { minLevel: 0, maxLevel: Infinity }; var r = this.view && this.view.basemapTerrain && this.view.basemapTerrain.tilingScheme; if (!r) return k; const A = r.levels[0]; r = z => { z = Math.log(A.scale / z) / Math.LN2; return 1E-9 > .5 - Math.abs(.5 - z % 1) ? Math.round(z) : Math.ceil(z) }; null != g && 0 < g && (k.minLevel = Math.max(0, r(g))); null != x && 0 < x && (k.maxLevel = Math.max(0, r(x))); return k }; e.isUpdating = function () { return !!(this.view && this.view.basemapTerrain && this.view.basemapTerrain.updating) }; w._createClass(m, [{
                key: "imageFormatIsOpaque",
                get: function () { return !1 }
              }, { key: "isOpaque", get: function () { return 1 <= this.fullOpacity && this.imageFormatIsOpaque } }, { key: "dataLevelRange", get: function () { const g = this.tileInfo.lods; return this.levelRangeFromScaleRange(g[0].scale, g[g.length - 1].scale) } }, { key: "displayLevelRange", get: function () { var g = this.tileInfo.lods; g = this.levelRangeFromScaleRange(this.layer.minScale || g[0].scale, this.layer.maxScale || g[g.length - 1].scale); this.layer.maxScale && g.maxLevel++; return g } }]); return m
          }(t); c.__decorate([n.property({ readOnly: !0 })],
            t.prototype, "imageFormatIsOpaque", null); c.__decorate([n.property({ readOnly: !0 })], t.prototype, "updating", void 0); c.__decorate([n.property(d.updatingProgress)], t.prototype, "updatingProgress", void 0); c.__decorate([n.property(d.updatingProgressValue)], t.prototype, "updatingProgressValue", void 0); c.__decorate([n.property({ readOnly: !0 })], t.prototype, "fullExtent", void 0); c.__decorate([n.property({ readOnly: !0 })], t.prototype, "isOpaque", null); c.__decorate([n.property({ readOnly: !0 })], t.prototype, "dataLevelRange",
              null); c.__decorate([n.property({ readOnly: !0 })], t.prototype, "displayLevelRange", null); c.__decorate([n.property()], t.prototype, "layer", void 0); c.__decorate([n.property({ readOnly: !0 })], t.prototype, "tileInfo", void 0); return t = c.__decorate([b.subclass("esri.views.3d.layers.TiledLayerView3D")], t)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/updatingProperties": function () {
      define(["exports"], function (a) {
      a.updatingProgress = {
        readOnly: !0, value: .5, get() {
          return this.updating ? this.updatingProgressValue :
            1
        }
      }; a.updatingProgressValue = { value: .5, readOnly: !0 }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/ElevationBounds": function () { define(["exports"], function (a) { let w = function () { function c(q = 0, u = 0) { this.min = q; this.max = u; this.level = 0; this.hasNoDataValues = !1 } c.prototype.copyFrom = function (q) { this.min = q.min; this.max = q.max; this.level = q.level; this.hasNoDataValues = q.hasNoDataValues }; return c }(); a.ElevationBounds = w; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/terrain/ElevationData": function () {
      define(["exports",
        "../../../core/mathUtils", "../support/mathUtils", "./TerrainConst"], function (a, w, c, q) {
          let u = function () {
            function y(p, l, h) {
            this.type = "elevation"; this.samplerData = null; this.level = p[0]; this.i = p[1]; this.j = p[2]; this.extent = l; p = h.noDataValue; const b = h.values; let d = Infinity, f = -Infinity, t = !0, v = !1; for (let m = 0; m < b.length; m++) { const e = b[m]; e !== p ? (d = e < d ? e : d, f = e > f ? e : f, t = !1) : v = !0 } t && (f = d = 0); this.samplerData = {
              pixelData: h.values, width: h.width, height: h.height, noDataValue: p, safeWidth: .99999999 * (h.width - 1), dx: (h.width -
                1) / (l[2] - l[0]), dy: (h.width - 1) / (l[3] - l[1]), x0: l[0], y1: l[3]
            }; this.bounds = [d, -3E38 < f ? f : 0]; this.hasNoDataValues = v
            } var n = y.prototype; n.release = function () { this.bounds = this.samplerData = null }; n.computeMinMaxValue = function (p, l, h, b) {
            b.min = Infinity; b.max = -Infinity; b.hasNoDataValues = !1; p -= this.level; if (0 >= p) return b; var d = 2 ** p; if (Math.floor(l / d) !== this.i || Math.floor(h / d) !== this.j) return b; var f = Infinity, t = -Infinity, v = this.samplerData.width, m = this.samplerData.pixelData, e = .5 * q.ELEVATION_NODATA_VALUE; p = (v - 1) / d;
              h = (h - this.j * d) * p; let g = (l - this.i * d) * p; if (1 > p) { const r = Math.floor(h), A = Math.floor(g); var x = r + A * v; l = m[x]; d = m[x + 1]; var k = m[x + v]; x = m[x + v + 1]; if (l + d + k + x < e) return f = h - r, e = g - A, t = c.bilerp(l, d, k, x, f, e), v = c.bilerp(l, d, k, x, f + p, e), m = c.bilerp(l, d, k, x, f, e + p), p = c.bilerp(l, d, k, x, f + p, e + p), b.min = Math.min(t, v, m, p), b.max = Math.max(t, v, m, p), b; h = r; g = A; p = 1 } else h = Math.floor(h), g = Math.floor(g), p = Math.ceil(p); for (l = h; l <= h + p; l++)for (d = g; d <= g + p; d++)k = m[l + d * v], k < e ? (f = Math.min(f, k), t = Math.max(t, k)) : b.hasNoDataValues = !0; b.min = f;
              b.max = t; return b
            }; y.sample = function (p, l, h) { for (const v of h) { if (!v) continue; var b = v.safeWidth, d = v.width, f = v.pixelData; h = w.clamp(v.dy * (v.y1 - l), 0, b); b = w.clamp(v.dx * (p - v.x0), 0, b); const m = Math.floor(h), e = Math.floor(b); var t = m * d + e; const g = t + d, x = f[t]; d = f[g]; t = f[t + 1]; f = f[g + 1]; if (x + d + t + f < .5 * q.ELEVATION_NODATA_VALUE) return h -= m, b -= e, p = x + (t - x) * b, p + (d + (f - d) * b - p) * h } return null }; return y
          }(); a.ElevationData = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/ExtentHelper": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/projection ../../../geometry/support/aaBoundingRect ../../../layers/support/layerUtils ./TerrainConst ./terrainUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          function e(k, r) { return y.isSome(k) && !k.spatialReference.equals(r) ? d.projectWithoutEngine(k, k.spatialReference, r) : k } a.ExtentHelper = function (k) {
            function r(z) { z = k.call(this, z) || this; z._handles = new u; return z } w._inheritsLoose(r, k); var A = r.prototype; A.initialize = function () { this._handles.add([this.layerViews.on("change", () => this.notifyChange("stencilEnabledExtents"))]) }; A.destroy = function () { this._handles.destroy(); this._handles = null }; A._computeStencilEnabledExtents =
              function () { const z = []; this.layerViews.forEach(B => { B = B.layer; "IntegratedMeshLayer" === B.operationalLayerType && null != this.viewSpatialReference && (B = e(B.fullExtent, this.viewSpatialReference), y.isSome(B) && z.push(f.fromExtent(B))) }); return z }; w._createClass(r, [{ key: "layerViewsExtent", get: function () { return this._computeLayerViewsExtent() } }, { key: "tiledLayersExtent", get: function () { return this._computeTiledLayersExtent() } }, { key: "stencilEnabledExtents", get: function () { return this._computeStencilEnabledExtents() } }]);
            return r
          }(q); c.__decorate([n.property({ readOnly: !0 })], a.ExtentHelper.prototype, "layerViewsExtent", null); c.__decorate([n.property({ readOnly: !0 })], a.ExtentHelper.prototype, "tiledLayersExtent", null); c.__decorate([n.property({ readOnly: !0 })], a.ExtentHelper.prototype, "stencilEnabledExtents", null); c.__decorate([n.property()], a.ExtentHelper.prototype, "viewSpatialReference", void 0); c.__decorate([n.property()], a.ExtentHelper.prototype, "tilingScheme", void 0); c.__decorate([n.property()], a.ExtentHelper.prototype,
            "defaultTiledLayersExtent", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.ExtentHelper.prototype, "layers", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.ExtentHelper.prototype, "layerViews", void 0); a.ExtentHelper = c.__decorate([b.subclass("esri.views.3d.terrain.ExtentHelper")], a.ExtentHelper); let g = function (k) {
              function r() { return k.apply(this, arguments) || this } w._inheritsLoose(r, k); var A = r.prototype; A._computeLayerViewsExtent = function () { return this._globalExtent }; A._computeTiledLayersExtent =
                function () { return this._globalExtent }; w._createClass(r, [{ key: "_globalExtent", get: function () { return this.viewSpatialReference.isWebMercator ? v.WEBMERCATOR_WORLD_EXTENT : v.GEOGRAPHIC_WORLD_EXTENT } }]); return r
            }(a.ExtentHelper); g = c.__decorate([b.subclass("esri.views.3d.terrain.ExtentHelperGlobal")], g); let x = function (k) {
              function r() { return k.apply(this, arguments) || this } w._inheritsLoose(r, k); var A = r.prototype; A._computeLayerViewsExtent = function () {
                const z = f.empty(), B = this.viewSpatialReference; this.layerViews.forEach(E => { const H = E.layer; !E.isResolved() || "graphics" === H.type && H.internal || (E = e("fullExtentInLocalViewSpatialReference" in E && E.fullExtentInLocalViewSpatialReference || E.layer.fullExtent, B), f.expand(z, E, z)) }); const C = f.allFinite(z) ? z : null, D = this._get("layerViewsExtent"); return f.equals(C, D) ? D : C
              }; A._computeTiledLayersExtent = function () {
                const z = this.tilingScheme; if (!z) return null; const B = this.viewSpatialReference, C = f.empty(); this.layers.forEach(H => {
                  if (H.loaded && t.isTiledLayer(H)) {
                    const F = m.getTiledLayerInfo(H,
                      B, 2); if (!y.isNone(F)) { var { tileInfo: J, fullExtent: M } = F; (y.isSome(J) && m.isProjectableRasterLayer(H) && y.isSome(M) || y.isSome(J) && z.compatibleWith(J) && y.isSome(M) && M.spatialReference.equals(z.spatialReference)) && f.expand(C, M, C) }
                  }
                }); f.expand(C, this.defaultTiledLayersExtent, C); const D = f.allFinite(C) ? C : null, E = this._get("tiledLayersExtent"); return f.equals(D, E) ? E : D
              }; return r
            }(a.ExtentHelper); x = c.__decorate([b.subclass("esri.views.3d.terrain.ExtentHelperLocal")], x); a.create = function (k, r) {
              return 1 === k ? new g(r) :
                new x(r)
            }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/LayerClass": function () { define(["exports"], function (a) { a.LayerClasses = [0, 1]; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/terrain/OverlayManager": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/has ../../../core/mathUtils ../../../core/maybe ../../../core/scheduling ../../../core/time ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec2 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4 ../../../chunks/vec4f64 ../../../geometry/projection ../../../geometry/projectionEllipsoid ../../../geometry/support/aaBoundingRect ../../../geometry/support/ray ../../../chunks/sphere ../../../geometry/support/vector ../../../geometry/support/webMercatorUtils ../state/utils/viewUtils ../support/animationUtils ../support/debugFlags ../support/debugUtils ../support/mathUtils ./Overlay ./OverlayRenderer ../webgl-engine/lib/Intersector ../webgl-engine/lib/localOrigin ../webgl-engine/parts/requireUtils ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I) {
          const O = [[-.1, -2, 3.9, 2], [-.1, -3.9, 3.9, .1], [-2, -3.9, 2, .1], [-3.9, -3.9, .1, .1], [-3.9, -2, .1, 2], [-3.9, -.1, .1, 3.9], [-2, -.1, 2, 3.9], [-.1, -.1, 3.9, 3.9]]; let R; a.OverlayManager = function (ha) {
            function ka(ba) {
              ba = ha.call(this, ba) || this; ba._handles = new u; ba._spatialReference = null; ba._renderSR = null; ba._overlaySREqualsRenderSR = !0; ba._drapeSources = new Map; ba._drapeTargets = new Set; ba._placementDirty = !1; ba._contentUpdated = !1; ba._drawTexturesDirty =
                !1; ba._drawTexturesAnimateDirty = !1; ba._layerViewsDirty = !0; ba._hasUnusedRenderTargets = !1; ba._longitudeCyclical = null; ba._latestOriginId = 0; ba._maxResolution = y("esri-mobile") ? 2048 : 4096; ba._animationTimeLast = 0; return ba
            } w._inheritsLoose(ka, ha); var ea = ka.prototype; ea.initialize = function () {
              const ba = this.view; this.renderer = new P.OverlayRenderer({ view: ba, worldToPCSRatio: this._worldToPCSRatio, spatialReference: this._spatialReference }); this._groundIntersector = L.newIntersector(this.view.state.viewingMode); this._groundIntersector.options.backfacesTerrain =
                !0; this._groundIntersector.options.invisibleTerrain = !0; this._groundIntersector.options.hud = !1; this._handles.add([this.renderer.events.on("has-highlights", () => { this._setDrawTexturesDirty(); this.notifyChange("hasHighlights") }), this.renderer.events.on("has-water", aa => { var W; return null == (W = ba._stage) ? void 0 : W.renderView.setRenderParameters({ hasOverlayWater: aa }) }), this.renderer.events.on("renders-occluded", () => { this._setDrawTexturesDirty(); this.notifyChange("rendersOccluded") }), this.renderer.events.on("content-changed",
                  () => this._setDrawTexturesDirty()), this.renderer.events.on("textures-disposed", () => this.updateDrapeTargets()), ba.watch(["pointsOfInterest.renderPointOfView", "pointsOfInterest.centerOnSurfaceFrequent.location", "pixelRatio"], () => this.setPlacementDirty()), this.surface.on("elevation-change", () => this.setPlacementDirty()), ba.allLayerViews.on("after-changes", () => this._layerViewsDirty = !0), ba.watch("graphicsView", () => this._layerViewsDirty = !0), ba.on("resize", () => this.setPlacementDirty()), l.addFrameTask({
                    preRender: aa => { this._contentUpdated = !1; this.renderer.processSyncLayers(); this._updateLayerViews(); this.renderer.hasOverlays && (this._dispatchRendererUpdate(aa), this._drawOverlayTextures(this.renderer.overlays, 1)); this._hasUnusedRenderTargets && this._collectUnusedRenderTargetMemory() }
                  }), ba.resourceController.scheduler.registerTask(I.TaskPriority.OVERLAY, this), ba._stage.renderView.events.on("force-camera-for-screenshot", aa => {
                    this._updateOverlays(aa, 0); this.renderer.hasOverlays && this._drawOverlayTextures(this.renderer.overlays,
                      0, aa)
                  })]); this._updateLayerViews()
            }; ea.destroy = function () { this._drapeSources.forEach((ba, aa) => this.unregisterDrapeSource(aa)); this._drapeTargets.forEach(ba => this._unregisterDrapeTarget(ba)); this.renderer.dispose(); this._handles && (this._handles.destroy(), this._handles = null); p.isSome(R) && (R.hide(), R = null) }; ea.setSpatialReference = function (ba) {
            this._spatialReference = ba; this.renderer.spatialReference = ba; this._longitudeCyclical = null; const aa = this.view.renderSpatialReference; p.isSome(ba) && p.isSome(aa) ? (this._renderSR =
              aa, this._overlaySREqualsRenderSR = ba.equals(this._renderSR), this._isSpherical && (this._longitudeCyclical = ba.isWebMercator ? new F.Cyclical(-2.0037508342787E7, 2.0037508342787E7) : new F.Cyclical(-180, 180), this.renderer.longitudeCyclical = this._longitudeCyclical), this.renderer && (this.renderer.worldToPCSRatio = this._worldToPCSRatio)) : this.renderer.disposeOverlays()
            }; ea._updateLayerViews = function () {
              if (this._layerViewsDirty) {
                var ba = new Set; for (var aa of this.view.allLayerViews.items) ba.add(aa.uid), "drapeSourceType" in
                  aa && !this._drapeSources.has(aa) && this._registerDrapeSource(aa, 0), "drapeTargetType" in aa && !this._drapeTargets.has(aa) && this._registerDrapeTarget(aa); aa = this.view.graphicsView; p.isSome(aa) && !this._drapeSources.has(aa) && (this._registerDrapeSource(aa, 0), ba.add(aa.uid)); this._drapeSources.forEach((W, U) => { 0 !== W || ba.has(U.uid) || this.unregisterDrapeSource(U) }); this._drapeTargets.forEach(W => { ba.has(W.uid) || this._unregisterDrapeTarget(W) }); this.renderer.updateLayerOrder(); this._setDrawTexturesDirty(); this._layerViewsDirty =
                    !1
              }
            }; ea.registerDrapeSource = function (ba) { this._registerDrapeSource(ba, 1) }; ea._registerDrapeSource = function (ba, aa) { this._drapeSources.set(ba, aa); this.renderer.ensureOverlays(this._drapeTargets, this._drapeSources); this._updateDrapeSourceExtent(ba); this._setContentDirty(); this.notifyChange("running") }; ea._updateDrapeSourceExtent = function (ba) { 2 === this.renderer.overlays.length && p.isSome(ba.setDrapingExtent) && p.isSome(this._spatialReference) && ba.setDrapingExtent(this.renderer.overlays, this._spatialReference) };
            ea.unregisterDrapeSource = function (ba) { this._drapeSources.has(ba) && (this._drapeSources.delete(ba), this.renderer.ensureDrapeSources(this._drapeSources), this._setContentDirty(), this.notifyChange("running")) }; ea._registerDrapeTarget = function (ba) { this._drapeTargets.add(ba); this._updateDrapeTarget(ba); this.renderer.ensureOverlays(this._drapeTargets, this._drapeSources) }; ea.updateDrapeTargets = function () { this._drapeTargets.forEach(ba => this._updateDrapeTarget(ba)) }; ea._updateDrapeTarget = function (ba) { ba.setDrapingTextures(this.renderer.overlays) };
            ea._unregisterDrapeTarget = function (ba) { this._drapeTargets.delete(ba); this.renderer.ensureDrapeTargets(this._drapeTargets) }; ea._setContentDirty = function () { this.setPlacementDirty(); this._setDrawTexturesDirty() }; ea.setPlacementDirty = function () { this._placementDirty = !0 }; ea.runTask = function () { this._updateOverlays(this.view.state.camera, 1) }; ea._updateOverlays = function (ba, aa) {
              if (this._spatialReference) {
                this._updateLayerViews(); var W = K.computeOverlayResolution(ba.fullWidth, ba.fullHeight, this._maxResolution);
                this._computeOverlayExtents(ba, W, T); var U = A.width(T.inner) / A.width(T.outer); this.renderer.ensureOverlays(this._drapeTargets, this._drapeSources); ba = this._updateOverlay(0, T.inner, W, 1 * T.pixelRatioAdjustment, T.mapUnitsPerPixel); W = this._updateOverlay(1, T.outer, W, U * T.pixelRatioAdjustment, T.mapUnitsPerPixel); if (1 === ba || 1 === W) this._drapeSources.forEach((X, Z) => this._updateDrapeSourceExtent(Z)), this.surface.updateTileOverlayParams(aa); 0 === ba && 0 === W || this._setDrawTexturesDirty(); this._placementDirty = !1
              }
            }; ea._updateOverlay =
              function (ba, aa, W, U, X) {
                if (0 === this.renderer.overlays.length) return 0; ba = this.renderer.overlays[ba]; const Z = ba.mapUnitsPerPixel; ba.mapUnitsPerPixel = X; ba.pixelRatio = U; { U = ba.extent; const ia = J.TESTS_DISABLE_OPTIMIZATIONS ? 0 : 1E-5 * Math.max(aa[2] - aa[0], aa[3] - aa[1], U[2] - U[0], U[3] - U[1]); U = Math.abs(U[0] - aa[0]) <= ia && Math.abs(U[1] - aa[1]) <= ia && Math.abs(U[2] - aa[2]) <= ia && Math.abs(U[3] - aa[3]) <= ia } if (U && W === ba.resolution) return Z === X ? 0 : 2; A.copy(ba.extent, aa); ba.resolution = W; aa = A.center(ba.extent); ba.renderLocalOrigin =
                  N.fromValues(aa[0], aa[1], 0, `OV_${this._latestOriginId++}`); return 1
              }; ea.setTileParameters = function (ba) {
                const aa = ba.renderData.overlay; if (0 < this.renderer.overlays.length) {
                  const W = this.renderer.overlays[0], U = this.renderer.overlays[1]; ba = A.intersection(ba.extent, this.surface.extent, da); this._rectInsideRect(W.extent, ba) || this._rectanglesOverlap(ba, W.extent) || this._rectanglesOverlap(ba, U.extent) ? (this._setTileOverlayData(ba, 0, aa), this._setTileOverlayData(ba, 1, aa)) : (this._clearTileOverlayData(0, aa), this._clearTileOverlayData(1,
                    aa))
                } else this._clearTileOverlayData(0, aa), this._clearTileOverlayData(1, aa)
              }; ea.overlayPixelSizeInMapUnits = function (ba) { if (0 === this.renderer.overlays.length) return 0; const aa = this.renderer.overlays[0], W = this.renderer.overlays[1]; ba = this._pointIsInExtent(ba, aa.extent) ? aa : W; return (ba.extent[2] - ba.extent[0]) / ba.resolution }; ea._setTileOverlayData = function (ba, aa, W) {
                if (0 !== this.renderer.overlays.length) {
                  var U = this.renderer.overlays[aa].extent, X = A.width(U), Z = A.height(U), ia = ba[0]; if (this._longitudeCyclical) {
                    ia =
                    this._longitudeCyclical.minimalMonotonic(U[0], ia); const la = this._longitudeCyclical.minimalMonotonic(U[0], ba[2]); ia > la && (ia = la - (ba[2] - ba[0]))
                  } W.setScale(aa, A.width(ba) / X, A.height(ba) / Z); W.setOffset(aa, (ia - U[0]) / X, (ba[1] - U[1]) / Z)
                }
              }; ea._clearTileOverlayData = function (ba, aa) { aa.setScale(ba, -1, -1); aa.setOffset(ba, -1, -1) }; ea.reloadShaders = function () {
                var ba = w._asyncToGenerator(function* () { G.removeLoadedShaderModules(); yield this.renderer.reloadShaders(); this._setDrawTexturesDirty(); this.runTask() }); return function () {
                  return ba.apply(this,
                    arguments)
                }
              }(); ea._dispatchRendererUpdate = function (ba) { const aa = h.Milliseconds(ba.time - this._animationTimeLast); aa < H.DESIRED_DRAPED_ANIMATION_MS && p.isNone(this.forcedAnimationTime) || (this._animationTimeLast = ba.time, this.renderer.updateLogic({ dt: aa, forcedTime: this.forcedAnimationTime, camera: this.view.state.camera }) && (this._drawTexturesAnimateDirty = !0)) }; ea._setDrawTexturesDirty = function () { this.renderer.hasOverlays ? this._drawTexturesDirty = this._contentUpdated = !0 : this.setPlacementDirty() }; ea._intersectGroundFromView =
                function (ba, aa, W, U) { W = this.view.sceneIntersectionHelper.getCenterRayWithSubpixelOffset(ba, fa, aa, W); if (p.isNone(W)) return !1; aa = W.origin; W = m.add(Q, W.origin, W.direction); this._groundIntersector.reset(aa, W, ba); this._groundIntersector.intersect([], null); this.view.basemapTerrain.intersect(this._groundIntersector, null, aa, W); return this._groundIntersector.results.min.getIntersectionPoint(U) }; ea._findHorizonBasedPointOfInterest = function (ba, aa) {
                  var W = .5; W = this.view.renderCoordsHelper.getAltitude(ba.eye); const U =
                    this.view.pointsOfInterest.centerOnSurfaceFrequent; var X = n.clamp(U.estimatedSurfaceAltitude, ba.aboveGround ? -Infinity : W + 1E-5, ba.aboveGround ? W - 1E-5 : Infinity); W = ba.aboveGround; if ("global" === this.view.viewingMode) { var Z = Q; B.closestPointOnSilhouette(B.fromRadius(r.getReferenceEllipsoid(this.view.spatialReference).radius + X), z.wrap(ba.eye, ba.viewForward), Z); m.subtract(Z, Z, ba.eye); X = F.cyclicalPI.normalize(C.angleAroundAxis(ba.viewForward, Z, ba.viewRight)) / ba.fovY + .5; Z = 0 >= X || 1 <= X ? .5 : .55; W = W ? Z * X : X + Z * (1 - X) } else X =
                      x.fromValues(0, Math.tan(.5 * Math.PI - Math.acos(-ba.viewForward[2])), 1, 0), X = g.transformMat4(X, X, ba.projectionMatrix)[1], X = n.clamp(.5 + .5 * X, 0, 1), W = 1 === X || 0 === X ? .5 : W ? .55 * X : 1 - .55 * (1 - X); return this._intersectGroundFromView(ba, .5, W, aa) ? m.sqrDist(aa, ba.eye) < U.distance * U.distance : !1
                }; ea._computeOverlayExtents = function (ba, aa, W) {
                  var U = this.view.pointsOfInterest.centerOnSurfaceFrequent.renderLocation, X = e.create(); this._findHorizonBasedPointOfInterest(ba, X) || m.copy(X, U); var Z = Math.max(.1, m.distance(ba.eye, X)); U =
                    E.viewAngle(this.view.renderCoordsHelper, U, ba.eye); const ia = Math.PI / 2 - Math.abs(U - Math.PI / 2); J.OVERLAY_SHOW_CENTER ? (p.isNone(R) && (R = new M.PointGraphics(this.view.graphics, "red")), R.show(X, this._renderSR)) : p.isSome(R) && R.hide(); this._overlaySREqualsRenderSR || k.projectVectorToVector(X, this._renderSR, X, this._spatialReference); U = this.surface.extent; var la = !this._isSpherical && p.isSome(this._spatialReference) && this._spatialReference.isGeographic, ma = la && p.isSome(this._spatialReference) ? 1 / r.getReferenceEllipsoid(this._spatialReference).metersPerDegree :
                      1; Z = ba.perRenderPixelRatio * Z * ma; W.mapUnitsPerPixel = Z / this._worldToPCSRatio; Z = aa * Z / 2; var ra = !1; la = la ? 90 : Infinity; this._isSpherical && p.isSome(U) && p.isSome(this._spatialReference) && (this._spatialReference.isWebMercator ? (Z /= Math.cos(D.y2lat(X[1])), la = U[3]) : (ra = !0, Z /= r.getReferenceEllipsoid(this._spatialReference).metersPerDegree, la = 90), Z >= la && (Z = la, X[1] = 0, this._spatialReference.isWebMercator && (X[0] = 0))); ma = 1; ra && (ma = 1 / Math.max(.2, Math.cos(Math.abs(n.deg2rad(X[1])))), 180 < Z * ma && (ma = 180 / Z), W.mapUnitsPerPixel *=
                        ma); ra = Math.log(2) / 12; Z = Math.exp(Math.round(Math.log(Z) / ra) * ra); const Aa = Z * ma; ra = .5 * aa / (32 * Aa); var za = .5 * aa / (32 * Z); X[0] = Math.round(X[0] * ra) / ra; X[1] = Math.round(X[1] * za) / za; ra = W.inner; ra[0] = X[0] - Aa; ra[1] = X[1] - Z; ra[2] = X[0] + Aa; ra[3] = X[1] + Z; this._isSpherical && this._shiftExtentToFitBounds(ra, Infinity, la); za = W.outer; 6 * Aa > A.width(U) ? A.copy(za, p.unwrap(U)) : ia <= .25 * Math.PI ? (za[0] = ra[0] - Aa, za[1] = ra[1] - Z, za[2] = ra[2] + Aa, za[3] = ra[3] + Z) : (k.projectVectorToVector(ba.eye, this._renderSR, Q, this._spatialReference), v.subtract(S,
                          X, Q), ba = -Math.atan2(S[1], S[0]) + .125 * Math.PI, 0 > ba && (ba += 2 * Math.PI), g.scale(S, O[Math.floor(ba / (.25 * Math.PI))], 2 * Z), S[0] *= ma, S[2] *= ma, g.add(za, ra, S)); this._isSpherical ? (za[0] = this._longitudeCyclical.clamp(za[0]), za[2] = this._longitudeCyclical.clamp(za[2]), za[1] = Math.max(za[1], -la), za[3] = Math.min(za[3], la)) : (ba = A.intersection(ra, U, da), X = A.intersection(za, U, Y), A.contains(ba, X) && (za[2] = za[0], za[3] = za[1])); aa = Math.abs(ra[2] - ra[0]) / aa; W.mapUnitsPerPixel = Math.max(W.mapUnitsPerPixel, aa); W.pixelRatioAdjustment =
                            W.mapUnitsPerPixel / aa
                }; ea._drawOverlayTextures = function (ba, aa, W = this.view.state.camera) {
                  if (0 !== ba.length && (this._drawTexturesDirty || this._drawTexturesAnimateDirty)) {
                    var U = this._drawTexturesDirty; this._drawTexturesAnimateDirty = this._drawTexturesDirty = !1; var X = this._drawOverlay(ba[0], W); ba = this._drawOverlay(ba[1], W); 0 !== X && 0 !== ba || this.surface.updateTileOverlayParams(1); this._collectUnusedRenderTargetMemory(); this.updateDrapeTargets(); U ? (this.surface.requestRender(aa), 1 === aa && this.surface.requestUpdate()) :
                      this.surface.requestRender(0)
                  }
                }; ea._drawOverlay = function (ba, aa) { this._longitudeCyclical ? ba.setupGeometryViewsCyclical(this._longitudeCyclical) : ba.setupGeometryViewsDirect(); return ba.draw(this.renderer, aa.pixelRatio) }; ea._collectUnusedRenderTargetMemory = function () { this._hasUnusedRenderTargets = !1; if (this.renderer.hasOverlays) { const ba = performance.now(); this._hasUnusedRenderTargets = this.renderer.collectUnusedRenderTargetMemory(ba) } }; ea._rectanglesOverlap = function (ba, aa) {
                  return p.isNone(ba) ? !1 : this._longitudeCyclical ?
                    (this._longitudeCyclical.contains(aa[0], aa[2], ba[0]) || this._longitudeCyclical.contains(aa[0], aa[2], ba[2]) || this._longitudeCyclical.contains(ba[0], ba[2], aa[0])) && !(ba[1] > aa[3] || ba[3] < aa[1]) : A.intersects(ba, aa)
                }; ea._rectInsideRect = function (ba, aa) { return p.isNone(aa) ? !1 : this._longitudeCyclical ? this._longitudeCyclical.contains(ba[0], ba[2], aa[0]) && this._longitudeCyclical.contains(ba[0], ba[2], aa[2]) && aa[1] > ba[1] && aa[3] < ba[3] : A.contains(ba, aa) }; ea._pointIsInExtent = function (ba, aa) {
                  if (this._longitudeCyclical) return this._longitudeCyclical.contains(aa[0],
                    aa[2], ba.x) && ba.y >= aa[1] && ba.y <= aa[3]; const W = ba.x; ba = ba.y; return W > aa[0] && W < aa[2] && ba > aa[1] && ba < aa[3]
                }; ea._shiftExtentToFitBounds = function (ba, aa, W) { let U = 0, X = 0; ba[0] < -aa ? U = ba[0] + aa : ba[2] > aa && (U = aa - ba[2]); ba[1] < -W ? X = ba[1] + W : ba[3] > W && (X = W - ba[3]); A.offset(ba, U, X) }; w._createClass(ka, [{ key: "running", get: function () { return (this._placementDirty || this._layerViewsDirty) && (0 < this._drapeSources.size || 0 < this.view.graphics.length || J.OVERLAY_DRAW_DEBUG_TEXTURE) && !!this._spatialReference && !this.suspended && this.surface.ready } },
                { key: "_isSpherical", get: function () { return this.view.state.isGlobal } }, { key: "_worldToPCSRatio", get: function () { return p.isSome(this._spatialReference) && this._spatialReference.isGeographic && !this.view.state.isLocal ? r.getReferenceEllipsoid(this._spatialReference).metersPerDegree : 1 } }, { key: "view", get: function () { return this.surface.view } }, { key: "updating", get: function () { return this.running || this.renderer.updating || this._contentUpdated } }, { key: "hasHighlights", get: function () { return this.renderer.hasHighlights } },
                { key: "rendersOccluded", get: function () { return this.renderer.rendersOccluded } }, { key: "hasOverlays", get: function () { return this.renderer.hasOverlays } }, { key: "gpuMemoryUsage", get: function () { return this.renderer.gpuMemoryUsage } }, { key: "test", get: function () { return { renderer: this.renderer, update: () => this.runTask() } } }]); return ka
          }(q); c.__decorate([b.property()], a.OverlayManager.prototype, "_spatialReference", void 0); c.__decorate([b.property({ readOnly: !0 })], a.OverlayManager.prototype, "running", null); c.__decorate([b.property()],
            a.OverlayManager.prototype, "_placementDirty", void 0); c.__decorate([b.property()], a.OverlayManager.prototype, "_contentUpdated", void 0); c.__decorate([b.property()], a.OverlayManager.prototype, "_layerViewsDirty", void 0); c.__decorate([b.property()], a.OverlayManager.prototype, "_isSpherical", null); c.__decorate([b.property()], a.OverlayManager.prototype, "_worldToPCSRatio", null); c.__decorate([b.property()], a.OverlayManager.prototype, "renderer", void 0); c.__decorate([b.property({ constructOnly: !0 })], a.OverlayManager.prototype,
              "surface", void 0); c.__decorate([b.property({ readOnly: !0, aliasOf: "surface.suspended" })], a.OverlayManager.prototype, "suspended", void 0); c.__decorate([b.property({ readOnly: !0 })], a.OverlayManager.prototype, "updating", null); c.__decorate([b.property({ type: Boolean })], a.OverlayManager.prototype, "hasHighlights", null); c.__decorate([b.property({ type: Boolean })], a.OverlayManager.prototype, "rendersOccluded", null); a.OverlayManager = c.__decorate([t.subclass("esri.views.3d.terrain.OverlayManager")], a.OverlayManager);
          const S = x.create(), Q = e.create(), T = { inner: A.create(), outer: A.create(), mapUnitsPerPixel: 0, pixelRatioAdjustment: 1 }, da = A.create(), Y = A.create(), fa = z.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/animationUtils": function () {
      define(["exports", "../../../core/time"], function (a, w) {
        const c = w.Milliseconds(40); w = w.Milliseconds(50); a.DESIRED_ANIMATION_FPS = 25; a.DESIRED_ANIMATION_MS = c; a.DESIRED_DRAPED_ANIMATION_FPS = 20; a.DESIRED_DRAPED_ANIMATION_MS = w; Object.defineProperty(a, "__esModule",
          { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/parts/requireUtils": function () { define(["exports"], function (a) { a.removeLoadedShaderModules = function () { var w; const c = null == (w = globalThis.require) ? void 0 : w.modules; if (c) { w = Object.keys(c); for (const q of w) -1 !== q.search(".glsl") && delete c[q] } }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/terrain/PlanarPatch": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../core/maybe ../../../chunks/vec3f64 ../../../geometry/support/aaBoundingBox ../../../geometry/support/frustum ../../../geometry/support/spatialReferenceUtils ./PatchGeometryFactory ./Tile ../webgl-engine/materials/internal/MaterialUtil".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          h = function (f) {
            function t(m, e, g) { var x = f.call(this) || this; x.horizontalScaleFactor = 1; void 0 !== m && x.init(m, e, g); return x } w._inheritsLoose(t, f); var v = t.prototype; v.init = function (m, e, g) {
              f.prototype.init.call(this, m, e, g); m = g.view.renderSpatialReference; this.horizontalScaleFactor = q.isSome(m) && p.isPlateCarree(m) && g.spatialReference.isGeographic ? this.ellipsoid.radius * Math.PI / 180 : 1; this._edgeLen = (this.extent[2] - this.extent[0]) * this.horizontalScaleFactor; this._edgeLen2 = this._edgeLen *
                this._edgeLen; this.centerAtSeaLevel[0] = c.lerp(this.extent[0], this.extent[2], .5) * this.horizontalScaleFactor; this.centerAtSeaLevel[1] = c.lerp(this.extent[1], this.extent[3], .5) * this.horizontalScaleFactor; this.centerAtSeaLevel[2] = 0; this.updateRadiusAndCenter()
            }; v.updateRadiusAndCenter = function () { this._updateCenter(); const m = (this.extent[2] - this.extent[0]) * Math.SQRT1_2, e = .5 * (this.elevationBounds[0] - this.elevationBounds[1]); this._center[1][3] = Math.sqrt(m * m + e * e) }; v._isVisible = function (m) {
              return n.intersectsAABB(m,
                this._aabb())
            }; v._aabb = function () { return y.wrap(this.extent[0] * this.horizontalScaleFactor, this.extent[1] * this.horizontalScaleFactor, this.elevationBounds[0], this.extent[2] * this.horizontalScaleFactor, this.extent[3] * this.horizontalScaleFactor, this.elevationBounds[1]) }; v.intersectsRay = function (m, e, g, x, k) { d[0] = 1 / e[0]; d[1] = 1 / e[1]; d[2] = 1 / e[2]; e = k * (this.extent[2] - this.extent[0]) * this.horizontalScaleFactor * .1; return b.intersectAabbInvDirBefore(this._aabb(), m, d, g + e, x) }; v.createGeometry = function (m, e) {
              l.createPlanarGlobePatch(m,
                this.extent, e, this.horizontalScaleFactor, this.renderData); this.setMemoryDirty()
            }; v.getDefaultVerticesPerRowOnLevel = function () { return 9 > this.level ? 3 : 2 }; return t
          }(h.Tile); const d = u.create(); a.PlanarPatch = h; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/PatchGeometryFactory": function () {
      define("exports ../../../core/mathUtils ../../../core/maybe ../../../chunks/vec3f64 ../../../chunks/vec4 ../../../chunks/vec4f64 ../../../geometry/support/aaBoundingBox ../../../geometry/support/buffer/BufferPool ../support/buffer/InterleavedLayout ./ElevationData ./TerrainConst ../webgl-engine/materials/internal/MaterialUtil".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          function f(D, E, H, J) {
            const M = 0 < (H & 2), F = E + (J ? 1024 : 0) + (M ? 2048 : 0); var K = k.get(F); if (!K) {
              {
                K = E - 1; const G = E - 1, I = E * E; var P = 2 * K + 2 * G; let O = K * G * 6, R = 6 * P, S = 6 * (2 * K + G - 1); J && (O *= 2, R *= 2, S *= 2); P = 65536 < I + P ? new Uint32Array(O + R) : new Uint16Array(O + R); let Q = 0, T = 0, da = O, Y, fa; let ha = 0; for (let ka = 0; ka <= G; ka++) {
                  M && (ha = 0 === ka ? S : ka === G ? -S : 0); da += ha; for (let ea = 0; ea <= K; ea++) {
                    var L = m(ea, ka, K, G); if (-1 < L) {
                      var N = 0 === ka && ea !== K ? 1 : ea === K && ka !== G ? K + 1 : ka === G && 0 !== ea ? -1 : 0 === ea && 0 !== ka ? -(K + 1) : 0; 0 !== N && (Y =
                        Q, fa = I + L, L = I + (0 === ea && 1 === ka ? 0 : L + 1), N = Q + N, J ? (P[da + 0] = Y, P[da + 1] = fa, P[da + 2] = fa, P[da + 3] = L, P[da + 4] = L, P[da + 5] = Y, P[da + 6] = L, P[da + 7] = N, P[da + 8] = N, P[da + 9] = Y, P[da + 10] = Y, P[da + 11] = L, da += 12) : (P[da + 0] = Y, P[da + 1] = fa, P[da + 2] = L, P[da + 3] = L, P[da + 4] = N, P[da + 5] = Y, da += 6))
                    } ++Q; ea < K && ka < G && (Y = ka * (K + 1) + ea, fa = Y + 1, L = fa + (K + 1), N = L - 1, J ? (P[T + 0] = Y, P[T + 1] = fa, P[T + 2] = fa, P[T + 3] = L, P[T + 4] = L, P[T + 5] = Y, P[T + 6] = L, P[T + 7] = N, P[T + 8] = N, P[T + 9] = Y, P[T + 10] = Y, P[T + 11] = L, T += 12) : (P[T + 0] = Y, P[T + 1] = fa, P[T + 2] = L, P[T + 3] = L, P[T + 4] = N, P[T + 5] = Y, T += 6))
                  } da -= ha
                } K = new x(P,
                  O, R)
              } k.set(F, K)
            } D.indices = K.values; D.numSurfaceIndices = K.numSurfaceIndices; D.numSkirtIndices = K.numSkirtIndices; D.numWithoutSkirtIndices = D.numSurfaceIndices + (H ? 6 * (E - 1) * (J ? 2 : 1) : 0)
          } function t(D, E, H, J) { D < J[0] && (J[0] = D); D > J[3] && (J[3] = D); E < J[1] && (J[1] = E); E > J[4] && (J[4] = E); H < J[2] && (J[2] = H); H > J[5] && (J[5] = H) } function v(D, E) { const H = E > D ? 1 : 0; return 2 + 4 * H + (1 - 2 * H) * (D + E) } function m(D, E, H, J) { return 0 === E ? D : D === H ? H + E : E === J ? H + J + (H - D) : 0 === D && 0 < E ? 2 * H + J + (J - E) : -1 } const e = l.newLayout().vec3f("position").vec2f("uv0"), g =
            new p.BufferPool(D => e.createBuffer(D), D => D.count); let x = function (D, E, H) { this.values = D; this.numSurfaceIndices = E; this.numSkirtIndices = H }; const k = new Map, r = Array(b.MAX_PATCH_TESSELATION + 1), A = Array(b.MAX_PATCH_TESSELATION + 1), z = Array(b.MAX_PATCH_TESSELATION + 1), B = Array(b.MAX_PATCH_TESSELATION + 1), C = q.create(); a.PatchGeometry = function () {
            this.vertexAttributes = this.indices = null; this.boundingBox = n.empty(); this.skirtLength = this.numVertsPerRow = this.numWithoutSkirtIndices = this.numSkirtIndices = this.numSurfaceIndices =
              0; this.uvOffsetAndScale = y.create()
            }; a.clearCaches = function () { g.clear(); k.clear() }; a.createPlanarGlobePatch = function (D, E, H, J, M) {
              const F = E[0], K = E[1], P = E[2] - F, L = E[3] - K, N = D.clippingArea, G = c.isSome(N) ? Math.max(0, (N[0] - E[0]) / P) : 0, I = c.isSome(N) ? Math.max(0, (N[1] - E[1]) / L) : 0, O = c.isSome(N) ? Math.min(1, (N[2] - E[0]) / P) : 1; E = c.isSome(N) ? Math.min(1, (N[3] - E[1]) / L) : 1; const R = O > G ? 1 / (O - G) : 1, S = E > I ? 1 / (E - I) : 1, Q = -G * R, T = -I * S, da = P * J * .1, Y = D.numVertsPerRow - 1, fa = D.numVertsPerRow - 1, ha = D.numVertsPerRow * D.numVertsPerRow, ka = g.acquire(ha +
                (2 * Y + 2 * fa)), ea = ka.position.typedBuffer, ba = ka.uv0.typedBuffer, aa = M.geometryInfo.boundingBox; n.empty(aa); let W = 0; for (let la = 0; la <= fa; la++) {
                  var U = la / fa; let ma = T + U * S; U = K + U * L; c.isSome(N) && (U < N[1] ? (U = N[1], ma = 0) : U > N[3] && (U = N[3], ma = 1)); for (let ra = 0; ra <= Y; ra++) {
                    var X = ra / Y; let Aa = Q + X * R; X = F + X * P; c.isSome(N) && (X < N[0] ? (X = N[0], Aa = 0) : X > N[2] && (X = N[2], Aa = 1)); var Z = D.samplerData ? h.ElevationData.sample(X, U, D.samplerData) || 0 : 0; X = X * J - H[0]; const za = U * J - H[1]; Z -= H[2]; t(X, za, Z, aa); var ia = b.GEOMETRY_VERTEX_STRIDE * W; ea[ia + 0] =
                      X; ea[ia + 1] = za; ea[ia + 2] = Z; ba[ia + 0] = Aa; ba[ia + 1] = ma; ia = m(ra, la, Y, Y); -1 < ia && (ia = b.GEOMETRY_VERTEX_STRIDE * (ha + ia), ea[ia + 0] = X, ea[ia + 1] = za, ea[ia + 2] = Z, ba[ia + 0] = v(Aa, ma), ba[ia + 1] = da); ++W
                  }
                } M.geometryInfo.numVertsPerRow = D.numVertsPerRow; M.geometryInfo.vertexAttributes = ka; M.geometryInfo.skirtLength = da; u.set(M.geometryInfo.uvOffsetAndScale, G, I, O - G, E - I); f(M.geometryInfo, D.numVertsPerRow, 0, D.wireframe); M.intersectionData = null; M.skirtIntersectionData = null
            }; a.createSphericalGlobePatch = function (D, E, H, J, M, F, K, P) {
              var L =
                M[0]; const N = M[1]; var G = M[2]; M = M[3]; const I = .1 * K.radius * (M - N), O = D.numVertsPerRow - 1, R = D.numVertsPerRow - 1, S = D.numVertsPerRow * D.numVertsPerRow, Q = g.acquire(S + (2 * O + 2 * R)), T = Q.position.typedBuffer, da = Q.uv0.typedBuffer, Y = J.geometryInfo.boundingBox; n.empty(Y); var fa = E[2] - E[0]; const ha = E[3] - E[1]; var ka = G - L; G = H[0]; const ea = H[1]; H = H[2]; for (var ba = 0; ba <= O; ba++) { var aa = ba / O, W = L + aa * ka; r[ba] = Math.sin(W); A[ba] = Math.cos(W); z[ba] = aa; B[ba] = E[0] + aa * fa } L = F && !!(P & 1); fa = F && !!(P & 2); ka = 0; for (ba = 0; ba <= R; ba++) {
                  aa = ba / R; var U =
                    w.lerp(N, M, aa); W = Math.cos(U); const ma = Math.sin(U); F ? (U = K.halfSemiMajorAxis * Math.log((1 + ma) / (1 - ma)), aa = (U - E[1]) / ha) : U = 180 * U / Math.PI; for (let ra = 0; ra <= O; ra++) {
                      const Aa = z[ra]; var X = r[ra], Z = A[ra], ia = K.radius; D.samplerData && (ia += h.ElevationData.sample(B[ra], U, D.samplerData) || 0); Z = Z * W * ia - G; X = X * W * ia - ea; ia = ma * ia - H; t(Z, X, ia, Y); var la = b.GEOMETRY_VERTEX_STRIDE * ka; T[la + 0] = Z; T[la + 1] = X; T[la + 2] = ia; da[la + 0] = Aa; da[la + 1] = aa; la = m(ra, ba, O, R); if (-1 < la) {
                        la = b.GEOMETRY_VERTEX_STRIDE * (S + la); const za = L && 0 === ba ? -1 : fa && ba ===
                          R ? 1 : 0; Z = 0 === za ? Z : -G; X = 0 === za ? X : -ea; ia = 0 === za ? ia : K.radius * za - H; T[la + 0] = Z; T[la + 1] = X; T[la + 2] = ia; da[la + 0] = 0 === za ? v(Aa, aa) : Aa; da[la + 1] = 0 === za ? I : aa; 0 !== za && t(Z, X, ia, Y)
                      } ++ka
                    }
                } J.geometryInfo.numVertsPerRow = D.numVertsPerRow; J.geometryInfo.vertexAttributes = Q; J.geometryInfo.skirtLength = I; u.set(J.geometryInfo.uvOffsetAndScale, 0, 0, 1, 1); f(J.geometryInfo, D.numVertsPerRow, F ? P : 0, D.wireframe); J.intersectionData = null; J.skirtIntersectionData = null
            }; a.getGlobalSkirtGeometry = function (D, E, H, J, M, F) {
              const K = J.position, P = J.uv0;
              J = new Map; E *= 3; H = 3 * H - E; const L = new Uint32Array(H); let N = 0; for (let I = 0; I < H; ++I) { const O = D[I + E]; if (J.has(O)) L[I] = J.get(O); else { const R = N++; J.set(O, R); L[I] = R } } const G = new Float64Array(3 * N); J.forEach((I, O) => { let R = K.get(O, 0), S = K.get(O, 1), Q = K.get(O, 2); if (2 <= P.get(O, 0)) { O = R + F[0]; const T = S + F[1], da = Q + F[2], Y = M / Math.sqrt(O * O + T * T + da * da); R += O * Y; S += T * Y; Q += da * Y } G[3 * I] = R; G[3 * I + 1] = S; G[3 * I + 2] = Q }); return { vertices: G, indices: L }
            }; a.intersectSkirtsGlobal = function (D, E, H, J, M, F, K, P, L, N) {
              const G = F.position; F = F.uv0; const I =
                D[0], O = D[1]; D = D[2]; const R = E[0] - I, S = E[1] - O; E = E[2] - D; H *= 3; for (J *= 3; H < J; H += 3) {
                  var Q = M[H], T = M[H + 1], da = M[H + 2], Y = G.get(Q, 0), fa = G.get(Q, 1), ha = G.get(Q, 2), ka = G.get(T, 0), ea = G.get(T, 1), ba = G.get(T, 2), aa = G.get(da, 0), W = G.get(da, 1), U = G.get(da, 2); if (2 <= F.get(Q, 0)) { Q = Y + P[0]; var X = fa + P[1], Z = ha + P[2]; const ia = K / Math.sqrt(Q * Q + X * X + Z * Z); Y += Q * ia; fa += X * ia; ha += Z * ia } 2 <= F.get(T, 0) && (T = ka + P[0], Q = ea + P[1], X = ba + P[2], Z = K / Math.sqrt(T * T + Q * Q + X * X), ka += T * Z, ea += Q * Z, ba += X * Z); 2 <= F.get(da, 0) && (da = aa + P[0], T = W + P[1], Q = U + P[2], X = K / Math.sqrt(da *
                    da + T * T + Q * Q), aa += da * X, W += T * X, U += Q * X); c.isSome(L) && ([Y, fa, ha] = L.applyToVertex(Y, fa, ha), [ka, ea, ba] = L.applyToVertex(ka, ea, ba), [aa, W, U] = L.applyToVertex(aa, W, U)); ka -= Y; ea -= fa; ba -= ha; aa -= Y; W -= fa; U -= ha; T = S * U - W * E; Q = E * aa - U * R; X = R * W - aa * S; da = ka * T + ea * Q + ba * X; if (!(Math.abs(da) <= Number.EPSILON)) {
                      Y = I - Y; fa = O - fa; ha = D - ha; T = Y * T + fa * Q + ha * X; if (0 < da) { if (0 > T || T > da) continue } else if (0 < T || T < da) continue; Q = fa * ba - ea * ha; ha = ha * ka - ba * Y; fa = Y * ea - ka * fa; Y = R * Q + S * ha + E * fa; if (0 < da) { if (0 > Y || T + Y > da) continue } else if (0 < Y || T + Y < da) continue; ha = (aa *
                        Q + W * ha + U * fa) / da; 0 <= ha && (fa = d.computeNormal(ka, ea, ba, aa, W, U, C), N(ha, fa))
                    }
                }
            }; a.intersectSkirtsLocal = function (D, E, H, J, M, F, K, P, L) {
              const N = F.position; F = F.uv0; const G = D[0], I = D[1]; D = D[2]; const O = E[0] - G, R = E[1] - I; E = E[2] - D; H *= 3; for (J *= 3; H < J; H += 3) {
                var S = M[H], Q = M[H + 1], T = M[H + 2], da = N.get(S, 0), Y = N.get(S, 1), fa = N.get(S, 2), ha = N.get(Q, 0), ka = N.get(Q, 1), ea = N.get(Q, 2), ba = N.get(T, 0), aa = N.get(T, 1), W = N.get(T, 2); 2 <= F.get(S, 0) && (fa += K); 2 <= F.get(Q, 0) && (ea += K); 2 <= F.get(T, 0) && (W += K); c.isSome(P) && ([da, Y, fa] = P.applyToVertex(da,
                  Y, fa), [ha, ka, ea] = P.applyToVertex(ha, ka, ea), [ba, aa, W] = P.applyToVertex(ba, aa, W)); S = ha - da; ka -= Y; ea -= fa; ba -= da; aa -= Y; W -= fa; T = R * W - aa * E; ha = E * ba - W * O; const U = O * aa - ba * R; Q = S * T + ka * ha + ea * U; if (!(Math.abs(Q) <= Number.EPSILON)) { da = G - da; Y = I - Y; fa = D - fa; T = da * T + Y * ha + fa * U; if (0 < Q) { if (0 > T || T > Q) continue } else if (0 < T || T < Q) continue; ha = Y * ea - ka * fa; fa = fa * S - ea * da; Y = da * ka - S * Y; da = O * ha + R * fa + E * Y; if (0 < Q) { if (0 > da || T + da > Q) continue } else if (0 < da || T + da < Q) continue; fa = (ba * ha + aa * fa + W * Y) / Q; 0 <= fa && (S = d.computeNormal(S, ka, ea, ba, aa, W, C), L(fa, S)) }
              }
            };
          a.releaseGeometry = function (D) { g.release(D.vertexAttributes); D.vertexAttributes = null; D.indices = null }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/support/buffer/BufferPool": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/PooledArray"], function (a, w, c) {
        let q = function () {
          function u(n, p) { this._factoryCallback = n; this._lengthCallback = p; this._pool = new Map } var y = u.prototype; y.acquire = function (n) {
            if (!u.test.disabled) {
              var p = this._pool.get(n); if (p &&
                0 !== p.length) return p.pop()
            } try { return this._factoryCallback(n) } catch (l) { p = window.performance && window.performance.memory; let h = ""; p && (h = `\n  totalJSHeapSize: ${p.totalJSHeapSize}, usedJSHeapSize: ${p.usedJSHeapSize}, jsHeapSizeLimit: ${p.jsHeapSizeLimit}`); console.log("Array allocation of size " + n + " failed: " + l + h); throw l; }
          }; y.release = function (n) { if (!u.test.disabled) { var p = this._lengthCallback(n), l = this._pool.get(p); l || (l = new c({ shrink: !0 }), this._pool.set(p, l)); l.push(n) } }; y.clear = function () { this._pool.clear() };
          w._createClass(u, [{ key: "test", get: function () { return { size: this._pool.size } } }]); return u
        }(); q.test = { disabled: !1 }; a.BufferPool = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/Tile": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../core/maybe ../../../core/ObjectPool ../../../chunks/vec2 ../../../chunks/vec2f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projectionEllipsoid ../../../geometry/support/aaBoundingRect ../../../chunks/sphere ../../2d/engine/vectorTiles/VectorTile ../support/StreamDataLoader ./ElevationBounds ./ElevationTileAgent ./LayerClass ./MapTileAgent ./RasterTile ./TerrainConst ./terrainUtils ./TileAgent ./TilePerLayerInfo ./TileTexture ./tileUtils ../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D) {
          function E(N) { N.dispose(); N instanceof m ? P.release(N) : N instanceof g && K.release(N) } const H = l.create(), J = l.create(), M = l.create(); let F = function () {
            function N() {
            this.lij = [0, 0, 0]; this._children = [null, null, null, null]; this._pendingUpdates = 0; this._dirty = !0; this._previouslyRendered = !1; this.extent = b.create(); this._elevationBounds = n.create(); this.layerInfo = [[], []]; this.extentInRadians = b.create(); this.centerAtSeaLevel = l.create(); this._center = [l.create(),
            d.create(), l.create()]; this.up = l.unitZ(); this._intersectsClippingArea = this._isWithinClippingArea = !0; this._maxTesselation = 0; this._usedMemory = -1; this._curvatureHeight = this._edgeLen2 = this._edgeLen = this.renderOrder = this._screenDepth = this._mapDataRefCount = this._mapTileMemory = 0
            } N.prune = function () { K.prune(0); P.prune(0); z.TilePerLayerInfo.prune() }; var G = N.prototype; G.updateVisibilityNow = function () {
            this._dirty = !1; const I = this._intersectsClippingArea && this._isVisible(this.surface.frustum); I !== this._visible &&
              (this._visible = I, this._surface.emit("tiles-visibility-changed"), this._surface.renderer.setNeedsRender(), this.updateAgentSuspension()); return this._visible
            }; G.init = function (I, O, R) {
            this.lij[0] = I[0]; this.lij[1] = I[1]; this.lij[2] = I[2]; this.ellipsoid = h.getReferenceEllipsoid(R.tilingScheme.spatialReference); R.tilingScheme.getExtent(I[0], I[1], I[2], this.extent); R.tilingScheme.convertExtentToRadians(this.extent, this.extentInRadians); this._intersectsClippingArea = this._isWithinClippingArea = !0; this._clippingArea =
              null; this._mapDataRefCount = 0; R.upsampleMapCache.pop(this.key); this._edgeLen2 = this._edgeLen = 0; this._center[1][3] = 0; this.vlevel = I ? I[0] : 0; O && O.elevationBounds ? y.copy(this._elevationBounds, O.elevationBounds) : y.set(this._elevationBounds, 0, 0); this._pendingUpdates = 0; this.renderData = null; this._screenDepth = 0; this._previouslyRendered = this._visible = !1; this._parent = O; this.unsetChildren(); this._surface = R; this.updateVisibility(); for (const S of e.LayerClasses) {
                I = R.numLayers(S); O = this.layerInfo[S]; for (const Q of O) Q.release();
                O.length = I; for (let Q = 0; Q < I; Q++)O[Q] = z.TilePerLayerInfo.acquire(this._surface.upsampleInfoPool), 0 === S && this.findElevationBoundsForLayer(Q, -1)
              } this.computeElevationBounds(); this._maxTesselation = Math.min(R.tilingScheme.pixelSize, k.MAX_PATCH_TESSELATION)
            }; G.release = function () {
              r.weakAssert(!this.renderData, "tile.renderData was not unloaded"); this._surface.upsampleMapCache.pop(this.key); for (const I of e.LayerClasses) { for (const O of this.layerInfo[I]) O.release(); this.layerInfo[I].length = 0 } this._surface =
                this._parent = null; this._usedMemory = -1
            }; G.refMapData = function () { ++this._mapDataRefCount; this.isCached || this._surface.upsampleMapCache.pop(this.key) }; G.unrefMapData = function () { --this._mapDataRefCount; if (this.isCached) { const I = this.cachedMemory; 0 < I && (this._surface.upsampleMapCache.put(this.key, this, I), this.setMemoryDirty()) } }; G.setMemoryDirty = function () { this._usedMemory = -1 }; G._updateMemoryUsed = function () {
            this._mapTileMemory = this._usedMemory = 0; const I = this.cpuImageMemorySize; for (const { data: O } of this.layerInfo[1]) O instanceof
              B ? this._mapTileMemory += D.getGpuMemoryUsage(O.texture) : O instanceof HTMLImageElement || O instanceof t.ImageWithType ? this._mapTileMemory += I : O instanceof x && (this._mapTileMemory += O.memoryUsage); for (const O of this.layerInfo[0]) this._usedMemory += O.data ? I : 0; this.renderData && (this._usedMemory += this.renderData.estimatedGeometryMemoryUsage, this._mapTileMemory += D.getGpuMemoryUsage(this.renderData.textureDescriptor)); this.isCached && this._surface.upsampleMapCache.updateSize(this.key, this, this.cachedMemory)
            };
            G.getUsedMemoryForLayer = function (I, O) { O = this.layerInfo[I][O]; if (!O || !O.data) return 0; if (1 === I && !this.isCached) { I = O.data; if (I instanceof B) return D.getGpuMemoryUsage(I.texture); if (I instanceof HTMLImageElement || I instanceof t.ImageWithType) return this.cpuImageMemorySize; if (I instanceof f.VectorTile || I instanceof x) return I.memoryUsage } else if (0 === I) return this.cpuImageMemorySize; return 0 }; G.updateScreenDepth = function (I) {
              var O = this._center[1]; const R = O[0], S = O[1]; O = O[2]; const Q = I[2] * R + I[6] * S + I[10] * O +
                I[14]; this._screenDepth = 0 > Q ? 0 : Q / (I[3] * R + I[7] * S + I[11] * O + I[15])
            }; G.shouldSplit = function (I, O, R) {
              if (q.isSome(I.frustum) && (!this._intersectsClippingArea || !this._isVisible(I.frustum))) return 0; const S = this.level; p.subtract(H, this._center[1], O); var Q = p.squaredLength(H); let T = 1; p.subtract(J, this._center[0], O); var da = p.squaredLength(J); da < Q && (Q = da, T = 0); p.subtract(J, this._center[2], O); da = p.squaredLength(J); da < Q && (Q = da, T = 2); if (this._edgeLen2 > Q && S < I.maxLod) return 2; Q = Math.sqrt(Q); const Y = this._edgeLen / (I.fovX *
                Q * 2); da = () => { const ka = S + Math.ceil(-Math.log2(I.relativeWidthLimit / Y)); return ka !== this.vlevel ? (this.vlevel = ka, 4) : 1 }; if (1 === R && 1 === this._surface.snapLevel - S) return S >= I.maxLod ? da() : 2; const fa = p.dot(this.up, H); R = this._elevationBounds[1] - this._elevationBounds[0]; const ha = R / this.edgeLen; return I.aboveGround && 0 < fa && .001 > ha && 0 < fa / Q - Math.sin(this._curvatureHeight / (this.edgeLen * Math.SQRT1_2) * Math.PI) - ha ? 0 : Y < I.relativeWidthLimit ? this.vlevel !== this.level ? (this.vlevel = this.level, 4) : 0 : S >= I.maxLod ? da() : 6 < S && (p.subtract(J,
                  this._center[T], O), p.scale(M, this.up, fa), p.subtract(M, M, J), da = p.squaredLength(M), da > this.radius * this.radius && (p.scale(M, M, this.radius / Math.sqrt(da)), p.add(M, M, this._center[T]), p.subtract(M, O, M), Math.min(1, (Math.abs(p.dot(M, this.up)) + .5 * R + this._curvatureHeight) / p.length(M)) * (this._edgeLen / (I.fovY * Q * 2)) < .1 / I.angledSplitBias * I.relativeHeightLimit)) ? 0 : 2
            }; G.setChildren = function (I, O, R, S) {
              r.weakAssert(!!(I && O && R && S), "Null child passed"); this._children[0] = I; this._children[1] = O; this._children[2] = R; this._children[3] =
                S
            }; G.unsetChildren = function () { this._children[0] = null; this._children[1] = null; this._children[2] = null; this._children[3] = null }; G.load = function (I) { this.refMapData(); for (const O of e.LayerClasses) this._createOrUpdateAgents(0, O); I.loadTile(this) }; G.unload = function (I) {
              I.unloadTile(this); for (const O of e.LayerClasses) { I = this.layerInfo[O]; for (const R of I) R.loadingAgent && R.loadingAgent !== A.TILE_AGENT_DONE && (E(R.loadingAgent), R.loadingAgent = null), R.pendingUpdates = 0 } this.resetPendingUpdate(32); this.resetPendingUpdate(64);
              this.resetPendingUpdate(128); this.unrefMapData()
            }; G.unloadMapData = function () { const I = this.layerInfo[1]; for (const O of I) O.loadingAgent && O.loadingAgent !== A.TILE_AGENT_DONE && (E(O.loadingAgent), O.loadingAgent = null), O.pendingUpdates = 0; this.renderData && this.renderData.releaseTexture(); this.setMemoryDirty() }; G.updateClippingStatus = function (I) {
              if (b.equals(I, this._clippingArea)) return !1; var O = this._intersectsClippingArea; const R = this._isWithinClippingArea; q.isSome(I) ? (this._intersectsClippingArea = this.intersectsExtent(I),
                this._isWithinClippingArea = this._isWithinExtent(I)) : this._isWithinClippingArea = this._intersectsClippingArea = !0; this._clippingArea = I; this.updateVisibility(); I = R && this._isWithinClippingArea; O = !R && !O && !this._isWithinClippingArea && !this._intersectsClippingArea; !this.renderData || I || O || this.setPendingUpdate(32); return !0
            }; G.updateVisibility = function () { this._dirty = !0; this._surface.setTileTreeDirty() }; G.getLayerInfo = function (I, O) { return this.layerInfo[O][I] }; G.hasLayerData = function (I, O) {
              I = this.layerInfo[O][I];
              return !(!I || !I.data || I.dataInvalidated)
            }; G.isSuspended = function (I) { return this.hasPendingUpdate(2) ? !0 : 0 === I ? !1 : !this.loadable }; G.hasPendingUpdate = function (I) { return (this._pendingUpdates & I) === I }; G.setPendingUpdate = function (I) { this._pendingUpdates |= I; 2 === I || 8 === I ? this._surface.setTileTreeDirty() : this._surface.requestUpdate() }; G.resetPendingUpdate = function (I) { return this.hasPendingUpdate(I) ? (this._pendingUpdates &= ~I, !0) : !1 }; G.requestLayerData = function (I, O, R) {
              const S = this.layerInfo[O][I]; if (S.waitingAgents.has(R)) return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",
                this.lij.toString(), R.tile.lij.toString(), O, I), !0; S.waitingAgents.push(R); if (S.data && !S.dataInvalidated) return console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)", this.lij.toString(), R.tile.lij.toString(), O, I), R.dataArrived(this), !0; if (S.requestPromise) return !0; q.abortMaybe(S.requestAbort); S.requestAbort = new AbortController; const Q = this._surface.requestTileData(this, I, O, S.requestAbort); if (!Q) return S.requestAbort = null, !1; I = () => {
                S.requestPromise === Q && (S.requestPromise =
                  null, S.requestAbort = null)
                }; S.requestPromise = Q; Q.then(I, I); return !0
            }; G.hasLij = function (I) { return this.lij[0] === I[0] && this.lij[1] === I[1] && this.lij[2] === I[2] }; G.findByLij = function (I) { return this.hasLij(I) ? this : this.isLeaf ? null : (I = this._children[0].findByLij(I) || this._children[1].findByLij(I) || this._children[2].findByLij(I) || this._children[3].findByLij(I)) ? I : null }; G.distanceToSquared = function (I) { return p.squaredLength(p.subtract(M, this._center[1], I)) }; G.containsPoint = function (I) {
              const O = this.extent; return I[0] >=
                O[0] && I[1] >= O[1] && I[0] <= O[2] && I[1] <= O[3]
            }; G.unrequestLayerData = function (I, O, R) { I = this.layerInfo[O][I]; O = I.waitingAgents; R = null != O.removeUnordered(R); r.weakAssert(R, "agent has not requested this piece of map data"); 1 > O.length && (I.abortRequest(), this._updateMemoryUsed()) }; G.dataArrived = function (I, O, R) { I = this.layerInfo[O][I]; I.data = R; I.dataInvalidated = !1; I.waitingAgents.forAll(S => S.dataArrived(this)); I.waitingAgents.clear(); this._updateMemoryUsed() }; G.dataMissing = function (I, O, R) {
            R.notInTilemap || console.error(`Tile ${this.lij.toString()} layer ${O}/${I} error ${R}`);
              I = this.layerInfo[O][I]; I.dataMissing = !0; I.waitingAgents.forAll(S => S.dataMissing()); I.waitingAgents.clear(); this._updateMemoryUsed()
            }; G.updateRenderData = function (I, O) { switch (I) { case 1: return this.updateTexture(O); case 0: return this.updateGeometry() } }; G.updateTexture = function (I) { this.renderData && (this.resetPendingUpdate(0 === I ? 64 : 128), this.setPendingUpdate(0 === I ? 128 : 64)) }; G.updateGeometry = function () { this.setPendingUpdate(32); for (const I of this.layerInfo[0]) I.pendingUpdates |= 32 }; G.invalidateLayerData =
              function (I, O) { this.layerInfo[O][I].invalidateSourceData(); this.restartAgents(O) }; G.computeElevationBounds = function () {
                y.set(this._elevationBounds, Number.MAX_VALUE, -Number.MAX_VALUE); const I = this.layerInfo[0]; let O = !0; for (const R of I) q.isSome(R.elevationBounds) && (this._elevationBounds[0] = Math.min(this._elevationBounds[0], R.elevationBounds.min), this._elevationBounds[1] = Math.max(this._elevationBounds[1], R.elevationBounds.max), R.elevationBounds.hasNoDataValues || (O = !1)); O && (this._elevationBounds[0] = Math.min(this._elevationBounds[0],
                  0), this._elevationBounds[1] = Math.max(this._elevationBounds[1], 0)); this.updateRadiusAndCenter(); this._surface.setTileTreeDirty()
              }; G._updateCenter = function () { p.scale(M, this.up, .5 * (this._elevationBounds[0] + this._elevationBounds[1])); p.add(this._center[1], this.centerAtSeaLevel, M); p.scale(M, this.up, this._elevationBounds[0]); p.add(this._center[0], this.centerAtSeaLevel, M); p.scale(M, this.up, this._elevationBounds[1]); p.add(this._center[2], this.centerAtSeaLevel, M) }; G.findElevationBoundsForLayer = function (I,
                O) {
                  const R = this.layerInfo[0][I]; if (!(q.isSome(R.elevationBounds) && R.elevationBounds.level >= O) && (O = this._surface.layerViewByIndex(I, 0), O = r.getLayerWithExtentRange(O), C.fallsWithinLayer(this, O, !1))) {
                    O = L; var S = !1; if (R.data) I = R.data, O.min = I.bounds[0], O.max = I.bounds[1], O.hasNoDataValues = I.hasNoDataValues, O.level = this.lij[0], S = !0; else {
                      let Q = 0, T, da; for (let Y = this._parent; Y && (!da || Q < k.getElevationDesiredResolutionLevel(this.level)) && !(Q = this.vlevel - Y.level, T = da || T, da = Y.layerInfo[0][I].data, !da && T && Q >= k.getElevationDesiredResolutionLevel(this.level)); Y =
                        Y.parent); if (da = da || T) da.computeMinMaxValue(this.lij[0], this.lij[1], this.lij[2], O), Infinity !== O.min && (O.level = da.level, S = !0)
                    } S && (q.isNone(R.elevationBounds) && (R.elevationBounds = new v.ElevationBounds), R.elevationBounds.copyFrom(O))
                  }
              }; G.modifyLayers = function (I, O, R) {
                R = this.layerInfo[R]; for (var S of R) S.loadingAgent && S.loadingAgent !== A.TILE_AGENT_DONE && (E(S.loadingAgent), S.loadingAgent = null), S.waitingAgents.clear(); for (S = 0; S < R.length; ++S)void 0 === I[S] && R[S].release(); I = Array(...R); S = O.length; R.length =
                  S; for (let Q = 0; Q < S; Q++) { const T = O[Q]; R[Q] = -1 < T ? I[T] : z.TilePerLayerInfo.acquire(this._surface.upsampleInfoPool) } this._updateMemoryUsed()
              }; G.restartAgents = function (I) { this.renderData && (this._createOrUpdateAgents(0, I), this.updateRenderData(I, 0)) }; G.updateAgents = function (I) { if (this.renderData) { const O = this.layerInfo[I]; for (const R of O) R.loadingAgent === A.TILE_AGENT_DONE && (R.loadingAgent = null); this._createOrUpdateAgents(0, I) } }; G.updateAgentSuspension = function () {
                for (const I of e.LayerClasses) {
                  const O = this.isSuspended(I);
                  for (const R of this.layerInfo[I]) R.loadingAgent && R.loadingAgent !== A.TILE_AGENT_DONE && (R.loadingAgent.setSuspension(O), R.loadingAgent === A.TILE_AGENT_DONE && this.updateRenderData(I, 0))
                }
              }; G.removeLayerAgent = function (I, O) { I = this.layerInfo[O][I]; I.loadingAgent && I.loadingAgent !== A.TILE_AGENT_DONE && I.loadingAgent.dispose(); I.loadingAgent = null }; G.agentDone = function (I, O) { const R = this.layerInfo[O][I]; R.loadingAgent = A.TILE_AGENT_DONE; R.data || R.upsampleInfo || this._createOrUpdateAgents(I + 1, O) }; G._createOrUpdateAgents =
                function (I, O) {
                  const R = this.isSuspended(O), S = this.layerInfo[O]; for (; I < S.length; ++I) {
                    const Y = S[I]; var Q = !1; const fa = this._surface.layerViewByIndex(I, O); var T = r.getLayerWithExtentRange(fa); if (Y.loadingAgent) C.fallsWithinLayer(this, T, !1) ? (Y.loadingAgent !== A.TILE_AGENT_DONE && Y.loadingAgent.setSuspension(R), Y.loadingAgent !== A.TILE_AGENT_DONE && (Q = Y.loadingAgent.update())) : Y.dispose(); else if (C.fallsWithinLayer(this, T, !1)) {
                      { Q = I; T = O; var da = R; const ha = 0 === T ? P.acquire() : K.acquire(); ha.init(this, Q, T, da); Q = ha } Y.loadingAgent =
                        Q; (Q = Y.loadingAgent.startLoading()) ? Y.loadingAgent === A.TILE_AGENT_DONE && this.setPendingUpdate(32) : (E(Y.loadingAgent), Y.loadingAgent = A.TILE_AGENT_DONE)
                    } Y.loadingAgent === A.TILE_AGENT_DONE && this.updateRenderData(O, 0); if (Q && fa.isOpaque) break
                  }
                }; G._isWithinExtent = function (I) { const O = this.extent; return O[0] >= I[0] && I[2] >= O[2] && O[1] >= I[1] && I[3] >= O[3] }; G.intersectsExtent = function (I) { const O = this.extent; return O[2] >= I[0] && I[2] >= O[0] && O[3] >= I[1] && I[3] >= O[1] }; G.getElevationBasedVerticesPerRow = function (I) {
                  const O =
                    this.vlevel - this.level; I = Math.max(this.level - I, k.getElevationDesiredResolutionLevel(this.level) - O); return c.clamp((this.maxTesselation >> I) + 1, 2, this.maxTesselation + 1)
                }; w._createClass(N, [{ key: "usedMemory", get: function () { -1 === this._usedMemory && this._updateMemoryUsed(); return this._usedMemory + (this.isCached ? 0 : this.mapTileMemory) } }, { key: "cachedMemory", get: function () { return this.isCached ? this.mapTileMemory : 0 } }, {
                  key: "mapTileMemory", get: function () {
                  -1 === this._usedMemory && this._updateMemoryUsed(); let I = this._mapTileMemory;
                    for (const { data: O } of this.layerInfo[1]) O instanceof f.VectorTile && (I += O.memoryUsage); return I
                  }
                }, { key: "isCached", get: function () { return !this.shouldLoad && 0 >= this._mapDataRefCount } }, { key: "maxTesselation", get: function () { return this._maxTesselation } }, { key: "isWithinClippingArea", get: function () { return this._isWithinClippingArea } }, { key: "intersectsClippingArea", get: function () { return this._intersectsClippingArea } }, { key: "clippingArea", get: function () { return this._clippingArea } }, { key: "parent", get: function () { return this._parent } },
                { key: "children", get: function () { return this._children } }, { key: "surface", get: function () { return this._surface } }, { key: "elevationBounds", get: function () { return this._elevationBounds } }, { key: "level", get: function () { return this.lij[0] } }, { key: "key", get: function () { return `${this.lij[0]}/${this.lij[1]}/${this.lij[2]}` } }, { key: "edgeLen", get: function () { return this._edgeLen } }, { key: "radius", get: function () { return this._center[1][3] } }, { key: "screenDepth", get: function () { return this._screenDepth } }, {
                  key: "visible", get: function () {
                  this._dirty &&
                    this.updateVisibilityNow(); return this._visible
                  }
                }, { key: "loadable", get: function () { return this.visible || this._surface.view.state.fixedContentCamera } }, { key: "rendered", get: function () { const I = !!this.renderData; I !== this._previouslyRendered && (this._surface.emit("tiles-visibility-changed"), this._previouslyRendered = I, this._surface.renderer.setNeedsRender()); return I } }, {
                  key: "shouldLoad", get: function () {
                    if (!this.loadable) return !1; if (1 === this._surface.lodSnapping) {
                      const I = this.level - this._surface.snapLevel; if (0 ===
                        I) return !0; if (1 === I) return !1
                    } return this.isLeaf
                  }
                }, { key: "cpuImageMemorySize", get: function () { const I = this._surface.tilingScheme.pixelSize; return I * I * 4 } }, { key: "updating", get: function () { if (this.hasPendingUpdates) return !0; for (const I of e.LayerClasses) { const O = this.layerInfo[I]; for (const R of O) if (R.loadingAgent && R.loadingAgent !== A.TILE_AGENT_DONE && R.loadingAgent.updating) return !0 } return !1 } }, { key: "hasPendingUpdates", get: function () { return 0 !== this._pendingUpdates } }, {
                  key: "isLeaf", get: function () {
                    return null ==
                      this._children[0]
                  }
                }, { key: "test", get: function () { return { cachedMemory: this.cachedMemory } } }]); return N
          }(); const K = new u(g), P = new u(m), L = new v.ElevationBounds; a.SplitLimits = function () { this.angledSplitBias = this.maxLod = this.relativeHeightLimit = this.relativeWidthLimit = this.fovY = this.fovX = 0; this.aboveGround = !0 }; a.Tile = F; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/ElevationTileAgent": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers", "./TerrainConst", "./TileAgent"],
        function (a, w, c) { return function (q) { function u() { var y = q.apply(this, arguments) || this; y._scaleRangeEnabled = !1; return y } a._inheritsLoose(u, q); a._createClass(u, [{ key: "_desiredMinLevelDelta", get: function () { return w.getElevationDesiredResolutionLevel(this.tile.level) - (this.tile.vlevel - this.tile.level) } }, { key: "_progressiveLevelModulo", get: function () { return 0 } }]); return u }(c.TileAgent) })
    }, "esri/views/3d/terrain/TileAgent": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ./TerrainConst ./terrainUtils ./tileUtils".split(" "),
        function (a, w, c, q, u, y) {
          let n = function () {
            function h() { } var b = h.prototype; b.init = function (d, f, t, v) { this.tile = d; this._layerIdx = f; this._layerClass = t; this._suspended = v; this._tileLayerInfo = d.getLayerInfo(f, t); this._tileRequested = null; d = this._findAncestorWithData(); this._setUpsampleTile(d) }; b.startLoading = function () { return this._requestNext() }; b.dispose = function () {
            this._tileRequested && (this._tileRequested.unrequestLayerData(this._layerIdx, this._layerClass, this), this._tileRequested = null); this._tileLayerInfo =
              this.tile = null
            }; b.setSuspension = function (d) { d !== this._suspended && ((this._suspended = d) ? this._tileRequested && (this._tileRequested.unrequestLayerData(this._layerIdx, this._layerClass, this), this._tileRequested = null) : this._tileLayerInfo.data || this.update()) }; b.update = function () { const d = this._findAncestorWithData(); this._setUpsampleTile(d); return this._requestNext() }; b.dataArrived = function (d) { this._setUpsampleTile(d); this._tileRequested = null; d === this.tile ? this.tile.updateRenderData(this._layerClass, 0) : this._requestNext() };
            b.dataMissing = function () { this._tileRequested = null; this._tileLayerInfo.data = null; this._requestNext() }; b._agentDone = function () { this.tile.agentDone(this._layerIdx, this._layerClass); this.dispose() }; b._requestNext = function () {
              if (this._suspended) return !0; const d = this._findNextDownload(); if (this._tileRequested) { if (d === this._tileRequested) return !0; this._tileRequested.unrequestLayerData(this._layerIdx, this._layerClass, this); this._tileRequested = null } c.isSome(d) ? d.requestLayerData(this._layerIdx, this._layerClass,
                this) && (this._tileRequested = d) : this._agentDone(); return !!this._tileRequested
            }; b._findNextDownload = function () {
              const d = this._layerIdx, f = this._layerClass; var t = this.tile.surface.layerViewByIndex(d, f); const v = u.getLayerWithExtentRange(t), { minLevel: m, maxLevel: e } = t.dataLevelRange; t = this._desiredMinLevelDelta; const g = this._progressiveLevelModulo + t, x = this._scaleRangeEnabled ? y.fallsWithinLayer : () => !0; let k = this.tile; const r = k.level; let A; var z = this._tileLayerInfo.upsampleInfo; z = z ? z.tile.level : -1; const B = c.get(v,
                "tilemapCache"); for (; k && x(k, v, !1) && k.level >= m;) { const C = k.level, D = r - C, E = k.layerInfo[f][d]; if (E.data && D >= t) { C > z && this._setUpsampleTile(k); E.dataInvalidated && (A = k); break } if ((c.isNone(B) || "unavailable" !== B.getAvailability(k.lij[0], k.lij[1], k.lij[2])) && C <= e && !E.data && !E.dataMissing) { if (c.isNone(A) || k.level === m || 0 === C % q.PROGRESSIVE_LOADING_MODULO || r - A.level < t) A = k; if (D >= g) break } k = k.parent } c.isSome(A) && r - A.level < t && this._tileLayerInfo.upsampleInfo && (A = null); return A
            }; b._findAncestorWithData = function () {
              const d =
                this.tile.vlevel, f = this._desiredMinLevelDelta; let t; for (let v = this.tile; v; v = v.parent)if (v.hasLayerData(this._layerIdx, this._layerClass)) { if (d - v.level >= f) return v; t = v } return t
            }; b._setUpsampleTile = function (d) { this._tileLayerInfo.setUpsampleInfo(this.tile, d); this.tile.updateRenderData(this._layerClass, 0) }; w._createClass(h, [{ key: "updating", get: function () { return !!this._tileRequested } }, { key: "test", get: function () { return { findNextDownload: () => this._findNextDownload(), tileLayerInfo: this._tileLayerInfo } } }]);
            return h
          }(); var p = function (h) { function b() { return h.apply(this, arguments) || this } w._inheritsLoose(b, h); b.prototype.dispose = function () { }; w._createClass(b, [{ key: "_desiredMinLevelDelta", get: function () { throw l; } }, { key: "_progressiveLevelModulo", get: function () { throw l; } }]); return b }(n); const l = Error("Abstract method called on TileAgent"); p = new p; a.TILE_AGENT_DONE = p; a.TileAgent = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/tileUtils": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers",
        "../../../core/maybe", "../../../core/PooledArray"], function (a, w, c, q) {
          function u(l, h) { h(l); if (!l.isLeaf) for (const b of l.children) u(b, h) } function y(l, h, b) { l = l.screenDepth; h = h.screenDepth; return l < h ? -b : l > h ? b : 0 } let n = function () {
            function l() { this._queue = new q; this._last = null; this.remove = () => { } } var h = l.prototype; h.resetOne = function (b) { this._queue.clear(); this._queue.push(b); this._last = null }; h.reset = function (b = null) { this._queue.clear(); c.isSome(b) && this._queue.pushArray(b); this._last = null }; h.skipSubtree =
              function () { this._last = null }; h.next = function () { this._last && !this._last.isLeaf && this._queue.pushArray(this._last.children); return this._last = this._queue.pop() }; w._createClass(l, [{ key: "done", get: function () { return 0 === this._queue.length && (!this._last || this._last.isLeaf) } }]); return l
          }(), p = function () {
            function l() { this.q = new q } var h = l.prototype; h.reset = function (b) { this.q.clear(); if (!c.isNone(b)) for (this.q.pushArray(b), b = 0; b < this.q.length; ++b) { const d = this.q.data[b]; d.isLeaf || this.q.pushArray(d.children) } };
            h.next = function () { return this.q.pop() }; w._createClass(l, [{ key: "done", get: function () { return 0 === this.q.length } }]); return l
          }(); a.IteratorPostorder = p; a.IteratorPreorder = n; a.compareTiles = y; a.computeUpsampleInfo = function (l, h, b) { let d = 1, f = 0, t = 0; for (; l !== h;)if (d *= .5, f *= .5, t *= .5, l.lij[2] & 1 && (f += .5), 0 === (l.lij[1] & 1) && (t += .5), l = l.parent, null == l) throw Error("tile was not a descendant of upsampleTile"); b.init(h, f, t, d) }; a.fallsWithinLayer = function (l, h, b) {
            if (c.isNone(h) || c.isNone(h.fullExtent)) return !1; const d =
              h.fullExtent, f = l.extent; if (b) { if (f[0] < d.xmin || f[1] < d.ymin || f[2] > d.xmax || f[3] > d.ymax) return !1 } else if (d.xmin > f[2] || d.ymin > f[3] || d.xmax < f[0] || d.ymax < f[1]) return !1; l = l.surface.tilingScheme.levels[l.level].scale; return 0 < h.minScale && l > 1.00000001 * h.minScale || 0 < h.maxScale && l < .99999999 * h.maxScale ? !1 : !0
          }; a.hasLoadableSiblings = function (l) { for (let h = 0; h < l.length; h++) { const b = l[h], d = b.parent; if (d) for (let f = 0; 4 > f; f++) { const t = d.children[f]; if (t && t !== b && t.loadable) return !0 } } return !1 }; a.sortTiles = function (l, h) {
            h.sort((b,
              d) => y(b, d, l))
          }; a.sortTilesByPOI = function (l, h) { const b = new Map; l.forAll(d => b.set(d, d.distanceToSquared(h))); l.sort((d, f) => b.get(d) - b.get(f)) }; a.tilesAreRelated = function (l, h) { if (!l || !h || l[0] === h[0]) return !1; const b = l[0] < h[0], d = b ? l : h; l = b ? h : l; h = 1 << l[0] - d[0]; return Math.floor(l[1] / h) === d[1] && Math.floor(l[2] / h) === d[2] }; a.traverseTilesPreorder = function (l, h) { if (Array.isArray(l)) for (let b = 0; b < l.length; b++)u(l[b], h); else u(l, h) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/MapTileAgent": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers",
        "./TerrainConst", "./TileAgent"], function (a, w, c) { return function (q) { function u() { var y = q.call(this) || this; y._scaleRangeEnabled = !0; return y } a._inheritsLoose(u, q); a._createClass(u, [{ key: "_desiredMinLevelDelta", get: function () { return 0 } }, { key: "_progressiveLevelModulo", get: function () { return w.PROGRESSIVE_LOADING_MODULO } }]); return u }(c.TileAgent) })
    }, "esri/views/3d/terrain/RasterTile": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers", "../../../core/maybe", "../../webgl/rasterUtils"], function (a,
        w, c) {
          const q = { bandCount: 3, outMin: 0, outMax: 1, minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255], factor: [1 / 255, 1 / 255, 1 / 255], useGamma: !1, gamma: [1, 1, 1], gammaCorrection: [1, 1, 1], colormap: null, colormapOffset: null, stretchType: "none", type: "stretch" }; return function () {
            function u(n, p, l = null, h = null) {
            this.type = "raster-tile"; this._interpolation = this._bandIds = this._symbolizerParameters = this._source = this._memoryUsed = null; this._dirty = !1; this._transformGrid = null; this.isRendereredSource = !1; this.lij = this.rawPixelData = this.symbolizerRenderer =
              null; this.scale = 1; this.offset = [0, 0]; this.opacity = 1; this.lij = n; this.source = p; this.width = l || p.width; this.height = h || p.height
            } var y = u.prototype; y.bind = function (n) { if (!(this.source && this.source.pixels && 0 < this.source.pixels.length)) return !1; this._rasterTexture && !this._dirty || this._updateRasterTexture(n, this.bandIds); this._rasterTexture && (this._updateColormapTexture(n), this.transformGrid && !this._transformGridTexture && (this._transformGridTexture = c.createTransformTexture(n, this.transformGrid))); return !0 };
            y.getUniforms = function () {
              const n = c.getBasicGridUniforms(this.scale, this.offset), { symbolizerParameters: p, transformGrid: l, width: h, height: b, opacity: d } = this, f = c.getCommonUniforms(l, [h, b], [this.source.width, this.source.height], d), t = p.colormap ? c.getColormapUniforms(p.colormap, p.colormapOffset) : null, v = "stretch" === this.symbolizerParameters.type ? c.getStretchUniforms(this.symbolizerParameters) : null, m = "hillshade" === this.symbolizerParameters.type ? c.getShadedReliefUniforms(this.symbolizerParameters) : null; return {
                basic: n,
                common: f, colormap: t, stretch: v, hillshade: m
              }
            }; y.getTextures = function () { const n = [], p = []; this._rasterTexture && (p.push(this._rasterTexture), n.push("u_image"), this._transformGridTexture && (p.push(this._transformGridTexture), n.push("u_transformGrid")), this._colormapTexture && (p.push(this._colormapTexture), n.push("u_colormap"))); return { names: n, textures: p } }; y.release = function () {
            this._rasterTexture = w.disposeMaybe(this._rasterTexture); this._transformGridTexture = w.disposeMaybe(this._transformGridTexture); this._colormapTexture =
              w.disposeMaybe(this._colormapTexture); this.rawPixelData = this.transformGrid = this.source = null; return !0
            }; y._updateRasterTexture = function (n, p) {
              const l = this.source ? this.source.extractBands(p) : null; if (l && l.pixels && 0 < l.pixels.length) {
                p = w.isNone(p) && w.isNone(this.bandIds) || w.isSome(p) && w.isSome(this.bandIds) && p.join("") === this.bandIds.join(""); if (this._rasterTexture) { if (p) return; this._rasterTexture.dispose(); this._rasterTexture = null } p = this._getRasterTextureInterpolation(this.interpolation); this._rasterTexture =
                  c.createRasterTexture(n, l, p, this.isRendereredSource || this.hasStretchTypeNone())
              } else this._rasterTexture && (this._rasterTexture.dispose(), this._rasterTexture = null)
            }; y.hasStretchTypeNone = function () { return "stretchType" in this.symbolizerParameters && "none" === this.symbolizerParameters.stretchType && !this.symbolizerParameters.useGamma && "u8" === this.source.pixelType }; y._getRasterTextureInterpolation = function (n) { return "lut" === this.symbolizerParameters.type || "nearest" === n || "majority" === n ? "nearest" : "bilinear" };
            y._updateColormapTexture = function (n) { const p = this._colormap, l = this.symbolizerParameters.colormap; if (!l) this._colormapTexture && (this._colormapTexture.dispose(), this._colormapTexture = null), this._colormap = null; else if (!p) this._colormapTexture = c.createColormapTexture(n, l), this._colormap = l; else if (l.length !== p.length || l.some((h, b) => h !== p[b])) this._colormapTexture && (this._colormapTexture.dispose(), this._colormapTexture = null), this._colormapTexture = c.createColormapTexture(n, l), this._colormap = l }; a._createClass(u,
              [{ key: "source", get: function () { return this._source }, set: function (n) { this._source = n; this._rasterTexture && (this._rasterTexture.dispose(), this._memoryUsed = this._rasterTexture = null) } }, { key: "symbolizerParameters", get: function () { return this.isRendereredSource ? { ...q, maxCutOff: [1, 1, 1], factor: [1, 1, 1] } : this._symbolizerParameters || q }, set: function (n) { this._symbolizerParameters = n } }, {
                key: "bandIds", get: function () { return this._bandIds }, set: function (n) {
                  w.isSome(n) && 0 < n.length ? this._bandIds && n.every((p, l) => this._bandIds[l] ?
                    p === this._bandIds[l] : !1) || (this._bandIds = n, this._dirty = !0) : this._bandIds = null
                }
              }, { key: "interpolation", get: function () { return this._interpolation || "nearest" }, set: function (n) { this._interpolation = n; this._rasterTexture && (n = this._getRasterTextureInterpolation(n), this._rasterTexture.setSamplingMode("bilinear" === n ? 9729 : 9728)) } }, {
                key: "transformGrid", get: function () { return this._transformGrid }, set: function (n) {
                this._transformGrid = n; this._transformGridTexture && (this._transformGridTexture.dispose(), this._memoryUsed =
                  this._transformGridTexture = null)
                }
              }, { key: "memoryUsage", get: function () { if (w.isNone(this._memoryUsed)) { const n = this.getTextures(); if (null == n) return 0; this._memoryUsed = n.textures.map(p => p.descriptor.width * p.descriptor.height * 4).reduce((p, l) => p + l, 0) } return this._memoryUsed } }]); return u
          }()
      })
    }, "esri/views/webgl/rasterUtils": function () {
      define(["exports", "./FramebufferObject", "./Texture"], function (a, w, c) {
      a.createColormapTexture = function (q, u) {
        return new c(q, {
          width: u.length / 4, height: 1, target: 3553, pixelFormat: 6408,
          internalFormat: 6408, dataType: 5121, samplingMode: 9728, wrapMode: 33071, flipped: !1
        }, u)
      }; a.createFrameBuffer = function (q, u, y, n) { n = new c(q, { width: u, height: y, target: 3553, pixelFormat: 6408, internalFormat: 6408, samplingMode: 9728, dataType: n ? 5121 : 5126, wrapMode: 33071, flipped: !1 }); return new w(q, { colorTarget: 0, depthStencilTarget: 3, width: u, height: y }, n) }; a.createRasterTexture = function (q, u, y = "nearest", n = !1) {
        var p; const l = (n = !(n && "u8" === u.pixelType)) ? 5126 : 5121, h = null == u.pixels || 0 === u.pixels.length ? null : n ? u.getAsRGBAFloat() :
          u.getAsRGBA(), b = null == (p = q.capabilities.textureFloat) ? void 0 : p.textureFloatLinear; return new c(q, { width: u.width, height: u.height, target: 3553, pixelFormat: 6408, internalFormat: "webgl2" === q.webglVersion && n ? 34836 : 6408, samplingMode: !b || "bilinear" !== y && "cubic" !== y ? 9728 : 9729, dataType: l, wrapMode: 33071, flipped: !1 }, h)
      }; a.createTransformTexture = function (q, u) {
        var y = 4 * u.size[0], n = u.size[1]; const p = {
          width: y, height: n, target: 3553, pixelFormat: 6408, internalFormat: "webgl2" === q.webglVersion ? 34836 : 6408, dataType: 5126, samplingMode: 9728,
          wrapMode: 33071, flipped: !1
        }; y = new Float32Array(y * n * 4); n = 0; for (let l = 0; l < u.coefficients.length; l++)y[n++] = u.coefficients[l], 2 === l % 3 && (y[n++] = 1); return new c(q, p, y)
      }; a.getBasicGridUniforms = function (q, u) { return { u_scale: q, u_offset: u } }; a.getColormapUniforms = function (q, u) { return { u_colormapOffset: u || 0, u_colormapMaxIndex: q ? q.length / 4 - 1 : null } }; a.getCommonUniforms = function (q, u, y, n = 1, p = !0, l = !1) {
        return {
          u_flipY: p, u_isFloatTexture: l, u_applyTransform: q ? !0 : !1, u_opacity: n, u_transformSpacing: q ? q.spacing : null, u_transformGridSize: q ?
            q.size : null, u_targetImageSize: u, u_srcImageSize: y
        }
      }; a.getShadedReliefUniforms = function (q) { return { u_hillshadeType: q.hillshadeType, u_sinZcosAs: q.sinZcosAs, u_sinZsinAs: q.sinZsinAs, u_cosZs: q.cosZs, u_weights: q.weights, u_factor: q.factor, u_minValue: q.minValue, u_maxValue: q.maxValue } }; a.getStretchUniforms = function (q) { return { u_bandCount: q.bandCount, u_minOutput: q.outMin, u_maxOutput: q.outMax, u_minCutOff: q.minCutOff, u_maxCutOff: q.maxCutOff, u_factor: q.factor, u_useGamma: q.useGamma, u_gamma: q.gamma, u_gammaCorrection: q.gammaCorrection } };
        a.getUniformLocationInfos = function (q, u) { q = q.gl; u = u.glName; const y = q.getProgramParameter(u, q.ACTIVE_UNIFORMS), n = new Map; let p; for (let l = 0; l < y; l++)(p = q.getActiveUniform(u, l)) && n.set(p.name, { location: q.getUniformLocation(u, p.name), info: p }); return n }; a.setTextures = function (q, u, y, n) { y.length === n.length && (n.some(p => null == p) || y.some(p => null == p) || y.forEach((p, l) => { u.setUniform1i(p, l); q.bindTexture(n[l], l) })) }; a.setUniforms = function (q, u, y) {
          Object.keys(y).forEach(n => {
            var p = u.get(n) || u.get(n + "[0]"); if (p) {
              var l =
                y[n]; if (null !== p && null != l) switch ({ info: p } = p, p.type) {
                  case 5126: 1 < p.size ? q.setUniform1fv(n, l) : q.setUniform1f(n, l); break; case 35664: q.setUniform2fv(n, l); break; case 35665: q.setUniform3fv(n, l); break; case 35666: q.setUniform4fv(n, l); break; case 35675: q.setUniformMatrix3fv(n, l); break; case 35676: q.setUniformMatrix4fv(n, l); break; case 5124: 1 < p.size ? q.setUniform1iv(n, l) : q.setUniform1i(n, l); break; case 35670: q.setUniform1i(n, l ? 1 : 0); break; case 35667: case 35671: q.setUniform2iv(n, l); break; case 35668: case 35672: q.setUniform3iv(n,
                    l); break; case 35669: case 35673: q.setUniform4iv(n, l)
                }
            }
          })
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TilePerLayerInfo": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../core/ObjectPool ../../../core/PooledArray ./terrainUtils ./tileUtils".split(" "), function (a, w, c, q, u, y, n) {
        let p = function () {
          function b() {
          this.waitingAgents = new u; this.requestAbort = this.requestPromise = this.loadingAgent = this._upsampleInfo = null; this.pendingUpdates =
            0
          } b.acquire = function (f) { const t = l.acquire(); t._init(f); return t }; var d = b.prototype; d.release = function () { this.dispose(); h.delete(this); l.release(this) }; d.dispose = function () { this.loadingAgent = c.disposeMaybe(this.loadingAgent); this.abortRequest(); this._unsetUpsampleInfo(); this.pendingUpdates = 0; this._data = y.releaseTileData(this._data) }; b.prune = function () { l.prune(0) }; d._init = function (f) {
            this.waitingAgents.clear(); this._data = y.releaseTileData(this._data); this.dataInvalidated = this.dataMissing = !1; this._unsetUpsampleInfo();
            this.abortRequest(); this.loadingAgent = null; this.pendingUpdates = 0; this._pool = f; this.elevationBounds = null
          }; d.invalidateSourceData = function () { this.dataInvalidated = !0; this.dataMissing = !1; this._unsetUpsampleInfo() }; d.abortRequest = function () { this.requestAbort = c.abortMaybe(this.requestAbort); this.requestPromise = null }; d._unsetUpsampleInfo = function () { this._upsampleInfo && (this._upsampleInfo.tile.unrefMapData(), this._pool.release(this._upsampleInfo), this._upsampleInfo = null) }; d.setUpsampleInfo = function (f, t) {
            if (f ===
              t || c.isNone(t)) this._unsetUpsampleInfo(); else { if (null == this._upsampleInfo) this._upsampleInfo = this._pool.acquire(); else { if (this._upsampleInfo.tile === t) return; this._upsampleInfo.tile.unrefMapData() } t.refMapData(); n.computeUpsampleInfo(f, t, this._upsampleInfo) }
          }; w._createClass(b, [{ key: "upsampleInfo", get: function () { return this._upsampleInfo } }, { key: "data", get: function () { return this._data }, set: function (f) { y.releaseTileData(this._data); this._data = f } }]); return b
        }(); const l = new q(p, null, () => { }), h = new Map; a.TilePerLayerInfo =
          p; a.printAllocations = function () { 0 < h.size && (console.log(`${h.size} live TilePerLayerInfo allocations:`), h.forEach(b => console.log(b, "\n"))) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TileTexture": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers"], function (a) {
        return function () {
          function w(q) { this._texture = q; this.type = "tile-texture"; this._refCount = 1 } var c = w.prototype; c.retain = function () { ++this._refCount }; c.release = function () {
            --this._refCount; 0 === this._refCount &&
              this._texture.dispose()
          }; c.generateMipmap = function () { this._texture.generateMipmap() }; a._createClass(w, [{ key: "texture", get: function () { return this._texture } }, { key: "descriptor", get: function () { return this._texture.descriptor } }]); return w
        }()
      })
    }, "esri/views/3d/terrain/SphericalPatch": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/projectionEllipsoid ../../../geometry/support/frustum ../../../geometry/support/plane ./PatchGeometryFactory ./Tile".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          b = function (t) {
            function v(e, g, x) { var k = t.call(this) || this; k.obb = Array(8); k.isWebMercator = !1; for (let r = 0; 8 > r; r++)k.obb[r] = u.create(); void 0 !== e && k.init(e, g, x); return k } w._inheritsLoose(v, t); var m = v.prototype; m.init = function (e, g, x) {
              t.prototype.init.call(this, e, g, x); this.isWebMercator = x.tilingScheme.spatialReference.isWebMercator; g = this.ellipsoid.radius; x = this.extentInRadians[0]; const k = this.extentInRadians[1], r = this.extentInRadians[2], A = this.extentInRadians[3]; e = e[0];
              const z = c.lerp(k, A, .5), B = c.lerp(x, r, .5); this._edgeLen = (r - x) * Math.cos(0 === e ? 0 : Math.min(Math.abs(k), Math.abs(A))) * g; this._edgeLen2 = this._edgeLen * this._edgeLen; this._curvatureHeight = g - Math.sqrt(g * g - this._edgeLen2 / 4); y.lonLatToSphericalPCPF(this.centerAtSeaLevel, B, z, this.ellipsoid.radius, 0); g = u.fromArray(this.centerAtSeaLevel); q.normalize(g, g); this.up = g; this._updateOBB(); this.updateRadiusAndCenter()
            }; m.updateRadiusAndCenter = function () {
              if (0 === this.lij[0]) q.set(this._center[1], 0, 0, 0), q.set(this._center[0],
                0, 0, 0), q.set(this._center[2], 0, 0, 0), this.ellipsoid || (this.ellipsoid = n.getReferenceEllipsoid(this.surface.spatialReference)), this._center[1][3] = this.ellipsoid.radius + this.elevationBounds[1]; else { this._updateCenter(); const e = Math.max(q.squaredDistance(this._center[1], this.obb[0]), q.squaredDistance(this._center[1], this.obb[1])); this._center[1][3] = Math.sqrt(e) }
            }; m._isVisible = function (e) {
              if (!p.intersectsSphere(e, this._center[1])) return !1; if (10 > this.lij[0]) return !0; const g = this.obb; for (let r = 0; 6 > r; r++) {
                var x =
                  4 === r, k = e[r]; x && (f[0] = k[0], f[1] = k[1], f[2] = k[2], f[3] = k[3] - this.surface.view.state.camera.near); x = x ? f : k; for (k = 0; 8 > k; k++) { const A = g[k]; if (0 > x[0] * A[0] + x[1] * A[1] + x[2] * A[2] + x[3]) break } if (8 === k) return !1
              } return !0
            }; m.computeElevationBounds = function () { t.prototype.computeElevationBounds.call(this); this._updateOBB() }; m.createGeometry = function (e, g) {
              const x = this._isPole(this.lij[1], this.lij[0]); h.createSphericalGlobePatch(e, this.extent, g, this.renderData, this.extentInRadians, this.isWebMercator, this.ellipsoid, x);
              this.setMemoryDirty()
            }; m._updateOBB = function () {
              var e = this.extentInRadians; const g = this.obb; for (let x = 0; 2 > x; x++) { const k = this.elevationBounds[x]; let r = 4 * x; y.lonLatToSphericalPCPF(g[r++], e[0], e[1], this.ellipsoid.radius, k); y.lonLatToSphericalPCPF(g[r++], e[0], e[3], this.ellipsoid.radius, k); y.lonLatToSphericalPCPF(g[r++], e[2], e[3], this.ellipsoid.radius, k); y.lonLatToSphericalPCPF(g[r++], e[2], e[1], this.ellipsoid.radius, k) } this.isWebMercator && (e = this._isPole(this.lij[1], this.lij[0]), 2 === e ? (q.set(g[1], 0, 0,
                this.ellipsoid.radius), q.set(g[2], 0, 0, this.ellipsoid.radius), q.set(g[5], 0, 0, this.ellipsoid.radius), q.set(g[6], 0, 0, this.ellipsoid.radius)) : 1 === e && (q.set(g[0], 0, 0, -this.ellipsoid.radius), q.set(g[3], 0, 0, -this.ellipsoid.radius), q.set(g[4], 0, 0, -this.ellipsoid.radius), q.set(g[7], 0, 0, -this.ellipsoid.radius)))
            }; m._isPole = function (e, g) { let x = 0; e === (1 << g) - 1 && (x += 1); 0 === e && (x += 2); return x }; m.intersectsRay = function (e, g, x, k, r) {
              k = this._center[1]; x = k[3] + x + .2 * this.ellipsoid.radius * Math.abs(r * (this.extentInRadians[3] -
                this.extentInRadians[1])); var A = k[0] - e[0]; r = k[1] - e[1]; e = k[2] - e[2]; k = (A * g[0] + r * g[1] + e * g[2]) / (g[0] * g[0] + g[1] * g[1] + g[2] * g[2]); A = g[0] * k - A; r = g[1] * k - r; g = g[2] * k - e; return A * A + r * r + g * g < x * x
            }; m.getDefaultVerticesPerRowOnLevel = function () { return this.level < d.length ? d[this.level] + 1 : 2 }; return v
          }(b.Tile); const d = [128, 64, 32, 16, 16, 8, 8, 4], f = l.create(); a.SphericalPatch = b; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/TerrainRenderer": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/Accessor ../../../core/maybe ../../../core/ObjectPool ../../../core/PooledArray ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4 ../../../chunks/vec4f64 ../../../geometry/support/aaBoundingBox ../../../geometry/support/buffer/BufferView ../../../support/requestImageUtils ./OverlayRenderer ./PatchGeometryFactory ./PatchRenderData ./ScaleRangeQueries ./TerrainConst ./TileRenderer ./tileUtils ../webgl-engine/collections/Component/ComponentIntersectionData ../webgl-engine/core/shaderLibrary/Slice.glsl ../webgl-engine/core/shaderLibrary/shading/ScreenSpaceReflections.glsl ../webgl-engine/core/shaderLibrary/util/View.glsl ../webgl-engine/lib/glUtil3D ../webgl-engine/lib/Intersector ../webgl-engine/lib/screenSizePerspectiveUtils ../webgl-engine/lib/verticalOffsetUtils ../webgl-engine/materials/internal/MaterialUtil ../webgl-engine/shaders/TerrainTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O) {
          function R(ea, ba, aa) { e.set(aa, ea[0] * ba[2] + ba[0], ea[1] * ba[3] + ba[1], ea[2] * ba[2], ea[3] * ba[3]) } const S = x.create(), Q = g.create(); q = function (ea) {
            function ba(W) {
              W = ea.call(this, W) || this; W.type = 2; W.isGround = !0; W.tileSize = 256; W.rctx = null; W._isTransparent = !1; W._scaleRangeQueries = new C.ScaleRangeQueries; W.renderDataPool = new y(B.PatchRenderData); W._patchGroups = new n({
                allocator: U => U || { root: null, origin: null, patches: new n }, deallocator: U => { U.root = null; U.origin = null; U.patches.clear(); return U }
              }); W.patchGroupsDirty = !0; W.patchGroupsMap = new Map; W.tileIterator = new H.IteratorPreorder; W.highestVisibleLODTile = null; W.visible = !0; W._opaque = !0; W._skirtScale = 1; W._velvetOverground = !0; W.castShadows = !0; W._ssrEnabled = !1; W.emptyTex = null; W.tileRenderer = null; W.tileBackgroundInitialized = !1; W.tileBackgroundUpdating = !1; W.stencilEnabledLayerExtents = []; W.numTrianglesRendered = 0; W.numTilesRendered = 0; W.numTilesCulled = 0; W.numOriginsRendered = 0; W.overlayOpacity =
                1; W.needsHighlight = !1; W.renderOccludedFlags = 1; return W
            } a._inheritsLoose(ba, ea); var aa = ba.prototype; aa.initialize = function () { this.stage.addRenderPlugin([1, 6, 8], this) }; aa.destroy = function () { this.stage.removeRenderPlugin(this); z.clearCaches() }; aa.setDebugScreenSizePerspective = function (W) { this.shaderTechniqueConfig.screenSizePerspective !== W && (this.shaderTechniqueConfig.screenSizePerspective = W, this.setNeedsRender()) }; aa.setRootTiles = function (W) { this._rootTiles = W; this.setNeedsRender() }; aa.setNeedsHighlight =
              function (W) { this.needsHighlight = W; this.setNeedsRender() }; aa.setRenderOccludedOverlay = function (W) { this.renderOccludedFlags = W ? A.overlayRenderOccludedFlag : 1; this.setNeedsRender() }; aa.setStencilEnabledLayerExtents = function (W) { this.stencilEnabledLayerExtents = W; this.setNeedsRender() }; aa.setTileSize = function (W) { this.tileSize = W; this.tileRenderer && (this.tileRenderer.tileSize = W); this.setNeedsRender() }; aa.loadTile = function (W) {
              W.renderData || (W.renderData = this.renderDataPool.acquire(), W.renderData.init(W), W.renderData.localOrigin =
                this._getLocalOriginOfTile(W)); this.updateTileGeometry(W); this.updateTileTexture(W, 128)
              }; aa.queryVisibleLevelRange = function (W, U, X, Z) { this._scaleRangeQueries.queryVisibleLevelRange(W, U, X, Z); this.setNeedsRender() }; aa.updateTileTexture = function (W, U) { this.tileRenderer && this.tileBackgroundInitialized && (this.tileRenderer.updateTileTexture(W, 128 === U ? 0 : 2), this.setNeedsRender(), W.resetPendingUpdate(U)) }; aa.updateTileGeometry = function (W) {
                for (const U of W.layerInfo[0]) U.pendingUpdates &= -33; W.resetPendingUpdate(32);
                W.renderData.updateGeometry(this.rctx, this.wireframe) && this.setNeedsRender()
              }; aa.unloadTile = function (W) { W.renderData && (W.renderData.releaseGeometry() && this.setNeedsRender(), this.renderDataPool.release(W.renderData), W.renderData.clear(), W.renderData = null, W.setMemoryDirty(), this.setNeedsRender()) }; aa._getLocalOriginOfTile = function (W) { const U = Math.max(0, 7 * Math.floor((W.level - 3) / 7)); if (this.isGlobal && 0 === U) return m.ZEROS; for (; W.parent && W.level > U;)W = W.parent; return W.centerAtSeaLevel }; aa.setVisibility =
                function (W) { this.visible = W; this.setNeedsRender() }; aa.getStats = function () { return { numTilesRendered: this.numTilesRendered, numTilesCulled: this.numTilesCulled, numTrianglesRendered: this.numTrianglesRendered, numOriginsRendered: this.numOriginsRendered } }; aa.setNeedsRender = function (W = 1) { this.patchGroupsDirty = !0; this.context.requestRender(W) }; aa.setTileBackground = function (W) { this.tileBackground = W; this._updateTileBackground() }; aa.initializeRenderContext = function (W) {
                this.context = W; this.rctx = W.renderContext.rctx;
                  this.shaderTechniques = W.shaderTechniqueRep; this.shaderTechniqueConfig = new O.TerrainTechniqueConfiguration; this.tileRenderer = new E.TileRenderer(this.rctx, this.tileSize, this.shaderTechniques); this.tileBackground && this._updateTileBackground(); this.emptyTex = P.createEmptyTexture(this.rctx)
                }; aa.uninitializeRenderContext = function () { null != this.emptyTex && (this.emptyTex.dispose(), this.emptyTex = null); this.tileRenderer && (this.tileRenderer.dispose(), this.tileRenderer = null) }; aa.intersect = function (W, U, X, Z) {
                  if (this._rootTiles &&
                    (!W.options.selectOpaqueTerrainOnly || !W.options.selectionMode || this._opaque)) {
                      var ia = Y, la = fa; v.subtract(ia, Z, X); v.set(la, 1 / ia[0], 1 / ia[1], 1 / ia[2]); var ma = W.results.min, ra = W.results.max, Aa = W.results.ground, za = 0 === W.options.store, Ka = !!W.results.ground.target, Ea = G.getVerticalOffsetTerrain(W.verticalOffset), Ua = this._skirtScale, Na = W.tolerance, ya, pa = za && u.isSome(ma.dist) ? ma.dist : Infinity, wa = Ha => {
                        var Oa = Ha.renderData; if (null != Oa) {
                          var Ba = Oa.geometryInfo; x.set(S, Ba.boundingBox); Oa = Oa.localOrigin; u.isSome(Ea) &&
                            (Ea.localOrigin = Oa, Ea.applyToAabb(S)); var sa = -Ua * Ba.skirtLength; if (0 !== sa) { var Ca = Ha.up; x.expandWithOffset(S, sa * Ca[0], sa * Ca[1], sa * Ca[2]) } ha[0] = X[0] - Oa[0]; ha[1] = X[1] - Oa[1]; ha[2] = X[2] - Oa[2]; if (I.intersectAabbInvDirBefore(S, ha, la, Na, pa)) {
                              var Ja = (Qa, Wa, Ra) => { Qa.set(this.type, Ha, Wa, Ra, t.IDENTITY); pa = za && u.isSome(ma.dist) ? ma.dist : Infinity }; Ca = (Qa, Wa) => {
                                u.isSome(Wa) && 0 <= Qa && (W.options.backfacesTerrain || 0 > v.dot(Wa, ia)) && (W.options.invisibleTerrain || !W.options.selectionMode || null == U || U(X, Z, Qa)) && ((null == Aa.dist ||
                                  Qa < Aa.dist) && Ja(Aa, Qa, Wa), W.options.isFiltered || (2 === W.options.store && (u.isNone(ya) ? (ya = L.newIntersectorResult(W.ray), Ja(ya, Qa, Wa), W.results.all.push(ya)) : Qa < ya.dist && Ja(ya, Qa, Wa)), (null == ma.dist || Qa < ma.dist) && Ja(ma, Qa, Wa), 0 !== W.options.store && (null == ra.dist || Qa > ra.dist) && Ja(ra, Qa, Wa)))
                              }; var ca = ka; v.subtract(ca, Z, Oa); var qa = Ba.indices, Da = Ba.vertexAttributes, na = { data: Da.getField("position", k.BufferViewVec3f).typedBuffer, size: 3, stride: Da.stride / 4 }; Ba = Ba.numWithoutSkirtIndices / 3; if (!u.isSome(Ea) && Ba >
                                J.componentMinimalSizeForIntersectionData) { var xa = Ha.renderData; u.isSome(xa.intersectionData) || (xa.intersectionData = new J.ComponentIntersectionData(qa, 0, Ba, na)); xa.intersectionData.intersectRay({ r0: ha, r1: ca }, Ca) } else I.intersectTriangles(ha, ca, 0, Ba, qa, na, null, Ea, Ca); if (0 !== sa) {
                                  const Qa = qa.length / 3; this.isGlobal ? (na = Qa - Ba, !u.isSome(Ea) && na > J.componentMinimalSizeForIntersectionData ? (xa = Ha.renderData, u.isSome(xa.skirtIntersectionData) || (Oa = z.getGlobalSkirtGeometry(qa, Ba, Qa, Da, sa, Oa), xa.skirtIntersectionData =
                                    new J.ComponentIntersectionData(Oa.indices, 0, na, { data: Oa.vertices, stride: 3 })), xa.skirtIntersectionData.intersectRay({ r0: ha, r1: ca }, Ca)) : z.intersectSkirtsGlobal(ha, ca, Ba, Qa, qa, Da, sa, Oa, Ea, Ca)) : z.intersectSkirtsLocal(ha, ca, Ba, Qa, qa, Da, sa, Ea, Ca)
                                }
                            }
                        }
                      }, Ia = this._rootTiles; u.isSome(Ia) && (() => {
                        const Ha = this.tileIterator; Ha.reset(Ia); const Oa = W.options.invisibleTerrain; for (; !Ha.done;) {
                          const Ba = Ha.next(); !(Ba.visible || Oa && Ba.intersectsClippingArea) || !u.isSome(Ea) && !Ba.intersectsRay(X, ia, Na, pa, Ua) || Ka && this._useStencilForTile(Ba) ?
                            Ha.skipSubtree() : wa(Ba)
                        }
                      })()
                  }
                }; aa.render = function (W) {
                  if (8 === W.slot) { if (0 === (W.renderOccludedMask & A.overlayRenderOccludedFlag)) return !1 } else if (W.slot !== (this.opaque ? 1 : 6)) return !1; var U = W.pass; const X = 1 === W.scenelightingData.globalFactor, Z = this._updatePatchGroups(); let ia = !1; switch (U) {
                    case 0: U = W.shadowMap && W.shadowMap.enabled; this.shaderTechniqueConfig.receiveShadows !== U && (this.shaderTechniqueConfig.receiveShadows = U); U = this.overlayRenderer.isEmpty() ? 0 : this.overlayRenderer.hasWater ? 2 : 1; this.shaderTechniqueConfig.overlayMode !==
                      U && (this.shaderTechniqueConfig.overlayMode = U); this._renderMaterialPass(W, 0, Z, 8 === W.slot ? 3 : 1); ia = !0; break; case 4: case 6: this.castShadows && X && (this._renderAuxiliaryPass(W, 3, Z, 0), ia = !0); break; case 2: this.isTransparent && this.overlayRenderer.isEmpty() || (this._renderAuxiliaryPass(W, 1, Z, 0), ia = !0); break; case 3: this._renderAuxiliaryPass(W, 2, Z, 0); ia = !0; break; case 5: this.needsHighlight && (this._renderAuxiliaryPass(W, 4, Z, 2), W.rctx.clearSafe(256), ia = !0)
                  }this._scaleRangeQueries.hasPendingQueries() && this.setNeedsRender();
                  return ia
                }; aa._renderMaterialPass = function (W, U, X, Z) {
                  const { rctx: ia, camera: la } = W; this._ssrEnabled = W.ssrParams.ssrEnabled; this._setTerrainTechnique(U, 3 === Z); const ma = this._shaderTechnique.program; ia.useProgram(ma); 0 !== this.shaderTechniqueConfig.overlayMode && 1 === Z && W.ssrParams && F.bindSSRUniforms(ma, W.ssrParams); W.shadowMap.bind(ma); W.ssaoHelper.bind(ma, W.camera); this._bindOverlayData(ma, Z); ma.setUniformMatrix4fv("viewNormal", la.viewInverseTransposeMatrix); K.bindProjectionMatrix(ma, la.projectionMatrix);
                  W.scenelightingData.setUniforms(ma, !0); U = la.viewMatrix; v.set(da, U[12], U[13], U[14]); v.normalize(da, da); ma.setUniform3fv("viewDirection", da); this.numOriginsRendered = this.numTrianglesRendered = this.numTilesCulled = this.numTilesRendered = 0; this._scaleRangeQueries.prepareQueries(); this.opaque ? this._renderPatchGroups(W, ma, X, Z) : W.offscreenRenderingHelper.renderToTargets(() => this._renderPatchGroups(W, ma, X, Z), W.offscreenRenderingHelper.tmpColor, W.offscreenRenderingHelper.mainDepth, [0, 0, 0, 0]); this._scaleRangeQueries.processQueries()
                };
            aa._renderAuxiliaryPass = function (W, U, X, Z) { this._setTerrainTechnique(U, 3 === Z); U = this._shaderTechnique.program; W.rctx.useProgram(U); if (5 === W.pass) { const ia = W.offscreenRenderingHelper; U.bindTexture(ia.depthTexture, "depthTex"); U.setUniform4f("highlightViewportPixelSz", 0, 0, 1 / ia.width, 1 / ia.height) } else U.setUniformMatrix4fv("viewNormal", W.camera.viewInverseTransposeMatrix), 2 !== W.pass && 4 !== W.pass && 6 !== W.pass || U.setUniform2fv("nearFar", W.camera.nearFar); this._renderPatchGroupsAuxiliary(W, U, X, Z) }; aa._updateTileBackground =
              function () {
                if (this.tileRenderer) {
                this.tileBackgroundUpdating = !0; var W = () => { this.tileBackgroundInitialized = !0; this.tileBackgroundUpdating = !1; this.shaderTechniqueConfig.useGrid = this.tileRenderer.backgroundIsGrid; this.shaderTechniqueConfig.hasBackgroundColor = !this.tileRenderer.backgroundIsGrid && !!u.isSome(this.tileRenderer.backgroundColor); this.allTiles.forAll(U => this.tileRenderer.updateTileTexture(U, 0)); this.setNeedsRender() }; if ("string" === typeof this.tileBackground) {
                  const U = this.tileBackground; r.requestImage(U).then(X => { U === this.tileBackground && this.tileRenderer && (this.tileRenderer.setBackground(X, this.tileBackground === D.DEFAULT_TILE_BACKGROUND), W()) })
                } else { const U = this.tileBackground ? c.toUnitRGBA(this.tileBackground) : [0, 0, 0, 0]; this.tileRenderer.setBackground(U, !1); W() }
                }
              }; aa._updatePatchGroups = function () {
                const W = this._patchGroups; if (!this.patchGroupsDirty) return W; this.highestVisibleLODTile = null; this._renderCollectOrigins(W); if (0 !== this.renderOrder) {
                  for (let U = 0; U < W.length; U++)H.sortTiles(this.renderOrder, W.data[U].patches);
                  W.sort((U, X) => { var Z = this.renderOrder; U = 0 === U.patches.length ? -Z : 0 === X.patches.length ? Z : H.compareTiles(U.patches.data[0], X.patches.data[0], Z); return U })
                } this.patchGroupsDirty = !1; return W
              }; aa._renderCollectOrigins = function (W) { var U = this._rootTiles; if (!u.isNone(U)) { var X = this.isGlobal; W.clear(); for (const Z of U) U = W.pushNew(), U.root = Z, U.origin = X ? m.ZEROS : Z.centerAtSeaLevel, U.patches.clear(), this._renderCollectOriginsForRoot(W, U); W.filterInPlace(Z => 0 < Z.patches.length) } }; aa._renderCollectOriginsForRoot =
                function (W, U) {
                  const X = this.tileIterator; X.resetOne(U.root); const Z = this.patchGroupsMap; Z.clear(); for (Z.set(U.origin, U); !X.done;) {
                    U = X.next(); var ia = U.renderData; if (ia && !U.visible) this.numTilesCulled++ , X.skipSubtree(); else {
                      if (0 === U.level % 7) { const la = W.pushNew(); la.root = U; la.origin = U.centerAtSeaLevel; Z.set(U.centerAtSeaLevel, la); la.patches.clear() } if (!U.rendered) this.numTilesCulled++; else if (ia) {
                      (ia = Z.get(ia.localOrigin)) && ia.patches.push(U); if (!this.highestVisibleLODTile || U.vlevel > this.highestVisibleLODTile.vlevel) this.highestVisibleLODTile =
                        U; X.skipSubtree()
                      }
                    }
                  }
                }; aa._useStencilForTile = function (W) { for (const U of this.stencilEnabledLayerExtents) if (W.intersectsExtent(U)) return !0; return !1 }; aa._renderPatchGroupsAuxiliary = function (W, U, X, Z) {
                  var ia = W.rctx; this._shaderTechnique.useStencil = !1; this._shaderTechnique.bindPipelineState(ia, W.slot); ia = 0 < this.stencilEnabledLayerExtents.length; U.setUniformMatrix4fv("proj", W.camera.projectionMatrix); U.setUniform1f("skirtScale", this._skirtScale); 0 !== Z && this._bindOverlayData(U, Z); for (let la = 0; la < X.length; la++) {
                    const ma =
                      X.data[la]; this._bindPatchGroupData(U, ma, W.camera.eye, W.camera.viewMatrix); for (let ra = 0; ra < ma.patches.length; ra++)this._renderPatch(W, U, ma.patches.data[ra], 4, ia, Z)
                  } W.rctx.bindVAO(null)
                }; aa._renderPatchGroups = function (W, U, X, Z) {
                  const ia = W.rctx, la = W.camera, ma = la.viewMatrix; this._shaderTechnique.useStencil = !1; this._shaderTechnique.bindPipelineState(ia, W.slot); if (this.shaderTechniqueConfig.screenSizePerspective && this.pointsOfInterest) {
                    var ra = N.getSettings(this.stage.viewingMode, this.ellipsoidRadius); ra.update({
                      distance: this.pointsOfInterest.centerOnSurfaceFrequent.distance,
                      fovY: la.fovY
                    }); I.bindScreenSizePerspective(ra, U, "screenSizePerspective")
                  } ra = 0 < this.stencilEnabledLayerExtents.length; const Aa = 3 === Z; Aa && (U.bindTexture(this.emptyTex, "tex"), U.setUniform1f("blend", 1), U.setUniform4fv("texOffsetAndScale", g.ZEROS)); var za = u.isSome(this.tileRenderer.backgroundColor) ? this.tileRenderer.backgroundColor : m.ZEROS; this.shaderTechniqueConfig.hasBackgroundColor && U.setUniform3fv("backgroundColor", za); U.setUniform1f("skirtScale", Aa ? 0 : this._skirtScale); za = this.wireframe ? 1 : 4; this.shaderTechniqueConfig.textureFadingEnabled &&
                    U.bindTexture(this.emptyTex, "texNext"); for (let Ua = 0; Ua < X.length; Ua++) {
                      var Ka = X.data[Ua]; const Na = Ka.patches; this._bindPatchGroupData(U, Ka, la.eye, ma); M.bindSliceUniforms(U, this._shaderTechnique.configuration, W.sliceHelper && W.sliceHelper.plane, Ka.origin); W.shadowMap && W.shadowMap.bindView(U, Ka.origin); this.numOriginsRendered++; for (Ka = 0; Ka < Na.length; Ka++) {
                        const ya = Na.data[Ka]; var Ea = ya.renderData.textureReference; if (!u.isNone(Ea)) {
                          if (!Aa) {
                            this._scaleRangeQueries.scaleQueriesForTile(ya); R(ya.renderData.geometryInfo.uvOffsetAndScale,
                              Ea.offsetAndScale, Q); U.setUniform4fv("texOffsetAndScale", Q); U.bindTexture(Ea.texture.texture, "tex"); const pa = ya.renderData.textureFadeFactor, wa = 1 > pa ? ya.renderData.nextTextureReference : null; this.shaderTechniqueConfig.textureFadingEnabled && u.isSome(wa) && 1 > pa ? (R(ya.renderData.geometryInfo.uvOffsetAndScale, wa.offsetAndScale, Q), U.setUniform1f("fadeFactor", pa), U.setUniform4fv("nextTexOffsetAndScale", Q), U.setUniform3fv("nextTexOpacities", wa.opacities), U.bindTexture(wa.texture.texture, "texNext")) : U.setUniform1f("fadeFactor",
                                1); ya.renderData.textureIsFading && this.setNeedsRender(); U.setUniform3fv("textureOpacities", Ea.opacities)
                          } Ea = this._renderPatch(W, U, ya, za, ra, Z); ya.renderOrder = this.numTilesRendered; this.numTilesRendered++; this.numTrianglesRendered += Ea / 3
                        }
                      }
                    } ia.bindVAO(null)
                }; aa._renderPatch = function (W, U, X, Z, ia, la) {
                  if (u.isNone(X.renderData.vao.indexBuffer)) return 0; 0 !== la && this._bindOverlayPatchData(U, X.renderData.overlay); ia && (this._shaderTechnique.useStencil = this._useStencilForTile(X), this._shaderTechnique.bindPipelineState(W.rctx,
                    W.slot)); ia = 0 === this._skirtScale ? X.renderData.geometryInfo.numWithoutSkirtIndices : X.renderData.vao.indexBuffer.size; W.rctx.bindVAO(X.renderData.vao); U.assertCompatibleVertexAttributeLocations(X.renderData.vao); W.rctx.drawElements(Z, ia, X.renderData.vao.indexBuffer.indexType, 0); return ia
                }; aa._bindPatchGroupData = function (W, U, X, Z) { W.setUniform3fv("origin", U.origin); f.translate(T, Z, U.origin); W.setUniformMatrix4fv("view", T); W.setUniform3f("camPos", X[0] - U.origin[0], X[1] - U.origin[1], X[2] - U.origin[2]) }; aa._bindOverlayData =
                  function (W, U) { if (0 !== this.shaderTechniqueConfig.overlayMode) { W.setUniform1f("overlayOpacity", this.overlayOpacity); var X = this.overlayRenderer.overlays; if (0 < X.length) { X = X[0]; const Z = X.getColorTexture(U); W.bindTexture(u.isSome(Z) ? Z : this.emptyTex, "ovColorTex"); 2 === this.shaderTechniqueConfig.overlayMode && (U = X.getNormalTexture(U), W.bindTexture(u.isSome(U) ? U : this.emptyTex, "ovWaterTex")) } } }; aa._bindOverlayPatchData = function (W, U) {
                    W.setUniform4fv("overlayTexOffset", U.offsets); W.setUniform4fv("overlayTexScale",
                      U.scales)
                  }; aa._setTerrainTechnique = function (W, U) { this.shaderTechniqueConfig.output = W; 0 === W && (this.shaderTechniqueConfig.atmosphere = this.isGlobal && this._velvetOverground, this.shaderTechniqueConfig.ssrEnabled = this._ssrEnabled); this.shaderTechniqueConfig.renderOccluded = U; this.shaderTechniqueConfig.stencilEnabled = !1; this._shaderTechnique = this.shaderTechniques.releaseAndAcquire(O.TerrainTechnique, this.shaderTechniqueConfig, this._shaderTechnique) }; a._createClass(ba, [{
                    key: "isGlobal", get: function () {
                      return 1 ===
                        this.stage.viewingMode
                    }
                  }, { key: "updating", get: function () { return !this.tileBackgroundInitialized || this.tileBackgroundUpdating } }, { key: "canRender", get: function () { return this.visible && !!this._rootTiles && this.tileBackgroundInitialized && !this.renderingDisabled } }, { key: "renderingDisabled", set: function (W) { this._set("renderingDisabled", !!W); this.setNeedsRender() } }, {
                    key: "opaque", get: function () { return this._opaque && !this.shaderTechniqueConfig.slicePlaneEnabled }, set: function (W) {
                    this._opaque !== W && (this._opaque = W,
                      this.setNeedsRender())
                    }
                  }, { key: "needsLinearDepth", get: function () { return this.overlayRenderer.hasWater } }, { key: "isTransparent", get: function () { return this._isTransparent }, set: function (W) { this._isTransparent !== W && (this._isTransparent = W, this.setNeedsRender()) } }, { key: "skirtScale", get: function () { return this._skirtScale }, set: function (W) { W !== this._skirtScale && (this._skirtScale = W, this.setNeedsRender()) } }, {
                    key: "renderPatchBorders", get: function () { return !!this.shaderTechniqueConfig.tileBorders }, set: function (W) {
                      this.shaderTechniqueConfig.tileBorders !==
                      W && (this.shaderTechniqueConfig.tileBorders = W, this.setNeedsRender(), this.notifyChange("renderPatchBorders"))
                    }
                  }, { key: "cullBackFaces", get: function () { return this.shaderTechniqueConfig.backfaceCullingEnabled }, set: function (W) { this.shaderTechniqueConfig.backfaceCullingEnabled !== W && (this.shaderTechniqueConfig.backfaceCullingEnabled = W, this.notifyChange("cullBackFaces"), this.setNeedsRender()) } }, { key: "renderOrder", set: function (W) { this._set("renderOrder", W); this.setNeedsRender() } }, {
                    key: "velvetOverground", set: function (W) {
                    this._velvetOverground !==
                      W && (this._velvetOverground = W, this.setNeedsRender())
                    }
                  }, { key: "layerUid", get: function () { return G.TERRAIN_ID } }, { key: "slicePlaneEnabled", get: function () { return this.shaderTechniqueConfig.slicePlaneEnabled }, set: function (W) { this.shaderTechniqueConfig.slicePlaneEnabled !== W && (this.shaderTechniqueConfig.slicePlaneEnabled = W, this.setNeedsRender()) } }, { key: "textureFadingEnabled", set: function (W) { this.shaderTechniqueConfig.textureFadingEnabled !== W && (this.shaderTechniqueConfig.textureFadingEnabled = W, this.setNeedsRender()) } },
                  { key: "wireframe", set: function (W) { this._get("wireframe") !== W && (this._set("wireframe", W), this.allTiles.forAll(U => { var X; return null == (X = U.renderData) ? void 0 : X.updateGeometry(this.rctx, W) }), this.setNeedsRender()) } }, { key: "test", get: function () { return { tileRenderer: this.tileRenderer } } }]); return ba
          }(q); w.__decorate([p.property()], q.prototype, "tileBackgroundInitialized", void 0); w.__decorate([p.property()], q.prototype, "tileBackgroundUpdating", void 0); w.__decorate([p.property({ constructOnly: !0 })], q.prototype,
            "overlayRenderer", void 0); w.__decorate([p.property({ constructOnly: !0 })], q.prototype, "stage", void 0); w.__decorate([p.property({ readOnly: !0 })], q.prototype, "isGlobal", null); w.__decorate([p.property({ constructOnly: !0 })], q.prototype, "allTiles", void 0); w.__decorate([p.property({ constructOnly: !0 })], q.prototype, "ellipsoidRadius", void 0); w.__decorate([p.property({ readOnly: !0 })], q.prototype, "updating", null); w.__decorate([p.property({ value: !1 })], q.prototype, "renderingDisabled", null); w.__decorate([p.property()],
              q.prototype, "renderPatchBorders", null); w.__decorate([p.property()], q.prototype, "cullBackFaces", null); w.__decorate([p.property({ value: 1 })], q.prototype, "renderOrder", null); w.__decorate([p.property()], q.prototype, "wireframe", null); w = q = w.__decorate([d.subclass("esri.views.3d.terrain.TerrainRenderer")], q); const T = t.create(), da = m.create(), Y = m.create(), fa = m.create(), ha = m.create(), ka = m.create(); return w
        })
    }, "esri/views/3d/terrain/PatchRenderData": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/arrayUtils ../../../core/maybe ../../../geometry/support/aaBoundingBox ../support/buffer/glUtil ./PatchGeometryFactory ./TextureFader ./TileOverlayData ./tileUtils ../webgl-engine/lib/DefaultVertexAttributeLocations ../../webgl/BufferObject ../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          let t = function () {
            function v() { this.geometryInfo = new n.PatchGeometry; this.skirtIntersectionData = this.intersectionData = null; this._textureRef = new p(() => this.tile.surface.textureFadeDuration); this.overlay = new l } var m = v.prototype; m.init = function (e) {
            this.tile = e; this.clear(); e = this.geometryInfo; e.indices = null; e.vertexAttributes = null; u.empty(e.boundingBox); e.numSurfaceIndices = 0; e.numSkirtIndices = 0; e.numWithoutSkirtIndices = 0; e.numVertsPerRow = 0; this.skirtIntersectionData =
              this.intersectionData = null; this.geometryState = { numVertsPerRow: 0, samplerData: null, clippingArea: null, wireframe: !1 }; this.localOrigin = null; this.overlay.clear()
            }; m.clear = function () { this.releaseGeometry(); this.releaseTexture(); this._textureRef.clear() }; m.updateGeometry = function (e, g) { if (!this._updateGeometryState(g)) return !1; this._releaseGeometry(); this._createGeometry(e); return !0 }; m.releaseGeometry = function () {
              return this._releaseGeometry() ? (this.geometryState = {
                numVertsPerRow: 0, samplerData: null, clippingArea: null,
                wireframe: !1
              }, !0) : !1
            }; m.ensureTexture = function (e, g) { q.isSome(this._texture) && this._texture.descriptor.width !== e && this.releaseTexture(); q.isNone(this._texture) && (this._texture = g(), this.tile.setMemoryDirty()); return this._texture }; m.releaseTexture = function () { q.isSome(this._texture) && (this._texture.release(), this._texture = null, this.tile.setMemoryDirty()) }; m._updateGeometryState = function (e) {
              const g = this._getElevationInfo(), x = g.samplerData ? this.tile.getElevationBasedVerticesPerRow(g.maxTileLevel) : this.tile.getDefaultVerticesPerRowOnLevel();
              let k = this.tile.clippingArea; if (!this.tile.intersectsClippingArea || this.tile.isWithinClippingArea) k = null; const r = this.geometryState; let A = !1; r.numVertsPerRow !== x && (r.numVertsPerRow = x, A = !0); g.changed && (r.samplerData = g.samplerData, A = !0); c.equals(r.clippingArea, k) || (r.clippingArea = k, A = !0); r.wireframe !== e && (r.wireframe = e, A = !0); return A
            }; m._createGeometry = function (e) {
              this.tile.createGeometry(this.geometryState, this.localOrigin); const g = this.geometryInfo.vertexAttributes, x = this.geometryInfo.indices, k = e.gl;
              this._vao = new f(e, b.Default3D, { geometry: y.glLayout(g.layout) }, { geometry: d.createVertex(e, k.STATIC_DRAW, g.buffer) }, d.createIndex(e, k.STATIC_DRAW, x))
            }; m._releaseGeometry = function () { if (!this._vao) return !1; this._vao.dispose(); this._vao = null; n.releaseGeometry(this.geometryInfo); return !0 }; m.setTextureReference = function (e, g = 0) { q.isSome(e) && e.texture !== this._texture && this.releaseTexture(); this._textureRef.push(e, g) }; m._getElevationInfo = function () {
              const e = this.geometryState.samplerData, g = this.tile.layerInfo[0],
              x = g.length; let k = Array(x), r = 0; var A = 0; let z = !1; for (let D = 0; D < x; D++) { var B = g[D]; if (B.upsampleInfo) { B = B.upsampleInfo.tile; var C = B.layerInfo[0][D].data; C = C && C.samplerData; e && e[r] === C || (z = !0); k[r++] = C; A = Math.max(A, B.lij[0]) } else B.data && (C = this.tile.surface.layerViewByIndex(D, 0), h.fallsWithinLayer(this.tile, C.layer, !1) && (A = B.data, e && e[r] === A.samplerData || (z = !0), k[r++] = A.samplerData, A = this.tile.level)) } e && e.length !== r && (z = !0); 0 < r ? k.length = r : k = null; return { changed: z, samplerData: k, maxTileLevel: A }
            }; w._createClass(v,
              [{ key: "vao", get: function () { return this._vao } }, { key: "textureReference", get: function () { return this._textureRef.current } }, { key: "nextTextureReference", get: function () { return this._textureRef.next } }, { key: "textureFadeFactor", get: function () { return this._textureRef.fadeFactor } }, { key: "textureIsFading", get: function () { return this._textureRef.isFading } }, {
                key: "estimatedGeometryMemoryUsage", get: function () {
                  const e = q.mapOr(this.intersectionData, 0, g => g.estimatedMemoryUsage) + q.mapOr(this.skirtIntersectionData, 0, g =>
                    g.estimatedMemoryUsage + g.vertexPositionBuffer.byteLength); return this.geometryInfo.indices.byteLength + this.geometryInfo.vertexAttributes.byteLength + e
                }
              }, { key: "textureDescriptor", get: function () { return q.isSome(this._texture) ? this._texture.descriptor : null } }, { key: "test", get: function () { return { hasTexture: null != this._texture } } }]); return v
          }(); a.PatchRenderData = t; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/TextureFader": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers",
        "../../../core/maybe"], function (a, w) {
          let c = function () {
            function q(y) { this._getFadeDuration = y; this._delayedTime = this._fadeStart = 0 } var u = q.prototype; u.clear = function () { this._current = w.destroyMaybe(this._current); this._next = w.destroyMaybe(this._next); this._waiting = w.destroyMaybe(this._waiting); this._delayed = w.destroyMaybe(this._delayed) }; u.push = function (y, n = 0) { this._delayed = w.destroyMaybe(this._delayed); this._push(y, n) }; u._push = function (y, n) {
            this._isFadingEnabled || this.clear(); if (w.isNone(this._current)) this._current =
              y; else { var p = q.test.fadeMoment || performance.now(); 0 !== n ? (this._delayed = y, this._delayedTime = p + n) : w.isNone(this._next) ? (this._next = y, this._fadeStart = this._alignFadeStart(p)) : w.isNone(y) || (w.destroyMaybe(this._waiting), this._waiting = y) }
            }; u._alignFadeStart = function (y) { const n = this._getFadeDuration(); return y + n - y % n }; a._createClass(q, [{
              key: "current", get: function () {
                if (w.isNone(this._current)) return null; if (!this._isFadingEnabled) {
                  var y = this._delayed || this._waiting || this._next || this._current; y !== this._current &&
                    (this._current = null, this.clear(), this._current = y)
                } y = q.test.fadeMoment; w.isSome(this._delayed) && (y = y || performance.now(), y >= this._delayedTime && (this._push(this._delayed, 0), this._delayed = null)); if (w.isSome(this._next)) {
                  y = y || performance.now(); var n = this._fadeDuration; const p = w.isSome(this._current) && this._next.texture === this._current.texture, l = 0 !== this._next.type; n = y - this._fadeStart >= n; if (p || l || n) w.destroyMaybe(this._current), this._current = this._next, this._next = this._waiting, this._waiting = null, this._fadeStart =
                    this._alignFadeStart(y)
                } return this._current
              }
            }, { key: "next", get: function () { return this._next } }, { key: "fadeFactor", get: function () { if (w.isNone(this._next)) return 1; var y = q.test.fadeMoment || performance.now(); y = Math.max(0, y - this._fadeStart); const n = this._fadeDuration; return y > n ? 0 : 1 - y / n } }, { key: "isFading", get: function () { return w.isSome(this._next) || w.isSome(this._delayed) } }, { key: "_fadeDuration", get: function () { return w.isNone(this._waiting) ? this._getFadeDuration() : .5 * this._getFadeDuration() } }, {
              key: "_isFadingEnabled",
              get: function () { return 0 < this._getFadeDuration() }
            }]); return q
          }(); c.test = { fadeMoment: 0 }; return c
        })
    }, "esri/views/3d/terrain/TileOverlayData": function () {
      define(["../../../chunks/_rollupPluginBabelHelpers"], function (a) {
        return function () {
          function w() { this._scales = [-1, -1, -1, -1]; this._offsets = [-1, -1, -1, -1] } var c = w.prototype; c.clear = function () { this._scales[0] = this._scales[1] = this._scales[2] = this._scales[3] = -1; this._offsets[0] = this._offsets[1] = this._offsets[2] = this._offsets[3] = -1 }; c.setScale = function (q, u, y) {
          this._scales[2 *
            q] = u; this._scales[2 * q + 1] = y
          }; c.setOffset = function (q, u, y) { this._offsets[2 * q] = u; this._offsets[2 * q + 1] = y }; a._createClass(w, [{ key: "scales", get: function () { return this._scales } }, { key: "offsets", get: function () { return this._offsets } }]); return w
        }()
      })
    }, "esri/views/3d/terrain/ScaleRangeQueries": function () {
      define(["exports", "../../../core/ObjectPool", "../../../core/PooledArray", "../../../chunks/vec4", "../../../chunks/vec4f64"], function (a, w, c, q, u) {
        let y = function () {
        this.extent = u.create(); this.maxLevel = this.minLevel =
          0; this.callback = null
        }, n = function () {
          function p() { this._queries = new c({ initialSize: 10 }); this._queriesInvPtr = 0; this._queryQueue = new c({ initialSize: 30 }); this._queryPool = new w(y) } var l = p.prototype; l.queryVisibleLevelRange = function (h, b, d, f) { const t = this._queryPool.acquire(); q.copy(t.extent, h); t.minLevel = b ? b : -Number.MAX_VALUE; t.maxLevel = null != d ? d : Number.MAX_VALUE; t.callback = f; this._queryQueue.push(t) }; l.hasPendingQueries = function () { return 0 !== this._queryQueue.length }; l.prepareQueries = function () {
            for (; this._queries.length <
              this._queries.data.length && 0 < this._queryQueue.length;) { const h = this._queryQueue.pop(); this._queries.push(h) } this._queriesInvPtr = this._queries.length
          }; l.processQueries = function () { for (let h = 0; h < this._queries.length; h++) { const b = this._queries.data[h]; this._queryPool.release(b); b.callback(h >= this._queriesInvPtr); b.callback = null } this._queries.clear() }; l.scaleQueriesForTile = function (h) {
            const b = h.level; let d = 0; for (; d < this._queriesInvPtr;) {
              const f = this._queries.data[d], t = f.extent; b >= f.minLevel && b <= f.maxLevel &&
                t[0] <= h.extent[2] && t[2] >= h.extent[0] && t[1] <= h.extent[3] && t[3] >= h.extent[1] ? (this._queries.swapElements(d, this._queriesInvPtr - 1), this._queriesInvPtr--) : d++
            }
          }; return p
        }(); a.ScaleRangeQueries = n; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TileRenderer": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../core/maybe ../../../chunks/vec2 ../../../chunks/vec2f64 ../../../chunks/vec3f64 ../../../chunks/vec4f64 ../../../layers/support/layerUtils ../../webgl/BufferObject ../../webgl/FramebufferObject ../../../core/has ../../webgl/checkWebGLError ../../webgl/enums ../../../chunks/builtins ../../webgl/Texture ../../webgl/VertexArrayObject ../../2d/engine/vectorTiles/VectorTileRendererHelper3D ../support/StreamDataLoader ./BlendLayersTechnique ./RasterColorizerTechnique ./terrainUtils ./TextureReference ./TileTexture ./support/FBOPool ../webgl-engine/lib/DefaultVertexBufferLayouts ../webgl-engine/lib/glUtil3D ../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H) {
          function J(P, L, N) { N.layerIndex = L; const G = P.layerInfo[1][L]; return G.data ? (u.set(N.offset, 0, 0), N.tile = P, N.scale = 1, N.sourceLod = P.lij, N.sourceLayerInfo = G, N) : (P = G.upsampleInfo) ? (L = P.tile.layerInfo[1][L], N.tile = P.tile, u.copy(N.offset, P.offset), N.scale = P.scale, N.sourceLod = P.tile.lij, N.sourceLayerInfo = L, N) : null } h = function () {
            function P(N, G, I) {
            this._rctx = N; this.tileSize = G; this._techniqueRepository = I; this._backgroundIsGrid = !1; this._blackTex =
              this._backgroundColor = this._backgroundTexture = null; this._vectorTileHelper = new g.VectorTileRendererHelper3D; this._maxAnisotropy = this._rctx.parameters.maxMaxAnisotropy; this._vaoQuad = E.createQuadVAO(this._rctx, D.Pos2Tex); this._blackTex = new B(E.createColorTexture(this._rctx, [0, 0, 0, 1])); this._fboPool = new C.FBOPool(this._rctx)
            } var L = P.prototype; L.dispose = function () {
            this._fboPool && (this._fboPool.clear(), this._fboPool = null); this._vaoQuad = q.disposeMaybe(this._vaoQuad); this._backgroundTexture = q.releaseMaybe(this._backgroundTexture);
              this._blackTex = q.releaseMaybe(this._blackTex); this._blendLayersTechnique = q.disposeMaybe(this._blendLayersTechnique); this._applyOpacityTechnique = q.disposeMaybe(this._applyOpacityTechnique); this._vectorTileHelper = q.disposeMaybe(this._vectorTileHelper)
            }; L.updateTileTexture = function (N, G) {
              var I = N.layerInfo[1]; for (var O of I) O.pendingUpdates &= -1; if (N.renderData) {
                for (var R = N.surface, S = R.baseOpacity, Q = O = 0, T = this.tileSize, da = !1, Y = R.view.pixelRatio, fa = I.length, ha = 0; ha < I.length && !da; ha++) {
                  const ka = R.layerViewByIndex(ha,
                    1), ea = ka.fullOpacity; M[ha] = ea; l.isBaseLayer(ka.layer) && fa >= I.length && (fa = ha); if (0 === ea) continue; ++Q; const ba = J(N, ha, F); ba && (A.isVectorTileLayerView(ka) ? T = Math.max(T, this.tileSize * Y) : 1 === S && 1 === ea && (ka.isOpaque || this._dataToTexture(ba) && ba.sourceLayerInfo.data.descriptor.isOpaque) && (da = !0), ++O)
                } this._cleanupFBOPool(Y, I.length); S = T; T = c.nextHighestPowerOfTwo(S); I = T * T; R = S * S; I === R ? T = S : (S = T / 2, T = I - R < R - S * S ? T : S); I = T / this.tileSize; --ha; 0 === O ? this._useBackgroundTexture(N, Q) : 1 === O && (da || this._backgroundIsGrid ||
                  q.isSome(this._backgroundColor)) && this._useLayerTexture(N, ha, fa, M[ha]) || this._composeMapLayers(N, G, ha, fa, da, M, T, I)
              }
            }; L._useBackgroundTexture = function (N, G) { let I = 0; if (N.surface.view.layerViewManager.updating || 0 < G) I = 5E3; this._backgroundTexture && q.isNone(N.renderData.textureReference) && (I = 0); N.renderData.setTextureReference(q.isSome(this._backgroundTexture) ? new z.TextureReference(this._backgroundTexture, 0, K, N.surface.baseOpacity, 1, 1, !1) : null, I) }; L._useLayerTexture = function (N, G, I, O) {
              var R = G < I; I = R ? 1 : N.surface.baseOpacity;
              R = R ? N.surface.baseOpacity : 1; G = J(N, G, F); return this._dataToTexture(G) ? (N.renderData.setTextureReference(new z.TextureReference(G.sourceLayerInfo.data, 0, G, I, O, R, !0)), !0) : !1
            }; L._composeMapLayers = function (N, G, I, O, R, S, Q, T) {
              const da = this._rctx, Y = this._fboPool.acquire(Q); da.bindFramebuffer(Y); da.setViewport(0, 0, Q, Q); da.setClearColor(0, 0, 0, 0); da.setClearDepth(1); da.clearSafe(16640); let fa = !1; !R && q.isSome(this._backgroundTexture) && this._drawRasterData(this.blendLayersTechnique, this._backgroundTexture.texture,
                1, y.ZEROS); R = N.surface.baseOpacity; let ha = !1, ka = 9987; for (; 0 <= I; I--) {
                  const ea = J(N, I, F); ea && (I < O && 1 > R && !ha && (this._drawRasterData(this.applyOpacityTechnique, this._blackTex.texture, 1, y.ZEROS, R), ha = !0), 0 !== S[I] && (A.isVectorTileRenderInfo(ea) ? fa = this._drawVectorData(this.blendLayersTechnique, ea, T, S[I], Q, Y, fa) : A.isImageryTileRenderInfo(ea) ? (this._drawImageryTileData(ea, S[I]), this.hasNearestInterpolation(ea) && (ka = 9728)) : this._dataToTexture(ea) && this._drawRasterData(this.blendLayersTechnique, ea.sourceLayerInfo.data.texture,
                    ea.scale, ea.offset, S[I])))
                } O = N.renderData.ensureTexture(Q, () => this._buildTexture(Q, ka)); S = da.bindTexture(O.texture, m.TEXTURE_UNIT_FOR_UPDATES); T = O.descriptor; da.gl.copyTexImage2D(da.gl.TEXTURE_2D, 0, T.pixelFormat, 0, 0, T.width, T.height, 0); O.generateMipmap(); da.bindTexture(S, m.TEXTURE_UNIT_FOR_UPDATES); da.bindFramebuffer(null); this._fboPool.release(Y); N.renderData.setTextureReference(new z.TextureReference(O, G, K, ha ? 1 : R, 1, 1, !1))
            }; L._drawQuad = function (N) {
              this._rctx.bindVAO(this._vaoQuad); N.assertCompatibleVertexAttributeLocations(this._vaoQuad);
              this._rctx.drawArrays(5, 0, H.vertexCount(this._vaoQuad, "geometry"))
            }; L._drawRasterData = function (N, G, I, O, R = 1) { if (!q.isNone(G)) { var S = this._rctx, Q = N.program; N.bindPipelineState(S); S.useProgram(Q); Q.bindTexture(G, "tex"); Q.setUniform1f("scale", I); Q.setUniform2f("offset", O[0], O[1]); Q.setUniform1f("opacity", R); this._drawQuad(Q) } }; L.hasNearestInterpolation = function (N) { N = N.sourceLayerInfo.data; return N.source ? "nearest" === N.interpolation : !1 }; L._drawImageryTileData = function (N, G = 1) {
              const I = N.sourceLayerInfo.data;
              if (I.source) { N.tile.surface.layerViewByIndex(N.layerIndex, 1).ensureSymbolizerParameters(I); var O = this._getRasterColorizerTechnique(I), R = this._rctx, S = O.program; O.bindPipelineState(R); R.useProgram(S); if (I.bind(R)) { I.opacity = G; I.scale = N.scale; I.offset = N.offset; var { names: Q, textures: T } = I.getTextures(); Q.forEach((da, Y) => S.bindTexture(T[Y], da)); O.bindPass(I.getUniforms()); this._drawQuad(S); R.bindVAO() } }
            }; L._getRasterColorizerTechnique = function (N) {
              const G = N.symbolizerParameters, I = ["stretch", "lut", "hillshade"].indexOf(G.type);
              q.isNone(this._rasterColorizerConfig) && (this._rasterColorizerConfig = new r.RasterColorizerTechniqueConfiguration, this._rctx.gl.getExtension("WEBGL_color_buffer_float"), this._rctx.gl.getExtension("OES_texture_float")); this._rasterColorizerConfig.colorizerType = I; this._rasterColorizerConfig.applyColormap = !!G.colormap; this._rasterColorizerConfig.stretchType = N.hasStretchTypeNone() ? 0 : 1; return this._rasterColorizerTechnique = this._techniqueRepository.releaseAndAcquire(r.RasterColorizerTechnique, this._rasterColorizerConfig,
                this._rasterColorizerTechnique)
            }; L._drawVectorData = function (N, G, I, O, R, S, Q) {
              const T = this._rctx, da = G.sourceLayerInfo.data, Y = G.tile.surface.layerViewByIndex(G.layerIndex, 1); let fa; N.bindPipelineState(T); 1 > O ? (fa = this._fboPool.acquire(R), T.bindFramebuffer(fa), T.setClearColor(1, 1, 1, 0), T.clearSafe(16640)) : Q && T.clearSafe(256); this._vectorTileHelper.render(T, G.sourceLod, da, Y.painter, Y.layer.styleRepository, Y.schemaHelper, Math.round(1 / G.scale), G.offset, this.tileSize, I); return q.isSome(fa) ? (T.bindFramebuffer(S),
                this._drawRasterData(N, fa.colorTexture, 1, [0, 0], O), this._fboPool.release(fa), Q) : !0
            }; L._dataToTexture = function (N) { A.isRasterTileRenderInfo(N) && this._rasterDataToTexture(N); return A.isTextureTileRenderInfo(N) }; L._rasterDataToTexture = function (N) { const G = N.sourceLayerInfo; G.data = this._buildTexture(G.data); N.tile.setMemoryDirty() }; L.setBackground = function (N, G) {
              q.releaseMaybe(this._backgroundTexture); this._backgroundIsGrid = G; N instanceof HTMLImageElement ? (this._backgroundTexture = this._buildTexture(N), this._backgroundColor =
                null) : (this._backgroundTexture = new B(E.createColorTexture(this._rctx, p.fromValues(N[0] || 0, N[1] || 0, N[2] || 0, 1))), this._backgroundColor = n.fromValues(N[0] || 0, N[1] || 0, N[2] || 0))
            }; L._buildTexture = function (N, G = 9987) {
              if (q.isNone(N)) return null; const I = { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: G, maxAnisotropy: this._maxAnisotropy, flipped: !0, hasMipmap: !0 }; G = this._rctx; let O; if ("number" === typeof N) I.width = I.height = N, O = new B(new m(G, I)); else if (N instanceof x.ImageWithType) I.isOpaque =
                N.isOpaque, O = new B(new m(G, I, N.image)), N.release(); else try { O = new B(new m(G, I, N)) } catch (R) { O = new B(E.createEmptyTexture(G)), console.warn("TileRenderer: failed to execute 'texImage2D', cross-origin image may not be loaded.") } N = G.bindTexture(O.texture, m.TEXTURE_UNIT_FOR_UPDATES); O.generateMipmap(); G.bindTexture(N, m.TEXTURE_UNIT_FOR_UPDATES); return O
            }; L._cleanupFBOPool = function (N, G) {
              if (N !== this._lastPixelRatio || G !== this._lastNumLayers) this._fboPool.clear(), this._lastPixelRatio = N, this._lastNumLayers =
                G
            }; w._createClass(P, [{ key: "blendLayersTechnique", get: function () { if (q.isNone(this._blendLayersTechnique)) { const N = new k.BlendLayersTechniqueConfiguration; N.mode = 2; this._blendLayersTechnique = this._techniqueRepository.acquire(k.BlendLayersTechnique, N) } return this._blendLayersTechnique } }, {
              key: "applyOpacityTechnique", get: function () {
                if (q.isNone(this._applyOpacityTechnique)) {
                  const N = new k.BlendLayersTechniqueConfiguration; N.mode = 1; this._applyOpacityTechnique = this._techniqueRepository.acquire(k.BlendLayersTechnique,
                    N)
                } return this._applyOpacityTechnique
              }
            }, { key: "backgroundIsGrid", get: function () { return this._backgroundIsGrid } }, { key: "backgroundColor", get: function () { return this._backgroundColor } }, { key: "test", get: function () { return { backgroundTexture: this._backgroundTexture } } }]); return P
          }(); const M = [], F = { tile: null, sourceLayerInfo: null, sourceLod: null, offset: [0, 0], scale: 1, layerIndex: 0 }, K = { offset: [0, 0], scale: 1 }; a.TileRenderer = h; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/2d/engine/vectorTiles/VectorTileRendererHelper3D": function () {
      define(["exports",
        "../../../../geometry", "../../../../Viewpoint", "../../ViewState", "../../../../geometry/Point"], function (a, w, c, q, u) {
          w = function () {
            function y() {
            this._renderParams = {
              context: null, drawPhase: 1, state: new q({ viewpoint: new c({ targetGeometry: new u(0, 0), scale: 1, rotation: 0 }), size: [256, 256] }), stationary: !0, pixelRatio: 1, displayLevel: -1, requiredLevel: -1, globalOpacity: 1, renderPass: "background", styleLayer: null, styleLayerUID: -1, painter: null, glyphMosaic: null, spriteMosaic: null, profiler: null, renderingOptions: null, deltaTime: -1,
              timeline: null, time: 0, hasClipping: !1, blendMode: null, dataUploadCounter: 0, effects: null, inFadeTransition: !1, requireFBO: !1
            }
            } var n = y.prototype; n.dispose = function () { this._renderParams = null }; n.render = function (p, l, h, b, d, f, t, v, m, e) {
              const g = f.adjustLevel(l[0]), x = this._renderParams; x.context = p; x.painter = b; x.glyphMosaic = b.glyphMosaic; x.spriteMosaic = b.spriteMosaic; x.pixelRatio = e; x.displayLevel = g; x.requiredLevel = g; e = f.getScale(l[0]); const [k, r] = f.getShift(l, t * e); l = .125 * t * e / m; f = h.transforms.dvs; f[0] = l; f[4] = -l; f[6] =
                -1 - k - v[0] * t * 2; f[7] = 1 + r + (1 - v[1]) * t * 2 - 2; x.state.size[0] = m; x.state.size[1] = m; h.stage || h.attachWithContext(p); h.triangleCount = 0; b.drawTile(x, h, d)
            }; return y
          }(); a.VectorTileRendererHelper3D = w; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/2d/ViewState": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../Viewpoint ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../chunks/common ../../chunks/mat2d ../../chunks/mat2df32 ../../chunks/mat2df64 ../../chunks/mat3 ../../chunks/mat3f32 ../../chunks/vec2 ../../chunks/vec2f32 ../../chunks/vec2f64 ../../core/libs/gl-matrix-2/types/vec2 ./viewpointUtils ../../geometry/Extent ../../geometry/Point".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z) {
          var B; const C = [0, 0]; c = B = function (D) {
            function E(J) { J = D.call(this, J) || this; J._viewpoint2D = { center: x.create(), rotation: 0, scale: 0, spatialReference: null }; J.center = [0, 0]; J.extent = new A; J.id = 0; J.inverseTransform = t.create(); J.resolution = 0; J.rotation = 0; J.scale = 0; J.transform = t.create(); J.transformNoRotation = t.create(); J.displayMat3 = m.create(); J.displayViewMat3 = m.create(); J.viewMat3 = m.create(); J.viewMat2d = f.create(); J.worldScreenWidth = 0; J.size = [0, 0]; return J }
            a._inheritsLoose(E, D); var H = E.prototype; H.copy = function (J) { const M = this.size, F = this.viewpoint; F && M ? (this.viewpoint = r.copy(F, J.viewpoint), this._set("size", e.copy(M, J.size))) : (this.viewpoint = J.viewpoint.clone(), this._set("size", [J.size[0], J.size[1]])); this._set("pixelRatio", J.pixelRatio); return this }; H.clone = function () { return new B({ size: this.size, viewpoint: this.viewpoint.clone(), pixelRatio: this.pixelRatio }) }; H.toMap = function (J, M, F) {
              if (k.isVec2(M)) return e.transformMat2d(J, M, this.inverseTransform);
              C[0] = M; C[1] = F; return e.transformMat2d(J, C, this.inverseTransform)
            }; H.toScreen = function (J, M, F) { if (k.isVec2(M)) return e.transformMat2d(J, M, this.transform); C[0] = M; C[1] = F; return e.transformMat2d(J, C, this.transform) }; H.toScreenNoRotation = function (J, M, F) { if (k.isVec2(M)) return e.transformMat2d(J, M, this.transformNoRotation); C[0] = M; C[1] = F; return e.transformMat2d(J, C, this.transformNoRotation) }; H.getScreenTransform = function (J, M) {
              const { center: F } = this._viewpoint2D, K = this._get("pixelRatio") || 1, P = this._get("size");
              r.getMatrix(J, F, P, M, 0, K); return J
            }; H._update = function () {
              const { center: J, spatialReference: M, scale: F, rotation: K } = this._viewpoint2D, P = this._get("pixelRatio") || 1, L = this._get("size"), N = new q({ targetGeometry: new z(J[0], J[1], M), scale: F, rotation: K }); this._set("viewpoint", N); if (L && M && F) {
              this.resolution = r.getResolution(N); this.rotation = K; this.scale = F; this.spatialReference = M; e.copy(this.center, J); v.set(this.displayMat3, 0 !== L[0] ? 2 / L[0] : 0, 0, 0, 0, 0 !== L[1] ? -2 / L[1] : 0, 0, -1, 1, 1); var G = v.identity(this.viewMat3), I = g.fromValues(L[0] /
                2, L[1] / 2), O = g.fromValues(-L[0] / 2, -L[1] / 2), R = b.toRadian(K); v.translate(G, G, I); v.rotate(G, G, R); v.translate(G, G, O); v.multiply(this.displayViewMat3, this.displayMat3, G); G = d.identity(this.viewMat2d); d.translate(G, G, I); d.rotate(G, G, R); d.translate(G, G, O); r.getExtent(this.extent, N, L); r.getTransform(this.transform, N, L, P); d.invert(this.inverseTransform, this.transform); r.getTransformNoRotation(this.transformNoRotation, N, L, P); this.worldScreenWidth = r.getWorldScreenWidth(this.spatialReference, this.resolution); this._set("id",
                  this.id + 1); return this
              }
            }; a._createClass(E, [{ key: "pixelRatio", set: function (J) { this._set("pixelRatio", J); this._update() } }, { key: "size", set: function (J) { this._set("size", J); this._update() } }, { key: "viewpoint", set: function (J) { if (J) { const M = this._viewpoint2D, F = J.targetGeometry; M.center[0] = F.x; M.center[1] = F.y; M.rotation = J.rotation; M.scale = J.scale; M.spatialReference = F.spatialReference } this._update() } }]); return E
          }(u.JSONSupport); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "id", void 0); w.__decorate([y.property({
            value: 1,
            json: { write: !0 }
          })], c.prototype, "pixelRatio", null); w.__decorate([y.property({ json: { write: !0 } })], c.prototype, "size", null); w.__decorate([y.property({ type: q, json: { write: !0 } })], c.prototype, "viewpoint", null); return c = B = w.__decorate([h.subclass("esri.views.2d.ViewState")], c)
        })
    }, "esri/chunks/mat2d": function () {
      define(["exports", "./common"], function (a, w) {
        function c(B, C) { B[0] = C[0]; B[1] = C[1]; B[2] = C[2]; B[3] = C[3]; B[4] = C[4]; B[5] = C[5]; return B } function q(B) { B[0] = 1; B[1] = 0; B[2] = 0; B[3] = 1; B[4] = 0; B[5] = 0; return B } function u(B,
          C, D, E, H, J, M) { B[0] = C; B[1] = D; B[2] = E; B[3] = H; B[4] = J; B[5] = M; return B } function y(B, C) { const D = C[0], E = C[1], H = C[2], J = C[3], M = C[4]; C = C[5]; let F = D * J - E * H; if (!F) return null; F = 1 / F; B[0] = J * F; B[1] = -E * F; B[2] = -H * F; B[3] = D * F; B[4] = (H * C - J * M) * F; B[5] = (E * M - D * C) * F; return B } function n(B) { return B[0] * B[3] - B[1] * B[2] } function p(B, C, D) { const E = C[0], H = C[1], J = C[2], M = C[3], F = C[4]; C = C[5]; const K = D[0], P = D[1], L = D[2], N = D[3], G = D[4]; D = D[5]; B[0] = E * K + J * P; B[1] = H * K + M * P; B[2] = E * L + J * N; B[3] = H * L + M * N; B[4] = E * G + J * D + F; B[5] = H * G + M * D + C; return B } function l(B,
            C, D) { const E = C[0], H = C[1], J = C[2], M = C[3], F = C[4]; C = C[5]; const K = Math.sin(D); D = Math.cos(D); B[0] = E * D + J * K; B[1] = H * D + M * K; B[2] = E * -K + J * D; B[3] = H * -K + M * D; B[4] = F; B[5] = C; return B } function h(B, C, D) { const E = C[1], H = C[2], J = C[3], M = C[4], F = C[5], K = D[0]; D = D[1]; B[0] = C[0] * K; B[1] = E * K; B[2] = H * D; B[3] = J * D; B[4] = M; B[5] = F; return B } function b(B, C, D) { const E = C[0], H = C[1], J = C[2], M = C[3], F = C[4]; C = C[5]; const K = D[0]; D = D[1]; B[0] = E; B[1] = H; B[2] = J; B[3] = M; B[4] = E * K + J * D + F; B[5] = H * K + M * D + C; return B } function d(B, C) {
              const D = Math.sin(C); C = Math.cos(C);
              B[0] = C; B[1] = D; B[2] = -D; B[3] = C; B[4] = 0; B[5] = 0; return B
            } function f(B, C) { B[0] = C[0]; B[1] = 0; B[2] = 0; B[3] = C[1]; B[4] = 0; B[5] = 0; return B } function t(B, C) { B[0] = 1; B[1] = 0; B[2] = 0; B[3] = 1; B[4] = C[0]; B[5] = C[1]; return B } function v(B) { return "mat2d(" + B[0] + ", " + B[1] + ", " + B[2] + ", " + B[3] + ", " + B[4] + ", " + B[5] + ")" } function m(B) { return Math.sqrt(B[0] ** 2 + B[1] ** 2 + B[2] ** 2 + B[3] ** 2 + B[4] ** 2 + B[5] ** 2 + 1) } function e(B, C, D) { B[0] = C[0] + D[0]; B[1] = C[1] + D[1]; B[2] = C[2] + D[2]; B[3] = C[3] + D[3]; B[4] = C[4] + D[4]; B[5] = C[5] + D[5]; return B } function g(B, C, D) {
            B[0] =
              C[0] - D[0]; B[1] = C[1] - D[1]; B[2] = C[2] - D[2]; B[3] = C[3] - D[3]; B[4] = C[4] - D[4]; B[5] = C[5] - D[5]; return B
            } function x(B, C, D) { B[0] = C[0] * D; B[1] = C[1] * D; B[2] = C[2] * D; B[3] = C[3] * D; B[4] = C[4] * D; B[5] = C[5] * D; return B } function k(B, C, D, E) { B[0] = C[0] + D[0] * E; B[1] = C[1] + D[1] * E; B[2] = C[2] + D[2] * E; B[3] = C[3] + D[3] * E; B[4] = C[4] + D[4] * E; B[5] = C[5] + D[5] * E; return B } function r(B, C) { return B[0] === C[0] && B[1] === C[1] && B[2] === C[2] && B[3] === C[3] && B[4] === C[4] && B[5] === C[5] } function A(B, C) {
              const D = B[0], E = B[1], H = B[2], J = B[3], M = B[4]; B = B[5]; const F = C[0],
                K = C[1], P = C[2], L = C[3], N = C[4]; C = C[5]; return Math.abs(D - F) <= w.EPSILON * Math.max(1, Math.abs(D), Math.abs(F)) && Math.abs(E - K) <= w.EPSILON * Math.max(1, Math.abs(E), Math.abs(K)) && Math.abs(H - P) <= w.EPSILON * Math.max(1, Math.abs(H), Math.abs(P)) && Math.abs(J - L) <= w.EPSILON * Math.max(1, Math.abs(J), Math.abs(L)) && Math.abs(M - N) <= w.EPSILON * Math.max(1, Math.abs(M), Math.abs(N)) && Math.abs(B - C) <= w.EPSILON * Math.max(1, Math.abs(B), Math.abs(C))
            } const z = Object.freeze({
              __proto__: null, copy: c, identity: q, set: u, invert: y, determinant: n, multiply: p,
              rotate: l, scale: h, translate: b, fromRotation: d, fromScaling: f, fromTranslation: t, str: v, frob: m, add: e, subtract: g, multiplyScalar: x, multiplyScalarAndAdd: k, exactEquals: r, equals: A, mul: p, sub: g
            }); a.add = e; a.copy = c; a.determinant = n; a.equals = A; a.exactEquals = r; a.frob = m; a.fromRotation = d; a.fromScaling = f; a.fromTranslation = t; a.identity = q; a.invert = y; a.mat2d = z; a.mul = p; a.multiply = p; a.multiplyScalar = x; a.multiplyScalarAndAdd = k; a.rotate = l; a.scale = h; a.set = u; a.str = v; a.sub = g; a.subtract = g; a.translate = b
      })
    }, "esri/chunks/mat2df32": function () {
      define(["exports"],
        function (a) {
          function w() { const l = new Float32Array(6); l[0] = 1; l[3] = 1; return l } function c(l) { const h = new Float32Array(6); h[0] = l[0]; h[1] = l[1]; h[2] = l[2]; h[3] = l[3]; h[4] = l[4]; h[5] = l[5]; return h } function q(l, h, b, d, f, t) { const v = new Float32Array(6); v[0] = l; v[1] = h; v[2] = b; v[3] = d; v[4] = f; v[5] = t; return v } function u(l, h) { return new Float32Array(l, h, 6) } function y(l, h, b, d) { const f = h[d]; h = h[d + 1]; l[d] = b[0] * f + b[2] * h + b[4]; l[d + 1] = b[1] * f + b[3] * h + b[5] } function n(l, h, b, d = 0, f = 0, t = 2) { for (f = f || h.length / t; d < f; d++)y(l, h, b, d * t) } const p =
            Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, createView: u, transform: y, transformMany: n }); a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.mat2df32 = p; a.transform = y; a.transformMany = n
        })
    }, "esri/chunks/mat2df64": function () {
      define(["exports"], function (a) {
        function w() { return [1, 0, 0, 1, 0, 0] } function c(n) { return [n[0], n[1], n[2], n[3], n[4], n[5]] } function q(n, p, l, h, b, d) { return [n, p, l, h, b, d] } function u(n, p) { return new Float64Array(n, p, 6) } const y = Object.freeze({
          __proto__: null, create: w, clone: c, fromValues: q,
          createView: u
        }); a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.mat2df64 = y
      })
    }, "esri/core/libs/gl-matrix-2/types/vec2": function () { define(["exports"], function (a) { function w(q) { return q instanceof Float32Array && 2 <= q.length } function c(q) { return Array.isArray(q) && 2 <= q.length } a.isVec2 = function (q) { return w(q) || c(q) }; a.isVec2f32 = w; a.isVec2f64 = c; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/2d/viewpointUtils": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../Viewpoint ../../core/Collection ../../core/maybe ../../core/unitUtils ../../chunks/common ../../chunks/mat2d ../../chunks/mat2df64 ../../chunks/vec2 ../../chunks/vec2f64 ../../geometry/Extent ../../geometry/Geometry ../../geometry/Point ../../geometry/SpatialReference ../../geometry/support/Ellipsoid ../../geometry/support/spatialReferenceUtils ../../geometry/support/webMercatorUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
          function x(U, X, Z, ia) { return ia && Z && !ia.equals(Z) && g.canProject(ia, Z) && ia.isWebMercator ? (ia.isWebMercator ? (Z = X[1], 89.99999 < Z ? Z = 89.99999 : -89.99999 > Z && (Z = -89.99999), Z = Math.sin(n.toRadian(Z)), U = h.set(U, n.toRadian(X[0]) * m.earth.radius, .5 * m.earth.radius * Math.log((1 + Z) / (1 - Z)))) : (Z = n.toDegree(X[0] / m.earth.radius), U = h.set(U, Z - 360 * Math.floor((Z + 180) / 360), n.toDegree(.5 * Math.PI - 2 * Math.atan(Math.exp(-X[1] / m.earth.radius))))), U) : h.copy(U, X) } function k(U) {
            return U.wkid ?
              U : U.spatialReference || v.WGS84
          } function r(U, X) { return X.type ? h.set(U, X.x, X.y) : h.copy(U, X) } function A(U, X) { return Math.max(U.width / X[0], U.height / X[1]) * K(U.spatialReference) } function z(U, X, Z, ia) { return B.apply(this, arguments) } function B() {
            B = w._asyncToGenerator(function* (U, X, Z, ia) {
              if (!U || Array.isArray(U) && !U.length) return null; q.isCollection(U) && (U = U.toArray()); if (Array.isArray(U) && U.length && "object" === typeof U[0]) {
                var la = U.every(Ea => "attributes" in Ea); var ma = U.some(Ea => !Ea.geometry), ra = U; if (la && ma &&
                  X && X.allLayerViews) {
                    la = new Map; for (var Aa of U) U = Aa.layer, ma = la.get(U) || [], ra = Aa.attributes[U.objectIdField], null != ra && ma.push(ra), la.set(U, ma); const Ea = []; la.forEach((Ua, Na) => { const ya = X.allLayerViews.find(pa => pa.layer.id === Na.id); if ("queryFeatures" in ya) { const pa = Na.createQuery(); pa.objectIds = Ua; pa.returnGeometry = !0; Ea.push(ya.queryFeatures(pa)) } }); Aa = yield Promise.all(Ea); U = []; for (var za of Aa) if (za && za.features && za.features.length) for (var Ka of za.features) u.isSome(Ka.geometry) && U.push(Ka.geometry);
                  ra = U
                } for (const Ea of ra) ia = yield z(Ea, X, Z, ia); return ia
              } if (Array.isArray(U) && 2 === U.length && "number" === typeof U[0] && "number" === typeof U[1]) la = new t(U); else if (U instanceof f) la = U; else if ("geometry" in U) if (U.geometry) la = U.geometry; else if (U.layer) { const Ea = U.layer; za = X.allLayerViews.find(Ua => Ua.layer.id === Ea.id); "queryFeatures" in za && (Ka = Ea.createQuery(), Ka.objectIds = [U.attributes[Ea.objectIdField]], Ka.returnGeometry = !0, za = yield za.queryFeatures(Ka), la = u.get(za, "features", 0, "geometry")) } if (u.isNone(la)) return null;
              za = "point" === la.type ? new d({ xmin: la.x, ymin: la.y, xmax: la.x, ymax: la.y, spatialReference: la.spatialReference }) : la.extent; if (!za) return null; Z = g.project(za, Z); return u.isNone(Z) ? null : ia = ia ? ia.union(Z) : Z
            }); return B.apply(this, arguments)
          } function C(U) {
            if (U && (!Array.isArray(U) || "number" !== typeof U[0]) && ("object" === typeof U || Array.isArray(U) && "object" === typeof U[0])) {
              if ("layer" in U && U.layer && U.layer.minScale && U.layer.maxScale) { var X = U.layer; return { min: X.minScale, max: X.maxScale } } if (Array.isArray(U) && U.length &&
                U.every(Z => "layer" in Z)) { let Z = X = 0; for (const ia of U) (U = ia.layer) && U.minScale && U.maxScale && (X = U.minScale < X ? U.minScale : X, Z = U.maxScale > Z ? U.maxScale : Z); return X && Z ? { min: X, max: Z } : null }
            }
          } function D(U, X) { return E.apply(this, arguments) } function E() {
            E = w._asyncToGenerator(function* (U, X) {
              if (!U || !X) return new c({ targetGeometry: new t, scale: 0, rotation: 0 }); var Z = X.spatialReference; const { constraints: ia, padding: la, viewpoint: ma, size: ra } = X, Aa = [la ? ra[0] - la.left - la.right : ra[0], la ? ra[1] - la.top - la.bottom : ra[1]]; let za =
                null; U instanceof c ? za = U : U.viewpoint ? za = U.viewpoint : U.target && "esri.Viewpoint" === U.target.declaredClass && (za = U.target); let Ka = null; if (za && za.targetGeometry) Ka = za.targetGeometry; else if (U instanceof d) Ka = U; else if (U || U && ("center" in U || "extent" in U || "target" in U)) Ka = (yield z(U.center, X, Z)) || (yield z(U.extent, X, Z)) || (yield z(U.target, X, Z)) || (yield z(U, X, Z)); !Ka && ma && ma.targetGeometry ? Ka = ma.targetGeometry : !Ka && X.extent && (Ka = X.extent); var Ea = k(Ka); Z || (Z = k(X.spatialReference || X.extent || Ka)); if (!g.canProject(Ka,
                  Z) && Ea && !Ea.equals(Z)) return null; var Ua = r(b.create(), Ka.center ? Ka.center : Ka); Ea = new t(x(Ua, Ua, Ea, Z), Z); Ua = null; za && u.isSome(za.targetGeometry) && "point" === za.targetGeometry.type ? Ua = za.scale : U.hasOwnProperty("scale") && U.scale ? Ua = U.scale : U.hasOwnProperty("zoom") && -1 !== U.zoom && ia && ia.effectiveLODs ? Ua = ia.zoomToScale(U.zoom) : Array.isArray(Ka) || "point" === Ka.type || "extent" === Ka.type && 0 === Ka.width && 0 === Ka.height ? (Z = g.project(X.extent, Z), Ua = u.isSome(Z) ? A(Z, Aa) : X.extent ? A(X.extent, Aa) : ma.scale) : Ua = g.canProject(Ka.extent,
                    Z) ? A(g.project(Ka.extent, Z), Aa) : A(Ka.extent, Aa); if (X = C(U)) X.min && X.min > Ua ? Ua = X.min : X.max && X.max < Ua && (Ua = X.max); X = 0; za ? X = za.rotation : U.hasOwnProperty("rotation") ? X = U.rotation : ma && (X = ma.rotation); U = new c({ targetGeometry: Ea, scale: Ua, rotation: X }); ia && (U = ia.fit(U), ia.constrainByGeometry(U), ia.rotationEnabled || (U.rotation = X)); return U
            }); return E.apply(this, arguments)
          } function H(U, X) {
            const Z = U.targetGeometry, ia = X.targetGeometry; Z.x = ia.x; Z.y = ia.y; Z.spatialReference = ia.spatialReference; U.scale = X.scale; U.rotation =
              X.rotation; return U
          } function J(U, X, Z) { return Z ? h.set(U, .5 * (X[0] - Z.right + Z.left), .5 * (X[1] - Z.bottom + Z.top)) : h.scale(U, X, .5) } function M(U, X, Z, ia) { R(U, X, Z, ia); return p.invert(U, U) } function F(U) { var X = U.scale; U = U.targetGeometry; U = u.isSome(U) && e.isValid(U.spatialReference) ? 1 / (39.37 * y.getMetersPerUnitForSR(U.spatialReference) * 96) : 1; return X * U } function K(U) { return e.isValid(U) ? 39.37 * y.getMetersPerUnitForSR(U) * 96 : 1 } function P(U) { return U.isWrappable ? (U = e.getInfo(U), U.valid[1] - U.valid[0]) : 0 } const L = 180 / Math.PI,
            N = function () { const U = b.create(); return function (X, Z, ia) { const la = Z.targetGeometry; r(U, la); Z = .5 * F(Z); X.xmin = U[0] - Z * ia[0]; X.ymin = U[1] - Z * ia[1]; X.xmax = U[0] + Z * ia[0]; X.ymax = U[1] + Z * ia[1]; X.spatialReference = la.spatialReference; return X } }(), G = function () { const U = b.create(); return function (X, Z, ia) { return h.sub(X, h.scale(X, Z, .5), J(U, Z, ia)) } }(), I = function () {
              const U = l.create(), X = b.create(); return function (Z, ia, la, ma) {
                const ra = F(ia); ia = n.toRadian(ia.rotation) || 0; h.set(X, ra, ra); p.fromScaling(U, X); p.rotate(U, U, ia);
                p.translate(U, U, G(X, la, ma)); p.translate(U, U, [0, ma.top - ma.bottom]); return h.set(Z, U[4], U[5])
              }
            }(), O = function () { const U = b.create(), X = b.create(), Z = b.create(); return function (ia, la, ma, ra, Aa, za) { h.negate(U, la); h.scale(X, ma, .5 * za); h.set(Z, 1 / ra * za, -1 / ra * za); p.identity(ia); p.translate(ia, ia, X); Aa && p.rotate(ia, ia, Aa); p.scale(ia, ia, Z); p.translate(ia, ia, U); return ia } }(), R = function () {
              const U = b.create(); return function (X, Z, ia, la) {
                const ma = F(Z), ra = n.toRadian(Z.rotation) || 0; r(U, Z.targetGeometry); return O(X, U, ia,
                  ma, ra, la)
              }
            }(), S = function () { const U = b.create(); return function (X, Z, ia, la) { const ma = F(Z); r(U, Z.targetGeometry); return O(X, U, ia, ma, 0, la) } }(), Q = function () { const U = b.create(), X = b.create(), Z = [0, 0, 0]; return function (ia, la, ma) { h.subtract(U, ia, la); h.normalize(U, U); h.subtract(X, ia, ma); h.normalize(X, X); h.cross(Z, U, X); ia = Math.acos(h.dot(U, X) / (h.length(U) * h.length(X))) * L; 0 > Z[2] && (ia = -ia); isNaN(ia) && (ia = 0); return ia } }(), T = function () {
              const U = b.create(); return function (X, Z, ia, la) {
                const ma = X.targetGeometry; H(X, Z);
                I(U, Z, ia, la); ma.x += U[0]; ma.y += U[1]; return X
              }
            }(), da = function () { const U = b.create(); return function (X, Z, ia, la) { const ma = X.targetGeometry; H(X, Z); I(U, Z, ia, la); ma.x -= U[0]; ma.y -= U[1]; return X } }(), Y = function () { const U = b.create(); return function (X, Z, ia) { H(X, Z); Z = X.targetGeometry; const la = k(ia), ma = k(Z); r(U, ia); x(U, U, la, ma); Z.x = U[0]; Z.y = U[1]; return X } }(), fa = function () {
              const U = b.create(); return function (X, Z, ia, la, ma) {
                ma || (ma = "center"); h.sub(U, ia, la); h.scale(U, U, .5); ia = U[0]; la = U[1]; switch (ma) {
                  case "center": h.set(U,
                    0, 0); break; case "left": h.set(U, -ia, 0); break; case "top": h.set(U, 0, la); break; case "right": h.set(U, ia, 0); break; case "bottom": h.set(U, 0, -la); break; case "top-left": h.set(U, -ia, la); break; case "bottom-left": h.set(U, -ia, -la); break; case "top-right": h.set(U, ia, la); break; case "bottom-right": h.set(U, ia, -la)
                }W(X, Z, U); return X
              }
            }(), ha = function () { const U = b.create(); return function (X, Z, ia, la, ma) { H(X, Z); isNaN(ia) || 0 === ia || (ba(U, la, Z, ma), X.scale = Z.scale * ia, aa(U, U, X, ma), W(X, X, h.set(U, U[0] - la[0], la[1] - U[1]))); return X } }(),
            ka = function () { const U = b.create(); return function (X, Z, ia, la, ma, ra) { H(X, Z); isNaN(ia) || 0 === ia || (ba(U, ma, Z, ra), X.scale = Z.scale * ia, X.rotation += la, aa(U, U, X, ra), W(X, X, h.set(U, U[0] - ma[0], ma[1] - U[1]))); return X } }(), ea = function () { const U = b.create(), X = b.create(); return function (Z, ia, la, ma, ra, Aa, za) { G(X, Aa, za); h.add(U, ra, X); return ma ? ka(Z, ia, la, ma, U, Aa) : ha(Z, ia, la, U, Aa) } }(), ba = function () { const U = l.create(); return function (X, Z, ia, la) { return h.transformMat2d(X, Z, M(U, ia, la, 1)) } }(), aa = function () {
              const U = l.create();
              return function (X, Z, ia, la) { return h.transformMat2d(X, Z, R(U, ia, la, 1)) }
            }(), W = function () { const U = b.create(), X = l.create(); return function (Z, ia, la) { H(Z, ia); const ma = F(ia), ra = Z.targetGeometry; p.fromRotation(X, n.toRadian(ia.rotation) || 0); p.scale(X, X, b.fromValues(ma, ma)); h.transformMat2d(U, la, X); ra.x += U[0]; ra.y += U[1]; return Z } }(); a.addPadding = T; a.angleBetween = Q; a.centerAt = Y; a.copy = H; a.create = D; a.createAsync = function (U, X) { return D(U, X) }; a.extentToScale = A; a.getAnchor = J; a.getExtent = N; a.getMatrix = O; a.getOuterSize =
              function (U, X, Z) { var ia = n.toRadian(X.rotation) || 0; X = Math.abs(Math.cos(ia)); ia = Math.abs(Math.sin(ia)); return h.set(U, Math.round(Z[1] * ia + Z[0] * X), Math.round(Z[1] * X + Z[0] * ia)) }; a.getPaddingMapTranslation = I; a.getPaddingScreenTranslation = G; a.getResolution = F; a.getResolutionToScaleFactor = K; a.getTransform = R; a.getTransformNoRotation = S; a.getWorldScreenWidth = function (U, X) { return Math.round(P(U) / X) }; a.getWorldWidth = P; a.padAndScaleAndRotateBy = ea; a.pixelSize = function (U) { return F(U) }; a.removePadding = da; a.resize = fa;
          a.rotateBy = function (U, X, Z) { H(U, X); U.rotation += Z; return U }; a.rotateTo = function (U, X, Z) { H(U, X); U.rotation = Z; return U }; a.scaleAndRotateBy = ka; a.scaleBy = ha; a.scaleTo = function (U, X, Z) { H(U, X); U.scale = Z; return U }; a.setExtent = function (U, X, Z, ia, la) { Y(U, X, Z.center); U.scale = A(Z, ia); la && la.constraints && la.constraints.constrain(U); return U }; a.toMap = ba; a.toScreen = aa; a.translateBy = W; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/BlendLayersTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../chunks/BlendLayers.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          n = function (d) { function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build(); return new h.Program(v.rctx, m, l.Default3D) }; t.initializePipeline = function () { const v = 2 === this.configuration.mode ? b.simpleBlendingParams(1, 771) : 1 === this.configuration.mode ? b.simpleBlendingParams(0, 770) : null; return b.makePipelineState({ blending: v, colorWrite: b.defaultColorWriteParams }) }; return f }(n.ShaderTechnique);
          n.shader = new y.ReloadableShaderModule(u.BlendLayersShader, () => new Promise((d, f) => a(["../webgl-engine/core/shaderLibrary/util/BlendLayers.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.mode = 0; return t } c._inheritsLoose(f, d); return f }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter({ count: 3 })], u.prototype, "mode", void 0); w.BlendLayersTechnique = n; w.BlendLayersTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/BlendLayers.glsl": function () {
      define(["exports",
        "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c) {
          function q() {
            const y = new c.ShaderBuilder; y.attributes.add("position", "vec2"); y.attributes.add("uv0", "vec2"); y.vertex.uniforms.add("scale", "float"); y.vertex.uniforms.add("offset", "vec2"); y.varyings.add("uv", "vec2"); y.vertex.code.add(w.glsl`void main(void) {
gl_Position = vec4(position, 0.0, 1.0);
uv = uv0 * scale + offset;
}`); y.fragment.uniforms.add("tex", "sampler2D"); y.fragment.uniforms.add("opacity", "float"); y.fragment.code.add(w.glsl`void main() {
vec4 color = texture2D(tex, uv);
gl_FragColor = vec4(color.xyz, 1.0) * color.a * opacity;
}`); return y
          } const u = Object.freeze({ __proto__: null, build: q }); a.BlendLayersShader = u; a.build = q
        })
    }, "esri/views/3d/terrain/RasterColorizerTechnique": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/maybe ../../../chunks/RasterColorizer.glsl ../webgl-engine/core/shaderTechnique/ReloadableShaderModule ../webgl-engine/core/shaderTechnique/ShaderTechnique ../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/Program ../../webgl/rasterUtils ../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          p = function (t) {
            function v() { return t.apply(this, arguments) || this } c._inheritsLoose(v, t); var m = v.prototype; m.initializeProgram = function (e) { var g = v.shader.get(); const x = this.configuration; g = g.build({ output: x.colorizerType, applyColormap: x.applyColormap, stretchType: x.stretchType }); this._context = e.rctx; return new b.Program(e.rctx, g, h.Default3D) }; m.initializePipeline = function () {
              const e = 2 === this.configuration.mode ? f.simpleBlendingParams(1, 771) : 1 === this.configuration.mode ?
                f.simpleBlendingParams(0, 770) : null; return f.makePipelineState({ blending: e, colorWrite: f.defaultColorWriteParams })
            }; m.bindPass = function (e) {
              d.setUniforms(this.program, this.uniformLocationInfos, e.basic); d.setUniforms(this.program, this.uniformLocationInfos, e.common); u.isSome(e.colormap) && d.setUniforms(this.program, this.uniformLocationInfos, e.colormap); 0 === this.configuration.colorizerType && u.isSome(e.stretch) ? d.setUniforms(this.program, this.uniformLocationInfos, e.stretch) : 2 === this.configuration.colorizerType &&
                u.isSome(e.hillshade) && d.setUniforms(this.program, this.uniformLocationInfos, e.hillshade)
            }; c._createClass(v, [{ key: "uniformLocationInfos", get: function () { this._uniformLocationInfos || (this._uniformLocationInfos = d.getUniformLocationInfos(this._context, this.program)); return this._uniformLocationInfos } }]); return v
          }(p.ShaderTechnique); p.shader = new n.ReloadableShaderModule(y.RasterColorizerShader, () => new Promise((t, v) => a(["../webgl-engine/core/shaderLibrary/raster/RasterColorizer.glsl"], t, v))); y = function (t) {
            function v() {
              var m =
                t.apply(this, arguments) || this; m.mode = 2; m.colorizerType = 0; m.stretchType = 0; m.applyColormap = !0; return m
            } c._inheritsLoose(v, t); return v
          }(l.ShaderTechniqueConfiguration); q.__decorate([l.parameter({ count: 3 })], y.prototype, "mode", void 0); q.__decorate([l.parameter({ count: 3 })], y.prototype, "colorizerType", void 0); q.__decorate([l.parameter({ count: 2 })], y.prototype, "stretchType", void 0); q.__decorate([l.parameter()], y.prototype, "applyColormap", void 0); w.RasterColorizerTechnique = p; w.RasterColorizerTechniqueConfiguration =
            y; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/RasterColorizer.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/raster/BasicGrid.glsl ../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl ../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(h) {
            const b = new n.ShaderBuilder; b.include(w.BasicGrid); b.include(q.Common); b.include(c.Colormap); if (0 === h.output) {
              {
                b.fragment.uniforms.add("u_bandCount", "int"); b.fragment.uniforms.add("u_minCutOff", "float", 3); b.fragment.uniforms.add("u_maxCutOff", "float", 3); b.fragment.uniforms.add("u_factor", "float", 3); b.fragment.uniforms.add("u_minOutput", "float"); b.fragment.uniforms.add("u_maxOutput", "float"); b.fragment.uniforms.add("u_useGamma", "bool"); b.fragment.uniforms.add("u_gamma",
                  "float", 3); b.fragment.uniforms.add("u_gammaCorrection", "float", 3); b.fragment.code.add(y.glsl`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {
if (val >= maxCutOff) {
return maxOutput;
} else if (val <= minCutOff) {
return minOutput;
}
float stretchedVal;
if (useGamma) {
float tempf = 1.0;
float outRange = maxOutput - minOutput;
float relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);
if (gamma > 1.0) {
tempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);
}
stretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;
} else {
stretchedVal = minOutput + (val - minCutOff) * factor;
}
return stretchedVal;
}`); const d = h.applyColormap ? y.glsl`gl_FragColor = colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma);` : y.glsl`gl_FragColor = vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;`; b.fragment.code.add(y.glsl`
      void main() {
        vec2 pixelLocation = getPixelLocation(v_texcoord);
        if (isOutside(pixelLocation)) {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
          return;
        }

        vec4 currentPixel = getPixel(pixelLocation);
        ${0 === h.stretchType ? y.glsl`
        gl_FragColor = vec4(currentPixel.rgb, 1.0) * currentPixel.a * u_opacity;`: y.glsl`
        if (currentPixel.a == 0.0) {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
          return;
        }
        if (u_bandCount == 1) {
          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);
          ${d}
        } else {
          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);
          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);
          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);
          gl_FragColor = vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;
        }`}
      }`)
              }
            } else 1 === h.output ? b.fragment.code.add(y.glsl`void main() {
vec2 pixelLocation = getPixelLocation(v_texcoord);
if (isOutside(pixelLocation)) {
gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
return;
}
vec4 currentPixel = getPixel(pixelLocation);
gl_FragColor = colormap(currentPixel, true);
}`) : 2 === h.output && (b.fragment.uniforms.add("u_hillshadeType", "int"), b.fragment.uniforms.add("u_sinZcosAs", "float", 6), b.fragment.uniforms.add("u_sinZsinAs", "float", 6), b.fragment.uniforms.add("u_cosZs", "float", 6), b.fragment.uniforms.add("u_weights", "float", 6), b.fragment.uniforms.add("u_factor", "vec2"), b.fragment.uniforms.add("u_applyColormap", "bool"), b.fragment.uniforms.add("u_minValue", "float"), b.fragment.uniforms.add("u_maxValue", "float"), b.fragment.uniforms.add("u_srcImageSize", "vec2"), b.fragment.include(u.ColorConversion),
                b.fragment.code.add(y.glsl`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {
val = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);
vec4 rgb = colormap(vec4(val, val, val, 1.0), false);
vec3 hsv = rgb2hsv(rgb.xyz);
hsv.z = hillshade;
return vec4(hsv2rgb(hsv) * alpha, alpha);
}`), b.fragment.code.add(y.glsl`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){
if (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {
return 0.0;
}  else {
return e;
}
}`), h = h.applyColormap ? y.glsl`gl_FragColor = overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha);` : y.glsl`hillshade *= alpha;
gl_FragColor = vec4(hillshade, hillshade, hillshade, alpha);`, b.fragment.code.add(y.glsl`
    void main() {
      vec2 pixelLocation = getPixelLocation(v_texcoord);
      if (isOutside(pixelLocation)) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        return;
      }

      vec4 currentPixel = getPixel(pixelLocation);
      if (currentPixel.a == 0.0) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        return;
      }

      //mirror edge pixels
      vec2 axy = vec2(-1.0, -1.0);
      vec2 bxy = vec2(0.0, -1.0);
      vec2 cxy = vec2(1.0, -1.0);
      vec2 dxy = vec2(-1.0, 0.0);
      vec2 fxy = vec2(1.0, 0.0);
      vec2 gxy = vec2(-1.0, 1.0);
      vec2 hxy = vec2(0.0, 1.0);
      vec2 ixy = vec2(1.0, 1.0);
      vec2 onePixel = 1.0 / u_srcImageSize;
      if (pixelLocation.s < onePixel.s) {
        axy[0] = 1.0;
        dxy[0] = 1.0;
        gxy[0] = 1.0;
      }
      if (pixelLocation.t < onePixel.t) {
        axy[1] = 1.0;
        bxy[1] = 1.0;
        cxy[1] = 1.0;
      }
      if (pixelLocation.s > 1.0 - onePixel.s) {
        cxy[0] = -1.0;
        fxy[0] = -1.0;
        ixy[0] = -1.0;
      }
      if (pixelLocation.t > 1.0 - onePixel.t) {
        gxy[1] = -1.0;
        hxy[1] = -1.0;
        ixy[1] = -1.0;
      }

      // calculate hillshade
      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);
      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);
      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);
      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);
      vec4 ve = texture2D(u_image, pixelLocation);
      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);
      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);
      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);
      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);

      // calculate the rate of z change along the x, y, and diagonal direction
      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;
      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;
      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);
      float hillshade = 0.0;

      // traditional single light source
      if (u_hillshadeType == 0){
        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;
        float z = (u_cosZs[0] + cosDelta) / dzd;
        if (z < 0.0)  z = 0.0;
        hillshade = z;
      } else {
        // multi-directional with 6 light sources
        for (int k = 0; k < 6; k++) {
        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;
        float z = (u_cosZs[k] + cosDelta) / dzd;
        if (z < 0.0) z = 0.0;
        hillshade = hillshade + z * u_weights[k];
        if (k == 5) break;
        }
      }

      // set color
      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);
      alpha *= u_opacity;
      ${h}
    }
  `)); return b
          } const l = Object.freeze({ __proto__: null, build: p }); a.RasterColorizerShader = l; a.build = p
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/raster/BasicGrid.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.BasicGrid = function (c) {
        c.attributes.add("position", "vec2"); c.attributes.add("uv0", "vec2"); c.vertex.uniforms.add("u_scale", "float"); c.vertex.uniforms.add("u_offset", "vec2"); c.varyings.add("v_texcoord", "vec2"); c.vertex.code.add(w.glsl`void main(void) {
v_texcoord = uv0 * u_scale + u_offset;
gl_Position = vec4(position, 0.0, 1.0);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.Colormap = function (c) {
        c.fragment.uniforms.add("u_colormap", "sampler2D"); c.fragment.uniforms.add("u_colormapOffset", "float"); c.fragment.uniforms.add("u_colormapMaxIndex", "float"); c.fragment.code.add(w.glsl`vec4 colormap(vec4 currentPixel, bool isFloat) {
float clrIndex = isFloat ? currentPixel.r - u_colormapOffset : currentPixel.r * 255.0 - u_colormapOffset;
vec4 result;
if (currentPixel.a == 0.0 || clrIndex > u_colormapMaxIndex) {
result = vec4(0.0, 0.0, 0.0, 0.0);
} else {
vec2 clrPosition = vec2((clrIndex + 0.5) / (u_colormapMaxIndex + 1.0), 0.0);
vec4 color = texture2D(u_colormap, clrPosition);
result = vec4(color.rgb, 1.0) * color.a * u_opacity;
}
return result;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl": function () {
      define(["exports", "./Projection.glsl", "../../shaderModules/interfaces"], function (a, w, c) {
      a.Common = function (q) {
        q.include(w.Projection); q.fragment.uniforms.add("u_image", "sampler2D"); q.fragment.uniforms.add("u_isFloatTexture", "bool"); q.fragment.uniforms.add("u_flipY", "bool"); q.fragment.uniforms.add("u_applyTransform", "bool"); q.fragment.uniforms.add("u_opacity", "float");
        q.fragment.code.add(c.glsl`vec2 getPixelLocation(vec2 coords) {
vec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;
if (!u_applyTransform) {
return targetLocation;
}
return projectPixelLocation(targetLocation);
}
bool isOutside(vec2 coords){
if (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {
return true;
} else {
return false;
}
}
vec4 getPixel(vec2 pixelLocation) {
return texture2D(u_image, pixelLocation);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/raster/Projection.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.Projection = function (c) {
        c.fragment.uniforms.add("u_transformGrid", "sampler2D"); c.fragment.uniforms.add("u_transformSpacing", "vec2"); c.fragment.uniforms.add("u_transformGridSize", "vec2"); c.fragment.uniforms.add("u_targetImageSize", "vec2"); c.fragment.code.add(w.glsl`vec2 projectPixelLocation(vec2 coords) {
vec2 index_image = floor(coords * u_targetImageSize);
vec2 oneTransformPixel = vec2(0.25 / u_transformGridSize.s, 1.0 / u_transformGridSize.t);
vec2 index_transform = floor(index_image / u_transformSpacing) / u_transformGridSize;
vec2 pos = fract((index_image + vec2(0.5, 0.5)) / u_transformSpacing);
vec2 srcLocation;
vec2 transform_location = index_transform + oneTransformPixel * 0.5;
if (pos.s <= pos.t) {
vec4 ll_abc = texture2D(u_transformGrid, vec2(transform_location.s, transform_location.t));
vec4 ll_def = texture2D(u_transformGrid, vec2(transform_location.s + oneTransformPixel.s, transform_location.t));
srcLocation.s = dot(ll_abc.rgb, vec3(pos, 1.0));
srcLocation.t = dot(ll_def.rgb, vec3(pos, 1.0));
} else {
vec4 ur_abc = texture2D(u_transformGrid, vec2(transform_location.s + 2.0 * oneTransformPixel.s, transform_location.t));
vec4 ur_def = texture2D(u_transformGrid, vec2(transform_location.s + 3.0 * oneTransformPixel.s, transform_location.t));
srcLocation.s = dot(ur_abc.rgb, vec3(pos, 1.0));
srcLocation.t = dot(ur_def.rgb, vec3(pos, 1.0));
}
return srcLocation;;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TextureReference": function () {
      define(["exports", "../../../chunks/vec3f64", "../../../chunks/vec4f64"], function (a, w, c) {
        let q = function () { function u(y, n, p, l, h, b, d) { this.texture = y; this.type = n; y.retain(); this.offsetAndScale = c.fromValues(p.offset[0], p.offset[1], p.scale, p.scale); this.opacities = w.fromValues(l, d ? b : 0, h) } u.prototype.destroy = function () { this.texture.release() }; return u }(); a.TextureReference = q; Object.defineProperty(a,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/support/FBOPool": function () {
      define(["exports", "../../../../core/ObjectPool", "../../../webgl/FramebufferObject"], function (a, w, c) {
        let q = function () {
          function u(n) { this._rctx = n; this._pools = new Map } var y = u.prototype; y.acquire = function (n) { return this.getPool(n).acquire() }; y.release = function (n) { this.getPool(n.width).release(n) }; y.clear = function () { this._pools.forEach(n => n.destroy()); this._pools.clear() }; y.getPool = function (n) {
            var p = this._pools.get(n); p || (p =
              c.bind(c, this._rctx, { colorTarget: 0, depthStencilTarget: 1, width: n, height: n }), p = new w(p), this._pools.set(n, p)); return p
          }; return u
        }(); a.FBOPool = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/collections/Component/ComponentIntersectionData": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../chunks/vec3f64", "../../../../../geometry/support/aaBoundingBox", "../../materials/internal/MaterialUtil"], function (a, w, c, q, u) {
        function y(e,
          g, x) { let k = 0, r = Infinity; for (let z = 0; 3 > z; ++z) { var A = e[z]; if (g[z] < A) { if (1E-6 >= x[z]) return !1; k = Math.max(k, (A - g[z]) / x[z]) } else -1E-6 >= x[z] && (r = Math.min(r, (A - g[z]) / x[z])); if (k > r) return !1; A = e[z + 3]; if (g[z] > A) { if (-1E-6 <= x[z]) return !1; k = Math.max(k, (A - g[z]) / x[z]) } else 1E-6 <= x[z] && (r = Math.min(r, (A - g[z]) / x[z])); if (k > r) return !1 } return !0 } function n(e, g, x, k, r, A) {
            let z = k; for (; x < z;) { var B = e[x]; g[6 * B + r + 3] <= A ? ++x : (--z, e[x] = e[z], e[z] = B) } B = x; for (z = k; B < z;)k = e[z - 1], g[6 * k + r] >= A ? --z : (e[z - 1] = e[B], e[B] = k, ++B); return {
              next: x,
              mid: B
            }
          } function p(e, g, x, k) { if (k <= x) return q.fromValues(NaN, NaN, NaN, NaN, NaN, NaN); var r = 6 * e[x]; for (var A = 0; 3 > A; ++A)v[A] = g[r + 0 + A], m[A] = g[r + 3 + A]; for (x += 1; x < k; ++x)for (r = 6 * e[x], A = 0; 3 > A; ++A)v[A] = Math.min(v[A], g[r + 0 + A]), m[A] = Math.max(m[A], g[r + 3 + A]); return q.fromValues(v[0], v[1], v[2], m[0], m[1], m[2]) } function l(e) { var g = e[3] - e[0]; const x = e[4] - e[1], k = e[5] - e[2]; g = g > x ? g > k ? 0 : x > k ? 1 : 2 : x > k ? 1 : k > g ? 2 : 0; return { axis: g, midValue: (e[g] + e[g + 3]) / 2 } } function h(e, g, x, k, r) {
            x -= g; const A = new Float32Array(6 * x); for (let B = 0; B < x; ++B) {
              var z =
                3 * (B + g); const C = e[z + 0] * r, D = e[z + 1] * r; z = e[z + 2] * r; for (let E = 0; 3 > E; ++E) { const H = k[C + E], J = k[D + E], M = k[z + E]; A[6 * B + E] = Math.min(H, J, M); A[6 * B + 3 + E] = Math.max(H, J, M) }
            } return A
          } function b(e, g, x, k) { const r = k - x; var A = 0; for (var z = x; z < k; ++z)for (var B = 0; 3 > B; ++B)A = Math.max(g[3 * z + B], A); k = 65535 >= A ? new Uint16Array(3 * r) : new Uint32Array(3 * r); for (A = 0; A < r; ++A)for (z = 3 * (e[A] + x), B = 0; 3 > B; ++B)k[3 * A + B] = g[z + B]; return k } let d = function (e, g, x, k, r) { this.aabb = e; this.axis = g; this.d = x; this.midStartIndex = k; this.rightStartIndex = r }, f = function () {
            function e(x,
              k, r, A) {
              this.globalTriangleVertexIndices = x; this.firstTriangleIndex = k; this.positionAttribute = A; this.rayDirection = c.create(); this.bspNodeTree = []; this.vertexPositionBuffer = A.data; this.vertexPositionStride = A.stride; const z = r - k, B = 65535 >= z ? new Uint16Array(z) : new Uint32Array(z); this.indices = B; for (let C = 0; C < z; ++C)B[C] = C; {
                const C = h(x, k, r, A.data, A.stride), D = (E, H, J) => {
                  var M = p(B, C, E, H); const F = H - E; if (20 >= F) return E = new d(M, void 0, 0, E, H), this.bspNodeTree.push(E), E; const { axis: K, midValue: P } = l(M), L = n(B, C, E, H, K, P),
                    N = (G, I) => { if (!(15 < J)) { var O = I - G; if (!(20 > O || O >= .8 * F)) return D(G, I, J + 1) } }; M = new d(M, K, P, L.next, L.mid); this.bspNodeTree.push(M); M.leftNode = N(E, L.next); M.rightNode = N(L.mid, H); return M
                }; D(0, z, 0); this.triangleVertexIndices = b(B, x, k, r)
              }
            } var g = e.prototype; g.intersectRayTriangleRange = function (x, k) {
              {
                if (x >= k) return; const L = this.triangleVertexIndices, N = this.positionAttribute.data, G = this.positionAttribute.stride; var r = this.rayOrigin; const I = r[0], O = r[1]; r = r[2]; var A = this.rayDirection; const R = A[0], S = A[1]; A = A[2];
                for (let Q = x, T = 3 * x; Q < k; ++Q) {
                  var z = L[T] * G, B = N[z], C = N[z + 1], D = N[z + 2], E = L[T + 1] * G; z = N[E]; var H = N[E + 1]; E = N[E + 2]; var J = L[T + 2] * G, M = N[J], F = N[J + 1]; J = N[J + 2]; T += 3; z -= B; H -= C; E -= D; M -= B; F -= C; J -= D; var K = S * J - F * A, P = A * M - J * R; const da = R * F - M * S, Y = z * K + H * P + E * da; if (!(Math.abs(Y) <= Number.EPSILON)) {
                    B = I - B; C = O - C; D = r - D; K = B * K + C * P + D * da; if (0 < Y) { if (0 > K || K > Y) continue } else if (0 < K || K < Y) continue; P = C * E - H * D; D = D * z - E * B; C = B * H - z * C; B = R * P + S * D + A * C; if (0 < Y) { if (0 > B || K + B > Y) continue } else if (0 < B || K + B < Y) continue; C = (M * P + F * D + J * C) / Y; 0 <= C && (D = this.indices[Q] +
                      this.firstTriangleIndex, z = u.computeNormal(z, H, E, M, F, J, t), this.callback(C, z, D, !1))
                  }
                }
              } e.numFacesTested += k - x
            }; g.intersectRay = function (x, k) { e.numFacesTested = 0; var r = c.fromValues(x.r0[0], x.r0[1], x.r0[2]), A = c.fromValues(x.r1[0], x.r1[1], x.r1[2]); x = A[0] - r[0]; const z = A[1] - r[1]; A = A[2] - r[2]; 1E-6 > x * x + z * z + A * A || (this.rayOrigin = r, r = this.rayDirection, r[0] = x, r[1] = z, r[2] = A, r = this.triangleVertexIndices.length / 3, this.callback = k, this.intersectRayBSP(this.bspNodeTree[0], 0, r)) }; g.intersectRayBSP = function (x, k, r) {
              const A =
                this.rayOrigin, z = this.rayDirection; if (y(x.aabb, A, z)) { var B = x.axis, C = x.d; if (A[B] < C || 0 > z[B]) { const D = x.midStartIndex; if (k < D) { const E = x.leftNode; void 0 !== E ? this.intersectRayBSP(E, k, D) : this.intersectRayTriangleRange(k, D) } } this.intersectRayTriangleRange(x.midStartIndex, x.rightStartIndex); if (A[B] > C || 0 < z[B]) k = x.rightStartIndex, k < r && (x = x.rightNode, void 0 !== x ? this.intersectRayBSP(x, k, r) : this.intersectRayTriangleRange(k, r)) }
            }; w._createClass(e, [{
              key: "estimatedMemoryUsage", get: function () {
                return this.triangleVertexIndices.byteLength +
                  this.indices.byteLength
              }
            }]); return e
          }(); f.numFacesTested = 0; const t = c.create(), v = [Infinity, Infinity, Infinity], m = [-Infinity, -Infinity, -Infinity]; a.ComponentIntersectionData = f; a.componentMinimalSizeForIntersectionData = 40; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/TerrainTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../chunks/Terrain.glsl ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/Program ../lib/StencilUtils ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          n = function (f) {
            function t() { var m = f.apply(this, arguments) || this; m.useStencil = !1; return m } c._inheritsLoose(t, f); var v = t.prototype; v.initializeProgram = function (m) {
              var e = t.shader.get(); const g = this.configuration; e = e.build({
                overlayMode: g.overlayMode, output: g.output, viewingMode: m.viewingMode, slicePlaneEnabled: g.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, textureFadingEnabled: g.textureFadingEnabled && !g.renderOccluded, hasBackgroundColor: g.hasBackgroundColor,
                useGrid: g.useGrid, receiveShadows: g.receiveShadows && !g.renderOccluded, receiveAmbientOcclusion: !1, atmosphere: g.atmosphere, tileBorders: g.tileBorders, screenSizePerspective: g.screenSizePerspective, pbrMode: 0, ssrEnabled: g.ssrEnabled, highStepCount: !1
              }); return new h.Program(m.rctx, e, l.Default3D)
            }; v.initializePipeline = function () { this._stencilPipelineState = this.createPipeline(!0); return this.createPipeline(!1) }; v.createPipeline = function (m) {
              const e = this.configuration, g = e.backfaceCullingEnabled && !e.renderOccluded;
              return d.makePipelineState({ blending: e.renderOccluded ? d.simpleBlendingParams(1, 771) : null, culling: g && d.backFaceCullingParams, depthTest: !e.renderOccluded && { func: 513 }, depthWrite: !e.renderOccluded && d.defaultDepthWriteParams, colorWrite: d.defaultColorWriteParams, stencilTest: m ? b.renderWhenBitIsNotSet(1) : null })
            }; v.getPipelineState = function (m, e) { return this.useStencil ? this._stencilPipelineState : f.prototype.getPipelineState.call(this, m, e) }; return t
          }(n.ShaderTechnique); n.shader = new y.ReloadableShaderModule(u.TerrainShader,
            () => new Promise((f, t) => a(["../core/shaderLibrary/terrain/Terrain.glsl"], f, t))); u = function (f) { function t() { var v = f.apply(this, arguments) || this; v.output = 0; v.overlayMode = 0; v.atmosphere = !1; v.receiveShadows = !1; v.slicePlaneEnabled = !1; v.backfaceCullingEnabled = !1; v.stencilEnabled = !1; v.textureFadingEnabled = !1; v.hasBackgroundColor = !1; v.useGrid = !1; v.renderOccluded = !1; v.ssrEnabled = !1; v.tileBorders = !1; v.screenSizePerspective = !1; return v } c._inheritsLoose(t, f); return t }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter({ count: 8 })],
              u.prototype, "output", void 0); q.__decorate([p.parameter({ count: 3 })], u.prototype, "overlayMode", void 0); q.__decorate([p.parameter()], u.prototype, "atmosphere", void 0); q.__decorate([p.parameter()], u.prototype, "receiveShadows", void 0); q.__decorate([p.parameter()], u.prototype, "slicePlaneEnabled", void 0); q.__decorate([p.parameter()], u.prototype, "backfaceCullingEnabled", void 0); q.__decorate([p.parameter()], u.prototype, "stencilEnabled", void 0); q.__decorate([p.parameter()], u.prototype, "textureFadingEnabled",
                void 0); q.__decorate([p.parameter()], u.prototype, "hasBackgroundColor", void 0); q.__decorate([p.parameter()], u.prototype, "useGrid", void 0); q.__decorate([p.parameter()], u.prototype, "renderOccluded", void 0); q.__decorate([p.parameter()], u.prototype, "ssrEnabled", void 0); q.__decorate([p.parameter()], u.prototype, "tileBorders", void 0); q.__decorate([p.parameter()], u.prototype, "screenSizePerspective", void 0); w.TerrainTechnique = n; w.TerrainTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    },
    "esri/chunks/Terrain.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl ../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl ../views/3d/webgl-engine/core/shaderLibrary/terrain/Skirts.glsl ../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/HeaderComment.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          function v(e) {
            const g = new t.ShaderBuilder; g.include(d.HeaderComment, { name: "Terrain Shader", output: e.output }); g.include(h.Skirts); g.attributes.add("position", "vec3"); g.attributes.add("uv0", "vec2"); g.vertex.uniforms.add("proj", "mat4").add("view", "mat4").add("origin", "vec3").add("skirtScale", "float"); if (0 === e.output) {
              g.include(c.Transform, { linearDepth: !1 }); g.include(p.NormalUtils, e); g.include(b.TerrainTexture, e); const x = 0 !== e.overlayMode, k = 2 === e.overlayMode; x && g.include(l.Overlay,
                { pbrMode: 3, useCustomDTRExponentForWater: !1, ssrEnabled: e.ssrEnabled, highStepCount: e.highStepCount }); k && g.include(q.VertexTangent, e); g.varyings.add("vnormal", "vec3"); g.varyings.add("vpos", "vec3"); g.vertex.uniforms.add("viewNormal", "mat4"); e.receiveShadows && g.varyings.add("linearDepth", "float"); e.tileBorders && g.varyings.add("vuv", "vec2"); e.atmosphere && (g.vertex.uniforms.add("lightingMainDirection", "vec3"), g.varyings.add("wnormal", "vec3"), g.varyings.add("wlight", "vec3")); e.screenSizePerspective && (g.vertex.uniforms.add("screenSizePerspective",
                  "vec4"), g.varyings.add("screenSizeDistanceToCamera", "float"), g.varyings.add("screenSizeCosAngle", "float")); g.vertex.code.add(f.glsl`
      void main(void) {
        vpos = position;
        vnormal = getLocalUp(vpos, origin);

        vec2 uv = uv0;
        vpos = applySkirts(uv, vpos, vnormal, skirtScale);
        ${e.atmosphere ? f.glsl`
        wnormal = normalize((viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz);
        wlight = normalize((view  * vec4(lightingMainDirection, 1.0)).xyz);`: ""}
        ${e.tileBorders ? f.glsl`vuv = uv;` : ""}
        ${e.screenSizePerspective ? f.glsl`
        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;
        screenSizeDistanceToCamera = length(viewPos);
        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;
        screenSizeCosAngle = abs(viewSpaceNormal.z);`: ""}
        gl_Position = transformPosition(proj, view, vpos);
        ${e.receiveShadows ? f.glsl`linearDepth = gl_Position.w;` : ""}
        forwardTextureCoordinates(uv);
        ${x ? f.glsl`setOverlayVTC(uv);` : ""}
        ${k ? f.glsl`forwardVertexTangent(vnormal);` : f.glsl``}
      }
    `); g.extensions.add("GL_OES_standard_derivatives"); g.extensions.add("GL_EXT_shader_texture_lod"); g.include(w.Slice, e); g.include(n.EvaluateSceneLighting, e); g.fragment.uniforms.add("camPos", "vec3").add("viewDirection", "vec3").add("ssaoTex", "sampler2D").add("viewportPixelSz", "vec4"); e.screenSizePerspective && g.fragment.uniforms.add("screenSizePerspective", "vec4"); k && (g.fragment.uniforms.add("ovWaterTex", "sampler2D"), g.fragment.uniforms.add("view", "mat4")); g.fragment.code.add(f.glsl`const float sliceOpacity = 0.2;
float lum(vec3 c) {
return (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;
}`); g.fragment.code.add(f.glsl`
      void main() {
        ${e.receiveShadows ? f.glsl`float shadow = readShadowMap(vpos, linearDepth);` : f.glsl`float shadow = 0.0;`}
        float vndl = dot(normalize(vnormal), lightingMainDirection);

        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;
        vec4 tileColor = getTileColor();
        ${x ? f.glsl`
            vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
            vec4 overlayColor = overlayOpacity * overlayColorOpaque;
            vec4 groundColor = tileColor;
            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;`: ""}
        if (rejectBySlice(vpos)) {
          tileColor *= sliceOpacity;
        }
        ${e.atmosphere ? f.glsl`
            float ndotl = clamp(vndl, 0.0, 1.0);
            vec3 atm = vec3(clamp(1.0 - dot(-viewDirection, wnormal), 0.0, 1.0));
            atm *= clamp(1.0 - lum(tileColor.rgb) * 1.5, 0.0, 1.0); //avoid atmosphere on bright base maps
            atm *= clamp(ndotl * 2.0, 0.0, 1.0); // avoid atmosphere on dark side of the globe
            atm *= tileColor.a; // premultiply with tile alpha`: ""}

        vec3 albedo = ${e.atmosphere ? f.glsl`atm + tileColor.rgb;` : f.glsl`tileColor.rgb;`}
        vec3 normal = normalize(vnormal);

        // heuristic shading function used in the old terrain, now used to add ambient lighting
        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

        gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);
        ${k ? f.glsl`
            vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);
            float waterNormalLength = length(overlayWaterMask);
            if (waterNormalLength > 0.95) {
              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);
              vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);
              vec4 viewPosition = view*vec4(vpos, 1.0);
              vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix, viewPosition.xyz);
              vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
              // un-gamma the ground color to mix in linear space
              gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w);
            }`: ""}
        ${e.screenSizePerspective ? f.glsl`
          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);
          if (perspectiveScale <= 0.25) {
            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);
          }
          else if (perspectiveScale <= 0.5) {
            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);
          }
          else if (perspectiveScale >= 0.99) {
            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);
          }
          else {
            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);
          }`: ""}
        ${e.tileBorders ? f.glsl`
            vec2 dVuv = fwidth(vuv);
            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));
            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);
            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);`: ""}
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
      }
    `)
            } if (1 === e.output || 3 === e.output) g.include(c.Transform, { linearDepth: !0 }), g.include(u.OutputDepth, { output: e.output }), g.include(p.NormalUtils, e), g.varyings.add("linearDepth", "float"), g.vertex.uniforms.add("nearFar", "vec2"), g.vertex.code.add(f.glsl`void main(void) {
vec3 normal = getLocalUp(position, origin);
vec2 uv = uv0;
vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);
}`), g.fragment.code.add(f.glsl`void main() {
outputDepth(linearDepth);
}`); 2 === e.output && (g.include(c.Transform, { linearDepth: !1 }), g.include(p.NormalUtils, e), g.varyings.add("vnormal", "vec3"), g.varyings.add("vpos", "vec3"), g.vertex.uniforms.add("viewNormal", "mat4"), g.vertex.code.add(f.glsl`void main(void) {
vec3 normal = getLocalUp(position, origin);
vec2 uv = uv0;
vpos = applySkirts(uv, position, normal, skirtScale);
gl_Position = transformPosition(proj, view, vpos);
vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);
}`), g.fragment.code.add(f.glsl`void main() {
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) {
normal = -normal;
}
gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);
}`)); 4 === e.output && (g.include(c.Transform, { linearDepth: !1 }), g.include(p.NormalUtils, e), g.include(l.Overlay, { pbrMode: 0 }), g.vertex.code.add(f.glsl`void main() {
vec3 vnormal = getLocalUp(position, origin);
vec2 uv = uv0;
vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);
setOverlayVTC(uv);
gl_Position = transformPosition(proj, view, vpos);
}`), g.include(y.OutputHighlight), g.fragment.code.add(f.glsl`void main() {
vec4 overlayColor = getCombinedOverlayColor();
if (overlayColor.a == 0.0) {
gl_FragColor = vec4(0.0);
return;
}
outputHighlight();
}`)); return g
          } const m = Object.freeze({ __proto__: null, build: v }); a.TerrainShader = m; a.build = v
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.VertexTangent = function (c, q) {
        c.varyings.add("tbnTangent", "vec3"); c.varyings.add("tbnBiTangent", "vec3"); 1 === q.viewingMode ? c.vertex.code.add(w.glsl`void forwardVertexTangent(vec3 n) {
tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));
tbnBiTangent = normalize(cross(n, tbnTangent));
}`) : c.vertex.code.add(w.glsl`void forwardVertexTangent(vec3 n) {
tbnTangent = vec3(1.0, 0.0, 0.0);
tbnBiTangent = normalize(cross(n, tbnTangent));
}`); c.fragment.code.add(w.glsl`mat3 getTBNMatrix(vec3 n) {
return mat3(tbnTangent, tbnBiTangent, n);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl": function () {
      define(["exports", "../shading/EvaluateMainLighting.glsl", "../shading/Water.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
      a.Overlay = function (u, y) {
        u.extensions.add("GL_OES_standard_derivatives"); 3 !== y.pbrMode && 4 !== y.pbrMode || u.include(c.Water, y); u.vertex.uniforms.add("overlayTexOffset", "vec4"); u.vertex.uniforms.add("overlayTexScale", "vec4"); u.varyings.add("vtcOverlay",
          "vec4"); u.vertex.code.add(q.glsl`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`); u.fragment.uniforms.add("ovColorTex", "sampler2D"); u.fragment.uniforms.add("overlayOpacity", "float"); u.fragment.code.add(q.glsl`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture2D(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture2D(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`); u.fragment.code.add(q.glsl`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`); if (3 === y.pbrMode || 4 === y.pbrMode) u.include(w.EvaluateMainLighting), u.fragment.code.add(q.glsl`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, lightingMainDirection, colorInput.rgb, lightingMainIntensity, localUp, 1.0 - shadow, maskInput.w, position);
return vec4(final, colorInput.w);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/terrain/Skirts.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.Skirts = function (c) {
        c.vertex.code.add(w.glsl`vec3 applySkirts(inout vec2 uv, vec3 vpos, vec3 vnormal, float skirtScale) {
float skirtLength = 0.0;
if (uv.x >= 2.0) {
skirtLength = uv.y * skirtScale;
vec2 x = vec2(uv.x) - vec2(3.5, 4.5);
uv = clamp(vec2(1.5) - abs(x), vec2(0.0), vec2(1.0));
}
return vpos - vnormal * skirtLength;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.TerrainTexture = function (c, q) {
        c.varyings.add("vtc", "vec2"); c.vertex.uniforms.add("texOffsetAndScale", "vec4"); c.fragment.uniforms.add("tex", "sampler2D"); c.fragment.uniforms.add("textureOpacities", "vec3"); q.textureFadingEnabled && (c.vertex.uniforms.add("nextTexOffsetAndScale", "vec4"), c.varyings.add("nvtc",
          "vec2"), c.fragment.uniforms.add("texNext", "sampler2D"), c.fragment.uniforms.add("nextTexOpacities", "vec3"), c.fragment.uniforms.add("fadeFactor", "float")); c.vertex.code.add(w.glsl`
  void forwardTextureCoordinates(in vec2 uv) {
    vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;
    ${q.textureFadingEnabled ? w.glsl`nvtc = uv * nextTexOffsetAndScale.zw + nextTexOffsetAndScale.xy;` : w.glsl``}
  }`); q.useGrid ? (c.fragment.code.add(w.glsl`float lineFactorAtPosition(float value) {
float pos = value * 129.0;
if(pos < 0.5 || pos > 128.5) {
return 1.0;
}
pos = pos + 0.5;
float modulo = mod(pos, 16.0);
return modulo <= 2.0 ?  1.0 - abs(modulo - 1.0) : 0.0;
}
float lineFactorAtUV(vec2 uv) {
return max(lineFactorAtPosition(uv.x), lineFactorAtPosition(uv.y));
}
float lineFactor(vec2 uv) {
vec2 offset = fwidth(uv) * 0.25;
return (lineFactorAtUV(vec2(uv.x + offset.x, uv.y + offset.y)) +
lineFactorAtUV(vec2(uv.x - offset.x, uv.y + offset.y)) +
lineFactorAtUV(vec2(uv.x + offset.x, uv.y - offset.y)) +
lineFactorAtUV(vec2(uv.x - offset.x, uv.y - offset.y))) / 4.0;
}
vec4 gridColor(vec2 uv) {
float line = lineFactor(uv) * 0.1 + 0.9;
float backgroundOpacity = textureOpacities.y;
return vec4(1.0, 0.972, 0.918, 1.0) * line * backgroundOpacity;
}`), c.fragment.code.add(w.glsl`vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {
if (opacities.y <= 0.0) {
return color * opacities.z * opacities.x;
}
vec4 grid = gridColor(uv);
float alpha = opacities.z * color.a;
return mix(grid, color, alpha) * opacities.x;
}`)) : q.hasBackgroundColor ? (c.fragment.uniforms.add("backgroundColor", "vec3"), c.fragment.code.add(w.glsl`vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {
if (opacities.y <= 0.0) {
return color * opacities.z * opacities.x;
}
float alpha = opacities.z * color.a;
float backgroundOpacity = opacities.y;
return mix(vec4(backgroundColor, 1.0) * backgroundOpacity, color, alpha) * opacities.x;
}`)) : c.fragment.code.add(w.glsl`vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {
return color;
}`); q.textureFadingEnabled ? c.fragment.code.add(w.glsl`vec4 getTileColor() {
vec4 color = getColor(texture2D(tex, vtc), vtc, textureOpacities);
if (fadeFactor >= 1.0) {
return color;
}
vec4 nextColor = getColor(texture2D(texNext, nvtc), nvtc, nextTexOpacities);
return mix(nextColor, color, fadeFactor);
}`) : c.fragment.code.add(w.glsl`vec4 getTileColor() {
return getColor(texture2D(tex, vtc), vtc, textureOpacities);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/terrain/TerrainSurfacePerformanceInfo": function () { define(function () { return function () { this.numMerged = this.numSplit = this.numRendered = this.numVisible = this.numLeaves = this.numNodes = 0; this.numRenderedPerLevel = []; this.numLoadedPerLevel = [] } }) }, "esri/views/3d/terrain/TilingSchemeLogic": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/projection ../../../geometry/support/aaBoundingRect ../../../geometry/support/spatialReferenceUtils ../../../layers/support/layerUtils ./terrainUtils ./TilingScheme".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
        a.TilingSchemeLogic = function (g) {
          function x(r) { r = g.call(this, r) || this; r._handles = new u; return r } w._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this._handles.add(this.layers.on("change", () => this._update())); this._handles.add(this.extentHelper.watch("layerViewsExtent", () => this._setAdHocTilingScheme())); this._update(); this.tilingSchemeLocked || this._setAdHocTilingScheme() }; k.destroy = function () {
          this._handles = y.destroyMaybe(this._handles); this._waitTask =
            null
          }; k._update = function () {
          this._waitTask = null; if (!this.tilingSchemeLocked) {
            this._set("tilingSchemeDone", !1); var r; this.layers.some(z => !v.isTiledLayer(z) || z.isRejected() ? !1 : !z.isFulfilled() || y.isSome(m.getTiledLayerInfo(z, this.viewSpatialReference, this.viewingMode)) ? (r = z, !m.isVectorTileLayer(z) && !m.isProjectableRasterLayer(z)) : !1); if (r) if (r.isResolved()) { var A = m.getTiledLayerInfo(r, this.viewSpatialReference, this.viewingMode); y.isSome(A) && (A = new e(A.tileInfo), this._set("tilingSchemeDone", !0), this._lockTilingScheme(A)) } else this._updateWhen(r);
            else this._set("tilingSchemeDone", !0)
          }
          }; k._updateWhen = function (r) { const A = r.when().catch(() => { }).then(() => { A !== this._waitTask || this.destroyed || this._update() }); this._waitTask = A }; k._lockTilingScheme = function (r) {
            if (1 === this.viewingMode) { const A = r.levels.length - 1; r.spatialReference.isWebMercator ? r = e.makeWebMercatorAuxiliarySphere(A) : d.canProjectToWGS84ComparableLonLat(r.spatialReference) && (r = e.makeGCSWithTileSize(r.spatialReference, r.pixelSize, A)) } this.tilingSchemeLocked = !0; this.tilingScheme = r; this.extentHelper.tilingScheme =
              this.tilingScheme; this._updateTiledLayerExtent(); this._handles.removeAll(); this._handles.add(this.extentHelper.watch("tiledLayersExtent", () => this._updateTiledLayerExtent()))
          }; k._updateTiledLayerExtent = function () { this._set("extent", this.extentHelper.tiledLayersExtent) }; k._setAdHocTilingScheme = function () {
            if (1 === this.viewingMode) {
              var r = this.extentHelper.viewSpatialReference; const A = d.canProjectToWGS84ComparableLonLat(r) || t.isMars(r) || t.isMoon(r); r.isWebMercator ? this.tilingScheme = e.WebMercatorAuxiliarySphere :
                A && (this.tilingScheme = e.makeGCSWithTileSize(r, 256)); this._set("extent", this.extentHelper.layerViewsExtent)
            } else r = this.extentHelper.layerViewsExtent, y.isSome(r) && !f.equals(r, this.extent) && (this.tilingScheme = e.fromExtent(r, this.extentHelper.viewSpatialReference), this._set("extent", r))
          }; w._createClass(x, [{ key: "test", get: function () { return { lockTilingScheme: r => this._lockTilingScheme(r), done: !this._waitTask } } }]); return x
        }(q); c.__decorate([n.property()], a.TilingSchemeLogic.prototype, "tilingScheme", void 0);
          c.__decorate([n.property({ readOnly: !0 })], a.TilingSchemeLogic.prototype, "extent", void 0); c.__decorate([n.property({ value: !1 })], a.TilingSchemeLogic.prototype, "tilingSchemeLocked", void 0); c.__decorate([n.property({ readOnly: !0, value: !1 })], a.TilingSchemeLogic.prototype, "tilingSchemeDone", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.TilingSchemeLogic.prototype, "viewSpatialReference", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.TilingSchemeLogic.prototype, "layers", void 0); c.__decorate([n.property({ constructOnly: !0 })],
            a.TilingSchemeLogic.prototype, "extentHelper", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.TilingSchemeLogic.prototype, "viewingMode", void 0); a.TilingSchemeLogic = c.__decorate([b.subclass("esri.views.3d.terrain.TilingSchemeLogic")], a.TilingSchemeLogic); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/terrain/UpsampleInfo": function () {
      define(["exports", "../../../chunks/vec2f64"], function (a, w) {
        let c = function () {
          function q() { this.offset = w.create(); this.scale = 0; this.tile = null }
          var u = q.prototype; u.init = function (y, n, p, l) { this.tile = y; this.offset[0] = n; this.offset[1] = p; this.scale = l }; u.dispose = function () { this.tile = null; this.offset[0] = 0; this.scale = this.offset[1] = 0 }; return q
        }(); a.UpsampleInfo = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/Stage": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/maybe ../../../core/PooledArray ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../state/helpers/SceneIntersectionHelper ./lib/AutoDisposable ./lib/ChangeSet ./lib/GeometryRecord ./lib/WebGLLayer ./parts/Model ./parts/RenderView ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
          var A; a.Stage = A = function (z) {
            function B(D) { D = z.call(this, D) || this; D._handles = new u; D._model = new x.Model; D._layers = new n; D._changeSet = new m.ChangeSet; D._layerSyncSet = new Set; return D } w._inheritsLoose(B, z); var C = B.prototype; C.initialize = function () { this._set("renderView", new k.RenderView(this)); this._frameTask = this.resourceController.scheduler.registerTask(r.TaskPriority.STAGE, this); this._handles.add(this._frameTask) }; C.destroy = function () {
              e.GeometryRecord.pool.prune(0);
              this._handles.destroy(); this.dispose()
            }; C.add = function (D) { this._model.add(D); g.isWebGLLayer(D) && (D.attachStage(this), this._addLayer(D)); this.renderView.requestRender() }; C.remove = function (D) { y.isNone(D) || (this.renderView.requestRender(), this._model.remove(D), g.isWebGLLayer(D) && (this._removeLayer(D), D.detachStage())) }; C.addMany = function (D) { y.isSome(D) && (this._model.addMany(D), this.renderView.requestRender()) }; C.removeMany = function (D) { y.isSome(D) && (this._model.removeMany(D), this.renderView.requestRender()) };
            C.load = function () { var D = w._asyncToGenerator(function* (E) { y.isNone(E) || (Array.isArray(E) || (E = [E]), yield p.all(E.filter(H => y.isNone(H.glTexture)).map(H => this.schedule(() => this._model.has(H) ? H.load(this.renderView.renderingContext, () => this.renderView.textureRepository.textureTechnique) : null)))) }); return function (E) { return D.apply(this, arguments) } }(); C.loadSynchronous = function (D) { return D.load(this.renderView.renderingContext, () => this.renderView.textureRepository.textureTechnique) }; C.forEachOfType = function (D,
              E) { this._model.forEachOfType(D, E) }; C.handleEvent = function (D, E) { this.destroyed || (this._model.dirtySet[D](E), this.renderView.requestRender()) }; C.runTask = function (D) { this._frameTask.processQueue(D); D.done || this._commit() }; C._commit = function () {
                const D = this._model.dirtySet; A.DebugSettings.logDirtySet && console.log("Dirty set: " + D.formatDebugInfo()); D.commit(this._changeSet); A.DebugSettings.logDirtySet && (console.log("RGs add: " + this._changeSet.adds.map(E => E.id)), console.log("RGs remove: " + this._changeSet.removes.map(E =>
                  E.id))); this._layerSyncSet.clear(); this.renderView.modify(this._changeSet); this.renderView.requestRender()
              }; C.schedule = function (D, E) { return this._frameTask.schedule(D, E) }; C.syncLayer = function (D) { this._layerSyncSet.add(D); this.renderView.requestRender() }; C.processSyncLayers = function () {
                const D = this._model.dirtySet; this._layers.forAll(E => { if (this._layerSyncSet.has(E.id) || 1 === E.updatePolicy) D.commitLayer(E.id, this._changeSet), this._layerSyncSet.delete(E.id) }); for (const E of this._layerSyncSet) D.commitLayer(E,
                  this._changeSet); this._layerSyncSet.clear(); this.renderView.modify(this._changeSet)
              }; C.getObject = function (D) { return this._model.getObject(D) }; C._addLayer = function (D) { this._layers.some(E => E === D) || this._layers.push(D) }; C._removeLayer = function (D) { this._commit(); null != this._layers.removeUnordered(D) && (this._model.dirtySet.getResidentRenderGeometries(D.id, this._changeSet.removes), this.renderView.modify(this._changeSet)) }; C.addRenderPlugin = function (D, E, H) {
                D = this.renderView.renderPlugins.add(D, E, H); H = () => { t.isIntersectionHandler(E) && this.sceneIntersectionHelper.addIntersectionHandler(E) }; if (p.isPromise(D)) return D.then(H); H()
              }; C.removeRenderPlugin = function (D) { t.isIntersectionHandler(D) && this.sceneIntersectionHelper.removeIntersectionHandler(D); this.renderView.renderPlugins.remove(D) }; w._createClass(B, [{ key: "viewingMode", get: function () { return this.state.viewingMode } }, { key: "updating", get: function () { return this._model.dirtySet.dirty || this.renderView.updating || this._frameTask.updating } }, {
                key: "running",
                get: function () { return this._model.dirtySet.dirty }
              }, { key: "layers", get: function () { return this._layers } }, { key: "performanceInfo", get: function () { return { renderView: this.renderView.performanceInfo, model: this._model.getStats() } } }, { key: "test", get: function () { const D = this; return { getCount(E) { return D._model.test.content.filter(H => H.type === E).length }, model: D._model } } }]); return B
          }(v.AutoDisposableMixin(q)); a.Stage.DebugSettings = { endFrameContentValidation: !1, logDirtySet: !1 }; c.__decorate([l.property({ constructOnly: !0 })],
            a.Stage.prototype, "resourceController", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.Stage.prototype, "options", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.Stage.prototype, "state", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.Stage.prototype, "sceneIntersectionHelper", void 0); c.__decorate([l.property({ readOnly: !0 })], a.Stage.prototype, "viewingMode", null); c.__decorate([l.property({ constructOnly: !0 })], a.Stage.prototype, "container", void 0); c.__decorate([l.property({ constructOnly: !0 })],
              a.Stage.prototype, "renderSR", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.Stage.prototype, "_handles", void 0); c.__decorate([l.property({ readOnly: !0 })], a.Stage.prototype, "updating", null); c.__decorate([l.property({ constructOnly: !0 })], a.Stage.prototype, "_model", void 0); c.__decorate([v.autoDispose(), l.property()], a.Stage.prototype, "renderView", void 0); a.Stage = A = c.__decorate([f.subclass("esri.views.3d.webgl-engine.Stage")], a.Stage); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/parts/Model": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../lib/GridLocalOriginFactory ../lib/ModelDirtySet ../lib/RenderGeometry ../lib/Util ../lib/WebGLLayer".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
        a.Model = function (m) {
          function e() { var x = m.apply(this, arguments) || this; x.dirtySet = new d({ model: w._assertThisInitialized(x) }); x._content = new Map; x._originFactory = new b.GridLocalOriginFactory(null, 75E4); return x } w._inheritsLoose(e, m); var g = e.prototype; g.getObject = function (x) { return this._content.get(x) }; g.add = function (x) { const k = x.id; t.assert(!this._content.has(k), "Model/Stage already contains object to be added"); this._content.set(k, x); v.isWebGLLayer(x) && this.dirtySet.layerAdded(x) };
          g.remove = function (x) { t.assert(this._content.has(x.id), "Model/Stage doesn't contain object to be removed"); this._content.delete(x.id); x.unload(); v.isWebGLLayer(x) && this.dirtySet.layerRemoved(x) }; g.addMany = function (x) { for (const k of x) u.isSome(k) && (t.assert(!this._content.has(k.id), "Model/Stage already contains object to be added"), this._content.set(k.id, k)) }; g.removeMany = function (x) {
            for (const k of x) t.assert(this._content.has(k.id), "Model/Stage doesn't contain object to be removed"), this._content.delete(k.id),
              k.unload()
          }; g.has = function (x) { return this._content.has(x.id) }; g.forEachOfType = function (x, k) { this._content.forEach(r => { r.type === x && k(r) }) }; g.getRenderGeometry = function (x, k) { const { geometry: r, material: A, id: z, shaderTransformation: B, origin: C, instanceParameters: D } = k, E = new f.RenderGeometry(r, A, null, null, z, r.boundingInfo, B, x.castShadow); E.updateTransformation(H => x.getCombinedStaticTransformation(k, H)); E.origin = C || this._originFactory.getOrigin(E.boundingSphere); E.instanceParameters = D; return E }; g.updateRenderGeometryTransformation =
            function (x, k, r) { if (u.isNone(x)) return !1; r.updateTransformation(z => x.getCombinedStaticTransformation(k, z)); const A = this._originFactory.getOrigin(r.boundingSphere); return r.origin !== A }; g.getStats = function () { const x = {}, k = Array.from(this._content.values()); for (let r = 0; 5 > r; ++r)x[r] = k.filter(A => A.type === r).length; return { contentTypes: x, dirtySet: this.dirtySet.formatDebugInfo() } }; w._createClass(e, [{ key: "test", get: function () { return { content: Array.from(this._content.values()) } } }]); return e
        }(q); c.__decorate([y.property({ constructOnly: !0 })],
          a.Model.prototype, "dirtySet", void 0); a.Model = c.__decorate([h.subclass("esri.views.3d.webgl-engine.parts.Model")], a.Model); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/ModelDirtySet": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/MapUtils ../../../../core/maybe ../../../../core/uid ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ./GeometryRecord ./Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          c = function (t) {
            function v(e) { e = t.call(this, e) || this; e._residentGeomRecords = new Map; e._dirtyGeomRecords = new Map; e.dirty = !1; return e } a._inheritsLoose(v, t); var m = v.prototype; m.commit = function (e) { this.dirty = !1; this._dirtyGeomRecords.forEach((g, x) => this.commitLayer(x, e)) }; m.commitLayer = function (e, g) {
              const x = this._dirtyGeomRecords.get(e); x && (x.forEach((k, r) => {
                const A = this._ensureGeomRecord(e, r); k.forEach((z, B) => {
                  var C = z[0], D = z[1], E = z[2]; z = !1; if (D & 2) {
                    var H = A.get(B); if (H) {
                      H =
                      H[1]; if (E & 4) { const J = this.model.getObject(r); this.model.updateRenderGeometryTransformation(J, C, H) && (z = !0) } z || g.updates.push({ renderGeometry: H, updateType: E })
                    } else f.assert(!1, "ModelDirtySet.getAddRemoveListFilteredByLayers: invalid update")
                  } if (D & 4 || z) (E = A.get(B)) ? (g.removes.push(E[1]), A.delete(B), E[0].disposed && d.GeometryRecord.pool.release(E[0])) : 4 === D && f.assert(!1, "ModelDirtySet.getAddRemoveListFilteredByLayers: invalid remove"); if (D & 1 || z) D = this.model.getObject(r), u.isSome(D) && (D = this.model.getRenderGeometry(D,
                    C), C = [C, D], g.adds.push(D), A.set(B, C))
                }); 0 === A.size && this._residentGeomRecords.get(e).delete(r)
              }), 0 === this._residentGeomRecords.get(e).size && this._residentGeomRecords.delete(e), this._dirtyGeomRecords.delete(e))
            }; m.getResidentRenderGeometries = function (e, g) { (e = this._residentGeomRecords.get(e)) && e.forEach(x => x.forEach(k => g.push(k[1]))) }; m._objectStateChanged = function (e, g) { for (const x of g.geometryRecords) this._updateOrCreateDirtyRecord(g, x, null, 2, 0, 0, 2, 5, e) }; m.visibilityChanged = function (e) {
              this._objectStateChanged(1,
                e)
            }; m.highlightChanged = function (e) { this._objectStateChanged(8, e) }; m.occlusionChanged = function (e) { this._objectStateChanged(16, e) }; m.vertexAttrsUpdated = function (e) { this._updateOrCreateDirtyRecord(e.object, e.record, null, 2, 0, 0, 2, 5, 2) }; m.layerAdded = function (e) { e.objects.forAll(g => this._layerObjectAdded(e, g)) }; m.layerRemoved = function (e) { e.objects.forAll(g => this._layerObjectRemoved(e, g)) }; m.layerObjectAdded = function (e) { this._layerObjectAdded(e.layer, e.object) }; m._layerObjectAdded = function (e, g) {
              e = e.id; for (const x of g.geometryRecords) this._objectGeometryAdded(g,
                x, e)
            }; m.layerObjectRemoved = function (e) { this._layerObjectRemoved(e.layer, e.object) }; m.layerObjectsAdded = function (e) { for (const g of e.objects) this._layerObjectAdded(e.layer, g) }; m.layerObjectsRemoved = function (e) { for (const g of e.objects) this._layerObjectRemoved(e.layer, g) }; m._layerObjectRemoved = function (e, g) { e = e.id; for (const x of g.geometryRecords) this._objectGeometryRemoved(g, x, e) }; m.shaderTransformationChanged = function (e) {
            (e = this._residentGeomRecords.get(e.id)) && e.forEach((g, x) => {
            (x = this.model.getObject(x)) &&
              x.hasVolativeTransformation() && g.forEach(k => { k[1].shaderTransformationChanged() })
            })
            }; m.objectTransformation = function (e) { const g = this._getParentLayerId(e); this._ensureGeomRecord(g, e.id).forEach(x => { this._updateOrCreateDirtyRecord(e, x[0], g, 2, 0, 0, 2, 5, 4) }) }; m.objectGeometryAdded = function (e) { this._objectGeometryAdded(e.object, e.record) }; m._objectGeometryAdded = function (e, g, x = null) { this._updateOrCreateDirtyRecord(e, g, x, 1, 4, 0, 0, 0) }; m.objectGeometryRemoved = function (e) {
              this._objectGeometryRemoved(e.object,
                e.record)
            }; m._objectGeometryRemoved = function (e, g, x = null) { this._updateOrCreateDirtyRecord(e, g, x, 4, 1, 2, 0, 0) }; m._updateOrCreateDirtyRecord = function (e, g, x, k, r, A, z, B, C) { x = u.unwrapOr(x, this._getParentLayerId(e)); const D = g.id; e = this._ensureDirtyRecord(x, e.id); (x = e.get(D)) ? (g = x[1], g & r ? (e.delete(D), x[0].disposed && d.GeometryRecord.pool.release(x[0])) : g & A ? (x[1] = k, x[2] = C) : g & z ? x[2] |= C : g & B || f.assert(!1, "ModelDirtySet.objectGeometryAdded: inconsistent state")) : e.set(D, [g, k, C]); this.dirty = this._hasDirtyGeometryRecords };
            m._ensureGeomRecord = function (e, g) { let x = this._residentGeomRecords.get(e); x || (x = new Map, this._residentGeomRecords.set(e, x)); e = x.get(g); e || (e = new Map, x.set(g, e)); return e }; m._ensureDirtyRecord = function (e, g) { let x = this._dirtyGeomRecords.get(e); x || (x = new Map, this._dirtyGeomRecords.set(e, x)); e = x.get(g); e || (e = new Map, x.set(g, e)); return e }; m._getParentLayerId = function (e) { return u.isSome(e.parentLayer) ? e.parentLayer.id : y.NullUID }; m.formatDebugInfo = function () {
              const e = ["ADD", "UPD", void 0, "REM"]; let g = ""; this._dirtyGeomRecords.forEach((x,
                k) => { x.forEach((r, A) => { 0 < g.length && (g += "\n"); g += k + "." + A; const z = []; r.forEach(B => { const C = B[1]; z[C] || (z[C] = []); z[C].push(B[0].geometry.id) }); for (r = 0; r < z.length; r++)if (z[r]) for (g += " " + e[r - 1] + ": ", A = 0; A < z[r].length; A++)g += z[r][A] + ", " }) }); return g
            }; a._createClass(v, [{ key: "_hasDirtyGeometryRecords", get: function () { return q.someMap(this._dirtyGeomRecords, e => q.someMap(e, g => g && 0 < g.size)) } }, {
              key: "test", get: function () {
                const e = this; return {
                  get residentLayerCount() { return e._residentGeomRecords.size }, get residentObjectCount() {
                    return Array.from(e._residentGeomRecords.values()).reduce((g,
                      x) => g + x.size, 0)
                  }
                }
              }
            }]); return v
          }(c); w.__decorate([n.property({ constructOnly: !0 })], c.prototype, "model", void 0); w.__decorate([n.property()], c.prototype, "dirty", void 0); return c = w.__decorate([b.subclass("esri.views.3d.webgl-engine.lib.ModelDirtySet")], c)
        })
    }, "esri/views/3d/webgl-engine/parts/RenderView": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../core/scheduling ../../../../core/time ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../support/animationUtils ../collections/Component/ComponentObjectCollection ../core/shaderTechnique/ShaderTechniqueRepository ../lib/AutoDisposable ../lib/CompositingHelper ../lib/depthRangeUtils ../lib/GLMaterialRepository ../lib/MagnifierHelper ../lib/Renderer ../lib/RenderingContext ../lib/TextureRepository ../materials/StippleTextureRepository ../materials/internal/WaterTextureRepository ./requireUtils ./ScreenshotManager ../../../webgl/context-util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F) {
          const K = n.getLogger("esri.views.3d.webgl-engine.parts.View"); a.RenderView = function (P) {
            function L(G) {
              var I = P.call(this, {}) || this; I.events = new u; I.waterTextureRepository = new H.WaterTextureRepository; I._magnifierHelper = new z.MagnifierHelper; I._needsUpdate = !0; I._needsRender = !0; I._idleSuspend = !0; I._needsWaterReflectionUpdate = !1; I._logicUpdateLast = 0; I._container = G.container; I._initializeContext(G); b.init(I.waterTextureRepository, "loadingState",
                () => I.requestRender()); I._magnifierHelper.events.on("request-render", () => I.requestRender()); I._stippleTextureRepository = new E.StippleTextureRepository(I._rctx); I._shaderTechniqueRepository = new g.ShaderTechniqueRepository({ rctx: I._rctx, viewingMode: G.viewingMode, stippleTextureRepository: I._stippleTextureRepository, waterTextureRepository: I.waterTextureRepository }); I._textureRepository = new D.TextureRepository(G, I._shaderTechniqueRepository, I._rctx); I._textureRepository.events.on("changed", O => I.requestRender(O));
              I._materialRepository = new A.GLMaterialRepository(I._textureRepository, I._shaderTechniqueRepository, () => I.requestRender(), () => I.requestRender()); I._compositingHelper = new k(I._rctx, I._shaderTechniqueRepository); I._renderer = new B.Renderer(I._materialRepository, I._textureRepository, I._shaderTechniqueRepository, I._rctx, I._compositingHelper, I._magnifierHelper, O => I.requestRender(O), (O, R) => G.schedule(O, R), G); I._screenshotManager = new M.ScreenshotManager(I._rctx, (O, R, S) => I._renderer.render(O, R, R, S), O => I.requestRender(O),
                G.options.screenshot.renderOverlay, O => I.events.emit("force-camera-for-screenshot", O)); I._registerFrameTask(G); return I
            } w._inheritsLoose(L, P); var N = L.prototype; N.normalizeCtorArgs = function () { return {} }; N.dispose = function () { this._container.contains(this._canvas) && this._container.removeChild(this._canvas); this._frameTask = p.removeMaybe(this._frameTask); this._shaderTechniqueRepository = p.disposeMaybe(this._shaderTechniqueRepository); P.prototype.dispose.call(this); this._rctx = this._tmpDepthBuffer = null }; N.requestRender =
              function (G = 1) { 1 === G ? this._needsUpdate = !0 : this._needsRender = !0 }; N.ensureEdgeView = function () { return this._renderer.ensureEdgeView() }; N.updateLightSources = function (G, I, O) { this._renderer.updateLightSources(G, I, O); this.requestRender() }; N.setRenderParameters = function (G) { void 0 !== G.idleSuspend && this._idleSuspend !== !!G.idleSuspend && (this._idleSuspend = !!G.idleSuspend, this.requestRender()); this._renderer.setRenderParameters(G) }; N.modify = function (G) { this._renderer.modify(G); G.clear() }; N.takeScreenshot = function (G) { return this._screenshotManager.takeScreenshot(G) };
            N.readAccumulatedShadow = function (G) { return this._renderer.readAccumulatedShadow(G[0], G[1]) }; N.getMinimalDepthForArea = function (G, I, O, R, S, Q = S) {
              Q = R.constrainWindowSize(I, O, S * R.pixelRatio, Q * R.pixelRatio); const T = this._ensureDepthBuffer(Q); this._renderer.readDepthPixels(R, Q[0], Q[1], Q[2], Q[3], T); S = Number.MAX_VALUE; for (let da = 0; da < Q[2] * Q[3]; da++) { const Y = r.textureToDepth(4 * da, T, R.nearFar); S > Y && Y !== R.nearFar[0] && Y !== R.nearFar[1] && (S = Y) } p.isSome(G) && (G = G.pickDepth(I * R.pixelRatio, O * R.pixelRatio, R), p.isSome(G) &&
                S > G && G !== R.nearFar[0] && G !== R.nearFar[1] && (S = G)); return S === Number.MAX_VALUE ? void 0 : S
            }; N._ensureDepthBuffer = function (G) { G = 4 * G[2] * G[3]; if (p.isNone(this._tmpDepthBuffer) || this._tmpDepthBuffer.byteLength < G) this._tmpDepthBuffer = new Uint8Array(G); return this._tmpDepthBuffer }; N.reloadShaders = function () { var G = w._asyncToGenerator(function* () { J.removeLoadedShaderModules(); yield this._shaderTechniqueRepository.reloadAll(); this.requestRender() }); return function () { return G.apply(this, arguments) } }(); N._registerFrameTask =
              function (G) {
                const I = G.state, O = { viewCamera: I.camera, frameHasDecorations: !1 }; this._frameTask = l.addFrameTask({
                  preRender: R => { G.processSyncLayers(); var S = h.Milliseconds(R.time - this._logicUpdateLast); if (S > m.DESIRED_ANIMATION_MS || p.isSome(this.forcedAnimationTime)) S = { camera: I.camera, dt: S, forcedTime: this.forcedAnimationTime }, this._logicUpdateLast = R.time, this._renderer.updateLogic(S) && this.requestRender(0) }, render: () => {
                    if ((this._needsUpdate || this._needsRender || !this._idleSuspend || !this._renderer.isCameraFinal ||
                      this._needsWaterReflectionUpdate) && 0 < I.camera.fullWidth && 0 < I.camera.fullHeight) { const R = this._needsUpdate && this._idleSuspend && this._renderer.isCameraFinal; this._needsWaterReflectionUpdate = this._needsUpdate = this._needsRender = !1; this._renderer.render(null, I.camera, I.contentCamera, 1); R && this._renderer.hasWaterReflection && (this.requestRender(0), this._needsWaterReflectionUpdate = !0) }
                  }, update: () => {
                  O.viewCamera = I.camera; O.frameHasDecorations = this._renderer.hasSlicePlane || this._magnifierHelper.enabled; this._textureRepository.update();
                    this._screenshotManager.update(O)
                  }
                })
              }; N._initializeContext = function (G) {
                const I = G.options; this._canvas = I.canvas; this._canvas || (this._canvas = document.createElement("canvas")); this._canvas.setAttribute("style", "width: 100%; height:100%; display:block;"); const O = { alpha: I.alpha || !1, premultipliedAlpha: !0, antialias: !1, depth: !0, stencil: null == I.stencil ? !0 : I.stencil, powerPreference: "high-performance" }; let R; const S = y("esri-force-webgl"); 1 === S || 2 === S ? R = F.createContextOrErrorHTML(this._canvas, S, O) : (R = F.createContext(this._canvas,
                  2, O), p.isNone(R) && (R = F.createContextOrErrorHTML(this._canvas, 1, O))); p.isNone(R) ? K.error("A WebGL context with the requested version (" + S ? S : "automatic) could not be created.") : (this._rctx = new C.RenderingContext(R, { disabledExtensions: I.deactivatedWebGLExtensions || {}, debugWebGLExtensions: I.debugWebGLExtensions || {}, maxAnisotropy: 8 }, (Q, T) => G.resourceController.memoryController.newCache(Q, T)), this._loadShaderOnlyExtensions(), !I.alpha && this._rctx.contextAttributes.alpha && K.error("WebGL context has alpha channel even though no alpha channel was requested"),
                    !this._rctx.contextAttributes.alpha && 11 <= y("safari") && (this._container.style.backgroundColor = "black"), this._container.appendChild(this._canvas))
              }; N._loadShaderOnlyExtensions = function () { this._rctx.capabilities.enable("standardDerivatives"); this._rctx.capabilities.enable("shaderTextureLOD"); this._rctx.capabilities.enable("textureFloat") }; w._createClass(L, [{
                key: "performanceInfo", get: function () {
                  const G = this._rctx.gl; return {
                    renderer: this._renderer.performanceInfo, textureMemory: void 0 !== G.getUsedTextureMemory ?
                      G.getUsedTextureMemory() : void 0, renderbufferMemory: void 0 !== G.getUsedRenderbufferMemory ? G.getUsedRenderbufferMemory() : void 0, VBOMemory: void 0 !== G.getUsedVBOMemory ? G.getUsedVBOMemory() : void 0
                  }
                }
              }, { key: "updating", get: function () { return this._needsUpdate || this._needsWaterReflectionUpdate || this._renderer.updating || this._textureRepository.updating || this.waterTextureRepository.updating || this._magnifierHelper.updating } }, { key: "edgeView", get: function () { return this._renderer.edgeView } }, {
                key: "textureRepository",
                get: function () { return this._textureRepository }
              }, { key: "compositingHelper", get: function () { return this._compositingHelper } }, { key: "magnifier", set: function (G) { this._magnifierHelper.magnifier = G } }, { key: "renderingContext", get: function () { return this._rctx } }, { key: "capabilities", get: function () { return this._rctx.capabilities } }, { key: "canvas", get: function () { return this._canvas } }, { key: "hasShadowsEnabled", get: function () { return this._renderer.hasShadowsEnabled } }, { key: "renderPlugins", get: function () { return this._renderer.renderPlugins } },
              { key: "test", get: function () { return { renderer: this._renderer } } }, { key: "gpuMemoryUsage", get: function () { return this._renderer.gpuMemoryUsage } }, { key: "componentObjectCollection", get: function () { p.isNone(this._componentObjectCollection) && (this._componentObjectCollection = new e.ComponentObjectCollection(this._renderer.renderPassManager)); return this._componentObjectCollection }, set: function (G) { this._componentObjectCollection = G } }]); return L
          }(x.AutoDisposableMixin(q)); c.__decorate([d.property({ type: Boolean, readOnly: !0 })],
            a.RenderView.prototype, "updating", null); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_rctx", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_container", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_canvas", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_stippleTextureRepository", void 0); c.__decorate([x.autoDispose(), d.property()], a.RenderView.prototype, "waterTextureRepository", void 0); c.__decorate([x.autoDispose(), d.property()], a.RenderView.prototype,
              "_magnifierHelper", void 0); c.__decorate([x.autoDispose(), d.property()], a.RenderView.prototype, "_textureRepository", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_compositingHelper", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_renderer", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "_screenshotManager", void 0); c.__decorate([x.autoDispose()], a.RenderView.prototype, "componentObjectCollection", null); c.__decorate([x.autoDispose()], a.RenderView.prototype,
                "_componentObjectCollection", void 0); c.__decorate([d.property()], a.RenderView.prototype, "_needsUpdate", void 0); c.__decorate([d.property()], a.RenderView.prototype, "_needsWaterReflectionUpdate", void 0); a.RenderView = c.__decorate([v.subclass("esri.views.3d.webgl-engine.parts.RenderView")], a.RenderView); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/collections/Component/ComponentObjectCollection": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/Logger ../../../../../core/maybe ../../../../../core/PooledArray ../../../../../chunks/mat3 ../../../../../chunks/mat3f32 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/vec4 ../../../../../chunks/vec4f32 ../../../layers/support/symbolColorUtils ../../../support/orientedBoundingBox ../../../support/buffer/glUtil ../../../support/buffer/InterleavedLayout ./ComponentData ./ComponentObject ./interface ./IntersectionGeometry ./Renderable ./RenderGeometry ./RenderSubmitSystem ./SourceGeometry ./Material/ComponentMaterial ./Material/ComponentTechnique ../../core/util/TwoVectorPosition ../../lib/ComponentUtils ../../lib/Util ../../lib/TextureBackedBuffer/BufferManager ../../../../webgl/BufferObject ../../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F) {
          const K = c.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection"); c = function () {
            function I(R) { this._renderManager = R; this._objects = [new u, new u]; this._renderSubmit = new A.RenderSubmitSystem(this); this._renderManager.register(this._renderSubmit); this._componentBufferManager = new J.BufferManager(R.rctx) } var O = I.prototype; O.dispose = function () {
              H.assert(0 === this._objects[0].length && 0 === this._objects[1].length,
                "ObjectCollection should be empty upon disposal"); this._componentBufferManager.destroy()
            }; O.createObject = function (R) { const S = new e.ComponentObject; S.toMapSpace = R.toMapSpace.slice(); S.transform = R.transform; S.obb = f.clone(R.obb); S.components = new m(this._componentBufferManager, R.geometry.componentOffsets); S.renderable = this._createRenderable(R, S.components); S.intersectionGeometry = new x(R.geometry.positionData, S.components); this._objects[S.visible].push(S); return S }; O.destroyObject = function (R) {
            this._objects[R.visible].removeUnordered(R);
              R.dispose(); this._notifyDirty()
            }; O.setObjectVisibility = function (R, S) { S !== R.visible && (this._objects[R.visible].removeUnordered(R), this._objects[S].push(R), R.visible = S, this._notifyDirty()) }; O.preSubmit = function (R) { const S = R.camera.eye; this.visibleObjects.forAll(Q => { const T = p.squaredDistance(S, Q.obb.center); Q.renderable.meta.cameraDepthSquared = T }) }; O.getMaterial = function (R) { return R.renderable.material }; O.updateMaterial = function (R, S) { R = R.renderable.material; S(R); R.dirty && this._notifyDirty() }; O.setAllComponentVisibilities =
              function (R, S) { R.components.visibility.reset(S); R.components.visibilityDirty(); this._notifyDirty() }; O.forEachVisibleComponent = function (R, S) { return R.components.visibility.forEachComponent(S) }; O.getComponentCount = function (R) { const S = R.components.visibility.componentCount(); return { visible: S, invisible: R.components.count - S } }; O.setComponentData = function (R, S) {
                const Q = R.renderable.material; if (g.isVaryingComponentParameters(S)) {
                  R = R.components; var T = R.materialDataBuffer; const da = R.materialDataIndices, Y = {
                    castShadows: !0,
                    pickable: !0, externalColor: b.create(), externalColorMixMode: 1
                  }; T = T.textureBuffer; const fa = new Uint8Array(4), ha = new Uint32Array(fa.buffer); let ka = 0, ea = 0, ba = 0, aa = !1, W = 0; for (let U = 0; U < R.count; U++)S(U, Y), ka += +(1 > Y.externalColor[3]), ea += +(3 === Y.externalColorMixMode && 1 === Y.externalColor[3]), ba += +Y.castShadows, d.encodeSymbolColor(Y.externalColor, Y.externalColorMixMode, fa), fa[2] = fa[2] & 254 | +Y.castShadows, T.setData(da[U], 0, fa[0], fa[1], fa[2], fa[3]), aa = aa || 0 < U && W !== ha[0], W = ha[0], Y.pickable !== E.getVisibility(R.pickability,
                    U) && (R.pickability = E.updateVisibilityWithCount(R.pickability, R.count, U, Y.pickable)); aa ? (Q.componentParameters = new B.ComponentParametersVarying, Q.componentParameters.castShadows = ba === R.count ? 0 : 0 === ba ? 2 : 1, Q.componentParameters.transparent = ka === R.count ? 0 : 0 === ka ? 2 : 1, Q.componentParameters.opaqueOverride = ea === R.count ? 0 : 0 === ea ? 2 : 1, Q.componentParameters.texture = T, T.updateTexture()) : (Q.componentParameters = new B.ComponentParametersUniform, Q.componentParameters.castShadows = Y.castShadows ? 0 : 2, Q.componentParameters.externalColor =
                      Y.externalColor, Q.componentParameters.externalColorMixMode = Y.externalColorMixMode)
                } else Q.componentParameters = new B.ComponentParametersUniform, Q.componentParameters.castShadows = S.castShadows ? 0 : 2, Q.componentParameters.externalColor = S.externalColor, Q.componentParameters.externalColorMixMode = S.externalColorMixMode; this._notifyDirty()
              }; O.getComponentAabb = function (R, S, Q) { return R.intersectionGeometry.getComponentAabb(S, Q) }; O.getComponentObb = function (R) { return R.obb }; O.getObjectTransform = function (R) { return R.transform };
            O.getComponentPositions = function (R, S, Q) { return R.intersectionGeometry.getComponentPositions(S, Q) }; O.intersect = function (R, S, Q, T, da, Y) { q.isSome(da) && (da.localOrigin = R.transform.position); const fa = y.invert(L, R.transform.rotationScale); p.sub(N, S, R.transform.position); p.sub(G, Q, R.transform.position); p.transformMat3(N, N, fa); p.transformMat3(G, G, fa); S = y.transpose(L, fa); return R.intersectionGeometry.intersect(N, G, T, S, da, Y) }; O.addEdges = function (R, S, Q, T) {
              const { indices: da, positions: Y } = R.intersectionGeometry,
              fa = R.components.offsets; return S.addComponentObject(R, R.transform, { center: R.obb.center, radius: f.radius(R.obb) }, Y, da, fa, Q, T)
            }; O.addComponentHighlight = function (R, S) { R = R.components; q.isNone(R.highlightCounts) && (R.highlightCounts = new Uint32Array(R.count + 1)); 0 === R.highlightCounts[S]++ && (R.highlightsDirty(), this._notifyDirty()); R.highlightCounts[R.count]++ }; O.removeComponentHighlight = function (R, S) {
              R = R.components; if (q.isNone(R.highlightCounts)) K.warn("Removing non-existing highlight."); else {
                var Q = R.highlightCounts[S],
                T = R.highlightCounts[R.count]; 0 === Q ? K.warn("Removing non-existing highlight.") : 1 < Q ? (R.highlightCounts[S] = Q - 1, R.highlightCounts[R.count] = T - 1) : (R.highlightCounts[S] = 0, R.highlightsDirty(), this._notifyDirty(), 1 === T ? R.highlightCounts = null : R.highlightCounts[R.count] = T - 1)
              }
            }; O.clearHighlights = function (R) { R = R.components; q.isSome(R.highlightCounts) && (R.highlightCounts = null, R.highlightsDirty(), this._notifyDirty()) }; O.getObjectGPUMemoryUsage = function (R) { return R.renderable.meta.gpuMemoryEstimate }; O._createRenderable =
              function (R, S) {
                const Q = this._renderManager.rctx; var T = R.geometry, da = T.vertices.layoutParameters, Y = M.createVertex(Q, 35044, T.vertices.data); const fa = q.applySome(T.indices, aa => M.createIndex(Q, 35044, aa)); var ha = t.glLayout(z.createVertexBufferLayout(da)), ka = new Uint16Array(T.vertices.count); for (var ea = 0; ea < S.count; ea++) { var ba = S.offsets[ea]; const aa = S.offsets[ea + 1], W = S.materialDataIndices[ea]; if (q.isSome(T.indices)) for (; ba < aa; ba++)ka[T.indices[ba]] = W; else for (; ba < aa; ba++)ka[ba] = W } T = M.createVertex(Q, 35044,
                  ka.buffer); ka = new D.TwoVectorPosition(R.transform.position); ea = n.clone(R.transform.rotationScale); y.invert(ea, ea); y.transpose(ea, ea); S = new C.ComponentDrawParameters; p.copy(S.worldFromModel_TL, ka.low); p.copy(S.worldFromModel_TH, ka.high); y.copy(S.worldFromModel_RS, R.transform.rotationScale); y.copy(S.transformNormal_GlobalFromModel, ea); h.copy(S.toMapSpace, R.toMapSpace); R = new B.ComponentMaterial; ha = new F(Q, R.attributeLocations, { data: ha, componentIndices: P }, { data: Y, componentIndices: T }, q.unwrap(fa)); da =
                    new r.RenderGeometry(ha, 4, da, q.isSome(fa)); Y = { cameraDepthSquared: .5, gpuMemoryEstimate: Y.byteSize + T.byteSize + (q.isSome(fa) ? fa.byteSize : 0) }; return new k.Renderable(R, S, da, Y)
              }; O._notifyDirty = function () { this._renderManager.notifyDirty() }; w._createClass(I, [{ key: "visibleObjects", get: function () { return this._objects[1] } }]); return I
          }(); const P = t.glLayout(v.newLayout().u16("componentIndex")), L = n.create(), N = l.create(), G = l.create(); a.ComponentObjectCollection = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/support/orientedBoundingBox": function () {
      define("exports ../../../chunks/mat3 ../../../chunks/mat3f64 ../../../chunks/quat ../../../chunks/quatf32 ../../../chunks/quatf64 ../../../chunks/vec3 ../../../chunks/vec3f32 ../../../chunks/vec3f64 ../../../chunks/vec4 ../../../chunks/vec4f64 ../../../geometry/support/aaBoundingBox ../../../geometry/support/plane ./dito".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        function v(C = [0, 0, 0], D = [-1, -1, -1], E = [0, 0, 0, 1]) {
          return {
            center: l.clone(C), halfSize: p.clone(D),
            quaternion: u.clone(E)
          }
        } function m(C, D) { const E = f.signedDistance(D, C.center); C = e(C, f.normal(D)); return E > C ? 1 : E < -C ? -1 : 0 } function e(C, D) { q.conjugate(g, C.quaternion); n.transformQuat(x, D, g); C = C.halfSize; return Math.abs(x[0] * C[0]) + Math.abs(x[1] * C[1]) + Math.abs(x[2] * C[2]) } const g = y.create(), x = l.create(), k = l.create(), r = b.create(), A = c.create(), z = [.1, .2, .3, .4, .5, .6, .7, .8, .9, 1, 1.1, 1.2], B = (() => {
          const C = new Int8Array(162); let D = 0; const E = H => { for (let J = 0; J < H.length; J++)C[D + J] = H[J]; D += 6 }; E([6, 2, 3, 1, 5, 4]); E([0, 2,
            3, 1, 5, 4]); E([0, 2, 3, 7, 5, 4]); E([0, 1, 3, 2, 6, 4]); E([0, 1, 3, 2, 0, 0]); E([0, 1, 5, 7, 3, 2]); E([0, 1, 3, 7, 6, 4]); E([0, 1, 3, 7, 6, 2]); E([0, 1, 5, 7, 6, 2]); E([0, 1, 5, 4, 6, 2]); E([0, 1, 5, 4, 0, 0]); E([0, 1, 3, 7, 5, 4]); E([0, 2, 6, 4, 0, 0]); E([0, 0, 0, 0, 0, 0]); E([1, 3, 7, 5, 0, 0]); E([2, 3, 7, 6, 4, 0]); E([2, 3, 7, 6, 0, 0]); E([2, 3, 1, 5, 7, 6]); E([0, 1, 5, 7, 6, 2]); E([0, 1, 5, 7, 6, 4]); E([0, 1, 3, 7, 6, 4]); E([4, 5, 7, 6, 2, 0]); E([4, 5, 7, 6, 0, 0]); E([4, 5, 1, 3, 7, 6]); E([0, 2, 3, 7, 5, 4]); E([6, 2, 3, 7, 5, 4]); E([6, 2, 3, 1, 5, 4]); return C
        })(); a.ObbArray = function (C) {
        this.buffer = new ArrayBuffer(56 *
          C); this.obbs = Array(C); for (let D = 0; D < C; D++)this.obbs[D] = { center: l.createView(this.buffer, 56 * D), halfSize: p.createView(this.buffer, 56 * D + 24), quaternion: u.createView(this.buffer, 56 * D + 36) }
        }; a.clone = function (C) { return v(C.center, C.halfSize, C.quaternion) }; a.compute = function (C, D) { D = D || v(); t.computeOBB(C, D); return D }; a.corners = function (C, D) {
          for (let E = 0; 8 > E; ++E) {
            const H = D[E]; H[0] = E & 1 ? -C.halfSize[0] : C.halfSize[0]; H[1] = E & 2 ? -C.halfSize[1] : C.halfSize[1]; H[2] = E & 4 ? -C.halfSize[2] : C.halfSize[2]; n.transformQuat(H, H,
              C.quaternion); n.add(H, H, C.center)
          }
        }; a.create = v; a.intersectLine = function (C, D, E, H = 0) { q.conjugate(g, C.quaternion); n.subtract(x, D, C.center); D = n.transformQuat(x, x, g); E = n.transformQuat(k, E, g); let J = -Infinity, M = Infinity; for (let F = 0; 3 > F; F++)if (1E-6 < Math.abs(E[F])) { const K = (H + C.halfSize[F] - D[F]) / E[F], P = (-H - C.halfSize[F] - D[F]) / E[F]; J = Math.max(J, Math.min(K, P)); M = Math.min(M, Math.max(K, P)) } else if (D[F] > C.halfSize[F] + H || D[F] < -C.halfSize[F] - H) return !1; return J <= M }; a.intersectPlane = m; a.isVisible = function (C, D) {
          return 0 >=
            m(C, D[0]) && 0 >= m(C, D[1]) && 0 >= m(C, D[2]) && 0 >= m(C, D[3]) && 0 >= m(C, D[4]) && 0 >= m(C, D[5])
        }; a.maximumDistancePlane = function (C, D) { const E = f.signedDistance(D, C.center); C = e(C, f.normal(D)); return E + C }; a.minimumDistancePlane = function (C, D) { const E = f.signedDistance(D, C.center); C = e(C, f.normal(D)); return E - C }; a.projectedArea = function (C, D, E, H, J) {
          q.conjugate(g, C.quaternion); n.sub(x, D, C.center); n.transformQuat(x, x, g); var M = x[0] < -C.halfSize[0] ? -1 : x[0] > C.halfSize[0] ? 1 : 0, F = x[1] < -C.halfSize[1] ? -1 : x[1] > C.halfSize[1] ? 1 : 0, K = x[2] <
            -C.halfSize[2] ? -1 : x[2] > C.halfSize[2] ? 1 : 0; D = Math.abs(M) + Math.abs(F) + Math.abs(K); if (0 === D) return Infinity; D = 1 === D ? 4 : 6; M = 6 * (M + 3 * F + 9 * K + 13); w.fromQuat(A, C.quaternion); w.scale(A, A, C.halfSize); for (F = 0; F < D; F++)K = B[M + F], n.set(x, ((K & 1) << 1) - 1, (K & 2) - 1, ((K & 4) >> 1) - 1), n.transformMat3(x, x, A), n.add(r, C.center, x), r[3] = 1, h.transformMat4(r, r, E), K = 1 / Math.max(1E-6, r[3]), z[2 * F] = r[0] * K, z[2 * F + 1] = r[1] * K; C = 2 * D - 2; E = z[0] * (z[3] - z[C + 1]) + z[C] * (z[1] - z[C - 1]); for (D = 2; D < C; D += 2)E += z[D] * (z[D + 3] - z[D - 1]); return Math.abs(E) * H * J * .125
        }; a.projectedRadius =
          e; a.radius = function (C) { return n.len(C.halfSize) }; a.set = function (C, D) { n.copy(D.center, C.center); n.copy(D.halfSize, C.halfSize); q.copy(D.quaternion, C.quaternion) }; a.toAaBoundingBox = function (C, D) {
            D || (D = d.create()); var E = w.fromQuat(A, C.quaternion); const H = C.halfSize[0] * Math.abs(E[0]) + C.halfSize[1] * Math.abs(E[3]) + C.halfSize[2] * Math.abs(E[6]), J = C.halfSize[0] * Math.abs(E[1]) + C.halfSize[1] * Math.abs(E[4]) + C.halfSize[2] * Math.abs(E[7]); E = C.halfSize[0] * Math.abs(E[2]) + C.halfSize[1] * Math.abs(E[5]) + C.halfSize[2] *
              Math.abs(E[8]); D[0] = C.center[0] - H; D[1] = C.center[1] - J; D[2] = C.center[2] - E; D[3] = C.center[0] + H; D[4] = C.center[1] + J; D[5] = C.center[2] + E; return D
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/quatf32": function () {
      define(["exports"], function (a) {
        function w() { const n = new Float32Array(4); n[3] = 1; return n } function c(n) { const p = new Float32Array(4); p[0] = n[0]; p[1] = n[1]; p[2] = n[2]; p[3] = n[3]; return p } function q(n, p, l, h) { const b = new Float32Array(4); b[0] = n; b[1] = p; b[2] = l; b[3] = h; return b } function u(n,
          p) { return new Float32Array(n, p, 4) } const y = Object.freeze({ __proto__: null, create: w, clone: c, fromValues: q, createView: u }); a.clone = c; a.create = w; a.createView = u; a.fromValues = q; a.quatf32 = y
      })
    }, "esri/views/3d/support/dito": function () {
      define(["exports"], function (a) {
        function w(fa, ha, ka, ea, ba, aa) {
          if (!(1E-6 > ha[0] * ha[0] + ha[1] * ha[1] + ha[2] * ha[2])) for (d(E, ka, ha), d(H, ea, ha), d(J, ba, ha), c(fa, ha, D), F[1] = D[0], M[1] = D[1], K[1] = M[1] - F[1], ka = [ka, ea, ba], ea = [E, H, J], ba = 0; 3 > ba; ++ba) {
            c(fa, ka[ba], D); F[0] = D[0]; M[0] = D[1]; c(fa, ea[ba],
              D); F[2] = D[0]; M[2] = D[1]; K[0] = M[0] - F[0]; K[2] = M[2] - F[2]; const W = n(K); W < aa.quality && (b(aa.b0, ka[ba]), b(aa.b1, ha), b(aa.b2, ea[ba]), aa.quality = W)
          }
        } function c(fa, ha, ka) { const { data: ea, size: ba } = fa; ka[0] = Number.POSITIVE_INFINITY; ka[1] = Number.NEGATIVE_INFINITY; for (fa = 0; fa < ea.length; fa += ba) { const aa = ea[fa] * ha[0] + ea[fa + 1] * ha[1] + ea[fa + 2] * ha[2]; ka[0] = Math.min(ka[0], aa); ka[1] = Math.max(ka[1], aa) } } function q(fa, ha, ka) {
          b(ka.center, fa); h(ka.halfSize, ha, .5); ka.quaternion[0] = 0; ka.quaternion[1] = 0; ka.quaternion[2] = 0; ka.quaternion[3] =
            1
        } function u(fa, ha, ka, ea, ba, aa) { c(fa, ha, D); ba[0] = D[0]; aa[0] = D[1]; c(fa, ka, D); ba[1] = D[0]; aa[1] = D[1]; c(fa, ea, D); ba[2] = D[0]; aa[2] = D[1] } function y(fa, ha, ka, ea, ba, aa, W) {
        Q[0] = fa[0]; Q[1] = fa[1]; Q[2] = fa[2]; Q[3] = ha[0]; Q[4] = ha[1]; Q[5] = ha[2]; Q[6] = ka[0]; Q[7] = ka[1]; Q[8] = ka[2]; var U = W.quaternion, X = Q, Z = X[0] + X[4] + X[8]; if (0 < Z) Z = Math.sqrt(Z + 1), U[3] = .5 * Z, Z = .5 / Z, U[0] = (X[5] - X[7]) * Z, U[1] = (X[6] - X[2]) * Z, U[2] = (X[1] - X[3]) * Z; else {
          Z = 0; X[4] > X[0] && (Z = 1); X[8] > X[3 * Z + Z] && (Z = 2); const ia = (Z + 1) % 3, la = (Z + 2) % 3; let ma = Math.sqrt(X[3 * Z + Z] -
            X[3 * ia + ia] - X[3 * la + la] + 1); U[Z] = .5 * ma; ma = .5 / ma; U[3] = (X[3 * ia + la] - X[3 * la + ia]) * ma; U[ia] = (X[3 * ia + Z] + X[3 * Z + ia]) * ma; U[la] = (X[3 * la + Z] + X[3 * Z + la]) * ma
        } p(T, ea, ba); h(T, T, .5); h(W.center, fa, T[0]); h(S, ha, T[1]); p(W.center, W.center, S); h(S, ka, T[2]); p(W.center, W.center, S); h(W.halfSize, aa, .5)
        } function n(fa) { return fa[0] * fa[1] + fa[0] * fa[2] + fa[1] * fa[2] } function p(fa, ha, ka) { fa[0] = ha[0] + ka[0]; fa[1] = ha[1] + ka[1]; fa[2] = ha[2] + ka[2] } function l(fa, ha, ka) { fa[0] = ha[0] - ka[0]; fa[1] = ha[1] - ka[1]; fa[2] = ha[2] - ka[2] } function h(fa, ha, ka) {
        fa[0] =
          ha[0] * ka; fa[1] = ha[1] * ka; fa[2] = ha[2] * ka
        } function b(fa, ha, ka = 0) { fa[0] = ha[ka + 0]; fa[1] = ha[ka + 1]; fa[2] = ha[ka + 2] } function d(fa, ha, ka) { const ea = ha[0], ba = ha[1]; ha = ha[2]; const aa = ka[0], W = ka[1]; ka = ka[2]; fa[0] = ba * ka - ha * W; fa[1] = ha * aa - ea * ka; fa[2] = ea * W - ba * aa } function f(fa, ha) { var ka = ha[0] * ha[0] + ha[1] * ha[1] + ha[2] * ha[2]; 0 < ka && (ka = 1 / Math.sqrt(ka), fa[0] = ha[0] * ka, fa[1] = ha[1] * ka, fa[2] = ha[2] * ka) } function t(fa, ha) { const ka = ha[0] - fa[0], ea = ha[1] - fa[1]; fa = ha[2] - fa[2]; return ka * ka + ea * ea + fa * fa } const v = [0, 0, 0], m = [0, 0, 0], e = [0,
          0, 0], g = [0, 0, 0], x = [0, 0, 0], k = [0, 0, 0], r = [0, 0, 0], A = [0, 0, 0], z = [0, 0, 0], B = [0, 0, 0], C = [0, 0, 0], D = [0, 0], E = [0, 0, 0], H = [0, 0, 0], J = [0, 0, 0], M = [0, 0, 0], F = [0, 0, 0], K = [0, 0, 0], P = [0, 0, 0], L = [0, 0, 0], N = [0, 0, 0], G = [0, 0, 0], I = [0, 0, 0], O = [0, 0, 0], R = [0, 0, 0], S = [0, 0, 0], Q = [1, 0, 0, 0, 1, 0, 0, 0, 1], T = [0, 0, 0]; let da = function (fa) {
          this.minVert = Array(7); this.maxVert = Array(7); this.buffer = new ArrayBuffer(448); var ha = 0; this.minProj = new Float64Array(this.buffer, ha, 7); ha += 56; this.maxProj = new Float64Array(this.buffer, ha, 7); ha += 56; for (var ka = 0; 7 > ka; ++ka)this.minVert[ka] =
            new Float64Array(this.buffer, ha, 3), ha += 24; for (ka = 0; 7 > ka; ++ka)this.maxVert[ka] = new Float64Array(this.buffer, ha, 3), ha += 24; for (ha = 0; 7 > ha; ++ha)this.minProj[ha] = Number.POSITIVE_INFINITY, this.maxProj[ha] = Number.NEGATIVE_INFINITY; ha = Array(7); ka = Array(7); const { data: ea, size: ba } = fa; for (fa = 0; fa < ea.length; fa += ba) {
              var aa = ea[fa]; aa < this.minProj[0] && (this.minProj[0] = aa, ha[0] = fa); aa > this.maxProj[0] && (this.maxProj[0] = aa, ka[0] = fa); aa = ea[fa + 1]; aa < this.minProj[1] && (this.minProj[1] = aa, ha[1] = fa); aa > this.maxProj[1] && (this.maxProj[1] =
                aa, ka[1] = fa); aa = ea[fa + 2]; aa < this.minProj[2] && (this.minProj[2] = aa, ha[2] = fa); aa > this.maxProj[2] && (this.maxProj[2] = aa, ka[2] = fa); aa = ea[fa] + ea[fa + 1] + ea[fa + 2]; aa < this.minProj[3] && (this.minProj[3] = aa, ha[3] = fa); aa > this.maxProj[3] && (this.maxProj[3] = aa, ka[3] = fa); aa = ea[fa] + ea[fa + 1] - ea[fa + 2]; aa < this.minProj[4] && (this.minProj[4] = aa, ha[4] = fa); aa > this.maxProj[4] && (this.maxProj[4] = aa, ka[4] = fa); aa = ea[fa] - ea[fa + 1] + ea[fa + 2]; aa < this.minProj[5] && (this.minProj[5] = aa, ha[5] = fa); aa > this.maxProj[5] && (this.maxProj[5] = aa, ka[5] =
                  fa); aa = ea[fa] - ea[fa + 1] - ea[fa + 2]; aa < this.minProj[6] && (this.minProj[6] = aa, ha[6] = fa); aa > this.maxProj[6] && (this.maxProj[6] = aa, ka[6] = fa)
            } for (fa = 0; 7 > fa; ++fa)aa = ha[fa], b(this.minVert[fa], ea, aa), aa = ka[fa], b(this.maxVert[fa], ea, aa)
          }, Y = function () { this.b0 = [1, 0, 0]; this.b1 = [0, 1, 0]; this.b2 = [0, 0, 1]; this.quality = 0 }; a.computeOBB = function (fa, ha) {
            const { data: ka, size: ea } = fa; var ba = ka.length / ea; if (!(0 >= ba)) {
              var aa = new da(fa); p(v, aa.minProj, aa.maxProj); h(v, v, .5); l(m, aa.maxProj, aa.minProj); var W = n(m), U = new Y; U.quality =
                W; 14 > ba && (fa = { data: new Float64Array(aa.buffer, 112, 42), size: 3 }); var X = [0, 0, 0], Z = [0, 0, 0], ia = [0, 0, 0]; ba = [0, 0, 0]; var la = [0, 0, 0], ma = [0, 0, 0], ra = [0, 0, 0]; var Aa = fa; var za = t(aa.maxVert[0], aa.minVert[0]), Ka = 0; for (var Ea = 1; 7 > Ea; ++Ea) { const Ua = t(aa.maxVert[Ea], aa.minVert[Ea]); Ua > za && (za = Ua, Ka = Ea) } b(X, aa.minVert[Ka]); b(Z, aa.maxVert[Ka]); if (1E-6 > t(X, Z)) Aa = 1; else {
                  l(ba, X, Z); f(ba, ba); {
                    const { data: Ua, size: Na } = Aa; aa = Number.NEGATIVE_INFINITY; za = 0; for (Ka = 0; Ka < Ua.length; Ka += Na)C[0] = Ua[Ka] - X[0], C[1] = Ua[Ka + 1] - X[1], C[2] =
                      Ua[Ka + 2] - X[2], Ea = ba[0] * C[0] + ba[1] * C[1] + ba[2] * C[2], Ea = C[0] * C[0] + C[1] * C[1] + C[2] * C[2] - Ea * Ea / (ba[0] * ba[0] + ba[1] * ba[1] + ba[2] * ba[2]), Ea > aa && (aa = Ea, za = Ka); b(ia, Ua, za)
                  } 1E-6 > aa ? Aa = 2 : (l(la, Z, ia), f(la, la), l(ma, ia, X), f(ma, ma), d(ra, la, ba), f(ra, ra), w(Aa, ra, ba, la, ma, U), Aa = 0)
                } switch (Aa) {
                  case 1: q(v, m, ha); return; case 2: W = fa; b(L, ba); Math.abs(ba[0]) > Math.abs(ba[1]) && Math.abs(ba[0]) > Math.abs(ba[2]) ? L[0] = 0 : Math.abs(ba[1]) > Math.abs(ba[2]) ? L[1] = 0 : L[2] = 0; 1E-6 > L[0] * L[0] + L[1] * L[1] + L[2] * L[2] && (L[0] = L[1] = L[2] = 1); d(N, ba, L); f(N,
                    N); d(G, ba, N); f(G, G); u(W, ba, N, G, I, O); l(R, O, I); y(ba, N, G, I, O, R, ha); return
                }Aa = fa; { aa = D; const { data: Ua, size: Na } = Aa; b(g, Ua); b(e, g); aa[0] = P[0] * ra[0] + P[1] * ra[1] + P[2] * ra[2]; aa[1] = aa[0]; for (za = Na; za < Ua.length; za += Na)Ka = Ua[za] * ra[0] + Ua[za + 1] * ra[1] + Ua[za + 2] * ra[2], Ka < aa[0] && (aa[0] = Ka, b(g, Ua, za)), Ka > aa[1] && (aa[1] = Ka, b(e, Ua, za)) } ra = X[0] * ra[0] + X[1] * ra[1] + X[2] * ra[2]; D[1] - 1E-6 <= ra && (e[0] = void 0); D[0] + 1E-6 >= ra && (g[0] = void 0); void 0 !== e[0] && (l(x, e, X), f(x, x), l(k, e, Z), f(k, k), l(r, e, ia), f(r, r), d(A, k, ba), f(A, A), d(z, r, la),
                  f(z, z), d(B, x, ma), f(B, B), w(Aa, A, ba, k, x, U), w(Aa, z, la, r, k, U), w(Aa, B, ma, x, r, U)); void 0 !== g[0] && (l(x, g, X), f(x, x), l(k, g, Z), f(k, k), l(r, g, ia), f(r, r), d(A, k, ba), f(A, A), d(z, r, la), f(z, z), d(B, x, ma), f(B, B), w(Aa, A, ba, k, x, U), w(Aa, z, la, r, k, U), w(Aa, B, ma, x, r, U)); u(fa, U.b0, U.b1, U.b2, I, O); fa = [0, 0, 0]; l(fa, O, I); U.quality = n(fa); U.quality < W ? y(U.b0, U.b1, U.b2, I, O, fa, ha) : q(v, m, ha)
            }
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/collections/Component/ComponentData": function () {
      define(["../../../../../chunks/_rollupPluginBabelHelpers",
        "../../../../../core/maybe", "../../../../../core/typedArrayUtil", "./IndexRange/ComponentRangeRunLengthEncoded", "../../lib/AutoDisposable"], function (a, w, c, q, u) {
          function y(n, p, l) {
            const h = [], b = []; let d = l.length, f = l.length; p.forEachComponent(t => { 0 < n[t] ? (d !== t - 1 && (h.length && h.push(l[d + 1] - h[h.length - 1]), h.push(l[t])), d = t) : (f !== t - 1 && (b.length && b.push(l[f + 1] - b[b.length - 1]), b.push(l[t])), f = t); return !0 }); h.length && h.push(l[d + 1] - h[h.length - 1]); b.length && b.push(l[f + 1] - b[b.length - 1]); return {
              highlightRanges: h,
              defaultRanges: b
            }
          } return function (n) {
            function p(h, b) { var d = n.call(this) || this; d.pickability = null; d.highlightCounts = null; d.cachedGeometryRanges = null; d.cachedHighlightRanges = null; d.cachedDefaultRanges = null; d.offsets = c.slice(b); b = d.count; d.visibility = new q.ComponentRangeRunLengthEncoded(b); d.materialDataBuffer = h.getBuffer(b); d.materialDataIndices = new Uint16Array(b); for (h = 0; h < b; h++)d.materialDataIndices[h] = d.materialDataBuffer.acquireIndex(); return d } a._inheritsLoose(p, n); var l = p.prototype; l.dispose = function () {
              n.prototype.dispose.call(this);
              for (let h = 0; h < this.count; h++)this.materialDataBuffer.releaseIndex(this.materialDataIndices[h])
            }; l.highlightsDirty = function () { this.cachedDefaultRanges = this.cachedHighlightRanges = null }; l.visibilityDirty = function () { this.cachedGeometryRanges = null; this.highlightsDirty() }; l.updateCachedHighlightRanges = function () {
              if ((w.isNone(this.cachedHighlightRanges) || w.isNone(this.cachedDefaultRanges)) && w.isSome(this.highlightCounts)) {
                const { highlightRanges: h, defaultRanges: b } = y(this.highlightCounts, this.visibility, this.offsets);
                this.cachedHighlightRanges = h; this.cachedDefaultRanges = b
              }
            }; a._createClass(p, [{ key: "count", get: function () { return this.offsets.length - 1 } }, { key: "geometryRanges", get: function () { w.isNone(this.cachedGeometryRanges) && (this.cachedGeometryRanges = this.visibility.computeOffsetRanges(this.offsets)); return this.cachedGeometryRanges } }, { key: "highlightRanges", get: function () { if (w.isNone(this.highlightCounts)) return null; this.updateCachedHighlightRanges(); return this.cachedHighlightRanges } }, {
              key: "defaultShadowMapRanges",
              get: function () { if (w.isNone(this.highlightCounts)) return this.geometryRanges; this.updateCachedHighlightRanges(); return this.cachedDefaultRanges }
            }]); return p
          }(u.AutoDisposable)
        })
    }, "esri/views/3d/webgl-engine/collections/Component/IndexRange/ComponentRangeRunLengthEncoded": function () {
      define(["exports"], function (a) {
        let w = function () {
          function c(u) { this._totalCount = u; this._indexRanges = [0, u] } var q = c.prototype; q.componentCount = function () {
            const u = this._indexRanges; let y = 0; for (let n = 0; n < u.length; n += 2)y += u[n +
              1]; return y
          }; q.reset = function (u) { if ("all" === u || u.length === this._totalCount) this._indexRanges = [0, this._totalCount]; else { { const p = []; if (0 !== u.length) { var y = u[0], n = 1; for (let l = 1; l < u.length; l++) { const h = u[l]; y + n === h ? n += 1 : (p.push(y), p.push(n), y = h, n = 1) } p.push(y); p.push(n) } u = p } this._indexRanges = u } }; q.forEachComponent = function (u) { const y = this._indexRanges; for (let p = 0; p < y.length; p += 2) { var n = y[p]; const l = n + y[p + 1]; for (; n < l; n++)if (!u(n)) return !1 } return !0 }; q.forEachComponentRange = function (u) {
            const y = this._indexRanges;
            for (let n = 0; n < y.length; n += 2) { const p = y[n]; if (!u(p, p + y[n + 1])) return !1 } return !0
          }; q.computeOffsetRanges = function (u) { const y = Array(this._indexRanges.length), n = this._indexRanges; for (let l = 0; l < n.length; l += 2) { var p = n[l]; const h = u[p]; p = u[p + n[l + 1]]; y[l] = h; y[l + 1] = p - h } return y }; return c
        }(); a.ComponentRangeRunLengthEncoded = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/collections/Component/ComponentObject": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers",
        "../../../../../chunks/tslib.es6", "../../lib/AutoDisposable"], function (a, w, c, q) { let u = function (y) { function n() { var p = y.apply(this, arguments) || this; p.visible = 0; return p } w._inheritsLoose(n, y); return n }(q.AutoDisposable); c.__decorate([q.autoDispose()], u.prototype, "renderable", void 0); c.__decorate([q.autoDispose()], u.prototype, "components", void 0); a.ComponentObject = u; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/collections/Component/interface": function () {
      define(["exports"],
        function (a) { a.isVaryingComponentParameters = function (w) { return "function" === typeof w }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/collections/Component/IntersectionGeometry": function () {
      define("../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/maybe ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/aaBoundingBox ../../../../../geometry/support/buffer/BufferView ./ComponentIntersectionData ../../lib/ComponentUtils ../../lib/geometryDataUtils ../../materials/internal/MaterialUtil".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          let b = function () {
            function t(m, e) { this._indices = w.isSome(m.indices) ? m.indices : l.generateDefaultIndexArray(m.positions.length / 3); this._positions = new y.BufferViewVec3f(m.positions); this._components = e; this._componentIntersectionData = Array(e.count) } var v = t.prototype; v.getComponentAabb = function (m, e) { if (w.isSome(this._perComponentAabbs)) { for (let g = 0; 6 > g; g++)e[g] = this._perComponentAabbs[6 * m + g]; return e } this._computePerComponentAabbs(); return this.getComponentAabb(m, e) }; v.getComponentPositions =
              function (m, e) { e.indices = this._indices; e.data = this._positions.typedBuffer; e.stride = this._positions.typedBufferStride; e.startIndex = this._components.offsets[m]; e.endIndex = this._components.offsets[m + 1] }; v.intersect = function (m, e, g, x, k, r) {
                const A = { data: this._positions.typedBuffer, stride: this._positions.typedBufferStride, size: 3 }, z = this._indices, B = this._components.offsets, C = h.computeInvDir(m, e, d); this._components.visibility.forEachComponent(D => {
                  if (!p.getVisibility(this._components.pickability, D)) return !0;
                  var E = this.getComponentAabb(D, f); w.isSome(k) && k.applyToAabb(E); if (!h.intersectAabbInvDir(E, m, C, g)) return !0; E = B[D] / 3; const H = B[D + 1] / 3, J = (F, K, P) => { r(D, F, c.transformMat3(K, K, x), P) }, M = H - E; w.isNone(k) && M > n.componentMinimalSizeForIntersectionData ? (null == this._componentIntersectionData[D] && (this._componentIntersectionData[D] = new n.ComponentIntersectionData(this._indices, E, H, A)), this._componentIntersectionData[D].intersectRay({ r0: m, r1: e }, J)) : h.intersectTriangles(m, e, E, H, z, A, void 0, k, J); return !0
                })
              }; v._computePerComponentAabbs =
                function () { const m = this._components.count; this._perComponentAabbs = new Float32Array(6 * m); for (let e = 0; e < m; e++)this._computeAABB(e) }; v._computeAABB = function (m) {
                  const e = this._indices, g = this._positions; var x = this._components.offsets, k = x[m]; const r = x[m + 1], A = [0, 0, 0]; x = [Infinity, Infinity, Infinity]; const z = [-Infinity, -Infinity, -Infinity]; for (; k < r; k++)g.getVec(e[k], A), c.min(x, x, A), c.max(z, z, A); m *= 6; this._perComponentAabbs[m++] = x[0]; this._perComponentAabbs[m++] = x[1]; this._perComponentAabbs[m++] = x[2]; this._perComponentAabbs[m++] =
                    z[0]; this._perComponentAabbs[m++] = z[1]; this._perComponentAabbs[m] = z[2]
                }; a._createClass(t, [{ key: "positions", get: function () { return this._positions } }, { key: "indices", get: function () { return this._indices } }]); return t
          }(); const d = q.create(), f = u.create(); return b
        })
    }, "esri/views/3d/webgl-engine/lib/ComponentUtils": function () {
      define(["exports"], function (a) {
        function w(c = !0) { return { isVisibleBit: !c, data: new Uint32Array(0) } } a.defaultVisibilities = w; a.getVisibility = function (c, q) {
          if (null == c) return !0; const { isVisibleBit: u,
            data: y } = c, n = 8 * y.BYTES_PER_ELEMENT; return q < y.length * n ? (c = q / n | 0, q = 0 !== (y[c] & 1 << q - c * n) === u) : !c.isVisibleBit
        }; a.updateVisibilityWithCount = function (c, q, u, y) { if (u >= q) return c; null == c && (c = w()); let n = c.data; const p = 8 * n.BYTES_PER_ELEMENT, l = u / p | 0, h = u - p * l, b = n; y = y === c.isVisibleBit; u < b.length * p || !y || (u = Math.max(l + 1, Math.ceil(1.5 * b.length)), u = Math.min(u, ((q - 1) / p | 0) + 1), n = new Uint32Array(u), n.set(b)); l < n.length && (n[l] = n[l] & ~(1 << h) | (y ? 1 : 0) << h); c.data = n; return c }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    },
    "esri/views/3d/webgl-engine/collections/Component/Renderable": function () { define(["exports"], function (a) { let w = function () { function c(q, u, y, n) { this.material = q; this.drawParameters = u; this.geometry = y; this.meta = n } c.prototype.dispose = function () { this.material.dispose(); this.geometry.dispose() }; return c }(); a.Renderable = w; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/webgl-engine/collections/Component/RenderGeometry": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers",
        "../../../../../chunks/tslib.es6", "../../lib/AutoDisposable"], function (a, w, c, q) { let u = function (y) { function n(p, l, h, b) { var d = y.call(this) || this; d.primitiveType = l; d.parameters = h; d.indexed = b; d.vao = p; return d } w._inheritsLoose(n, y); return n }(q.AutoDisposable); c.__decorate([q.autoDispose()], u.prototype, "vao", void 0); a.RenderGeometry = u; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/collections/Component/RenderSubmitSystem": function () {
      define(["exports", "./DepthRange"], function (a,
        w) { let c = function () { function q(y) { this._objects = y } var u = q.prototype; u.submit = function (y, n) { this._objects.preSubmit(n); this._objects.visibleObjects.forAll(p => p.renderable.material.submit(y, p)) }; u.queryShadowCasterDepthRange = function (y) { return this._objects.visibleObjects.length ? w.computeDepthRange(y, this._objects.visibleObjects) : null }; return q }(); a.RenderSubmitSystem = c; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/collections/Component/DepthRange": function () {
      define("exports ../../../../../core/PooledArray ../../../../../chunks/mat3 ../../../../../chunks/mat3f64 ../../../../../chunks/quat ../../../../../chunks/quatf64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/plane ../../../support/orientedBoundingBox ../../lib/depthRange".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(J, M, F) { return n.set(J, M.data[F + 0], M.data[F + 1], M.data[F + 2]) } function f(J, M) { J.push(M[0]); J.push(M[1]); J.push(M[2]) } function t(J, M, F, K) {
            u.conjugate(z, J.quaternion); n.sub(B, M, J.center); n.transformQuat(B, B, z); const P = 8 * ((B[0] < -J.halfSize[0] ? -1 : B[0] > J.halfSize[0] ? 1 : 0) + 3 * (B[1] < -J.halfSize[1] ? -1 : B[1] > J.halfSize[1] ? 1 : 0) + 9 * (B[2] < -J.halfSize[2] ? -1 : B[2] > J.halfSize[2] ? 1 : 0) + 13); M = r[P]; if (0 === M) return M; c.fromQuat(A, J.quaternion); c.scale(A, A, J.halfSize); const L = (N, G) => { G = r[P + G + 1]; n.set(N, ((G & 1) << 1) - 1, (G & 2) - 1, ((G & 4) >> 1) - 1); n.transformMat3(N, N, A); return n.add(N, J.center, N) }; F.length = 0; f(F, L(C, 0)); f(F, L(D, 1)); f(F, L(B, 2)); f(F, L(E, 3)); K(F); if (1 === M) return M; F.length = 0; f(F, C); f(F, E); f(F, L(B, 4)); f(F, L(H, 5)); K(F); if (2 === M) return M; F.length = 0; f(F, C); f(F, H); f(F, L(B, 6)); f(F, D); K(F); return M
          } const v = new w({ allocator: J => J || { near: Infinity, far: -Infinity, mask: 0, object: null }, deallocator: J => { J.object = null; return J } }), m = b.empty(), e = p.create(), g = p.create(), x = new w({ deallocator: null }),
            k = new w({ deallocator: null }), r = (() => {
              const J = new Int8Array(216); let M = 0; const F = K => { for (let P = 0; P < K.length; P++)J[M + P] = K[P]; M += 8 }; F([3, 0, 6, 2, 3, 1, 5, 4]); F([2, 0, 2, 3, 1, 5, 4, 0]); F([3, 1, 0, 2, 3, 7, 5, 4]); F([2, 0, 1, 3, 2, 6, 4, 0]); F([1, 0, 1, 3, 2, 0, 0, 0]); F([2, 1, 5, 7, 3, 2, 0, 0]); F([3, 2, 0, 1, 3, 7, 6, 4]); F([2, 2, 0, 1, 3, 7, 6, 0]); F([3, 3, 0, 1, 5, 7, 6, 2]); F([2, 0, 1, 5, 4, 6, 2, 0]); F([1, 0, 1, 5, 4, 0, 0, 0]); F([2, 1, 3, 7, 5, 4, 0, 0]); F([1, 0, 2, 6, 4, 0, 0, 0]); F([0, 0, 0, 0, 0, 0, 0, 0]); F([1, 1, 3, 7, 5, 0, 0, 0]); F([2, 2, 3, 7, 6, 4, 0, 0]); F([1, 2, 3, 7, 6, 0, 0, 0]); F([2, 3, 1, 5, 7, 6, 2,
                0]); F([3, 4, 0, 1, 5, 7, 6, 2]); F([2, 5, 7, 6, 4, 0, 1, 0]); F([3, 5, 0, 1, 3, 7, 6, 4]); F([2, 4, 5, 7, 6, 2, 0, 0]); F([1, 4, 5, 7, 6, 0, 0, 0]); F([2, 5, 1, 3, 7, 6, 4, 0]); F([3, 6, 0, 2, 3, 7, 5, 4]); F([2, 6, 2, 3, 7, 5, 4, 0]); F([3, 7, 6, 2, 3, 1, 5, 4]); return J
            })(), A = q.create(), z = y.create(), B = p.create(), C = p.create(), D = p.create(), E = p.create(), H = p.create(); a.computeDepthRange = function (J, M) {
              const F = b.empty(), { eye: K, frustum: P, viewForward: L } = J; M.forAll(N => {
                var G = N.obb; const I = n.dot(n.sub(B, G.center, K), L), O = h.projectedRadius(G, L); if (!b.within(F, I - O) || !b.within(F,
                  I + O)) { a: { var R = 0; for (let S = 0; 4 > S; S++) { const Q = h.intersectPlane(G, P[S]); if (0 < Q) { G = -1; break a } 0 === Q && (R |= 1 << S) } G = R } -1 !== G && (0 === G ? (m.far = I + O, m.near = I - O, b.union(F, m)) : (R = v.pushNew(), R.near = I - O, R.far = I + O, R.mask = G, R.object = N)) }
              }); for (J = 0; J < v.length; J++) {
                const N = v.data[J]; b.within(F, N.near) && b.within(F, N.far) || (m.far = N.far, m.near = Infinity, 0 === t(N.object.obb, K, x, G => {
                  var I = k; for (var O = 0; 4 > O && 0 < G.length; O++)if (0 !== (N.mask & 1 << O)) {
                    {
                      var R = P[O], S = G, Q = I; Q.length = 0; const T = S.length - 3; d(e, S, T); const da = l.signedDistance(R,
                        e); 0 >= da && (Q.push(e[0]), Q.push(e[1]), Q.push(e[2])); let Y = 0, fa = da; for (Y; Y < T; Y += 3) { d(g, S, Y); const ha = l.signedDistance(R, g); 0 > fa * ha && (n.lerp(e, g, e, ha / (ha - fa)), f(Q, e)); 0 >= ha && f(Q, g); fa = ha; n.copy(e, g) } 0 > fa * da && (d(g, S, T), n.lerp(e, g, e, da / (da - fa)), f(Q, e))
                    } R = G; G = I; I = R
                  } for (I = 0; I < G.length; I += 3)n.set(e, G.data[I + 0], G.data[I + 1], G.data[I + 2]), O = n.dot(n.sub(e, e, K), L), m.near = Math.min(m.near, O)
                }) && (m.near = 0), b.union(F, m))
              } v.length = 0; return F
            }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/depthRange": function () {
      define(["exports"],
        function (a) { function w(q, u) { return { near: q, far: u } } function c(q, u, y) { q.near = u; q.far = y; return q } a.ZERO = { near: 0, far: 0 }; a.create = w; a.empty = function (q) { return q ? c(q, Infinity, -Infinity) : w(Infinity, -Infinity) }; a.set = c; a.union = function (q, u, y = q) { y.near = Math.min(q.near, u.near); y.far = Math.max(q.far, u.far); return y }; a.within = function (q, u) { return q.near <= u && u <= q.far }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/collections/Component/SourceGeometry": function () {
      define(["exports",
        "../../../support/buffer/InterleavedLayout"], function (a, w) { a.createVertexBufferLayout = function (c) { const q = w.newLayout().vec3f("position"); c.normals && q.vec2i16("normalCompressed", { glNormalized: !0 }); 1 === c.textureCoordinates ? q.vec2f("uv0") : 2 === c.textureCoordinates && (q.vec2f("uv0"), q.vec4u16("uvRegion", { glNormalized: !0 })); c.colors && q.vec4u8("color", { glNormalized: !0 }); return q.alignTo(4) }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/collections/Component/Material/ComponentMaterial": function () {
      define("exports ../../../../../../chunks/_rollupPluginBabelHelpers ../../../../../../chunks/tslib.es6 ../../../../../../core/maybe ../../../../../../chunks/vec3 ../../../../../../chunks/vec3f32 ../../../../../../chunks/vec4 ../../../../../../chunks/vec4f32 ../../../../../../chunks/vec4f64 ./ComponentTechnique ../../../../../../chunks/ComponentShader.glsl ../../../core/material/MaterialBase ../../../core/shaderLibrary/util/AlphaDiscard.glsl".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(g) { switch (g) { case 0: return 0; case 1: return 7; case 2: return 1; case 3: return 2 } } let v = function (g) {
            function x() {
              var r = g.apply(this, arguments) || this; r.baseColor = p.fromValues(1, 1, 1, 1); r.usePBR = !1; r.hasParametersFromSource = !1; r.mrrFactors = y.fromValues(1, 1, .5); r.emissiveFactor = y.fromValues(0, 0, 0); r.baseColorTexture = null; r.metallicRoughnessTexture = null; r.emissionTexture = null; r.occlusionTexture = null; r.normalTexture = null; r.overlayTexOffset = l.fromValues(-1, -1, -1,
                -1); r.overlayTexScale = l.fromValues(0, 0, 0, 0); r.overlayColor = null; r.overlayHighlight = null; r.overlayNormal = null; r.objectOpacity = 1; r.commonMaterialParameters = new m; r.componentParameters = new e; r.alphaCutoff = f.defaultMaskAlphaCutoff; r.alphaDiscardMode = 1; r.isIntegratedMesh = !1; r.polygonOffsetEnabled = !1; r.ellipsoidMode = 1; r.sceneHasOcludees = !1; r._techniqueConfig = new h.ComponentTechniqueConfiguration; return r
            } w._inheritsLoose(x, g); var k = x.prototype; k.dispose = function () {
            this._technique = q.releaseMaybe(this._technique);
              this.normalTexture = this.occlusionTexture = this.emissionTexture = this.metallicRoughnessTexture = this.baseColorTexture = null
            }; k.getTechnique = function (r, A, z) {
              const B = this._techniqueConfig; B.hasVertexColors = z.colors; B.hasNormals = z.normals; B.vertexTextureCoordinates = z.textureCoordinates; B.usePBR = this.usePBR; B.hasMetalnessAndRoughnessTexture = q.isSome(this.metallicRoughnessTexture); B.hasEmissionTexture = q.isSome(this.emissionTexture); B.hasOcclusionTexture = q.isSome(this.occlusionTexture); B.hasNormalTexture = q.isSome(this.normalTexture);
              B.transparencyPassType = 0 === A.identifier && null != A.transparencyPassType ? A.transparencyPassType : 3; B.multipassTerrainEnabled = 0 === A.identifier && null != A.multipassTerrainParams ? A.multipassTerrainParams.multipassTerrainEnabled : !1; B.cullAboveGround = 0 === A.identifier && null != A.multipassTerrainParams ? A.multipassTerrainParams.cullAboveGround : !1; B.ellipsoidMode = this.ellipsoidMode; this.dirty && (B.componentData = this.componentParameters.type, B.cullFace = this.commonMaterialParameters.cullFace, B.doubleSidedMode = this.commonMaterialParameters.doubleSided ?
                1 : 0, B.baseColorTexture = q.isSome(this.baseColorTexture), B.isSchematic = this.hasParametersFromSource && !q.isSome(this.baseColorTexture), z = this._computeWhichMaterialPass(), B.blendingEnabled = 1 === z || 2 === z, B.alphaDiscardMode = this.alphaDiscardMode, B.integratedMeshMode = this.isIntegratedMesh ? this.overlayColor ? this.overlayNormal ? 3 : 2 : 1 : 0, B.polygonOffsetEnabled = this.polygonOffsetEnabled, this._setClean()); B.slicePlaneEnabled = A.slicePlaneEnabled && this.commonMaterialParameters.slicePlaneEnabled; 1 === A.identifier ? (B.output =
                  3, B.vertexDiscardMode = 0) : 2 === A.identifier ? (B.output = 4, B.vertexDiscardMode = 0) : (2 === this._computeWhichMaterialPass() ? B.vertexDiscardMode = A.transparent ? 2 : 1 : B.vertexDiscardMode = 0, B.output = t(A.subPass), 1 === A.subPass && (B.sceneHasOcludees = A.sceneHasOcludees), 0 === A.subPass ? (B.receiveAmbientOcclusion = A.ambientOcclusionEnabled, B.sceneHasOcludees = A.sceneHasOcludees, B.receiveShadows = A.shadowsEnabled, B.ssrEnabled = A.ssrParams.ssrEnabled) : (B.receiveAmbientOcclusion = !1, B.receiveShadows = !1)); return this._technique =
                    r.releaseAndAcquire(h.ComponentTechnique, B, this._technique)
            }; k.submit = function (r, A) {
              if (0 !== this.objectOpacity) {
                var z = A.renderable.geometry, B = A.components, C = A.renderable.drawParameters; A = A.renderable.meta.cameraDepthSquared; var D = B.geometryRanges, E = B.highlightRanges; B = B.defaultShadowMapRanges; switch (this._computeWhichMaterialPass()) {
                  case 0: r.materialOpaque.submitDraw(this, z, D, C, A); break; case 1: r.materialTransparent.submitDraw(this, z, D, C, A); break; case 2: r.materialOpaque.submitDraw(this, z, D, C, A); r.materialTransparent.submitDraw(this,
                    z, D, C, A); break; case 3: r.materialIntegratedMesh.submitDraw(this, z, D, C, A), this.overlayHighlight && r.highlightIntegratedMesh.submitDraw(this, z, D, C, A)
                }var H = 2 !== this.componentParameters.castShadows; H && r.shadowMap.submitDraw(this, z, D, C, A); q.isSome(E) && (r.highlight.submitDraw(this, z, E, C, A), H && r.highlightShadowMap.submitDraw(this, z, E, C, A)); H && q.isSome(B) && r.defaultShadowMap.submitDraw(this, z, B, C, A)
              }
            }; k._computeWhichMaterialPass = function () {
              return this.isIntegratedMesh ? 3 : 1 > this.objectOpacity ? 1 : 0 === this.componentParameters.opaqueOverride ?
                0 : 1 > this.baseColor[3] || 0 === this.alphaDiscardMode || 3 === this.alphaDiscardMode ? 1 : 2 === this.componentParameters.transparent ? 0 : 0 === this.componentParameters.transparent ? 1 : 2
            }; w._createClass(x, [{ key: "attributeLocations", get: function () { return b.attributeLocations } }]); return x
          }(d.MaterialBase); c.__decorate([d.parameter({ vectorOps: n.vec4 })], v.prototype, "baseColor", void 0); c.__decorate([d.parameter()], v.prototype, "usePBR", void 0); c.__decorate([d.parameter()], v.prototype, "hasParametersFromSource", void 0); c.__decorate([d.parameter({ vectorOps: u.vec3 })],
            v.prototype, "mrrFactors", void 0); c.__decorate([d.parameter({ vectorOps: u.vec3 })], v.prototype, "emissiveFactor", void 0); c.__decorate([d.parameter({ dispose: !0 })], v.prototype, "baseColorTexture", void 0); c.__decorate([d.parameter({ dispose: !0 })], v.prototype, "metallicRoughnessTexture", void 0); c.__decorate([d.parameter({ dispose: !0 })], v.prototype, "emissionTexture", void 0); c.__decorate([d.parameter({ dispose: !0 })], v.prototype, "occlusionTexture", void 0); c.__decorate([d.parameter({ dispose: !0 })], v.prototype, "normalTexture",
              void 0); c.__decorate([d.parameter({ vectorOps: { equals: n.exactEquals, copy: n.copy } })], v.prototype, "overlayTexOffset", void 0); c.__decorate([d.parameter({ vectorOps: { equals: n.exactEquals, copy: n.copy } })], v.prototype, "overlayTexScale", void 0); c.__decorate([d.parameter()], v.prototype, "overlayColor", void 0); c.__decorate([d.parameter()], v.prototype, "overlayHighlight", void 0); c.__decorate([d.parameter()], v.prototype, "overlayNormal", void 0); c.__decorate([d.parameter()], v.prototype, "objectOpacity", void 0); c.__decorate([d.parameterBlock()],
                v.prototype, "commonMaterialParameters", void 0); c.__decorate([d.parameterBlock()], v.prototype, "componentParameters", void 0); c.__decorate([d.parameter()], v.prototype, "alphaCutoff", void 0); c.__decorate([d.parameter()], v.prototype, "alphaDiscardMode", void 0); c.__decorate([d.parameter()], v.prototype, "isIntegratedMesh", void 0); c.__decorate([d.parameter()], v.prototype, "polygonOffsetEnabled", void 0); c.__decorate([d.parameter()], v.prototype, "ellipsoidMode", void 0); c.__decorate([d.parameter()], v.prototype, "sceneHasOcludees",
                  void 0); let m = function (g) { function x() { var k = g.apply(this, arguments) || this; k.doubleSided = !1; k.cullFace = 2; k.slicePlaneEnabled = !0; return k } w._inheritsLoose(x, g); return x }(d.MaterialParameterBlock); c.__decorate([d.parameter()], m.prototype, "doubleSided", void 0); c.__decorate([d.parameter()], m.prototype, "cullFace", void 0); c.__decorate([d.parameter()], m.prototype, "slicePlaneEnabled", void 0); let e = function (g) {
                    function x() {
                      var k = g.apply(this, arguments) || this; k.externalColor = p.fromValues(1, 1, 1, 1); k.externalColorMixMode =
                        1; k.castShadows = 0; return k
                    } w._inheritsLoose(x, g); w._createClass(x, [{ key: "transparent", get: function () { return 1 > this.externalColor[3] ? 0 : 2 } }, { key: "opaqueOverride", get: function () { return 3 === this.externalColorMixMode && 1 === this.externalColor[3] ? 0 : 2 } }, { key: "visible", get: function () { return 0 < this.externalColor[3] ? 0 : 2 } }, { key: "type", get: function () { return 0 } }]); return x
                  }(d.MaterialParameterBlock); c.__decorate([d.parameter({ vectorOps: n.vec4 })], e.prototype, "externalColor", void 0); c.__decorate([d.parameter()], e.prototype,
                    "externalColorMixMode", void 0); c.__decorate([d.parameter()], e.prototype, "castShadows", void 0); u = function (g) { function x() { var k = g.apply(this, arguments) || this; k.texture = null; k.transparent = 2; k.opaqueOverride = 2; k.castShadows = 2; return k } w._inheritsLoose(x, g); w._createClass(x, [{ key: "type", get: function () { return 1 } }]); return x }(d.MaterialParameterBlock); c.__decorate([d.parameter()], u.prototype, "texture", void 0); c.__decorate([d.parameter()], u.prototype, "transparent", void 0); c.__decorate([d.parameter()], u.prototype,
                      "opaqueOverride", void 0); c.__decorate([d.parameter()], u.prototype, "castShadows", void 0); a.CommonMaterialParameters = m; a.ComponentMaterial = v; a.ComponentParametersUniform = e; a.ComponentParametersVarying = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/collections/Component/Material/ComponentTechnique": function () {
      define("require exports ../../../../../../chunks/_rollupPluginBabelHelpers ../../../../../../chunks/tslib.es6 ../../../../../../core/maybe ../../../../../../chunks/mat3f64 ../../../../../../chunks/vec4f64 ../../../../../../chunks/ComponentShader.glsl ../../../core/shaderLibrary/Slice.glsl ../../../core/shaderLibrary/attributes/VertexPosition.glsl ../../../core/shaderLibrary/output/OutputHighlight.glsl ../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../../../core/shaderLibrary/shading/ScreenSpaceReflections.glsl ../../../core/shaderLibrary/util/DoublePrecision.glsl ../../../core/shaderTechnique/ReloadableShaderModule ../../../core/shaderTechnique/ShaderTechnique ../../../core/shaderTechnique/ShaderTechniqueConfiguration ../../../lib/OrderIndependentTransparency ../../../lib/Program ../../../lib/StencilUtils ../../../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r) {
          m = function (A) {
            function z() { return A.apply(this, arguments) || this } c._inheritsLoose(z, A); var B = z.prototype; B.bindPass = function (C) {
              const D = this.program; h.VertexPosition.bindViewProjTransform(D, C.viewTransform); l.bindSliceUniforms(this.program, this.configuration, C.slicePlane); 0 === C.identifier && (void 0 !== C.ssrParams && f.bindSSRUniforms(this.program, C.ssrParams), D.setUniformMatrix3fv("uTransformNormal_ViewFromGlobal", C.transformNormal_ViewFromGlobal), 2 ===
                C.subPass && D.setUniform2fv("cameraNearFar", C.cameraNearFar), 0 === C.subPass && C.lighting.setUniforms(this.program, C.integratedMesh)); 1 === C.identifier && this.program.setUniform2fv("cameraNearFar", C.cameraNearFar)
            }; B.bindMaterial = function (C, D) {
            this._material = C; const E = this.program; E.setUniform4fv("uBaseColor", C.baseColor); E.setUniform1f("uObjectOpacity", C.objectOpacity); E.setUniform1f("textureAlphaCutoff", C.alphaCutoff); 1 === C.componentParameters.type ? C.componentParameters.texture.bind(E, "uComponentColorTex",
              "uComponentColorTexInvDim") : (E.setUniform4fv("uExternalColor", C.componentParameters.externalColor), E.setUniform1i("uExternalColorMixMode", C.componentParameters.externalColorMixMode)); u.isSome(C.baseColorTexture) && C.baseColorTexture.bind(E, "uBaseColorTexture", "uBaseColorTextureSize"); if (0 === this.configuration.output || 7 === this.configuration.output) d.bindPBRUniforms(this.program, C, this.configuration.isSchematic), u.isSome(C.metallicRoughnessTexture) && C.metallicRoughnessTexture.bind(E, "texMetallicRoughness",
                "texMetallicRoughnessSize"), u.isSome(C.emissionTexture) && C.emissionTexture.bind(E, "texEmission", "texEmissionSize"), u.isSome(C.occlusionTexture) && C.occlusionTexture.bind(E, "texOcclusion", "texOcclusionSize"), u.isSome(C.normalTexture) && C.normalTexture.bind(E, "normalTexture", "normalTextureSize"); C.isIntegratedMesh && (0 === D.identifier && 0 === D.subPass ? (E.bindTexture(C.overlayColor, "ovColorTex"), E.bindTexture(C.overlayNormal, "ovNormalTex")) : 2 === D.identifier && E.bindTexture(C.overlayHighlight, "ovColorTex"),
                  E.setUniform1f("overlayOpacity", 1)); 2 === D.identifier && b.bindOutputHighlight(this.program, D); 0 === D.identifier && 0 === D.subPass && (D.ambientOcclusionEnabled && D.bindAmbientOcclusion(E), D.shadowsEnabled && D.bindShadowMap(E)); 0 !== D.identifier || 0 !== D.subPass && 1 !== D.subPass || !D.multipassTerrainParams.multipassTerrainEnabled || (this.program.setUniform2fv("cameraNearFar", D.cameraNearFar), E.setUniform2fv("inverseViewport", D.inverseViewport), D.multipassTerrainParams.terrainLinearDepthTexture && E.bindTexture(D.multipassTerrainParams.terrainLinearDepthTexture,
                    "terrainDepthTexture"))
            }; B.bindDraw = function (C) {
              h.VertexPosition.bindModelTransform(this.program, C); this.program.setUniformMatrix3fv("uTransformNormal_GlobalFromModel", C.transformNormal_GlobalFromModel); this.program.rebindTextures(); if (u.isSome(this._material) && this._material.isIntegratedMesh) {
                const D = this._material.overlayTexScale, E = this._material.overlayTexOffset; this.program.setUniform4fv("overlayTexOffset", [C.toMapSpace[0] * D[0] + E[0], C.toMapSpace[1] * D[1] + E[1], C.toMapSpace[0] * D[2] + E[2], C.toMapSpace[1] *
                  D[3] + E[3]]); this.program.setUniform4fv("overlayTexScale", [C.toMapSpace[2] * D[0], C.toMapSpace[3] * D[1], C.toMapSpace[2] * D[2], C.toMapSpace[3] * D[3]])
              }
            }; B.initializeProgram = function (C) {
              const D = z.shader.get(); var E = this.configuration; E = D.build({
                multipassTerrainEnabled: E.multipassTerrainEnabled, cullAboveGround: E.cullAboveGround, OITEnabled: 0 === E.transparencyPassType, output: E.output, normalType: 0 === E.integratedMeshMode ? E.hasNormals ? 1 : 3 : 2, attributeColor: E.hasVertexColors, attributeTextureCoordinates: E.vertexTextureCoordinates,
                componentData: E.componentData, alphaDiscardMode: E.alphaDiscardMode, baseColorTexture: E.baseColorTexture, doubleSidedMode: E.doubleSidedMode, receiveAmbientOcclusion: E.receiveAmbientOcclusion, receiveShadows: E.receiveShadows, slicePlaneEnabled: E.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !1, viewingMode: C.viewingMode, vertexDiscardMode: E.vertexDiscardMode, pbrMode: 3 === E.integratedMeshMode ? 4 : E.usePBR ? E.isSchematic ? 2 : 1 : 0, hasMetalnessAndRoughnessTexture: E.hasMetalnessAndRoughnessTexture,
                hasEmissionTexture: E.hasEmissionTexture, hasOcclusionTexture: E.hasOcclusionTexture, hasNormalTexture: E.hasNormalTexture, vertexTangents: !1, supportsTextureAtlas: !0, doublePrecisionRequiresObfuscation: t.doublePrecisionRequiresObfuscation(C.rctx), overlayEnabled: 2 === E.integratedMeshMode || 3 === E.integratedMeshMode, ssrEnabled: E.ssrEnabled, highStepCount: !1, ellipsoidMode: E.ellipsoidMode
              }); return new x.Program(C.rctx, E, D.attributeLocations)
            }; B.setPipelineState = function (C) {
              const D = this.configuration, E = 0 !== D.integratedMeshMode,
              H = 3 === C, J = 2 === C; return r.makePipelineState({
                blending: 0 !== D.output && 7 !== D.output || !D.blendingEnabled ? null : H ? g.blendingDefault : g.OITBlending(C), culling: r.cullingParams(D.cullFace), depthTest: { func: g.OITDepthTest(C) }, depthWrite: H || J ? r.defaultDepthWriteParams : null, colorWrite: r.defaultColorWriteParams, stencilWrite: E || D.sceneHasOcludees ? k.stencilWriteMaskOn : null, stencilTest: E ? k.replaceBitWhenDepthTestPasses(1) : D.sceneHasOcludees ? k.stencilBaseAllZerosParams : null, polygonOffset: H || J ? D.polygonOffsetEnabled ?
                  { factor: 2, units: 2 } : null : g.OITPolygonOffset
              })
            }; B.initializePipeline = function () { return this.setPipelineState(this.configuration.transparencyPassType) }; return z
          }(m.ShaderTechnique); m.shader = new v.ReloadableShaderModule(p.ComponentShader, () => new Promise((A, z) => a(["./shader/ComponentShader.glsl"], A, z))); p = function (A) { function z() { var B = A.apply(this, arguments) || this; B.transformNormal_GlobalFromModel = y.create(); B.toMapSpace = n.create(); return B } c._inheritsLoose(z, A); return z }(h.VertexPosition.ModelTransform);
          v = function (A) {
            function z() {
              var B = A.apply(this, arguments) || this; B.output = 0; B.hasVertexColors = !1; B.hasNormals = !1; B.vertexTextureCoordinates = 0; B.componentData = 0; B.slicePlaneEnabled = !1; B.cullFace = 2; B.baseColorTexture = !1; B.receiveAmbientOcclusion = !0; B.receiveShadows = !0; B.vertexDiscardMode = 0; B.doubleSidedMode = 2; B.blendingEnabled = !0; B.alphaDiscardMode = 1; B.integratedMeshMode = 0; B.ssrEnabled = !1; B.polygonOffsetEnabled = !1; B.usePBR = !1; B.isSchematic = !1; B.hasMetalnessAndRoughnessTexture = !1; B.hasEmissionTexture =
                !1; B.hasOcclusionTexture = !1; B.hasNormalTexture = !1; B.sceneHasOcludees = !1; B.transparencyPassType = 3; B.ellipsoidMode = 1; B.multipassTerrainEnabled = !1; B.cullAboveGround = !1; return B
            } c._inheritsLoose(z, A); return z
          }(e.ShaderTechniqueConfiguration); q.__decorate([e.parameter({ count: 8 })], v.prototype, "output", void 0); q.__decorate([e.parameter()], v.prototype, "hasVertexColors", void 0); q.__decorate([e.parameter()], v.prototype, "hasNormals", void 0); q.__decorate([e.parameter({ count: 3 })], v.prototype, "vertexTextureCoordinates",
            void 0); q.__decorate([e.parameter({ count: 2 })], v.prototype, "componentData", void 0); q.__decorate([e.parameter()], v.prototype, "slicePlaneEnabled", void 0); q.__decorate([e.parameter({ count: 3 })], v.prototype, "cullFace", void 0); q.__decorate([e.parameter()], v.prototype, "baseColorTexture", void 0); q.__decorate([e.parameter()], v.prototype, "receiveAmbientOcclusion", void 0); q.__decorate([e.parameter()], v.prototype, "receiveShadows", void 0); q.__decorate([e.parameter({ count: 3 })], v.prototype, "vertexDiscardMode", void 0);
          q.__decorate([e.parameter({ count: 3 })], v.prototype, "doubleSidedMode", void 0); q.__decorate([e.parameter()], v.prototype, "blendingEnabled", void 0); q.__decorate([e.parameter({ count: 4 })], v.prototype, "alphaDiscardMode", void 0); q.__decorate([e.parameter({ count: 4 })], v.prototype, "integratedMeshMode", void 0); q.__decorate([e.parameter()], v.prototype, "ssrEnabled", void 0); q.__decorate([e.parameter()], v.prototype, "polygonOffsetEnabled", void 0); q.__decorate([e.parameter()], v.prototype, "usePBR", void 0); q.__decorate([e.parameter()],
            v.prototype, "isSchematic", void 0); q.__decorate([e.parameter()], v.prototype, "hasMetalnessAndRoughnessTexture", void 0); q.__decorate([e.parameter()], v.prototype, "hasEmissionTexture", void 0); q.__decorate([e.parameter()], v.prototype, "hasOcclusionTexture", void 0); q.__decorate([e.parameter()], v.prototype, "hasNormalTexture", void 0); q.__decorate([e.parameter()], v.prototype, "sceneHasOcludees", void 0); q.__decorate([e.parameter({ count: 4 })], v.prototype, "transparencyPassType", void 0); q.__decorate([e.parameter({ count: 4 })],
              v.prototype, "ellipsoidMode", void 0); q.__decorate([e.parameter()], v.prototype, "multipassTerrainEnabled", void 0); q.__decorate([e.parameter()], v.prototype, "cullAboveGround", void 0); w.ComponentDrawParameters = p; w.ComponentTechnique = m; w.ComponentTechniqueConfiguration = v; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/ComponentShader.glsl": function () {
      define("exports ../geometry/support/Ellipsoid ../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl ../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl ../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl ../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          function D(J) {
            const M = new C.ShaderBuilder; M.include(h.VertexPosition, J); M.include(l.VertexNormal, J); M.include(p.VertexColor, J); M.include(n.TextureCoordinateAttribute, J); M.include(u.ForwardLinearDepth, J); M.include(c.ComponentData, J); M.include(z.DiscardOrAdjustAlpha, J); M.include(y.Slice, J); M.include(k.ReadBaseColorTexture, J); M.include(q.VertexDiscardByOpacity, J); M.fragment.uniforms.add("view", "mat4"); if (1 === J.pbrMode || 2 === J.pbrMode) M.include(x.PhysicallyBasedRenderingParameters,
              J), J.hasNormalTexture && M.include(v.ComputeNormalTexture, J); 3 === J.output && 1 === J.componentData ? M.vertex.code.add(B.glsl`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`) : M.vertex.code.add(B.glsl`#define discardShadows(castShadows) {}`); const F = J.overlayEnabled && 0 === J.output && 4 === J.pbrMode; J.overlayEnabled && (M.include(A.Overlay, J), 1 === J.viewingMode ? M.vertex.code.add(B.glsl`
      const float invEllipsoidRadius = ${B.glsl.float(1 / (1 === J.ellipsoidMode ? w.earth.radius : 2 === J.ellipsoidMode ? w.mars.radius : w.moon.radius))};
      vec2 projectOverlay(vec3 pos) {
        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);
      }
      `) : M.vertex.code.add(B.glsl`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)); F && (M.varyings.add("tbnTangent", "vec3"), M.varyings.add("tbnBiTangent", "vec3"), M.varyings.add("groundNormal", "vec3"), M.varyings.add("positionView", "vec3")); M.vertex.code.add(B.glsl`
    void main() {
      bool castShadows;
      vec4 externalColor = forwardExternalColor(castShadows);
      discardShadows(castShadows);

      vertexDiscardByOpacity(externalColor.a);

      if (externalColor.a < ${B.glsl.float(z.symbolAlphaCutoff)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }
      forwardPosition();
      forwardNormal();
      ${F ? B.glsl`
        positionView = position_view();
        ${1 === J.viewingMode ? B.glsl`
        groundNormal = normalize(positionWorld());
        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`: B.glsl`
        groundNormal = vec3(0.0, 0.0, 1.0);
        tbnTangent = vec3(1.0, 0.0, 0.0);
        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`}
        `: ""}

      ${J.overlayEnabled ? B.glsl`setOverlayVTC(projectOverlay(position));` : ""}
      forwardTextureCoordinates();
      forwardVertexColor();
      forwardLinearDepth(); // depends on forwardPosition()
    }
  `); 7 === J.output && (M.fragment.include(f.ReadLinearDepth), J.multipassTerrainEnabled && M.include(g.multipassTerrainTest, J), M.include(t.ComputeMaterialColor, J), M.fragment.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${J.multipassTerrainEnabled ? B.glsl`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : ""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${J.overlayEnabled ? B.glsl`
        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
        vec4 overlayColor = overlayOpacity * overlayColorOpaque;
        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`: ""}

        gl_FragColor = vec4(materialColor.a);
      }
    `)); 0 === J.output && (M.fragment.include(f.ReadLinearDepth), J.multipassTerrainEnabled && M.include(g.multipassTerrainTest, J), M.include(t.ComputeMaterialColor, J), M.include(m.ComputeShadingNormal, J), M.include(e.EvaluateSceneLighting, J), F && M.fragment.uniforms.add("ovNormalTex", "sampler2D"), J.receiveShadows ? (M.include(r.ReadShadowMap, J), M.fragment.code.add(B.glsl`float evaluateShadow() {
return readShadowMap(vPositionWorldCameraRelative, linearDepth);
}`)) : M.fragment.code.add(B.glsl`float evaluateShadow() { return 0.0; }`), M.fragment.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${J.multipassTerrainEnabled ? B.glsl`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : ""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${J.overlayEnabled ? B.glsl`
        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
        vec4 overlayColor = overlayOpacity * overlayColorOpaque;
        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`: ""}
    `), 1 === J.pbrMode || 2 === J.pbrMode ? (M.fragment.code.add(B.glsl`
        ${1 === J.pbrMode ? B.glsl`
        applyPBRFactors();
        if (int(externalColorMixMode) == 3) {
          mrr = vec3(0.0, 0.6, 0.2);
        }`: ""}
        vec3 normalVertex = shadingNormalWorld();
        float additionalIrradiance = 0.02 * lightingMainIntensity[2];
      `), J.hasNormalTexture ? M.fragment.code.add(B.glsl`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);
vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`) : M.fragment.code.add(B.glsl`vec3 shadingNormal = normalVertex;`), M.fragment.code.add(B.glsl`${1 === J.viewingMode ? B.glsl`vec3 normalGround = normalize(positionWorld());` : B.glsl`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}
      `), M.fragment.code.add(B.glsl`vec3 viewDir = normalize(vPositionWorldCameraRelative);
float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());
vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);`)) : (J.receiveShadows ? M.fragment.code.add(B.glsl`float shadow = evaluateShadow();`) : 1 === J.viewingMode ? M.fragment.code.add(B.glsl`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());
float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`) : M.fragment.code.add(B.glsl`float shadow = 0.0;`), M.fragment.code.add(B.glsl`
      float ambientOcclusion = evaluateAmbientOcclusion();
      // At global scale we create some additional ambient light based on the main light to simulate global illumination
      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());
      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);
      ${F ? B.glsl`
          vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
          float waterNormalLength = length(overlayWaterMask);
          if (waterNormalLength > 0.95) {
            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
            vec4 waterOverlayColor = vec4(overlayColorOpaque.xyz, overlayColor.w);
            vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, positionView);
            vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
            // un-gamma the ground color to mix in linear space
            shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
          }`: ""}
      `)), M.fragment.code.add(B.glsl`
        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);
        ${J.OITEnabled ? "gl_FragColor \x3d premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)); if (1 === J.output || 3 === J.output) M.include(b.OutputDepth, J), M.fragment.code.add(B.glsl`void main() {
discardBySlice(vPositionWorldCameraRelative);
vec4 textureColor = readBaseColorTexture();
discardOrAdjustAlpha(textureColor);
outputDepth(linearDepth);
}`); 2 === J.output && (M.include(m.ComputeShadingNormal, J), M.fragment.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        // note: the alpha component needs to be 1.0 in order for this material
        // to influence ambient occlusion, see the ssao fragment shader
        float alpha = ${2 === J.normalType ? "0.0" : "1.0"};
        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);
      }
    `)); 4 === J.output && (M.include(d.OutputHighlight), M.fragment.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${J.overlayEnabled ? B.glsl`
        vec4 overlayColor = getCombinedOverlayColor();

        if (overlayColor.a == 0.0) {
          gl_FragColor = vec4(0.0);
          return;
        }`: ""}

        outputHighlight();
      }
    `)); return M
          } const E = new Map([["position", 0], ["normal", 1], ["normalCompressed", 1], ["color", 2], ["uv0", 3], ["uvRegion", 4], ["componentIndex", 5]]), H = Object.freeze({ __proto__: null, attributeLocations: E, build: D }); a.ComponentShader = H; a.attributeLocations = E; a.build = D
        })
    }, "esri/views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl": function () {
      define(["exports", "./DecodeSymbolColor.glsl", "../../../../core/shaderModules/interfaces"], function (a, w, c) {
      a.ComponentData = function (q, u) {
      1 ===
        u.componentData && (q.vertex.uniforms.add("uComponentColorTex", "sampler2D"), q.vertex.uniforms.add("uComponentColorTexInvDim", "vec2"), q.attributes.add("componentIndex", "float"), q.varyings.add("vExternalColorMixMode", "mediump float"), q.varyings.add("vExternalColor", "vec4"), q.include(w.DecodeSymbolColor), q.vertex.code.add(c.glsl`vec4 _readComponentColor() {
float normalizedIndex = (componentIndex + 0.5) * uComponentColorTexInvDim.x;
vec2 indexCoord = vec2(
mod(normalizedIndex, 1.0),
(floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y
);
return texture2D(uComponentColorTex, indexCoord);
}
vec4 forwardExternalColor(out bool castShadows) {
vec4 componentColor = _readComponentColor() * 255.0;
float shadowFlag = mod(componentColor.b * 255.0, 2.0);
componentColor.b -= shadowFlag;
castShadows = shadowFlag >= 1.0;
int decodedColorMixMode;
vExternalColor = decodeSymbolColor(componentColor, decodedColorMixMode) * 0.003921568627451;
vExternalColorMixMode = float(decodedColorMixMode) + 0.5;
return vExternalColor;
}`), q.fragment.code.add(c.glsl`void readExternalColor(out vec4 externalColor, out int externalColorMixMode) {
externalColor = vExternalColor;
externalColorMixMode = int(vExternalColorMixMode);
}`)); 0 === u.componentData && (q.vertex.uniforms.add("uExternalColor", "vec4"), q.fragment.uniforms.add("uExternalColorMixMode", "int"), q.varyings.add("vExternalColor", "vec4"), q.vertex.code.add(c.glsl`vec4 forwardExternalColor(out bool castShadows) {
vExternalColor = uExternalColor;
castShadows = true;
return uExternalColor;
}`), q.fragment.code.add(c.glsl`void readExternalColor(out vec4 externalColor, out int externalColorMixMode) {
externalColor = vExternalColor;
externalColorMixMode = uExternalColorMixMode;
}`))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl": function () {
      define(["exports", "../../../../core/shaderModules/interfaces"], function (a, w) {
      a.VertexDiscardByOpacity = function (c, q) {
        c = c.vertex; c.code.add(w.glsl`#define VERTEX_DISCARD_CUTOFF (1.0 - 1.0 / 255.0)`); switch (q.vertexDiscardMode) {
          case 0: c.code.add(w.glsl`#define vertexDiscardByOpacity(_opacity_) {}`); break; case 2: c.code.add(w.glsl`#define vertexDiscardByOpacity(_opacity_) { if (_opacity_ >  VERTEX_DISCARD_CUTOFF) {  gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`);
            break; case 1: c.code.add(w.glsl`#define vertexDiscardByOpacity(_opacity_) { if (_opacity_ <= VERTEX_DISCARD_CUTOFF) {  gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`)
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl": function () {
      define(["exports", "../attributes/VertexColor.glsl", "../util/MixExternalColor.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
      a.ComputeMaterialColor = function (u, y) {
        u.include(w.VertexColor,
          y); u.fragment.include(c.MixExternalColor); u = u.fragment; u.uniforms.add("uBaseColor", "vec4"); u.uniforms.add("uObjectOpacity", "float"); y.attributeColor ? u.code.add(q.glsl`vec3 _baseColor() {
return uBaseColor.rgb * vColor.rgb;
}
float _baseOpacity() {
return uBaseColor.a * vColor.a;
}`) : u.code.add(q.glsl`vec3 _baseColor() {
return uBaseColor.rgb;
}
float _baseOpacity() {
return uBaseColor.a;
}`); u.code.add(q.glsl`vec4 computeMaterialColor(vec4 textureColor, vec4 externalColor, int externalColorMixMode) {
vec3 baseColor = _baseColor();
float baseOpacity = _baseOpacity();
vec3 color = mixExternalColor(
baseColor,
textureColor.rgb,
externalColor.rgb,
externalColorMixMode
);
float opacity = uObjectOpacity * mixExternalOpacity(
baseOpacity,
textureColor.a,
externalColor.a,
externalColorMixMode
);
return vec4(color, opacity);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl": function () {
      define(["exports", "../attributes/VertexNormal.glsl", "../attributes/VertexPosition.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
      a.ComputeShadingNormal = function (u, y) {
        const n = u.fragment; 0 === y.doubleSidedMode ? n.code.add(q.glsl`vec3 _adjustDoublesided(vec3 normal) {
return normal;
}`) : 1 === y.doubleSidedMode ? (u.include(c.VertexPosition, y), n.uniforms.add("uTransform_ViewFromCameraLocal_T", "vec3"), n.code.add(q.glsl`vec3 _adjustDoublesided(vec3 normal) {
vec3 viewDir = vPositionWorldCameraRelative + uTransform_ViewFromCameraLocal_T;
return dot(normal, viewDir) > 0.0 ? -normal : normal;
}`)) : 2 === y.doubleSidedMode && n.code.add(q.glsl`vec3 _adjustDoublesided(vec3 normal) {
return gl_FrontFacing ? normal : -normal;
}`); 0 === y.normalType || 1 === y.normalType ? (u.include(w.VertexNormal, y), n.code.add(q.glsl`vec3 shadingNormalWorld() {
return _adjustDoublesided(normalize(vNormalWorld));
}
vec3 shadingNormal_view() {
vec3 normal = normalize(vNormalView);
return gl_FrontFacing ? normal : -normal;
}`)) : 3 === y.normalType ? (u.extensions.add("GL_OES_standard_derivatives"), u.include(c.VertexPosition, y), n.code.add(q.glsl`vec3 shadingNormalWorld() {
return normalize(cross(
dFdx(vPositionWorldCameraRelative),
dFdy(vPositionWorldCameraRelative)
));
}
vec3 shadingNormal_view() {
return normalize(cross(dFdx(vPosition_view),dFdy(vPosition_view)));
}`)) : 2 === y.normalType && (1 === y.viewingMode ? (u.include(c.VertexPosition, y), n.code.add(q.glsl`vec3 shadingNormalWorld() {
return normalize(positionWorld());
}`)) : 2 === y.viewingMode && n.code.add(q.glsl`vec3 shadingNormalWorld() {
return vec3(0.0, 0.0, 1.0);
}`), u.extensions.add("GL_OES_standard_derivatives"), n.code.add(q.glsl`vec3 shadingNormal_view() {
return normalize(cross(dFdx(vPosition_view),dFdy(vPosition_view))).xyz;
}`))
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl": function () {
      define(["exports", "../attributes/VertexTextureCoordinates.glsl", "../util/TextureAtlasLookup.glsl", "../../shaderModules/interfaces"], function (a, w, c, q) {
      a.ReadBaseColorTexture = function (u, y) {
        const n = u.fragment; y.baseColorTexture ? (u.include(w.VertexTextureCoordinates, y), n.uniforms.add("uBaseColorTexture", "sampler2D"), n.uniforms.add("uBaseColorTextureSize",
          "vec2"), 2 === y.attributeTextureCoordinates ? (u.include(c.TextureAtlasLookup), n.code.add(q.glsl`vec4 readBaseColorTexture() {
return textureAtlasLookup(
uBaseColorTexture,
uBaseColorTextureSize,
vuv0,
vuvRegion
);
}`)) : n.code.add(q.glsl`vec4 readBaseColorTexture() {
return texture2D(uBaseColorTexture, vuv0);
}`)) : n.code.add(q.glsl`vec4 readBaseColorTexture() { return vec4(1.0); }`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/material/MaterialBase": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function u() { this._dirty = !0 } var y = u.prototype; y._setDirty = function () { this._dirty = !0 }; y._setClean = function () { this._dirty = !1; if (null != this._parameterBlocks) for (const n of this._parameterBlocks) this[n]._setClean() };
          y._checkParameterBlocksDirty = function () { if (null == this._parameterBlocks) return !1; for (const n of this._parameterBlocks) if (this[n].dirty) return !0; return !1 }; w._createClass(u, [{ key: "dirty", get: function () { return this._dirty || this._checkParameterBlocksDirty() } }]); return u
        }(), q = function () { function u() { this._dirty = !0 } var y = u.prototype; y._setDirty = function () { this._dirty = !0 }; y._setClean = function () { this._dirty = !1 }; w._createClass(u, [{ key: "dirty", get: function () { return this._dirty } }]); return u }(); a.MaterialBase =
          c; a.MaterialParameterBlock = q; a.parameter = function (u = {}) { return (y, n) => { var p; const l = null != (p = y._parameterCount) ? p : 0; y._parameterCount = l + 1; if (u.vectorOps) { const h = u.vectorOps; Object.defineProperty(y, n, { get() { return this[l] }, set(b) { const d = this[l]; if (null == d) this[l] = b; else { if (h.equals(d, b)) return; h.copy(d, b) } this._setDirty() } }) } else Object.defineProperty(y, n, { get() { return this[l] }, set(h) { this[l] !== h && (u.dispose && this[l] && this[l].dispose(), this[l] = h, this._setDirty()) } }) } }; a.parameterBlock = function () {
            return (u,
              y) => { var n; const p = null != (n = u._parameterCount) ? n : 0; u._parameterCount = p + 1; u._parameterBlocks = u._parameterBlocks || []; u._parameterBlocks.push(p); Object.defineProperty(u, y, { get() { return this[p] }, set(l) { this[p] !== l && (this[p] = l, this._setDirty()) } }) }
          }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/util/TwoVectorPosition": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../chunks/vec3", "../../../../../chunks/vec3f32", "../../../../../chunks/vec3f64"],
        function (a, w, c, q, u) {
          let y = function () { function p(h) { this._low = q.create(); this._high = q.create(); h && this.set(h) } var l = p.prototype; l.set = function (h) { const b = this._low, d = this._high; c.copy(b, h); c.sub(d, h, b) }; l.setElements = function (h, b, d) { c.set(n, h, b, d); this.set(n) }; l.get = function (h) { return c.add(h, this._low, this._high) }; l.getLowScaled = function (h) { return c.scale(h, this._low, 1) }; w._createClass(p, [{ key: "low", get: function () { return this._low } }, { key: "high", get: function () { return this._high } }]); return p }(); const n =
            u.create(); a.TwoVectorPosition = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/TextureBackedBuffer/BufferManager": function () {
      define(["exports", "./ManagedTextureBackedBuffer"], function (a, w) {
        let c = function () {
          function q(y, n = 1) { this.rctx = y; this.fieldCount = n; this.buffers = [] } var u = q.prototype; u.garbageCollect = function () { this.buffers = this.buffers.filter(y => 0 === y.activeCount ? (y.dispose(), !1) : !0) }; u.destroy = function () {
            this.buffers.forEach(y => y.dispose()); this.buffers =
              []
          }; u.getBuffer = function (y) { for (const n of this.buffers) if (n.availableCount >= y) return n; if (y > w.MAX_INDEX_COUNT) return null; y = new w.ManagedTextureBackedBuffer(this.rctx, this.fieldCount); this.buffers.push(y); return y }; u.updateTextures = function () { for (const y of this.buffers) y.textureBuffer.updateTexture() }; return q
        }(); a.BufferManager = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/TextureBackedBuffer/ManagedTextureBackedBuffer": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers",
        "./SimpleIndexManager", "./TextureBackedBuffer"], function (a, w, c, q) {
          let u = function () {
            function y(p, l = 1) { this.textureBuffer = new q.TextureBackedBuffer(p, l); this.indexManager = new c.SimpleIndexManager(65536) } var n = y.prototype; n.dispose = function () { this.textureBuffer.dispose(); this.textureBuffer = void 0 }; n.acquireIndex = function () { const p = this.indexManager.acquire(); this.textureBuffer.resizeToFit(p); return p }; n.releaseIndex = function (p) { this.indexManager.release(p) }; w._createClass(y, [{ key: "availableCount", get: function () { return this.indexManager.availableCount } },
            { key: "activeCount", get: function () { return this.indexManager.activeCount } }]); return y
          }(); a.MAX_INDEX_COUNT = 65536; a.ManagedTextureBackedBuffer = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/TextureBackedBuffer/SimpleIndexManager": function () {
      define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        let c = function () {
          function q(y) { this.maxCount = y; this._nextIndex = 0; this.recycledIndices = [] } var u = q.prototype; u.acquire = function () {
            if (0 < this.recycledIndices.length) return this.recycledIndices.pop();
            if (this.availableCount) return this._nextIndex++
          }; u.release = function (y) { this.recycledIndices.push(y) }; w._createClass(q, [{ key: "activeCount", get: function () { return this._nextIndex - this.recycledIndices.length } }, { key: "availableCount", get: function () { return this.recycledIndices.length + this.maxCount - this._nextIndex } }]); return q
        }(); a.SimpleIndexManager = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/TextureBackedBuffer/TextureBackedBuffer": function () {
      define(["exports",
        "../../../../../geometry/support/buffer/BufferView", "../../../../webgl/Texture"], function (a, w, c) {
          let q = function () {
            function u(n, p = 1) { this.rctx = n; this.fieldCount = p; this.textureWidth = 4096; this.dirty = !0; this.texture = new c(this.rctx, { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, wrapMode: 33071, width: this.textureWidth, height: 1, flipped: !1 }); this.data = new w.BufferViewVec4u8(new ArrayBuffer(4 * this.textureWidth)) } var y = u.prototype; y.dispose = function () {
              this.texture.dispose(); this.data = this.texture =
                void 0
            }; y.setData = function (n, p, l, h, b, d) { n = n * this.fieldCount + p; this.dirty = !0; this.data.set(n, 0, l); this.data.set(n, 1, h); this.data.set(n, 2, b); this.data.set(n, 3, d) }; y.setDataElement = function (n, p, l, h) { n = n * this.fieldCount + p; this.dirty = !0; this.data.set(n, l, h) }; y.resizeToFit = function (n) { n *= this.fieldCount; n >= this.data.count && (n = new w.BufferViewVec4u8(new ArrayBuffer(Math.ceil((n + 1) / this.textureWidth) * this.textureWidth * 4)), n.typedBuffer.set(this.data.typedBuffer), this.data = n) }; y.updateTexture = function () {
              if (this.dirty) {
                var n =
                  this.texture.descriptor.width; this.data.count > n * this.texture.descriptor.height && this.texture.resize(n, this.data.count / n); this.texture.setData(this.data.typedBuffer); this.dirty = !1
              }
            }; y.bind = function (n, p, l) { n.bindTexture(this.texture, p); n.setUniform2f(l, 1 / this.texture.descriptor.width, 1 / this.texture.descriptor.height) }; return u
          }(); a.TextureBackedBuffer = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/CompositingHelper": function () {
      define(["../../../../core/maybe",
        "./glUtil3D", "../shaders/CompositingTechnique", "../../../webgl/Util"], function (a, w, c, q) {
          let u = function () {
            function n(l, h) { this._rctx = l; this._techniqueRepository = h } var p = n.prototype; p.dispose = function () { this._vao = a.disposeMaybe(this._vao) }; p.compositeTransparent = function (l, h, b, d = 1) {
              const f = this._rctx; y.alphaMode = 1; y.function = 2; y.hasOpacityFactor = 1 !== d; d = this._techniqueRepository.acquire(c.CompositingTechnique, y); f.useProgram(d.program); d.bindPipelineState(f); d.program.bindTexture(l, "colorTexture");
              d.program.bindTexture(h, "alphaTexture"); d.program.bindTexture(b, "frontFaceTexture"); l = this.ensureVAO(); f.bindVAO(l); f.drawArrays(5, 0, q.vertexCount(l, "geometry")); d.release()
            }; p.composite = function (l, h = 0, b = 1, d = 0, f = 0) {
              const t = this._rctx; y.alphaMode = h; y.function = d; y.hasOpacityFactor = 1 !== b; h = this._techniqueRepository.acquire(c.CompositingTechnique, y); t.useProgram(h.program); h.bindPipelineState(t); h.program.bindTexture(l, "tex"); y.hasOpacityFactor && h.program.setUniform1f("opacity", b); 3 === d && h.program.setUniform1i("overlayIdx",
                f); l = this.ensureVAO(); t.bindVAO(l); t.drawArrays(5, 0, q.vertexCount(l, "geometry")); h.release()
            }; p.ensureVAO = function () { a.isNone(this._vao) && (this._vao = w.createQuadVAO(this._rctx)); return this._vao }; return n
          }(); const y = new c.CompositingTechniqueConfiguration; return u
        })
    }, "esri/views/3d/webgl-engine/shaders/CompositingTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/Program ../../../../chunks/Compositing.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          y = function (d) {
            function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build(this.configuration); return new l.Program(v.rctx, m, p.Default3D) }; t.initializePipeline = function () {
              if (1 === this.configuration.function) return b.makePipelineState({ colorWrite: { r: !1, g: !0, b: !1, a: !1 } }); switch (this.configuration.alphaMode) {
                case 0: return b.makePipelineState({ colorWrite: b.defaultColorWriteParams });
                case 1: return b.makePipelineState({ blending: b.separateBlendingParams(770, 1, 771, 771), colorWrite: b.defaultColorWriteParams }); default: return b.makePipelineState({ blending: b.simpleBlendingParams(1, 771), colorWrite: b.defaultColorWriteParams })
              }
            }; return f
          }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(h.CompositingShader, () => new Promise((d, f) => a(["./Compositing.glsl"], d, f))); u = function (d) {
            function f() { var t = d.apply(this, arguments) || this; t.function = 0; t.alphaMode = 0; t.hasOpacityFactor = !1; return t }
            c._inheritsLoose(f, d); return f
          }(n.ShaderTechniqueConfiguration); q.__decorate([n.parameter({ count: 4 })], u.prototype, "function", void 0); q.__decorate([n.parameter({ count: 3 })], u.prototype, "alphaMode", void 0); q.__decorate([n.parameter()], u.prototype, "hasOpacityFactor", void 0); w.CompositingTechnique = y; w.CompositingTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/Compositing.glsl": function () {
      define(["exports", "../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass",
        "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c, q) {
          function u(n) {
            const p = new q.ShaderBuilder; p.include(w.ScreenSpacePass); p.fragment.uniforms.add("tex", "sampler2D"); 0 === n.function && (n.hasOpacityFactor ? (p.fragment.uniforms.add("opacity", "float"), p.fragment.code.add(c.glsl`void main() {
gl_FragColor = texture2D(tex, uv) * opacity;
}`)) : p.fragment.code.add(c.glsl`void main() {
gl_FragColor = texture2D(tex, uv);
}`)); 3 === n.function && (p.fragment.uniforms.add("overlayIdx", "int"), n.hasOpacityFactor && p.fragment.uniforms.add("opacity", "float"), p.fragment.code.add(c.glsl`
      void main() {
        vec2 overlayUV = overlayIdx == 0 ? vec2(uv.x * 0.5, uv.y) : vec2(uv.x * 0.5+ 0.5, uv.y);
        gl_FragColor = texture2D(tex, overlayUV) ${n.hasOpacityFactor ? "* opacity" : ""};
      }`)); 1 === n.function && p.fragment.code.add(c.glsl`void main() {
gl_FragColor = vec4(1.0 - texture2D(tex, uv).a);
}`); 2 === n.function && (p.fragment.uniforms.add("colorTexture", "sampler2D"), p.fragment.uniforms.add("alphaTexture", "sampler2D"), p.fragment.uniforms.add("frontFaceTexture", "sampler2D"), p.fragment.code.add(c.glsl`void main() {
vec4 srcColor = texture2D(colorTexture, uv);
float srcAlpha = texture2D(alphaTexture, uv).r;
vec4 frontFace = texture2D(frontFaceTexture, uv);
if(srcColor.a <= 1e-5){
discard;
}
gl_FragColor = vec4(mix(srcColor.rgb/srcColor.a, frontFace.rgb, frontFace.a), 1.0 - srcAlpha);
}`)); return p
          } const y = Object.freeze({ __proto__: null, build: u }); a.CompositingShader = y; a.build = u
        })
    }, "esri/views/3d/webgl-engine/lib/depthRangeUtils": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/floatRGBA ../../../../core/maybe ../../../../core/PooledArray ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ../../../../geometry/support/frustum ../../../../chunks/sphere ../../support/mathUtils ./depthRange ./Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(K, P) { if (P.isVisible) { var L = t.empty(), N = P.getSpatialQueryAccelerator(); q.isSome(N) ? e(L, K, N) : g(L, K, P.objects); return L } } function e(K, P, L) {
            var N = P.eye; const G = P.viewForward, I = P.frustum, O = S => S.isVisible; var R = L.objectCount; 500 > R ? (t.set(H, P.near, Math.min(K.near, P.far)), L.forEachInDepthRange(N, G, 1, H, (S, Q) => { x(K, P, S); H.far = K.near; Q.setRange(H) }, I, O), t.set(H, Math.max(K.far, P.near), P.far), L.forEachInDepthRange(N, G, -1, H, (S, Q) => { x(K, P, S); H.near = K.far; Q.setRange(H) },
              I, O)) : (R = Math.max(Math.min(R, 500), Math.ceil(.1 * R)), N = L.findClosest(G, 1, I, O, R), L = L.findClosest(G, -1, I, O, R), N && L && (r(K, P, N.boundingVolumeWorldSpace.bounds), r(K, P, L.boundingVolumeWorldSpace.bounds)))
          } function g(K, P, L) {
            J.clear(); L.forAll(N => { N.isVisible && 0 !== N.geometryRecords.length && J.add(N) }); J.empty || (J.sort(P), t.set(H, P.near, Math.min(K.near, P.far)), J.forEachInDepthRange(H, 1, (N, G) => { G < K.near && x(K, P, N) }), t.set(H, Math.max(K.far, P.near), P.far), J.forEachInDepthRange(H, -1, (N, G, I) => {
            K.far = Math.max(K.far,
              I)
            }))
          } function x(K, P, L) { if (L.isVisible && b.intersectsSphere(P.frustum, L.boundingVolumeWorldSpace.bounds)) { var N = L.transformation, G = E; L.geometryRecords.forEach(I => { y.multiply(G, N, I.getShaderTransformation()); const O = f.maxScale(G); k(K, P, I.geometry.boundingInfo, G, O) }) } } function k(K, P, L, N, G) {
            if (!q.isNone(L)) {
              var I = P.eye, O = P.viewForward; p.transformMat4(D, L.center, N); I = O[0] * (D[0] - I[0]) + O[1] * (D[1] - I[1]) + O[2] * (D[2] - I[2]); D[3] = L.radius * G; if (!(I - D[3] > K.near && I + D[3] < K.far) && b.intersectsSphere(P.frustum, D)) if (100 <
                L.radius && L.getChildren()) for (L = L.getChildren(), I = 0; 8 > I; ++I)L[I] && k(K, P, L[I], N, G); else F.unionDepthRangeWithAABB(K, P.viewProjectionMatrix, N, L.bbMin, L.bbMax)
            }
          } function r(K, P, L) { var N = P.eye; P = P.viewForward; N = (L[0] - N[0]) * P[0] + (L[1] - N[1]) * P[1] + (L[2] - N[2]) * P[2]; K.near = Math.min(K.near, N - L[3]); K.far = Math.max(K.far, N + L[3]) } let A = function () {
            function K() { this._items = new u({ allocator: L => L || { obj: null, distance: 0, near: 0, far: 0 }, deallocator: L => { L.obj = null; L.distance = 0; L.near = 0; L.far = 0; return L } }) } var P = K.prototype;
            P.clear = function () { this._items.clear() }; P.add = function (L) { this._items.pushNew().obj = L }; P.sort = function (L) { const N = L.eye, G = L.viewForward; this._items.forAll(I => { const O = I.obj.boundingVolumeWorldSpace.bounds, R = (O[0] - N[0]) * G[0] + (O[1] - N[1]) * G[1] + (O[2] - N[2]) * G[2]; I.distance = R; I.near = R - O[3]; I.far = R + O[3] }); this._items.sort((I, O) => I.distance - O.distance) }; P.forEachInDepthRange = function (L, N, G) {
              if (1 === N) for (N = 0; N < this._items.length; ++N) { var I = this._items.data[N]; I.far < L.near || I.near > L.far || G(I.obj, I.near, I.far) } else for (N =
                this._items.length - 1; 0 <= N; --N)I = this._items.data[N], I.far < L.near || I.near > L.far || G(I.obj, I.near, I.far)
            }; w._createClass(K, [{ key: "length", get: function () { return this._items.length } }, { key: "empty", get: function () { return 0 === this._items.length } }]); return K
          }(), z = function () {
            function K() { this.view = n.create(); this.viewProj = n.create(); this.frustum = b.create(); this.geometries = []; this.near = []; this.far = []; this.nearCandidates = []; this.farCandidates = []; this.range = { near: 0, far: 0 }; this.looseRange = { near: 0, far: 0 } } var P = K.prototype;
            P.compute = function (L, N) {
              this.reset(); y.copy(this.view, L.viewMatrix); y.multiply(this.viewProj, L.projectionMatrix, this.view); b.copy(L.frustum, this.frustum); L = this.view; const G = L[2], I = L[6], O = L[10], R = L[14]; L = this.range; let S = 0; N.forEach(da => {
                if (da.instanceParameters.visible && da.castShadow) {
                  if (da.hasShaderTransformation) { da.computeBoundingSphere(da.getShaderTransformation(), D, 1); var Y = D } else Y = da.boundingSphere; var fa = G * Y[0] + I * Y[1] + O * Y[2] + R, ha = fa - Y[3]; Y = fa + Y[3]; this.geometries[S] = da; this.near[S] = -Y; this.far[S] =
                    -ha; ++S
                }
              }); if (0 === this.geometries.length) return L; for (N = 0; N < this.geometries.length; ++N)this.near[N] > L.far && (L.far = this.near[N]), 2 < this.near[N] && this.far[N] < L.near && (L.near = this.far[N]); N = this.looseRange; N.near = Math.max(.5 * L.near, 2); N.far = 2 * L.far; var Q = 0; let T = 0; for (let da = 0; da < this.geometries.length; ++da)this.near[da] < L.near && (this.near[da] >= N.near ? L.near = this.near[da] : this.nearCandidates[Q++] = da), this.far[da] > L.far && (this.far[da] <= N.far ? L.far = this.far[da] : this.farCandidates[T++] = da); if (0 === this.nearCandidates.length &&
                0 === this.farCandidates.length) return L; this.nearCandidates.sort((da, Y) => this.near[da] < this.near[Y] ? -1 : this.near[da] > this.near[Y] ? 1 : 0); this.farCandidates.sort((da, Y) => this.far[da] < this.far[Y] ? 1 : this.far[da] > this.far[Y] ? -1 : 0); for (N = 0; N < this.nearCandidates.length; ++N)Q = this.nearCandidates[N], this.near[Q] < L.near && (Q = this.geometries[Q], this.includeNearBoundingInfoRec(Q.boundingInfo, Q.getShaderTransformation())); for (N = 0; N < this.farCandidates.length; ++N)Q = this.farCandidates[N], this.far[Q] > L.far && (Q = this.geometries[Q],
                  this.includeFarBoundingInfoRec(Q.boundingInfo, Q.getShaderTransformation())); return L
            }; P.reset = function () { this.geometries.length = 0; this.near.length = 0; this.far.length = 0; this.nearCandidates.length = 0; this.farCandidates.length = 0; this.range.near = Number.MAX_VALUE; this.range.far = -Number.MAX_VALUE }; P.includeNearBoundingInfoRec = function (L, N) {
              if (!q.isNone(L)) {
                var G = L.getCenter(); p.transformMat4(D, G, N); G = f.maxScale(N); var I = D[0], O = D[1], R = D[2]; G *= L.getBSRadius(); var S = this.frustum; if (!(S[0][0] * I + S[0][1] * O + S[0][2] *
                  R + S[0][3] > G || S[1][0] * I + S[1][1] * O + S[1][2] * R + S[1][3] > G || S[2][0] * I + S[2][1] * O + S[2][2] * R + S[2][3] > G || S[3][0] * I + S[3][1] * O + S[3][2] * R + S[3][3] > G || (I = this.view[2] * I + this.view[6] * O + this.view[10] * R + this.view[14], O = I + G, 2 > -(I - G) || -O >= this.range.near))) if (-O > this.looseRange.near) this.range.near = -O; else { if (100 < G && (G = L.getChildren(), void 0 !== G)) { for (L = 0; 8 > L; ++L)void 0 !== G[L] && this.includeNearBoundingInfoRec(G[L], N); return } F.unionDepthRangeWithAABB(this.range, this.viewProj, N, L.getBBMin(), L.getBBMax()) }
              }
            }; P.includeFarBoundingInfoRec =
              function (L, N) {
                if (!q.isNone(L)) {
                  var G = L.getBSRadius(), I = L.getCenter(); p.transformMat4(D, I, N); var O = f.maxScale(N); I = D[0]; var R = D[1], S = D[2]; G *= O; O = this.frustum; if (!(O[0][0] * I + O[0][1] * R + O[0][2] * S + O[0][3] > G || O[1][0] * I + O[1][1] * R + O[1][2] * S + O[1][3] > G || O[2][0] * I + O[2][1] * R + O[2][2] * S + O[2][3] > G || O[3][0] * I + O[3][1] * R + O[3][2] * S + O[3][3] > G || (I = this.view[2] * I + this.view[6] * R + this.view[10] * S + this.view[14] - G, -I <= this.range.far))) if (-I < this.looseRange.far) this.range.far = -I; else {
                    if (100 < G && (G = L.getChildren(), void 0 !== G)) {
                      for (L =
                        0; 8 > L; ++L)void 0 !== G[L] && this.includeFarBoundingInfoRec(G[L], N); return
                    } F.unionDepthRangeWithAABB(this.range, this.viewProj, N, L.getBBMin(), L.getBBMax())
                  }
                }
              }; return K
          }(), B = function () {
            function K() { this.modelViewProj = n.create(); this.clipPosition = [h.create(), h.create(), h.create(), h.create(), h.create(), h.create(), h.create(), h.create()] } var P = K.prototype; P.unionDepthRangeWithAABB = function (L, N, G, I, O) {
              var R = this.modelViewProj; y.multiply(R, N, G); N = !1; for (G = 0; 8 > G; ++G) {
                const S = this.clipPosition[G], Q = 0 === G || 3 ===
                  G || 4 === G || 7 === G ? I[0] : O[0], T = 0 === G || 1 === G || 4 === G || 5 === G ? I[1] : O[1], da = 4 > G ? I[2] : O[2]; S[0] = R[0] * Q + R[4] * T + R[8] * da + R[12]; S[1] = R[1] * Q + R[5] * T + R[9] * da + R[13]; S[2] = R[2] * Q + R[6] * T + R[10] * da + R[14]; S[3] = R[3] * Q + R[7] * T + R[11] * da + R[15]
              } for (I = 0; 12 > I; ++I) { O = this.clipTriangle(this.clipPosition[C[I][0]], this.clipPosition[C[I][1]], this.clipPosition[C[I][2]]); R = !0; for (G = 0; G < O.length; ++G)if (2 <= O[G][3]) { R = !1; break } if (!R) for (N = !0, R = 0; R < O.length; ++R)G = O[R][3], G < L.near && (L.near = G), G > L.far && (L.far = G) } return N
            }; P.inside = function (L,
              N) { if (0 === N) return L[0] >= -L[3]; if (1 === N) return L[1] >= -L[3]; if (2 === N) return L[0] <= L[3]; if (3 === N) return L[1] <= L[3]; v.assert(!1) }; P.intersect = function (L, N, G) { let I = 0; 0 === G ? I = (-L[3] - L[0]) / (N[0] - L[0] + N[3] - L[3]) : 1 === G ? I = (-L[3] - L[1]) / (N[1] - L[1] + N[3] - L[3]) : 2 === G ? I = (L[3] - L[0]) / (N[0] - L[0] - N[3] + L[3]) : 3 === G && (I = (L[3] - L[1]) / (N[1] - L[1] - N[3] + L[3])); return l.lerp(h.create(), L, N, I) }; P.clipTriangle = function (L, N, G) {
                L = [L, N, G]; for (N = 0; 4 > N; ++N) {
                  G = L; L = []; for (let I = 0; I < G.length; ++I) {
                    const O = G[I], R = G[(I + 1) % G.length]; this.inside(R,
                      N) ? (this.inside(O, N) || L.push(this.intersect(O, R, N)), L.push(R)) : this.inside(O, N) && L.push(this.intersect(O, R, N))
                  }
                } return L
              }; return K
          }(); const C = [[0, 1, 3], [2, 3, 1], [1, 5, 2], [6, 2, 5], [5, 4, 6], [7, 6, 4], [4, 0, 7], [3, 7, 0], [3, 2, 7], [6, 7, 2], [4, 5, 0], [1, 0, 5]], D = d.create(), E = n.create(), H = t.empty(), J = new A, M = new z, F = new B; a.DepthRangeFromRenderGeometries = z; a.depthRangeFromLayer = m; a.depthRangeFromScene = function (K, P, L) { if (1E4 > P.size) return M.compute(K, P); const N = t.empty(); L.forAll(G => { G.isVisible && t.union(N, m(K, G)) }); return N };
          a.textureToDepth = function (K, P, L) { return c.unpackFloatRGBA(P, K) * (L[1] - L[0]) + L[0] }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/MagnifierHelper": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/Handles ../../../../core/mathUtils ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/screenUtils ../../../../core/urlUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../support/requestImageUtils ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../webgl/checkWebGLError ../../../webgl/enums ../../../../chunks/builtins ../../../webgl/Texture ../../../webgl/VertexArrayObject ./DefaultVertexBufferLayouts ./glUtil3D ./Program ../shaders/Magnifier.glsl ../../../magnifier/resources ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M) {
        a.MagnifierHelper = function (F) {
          function K() { var L = F.apply(this, arguments) || this; L._handles = new y; L._magnifier = null; L._imageSources = null; L._imageLoadTask = null; L._resources = null; L.events = new u; L.attributeLocations = new Map([["position", 0]]); L.tmpScreenPoint = h.createScreenPointArray(); L.tmpRenderPoint = h.createRenderScreenPointArray(); return L } w._inheritsLoose(K, F); var P = K.prototype; P.dispose = function () {
          this._magnifier = null; this._handles.destroy();
            p.isSome(this._imageLoadTask) && (this._imageLoadTask.task.abort(), this._imageLoadTask = null); this.disposeResources()
          }; P.render = function (L, N) {
            const G = this._validMagnifier; if (!p.isNone(G)) {
              var I = N.camera.pixelRatio, O = Math.ceil(I * G.size); this.updateResources(L, O); if (!p.isNone(this._resources)) {
                var R = this._resources.program; L.useProgram(R); var S = this._resources.textures, Q = Math.ceil(1 / this.factor * O); S.input.resize(Q, Q); var T = N.camera.fullWidth, da = N.camera.fullHeight; h.screenPointObjectToArray(G.position,
                  this.tmpScreenPoint); N = N.camera.screenToRender(this.tmpScreenPoint, this.tmpRenderPoint); var Y = .5 * Q, fa = .5 * Q; N[0] = n.clamp(N[0], Y, T - Y - 1); N[1] = n.clamp(N[1], fa, da - fa - 1); Y = Math.floor(N[0] - Y); fa = Math.floor(N[1] - fa); R.bindTexture(S.input, "textureInput"); L.gl.copyTexImage2D(S.input.descriptor.target, 0, S.input.descriptor.pixelFormat, Y, fa, Q, Q, 0); Q = -1 + (N[0] + G.offset.x * I) / T * 2; I = -1 + (N[1] - G.offset.y * I) / da * 2; T = O / T * 2; O = O / da * 2; L.bindVAO(this._resources.vao); R.bindTexture(S.overlay, "textureOverlay"); R.bindTexture(S.mask,
                    "textureMask"); R.setUniform4f("drawPosition", Q, I, T, O); R.setUniform1i("maskEnabled", G.maskEnabled ? 1 : 0); R.setUniform1i("overlayEnabled", G.overlayEnabled ? 1 : 0); L.setPipelineState(this._resources.pipelineState); L.drawArrays(5, 0, 4)
              }
            }
          }; P.updateResourceLoading = function () {
            var L = this; const N = this._validMagnifier; if (!p.isNone(N)) {
              var G = N.maskUrl, I = N.overlayUrl; !p.isSome(this._imageLoadTask) || this._imageLoadTask.maskUrl === G && this._imageLoadTask.overlayUrl === I || (this._imageLoadTask.task.abort(), this._imageSources =
                this._imageLoadTask = null); p.isSome(this._imageSources) || p.isSome(this._imageLoadTask) || (this._imageLoadTask = {
                  maskUrl: G, overlayUrl: I, task: l.createTask(function () {
                    var O = w._asyncToGenerator(function* (R) { const S = p.isNone(G) || p.isNone(I) ? J.loadMagnifierResources(R) : null, Q = p.isSome(G) ? e.requestImage(G, { signal: R }) : S.then(T => T.mask); R = p.isSome(I) ? e.requestImage(I, { signal: R }) : S.then(T => T.overlay); L._imageSources = { mask: yield Q, overlay: yield R }; L.disposeResources(); L.events.emit("request-render") }); return function (R) {
                      return O.apply(this,
                        arguments)
                    }
                  }())
                }, this._imageLoadTask.task.promise.then(() => this.notifyChange("updating"), () => this.notifyChange("updating")))
            }
          }; P.updateResources = function (L, N) {
            this.enabled ? p.isSome(this._resources) ? this._resources.textures.size !== N && (L = this.createTextureResources(L, N), p.isNone(L) ? this.disposeResources() : (this.disposeTextureResources(this._resources.textures), this._resources.textures = L)) : (N = this.createTextureResources(L, N), p.isNone(N) || (this._resources = {
              textures: N, program: this.createProgram(L), vao: D.createQuadVAO(L,
                C.Pos2, this.attributeLocations, 0, 1), pipelineState: M.makePipelineState({ blending: M.simpleBlendingParams(1, 771), depthTest: null, depthWrite: null, colorWrite: M.defaultColorWriteParams })
            })) : this.disposeResources()
          }; P.disposeResources = function () { p.isNone(this._resources) || (this.disposeTextureResources(this._resources.textures), this._resources.program.dispose(), this._resources.vao.dispose(), this._resources = null) }; P.disposeTextureResources = function (L) { L.mask.dispose(); L.overlay.dispose(); L.input.dispose() };
          P.createTextureResources = function (L, N) {
            if (p.isNone(this._imageSources)) return null; this._imageSources.overlay.width = N; this._imageSources.overlay.height = N; this._imageSources.mask.width = N; this._imageSources.mask.height = N; const G = new z(L, { target: 3553, pixelFormat: 6408, internalFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9729, flipped: !0, preMultiplyAlpha: b.isSVG(this._imageSources.overlay.src) && L.driverTest.svgAlwaysPremultipliesAlpha ? !1 : !0 }, this._imageSources.overlay), I = new z(L, {
              target: 3553, pixelFormat: 6406,
              internalFormat: 6406, dataType: 5121, wrapMode: 33071, samplingMode: 9729, flipped: !0
            }, this._imageSources.mask); return { input: new z(L, { target: 3553, pixelFormat: 6408, internalFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9729, flipped: !1 }), mask: I, overlay: G, size: N }
          }; P.createProgram = function (L) { const N = H.build(); return new E.Program(L, N, this.attributeLocations) }; w._createClass(K, [{ key: "updating", get: function () { return p.isNone(this._imageSources) && p.isSome(this._imageLoadTask) && !this._imageLoadTask.task.finished } },
          { key: "magnifier", get: function () { return this._magnifier }, set: function (L) { L !== this._magnifier && (this._handles.removeAll(), this._magnifier = L, L = () => { this.updateResourceLoading(); this.events.emit("request-render") }, p.isSome(this._magnifier) && this._handles.add(this._magnifier.watch("version", L)), L()) } }, { key: "enabled", get: function () { return p.isSome(this._validMagnifier) } }, {
            key: "_validMagnifier", get: function () {
              return p.isSome(this._magnifier) && this._magnifier.visible && p.isSome(this._magnifier.position) &&
                0 < this._magnifier.size ? this._magnifier : null
            }
          }, { key: "factor", get: function () { return p.isSome(this._magnifier) ? this._magnifier.factor || 1 : 1 } }]); return K
        }(q); c.__decorate([d.property()], a.MagnifierHelper.prototype, "_imageSources", void 0); c.__decorate([d.property()], a.MagnifierHelper.prototype, "_imageLoadTask", void 0); c.__decorate([d.property({ readOnly: !0 })], a.MagnifierHelper.prototype, "updating", null); a.MagnifierHelper = c.__decorate([m.subclass("esri/views/3d/webgl-engine/lib/MagnifierHelper")], a.MagnifierHelper);
          Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/shaders/Magnifier.glsl": function () {
      define(["exports", "../core/shaderModules/interfaces", "../core/shaderModules/ShaderBuilder"], function (a, w, c) {
      a.build = function () {
        const q = new c.ShaderBuilder; q.attributes.add("position", "vec2"); q.vertex.uniforms.add("proj", "mat4"); q.vertex.uniforms.add("drawPosition", "vec4"); q.varyings.add("vUV", "vec2"); q.vertex.code.add(w.glsl`void main(void) {
vUV = position;
gl_Position = vec4(drawPosition.xy + vec2(position - 0.5) * drawPosition.zw, 0.0, 1.0);
}`); q.fragment.uniforms.add("textureInput", "sampler2D"); q.fragment.uniforms.add("textureMask", "sampler2D"); q.fragment.uniforms.add("textureOverlay", "sampler2D"); q.fragment.uniforms.add("maskEnabled", "bool"); q.fragment.uniforms.add("overlayEnabled", "bool"); q.fragment.code.add(w.glsl`const float barrelFactor = 1.1;
vec2 barrel(vec2 uv) {
vec2 uvn = uv * 2.0 - 1.0;
if (uvn.x == 0.0 && uvn.y == 0.0) {
return vec2(0.5, 0.5);
}
float theta = atan(uvn.y, uvn.x);
float r = pow(length(uvn), barrelFactor);
return r * vec2(cos(theta), sin(theta)) * 0.5 + 0.5;
}
void main() {
float mask = maskEnabled ? texture2D(textureMask, vUV).a : 1.0;
vec4 inputColor = texture2D(textureInput, barrel(vUV)) * mask;
vec4 overlayColor = overlayEnabled ? texture2D(textureOverlay, vUV) : vec4(0);
gl_FragColor = overlayColor + (1.0 - overlayColor.a) * inputColor;
}`); return q
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/magnifier/resources": function () {
      define(["require", "exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/promiseUtils", "../../support/requestImageUtils"], function (a, w, c, q, u) {
        function y() {
          y = c._asyncToGenerator(function* (n) {
            var p = new Promise((h, b) => a(["./mask-svg"], d => h(Object.freeze({ __proto__: null, default: d })), b)), l = new Promise((h, b) => a(["./overlay-svg"], d => h(Object.freeze({ __proto__: null, default: d })), b)); p = u.requestImage((yield p).default,
              { signal: n }); l = u.requestImage((yield l).default, { signal: n }); l = { mask: yield p, overlay: yield l }; q.throwIfAborted(n); return l
          }); return y.apply(this, arguments)
        } w.loadMagnifierResources = function (n) { return y.apply(this, arguments) }; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/Renderer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/MapUtils ../../../../core/maybe ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2f64 ../../support/debugFlags ../core/renderPasses/RenderPassManager ./BoundingInfo ./depthRange ./depthRangeUtils ./glUtil3D ./HighlightHelper ./OffscreenRendering ./RenderContext ./rendererUtils ./RenderPluginManager ./ShadowAccumulator ./ShadowHighlightHelper ./ShadowMap ./SliceHelper ./SmaaRenderPass ./SSAOHelper ./edgeRendering/EdgeView ../lighting/SceneLighting ../materials/renderers/MergedRenderer ../shaders/ShadowHighlightTechnique ../statistics/RendererPerformanceInfo ../../../webgl/Measurement".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R) {
        a.Renderer = function (ha) {
          function ka(ba, aa, W, U, X, Z, ia, la, ma) {
            var ra = ha.call(this, {}) || this; ra._materialRepository = ba; ra._shaderTechniqueRepository = W; ra._rctx = U; ra._compositingHelper = X; ra._magnifierHelper = Z; ra._requestRender = ia; ra._stage = ma; ra._materialRenderers = new Map; ra._hasHighlights = !1; ra._hasOccludees = !1; ra._hasWater = !1; ra._hasOverlayWater = !1; ra._content = new Map; ra._isRendering = !1; ra._fallbackDepthStencilTexture =
              null; ra.performanceInfo = new O.RendererPerformanceInfo; ra._antialiasing = 1; ra._oitEnabled = !1; ra._multipassTerrain = !0; ra._opaqueTerrain = !0; ra._lighting = new N.SceneLighting; ra._handles = new u; ra.renderHiddenTransparentEdges = () => { }; ra._smaaPass = new K.SmaaRenderPass(ra._rctx, W); ra._oitEnabled = ra._hasOITSupport; ra._requestRender(); ra._offscreenRendering = new B.OffscreenRendering(ra._rctx, ra._compositingHelper); ra._sliceHelper = new F; ra._shadowMap = new M(ra._rctx, ma.viewingMode, 2); ra._ssaoHelper = new P.SSAOHelper(W,
                ra._rctx, () => ra._requestRender()); ra._highlightHelper = new z(W, ra._rctx); ra._shadowHighlightHelper = new J.ShadowHighlightHelper(ra._rctx, ma.viewingMode); ra._shadowAccumulator = new H.ShadowAccumulator(ra._rctx, W, ma, (Aa, za) => { ra.renderPassManager.shadowCastingEnabled = !0; ra._renderPlugins.prepareRender(Aa, za); ra.renderPassManager.shadowCastingEnabled = ra._shadowMap.enabled }, (Aa, za, Ka, Ea) => { Aa.start(Ka, za, Ea); ra.renderShadowCascades(4, Aa); Ka.setGLViewport(ra._rctx); ra.ensureCameraBindParameters(Ka) }, () =>
                  ra._requestRender()); ra._bindParameters = {
                    slot: null, camera: null, inverseViewport: m.create(), shadowMap: ra._shadowMap, shadowMappingEnabled: ra._shadowMap.enabled, ssaoHelper: ra._ssaoHelper, ssaoEnabled: ra._ssaoHelper.enabled, origin: null, screenToWorldRatio: null, screenToPCSRatio: null, slicePlane: ra._sliceHelper.plane, highlightDepthTexture: null, hasOccludees: !1, linearDepthTexture: null, terrainLinearDepthTexture: null, geometryLinearDepthTexture: null, multipassTerrainEnabled: !1, multipassGeometryEnabled: !1, cullAboveGround: !1,
                    lastFrameColorTexture: null, reprojectionMatrix: v.IDENTITY, ssrEnabled: !1, lighting: ra._lighting, highlightColorTexture: null
                  }; ra._renderContext = new C.RenderContext(ra._rctx, ra._offscreenRendering, ra._lighting, ra._shadowMap, ra._ssaoHelper, ra._sliceHelper); ra._renderContext.multipassTerrainParams = { camera: null, multipassTerrainEnabled: !1, cullAboveGround: !1, terrainLinearDepthTexture: null }; ra._renderContext.multipassGeometryParams = { multipassGeometryEnabled: !1, geometryLinearDepthTexture: null }; ra._renderContext.ssrParams =
                    { camera: null, linearDepthTexture: null, lastFrameColorTexture: null, reprojectionMatrix: v.IDENTITY, ssrEnabled: !1 }; ra._renderPlugins = new E.RenderPluginManager({ renderContext: ra._renderContext, shaderTechniqueRep: W, textureRep: aa, materialRep: ra._materialRepository, requestRender: ra._requestRender, schedule: la }); ra.renderPassManager = new g.RenderPassManager(ra._rctx, ra._shaderTechniqueRepository); ra._renderPlugins.add(ra.renderPassManager.slots(), ra.renderPassManager); ra._handles.add([p.init(e, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",
                      Aa => { ra.renderHiddenTransparentEdges = Aa ? () => ra.renderEdges(1) : () => { }; ra._requestRender() }), p.init(ra._stage, "camera", () => ra._requestRender(), !0)]); return ra
          } w._inheritsLoose(ka, ha); var ea = ka.prototype; ea.normalizeCtorArgs = function () { return {} }; ea.dispose = function () {
            this._handles.destroy(); this._smaaPass.dispose(); this._materialRenderers.forEach(ba => ba.dispose()); this._materialRenderers.clear(); this._edgeView = n.destroyMaybe(this._edgeView); this._offscreenRendering.dispose(); this._fallbackDepthStencilTexture =
              n.disposeMaybe(this._fallbackDepthStencilTexture); this._shadowMap.enabled = !1; this._shadowMap.dispose(); this._ssaoHelper.enabled = !1; this._ssaoHelper.dispose(); this._highlightHelper.dispose(); this._shadowHighlightHelper.dispose(); this._shadowAccumulator.dispose(); x.BoundingInfo.prune(); this._content.clear()
          }; ea.ensureEdgeView = function () {
            n.isNone(this._edgeView) && (this._edgeView = new L.EdgeView({
              rctx: this._rctx, renderSR: this._stage.renderSR, techniqueRepository: this._shaderTechniqueRepository, setNeedsRender: () =>
                this._requestRender(), schedule: ba => this._stage.resourceController.schedule(ba)
            }), this._handles.add(this._edgeView.watch("updating", () => this._requestRender(), !0)), this._requestRender()); return this._edgeView
          }; ea.setRenderParameters = function (ba) {
            const { renderPassManager: aa, _shadowMap: W, _ssaoHelper: U } = this; void 0 !== ba.screenSpaceReflectionsEnabled && aa.screenSpaceReflectionsEnabled !== ba.screenSpaceReflectionsEnabled && (aa.screenSpaceReflectionsEnabled = ba.screenSpaceReflectionsEnabled, this._requestRender());
            void 0 === ba.shadowMap || W.enabled === ba.shadowMap && aa.shadowCastingEnabled === ba.shadowMap || (W.enabled = ba.shadowMap, aa.shadowCastingEnabled = ba.shadowMap, this._requestRender()); void 0 !== ba.shadowMapMaxCascades && W.maxCascades !== ba.shadowMapMaxCascades && (W.maxCascades = ba.shadowMapMaxCascades, this._requestRender()); void 0 !== ba.ssao && U.enabled !== ba.ssao && (U.enabled = ba.ssao, this._requestRender()); ba.background && this._offscreenRendering.background !== ba.background && (this._offscreenRendering.background = ba.background,
              this._requestRender()); const X = ba.antialiasingEnabled ? 1 : 0; void 0 !== ba.antialiasingEnabled && this._antialiasing !== X && (this._antialiasing = X, this._requestRender()); void 0 !== ba.highQualityTransparency && this._multipassTerrain !== ba.highQualityTransparency && (this._oitEnabled = (this._multipassTerrain = ba.highQualityTransparency) && this._hasOITSupport, this._requestRender()); void 0 !== ba.defaultHighlightOptions && (this._highlightHelper.setDefaultOptions(ba.defaultHighlightOptions), this._shadowHighlightHelper.setDefaultOptions(ba.defaultHighlightOptions),
                this._requestRender()); void 0 !== ba.slicePlane && this._sliceHelper.plane !== ba.slicePlane && (this._sliceHelper.plane = n.unwrap(ba.slicePlane), this._requestRender()); void 0 !== ba.waterReflectionEnabled && this._waterReflectionEnabled !== ba.waterReflectionEnabled && (this._waterReflectionEnabled = ba.waterReflectionEnabled, this._requestRender()); void 0 !== ba.opaqueTerrain && this._opaqueTerrain !== ba.opaqueTerrain && (this._opaqueTerrain = ba.opaqueTerrain, this._requestRender()); void 0 !== ba.hasOverlayWater && this._hasOverlayWater !==
                  ba.hasOverlayWater && (this._hasOverlayWater = ba.hasOverlayWater, this._requestRender()); void 0 !== ba.shadowCastOptions && this._shadowAccumulator.setOptions(ba.shadowCastOptions)
          }; ea.modify = function (ba) {
          this._isRendering && console.warn("Renderer.modify called while rendering"); const { adds: aa, removes: W, updates: U } = ba; if (0 !== aa.length || 0 !== W.length || 0 !== U.length) {
            W.forAll(({ id: Z }) => this._content.delete(Z)); aa.forAll(Z => this._content.set(Z.id, Z)); var X = !1; D.splitRenderGeometryChangeSetByMaterial(ba).forEach((Z,
              ia) => { let la = this._materialRenderers.get(ia); if (!la) if (0 < Z.adds.length) la = new G.MergedRenderer(this._rctx, this._materialRepository, ia), this._materialRenderers.set(ia, la); else return; la.modify(Z); la.isEmpty && (X = !0) }); X && this._materialRenderers.forEach((Z, ia) => { Z.isEmpty && (this._materialRenderers.delete(ia), Z.dispose()) }); this._hasHighlights = y.someMap(this._materialRenderers, Z => Z.hasHighlights); this._hasOccludees = y.someMap(this._materialRenderers, Z => Z.hasOccludees); this._hasWater = y.someMap(this._materialRenderers,
                Z => Z.hasWater); this._requestRender()
          }
          }; ea.updateLogic = function (ba) { let aa = !1; this._materialRenderers.forEach(W => aa = W.updateLogic(ba) || aa); return aa }; ea.updateLightSources = function (ba, aa, W) { this._lighting.groundLightingFactor = aa; this._lighting.globalFactor = W; this._lighting.set(ba) }; ea.render = function (ba, aa, W, U) {
          this._isRendering = !0; this.performanceInfo.prerender(this._rctx); this._bindParameters.lighting = this._lighting; this._renderContext.hasOccludees = this._hasOccludees; this._renderContext.transparencyPassType =
            3; this._bindParameters.transparencyPassType = 3; var X = this._offscreenRendering; X.needLastFrameColorTexture = this.hasWaterReflection; X.advanceCurrentRenderTarget(); const Z = this._sliceHelper.plane; 0 === U && (this._sliceHelper.plane = null); this._rctx.bindFramebuffer(ba); aa.setGLViewport(this._rctx); this.needsShadowCast && (this.renderPassManager.shadowCastingEnabled = !0); this._renderPlugins.prepareRender(aa, W); this.performanceInfo.advance(0); var ia = this.computeDepthRange(aa); this.renderShadowMap(ba, aa, this._lighting.lightingMainDirection,
              ia); this.performanceInfo.advance(1); X.initializeFrame(aa); this.ensureBindParameters(aa); this.renderLinearDepth(); this.performanceInfo.advance(2); this.accumulateShadows(ia, aa, W); this.renderNormal(); this.performanceInfo.advance(3); this.ensureBindParametersSSR(); this._ssaoHelper.computeSSAO(aa, X.linearDepthTexture, X.normalTexture); this.performanceInfo.advance(4); this._renderContext.pass = 0; X.bindFramebuffer(); this.renderOpaqueGeometry(); this.performanceInfo.advance(5); aa = this._multipassTerrain && !this._opaqueTerrain;
            this.renderTerrainLinearDepth(aa); this.setMultipassFlags(aa); this.setTerrainCulling(aa); this.renderEdges(2); this.performanceInfo.advance(6); this.renderHiddenTransparentEdges(); this._oitEnabled ? this.renderOrderIndependentTransparency(() => this.renderTransparentGeometry(), !1) : this.renderTransparentGeometry(); this.performanceInfo.advance(7); this.renderGeometryLinearDepth(aa); ia = W = !1; W = this.renderHUDVisibility(); aa || this.renderInternalSlot(18); this.performanceInfo.advance(9); this.renderEdges(1, aa); this.performanceInfo.advance(8);
            this.renderSlot(22); (ia = this.renderTransparentTerrain()) && W && (aa ? this.renderLineCallouts(0) : X.compositeTransparentTerrainOntoHUDVisibility(), this.renderHUD(0, X.framebuffer), this.performanceInfo.advance(16)); this.performanceInfo.advance(10); this.setTerrainCulling(!1); ia && (X.compositeTransparentTerrainOntoMain(), aa && (this.renderEdges(2), this.performanceInfo.advance(6), this._oitEnabled ? this.renderOrderIndependentTransparency(() => this.renderTransparentGeometry(), !1) : this.renderTransparentGeometry(), this.performanceInfo.advance(7),
              this.renderEdges(1), this.performanceInfo.advance(8))); aa && this.renderLineCallouts(1); this.setMultipassFlags(!1); this._shadowAccumulator.render(); X.renderToTargets(() => { this.renderInternalSlot(7); this.renderSlot(13); this.renderSlot(14) }, X.currentColorTarget, X.mainDepth); this.performanceInfo.advance(11); this._renderPlugins.needsLaserlineWithContrastControl && X.renderTmpAndCompositeToMain(() => this.renderSlot(15), 2); this.performanceInfo.advance(12); this.renderOccluded(); this.performanceInfo.advance(13);
            X = (U = 1 === U && this._magnifierHelper.enabled) && n.isNone(ba) ? this._offscreenRendering.getFramebuffer(this._offscreenRendering.tmpColor, this._offscreenRendering.tmpDepth) : ba; this._rctx.bindFramebuffer(X); aa = this._offscreenRendering.colorTexture; !this.renderAntiAliasing(this._antialiasing, aa) && n.isSome(aa) && this._compositingHelper.composite(aa, 0); this.performanceInfo.advance(14); this.renderHUD(1, X); this.performanceInfo.advance(17); this.renderHighlights(X, this._bindParameters); this.performanceInfo.advance(15);
            U && this._magnifierHelper.render(this._rctx, this._bindParameters); X !== ba && (this._rctx.bindFramebuffer(ba), this._compositingHelper.composite(this._offscreenRendering.tmpColorTexture, 0)); this._renderContext.lastFrameCamera.copyFrom(this._renderContext.camera); this._sliceHelper.plane = Z; this._isRendering = !1; if (this.onPostRender) this.onPostRender(); this.performanceInfo.postrender()
          }; ea.readDepthPixels = function (ba, aa, W, U, X, Z) {
            const ia = this._offscreenRendering.bindTarget(this._offscreenRendering.linearDepth,
              this._offscreenRendering.tmpDepth); this._needsLinearDepth || (this.ensureBindParameters(ba), this._renderContext.camera.setGLViewport(this._rctx), this._rctx.setClearColor(0, 0, 0, 0), this._rctx.clearSafe(17664), this.renderGeometryAndTransparentTerrainPass(2)); ia.readPixels(aa, W, U, X, 6408, 5121, Z)
          }; ea.readAccumulatedShadow = function (ba, aa) { return this._shadowAccumulator.readAccumulatedShadow(ba, aa) }; ea.setMultipassFlags = function (ba) {
            this._renderContext.multipassTerrainParams.multipassTerrainEnabled = this._bindParameters.multipassTerrainEnabled =
              ba; this._renderContext.multipassGeometryParams.multipassGeometryEnabled = this._bindParameters.multipassGeometryEnabled = ba
          }; ea.setTerrainCulling = function (ba) { this._renderContext.multipassTerrainParams.cullAboveGround = this._bindParameters.cullAboveGround = ba }; ea.renderSlot = function (ba) { this._renderContext.slot = ba; return this._renderPlugins.render() }; ea.renderEdges = function (ba, aa = !1) {
            const W = this._edgeView; n.isSome(W) && W.shouldRender() && this._offscreenRendering.renderTmpAndCompositeToMain(() => W.render(this._bindParameters,
              ba), 1, aa)
          }; ea.renderShadowMap = function (ba, aa, W, U) { const X = this._shadowMap; X.enabled && (X.start(aa, W, U), this.needsShadowHighlight ? (this.renderShadowCascades(7, this._shadowMap, Z => X.takeCascadeSnapshotTo(Z, I.HighlightShadowMapSlot)), X.clear(), this.renderShadowCascades(6, this._shadowMap, Z => { X.takeCascadeSnapshotTo(Z, I.DefaultSnapshotSlot); this.renderGeometryAndTransparentTerrainPass(7) })) : this.renderShadowCascades(4), X.finish(ba), aa.setGLViewport(this._rctx)) }; ea.renderShadowCascades = function (ba, aa = this._shadowMap,
            W = U => { }) { for (const U of aa.getCascades()) U.camera.setGLViewport(this._rctx), this.ensureCameraBindParameters(U.camera), this.renderGeometryAndTransparentTerrainPass(ba), W(U) }; ea.renderLinearDepth = function () {
              this._needsLinearDepth ? this._offscreenRendering.renderToTargets(() => this.renderGeometryAndTransparentTerrainPass(2), this._offscreenRendering.linearDepth, this._offscreenRendering.tmpDepth, [0, 0, 0, 0], !0, !0) : this._offscreenRendering.disposeTarget(this._offscreenRendering.linearDepth); this._renderContext.ssrParams.linearDepthTexture =
                this._bindParameters.linearDepthTexture = this._offscreenRendering.linearDepthTexture
            }; ea.renderTerrainLinearDepth = function (ba) {
              ba ? (ba = this._renderContext.pass, this._renderContext.pass = 2, this._offscreenRendering.renderToTargets(() => this.renderTransparentTerrain(), this._offscreenRendering.terrainLinearDepth, this._offscreenRendering.tmpDepth, [-1E10, -1E10, -1E10, 1], !0, !0), this._renderContext.pass = ba) : this._offscreenRendering.disposeTarget(this._offscreenRendering.terrainLinearDepth); this._renderContext.multipassTerrainParams.terrainLinearDepthTexture =
                this._bindParameters.terrainLinearDepthTexture = this._offscreenRendering.terrainLinearDepthTexture
            }; ea.renderGeometryLinearDepth = function (ba) {
              ba ? (ba = this._renderContext.pass, this._offscreenRendering.renderToTargets(() => this.renderGeometryPass(2), this._offscreenRendering.geometryLinearDepth, this._offscreenRendering.tmpDepth, [1, 1, 1, 1], !0, !0), this._renderContext.pass = ba) : this._offscreenRendering.disposeTarget(this._offscreenRendering.geometryLinearDepth); this._renderContext.multipassGeometryParams.geometryLinearDepthTexture =
                this._bindParameters.geometryLinearDepthTexture = this._offscreenRendering.geometryLinearDepthTexture
            }; ea.renderNormal = function () { this.needsNormal ? this._offscreenRendering.renderToTargets(() => { this.renderGeometryAndTransparentTerrainPass(3) }, this._offscreenRendering.normal, this._offscreenRendering.tmpDepth, [0, 0, 0, 0], !0, !0) : this._offscreenRendering.disposeTarget(this._offscreenRendering.normal) }; ea.computeDepthRange = function (ba) {
              if (!this.needsDepthRange) return k.ZERO; const aa = r.depthRangeFromScene(ba,
                this._content, this._stage.layers); k.union(aa, this.renderPlugins.queryDepthRange(ba)); aa.near = Math.max(ba.near, aa.near); aa.far = Math.min(ba.far, aa.far); return aa
            }; ea.renderGeometryAndTransparentTerrainPass = function (ba) { this._renderContext.pass = ba; this.renderGeometryPass(ba); this.renderTransparentTerrain() }; ea.renderGeometryPass = function (ba) { this._renderContext.pass = ba; this.renderOpaqueGeometry(); this.renderTransparentGeometry() }; ea.renderOpaqueGeometry = function () {
              this.renderSlot(0); this.renderSlot(1);
              this.renderInternalSlot(2); this.renderSlot(3); this.renderSlot(12)
            }; ea.renderTransparentGeometry = function () { this.renderInternalSlot(4); this.renderSlot(5) }; ea.renderTransparentTerrain = function () { return this.renderSlot(6) }; ea.renderHUDVisibility = function () {
              let ba = !1; this._renderContext.offscreenRenderingHelper && this._renderContext.offscreenRenderingHelper.renderHUDVisibility(() => {
                this._bindParameters.hudVisibilityTexture = this._renderContext.offscreenRenderingHelper ? this._renderContext.offscreenRenderingHelper.hudVisibilityTexture :
                  null; ba = this.renderInternalSlot(11)
              }, this._multipassTerrain && !this._opaqueTerrain); return ba
            }; ea.renderLineCallouts = function (ba) { this._bindParameters.renderTransparentlyOccludedHUD = ba; 0 === ba ? this._offscreenRendering.renderToTargets(() => this.renderInternalSlot(18), this._offscreenRendering.currentColorTarget, this._offscreenRendering.tmpDepth, void 0, !0, !0) : this.renderInternalSlot(18) }; ea.renderHUD = function (ba, aa) {
              this._oitEnabled ? (this.renderOrderIndependentTransparency(() => this.renderHUDElements(ba),
                !0), this._rctx.bindFramebuffer(aa), this._compositingHelper.composite(this._offscreenRendering.hudColorTexture, 2)) : 0 === ba ? this._offscreenRendering.renderToTargets(() => this.renderHUDElements(0), this._offscreenRendering.currentColorTarget, this._offscreenRendering.tmpDepth, void 0, !0, !0) : this.renderHUDElements(ba)
            }; ea.renderHUDElements = function (ba) { this._bindParameters.renderTransparentlyOccludedHUD = ba; this.renderInternalSlot(19); this.renderInternalSlot(16); this.renderInternalSlot(17) }; ea.renderHighlights =
              function (ba, aa) {
                if (this.needsHighlight) {
                  var W = this._highlightHelper, U = W.profilingCallback && R.startMeasurement(this._renderContext.rctx); this._renderContext.highlightDepthTexture = aa.highlightDepthTexture; var X = this._offscreenRendering.renderToTargets(() => { this.renderGeometryAndTransparentTerrainPass(5); this._rctx.clearSafe(256); this.renderHUDElements(2) }, this._offscreenRendering.highlight, this._offscreenRendering.tmpDepth, [0, 0, 0, 0], !0, !0); this._bindParameters.highlightColorTexture = X.colorTexture; this.needsShadowHighlight &&
                    this._shadowHighlightHelper.render(aa, ba); W.render(this._renderContext.camera, X, ba); n.isSome(U) && W.profilingCallback && U.stop(Z => { W.profilingCallback && W.profilingCallback(Z) })
                } else this._offscreenRendering.disposeTarget(this._offscreenRendering.highlight)
              }; ea.accumulateShadows = function (ba, aa, W) {
              this.needsShadowCast && (this._shadowAccumulator.setAccumulationDependencies(this._offscreenRendering.linearDepthTexture, ba, aa, W), this._shadowAccumulator.accumulateFixedSamples(), this.renderPassManager.shadowCastingEnabled =
                this._shadowMap.enabled)
              }; ea.renderOrderIndependentTransparency = function (ba, aa) {
                const W = X => { this._renderContext.transparencyPassType = X; this._bindParameters.transparencyPassType = this._renderContext.transparencyPassType; this._offscreenRendering.renderOITPass(() => ba(), X, aa) }, U = this._renderContext.pass; this._renderContext.pass = 1; W(1); this._renderContext.pass = 0; W(0); W(2); this._offscreenRendering.compositeTransparentOntoOpaque(aa); this._renderContext.transparencyPassType = 3; this._bindParameters.transparencyPassType =
                  this._renderContext.transparencyPassType; this._renderContext.pass = U
              }; ea.renderOccluded = function () {
                let ba = 0; this._materialRenderers.forEach((Z, ia) => { ia && ia.isVisible() && 8 === ia.renderOccluded && (ba |= ia.renderOccluded, Q.push(ia)) }); const aa = this._offscreenRendering, W = (Z, ia, la, ma, ra) => { 0 !== (ba & ia) && (aa.renderToTargets(la, aa.tmpColor, aa.mainDepth, [0, 0, 0, 0], ma, ra), aa.compositeOccludedOntoMain(Z)) }; 0 !== Q.length && (this.renderInternalSlot(9, Q), W(.5, 8, () => this.renderInternalSlot(10, Q), !1, !1), Q.length = 0); this._materialRenderers.forEach((Z,
                  ia) => { ia && ia.isVisible() && (4 === ia.renderOccluded || 2 === ia.renderOccluded || 16 === ia.renderOccluded) && (ba |= ia.renderOccluded, S.push(ia)) }); const U = this._renderPlugins.renderOccludedFlags; if (ba |= U) {
                    var X = Z => { this._renderContext.renderOccludedMask = Z; 1 < U && this.renderSlot(8); this.renderInternalSlot(2, S); this.renderInternalSlot(4, S); this.renderInternalSlot(7, S); this._renderContext.resetRenderOccludedMask() }; this._renderContext.pass = 0; W(.5, 4, () => X(4), !0, 2); W(.5, 2, () => X(2), !0, 2); W(1, 16, () => X(16), !0, 2); S.length =
                      0
                  }
              }; ea.renderAntiAliasing = function (ba, aa) { if (1 === ba) { if (this._smaaPass.enable(() => this._requestRender()) && n.isSome(aa)) return this._smaaPass.render(aa), !0 } else this._smaaPass.disable(); return !1 }; ea.ensureCameraBindParameters = function (ba) { this._renderContext.camera = ba; this._bindParameters.camera = this._renderContext.camera; this._bindParameters.inverseViewport[0] = 1 / this._renderContext.camera.fullViewport[2]; this._bindParameters.inverseViewport[1] = 1 / this._renderContext.camera.fullViewport[3] }; ea.ensureBindParameters =
                function (ba) {
                  var aa; this.ensureCameraBindParameters(ba); ba = this._renderContext.offscreenRenderingHelper; this._bindParameters.shadowMap = this._renderContext.shadowMap; this._bindParameters.shadowMappingEnabled = this._renderContext.shadowMap.enabled; this._bindParameters.ssaoHelper = this._renderContext.ssaoHelper; this._bindParameters.ssaoEnabled = this._renderContext.ssaoHelper.enabled; this._bindParameters.slicePlane = this._renderContext.sliceHelper.plane; this._bindParameters.hasOccludees = this._renderContext.hasOccludees;
                  this._renderContext.multipassTerrainParams.camera = this._renderContext.camera; this._bindParameters.hudVisibilityTexture = ba.hudVisibilityTexture; this._bindParameters.highlightDepthTexture = null != (aa = ba.depthTexture) ? aa : this.getFallbackDepthTexture()
                }; ea.ensureBindParametersSSR = function () {
                  this.hasWaterReflection ? (this._renderContext.lastFrameCamera.equals(this._renderContext.camera) ? this._renderContext.ssrParams.reprojectionMatrix = this._reprojectionMatrix = v.IDENTITY : (t.translate(T, this._renderContext.lastFrameCamera.viewMatrix,
                    this._bindParameters.origin ? this._bindParameters.origin : [0, 0, 0]), t.translate(Y, this._renderContext.camera.viewMatrix, this._bindParameters.origin ? this._bindParameters.origin : [0, 0, 0]), t.invert(Y, Y), t.invert(da, this._renderContext.camera.projectionMatrix), t.multiply(fa, Y, da), t.multiply(fa, T, fa), t.multiply(fa, this._renderContext.lastFrameCamera.projectionMatrix, fa), this._renderContext.ssrParams.reprojectionMatrix = this._reprojectionMatrix = fa), this._renderContext.ssrParams.camera = this._renderContext.camera,
                    this._renderContext.ssrParams.lastFrameColorTexture = this._bindParameters.lastFrameColorTexture = this._offscreenRendering.lastFrameColorTexture) : this._renderContext.ssrParams.lastFrameColorTexture = this._bindParameters.lastFrameColorTexture = null; this._renderContext.ssrParams.ssrEnabled = this._bindParameters.ssrEnabled = this.hasWaterReflection
                }; ea.renderInternalSlot = function (ba, aa) {
                  let W = !1; this._bindParameters.slot = ba; n.isSome(aa) ? aa.forEach(U => {
                    U.shouldRender(this._renderContext) && (U = this._materialRenderers.get(U),
                      n.isSome(U) && (W = U.render(ba, this._renderContext.pass, this._bindParameters) || W))
                  }) : this._materialRenderers.forEach((U, X) => { X.shouldRender(this._renderContext) && (W = U.render(ba, this._renderContext.pass, this._bindParameters) || W) }); return W
                }; ea.getFallbackDepthTexture = function () { this._fallbackDepthStencilTexture || (this._fallbackDepthStencilTexture = A.createEmptyDepthTexture(this._rctx)); return this._fallbackDepthStencilTexture }; w._createClass(ka, [{ key: "hasWater", get: function () { return this._hasWater || this._hasOverlayWater } },
                { key: "hasWaterReflection", get: function () { return this.hasWater && this._waterReflectionEnabled } }, { key: "updating", get: function () { return 1 === this._antialiasing && this._smaaPass.updating || n.isSome(this._edgeView) && this._edgeView.updating || this._shadowAccumulator.running || !this.isCameraFinal } }, { key: "edgeView", get: function () { return this._edgeView } }, { key: "isCameraFinal", get: function () { return null === this._bindParameters.reprojectionMatrix || t.equals(this._bindParameters.reprojectionMatrix, v.IDENTITY) } }, {
                  key: "_reprojectionMatrix",
                  set: function (ba) { t.equals(this._bindParameters.reprojectionMatrix, ba) || (this._bindParameters.reprojectionMatrix = ba, this.notifyChange("isCameraFinal")) }
                }, { key: "hasShadowsEnabled", get: function () { var ba; return !(null == (ba = this._shadowMap) || !ba.enabled) } }, { key: "hasSlicePlane", get: function () { return !!this._sliceHelper.plane } }, { key: "renderPlugins", get: function () { return this._renderPlugins } }, { key: "_hasOITSupport", get: function () { return this._rctx.driverTest.floatBufferBlendWorking } }, {
                  key: "_needsLinearDepth",
                  get: function () { return this._ssaoHelper.enabled || this._renderPlugins.needsLinearDepth || this._hasWater && this._waterReflectionEnabled || this.needsShadowHighlight || this.needsShadowCast }
                }, { key: "needsNormal", get: function () { return this._ssaoHelper.enabled } }, { key: "needsDepthRange", get: function () { return this._shadowMap.enabled || this.needsShadowCast } }, { key: "needsHighlight", get: function () { return this._hasHighlights || this._renderPlugins.needsHighlight } }, {
                  key: "needsShadowHighlight", get: function () {
                    return this._shadowMap.enabled &&
                      this._shadowHighlightHelper.isVisible && this.needsHighlight
                  }
                }, { key: "needsShadowCast", get: function () { return this._shadowAccumulator.isAccumulating } }, {
                  key: "gpuMemoryUsage", get: function () {
                    var ba, aa, W, U, X, Z, ia, la, ma, ra; return {
                      offscreen: null != (ba = null == (aa = this._offscreenRendering) ? void 0 : aa.gpuMemoryUsage) ? ba : 0, highlights: (null != (W = null == (U = this._highlightHelper) ? void 0 : U.gpuMemoryUsage) ? W : 0) + (null != (X = null == (Z = this._shadowHighlightHelper) ? void 0 : Z.gpuMemoryUsage) ? X : 0), shadows: null != (ia = null == (la = this._shadowMap) ?
                        void 0 : la.gpuMemoryUsage) ? ia : 0, ssao: null != (ma = null == (ra = this._ssaoHelper) ? void 0 : ra.gpuMemoryUsage) ? ma : 0
                    }
                  }
                }, {
                  key: "test", get: function () {
                    const ba = this; return {
                      offscreen: this._offscreenRendering, shadowMap: this._shadowMap, ssao: this._ssaoHelper, highlight: this._highlightHelper, lighting: this._lighting, materialRenderers: this._materialRenderers, shadowAccumulator: this._shadowAccumulator, getFramebufferTexture: aa => {
                        var W; switch (aa) {
                          case 0: return ba._offscreenRendering.colorTexture; case 1: return ba._offscreenRendering.linearDepthTexture;
                          case 2: return ba._offscreenRendering.normalTexture; case 3: return null == (W = ba._shadowMap) ? void 0 : W.test.depthTexture; case 4: return ba._offscreenRendering.hudVisibilityTexture; case 5: return ba._offscreenRendering.highlightTexture
                        }
                      }
                    }
                  }
                }]); return ka
        }(q); c.__decorate([l.property()], a.Renderer.prototype, "_shadowAccumulator", void 0); c.__decorate([l.property()], a.Renderer.prototype, "_smaaPass", void 0); c.__decorate([l.property()], a.Renderer.prototype, "_antialiasing", void 0); c.__decorate([l.property()], a.Renderer.prototype,
          "_edgeView", void 0); c.__decorate([l.property()], a.Renderer.prototype, "updating", null); c.__decorate([l.property()], a.Renderer.prototype, "isCameraFinal", null); a.Renderer = c.__decorate([f.subclass("esri.views.3d.webgl-engine.lib.Renderer")], a.Renderer); const S = [], Q = [], T = v.create(), da = v.create(), Y = v.create(), fa = v.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/renderPasses/RenderPassManager": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/maybe ../../../../../chunks/mat3 ../../../../../chunks/mat3f64 ../../../../../chunks/mat4 ../../../../../chunks/vec2 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/vec4 ../../../../../chunks/boundedPlane ./AllRenderPasses ./RenderPass ../util/TwoVectorPosition ../../lib/depthRange".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          let m = function () {
            function k(A, z) {
            this.rctx = A; this.shaderTechniqueRepository = z; this.canRender = !0; this._materialPassParams = new d.MaterialPassesParameters; this._shadowPassParams = new d.ShadowMapPassParameters; this._highlightPassParams = new d.HighlightPassParameters; this._systems = new Set; this._passes = {
              materialOpaque: new f.RenderPass(A, this.shaderTechniqueRepository), materialTransparent: new f.RenderPass(A, this.shaderTechniqueRepository, 1), materialIntegratedMesh: new f.RenderPass(A,
                this.shaderTechniqueRepository), shadowMap: new f.RenderPass(A, this.shaderTechniqueRepository), highlight: new f.RenderPass(A, this.shaderTechniqueRepository), highlightIntegratedMesh: new f.RenderPass(A, this.shaderTechniqueRepository), highlightShadowMap: new f.RenderPass(A, this.shaderTechniqueRepository), defaultShadowMap: new f.RenderPass(A, this.shaderTechniqueRepository)
            }
            } var r = k.prototype; r.register = function (A) { this._systems.add(A) }; r.prepareRender = function (A) {
              if (0 !== this._systems.size) {
                for (const z of Object.values(this._passes)) z.prepareSubmit();
                this._systems.forEach(z => z.submit(this._passes, { camera: A })); for (const z of Object.values(this._passes)) z.finishSubmit(); this.shaderTechniqueRepository.frameUpdate()
              }
            }; r.render = function (A) {
              if (0 === this._systems.size) return !1; this._configure(A); switch (A.slot) {
                case 3: switch (A.pass) {
                  case 0: return this._materialPassParams.subPass = 0, this._configureMaterialColorPass(A), this._passes.materialOpaque.dispatch(this._materialPassParams); case 2: return this._materialPassParams.subPass = 2, this._passes.materialOpaque.dispatch(this._materialPassParams);
                  case 3: return this._materialPassParams.subPass = 3, this._passes.materialOpaque.dispatch(this._materialPassParams); case 5: return this._passes.highlight.dispatch(this._highlightPassParams); case 4: return this._passes.shadowMap.dispatch(this._shadowPassParams); case 7: return this._passes.highlightShadowMap.dispatch(this._shadowPassParams); case 6: return this._passes.defaultShadowMap.dispatch(this._shadowPassParams)
                }break; case 5: switch (A.pass) {
                  case 0: return this._materialPassParams.subPass = 0, this._configureMaterialColorPass(A),
                    this._passes.materialTransparent.dispatch(this._materialPassParams); case 1: return this._materialPassParams.subPass = 1, this._configureMaterialColorPass(A), this._passes.materialTransparent.dispatch(this._materialPassParams); case 2: return this._materialPassParams.subPass = 2, this._passes.materialTransparent.dispatch(this._materialPassParams); case 3: return this._materialPassParams.subPass = 3, this._passes.materialTransparent.dispatch(this._materialPassParams)
                }break; case 0: switch (A.pass) {
                  case 0: return this._materialPassParams.subPass =
                    0, this._configureMaterialColorPass(A), this._materialPassParams.ssrParams = A.ssrParams, this._passes.materialIntegratedMesh.dispatch(this._materialPassParams); case 2: return this._materialPassParams.subPass = 2, this._passes.materialIntegratedMesh.dispatch(this._materialPassParams); case 3: return this._materialPassParams.subPass = 3, this._passes.materialIntegratedMesh.dispatch(this._materialPassParams); case 5: return this._passes.highlightIntegratedMesh.dispatch(this._highlightPassParams)
                }
              }return !1
            }; r.notifyDirty =
              function () { this._context.requestRender() }; r.slots = function () { return [3, 5, 0] }; r.initializeRenderContext = function (A) { this._context = A }; r.uninitializeRenderContext = function () { }; r.queryDepthRange = function (A) { const z = { near: Infinity, far: -Infinity }; this._systems.forEach(B => { B = B.queryShadowCasterDepthRange(A); c.isSome(B) && v.union(z, B, z) }); return z }; r._configureMaterialColorPass = function (A) {
                this._materialPassParams.bindShadowMap = z => {
                  A.shadowMap.bind(z); const B = this._materialPassParams.viewTransform; p.add(e,
                    B.worldFromView_TL, B.worldFromView_TH); A.shadowMap.bindView(z, e)
                }; this._materialPassParams.bindAmbientOcclusion = z => A.ssaoHelper.bind(z, A.camera); this._materialPassParams.ambientOcclusionEnabled = !!A.ssaoHelper && A.ssaoHelper.ready; this._materialPassParams.sceneHasOcludees = A.hasOccludees
              }; r._configure = function (A) { this._updateParameters(A, 4 === A.pass || 7 === A.pass || 6 === A.pass ? this._shadowPassParams : 5 === A.pass ? this._highlightPassParams : this._materialPassParams) }; r._updateParameters = function (A, z) {
                const B =
                  A.camera, C = B.viewInverseTransposeMatrix; p.set(e, C[3], C[7], C[11]); x.set(e); p.copy(z.viewTransform.worldFromView_TH, x.high); p.copy(z.viewTransform.worldFromView_TL, x.low); q.fromMat4(z.viewTransform.viewFromCameraRelative_RS, B.viewMatrix); y.copy(z.viewTransform.projFromView, B.projectionMatrix); 0 === z.identifier ? (this._materialPassParams.transparent = 5 === A.slot, this._materialPassParams.integratedMesh = 0 === A.slot, this._materialPassParams.lighting = A.scenelightingData, q.transpose(g, z.viewTransform.viewFromCameraRelative_RS),
                    q.invert(z.transformNormal_ViewFromGlobal, g), n.set(z.cameraNearFar, B.near, B.far)) : 1 === z.identifier ? n.set(z.cameraNearFar, B.near, B.far) : 2 === z.identifier && (z.highlightDepthTexture = A.highlightDepthTexture, h.copy(z.viewport, B.fullViewport)); if (0 === z.identifier || 2 === z.identifier) z.inverseViewport[0] = 1 / B.fullViewport[2], z.inverseViewport[1] = 1 / B.fullViewport[3]; b.copyWithoutVerify(A.sliceHelper.plane, z.slicePlane); p.subtract(z.slicePlane.origin, z.slicePlane.origin, e); z.slicePlaneEnabled = A.sliceHelper.isEnabled;
                this._materialPassParams.slot = A.slot; this._materialPassParams.transparencyPassType = A.transparencyPassType; this._materialPassParams.multipassTerrainParams = A.multipassTerrainParams
              }; w._createClass(k, [{ key: "shadowCastingEnabled", get: function () { return this._materialPassParams.shadowsEnabled }, set: function (A) { this._materialPassParams.shadowsEnabled = A } }, {
                key: "screenSpaceReflectionsEnabled", get: function () { return c.isSome(this._materialPassParams.ssrParams.ssrEnabled) }, set: function (A) {
                  this._materialPassParams.ssrParams.ssrEnabled =
                  !!A
                }
              }, { key: "needsHighlight", get: function () { return 0 < this._passes.highlight.count || 0 < this._passes.highlightIntegratedMesh.count } }]); return k
          }(); const e = l.create(), g = u.create(), x = new t.TwoVectorPosition; a.RenderPassManager = m; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/renderPasses/AllRenderPasses": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/mat3f64 ../../../../../chunks/vec2f64 ../../../../../chunks/vec4f64 ../../../../../chunks/boundedPlane ../shaderLibrary/attributes/VertexPosition.glsl".split(" "),
        function (a, w, c, q, u, y, n) {
          let p = function () { this.viewTransform = new n.VertexPosition.ViewProjectionTransform; this.slicePlane = y.create() }, l = function (d) { function f() { var t = d.apply(this, arguments) || this; t.identifier = 0; t.slicePlaneEnabled = !0; t.transparent = !1; t.integratedMesh = !1; t.transformNormal_ViewFromGlobal = c.create(); t.cameraNearFar = q.create(); t.inverseViewport = q.create(); t.ambientOcclusionEnabled = !0; t.shadowsEnabled = !0; t.sceneHasOcludees = !1; t.transparencyPassType = 3; return t } w._inheritsLoose(f, d); return f }(p),
          h = function (d) { function f() { var t = d.apply(this, arguments) || this; t.identifier = 1; t.cameraNearFar = q.create(); return t } w._inheritsLoose(f, d); return f }(p), b = function (d) { function f() { var t = d.apply(this, arguments) || this; t.identifier = 2; t.inverseViewport = q.create(); t.viewport = u.create(); return t } w._inheritsLoose(f, d); return f }(p); a.HighlightPassParameters = b; a.MaterialPassesParameters = l; a.PassParameters = p; a.ShadowMapPassParameters = h; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/renderPasses/RenderPass": function () {
      define(["exports",
        "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../core/maybe", "../../../../../core/PooledArray"], function (a, w, c, q) {
          let u = function () {
            function n(l, h, b = 0) { this._rctx = l; this._techniqueRepository = h; this._sorting = b; this._draws = new q({ initialSize: 32, allocator: d => d || { material: null, geometry: null, geometryRanges: null, bindDrawParams: null, depthSquaredHint: 0, indexType: 0 } }); this._passBoundTechniques = new Set; this._previouslyBoundMaterials = new Map; this._previouslyBoundDraw = new Map } var p = n.prototype;
            p.submitDraw = function (l, h, b, d, f) { const t = this._draws.pushNew(); t.geometry = h; t.geometryRanges = b; t.material = l; t.bindDrawParams = d; t.depthSquaredHint = f; t.indexType = h.indexed ? c.unwrap(h.vao.indexBuffer).indexType : 0 }; p.dispatch = function (l) {
              const h = this._rctx; this._passBoundTechniques.clear(); this._previouslyBoundMaterials.clear(); this._previouslyBoundDraw.clear(); let b = null; const d = this._draws.length; for (let v = 0; v < d; v++) {
                var f = this._draws.data[v]; const m = f.geometry; var t = f.material.getTechnique(this._techniqueRepository,
                  l, m.parameters); if (t !== b || 3 !== t.configuration.transparencyPassType) h.useProgram(t.program), t.bindPipelineState(h, l.slot), b = t; this._passBoundTechniques.has(t) || (t.bindPass(l), this._passBoundTechniques.add(t)); h.bindVAO(m.vao); this._previouslyBoundMaterials.get(t) !== f.material && (t.bindMaterial(f.material, l), this._previouslyBoundMaterials.set(t, f.material)); this._previouslyBoundDraw.get(t) !== f.bindDrawParams && (t.bindDraw(f.bindDrawParams), this._previouslyBoundDraw.set(t, f.bindDrawParams)); t = f.geometryRanges;
                const e = t.length; if (0 !== f.indexType) { const g = y.get(f.indexType); for (let x = 0; x < e; x += 2)h.drawElements(m.primitiveType, t[x + 1], f.indexType, t[x] * g) } else for (f = 0; f < e; f += 2)h.drawArrays(m.primitiveType, t[f], t[f + 1])
              } return 0 < d
            }; p.prepareSubmit = function () { this._draws.clear() }; p.finishSubmit = function () { const l = 0 === this._sorting ? 1 : -1; this._draws.sort((h, b) => { const d = l * (h.depthSquaredHint - b.depthSquaredHint); return 0 !== d ? d : h.geometry.vao.size - b.geometry.vao.size }) }; w._createClass(n, [{ key: "count", get: function () { return this._draws.length } }]);
            return n
          }(); const y = new Map; y.set(5121, 1); y.set(5123, 2); y.set(5125, 4); a.RenderPass = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/HighlightHelper": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/vec4 ../../../../chunks/vec4f32 ../../../../chunks/vec4f64 ../../support/debugFlags ./DefaultVertexAttributeLocations ./DefaultVertexBufferLayouts ./glUtil3D ../shaders/HighlightTechnique ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../webgl/Util ../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          return function () {
            function v(e, g) {
            this._techniqueRep = e; this._rctx = g; this.viewportToRestore = u.create(); this.defaultOptions = { color: q.fromValues(1, 0, 1, 1), haloColor: q.fromValues(1, 0, 1, 1), haloOpacity: 1, fillOpacity: .2, haloOpacityOccluded: .25, fillOpacityOccluded: .05, shadowColor: q.fromValues(1, 0, 1, 1), shadowOpacity: .15, occludedShadowOpacity: .075 }; this._grid = {
              coverageMipmap: null, vao: null, verticalCellCount: 0, horizontalCellCount: 0, cellPixelSize: 0, mipmapLevels: 0, viewportWidth: 0,
              viewportHeight: 0
            }
            } var m = v.prototype; m.assertResources = function () {
              if (!this.quadVAO) {
              this.quadVAO = l.createQuadVAO(this._rctx); var e = { colorTarget: 0, depthStencilTarget: 0, width: 0, height: 0 }, g = { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9729, wrapMode: 33071, width: 0, height: 0 }; this.blur0Fbo = new d(this._rctx, e, g); this.blur1Fbo = new d(this._rctx, e, g); e = new h.HighlightCompositionTechniqueConfiguration; e.highlightStage = 0; e.gridOptimization = !1; this.blurTechnique = this._techniqueRep.acquire(h.HighlightCompositionTechnique,
                e); e.highlightStage = 0; e.gridOptimization = !0; this.blurGridTechnique = this._techniqueRep.acquire(h.HighlightCompositionTechnique, e); e.highlightStage = 1; e.gridOptimization = !1; this.applyTechnique = this._techniqueRep.acquire(h.HighlightCompositionTechnique, e); e.highlightStage = 1; e.gridOptimization = !0; this.applyGridTechnique = this._techniqueRep.acquire(h.HighlightCompositionTechnique, e); e.highlightStage = 2; e.gridOptimization = !1; this.downsampleTechnique = this._techniqueRep.acquire(h.HighlightCompositionTechnique,
                  e)
              }
            }; m.dispose = function () { if (this._grid.coverageMipmap) for (let e = 1; e < this._grid.coverageMipmap.length; e++)this._grid.coverageMipmap[e].dispose(); this._grid.vao && this._grid.vao.dispose(!0); this.quadVAO && (this.quadVAO.dispose(!0), this.quadVAO = null); this.blur0Fbo = w.disposeMaybe(this.blur0Fbo); this.blur1Fbo = w.disposeMaybe(this.blur1Fbo) }; m.setDefaultOptions = function (e) { this.defaultOptions = e }; m.render = function (e, g, x) {
              var k = e.pixelRatio; const r = y.HIGHLIGHTS_GRID_OPTIMIZATION_ENABLED, A = this._rctx; this.assertResources();
              c.copy(this.viewportToRestore, e.fullViewport); var z = Math.ceil(e.fullWidth / k); k = Math.ceil(e.fullHeight / k); this.blur0Fbo.resize(z, k); this.blur1Fbo.resize(z, k); A.bindVAO(this.quadVAO); e = null; const B = r ? this.blurGridTechnique : this.blurTechnique; B.bindPipelineState(A); A.useProgram(B.program); r ? (this._gridUpdateResources(g, 32), this._gridComputeMipmap(), e = this._grid.vao, B.program.bindTexture(this._grid.coverageMipmap[this._grid.mipmapLevels].colorTexture, "coverageTex")) : e = this.quadVAO; A.bindVAO(e); A.bindFramebuffer(this.blur0Fbo);
              A.setViewport(0, 0, z, k); A.setClearColor(0, 0, 0, 0); A.clear(16384); B.program.bindTexture(g.colorTexture, "tex"); B.program.setUniform2f("blurSize", 1 / z, 0); A.drawArrays(B.primitiveType, 0, f.vertexCount(e, "geometry")); A.bindFramebuffer(this.blur1Fbo); A.clear(16384); B.program.bindTexture(this.blur0Fbo.colorTexture, "tex"); B.program.setUniform2f("blurSize", 0, 1 / k); A.drawArrays(B.primitiveType, 0, f.vertexCount(e, "geometry")); z = r ? this.applyGridTechnique : this.applyTechnique; A.bindFramebuffer(x); z.bindPipelineState(A);
              A.setViewport(this.viewportToRestore[0], this.viewportToRestore[1], this.viewportToRestore[2], this.viewportToRestore[3]); A.useProgram(z.program); z.program.bindTexture(this.blur1Fbo.colorTexture, "tex"); z.program.bindTexture(g.colorTexture, "origin"); r && z.program.bindTexture(this._grid.coverageMipmap[this._grid.mipmapLevels].colorTexture, "coverageTex"); z.bindApplyPass(this.defaultOptions); A.drawArrays(z.primitiveType, 0, f.vertexCount(e, "geometry")); A.bindVAO(null)
            }; m._gridUpdateResources = function (e, g) {
              const x =
                this._rctx, k = this._grid; var r = !1; null === k.coverageMipmap && (k.coverageMipmap = [e], r = !0); if (k.viewportWidth !== e.width || k.viewportHeight !== e.height) r = !0, k.viewportWidth = e.width, k.viewportHeight = e.height; k.coverageMipmap[0] = e; k.cellPixelSize !== g && (k.cellPixelSize = g, r = !0); if (r) {
                  for (g = 1; g < k.coverageMipmap.length; g++)k.coverageMipmap[g].dispose(); k.mipmapLevels = Math.ceil(Math.log(k.cellPixelSize) * Math.LOG2E); k.coverageMipmap.length = k.mipmapLevels + 1; for (g = 0; g < k.mipmapLevels; g++)r = k.coverageMipmap[g], k.coverageMipmap[g +
                    1] = new d(x, { colorTarget: 0, depthStencilTarget: 0, width: Math.ceil(r.width / 2), height: Math.ceil(r.height / 2) }, { target: 3553, pixelFormat: 6407, dataType: 33635, samplingMode: 9729, wrapMode: 33071, width: Math.ceil(r.width / 2), height: Math.ceil(r.height / 2) })
                } r = Math.ceil(e.height / k.cellPixelSize); var A = Math.ceil(e.width / k.cellPixelSize); if (!k.vao || k.verticalCellCount !== r || k.horizontalCellCount !== A) {
                k.verticalCellCount = r; k.horizontalCellCount = A; e = r + 1; g = A + 1; r = 1 / r; A = 1 / A; const z = new Float32Array(24 * e * g); let B = 0; for (let C =
                  0; C < e; C++)for (let D = 0; D < g; D++)z[B + 0] = (D - .5) * A * 2 - 1, z[B + 1] = (C - .5) * r * 2 - 1, z[B + 2] = D * A, z[B + 3] = C * r, z[B + 4] = (D + .5) * A * 2 - 1, z[B + 5] = (C - .5) * r * 2 - 1, z[B + 6] = D * A, z[B + 7] = C * r, z[B + 8] = (D - .5) * A * 2 - 1, z[B + 9] = (C + .5) * r * 2 - 1, z[B + 10] = D * A, z[B + 11] = C * r, z[B + 12] = (D - .5) * A * 2 - 1, z[B + 13] = (C + .5) * r * 2 - 1, z[B + 14] = D * A, z[B + 15] = C * r, z[B + 16] = (D + .5) * A * 2 - 1, z[B + 17] = (C - .5) * r * 2 - 1, z[B + 18] = D * A, z[B + 19] = C * r, z[B + 20] = (D + .5) * A * 2 - 1, z[B + 21] = (C + .5) * r * 2 - 1, z[B + 22] = D * A, z[B + 23] = C * r, B += 24; k.vao && k.vao.dispose(!0); k.vao = new t(x, n.Default3D, { geometry: p.Pos2Tex }, {
                    geometry: b.createVertex(x,
                      35044, z)
                  })
                }
            }; m._gridComputeMipmap = function () {
              const e = this._rctx, g = this._grid, x = this.downsampleTechnique.program; this.downsampleTechnique.bindPipelineState(e); e.bindVAO(this.quadVAO); e.useProgram(x); for (let k = 0; k < g.mipmapLevels; k++) {
                e.bindFramebuffer(g.coverageMipmap[k + 1]); x.bindTexture(g.coverageMipmap[k].colorTexture, "tex"); const r = g.coverageMipmap[k + 1].width, A = g.coverageMipmap[k + 1].height; x.setUniform2f("invFramebufferDim", 1 / r, 1 / A); e.setViewport(0, 0, r, A); e.drawArrays(5, 0, f.vertexCount(this.quadVAO,
                  "geometry"))
              }
            }; a._createClass(v, [{ key: "profilingCallback", get: function () { return y.HIGHLIGHTS_PROFILE_TO_CONSOLE ? e => console.log(e) : null } }, { key: "gpuMemoryUsage", get: function () { let e = (w.isSome(this.blur0Fbo) ? this.blur0Fbo.gpuMemoryUsage : 0) + (w.isSome(this.blur1Fbo) ? this.blur1Fbo.gpuMemoryUsage : 0); if (this._grid.coverageMipmap) for (const g of this._grid.coverageMipmap) e += g.gpuMemoryUsage; return e } }, { key: "test", get: function () { return { coverage: this._grid.coverageMipmap, blur: [this.blur0Fbo, this.blur1Fbo] } } }]);
            return v
          }()
        })
    }, "esri/views/3d/webgl-engine/shaders/HighlightTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/Program ../../../../chunks/HighlightComposition.glsl ../../../webgl/renderState".split(" "), function (a, w, c, q, u, y, n, p, l, h, b) {
        y = function (d) {
          function f() {
            return d.apply(this,
              arguments) || this
          } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build(this.configuration); return new l.Program(v.rctx, m, p.Default3D) }; t.bindApplyPass = function (v) { this.program.setUniform4fv("color", v.color); this.program.setUniform4fv("haloColor", v.haloColor); this.program.setUniform1f("outlineSize", 8.6); this.program.setUniform1f("blurSize", .4); this.program.setUniform4f("opacities", v.haloOpacity, v.haloOpacityOccluded, v.fillOpacity, v.fillOpacityOccluded) };
          t.initializePipeline = function () { return 1 === this.configuration.highlightStage ? b.makePipelineState({ blending: b.separateBlendingParams(770, 1, 771, 771), colorWrite: b.defaultColorWriteParams }) : b.makePipelineState({ colorWrite: b.defaultColorWriteParams }) }; c._createClass(f, [{ key: "primitiveType", get: function () { return this.configuration.gridOptimization ? 4 : 5 } }]); return f
        }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(h.HighlightCompositionShader, () => new Promise((d, f) => a(["./HighlightComposition.glsl"],
          d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.highlightStage = 0; t.gridOptimization = !1; return t } c._inheritsLoose(f, d); return f }(n.ShaderTechniqueConfiguration); q.__decorate([n.parameter({ count: 3 })], u.prototype, "highlightStage", void 0); q.__decorate([n.parameter()], u.prototype, "gridOptimization", void 0); w.HighlightCompositionTechnique = y; w.HighlightCompositionTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/chunks/HighlightComposition.glsl": function () {
      define(["exports",
        "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"], function (a, w, c) {
          function q(y) {
            const n = new c.ShaderBuilder, p = n.vertex.code, l = n.fragment.code; n.attributes.add("position", "vec2"); 2 === y.highlightStage && (p.add(w.glsl`void main() {
gl_Position = vec4(vec2(1.0) - position * 2.0, 0.0, 1.0);
}`), n.fragment.uniforms.add("tex", "sampler2D"), n.fragment.uniforms.add("invFramebufferDim", "vec2"), l.add(w.glsl`void main() {
vec2 coord = gl_FragCoord.xy * invFramebufferDim;
vec4 value = texture2D(tex, coord);
float mx = floor(max(value.g, value.b));
gl_FragColor = vec4(ceil(value.r), mx, mx, 1.0);
}`)); 0 === y.highlightStage && (n.attributes.add("uv0", "vec2"), y.gridOptimization ? (n.vertex.uniforms.add("coverageTex", "sampler2D"), n.fragment.uniforms.add("blurSize", "vec2"), n.varyings.add("blurCoordinate", "vec3")) : (n.vertex.uniforms.add("blurSize", "vec2"), n.varyings.add("blurCoordinates[5]", "vec2")), p.add(w.glsl`
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
      ${y.gridOptimization ? w.glsl`
      vec4 cov = texture2D(coverageTex, uv0);
      if (cov.r == 0.0) {
        gl_Position = vec4(0.0);
      }
      blurCoordinate = vec3(gl_Position.xy * 0.5 + vec2(0.5), max(cov.g, cov.b));
      `: w.glsl`
      vec2 uv = position.xy * 0.5 + vec2(0.5);
      blurCoordinates[0] = uv;
      blurCoordinates[1] = uv + blurSize * 1.407333;
      blurCoordinates[2] = uv - blurSize * 1.407333;
      blurCoordinates[3] = uv + blurSize * 3.294215;
      blurCoordinates[4] = uv - blurSize * 3.294215;
          `}
    }`), n.fragment.uniforms.add("tex", "sampler2D"), l.add(w.glsl`
    void main() {
      ${y.gridOptimization ? w.glsl`
          vec2 uv = blurCoordinate.xy;
          vec4 center = texture2D(tex, uv);

          // do not blur if no pixel or all pixels in neighborhood are set
          if (blurCoordinate.z == 1.0) {
            gl_FragColor = center;
          } else {
            vec4 sum = vec4(0.0);
            sum += center * 0.204164;
            sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;
            sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;
            sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;
            sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;
            gl_FragColor = sum;
          }`: w.glsl`
          vec4 sum = vec4(0.0);
          sum += texture2D(tex, blurCoordinates[0]) * 0.204164;
          sum += texture2D(tex, blurCoordinates[1]) * 0.304005;
          sum += texture2D(tex, blurCoordinates[2]) * 0.304005;
          sum += texture2D(tex, blurCoordinates[3]) * 0.093913;
          sum += texture2D(tex, blurCoordinates[4]) * 0.093913;
          gl_FragColor = sum;`}
    }`)); 1 === y.highlightStage && (n.varyings.add("uv", "vec2"), y.gridOptimization && (n.attributes.add("uv0", "vec2"), n.vertex.uniforms.add("coverageTex", "sampler2D")), p.add(w.glsl`
      void main() {
        ${y.gridOptimization ? w.glsl`
            vec4 cov = texture2D(coverageTex, uv0);
            // if no highlight pixel set in this block, hide block
            if (cov.r == 0.0) {
              gl_Position = vec4(0.0);
              return;
            }`: ""}
        gl_Position = vec4(position, 0.0, 1.0);
        uv = position.xy * 0.5 + vec2(0.5);
      }`), n.fragment.uniforms.add("tex", "sampler2D"), n.fragment.uniforms.add("origin", "sampler2D"), n.fragment.uniforms.add("color", "vec4"), n.fragment.uniforms.add("haloColor", "vec4"), n.fragment.uniforms.add("outlineSize", "float"), n.fragment.uniforms.add("blurSize", "float"), n.fragment.uniforms.add("opacities", "vec4"), l.add(w.glsl`void main() {
vec4 blurredHighlightValue = texture2D(tex, uv);
float highlightIntensity = blurredHighlightValue.a;
if (highlightIntensity == 0.0) {
discard;
}
vec4 origin_color = texture2D(origin, uv);
float outlineIntensity;
float fillIntensity;
if (blurredHighlightValue.g > blurredHighlightValue.b) {
outlineIntensity = haloColor.w * opacities[1];
fillIntensity = color.w * opacities[3];
}
else {
outlineIntensity = haloColor.w * opacities[0];
fillIntensity = color.w * opacities[2];
}
float inner = 1.0 - outlineSize / 9.0;
float outer = 1.0 - (outlineSize + blurSize) / 9.0;
float outlineFactor = smoothstep(outer, inner, highlightIntensity);
float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;
float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;
gl_FragColor = vec4(mix(haloColor.rgb, color.rgb, fillFactor), intensity);
}`)); return n
          } const u = Object.freeze({ __proto__: null, build: q }); a.HighlightCompositionShader = u; a.build = q
        })
    }, "esri/views/3d/webgl-engine/lib/OffscreenRendering": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "./RenderTargetHelper"], function (a, w, c, q) {
        let u = function () {
          function p(h, b) {
          this._rctx = h; this._compositingHelper = b; this._mainColorTarget = 0; this._dimensions = { width: 4, height: 4 }; this._needLastFrameColorTexture = !1; this._background = {
            type: "color", color: [0,
              0, 0, 1]
          }; const d = "webgl2" === h.webglVersion, f = this._renderTargetHelper = new q.RenderTargetHelper(h); this.mainColorTargets = [f.registerColorTarget({ name: "mainColorTarget0" }), f.registerColorTarget({ name: "mainColorTarget1" })]; this.frontFaceTarget = f.registerColorTarget({ name: "frontFaceTarget" }); h = t => f.registerColorTarget({ name: t, dataType: 5126, internalFormat: d ? 34836 : 6408, samplingMode: 9728 }); this.colorFloatTarget = h("colorFloatTarget"); this.alphaFloatTarget = h("alphaFloatTarget"); this.mainDepth = f.registerDepthTarget({ name: "mainDepth" });
            this.linearDepth = f.registerColorTarget({ name: "linearDepth", samplingMode: 9728 }); this.terrainLinearDepth = f.registerColorTarget({ name: "terrainLinearDepth" }); this.geometryLinearDepth = f.registerColorTarget({ name: "geometryLinearDepth" }); this.normal = f.registerColorTarget({ name: "normal" }); this.highlight = f.registerColorTarget({ name: "highlight", internalFormat: d ? 32854 : 6408, dataType: 32819 }); this.hudVisibility = f.registerColorTarget({ name: "hudVisibility", internalFormat: d ? 32854 : 6408, dataType: 32819 }); this.tmpColor =
              f.registerColorTarget({ name: "tmpColor" }); this.tmpDepth = f.registerDepthTarget({ name: "tmpDepth" }); this.hudColor = f.registerColorTarget({ name: "hudColor" })
          } var l = p.prototype; l.dispose = function () { this._renderTargetHelper.dispose() }; l.getFramebuffer = function (h, b) { return this._renderTargetHelper.getFramebuffer(this._dimensions, h, b) }; l.advanceCurrentRenderTarget = function () { this._mainColorTarget = 0 === this._mainColorTarget && this._needLastFrameColorTexture ? 1 : 0 }; l.initializeFrame = function (h) {
            const b = this._rctx;
            this._dimensions.width = h.fullWidth; this._dimensions.height = h.fullHeight; this.bindTarget(this.currentColorTarget, this.mainDepth); b.setClearStencil(0); h = this._background.color; b.setClearColor(h[0] * h[3], h[1] * h[3], h[2] * h[3], h[3]); b.clearSafe(17664)
          }; l.composite = function () { c.isSome(this.colorTexture) && this._compositingHelper.composite(this.colorTexture, 0) }; l.renderTmpAndCompositeToMain = function (h, b, d = !1) {
            this.renderToTargets(h, this.tmpColor, d ? this.tmpDepth : this.mainDepth, y); this._compositingHelper.composite(this.getColorTexture(this.tmpColor),
              b)
          }; l.renderHUDVisibility = function (h, b = !1) { this.renderToTargets(h, this.hudVisibility, b ? this.tmpDepth : this.mainDepth, n) }; l.compositeTransparentTerrainOntoHUDVisibility = function () { this.renderToTargets(() => this._compositingHelper.composite(this.getColorTexture(this.tmpColor), 0, 1, 1), this.hudVisibility, this.tmpDepth) }; l.renderOITPass = function (h, b, d) {
            let f, t; switch (b) {
              case 0: f = this.colorFloatTarget; t = [0, 0, 0, 0]; break; case 1: f = this.alphaFloatTarget; t = [1, 1, 1, 1]; break; case 2: f = this.frontFaceTarget, t = [0, 0, 0,
                0]
            }d ? this.renderToTargets(h, f, this.tmpDepth, t, !0, !0) : this.renderToTargets(h, f, this.mainDepth, t, !1)
          }; l.compositeTransparentTerrainOntoMain = function () { this.bindFramebuffer(); this._compositingHelper.composite(this.getColorTexture(this.tmpColor), 2) }; l.compositeOccludedOntoMain = function (h) { this.bindFramebuffer(); this._compositingHelper.composite(this.getColorTexture(this.tmpColor), 2, h) }; l.compositeTransparentOntoOpaque = function (h) {
            h ? (this.bindTarget(this.hudColor, this.tmpDepth), this._rctx.setClearColor(0,
              0, 0, 1E-13), this._rctx.clearSafe(16384)) : this.bindFramebuffer(); this._compositingHelper.compositeTransparent(this.getColorTexture(this.colorFloatTarget), this.getColorTexture(this.alphaFloatTarget), this.getColorTexture(this.frontFaceTarget))
          }; l.bindFramebuffer = function () { this._rctx.bindFramebuffer(this.framebuffer) }; l.renderDepthDetached = function (h) { this.bindTarget(this.currentColorTarget); h(); this.bindTarget(this.currentColorTarget, this.mainDepth) }; l.disposeTarget = function (h) { this._renderTargetHelper.disposeTargetResource(h) };
          l.renderToTargets = function (h, b, d, f, t = !1, v = !1) { const m = this._rctx; b = this.bindTarget(b, d); d = 0; f && (m.setClearColor(f[0], f[1], f[2], Math.max(1E-13, f[3])), d |= 16384); t && (d |= 256); !1 === v ? v = 0 : (!0 === v && (v = 255), d |= 1024); d && m.clearSafe(d, v); h(); m.gl.flush(); this.bindTarget(this.currentColorTarget, this.mainDepth); return b }; l.bindTarget = function (h, b) { h = this._renderTargetHelper.getFramebuffer(this._dimensions, h, b); this._rctx.bindFramebuffer(h); return h }; l.getColorTexture = function (h) {
            return this._renderTargetHelper.getColorTexture(h,
              this._dimensions)
          }; w._createClass(p, [{ key: "width", get: function () { return this._dimensions.width } }, { key: "height", get: function () { return this._dimensions.height } }, { key: "background", get: function () { return this._background }, set: function (h) { this._background = h } }, { key: "currentColorTarget", get: function () { return this.mainColorTargets[this._mainColorTarget] } }, { key: "previousColorTarget", get: function () { return this.mainColorTargets[1 - this._mainColorTarget] } }, {
            key: "framebuffer", get: function () {
              return this.getFramebuffer(this.currentColorTarget,
                this.mainDepth)
            }
          }, { key: "colorTexture", get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.currentColorTarget) } }, { key: "depthTexture", get: function () { return this._renderTargetHelper.getAllocatedDepthTexture(this.mainDepth) } }, { key: "linearDepthTexture", get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.linearDepth) } }, { key: "terrainLinearDepthTexture", get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.terrainLinearDepth) } }, {
            key: "geometryLinearDepthTexture",
            get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.geometryLinearDepth) }
          }, { key: "lastFrameColorTexture", get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.previousColorTarget) } }, { key: "normalTexture", get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.normal) } }, { key: "highlightTexture", get: function () { return this._renderTargetHelper.getAllocatedColorTexture(this.highlight) } }, { key: "hudVisibilityTexture", get: function () { return this.getColorTexture(this.hudVisibility) } },
          { key: "tmpColorTexture", get: function () { return this.getColorTexture(this.tmpColor) } }, { key: "hudColorTexture", get: function () { return this.getColorTexture(this.hudColor) } }, { key: "mainColorTexture", get: function () { return this.getColorTexture(this.currentColorTarget) } }, {
            key: "needLastFrameColorTexture", get: function () { return this._needLastFrameColorTexture }, set: function (h) {
            !h && this._needLastFrameColorTexture && (this._mainColorTarget = 0, this.disposeTarget(this.mainColorTargets[1])); this._needLastFrameColorTexture =
              h
            }
          }, { key: "gpuMemoryUsage", get: function () { let h = 0; this._renderTargetHelper && (h += this._renderTargetHelper.gpuMemoryUsage); return h } }]); return p
        }(); const y = [0, 0, 0, 0], n = [0, 1, 0, 1]; a.OffscreenRendering = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/RenderTargetHelper": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/uid ../../../webgl/FramebufferObject ../../../webgl/Renderbuffer ../../../webgl/Texture ../../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p) {
          const l = { dataType: 5121, internalFormat: 6408 }, h = {}; let b = function () {
            function d(t) { this.rctx = t; this._activeTargets = new Set; this._depthTextures = new Map; this._depthBuffers = new Map; this._colorTextures = new Map; this._framebuffers = new Map; this.depthTextureSupported = t.capabilities.depthTexture } var f = d.prototype; f.dispose = function () {
              this._depthBuffers.forEach(t => t.dispose()); this._depthBuffers.clear(); this._depthTextures.forEach(t => t.dispose()); this._depthTextures.clear(); this._colorTextures.forEach(t =>
                t.dispose()); this._colorTextures.clear(); this._framebuffers.forEach(t => t.dispose()); this._framebuffers.clear()
            }; f.disposeTargetResource = function (t) { t = t.id; this._activeTargets.has(t) && (this._activeTargets.delete(t), this.disposeWithFramebuffers(this._depthTextures, t), this.disposeWithFramebuffers(this._depthBuffers, t), this.disposeWithFramebuffers(this._colorTextures, t)) }; f.disposeWithFramebuffers = function (t, v) {
              const m = t.get(v); m && (this._framebuffers.forEach((e, g) => {
                if (e.colorAttachment === m || e.depthStencilAttachment ===
                  m) e.detachAll(), e.dispose(), this._framebuffers.delete(g)
              }), m.dispose(), t.delete(v))
            }; f.getDepthTexture = function (t, v) { if (!this.depthTextureSupported) return null; let m = this._depthTextures.get(t.id); !m || m.descriptor.width === v.width && m.descriptor.height === v.height || (m.dispose(), m = null); m || (m = new n(this.rctx, { target: 3553, pixelFormat: 34041, dataType: 34042, samplingMode: 9728, wrapMode: 33071, width: v.width, height: v.height }), this._depthTextures.set(t.id, m), this._activeTargets.add(t.id)); return m }; f.getAllocatedDepthTexture =
              function (t) { return this._depthTextures.get(t.id) }; f.getDepthBuffer = function (t, v) { if (this.depthTextureSupported) return null; let m = this._depthBuffers.get(t.id); m ? m.descriptor.width === v.width && m.descriptor.height === v.height || m.resize(v.width, v.height) : (m = new y(this.rctx, { internalFormat: 34041, ...v }), this._depthBuffers.set(t.id, m), this._activeTargets.add(t.id)); return m }; f.getColorTexture = function (t, v) {
                let m = this._colorTextures.get(t.id); !m || m.descriptor.width === v.width && m.descriptor.height === v.height ||
                  (m.dispose(), m = null); m || (m = new n(this.rctx, { target: 3553, pixelFormat: 6408, internalFormat: t.internalFormat, dataType: t.dataType, samplingMode: null != t.samplingMode ? t.samplingMode : 9729, wrapMode: 33071, width: v.width, height: v.height }), this._colorTextures.set(t.id, m), this._activeTargets.add(t.id)); return m
              }; f.getAllocatedColorTexture = function (t) { return this._colorTextures.get(t.id) }; f.registerDepthTarget = function (t = {}) { return { id: q.generateUID(), ...h, ...t } }; f.registerColorTarget = function (t = {}) {
                return {
                  id: q.generateUID(),
                  ...l, ...t
                }
              }; f.getFramebuffer = function (t, v, m) {
                const e = this.getKey(v, m); let g = this._framebuffers.get(e); v = this.getColorTexture(v, t); if (this.depthTextureSupported) {
                  var x = m ? this.getDepthTexture(m, t) : void 0; if (!g) return g = c.isSome(m) ? new u(this.rctx, { colorTarget: 0, depthStencilTarget: 4 }, v, x) : new u(this.rctx, { colorTarget: 0, depthStencilTarget: 0 }, v), this._framebuffers.set(e, g), g; if (g.width !== t.width || g.height !== t.height || g.colorTexture !== v || g.depthStencilTexture !== x) g.detachAll(), g.resize(t.width, t.height),
                    g.attachColorTexture(v), g.attachDepthStencilTexture(x); return g
                } x = m ? this.getDepthBuffer(m, t) : void 0; if (!g) return g = new u(this.rctx, { colorTarget: 0, depthStencilTarget: m ? 3 : 0 }, v, x), this._framebuffers.set(e, g), g; if (g.width !== t.width || g.height !== t.height || g.colorTexture !== v) g.detachAll(), g.resize(t.width, t.height), g.attachColorTexture(v), g.attachDepthStencilBuffer(x); return g
              }; f.getKey = function (t, v) { return `${t.id}_${v ? v.id : "X"}_${t.name}${v ? "_" + v.name : ""}` }; w._createClass(d, [{
                key: "gpuMemoryUsage", get: function () {
                  let t =
                    0; const v = new Set, m = e => { v.has(e) || (v.add(e), t += p.getGpuMemoryUsage(e)) }; this._depthTextures.forEach(m); this._colorTextures.forEach(m); this._depthBuffers.forEach(m); return t
                }
              }]); return d
          }(); a.RenderTargetHelper = b; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/RenderPluginManager": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/promiseUtils", "./depthRange", "./Util"], function (a, w, c, q, u) {
        let y = function () {
          function p(h) {
          this.context =
            h; this.renderPlugins = []; this.slots = []; for (h = 0; 23 > h; ++h)this.slots[h] = []
          } var l = p.prototype; l.add = function (h, b, d) { const f = () => { this.renderPlugins.push(b); for (const t of h) this.slots[t].push(b); this.context.requestRender() }; d = b.initializeRenderContext(this.context, d); if (c.isPromise(d)) return d.then(f); f() }; l.remove = function (h) {
            var b = this.renderPlugins.length; this.renderPlugins = this.renderPlugins.filter(d => d !== h); u.assert(this.renderPlugins.length < b, "Removing non-added render plugin"); for (b = 0; b < this.slots.length; ++b)this.slots[b] =
              this.slots[b].filter(d => d !== h); h.uninitializeRenderContext(); this.context.requestRender()
          }; l.prepareRender = function (h, b) { for (const d of this.renderPlugins) d.prepareRender && d.prepareRender(h, b) }; l.render = function () { const h = this.slots[this.context.renderContext.slot]; let b = !1; for (const d of h) d.canRender && d.render(this.context.renderContext) && (b = !0); return b }; l.queryDepthRange = function (h) {
            const b = n; b.near = Infinity; b.far = -Infinity; for (const d of this.renderPlugins) if (d.queryDepthRange) {
              const f = d.queryDepthRange(h);
              f && q.union(b, f, b)
            } return b
          }; w._createClass(p, [{ key: "needsHighlight", get: function () { return this.renderPlugins.some(h => h.needsHighlight) } }, { key: "needsLinearDepth", get: function () { return this.renderPlugins.some(h => h.needsLinearDepth) } }, { key: "needsLaserlineWithContrastControl", get: function () { const h = this.slots[15]; return !!h && 0 < h.length } }, { key: "renderOccludedFlags", get: function () { let h = 0; this.renderPlugins.forEach(b => { b.renderOccludedFlags && (h |= b.renderOccludedFlags) }); return h } }]); return p
        }(); const n =
          { near: 0, far: 0 }; a.RenderPluginManager = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/ShadowAccumulator": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/arrayUtils ../../../../core/Handles ../../../../core/mathUtils ../../../../core/maybe ../../../../core/reactiveUtils ../../../../core/accessorSupport/decorators/property ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../webgl/BufferObject ../../../webgl/FramebufferObject ../../../webgl/checkWebGLError ../../../webgl/enums ../../../../chunks/builtins ../../../webgl/Texture ../../../webgl/VertexArrayObject ./Camera ./depthRange ./glUtil3D ./ShadowCastRenderer ./ShadowMap ./Util ../../../../chunks/ShadowCast.glsl ../shaders/ShadowCastTechnique ../../../support/Scheduler ../../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G) {
          var I; a.ShadowAccumulator = I = function (R) {
            function S(T, da, Y, fa, ha, ka) {
              var ea = R.call(this, {}) || this; ea._rctx = T; ea._stage = Y; ea._prepareForShadowMapPass = fa; ea._renderToShadowMap = ha; ea._requestRender = ka; ea._progress = 0; ea._sampleCount = 0; ea._cachedCamera = new E; ea._contentCamera = new E; ea._enabled = !1; ea._cachedLightDirections = []; ea._depthRange = H.ZERO; ea._previewing = !1; ea._handles = new y; ea._cameraForcedForScreenshot = !1; ea._shadowMap =
                new F(T, Y.viewingMode); ea._shadowMap.enabled = !0; ea._vao = J.createQuadVAO(T); ea._fbo = new r(T, { colorTarget: 0, depthStencilTarget: 0, width: 0, height: 0 }, { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9729, wrapMode: 33071, width: 0, height: 0 }); ea._accumulationParams = { camera: ea._cachedCamera, linearDepthTexture: null, shadowMap: ea._shadowMap, inverseView: v.create(), projInfo: x.create(), zScale: m.create() }; ea._accumulationRenderer = new M.ShadowCastRenderer(da, T, w._assertThisInitialized(ea), ka); ea._handles.add(ea._stage.resourceController.scheduler.registerTask(N.TaskPriority.SHADOW_ACCUMULATOR,
                  w._assertThisInitialized(ea))); ea._handles.add(l.react(() => Y.renderView, ba => { ea._handles.remove(I.renderViewHandleKey); p.isNone(ba) || ea._handles.add(ba.events.on("force-camera-for-screenshot", () => ea._cameraForcedForScreenshot = !0), I.renderViewHandleKey) }, l.syncAndInitial)); return ea
            } w._inheritsLoose(S, R); var Q = S.prototype; Q.normalizeCtorArgs = function () { return {} }; Q.runTask = function (T) {
              for (this._prepareForShadowMapPass(this._cachedCamera, this._contentCamera); !T.done && !this._isDoneAccumulating;)this._accumulateShadow(),
                T.madeProgress(); this._requestRender()
            }; Q.accumulateFixedSamples = function () { if (this.isAccumulating && this._canAccumulate) { (this._previewing || 0 === this._progress || this._cameraForcedForScreenshot) && this._clear(); var T = this._cameraForcedForScreenshot ? this._sampleCount : Math.min(I.previewSamples, this._sampleCount - this._progress); for (let da = 0; da < T; ++da)this._accumulateShadow(); this._cameraForcedForScreenshot = !1 } }; Q.render = function () { this._accumulationRenderer.render() }; Q.dispose = function () {
              this._stop(); this._handles.destroy();
              this._accumulationRenderer = p.disposeMaybe(this._accumulationRenderer); this._shadowMap = p.disposeMaybe(this._shadowMap); this._fbo = p.disposeMaybe(this._fbo); this._vao = p.disposeMaybe(this._vao); this._accumulationTechnique = p.disposeMaybe(this._accumulationTechnique); this._sampleCount = this._cachedLightDirections.length = 0
            }; Q.setOptions = function (T) {
            void 0 !== T.enabled && this._setEnabled(T.enabled); void 0 !== T.previewing && this.setPreviewing(T.previewing); void 0 !== T.lightDirections && this.setLightDirections(T.lightDirections);
              this._accumulationRenderer.setOptions(T)
            }; Q.setPreviewing = function (T) { this._previewing !== T && (this._previewing = T, this._requestRenderIfEnabled()) }; Q.setLightDirections = function (T) { this._lightDirections = T }; Q.setAccumulationDependencies = function (T, da, Y, fa) { this._accumulationParams.linearDepthTexture = T; this._depthRange = da; this._updateCamera(Y); this._contentCamera = fa; this.notifyChange("_canAccumulate") }; Q.readAccumulatedShadow = function (T, da) {
              if (!this._isActive || 1 > this._progress || 0 > T || T > this._fbo.width ||
                0 > da || da > this._fbo.height) return 0; const Y = O; this._fbo.readPixels(T, da, 1, 1, 6408, 5121, Y); return Y[0] / this._progress
            }; Q._start = function () { this._progress = 0; this._enabled = !0 }; Q._stop = function () { this._enabled = !1 }; Q._invalidate = function () { this._progress = 0; this._requestRenderIfEnabled() }; Q._clear = function () { this._rctx.bindFramebuffer(this._fbo); this._rctx.setClearColor(0, 0, 0, 0); this._rctx.clearSafe(16384); this._progress = 0 }; Q._accumulateShadow = function () {
              this._renderToShadowMap(this._shadowMap, this._lightDirections[this._progress],
                this._cachedCamera, this._depthRange); this._rctx.bindFramebuffer(this._fbo); const T = this.accumulationTechnique; this._rctx.useProgram(T.program); T.bindPipelineState(this._rctx); T.bindPass(this._accumulationParams); this._rctx.bindVAO(this._vao); this._rctx.drawArrays(T.primitiveType, 0, G.vertexCount(this._vao, "geometry")); this._progress++
            }; Q._updateCamera = function (T) {
              if (!T.equals(this._cachedCamera)) {
                var { fullWidth: da, fullHeight: Y, projectionMatrix: fa, viewMatrix: ha, center: ka } = T; this._cachedCamera.copyFrom(T);
                this._fbo.resize(da, Y); K.inverseProjectionInfo(fa, da, Y, this._projInfo, this._zScale); t.translate(this._inverseView, ha, ka); t.invert(this._inverseView, this._inverseView); this._opacityFromElevation = 1 - n.smoothstep(M.shadowCastDisableElevationMin, M.shadowCastDisableElevationMax, T.relativeElevation)
              }
            }; Q._setEnabled = function (T) { T !== this._enabled && (T ? this._start() : this._stop()) }; Q._requestRenderIfEnabled = function () { this._enabled && this._requestRender() }; w._createClass(S, [{ key: "computedSamples", get: function () { return this._progress } },
            { key: "shadowCastTexture", get: function () { return this._fbo.colorTexture } }, { key: "isAccumulating", get: function () { return this._isPreviewing || this._isRefining } }, { key: "accumulationTechnique", get: function () { if (p.isNone(this._accumulationTechnique)) { const T = { rctx: this._rctx, viewingMode: this._stage.viewingMode }, da = new L.ShadowCastTechniqueConfiguration; da.pass = 0; this._accumulationTechnique = new L.ShadowCastTechnique(T, da) } return this._accumulationTechnique } }, {
              key: "_isRefining", get: function () {
                return this._isActive &&
                  !this._isDoneAccumulating && !this._previewing
              }
            }, { key: "_isPreviewing", get: function () { return this._isActive && this._previewing } }, { key: "_isActive", get: function () { return this._enabled && 0 < this._sampleCount } }, { key: "_canAccumulate", get: function () { return null !== this._accumulationParams.linearDepthTexture && this._depthRange !== H.ZERO && this._opacityFromElevation > M.shadowCastDisabledElevationThreshold } }, { key: "_isDoneAccumulating", get: function () { return this._progress >= this._sampleCount } }, {
              key: "_lightDirections",
              get: function () { return this._cachedLightDirections }, set: function (T) { const da = this._cachedLightDirections; if (!u.equals(da, T, e.equals)) { var Y = T.length; da.length = Y; this._sampleCount = Math.min(P.shadowCastMaxSamples, Y); for (let fa = 0; fa < Y; ++fa) { const ha = T[fa], ka = da[fa] || g.create(); e.copy(ka, ha); da[fa] = ka } this._invalidate() } }
            }, { key: "_projInfo", get: function () { return this._accumulationParams.projInfo } }, { key: "_zScale", get: function () { return this._accumulationParams.zScale } }, { key: "_inverseView", get: function () { return this._accumulationParams.inverseView } },
            { key: "_opacityFromElevation", get: function () { return this._accumulationRenderer.opacityFromElevation }, set: function (T) { this._accumulationRenderer.opacityFromElevation = T } }, { key: "running", get: function () { return this._isRefining && this._canAccumulate && 0 < this._progress } }, { key: "test", get: function () { return { lightDirections: this._lightDirections, isDone: () => this._isDoneAccumulating, isActive: () => this._isActive } } }]); return S
          }(q); a.ShadowAccumulator.previewSamples = 6; a.ShadowAccumulator.renderViewHandleKey = "renderView";
          c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_progress", void 0); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_sampleCount", void 0); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_enabled", void 0); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_depthRange", void 0); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_previewing", void 0); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_accumulationRenderer", void 0); c.__decorate([h.property()],
            a.ShadowAccumulator.prototype, "_isRefining", null); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_isActive", null); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_canAccumulate", null); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_isDoneAccumulating", null); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "_opacityFromElevation", null); c.__decorate([h.property()], a.ShadowAccumulator.prototype, "running", null); a.ShadowAccumulator = I = c.__decorate([f.subclass("esri.views.3d.webgl-engine.lib.ShadowAccumulator")],
              a.ShadowAccumulator); const O = new Uint8Array(4); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/ShadowCastRenderer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec4 ../../../../chunks/vec4f64 ./glUtil3D ../shaders/ShadowCastTechnique ../../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          const m = d.fromValues(.01, 0, .25, 1), e = 1 / 512; a.ShadowCastRenderer = function (g) {
            function x(r, A, z, B) {
              var C = g.call(this, {}) || this; C._techniqueRepository = r; C._rctx = A; C._shadowAccumulator = z; C._requestRender = B; C._visualizationParams = { shadowCastMap: C._shadowCastTexture, sampleScale: 0, color: m, threshold: .5, bandSize: .1, opacityFromElevation: 1 }; C._techniqueConfig = new t.ShadowCastTechniqueConfiguration; C._enabled = !1; C._vao = f.createQuadVAO(A); C._techniqueConfig.pass = 1; C._techniqueConfig.visualization =
                0; return C
            } w._inheritsLoose(x, g); var k = x.prototype; k.normalizeCtorArgs = function () { return {} }; k.dispose = function () { this._stop(); this._vao = u.disposeMaybe(this._vao); this._techniqueRepository.release(this._technique); this._shadowAccumulator = this._technique = null }; k.render = function () {
              if (this._isRenderingVisualization) {
              this._sampleScale = 1 / this._computedSamples; this._rctx.bindVAO(this._vao); var r = this.visualizeShadowCastTechnique; this._rctx.useProgram(r.program); r.bindPipelineState(this._rctx); r.bindPass(this._visualizationParams);
                this._rctx.drawArrays(r.primitiveType, 0, v.vertexCount(this._vao, "geometry"))
              }
            }; k.setOptions = function (r) { void 0 !== r.enabled && this._setEnabled(r.enabled); void 0 !== r.color && this._setColor(r.color); void 0 !== r.threshold && (this._threshold = r.threshold); void 0 !== r.visualization && (this._visualization = r.visualization); void 0 !== r.bandSize && (this._bandSize = r.bandSize); void 0 !== r.bandsEnabled && (this._bandsEnabled = r.bandsEnabled) }; k._setColor = function (r) {
              b.exactEquals(r, this._visualizationParams.color) || (b.copy(this._visualizationParams.color,
                r), this._requestRenderIfRunning())
            }; k._setEnabled = function (r) { r !== this._enabled && (r ? this._start() : this._stop()) }; k._requestRenderIfRunning = function () { this._enabled && this._requestRender() }; k._start = function () { this._enabled = !0; this._requestRender() }; k._stop = function () { this._enabled = !1; this._requestRender() }; w._createClass(x, [{ key: "visualizeShadowCastTechnique", get: function () { return this._technique = this._techniqueRepository.releaseAndAcquire(t.ShadowCastTechnique, this._techniqueConfig, this._technique) } },
            { key: "opacityFromElevation", get: function () { return this._visualizationParams.opacityFromElevation }, set: function (r) { this._visualizationParams.opacityFromElevation !== r && (this._visualizationParams.opacityFromElevation = r, this.notifyChange("opacityFromElevation")) } }, { key: "_isRenderingVisualization", get: function () { return this._enabled && 0 < this._computedSamples && this.opacityFromElevation > e } }, { key: "_computedSamples", get: function () { return this._shadowAccumulator.computedSamples } }, { key: "_shadowCastTexture", get: function () { return this._shadowAccumulator.shadowCastTexture } },
            { key: "_sampleScale", get: function () { return this._visualizationParams.sampleScale }, set: function (r) { this._visualizationParams.sampleScale = r } }, { key: "_threshold", get: function () { return this._visualizationParams.threshold }, set: function (r) { this._threshold !== r && (this._visualizationParams.threshold = r, this._requestRenderIfRunning()) } }, {
              key: "_visualization", get: function () { return this._techniqueConfig.visualization }, set: function (r) {
              r !== this._visualization && (this._techniqueConfig.visualization = r, this._techniqueRepository.release(this._technique),
                this._technique = null, this._requestRenderIfRunning())
              }
            }, { key: "_bandSize", get: function () { return this._visualizationParams.bandSize }, set: function (r) { r !== this._bandSize && (this._visualizationParams.bandSize = r, this._requestRenderIfRunning()) } }, { key: "_bandsEnabled", get: function () { return this._techniqueConfig.bandsEnabled }, set: function (r) { r !== this._bandsEnabled && (this._techniqueConfig.bandsEnabled = r, this._techniqueRepository.release(this._technique), this._technique = null, this._requestRenderIfRunning()) } }]);
            return x
          }(q); c.__decorate([y.property()], a.ShadowCastRenderer.prototype, "opacityFromElevation", null); a.ShadowCastRenderer = c.__decorate([h.subclass("esri.views.3d.webgl-engine.lib.ShadowCastRenderer")], a.ShadowCastRenderer); a.shadowCastDisableElevationMax = 5E4; a.shadowCastDisableElevationMin = 4E4; a.shadowCastDisabledElevationThreshold = e; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/shaders/ShadowCastTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/OrderIndependentTransparency ../lib/Program ../../../../chunks/ShadowCast.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          y = function (f) {
            function t() { return f.apply(this, arguments) || this } c._inheritsLoose(t, f); var v = t.prototype; v.initializeProgram = function (m) { const e = t.shader.get().build(this.configuration); return new h.Program(m.rctx, e, p.Default3D) }; v.initializePipeline = function (m) {
              switch (this.configuration.pass) {
                case 0: return d.makePipelineState({ blending: d.separateBlendingParams(1, 1, 1, 1), colorWrite: d.defaultColorWriteParams, depthTest: null, depthWrite: null }); case 1: case 2: return d.makePipelineState({
                  blending: l.blendingDefault,
                  colorWrite: d.defaultColorWriteParams, depthTest: null, depthWrite: null
                })
              }return d.makePipelineState({})
            }; v.bindPass = function (m) {
            0 === this.configuration.pass || 2 === this.configuration.pass ? (this.program.bindTexture(m.linearDepthTexture, "depthMap"), m.shadowMap.bind(this.program), m.shadowMap.bindView(this.program, m.camera.center), this.program.setUniform2fv("nearFar", m.camera.nearFar), this.program.setUniformMatrix4fv("inverseView", m.inverseView), this.program.setUniform4fv("projInfo", m.projInfo), this.program.setUniform2fv("zScale",
              m.zScale)) : 1 === this.configuration.pass && (this.program.bindTexture(m.shadowCastMap, "shadowCastMap"), this.program.setUniform1f("sampleScale", m.sampleScale), this.program.setUniform1f("opacityFromElevation", m.opacityFromElevation), this.program.setUniform4fv("color", m.color), 0 === this.configuration.visualization && this.configuration.bandsEnabled ? this.program.setUniform1f("bandSize", m.bandSize) : 1 === this.configuration.visualization && this.program.setUniform1f("threshold", m.threshold))
            }; c._createClass(t, [{
              key: "primitiveType",
              get: function () { return 5 }
            }]); return t
          }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(b.ShadowCast, () => new Promise((f, t) => a(["./ShadowCast.glsl"], f, t))); u = function (f) { function t() { var v = f.apply(this, arguments) || this; v.pass = 0; v.visualization = 0; v.bandsEnabled = !1; return v } c._inheritsLoose(t, f); return t }(n.ShaderTechniqueConfiguration); q.__decorate([n.parameter({ count: 3 })], u.prototype, "pass", void 0); q.__decorate([n.parameter()], u.prototype, "visualization", void 0); q.__decorate([n.parameter()],
            u.prototype, "bandsEnabled", void 0); w.ShadowCastTechnique = y; w.ShadowCastTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/ShadowCast.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p) {
          function l(d) {
            const f = new p.ShaderBuilder; f.fragment.include(y.RgbaFloatEncoding); f.fragment.include(c.ReadLinearDepth); f.include(u.CameraSpace); f.include(w.ScreenSpacePass); var { pass: t } = d; if (1 === t) {
              const { visualization: v, bandsEnabled: m } = d; f.fragment.constants.add("inverseSampleValue", "float", 255); f.fragment.uniforms.add("shadowCastMap", "sampler2D"); f.fragment.uniforms.add("sampleScale", "float"); f.fragment.uniforms.add("opacityFromElevation", "float"); d = 0 === v; t = 1 === v; f.fragment.uniforms.add("color",
                "vec4"); d ? m && f.fragment.uniforms.add("bandSize", "float") : t && f.fragment.uniforms.add("threshold", "float"); f.fragment.code.add(n.glsl`
      void main(void) {
        vec4 record = texture2D(shadowCastMap, uv);
        float pixelSamples = record.r * inverseSampleValue;

        if (pixelSamples < 1.0) {
          discard;
        }

        float strength = pixelSamples * sampleScale;

        ${t ? n.glsl`
            if (strength <= threshold) {
              discard;
            }`: ""}

        ${d && m ? n.glsl`strength = ceil(strength / bandSize) * bandSize;` : ""}

        gl_FragColor = vec4(color.xyz, color.a * opacityFromElevation ${d ? n.glsl`* strength` : ""});
      }
    `)
            } else if (0 === t || 2 === t) f.include(q.ReadShadowMap), f.fragment.uniforms.add("depthMap", "sampler2D"), f.fragment.uniforms.add("inverseView", "mat4"), f.fragment.uniforms.add("nearFar", "vec2"), 0 === t ? f.fragment.constants.add("sampleValue", "float", h) : f.fragment.constants.add("shadowColor", "vec4", [0, 0, 0, .8]), f.fragment.code.add(n.glsl`
      void main(void) {

        float depth = rgba2float(texture2D(depthMap, uv));
        // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard
        if (depth == 0.0) {
          discard;
        }

        float currentPixelDepth = linearDepthFromFloat(depth, nearFar);

        if (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {
          discard;
        }

        vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
        vec4 worldSpacePos = inverseView * currentPixelPos;

        mat4 shadowMatrix;
        float linearDepth = -currentPixelDepth;
        int i = chooseCascade(linearDepth, shadowMatrix);

        if (i >= uShadowMapNum) {
          discard;
        }

        vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);

        // vertex completely outside? -> no shadow
        if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
          discard;
        }

        vec2 uvShadow = cascadeCoordinates(i, lvpos);

        float depthShadow = readShadowMapDepth(uvShadow, uShadowMapTex);
        bool shadow = depthShadow < lvpos.z;

        if (!shadow) {
          discard;
        }

        gl_FragColor = ${0 === t ? n.glsl`vec4(sampleValue)` : n.glsl`shadowColor`};
      }
    `); return f
          } const h = 1 / 255, b = Object.freeze({ __proto__: null, shadowCastMaxSamples: 255, build: l }); a.ShadowCast = b; a.build = l; a.shadowCastMaxSamples = 255
        })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.CameraSpace = function (c) {
        c.fragment.uniforms.add("projInfo", "vec4"); c.fragment.uniforms.add("zScale", "vec2"); c.fragment.code.add(w.glsl`vec3 reconstructPosition(vec2 fragCoord, float depth) {
return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/ShadowMap": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../chunks/vec4f64 ./Camera ./Util ../../../webgl/FramebufferObject ../../../webgl/Texture ../../../webgl/Util".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          function g(W, U) { n.set(ea, W[U], W[U + 3]); return ea } let x = function () { this.camera = new f; this.lightMat = y.create() }, k = function () {
            function W(X, Z, ia = 0) {
            this.rctx = X; this.viewingMode = Z; this._enabled = !1; this._snapshots = []; this.maxTextureSize = this.textureSize = 0; this.numCascades = 1; this.maxNumCascades = 4; this.splitSchemeLambda = 0; this.warp = !0; this.cascadeDistances = [0, 0, 0, 0, 0]; this.cascades = []; this.maxTextureSize = this.rctx.parameters.maxTextureSize; for (X = 0; 4 > X; ++X)this.cascades.push(new x);
              this.snapshotCount = ia
            } var U = W.prototype; U.dispose = function () { this.discardDepthTexture(); this.discardAllSnapshots() }; U.getSnapshot = function (X) { return this.enabled ? this._snapshots[X] : null }; U.getCascades = function () { for (let X = 0; X < this.numCascades; ++X)N[X] = this.cascades[X]; N.length = this.numCascades; return N }; U.start = function (X, Z, ia) {
              t.assert(this.enabled); this.textureSize = this.computeTextureSize(X.fullWidth, X.fullHeight); this.ensureDepthTexture(); const { near: la, far: ma } = this.clampNearFar(ia); this.computeCascadeDistances(ma,
                la); this.setupMatrices(X, Z); ia = X.viewMatrix; X = X.projectionMatrix; for (let ra = 0; ra < this.numCascades; ++ra)this.constructCascade(ra, X, ia, Z); this.lastOrigin = null; this.clear()
            }; U.finish = function (X) { t.assert(this.enabled); this.rctx.bindFramebuffer(X) }; U.bind = function (X) {
              this.enabled ? (this._depthTextureUnit = X.bindTexture(this._depthTexture, "uShadowMapTex"), X.setUniform1f("uDepthHalfPixelSz", .5 / this.textureSize), X.setUniform1i("uShadowMapNum", this.numCascades), X.setUniform4f("uShadowMapDistance", this.cascadeDistances[0],
                1 < this.numCascades ? this.cascadeDistances[1] : Infinity, 2 < this.numCascades ? this.cascadeDistances[2] : Infinity, 3 < this.numCascades ? this.cascadeDistances[3] : Infinity)) : X.setUniform1f("uDepthHalfPixelSz", -1)
            }; U.bindView = function (X, Z) {
              if (this.enabled) {
                var ia = this.lastOrigin; if (!ia || ia[0] !== Z[0] || ia[1] !== Z[1] || ia[2] !== Z[2]) for (this.lastOrigin = this.lastOrigin || h.create(), l.copy(this.lastOrigin, Z), ia = 0; ia < this.numCascades; ++ia) { u.translate(G, this.cascades[ia].lightMat, Z); for (let la = 0; 16 > la; ++la)I[16 * ia + la] = G[la] } X.setUniformMatrix4fv("uShadowMapMatrix",
                  I)
              }
            }; U.takeCascadeSnapshotTo = function (X, Z) { t.assert(this.enabled); this.ensureSnapshot(Z); this._bindFbo(); const ia = this.rctx; Z = ia.bindTexture(this._snapshots[Z], m.TEXTURE_UNIT_FOR_UPDATES); ia.gl.copyTexSubImage2D(3553, 0, X.camera.viewport[0], X.camera.viewport[1], X.camera.viewport[0], X.camera.viewport[1], X.camera.viewport[2], X.camera.viewport[3]); ia.bindTexture(Z, m.TEXTURE_UNIT_FOR_UPDATES) }; U.clear = function () { const X = this.rctx; this._bindFbo(); X.setClearColor(1, 1, 1, 1); X.clearSafe(16640) }; U.computeTextureSize =
              function (X, Z) { return Math.min(this.maxTextureSize, 2 * 2 ** Math.round(.5 * Math.log(X * X + Z * Z) * Math.LOG2E + .35)) }; U.ensureDepthTexture = function () {
                if (null == this._depthTexture || this._depthTexture.descriptor.width !== this.textureSize) this.discardDepthTexture(), this._depthTexture = new m(this.rctx, { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9728, flipped: !0, width: this.textureSize, height: this.textureSize }), this.fbo = new v(this.rctx, {
                  colorTarget: 0, depthStencilTarget: 1, width: this.textureSize,
                  height: this.textureSize
                }, this._depthTexture)
              }; U.ensureSnapshot = function (X) { const Z = this._snapshots[X]; c.isSome(Z) && Z.descriptor.width === this.textureSize || (this.discardSnapshot(X), this._snapshots[X] = new m(this.rctx, { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 33071, samplingMode: 9728, flipped: !0, width: this.textureSize, height: this.textureSize })) }; U.discardDepthTexture = function () { this.fbo = c.disposeMaybe(this.fbo); this._depthTexture = c.disposeMaybe(this._depthTexture) }; U.discardSnapshot = function (X) {
              this._snapshots[X] =
                c.disposeMaybe(this._snapshots[X])
              }; U.discardAllSnapshots = function () { for (let X = 0; X < this.snapshotCount; ++X)this.discardSnapshot(X) }; U._bindFbo = function () { const X = this.rctx; c.isSome(this._depthTextureUnit) && (X.bindTexture(null, this._depthTextureUnit), this._depthTextureUnit = null); X.bindFramebuffer(this.fbo) }; U.constructCascade = function (X, Z, ia, la) {
                const ma = this.cascades[X]; var ra = -this.cascadeDistances[X], Aa = -this.cascadeDistances[X + 1]; ra = (Z[10] * ra + Z[14]) / Math.abs(Z[11] * ra + Z[15]); Z = (Z[10] * Aa + Z[14]) / Math.abs(Z[11] *
                  Aa + Z[15]); t.assert(ra < Z); for (Aa = 0; 8 > Aa; ++Aa) { b.set(B, 0 === Aa % 4 || 3 === Aa % 4 ? -1 : 1, 0 === Aa % 4 || 1 === Aa % 4 ? -1 : 1, 4 > Aa ? ra : Z, 1); b.transformMat4(C[Aa], B, z); for (let za = 0; 3 > za; ++za)C[Aa][za] /= C[Aa][3] } l.negate(L, C[0]); u.translate(r, P, L); ma.camera.viewMatrix = r; for (ra = 0; 8 > ra; ++ra)l.transformMat4(C[ra], C[ra], ma.camera.viewMatrix); l.copy(D, C[0]); l.copy(E, C[0]); for (ra = 1; 8 > ra; ++ra)for (Z = 0; 3 > Z; ++Z)D[Z] = Math.min(D[Z], C[ra][Z]), E[Z] = Math.max(E[Z], C[ra][Z]); D[2] -= 200; E[2] += 200; ma.camera.near = -E[2]; ma.camera.far = -D[2]; this.warp ?
                    this.constructTrapezoidalProjection(ia, la, ma) : this.constructOrthogonalProjection(ma); u.multiply(ma.lightMat, ma.camera.projectionMatrix, ma.camera.viewMatrix); ia = this.textureSize / 2; ma.camera.viewport[0] = 0 === X % 2 ? 0 : ia; ma.camera.viewport[1] = 0 === Math.floor(X / 2) ? 0 : ia; ma.camera.viewport[2] = ia; ma.camera.viewport[3] = ia
              }; U.constructOrthogonalProjection = function (X) { u.ortho(X.camera.projectionMatrix, D[0], E[0], D[1], E[1], X.camera.near, X.camera.far) }; U.constructTrapezoidalProjection = function (X, Z, ia) {
                var la = 1 / C[0][3],
                ma = 1 / C[4][3]; t.assert(la < ma); la += Math.sqrt(la * ma); var ra = Math.sin(w.acosClamped(X[2] * Z[0] + X[6] * Z[1] + X[10] * Z[2])); X = C; var Aa = la / ra; Z = H; var za = J, Ka = M; ma = F; la = K; n.set(O, 0, 0); for (var Ea = 0; 4 > Ea; ++Ea)n.add(O, O, X[Ea]); n.scale(O, O, .25); n.set(R, 0, 0); for (Ea = 4; 8 > Ea; ++Ea)n.add(R, R, X[Ea]); n.scale(R, R, .25); n.lerp(S[0], X[4], X[5], .5); n.lerp(S[1], X[5], X[6], .5); n.lerp(S[2], X[6], X[7], .5); n.lerp(S[3], X[7], X[4], .5); Ea = 0; var Ua = n.squaredDistance(S[0], O); for (var Na = 1; 4 > Na; ++Na) {
                  var ya = n.squaredDistance(S[Na], O); ya < Ua &&
                    (Ua = ya, Ea = Na)
                } n.subtract(Q, S[Ea], X[Ea + 4]); Ea = Q[0]; Q[0] = -Q[1]; Q[1] = Ea; n.subtract(T, R, O); 0 > n.dot(T, Q) && n.negate(Q, Q); n.lerp(Q, Q, T, ra); n.normalize(Q, Q); ra = Ea = n.dot(n.subtract(da, X[0], O), Q); for (Ua = 1; 8 > Ua; ++Ua)Na = n.dot(n.subtract(da, X[Ua], O), Q), Na < ra ? ra = Na : Na > Ea && (Ea = Na); n.copy(Z, O); n.scale(da, Q, ra - Aa); n.add(Z, Z, da); Na = -1; ya = 1; Aa = Ua = 0; for (let pa = 0; 8 > pa; ++pa) { n.subtract(Y, X[pa], Z); n.normalize(Y, Y); const wa = Q[0] * Y[1] - Q[1] * Y[0]; 0 < wa ? wa > Na && (Na = wa, Ua = pa) : wa < ya && (ya = wa, Aa = pa) } t.verify(0 < Na, "leftArea"); t.verify(0 >
                  ya, "rightArea"); n.scale(fa, Q, ra); n.add(fa, fa, O); n.scale(ha, Q, Ea); n.add(ha, ha, O); ka[0] = -Q[1]; ka[1] = Q[0]; za = t.rayRay2D(Z, X[Aa], ha, n.add(da, ha, ka), 1, za); Ka = t.rayRay2D(Z, X[Ua], ha, da, 1, Ka); ma = t.rayRay2D(Z, X[Ua], fa, n.add(da, fa, ka), 1, ma); X = t.rayRay2D(Z, X[Aa], fa, da, 1, la); t.verify(za, "rayRay"); t.verify(Ka, "rayRay"); t.verify(ma, "rayRay"); t.verify(X, "rayRay"); Ka = H; X = J; Z = F; ma = K; la = ia.camera.projectionMatrix; n.subtract(ba, Z, ma); n.scale(ba, ba, .5); aa[0] = ba[0]; aa[1] = ba[1]; aa[2] = 0; aa[3] = ba[1]; aa[4] = -ba[0]; aa[5] = 0;
                aa[6] = ba[0] * ba[0] + ba[1] * ba[1]; aa[7] = ba[0] * ba[1] - ba[1] * ba[0]; aa[8] = 1; aa[6] = -n.dot(g(aa, 0), Ka); aa[7] = -n.dot(g(aa, 1), Ka); Ka = n.dot(g(aa, 0), Z) + aa[6]; za = n.dot(g(aa, 1), Z) + aa[7]; Aa = n.dot(g(aa, 0), ma) + aa[6]; ma = n.dot(g(aa, 1), ma) + aa[7]; Ka = -(Ka + Aa) / (za + ma); aa[0] += aa[1] * Ka; aa[3] += aa[4] * Ka; aa[6] += aa[7] * Ka; Ka = 1 / (n.dot(g(aa, 0), Z) + aa[6]); za = 1 / (n.dot(g(aa, 1), Z) + aa[7]); aa[0] *= Ka; aa[3] *= Ka; aa[6] *= Ka; aa[1] *= za; aa[4] *= za; aa[7] *= za; aa[2] = aa[1]; aa[5] = aa[4]; aa[8] = aa[7]; aa[7] += 1; Ka = n.dot(g(aa, 1), X) + aa[7]; za = n.dot(g(aa, 2), X) +
                  aa[8]; Aa = n.dot(g(aa, 1), Z) + aa[7]; ma = n.dot(g(aa, 2), Z) + aa[8]; Ka = -.5 * (Ka / za + Aa / ma); aa[1] += aa[2] * Ka; aa[4] += aa[5] * Ka; aa[7] += aa[8] * Ka; Ka = n.dot(g(aa, 1), X) + aa[7]; za = n.dot(g(aa, 2), X) + aa[8]; Aa = -za / Ka; aa[1] *= Aa; aa[4] *= Aa; aa[7] *= Aa; la[0] = aa[0]; la[1] = aa[1]; la[2] = 0; la[3] = aa[2]; la[4] = aa[3]; la[5] = aa[4]; la[6] = 0; la[7] = aa[5]; la[8] = 0; la[9] = 0; la[10] = 1; la[11] = 0; la[12] = aa[6]; la[13] = aa[7]; la[14] = 0; la[15] = aa[8]; ia.camera.projectionMatrix[10] = 2 / (D[2] - E[2]); ia.camera.projectionMatrix[14] = -(D[2] + E[2]) / (D[2] - E[2])
              }; U.setupMatrices =
                function (X, Z) { u.multiply(A, X.projectionMatrix, X.viewMatrix); u.invert(z, A); X = 1 === this.viewingMode ? X.eye : l.set(L, 0, 0, 1); u.lookAt(P, [0, 0, 0], [-Z[0], -Z[1], -Z[2]], X) }; U.clampNearFar = function (X) { let { near: Z, far: ia } = X; 2 > Z && (Z = 2); 2 > ia && (ia = 2); Z >= ia && (Z = 2, ia = 4); return { near: Z, far: ia } }; U.computeCascadeDistances = function (X, Z) {
                this.numCascades = Math.min(1 + Math.floor(t.logWithBase(X / Z, 4)), this.maxNumCascades); const ia = (X - Z) / this.numCascades; X = (X / Z) ** (1 / this.numCascades); let la = Z; for (let ma = 0; ma < this.numCascades +
                  1; ++ma)this.cascadeDistances[ma] = w.lerp(la, Z, this.splitSchemeLambda), la *= X, Z += ia
                }; a._createClass(W, [{ key: "maxCascades", get: function () { return this.maxNumCascades }, set: function (X) { this.maxNumCascades = w.clamp(Math.floor(X), 1, 4) } }, { key: "enabled", get: function () { return this._enabled }, set: function (X) { this._enabled = X; X || (this.discardDepthTexture(), this.discardAllSnapshots()) } }, {
                  key: "snapshotCount", get: function () { return this._snapshots.length }, set: function (X) {
                    var Z = this._snapshots.length; if (X > Z) {
                      var ia = X -
                        Z; this._snapshots.length = X; for (X = 0; X < ia; ++X)this._snapshots[Z + X] = null
                    } else if (X < this.snapshotCount) { Z -= X; for (ia = 0; ia < Z; ++ia)this.discardSnapshot(X + ia); this._snapshots.length = X }
                  }
                }, { key: "gpuMemoryUsage", get: function () { var X, Z; return this._snapshots.reduce((ia, la) => ia + e.getGpuMemoryUsage(la), null != (X = null == (Z = this.fbo) ? void 0 : Z.gpuMemoryUsage) ? X : 0) } }, {
                  key: "test", get: function () {
                    const X = this; return {
                      maxNumCascades: this.maxNumCascades, cascades: this.cascades, textureSize: this.textureSize, depthTexture: this._depthTexture,
                      set splitSchemeLambda(Z) { X.splitSchemeLambda = Z }, get splitSchemeLambda() { return X.splitSchemeLambda }, set warp(Z) { X.warp = Z }, get warp() { return X.warp }
                    }
                  }
                }]); return W
          }(); const r = y.create(), A = y.create(), z = y.create(), B = d.create(), C = []; for (let W = 0; 8 > W; ++W)C.push(d.create()); const D = h.create(), E = h.create(), H = p.create(), J = p.create(), M = p.create(), F = p.create(), K = p.create(), P = y.create(), L = h.create(), N = [], G = y.create(), I = new Float32Array(64), O = p.create(), R = p.create(), S = [p.create(), p.create(), p.create(), p.create()],
            Q = p.create(), T = p.create(), da = p.create(), Y = p.create(), fa = p.create(), ha = p.create(), ka = p.create(), ea = p.create(), ba = p.create(), aa = q.create(); return k
        })
    }, "esri/views/3d/webgl-engine/lib/ShadowHighlightHelper": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f32 ./glUtil3D ../shaders/ShadowHighlightTechnique ../../../webgl/Util".split(" "), function (a, w, c, q, u,
        y, n, p, l, h) {
          let b = function () {
            function f(v, m) { this._rctx = v; this._viewingMode = m; this._maxOpacity = 1; this._parameters = { shadowColor: n.fromValues(1, 0, 1, 1), shadowOpacity: .2, occludedShadowOpacity: .1, opacityElevation: 1, dayNightTerminator: 1 }; this._vao = p.createQuadVAO(this._rctx) } var t = f.prototype; t.render = function (v, m) {
              this._updateParameters(v); if (v.shadowMap.enabled && v.linearDepthTexture && this.isVisible) {
                var e = this.technique; this._rctx.bindFramebuffer(m); this._rctx.useProgram(e.program); e.bindPipelineState(this._rctx);
                e.bindPass(this._parameters, v); this._rctx.bindVAO(this._vao); this._rctx.drawArrays(e.primitiveType, 0, h.vertexCount(this._vao, "geometry"))
              }
            }; t.setDefaultOptions = function (v) { this._parameters = { ...this._parameters, ...v }; this._updateMaxOpacity() }; t._updateParameters = function (v) {
              this._parameters.opacityElevation = 1 - c.smoothstep(4E4, 5E4, v.camera.relativeElevation); const m = 1 === this._viewingMode ? u.normalize(d, v.camera.center) : u.set(d, 0, 0, 1); v = u.dot(m, v.lighting.lightingMainDirection); this._parameters.dayNightTerminator =
                c.smoothstep(0, 1, c.clamp(30 * v, 0, 1))
            }; t.dispose = function () { this._vao = q.disposeMaybe(this._vao); this._technique = q.disposeMaybe(this._technique) }; t._updateMaxOpacity = function () { const v = this._parameters; this._maxOpacity = Math.max(v.shadowOpacity, v.occludedShadowOpacity) * v.shadowColor[3] }; w._createClass(f, [{ key: "technique", get: function () { q.isNone(this._technique) && (this._technique = new l.ShadowHighlightTechnique({ rctx: this._rctx, viewingMode: this._viewingMode }, null)); return this._technique } }, {
              key: "gpuMemoryUsage",
              get: function () { var v, m; return null != (v = null == (m = this._vao) ? void 0 : m.size) ? v : 0 }
            }, { key: "isVisible", get: function () { return .001953125 <= this._maxOpacity * this._parameters.opacityElevation * this._parameters.dayNightTerminator } }]); return f
          }(); const d = y.create(); a.ShadowHighlightHelper = b; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/ShadowHighlightTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../lib/DefaultVertexAttributeLocations ../lib/Program ../lib/Util ../../../../chunks/ShadowHighlight.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          d = function (A) {
            function z() { return A.apply(this, arguments) || this } c._inheritsLoose(z, A); var B = z.prototype; B.initializeProgram = function (C) { const D = z.shader.get().build({ highlightedThreshold: .99999, selfShadowThreshold: .025 }); return new t.Program(C.rctx, D, f.Default3D) }; B.initializePipeline = function (C) { return e.makePipelineState({ blending: e.separateBlendingParams(770, 1, 771, 771), colorWrite: e.defaultColorWriteParams, depthTest: null, depthWrite: null }) }; B.bindPass =
              function (C, D) {
                q.isNone(D.linearDepthTexture) || (this.program.bindTexture(D.linearDepthTexture, "depthMap"), this.program.bindTexture(D.highlightColorTexture, "highlightMap"), p.transformMat4(g, D.lighting.lightingMainDirection, D.camera.viewInverseTransposeMatrix), p.normalize(g, g), v.inverseProjectionInfo(D.camera.projectionMatrix, D.camera.fullWidth, D.camera.fullHeight, k, x), u.translate(r, D.camera.viewMatrix, D.camera.center), u.invert(r, r), this.program.setUniform4fv("color", C.shadowColor), this.program.setUniform1f("opacity",
                  C.shadowOpacity), this.program.setUniform1f("occludedOpacity", C.occludedShadowOpacity), this.program.setUniform1f("terminationFactor", C.opacityElevation * C.dayNightTerminator), this.program.setUniform2fv("nearFar", D.camera.nearFar), this.program.setUniformMatrix4fv("inverseView", r), this.program.setUniform4fv("projInfo", k), this.program.setUniform2fv("zScale", x), this.program.setUniform3fv("lightingMainDirectionView", g), this.program.setUniform2f("texelSize", 1 / D.linearDepthTexture.descriptor.width, 1 / D.linearDepthTexture.descriptor.height),
                  D.shadowMap.bind(this.program), D.shadowMap.bindView(this.program, D.camera.center), C = D.shadowMap.getSnapshot(0), q.isSome(C) && this.program.bindTexture(C, "highlightDepthTex"), C = D.shadowMap.getSnapshot(1), q.isSome(C) && this.program.bindTexture(C, "defaultDepthTex"))
              }; c._createClass(z, [{ key: "primitiveType", get: function () { return 5 } }]); return z
          }(d.ShaderTechnique); d.shader = new b.ReloadableShaderModule(m.ShadowHighlightShader, () => new Promise((A, z) => a(["./ShadowHighlight.glsl"], A, z))); const g = l.create(), x = n.create(),
            k = h.create(), r = y.create(); w.DefaultSnapshotSlot = 1; w.HighlightShadowMapSlot = 0; w.ShadowHighlightTechnique = d; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/ShadowHighlight.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(d) {
            const f = new l.ShaderBuilder; f.include(u.ReadShadowMap); f.fragment.include(n.RgbaFloatEncoding); f.fragment.include(q.ReadLinearDepth); f.include(y.CameraSpace); f.include(w.ScreenSpacePass); f.fragment.uniforms.add("defaultDepthTex", "sampler2D").add("highlightDepthTex", "sampler2D").add("depthMap", "sampler2D").add("highlightMap", "sampler2D").add("color", "vec4").add("nearFar", "vec2").add("opacity", "float").add("occludedOpacity", "float").add("terminationFactor",
              "float").add("inverseView", "mat4").add("lightingMainDirectionView", "vec3").add("texelSize", "vec2"); f.fragment.constants.add("unoccludedHighlightFlag", "vec4", c.unoccludedHighlightFlag).add("highlightedThreshold", "float", d.highlightedThreshold).add("selfShadowThreshold", "float", d.selfShadowThreshold); f.fragment.code.add(p.glsl`vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, vec2 uv, vec2 texelSize, sampler2D depthMap, vec2 nearFar) {
float leftPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(-1.0, 0.0) * texelSize, nearFar);
float rightPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(1.0, 0.0) * texelSize, nearFar);
float bottomPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, -1.0) * texelSize, nearFar);
float topPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, 1.0) * texelSize, nearFar);
bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);
bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);
vec3 fragCoordHorizontal = pickLeft
? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)
: vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);
vec3 fragCoordVertical = pickBottom
? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)
: vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);
vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);
vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);
vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));
return pickLeft == pickBottom ? normal : -normal;
}`); f.fragment.code.add(p.glsl`void main(void) {
vec4 highlightInfo = texture2D(highlightMap, uv);
float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
if (visiblyHighlighted > highlightedThreshold) {
discard;
}
float depth = rgba2float(texture2D(depthMap, uv));
if (depth == 0.0) {
discard;
}
float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
discard;
}
vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
vec4 worldSpacePos = inverseView * currentPixelPos;
mat4 shadowMatrix;
float linearDepth = -currentPixelDepth;
int i = chooseCascade(linearDepth, shadowMatrix);
if (i >= uShadowMapNum) {
discard;
}
vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
discard;
}
vec2 uvShadow = cascadeCoordinates(i, lvpos);
float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
bool shadowHighlight = depthHighlight < lvpos.z;
if (!shadowHighlight) {
discard;
}
float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
bool shadowDefault = depthDefault < lvpos.z;
vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, uv, texelSize, depthMap, nearFar);
bool shaded = dot(normal, lightingMainDirectionView) < selfShadowThreshold;
float differenceOpacity = opacity;
float bothOpacity = occludedOpacity;
float fragOpacity = (shadowDefault || shaded) ? bothOpacity : differenceOpacity;
gl_FragColor = vec4(color.rgb, color.a * fragOpacity * terminationFactor);
}`); return f
          } const b = Object.freeze({ __proto__: null, build: h }); a.ShadowHighlightShader = b; a.build = h
        })
    }, "esri/views/3d/webgl-engine/lib/SliceHelper": function () { define(["../../../../chunks/_rollupPluginBabelHelpers", "../../../../chunks/boundedPlane"], function (a, w) { const c = w.create(); return function () { function q() { this._worldPlane = c } a._createClass(q, [{ key: "isEnabled", get: function () { return this.plane !== c } }, { key: "plane", get: function () { return this._worldPlane }, set: function (u) { this._worldPlane = u ? u : c } }]); return q }() }) },
    "esri/views/3d/webgl-engine/lib/SmaaRenderPass": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../support/requestImageUtils ./glUtil3D ./SMAATechnique ../../../webgl/FramebufferObject ../../../webgl/Texture".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
        w.SmaaRenderPass = function (g) {
          function x(r, A) { var z = g.call(this, {}) || this; z.rctx = r; z._techniqueRep = A; z._isEnabled = !1; return z } c._inheritsLoose(x, g); var k = x.prototype; k.normalizeCtorArgs = function () { return {} }; k.dispose = function () { this._abortController = y.abortMaybe(this._abortController); this.disable() }; k._loadResources = function (r) {
            if (y.isSome(this._abortController)) return !1; if (y.isSome(this._searchTexture)) return !0; this._abortController = new AbortController;
            const A = this._abortController.signal; (new Promise((z, B) => a(["./SmaaRenderPassData"], z, B))).then(z => this._loadTextures(z, A)).then(() => r()).finally(() => this._abortController = null); return !1
          }; k._loadTextures = function (r, A) { n.throwIfAborted(A); return Promise.all([this.loadTextureFromBase64(r.areaTexture, 9729, 6407), this.loadTextureFromBase64(r.searchTexure, 9728, 6409)]).then(([z, B]) => { n.isAborted(A) ? (z.dispose(), B.dispose(), n.throwIfAborted(A)) : (this._areaTexture = z, this._searchTexture = B) }) }; k.enable = function (r) {
            if (this._isEnabled) return !0;
            if (!this._edgeDetectTechnique || !this._blendWeights || !this._blur) { const A = new v.SMAATechniqueConfiguration, z = (B, C) => this._techniqueRep.releaseAndAcquire(v.SMAATechnique, B, C); A.output = 0; this._edgeDetectTechnique = z(A, this._edgeDetectTechnique); A.output = 1; this._blendWeights = z(A, this._blendWeights); A.output = 2; this._blur = z(A, this._blur) } if (!this._loadResources(r)) return !1; this._vao = t.createScreenSizeTriangleVAO(this.rctx); this._edges = new m(this.rctx, { colorTarget: 0, depthStencilTarget: 0 }, {
              target: 3553, pixelFormat: 6407,
              dataType: 5121, samplingMode: 9729, wrapMode: 33071, width: 4, height: 4
            }); this._blend = new m(this.rctx, { colorTarget: 0, depthStencilTarget: 0 }, { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9729, wrapMode: 33071, width: 4, height: 4 }); return this._isEnabled = !0
          }; k.disable = function () {
          this._isEnabled && (this._vao = y.disposeMaybe(this._vao), this._areaTexture = y.disposeMaybe(this._areaTexture), this._searchTexture = y.disposeMaybe(this._searchTexture), this._blend = y.disposeMaybe(this._blend), this._edges = y.disposeMaybe(this._edges),
            this._isEnabled = !1)
          }; k.render = function (r) {
            if (this._isEnabled) {
              var A = this.rctx, z = A.getBoundFramebufferObject(), B = r.descriptor.width, C = r.descriptor.height; A.bindVAO(this._vao); this._edgeDetectTechnique.bindPipelineState(A); A.setViewport(0, 0, B, C); this._edges.resize(B, C); A.bindFramebuffer(this._edges); A.setClearColor(0, 0, 0, 1); A.clear(16384); A.useProgram(this._edgeDetectTechnique.program); this._edgeDetectTechnique.program.bindTexture(r, "tColor"); this._edgeDetectTechnique.program.setUniform4f("uResolution",
                1 / B, 1 / C, B, C); A.drawArrays(4, 0, 3); this._blend.resize(B, C); A.bindFramebuffer(this._blend); A.setClearColor(0, 0, 1, 1); A.clear(16384); A.useProgram(this._blendWeights.program); this._blendWeights.program.setUniform4f("uResolution", 1 / B, 1 / C, B, C); this._blendWeights.program.bindTexture(this._searchTexture, "tSearch"); this._blendWeights.program.bindTexture(this._areaTexture, "tArea"); this._blendWeights.program.bindTexture(this._edges.colorTexture, "tEdges"); A.drawArrays(4, 0, 3); A.bindFramebuffer(z); A.setClearColor(0,
                  1, 0, 1); A.clear(16384); A.useProgram(this._blur.program); this._blur.program.setUniform4f("uResolution", 1 / B, 1 / C, B, C); this._blur.program.bindTexture(r, "tColor"); this._blur.program.bindTexture(this._blend.colorTexture, "tBlendWeights"); A.drawArrays(4, 0, 3)
            }
          }; k.loadTextureFromBase64 = function (r, A, z) { const B = new e(this.rctx, { pixelFormat: z, dataType: 5121, wrapMode: 33071, samplingMode: A }, null); return f.requestImage(r).then(C => { B.resize(C.width, C.height); B.setData(C); return B }) }; c._createClass(x, [{
            key: "updating",
            get: function () { return y.isSome(this._abortController) }
          }]); return x
        }(u); q.__decorate([p.property()], w.SmaaRenderPass.prototype, "_abortController", void 0); q.__decorate([p.property({ readOnly: !0 })], w.SmaaRenderPass.prototype, "updating", null); w.SmaaRenderPass = q.__decorate([d.subclass("esri.views.3d.webgl-engine.lib.SmaaRenderPass")], w.SmaaRenderPass); Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/SMAATechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ./DefaultVertexAttributeLocations ./Program ../../../../chunks/SMAA.glsl ../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          y = function (d) { function f() { return d.apply(this, arguments) || this } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { const m = f.shader.get().build({ output: this.configuration.output, threshold: .05, localConstrastAdaption: 2, maxSearchSteps: 8, maxDistanceAreaTex: 16 }); return new l.Program(v.rctx, m, p.Default3D) }; t.initializePipeline = function () { return b.makePipelineState({ colorWrite: b.defaultColorWriteParams }) }; return f }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(h.SMAAShader,
            () => new Promise((d, f) => a(["../shaders/SMAA.glsl"], d, f))); u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.output = 0; return t } c._inheritsLoose(f, d); return f }(n.ShaderTechniqueConfiguration); q.__decorate([n.parameter({ count: 3 })], u.prototype, "output", void 0); w.SMAATechnique = y; w.SMAATechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/SMAA.glsl": function () {
      define(["exports", "../views/3d/webgl-engine/core/shaderModules/interfaces", "../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"],
        function (a, w, c) {
          function q(y) {
            const n = new c.ShaderBuilder; 0 === y.output && (n.attributes.add("position", "vec2"), n.vertex.uniforms.add("uResolution", "vec4"), n.varyings.add("fTexCoord", "vec2"), n.varyings.add("fOffset[3]", "vec4"), n.vertex.code.add(w.glsl`void SMAAEdgeDetectionVS( vec2 texcoord ) {
fOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );
fOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );
fOffset[2] = texcoord.xyxy + uResolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );
}
void main() {
fTexCoord = (position + 1.0 ) * 0.5;
gl_Position = vec4(position, 0, 1);
SMAAEdgeDetectionVS( fTexCoord );
}`), n.fragment.uniforms.add("tColor", "sampler2D"), n.fragment.code.add(w.glsl`
      vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
        vec2 threshold = vec2( ${w.glsl.float(y.threshold)} );

        // Calculate color deltas:
        vec4 delta;
        vec3 C = texture2D( colorTex, texcoord ).rgb;

        vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
        vec3 t = abs( C - Cleft );
        delta.x = max( max( t.r, t.g ), t.b );

        vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
        t = abs( C - Ctop );
        delta.y = max( max( t.r, t.g ), t.b );

        // We do the usual threshold:
        vec2 edges = step( threshold, delta.xy );

        // Then discard if there is no edge:
        if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
            discard;

        // Calculate right and bottom deltas:
        vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
        t = abs( C - Cright );
        delta.z = max( max( t.r, t.g ), t.b );

        vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
        t = abs( C - Cbottom );
        delta.w = max( max( t.r, t.g ), t.b );

        // Calculate the maximum delta in the direct neighborhood:
        float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

        // Calculate left-left and top-top deltas:
        vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
        t = abs( C - Cleftleft );
        delta.z = max( max( t.r, t.g ), t.b );

        vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
        t = abs( C - Ctoptop );
        delta.w = max( max( t.r, t.g ), t.b );

        // Calculate the final maximum delta:
        maxDelta = max( max( maxDelta, delta.z ), delta.w );

        // Local contrast adaptation in action:
        edges.xy *= step( maxDelta, float(${w.glsl.float(y.localConstrastAdaption)}) * delta.xy );

        return vec4( edges, 0.0, 0.0 );
      }

      void main() {
        gl_FragColor = SMAAColorEdgeDetectionPS( fTexCoord, fOffset, tColor );
      }
    `)); 1 === y.output && (n.attributes.add("position", "vec2"), n.vertex.uniforms.add("uResolution", "vec4"), n.varyings.add("fTexCoord", "vec2"), n.varyings.add("fOffset[3]", "vec4"), n.varyings.add("fPixCoord", "vec2"), n.vertex.code.add(w.glsl`
      void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
        fPixCoord = texcoord * uResolution.zw;
        fOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );
        fOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );
        fOffset[2] = vec4( fOffset[0].xz, fOffset[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * uResolution.xxyy * float( ${w.glsl.int(y.maxSearchSteps)} );
      }

      void main() {
        fTexCoord = (position + 1.0 ) * 0.5;
        gl_Position = vec4(position, 0, 1);
        SMAABlendingWeightCalculationVS( fTexCoord );
      }
    `), n.fragment.uniforms.add("tEdges", "sampler2D").add("tArea", "sampler2D").add("tSearch", "sampler2D").add("tColor", "sampler2D").add("uResolution", "vec4"), n.fragment.code.add(w.glsl`
      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )
      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )

      vec4 SMAASampleLevelZeroOffset(sampler2D tex, vec2 coord, vec2 offset) {
        return texture2D( tex, coord + offset.x * uResolution.xy, 0.0 );
      }

      vec2 round( vec2 x ) {
        return sign( x ) * floor( abs( x ) + 0.5 );
      }

      float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
        e.r = bias + e.r * scale;
        return 255.0 * texture2D( searchTex, e, 0.0 ).r;
      }

      float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
        vec2 e = vec2( 0.0, 1.0 );
        for ( int i = 0; i < ${w.glsl.int(y.maxSearchSteps)}; i ++ ) {
          e = texture2D( edgesTex, texcoord, 0.0 ).rg;
          texcoord -= vec2( 2.0, 0.0 ) * uResolution.xy;
          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
        }
        texcoord.x += 0.25 * uResolution.x;
        texcoord.x += uResolution.x;
        texcoord.x += 2.0 * uResolution.x;
        texcoord.x -= uResolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);
        return texcoord.x;
      }

      float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
        vec2 e = vec2( 0.0, 1.0 );
        for ( int i = 0; i < ${w.glsl.int(y.maxSearchSteps)}; i ++ ) {
          e = texture2D( edgesTex, texcoord, 0.0 ).rg;
          texcoord += vec2( 2.0, 0.0 ) * uResolution.xy;
          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
        }
        texcoord.x -= 0.25 * uResolution.x;
        texcoord.x -= uResolution.x;
        texcoord.x -= 2.0 * uResolution.x;
        texcoord.x += uResolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );
        return texcoord.x;
      }

      float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
        vec2 e = vec2( 1.0, 0.0 );
        for ( int i = 0; i < ${w.glsl.int(y.maxSearchSteps)}; i ++ ) {
          e = texture2D( edgesTex, texcoord, 0.0 ).rg;
          texcoord += vec2( 0.0, 2.0 ) * uResolution.xy;
          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
        }
        texcoord.y -= 0.25 * uResolution.y;
        texcoord.y -= uResolution.y;
        texcoord.y -= 2.0 * uResolution.y;
        texcoord.y += uResolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );
        return texcoord.y;
      }

      float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
        vec2 e = vec2( 1.0, 0.0 );
        for ( int i = 0; i < ${w.glsl.int(y.maxSearchSteps)}; i ++ ) {
          e = texture2D( edgesTex, texcoord, 0.0 ).rg;
          texcoord -= vec2( 0.0, 2.0 ) * uResolution.xy;
          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
        }
        texcoord.y += 0.25 * uResolution.y;
        texcoord.y += uResolution.y;
        texcoord.y += 2.0 * uResolution.y;
        texcoord.y -= uResolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );
        return texcoord.y;
      }

      vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
        vec2 texcoord = float( ${w.glsl.int(y.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;
        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );
        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;
        return texture2D( areaTex, texcoord, 0.0 ).rg;
      }

      vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
        vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );
        vec2 e = texture2D( edgesTex, texcoord ).rg;
        if ( e.g > 0.0 ) {
          vec2 d;
          vec2 coords;
          coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
          coords.y = offset[ 1 ].y;
          d.x = coords.x;
          float e1 = texture2D( edgesTex, coords, 0.0 ).r;
          coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
          d.y = coords.x;
          d = d * uResolution.z - pixcoord.x;
          vec2 sqrt_d = sqrt( abs( d ) );
          coords.y -= 1.0 * uResolution.y;
          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 1.0, 0.0 ) ).r;
          weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
        }

        if ( e.r > 0.0 ) {
          vec2 d;
          vec2 coords;
          coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
          coords.x = offset[ 0 ].x;
          d.x = coords.y;
          float e1 = texture2D( edgesTex, coords, 0.0 ).g;
          coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
          d.y = coords.y;
          d = d * uResolution.w - pixcoord.y;
          vec2 sqrt_d = sqrt( abs( d ) );
          coords.y -= 1.0 * uResolution.y;
          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 0.0, 1.0 ) ).g;
          weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );

          // for some reason the following lines are necessary to prevent
          // texture lookup precision issues on some Intel integrated graphics chips
          vec4 dbg = (offset[ 0 ]+offset[ 1 ]+offset[ 2 ] + coords.xyyx);
          weights.r += 0.00000001 * dot(vec4(0,1,0,1),dbg);
        }
        return weights;
      }

      void main() {
        gl_FragColor = SMAABlendingWeightCalculationPS( fTexCoord, fPixCoord, fOffset, tEdges, tArea, tSearch, ivec4( 0.0 ) );
      }
    `)); 2 === y.output && (n.attributes.add("position", "vec2"), n.vertex.uniforms.add("uResolution", "vec4"), n.varyings.add("fTexCoord", "vec2"), n.varyings.add("fOffset[2]", "vec4"), n.vertex.code.add(w.glsl`void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
fOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );
fOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );
}
void main() {
fTexCoord = (position + 1.0 ) * 0.5;
gl_Position = vec4(position, 0, 1);
SMAANeighborhoodBlendingVS(fTexCoord);
}`), n.fragment.uniforms.add("tBlendWeights", "sampler2D"), n.fragment.uniforms.add("tColor", "sampler2D"), n.fragment.uniforms.add("uResolution", "vec4"), n.fragment.code.add(w.glsl`vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
vec4 a;
a.xz = texture2D( blendTex, texcoord ).xz;
a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
a.w = texture2D( blendTex, offset[ 1 ].xy ).a;
if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
return texture2D( colorTex, texcoord, 0.0 );
} else {
vec2 offset;
offset.x = a.a > a.b ? a.a : -a.b;
offset.y = a.g > a.r ? -a.g : a.r;
if ( abs( offset.x ) > abs( offset.y )) {
offset.y = 0.0;
} else {
offset.x = 0.0;
}
vec4 C = texture2D( colorTex, texcoord, 0.0 );
texcoord += sign( offset ) * uResolution.xy;
vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );
vec4 mixed = mix(C, Cop, s);
return mixed;
}
}
void main() {
gl_FragColor = SMAANeighborhoodBlendingPS( fTexCoord, fOffset, tColor, tBlendWeights );
}`)); return n
          } const u = Object.freeze({ __proto__: null, build: q }); a.SMAAShader = u; a.build = q
        })
    }, "esri/views/3d/webgl-engine/lib/SSAOHelper": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec4f64 ../../../../support/requestImageUtils ./glUtil3D ./SSAOTechnique ./Util ../../../webgl/FramebufferObject ../../../webgl/Texture ../../../webgl/Util".split(" "), function (a, w, c, q, u, y, n, p, l,
        h, b, d, f, t) {
          let v = function () {
            function g(k, r, A) { this._techniqueRep = k; this._rctx = r; this._requestRender = A; this._enabled = !1; this._ssaoTechniqueConfig = new h.SSAOTechniqueConfiguration; this.quadVAO = null; this._blurSizePx = 2; this._attenuation = .5 } var x = g.prototype; x.dispose = function () { this.quadVAO = q.disposeMaybe(this.quadVAO) }; x.computeSSAO = function (k, r, A) {
              if (!(!this.enabled || q.isNone(r) || q.isNone(A) || q.isNone(this._noiseTexture) || q.isNone(this._ssaoFBO) || q.isNone(this._blur0FBO) || q.isNone(this._blur1FBO))) {
                var z =
                  this._rctx, B = k.fullViewport, C = B[2], D = B[3], E = C / this._blurSizePx, H = D / this._blurSizePx; this._ssaoFBO.resize(C, D); this._blur0FBO.resize(E, H); this._blur1FBO.resize(E, H); E = 1 * C; H = 1 * D; z.bindFramebuffer(this._ssaoFBO); z.setViewport(0, 0, C, D); var J = this._ssaoTechnique.program; z.useProgram(J); this._ssaoTechnique.bindPipelineState(z); J.setUniform2f("rnmScale", C / this._noiseTexture.descriptor.width, D / this._noiseTexture.descriptor.height); b.inverseProjectionInfo(k.projectionMatrix, k.fullWidth, k.fullHeight, e, m); J.setUniform4fv("projInfo",
                    e); J.setUniform2fv("zScale", m); J.setUniform2f("nearFar", k.near, k.far); C = 1 / k.computeRenderPixelSizeAtDist(1); J.setUniform1f("projScale", 1 * C); J.setUniform2f("screenDimensions", E, H); D = y.distance(k.eye, k.center); var M = 20 * k.computeRenderPixelSizeAtDist(D); M = Math.max(.1, M); J.setUniform1f("radius", M); J.setUniform1f("intensity", 4 * this._attenuation / M ** 6); J.bindTexture(this._noiseTexture, "rnm"); J.bindTexture(A, "normalMap"); J.bindTexture(r, "depthMap"); q.isNone(this.quadVAO) && (this.quadVAO = l.createQuadVAO(this._rctx));
                z.bindVAO(this.quadVAO); z.drawArrays(5, 0, t.vertexCount(this.quadVAO, "geometry")); J = this._blurTechnique.program; z.useProgram(J); J.bindTexture(this._ssaoFBO.colorTexture, "tex"); J.bindTexture(A, "normalMap"); J.bindTexture(r, "depthMap"); z.setViewport(0, 0, E / this._blurSizePx, H / this._blurSizePx); z.bindFramebuffer(this._blur0FBO); J.setUniform2f("screenDimensions", E, H); J.setUniform2f("blurSize", 0, 1 * this._blurSizePx / H); J.setUniform2f("nearFar", k.near, k.far); 5E4 < D && (C = Math.max(0, C - (D - 5E4))); J.setUniform1f("projScale",
                  C); z.drawArrays(5, 0, t.vertexCount(this.quadVAO, "geometry")); J.setUniform2f("blurSize", 1 * this._blurSizePx / E, 0); z.bindFramebuffer(this._blur1FBO); J.bindTexture(this._blur0FBO.colorTexture, "tex"); z.drawArrays(5, 0, t.vertexCount(this.quadVAO, "geometry")); z.setViewport(B[0], B[1], B[2], B[3])
              }
            }; x.bind = function (k, r) {
            this.enabled && q.isSome(this._blur1FBO) && q.isSome(this._ssaoFBO) ? (k.bindTexture(this._blur1FBO.colorTexture, "ssaoTex"), k.setUniform4f("viewportPixelSz", r.fullViewport[0], r.fullViewport[1], 1 / this._ssaoFBO.width,
              1 / this._ssaoFBO.height)) : k.setUniform4f("viewportPixelSz", -1, -1, -1, -1)
            }; x._selectPrograms = function () { this._ssaoTechniqueConfig.output = 0; this._ssaoTechnique = this._techniqueRep.releaseAndAcquire(h.SSAOTechnique, this._ssaoTechniqueConfig, this._ssaoTechnique); this._ssaoTechniqueConfig.output = 1; this._blurTechnique = this._techniqueRep.releaseAndAcquire(h.SSAOTechnique, this._ssaoTechniqueConfig, this._blurTechnique) }; x._enable = function () {
            this.enabled || (this._enabled = !0, this._loadResources(() => {
            this._enabled &&
              this._initialize()
            }))
            }; x._loadResources = function (k) { this._data ? k() : (new Promise((r, A) => a(["./SSAOHelperData"], r, A))).then(r => { this._data = r; k() }) }; x._initialize = function () {
              const k = { target: 3553, pixelFormat: 6408, dataType: 5121, samplingMode: 9729, wrapMode: 33071, width: 0, height: 0 }, r = { colorTarget: 0, depthStencilTarget: 0 }; p.requestImage(this._data.noiseTexture).then(A => {
              this._enabled && (this._ssaoFBO = new d(this._rctx, r, k), this._blur0FBO = new d(this._rctx, r, k), this._blur1FBO = new d(this._rctx, r, k), this._noiseTexture =
                new f(this._rctx, { target: 3553, pixelFormat: 6408, dataType: 5121, hasMipmap: !0, width: A.width, height: A.height }, A), this._requestRender())
              }); this._selectPrograms()
            }; x._disable = function () { this._enabled = !1; this._noiseTexture = q.disposeMaybe(this._noiseTexture); this._blur1FBO = q.disposeMaybe(this._blur1FBO); this._blur0FBO = q.disposeMaybe(this._blur0FBO); this._ssaoFBO = q.disposeMaybe(this._ssaoFBO) }; c._createClass(g, [{ key: "enabled", get: function () { return this._enabled }, set: function (k) { k ? this._enable() : this._disable() } },
            { key: "ready", get: function () { return this.enabled && q.isSome(this._noiseTexture) && q.isSome(this._ssaoFBO) && q.isSome(this._blur0FBO) && q.isSome(this._blur1FBO) } }, { key: "gpuMemoryUsage", get: function () { return (q.isSome(this._blur0FBO) ? this._blur0FBO.gpuMemoryUsage : 0) + (q.isSome(this._blur1FBO) ? this._blur1FBO.gpuMemoryUsage : 0) + (q.isSome(this._ssaoFBO) ? this._ssaoFBO.gpuMemoryUsage : 0) } }, { key: "test", get: function () { return { ssao: this._ssaoFBO, blur: this._blur1FBO } } }]); return g
          }(); const m = u.create(), e = n.create(); w.SSAOHelper =
            v; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/SSAOTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ./DefaultVertexAttributeLocations ./Program ../../../../chunks/SSAO.glsl ../../../webgl/renderState".split(" "), function (a, w, c, q, u, y, n, p, l, h, b) {
        y = function (d) {
          function f() {
            return d.apply(this,
              arguments) || this
          } c._inheritsLoose(f, d); var t = f.prototype; t.initializeProgram = function (v) { var m = f.shader.get(); const e = (f.filterRadius + 1) / 2; m = m.build({ output: this.configuration.output, samples: f.samples, filterRadius: f.filterRadius, blurFalloff: 1 / (2 * e * e) }); return new l.Program(v.rctx, m, p.Default3D) }; t.initializePipeline = function () { return b.makePipelineState({ colorWrite: b.defaultColorWriteParams }) }; return f
        }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(h.SSAOShader, () => new Promise((d, f) => a(["../shaders/SSAO.glsl"],
          d, f))); y.samples = 16; y.filterRadius = 4; u = function (d) { function f() { var t = d.apply(this, arguments) || this; t.output = 0; return t } c._inheritsLoose(f, d); return f }(n.ShaderTechniqueConfiguration); q.__decorate([n.parameter({ count: 2 })], u.prototype, "output", void 0); w.SSAOTechnique = y; w.SSAOTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/chunks/SSAO.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y) {
          function n(l) {
            const h = new y.ShaderBuilder; h.include(w.ScreenSpacePass); 1 === l.output && (h.fragment.include(c.ReadLinearDepth), h.fragment.uniforms.add("normalMap", "sampler2D").add("depthMap", "sampler2D").add("tex", "sampler2D").add("blurSize", "vec2").add("projScale", "float").add("nearFar", "vec2"), h.fragment.code.add(u.glsl`
      void blurFunction(vec2 uv, float r, float center_d, float sharpness, inout float wTotal, inout float bTotal) {
        float c = texture2D(tex, uv).r;
        float d = linearDepthFromTexture(depthMap, uv, nearFar);

        float ddiff = d - center_d;

        float w = exp(-r * r * ${u.glsl.float(l.blurFalloff)} - ddiff * ddiff * sharpness);
        wTotal += w;
        bTotal += w * c;
      }
    `), h.fragment.code.add(u.glsl`
      void main(void) {
        float b = 0.0;
        float w_total = 0.0;

        float center_d = linearDepthFromTexture(depthMap, uv, nearFar);

        float sharpness = -0.05 * projScale/center_d;
        for (int r = -${u.glsl.int(l.filterRadius)}; r <= ${u.glsl.int(l.filterRadius)}; ++r) {
          float rf = float(r);
          vec2 uvOffset = uv + rf * blurSize;
          blurFunction(uvOffset, rf, center_d, sharpness, w_total, b);
        }

        gl_FragColor = vec4(b / w_total);
      }
    `)); 0 === l.output && (h.fragment.include(c.ReadLinearDepth), h.include(q.CameraSpace), h.fragment.uniforms.add("normalMap", "sampler2D").add("depthMap", "sampler2D").add("intensity", "float").add("projScale", "float").add("radius", "float").add("nearFar", "vec2").add("screenDimensions", "vec2").add("rnmScale", "vec2").add("rnm", "sampler2D"), h.fragment.code.add(u.glsl`vec3 sphere[16];
void fillSphere() {
sphere[0] = vec3(0.186937, 0.0, 0.0);
sphere[1] = vec3(0.700542, 0.0, 0.0);
sphere[2] = vec3(-0.864858, -0.481795, -0.111713);
sphere[3] = vec3(-0.624773, 0.102853, -0.730153);
sphere[4] = vec3(-0.387172, 0.260319, 0.007229);
sphere[5] = vec3(-0.222367, -0.642631, -0.707697);
sphere[6] = vec3(-0.01336, -0.014956, 0.169662);
sphere[7] = vec3(0.122575, 0.1544, -0.456944);
sphere[8] = vec3(-0.177141, 0.85997, -0.42346);
sphere[9] = vec3(-0.131631, 0.814545, 0.524355);
sphere[10] = vec3(-0.779469, 0.007991, 0.624833);
sphere[11] = vec3(0.308092, 0.209288,0.35969);
sphere[12] = vec3(0.359331, -0.184533, -0.377458);
sphere[13] = vec3(0.192633, -0.482999, -0.065284);
sphere[14] = vec3(0.233538, 0.293706, -0.055139);
sphere[15] = vec3(0.417709, -0.386701, 0.442449);
}
float fallOffFunction(float vv, float vn, float bias) {
float f = max(radius * radius - vv, 0.0);
return f * f * f * max(vn-bias, 0.0);
}`), h.fragment.code.add(u.glsl`float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {
vec3 v = Q - C;
float vv = dot(v, v);
float vn = dot(normalize(v), n_C);
return fallOffFunction(vv, vn, 0.1);
}`), h.fragment.code.add(u.glsl`
      void main(void) {
        fillSphere();
        vec3 fres = normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));
        float currentPixelDepth = linearDepthFromTexture(depthMap, uv, nearFar);

        if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
          gl_FragColor = vec4(0.0);
          return;
        }

        vec3 currentPixelPos = reconstructPosition(gl_FragCoord.xy,currentPixelDepth);

        // get the normal of current fragment
        vec4 norm4 = texture2D(normalMap, uv);
        vec3 norm = vec3(-1.0) + 2.0 * norm4.xyz;
        bool isTerrain = norm4.w<0.5;

        float sum = .0;
        vec3 tapPixelPos;

        // note: the factor 2.0 should not be necessary, but makes ssao much nicer.
        // bug or deviation from CE somewhere else?
        float ps = projScale/(2.0 * currentPixelPos.z * zScale.x + zScale.y);

        for(int i = 0; i < ${u.glsl.int(l.samples)}; ++i) {
          vec2 unitOffset = reflect(sphere[i], fres).xy;
          vec2 offset = vec2(-unitOffset * radius * ps);

          //don't use current or very nearby samples
          if ( abs(offset.x)<2.0 || abs(offset.y)<2.0) continue;

          vec2 tc = vec2(gl_FragCoord.xy + offset);
          if (tc.x < 0.0 || tc.y < 0.0 || tc.x > screenDimensions.x || tc.y > screenDimensions.y) continue;
          vec2 tcTap = tc/screenDimensions;
          float occluderFragmentDepth = linearDepthFromTexture(depthMap, tcTap, nearFar);

          if (isTerrain) {
            bool isTerrainTap = texture2D(normalMap, tcTap).w<0.5;
            if (isTerrainTap) {
              continue;
            }
          }

          tapPixelPos = reconstructPosition(tc, occluderFragmentDepth);

          sum+= aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);
        }

        // output the result
        float A = max(1.0-sum*intensity/float(${u.glsl.int(l.samples)}),0.0);

        // Anti-tone map to reduce contrast and drag dark region farther: (x^0.2 + 1.2 * x^4)/2.2
        A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;
        gl_FragColor = vec4(A);
      }
    `)); return h
          } const p = Object.freeze({ __proto__: null, build: n }); a.SSAOShader = p; a.build = n
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/EdgeView": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../core/Accessor ../../../../../core/arrayUtils ../../../../../core/Logger ../../../../../core/mathUtils ../../../../../core/maybe ../../../../../core/accessorSupport/decorators/property ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../chunks/mat3 ../../../../../chunks/mat3f64 ../../../../../chunks/mat4 ../../../../../chunks/mat4f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/sphere ../../../../../chunks/vec33 ../../core/shaderLibrary/attributes/VertexPosition.glsl ../../core/util/TwoVectorPosition ../GridLocalOriginFactory ../localOriginHelper ../LocalOriginManager ../Object3D ./bufferLayouts ./edgeBufferWriters ./EdgeRenderer ./EdgeWorkerHandle ./strokes ./util ../TextureBackedBuffer/BufferManager ../../../../support/WatchUpdatingTracking ../../../../webgl/BufferObject ../../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G) {
          function I(S) { let Q = null, T = null; for (let Y = 0; Y < S.geometries.length; Y++) { var da; const fa = S.geometryRecords[Y]; if (fa.material.supportsEdges) { if (!Q) Q = fa.transformation; else if (!u.equals(Q, fa.transformation)) return !1; if (!T && p.isSome(fa.origin)) T = fa; else if (p.isSome(null == (da = T) ? void 0 : da.origin) && p.isSome(fa.origin) && T.origin.id !== fa.origin.id) return !1 } } return !0 } const O = y.getLogger("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView");
          a.EdgeView = function (S) {
            function Q(da) { var Y = S.call(this, da) || this; Y.updatingHandles = new L.WatchUpdatingTracking; Y.perObjectData = new Map; Y.perObjectDataEvictionCache = new Set; Y.renderers = new Map; Y.numberOfRenderedEdges = 0; Y.gpuMemoryUsage = 0; Y.workerAbort = new AbortController; Y.tmpModelPosition = g.create(); Y.localOrigins = new C.LocalOriginManager(new z.GridLocalOriginFactory(da.renderSR)); return Y } w._inheritsLoose(Q, S); var T = Q.prototype; T.initialize = function () {
            this.worker = new M(this.schedule); this.componentColorManager =
              new P.BufferManager(this.rctx, 2); const da = E.VertexLayout.createBuffer(4); for (let Y = 0; 4 > Y; Y++)da.sideness.set(Y, 0, 0 === Y || 3 === Y ? 0 : 1), da.sideness.set(Y, 1, 0 === Y || 1 === Y ? 0 : 1); this.verticesBufferObject = N.createVertex(this.rctx, 35044, da.buffer)
            }; T.destroy = function () {
            this.destroyed || (this.perObjectData.forEach(da => this._discardObjectEntry(da)), this.perObjectData.clear(), this.strokesTexture = p.disposeMaybe(this.strokesTexture), this.componentColorManager = p.destroyMaybe(this.componentColorManager), this.workerAbort.abort(),
              this.worker.destroy(), this.verticesBufferObject = p.disposeMaybe(this.verticesBufferObject), this.renderers.clear(), this.updatingHandles.destroy())
            }; T.shouldRender = function () { return 0 < this.renderers.size }; T.addComponentObject = function () {
              var da = w._asyncToGenerator(function* (Y, fa, ha, ka, ea, ba, aa, W) {
                if (!this.hasObject(Y)) {
                  var U; ha = new R(new Promise(X => U = X), ha.center, ha.radius); this.perObjectData.set(Y, ha); yield this.updatingHandles.addPromise(this.addComponentGeometry(fa, ha, ka, ea, ba, aa, W)); this.setNeedsRender();
                  U()
                }
              }); return function (Y, fa, ha, ka, ea, ba, aa, W) { return da.apply(this, arguments) }
            }(); T.addOrUpdateObject3D = function () {
              var da = w._asyncToGenerator(function* (Y, fa, ha, ka) {
                if (this.destroyed) O.warn("Attempt to add an object to a destroyed instance"); else {
                  var ea = this.perObjectData.get(Y); 0 < (null == ea ? void 0 : ea.renderables.length) && this.perObjectDataEvictionCache.add(ea); var ba, aa = Y.boundingVolumeWorldSpace.bounds; aa = new R(new Promise(U => ba = U), x.getCenter(aa), x.getRadius(aa)); this.perObjectData.set(Y, aa); var W =
                    []; if (ha.mergeGeometries && 1 < Y.geometries.length && I(Y)) W.push(this.addObjectMergedGeometries(Y, aa, fa, ha, ka)); else for (let U = 0; U < Y.geometries.length; U++) { const X = Y.geometryRecords[U]; X.material.supportsEdges && W.push(this.addGeometry(Y, aa, Y.geometries[U], X, fa[0], ha, ka)) } yield this.updatingHandles.addPromise(Promise.all(W)); this.perObjectDataEvictionCache.delete(aa); this._discardObjectEntry(ea); this.setNeedsRender(); ba()
                }
              }); return function (Y, fa, ha, ka) { return da.apply(this, arguments) }
            }(); T._discardObjectEntry =
              function (da) { da && (da.renderables.length && (da.renderables.forEach(Y => this.removeRenderable(Y)), this.setNeedsRender()), da.loaded = null) }; T.hasObject = function (da) { return this.perObjectData.has(da) }; T.updateAllComponentOpacities = function () {
                var da = w._asyncToGenerator(function* (Y, fa) {
                  const ha = fa instanceof Array ? ka => fa[ka] : () => fa; (yield this.updatingHandles.addPromise(this.getObjectEntry(Y))).renderables.forEach(ka => {
                    const ea = ka.components.meta.length; for (let ba = 0; ba < ea; ba++) {
                      const aa = ha(ba), W = ka.components.meta[ba],
                      U = W.index; W.material.opacity = aa; ka.components.buffer.textureBuffer.setDataElement(U, 1, 3, 255 * aa)
                    } this.updateTransparency(ka)
                  }); this.setNeedsRender()
                }); return function (Y, fa) { return da.apply(this, arguments) }
              }(); T.updateAllComponentMaterials = function () {
                var da = w._asyncToGenerator(function* (Y, fa, ha, ka) {
                  const ea = Y instanceof D.Object3D, ba = !!ha.slicePlaneEnabled, aa = K.determineRendererType(fa), W = J.EdgeRenderer.getKey(aa, ba, ea); (yield this.updatingHandles.addPromise(this.getObjectEntry(Y))).renderables.forEach(U => { if (W !== U.rendererKey) { var X = this.renderers.get(U.rendererKey); const Z = this.acquireRenderer(aa, ba, ea); X.removeRenderable(U); X.refCount.decrement(); U.rendererKey = W; Z.addRenderable(U) } for (X = 0; X < fa.length; X++)U.components.meta[X].material = fa[X]; ka && this.updateComponentBuffer(U.components); this.updateTransparency(U) }); this.setNeedsRender()
                }); return function (Y, fa, ha, ka) { return da.apply(this, arguments) }
              }(); T.updateObjectVisibility = function () {
                var da = w._asyncToGenerator(function* (Y, fa) {
                  (yield this.updatingHandles.addPromise(this.getObjectEntry(Y))).renderables.forEach(ha =>
                    ha.visible = fa); this.setNeedsRender()
                }); return function (Y, fa) { return da.apply(this, arguments) }
              }(); T.removeObject = function (da) { const Y = this.perObjectData.get(da); Y && (this.perObjectData.delete(da), this._discardObjectEntry(Y)) }; T.getObjectEntry = function () { var da = w._asyncToGenerator(function* (Y) { Y = this.perObjectData.get(Y); if (!Y) throw "no object"; yield Y.loaded; return Y }); return function (Y) { return da.apply(this, arguments) } }(); T.removeAll = function () { this.perObjectData.forEach((da, Y) => this.removeObject(Y)) };
            T.render = function (da, Y) {
              if (!p.isNone(this.componentColorManager)) {
                this.localOrigins.updateViewMatrices(da.camera.viewMatrix); var fa = da.camera.viewInverseTransposeMatrix, ha = g.create(), ka = new A.TwoVectorPosition, ea = new r.VertexPosition.ViewProjectionTransform, ba = t.create(); e.set(ha, fa[3], fa[7], fa[11]); ka.set(ha); e.copy(ea.worldFromView_TH, ka.high); e.copy(ea.worldFromView_TL, ka.low); f.fromMat4(ea.viewFromCameraRelative_RS, da.camera.viewMatrix); v.copy(ea.projFromView, da.camera.projectionMatrix); fa = t.create();
                f.transpose(fa, ea.viewFromCameraRelative_RS); f.invert(ba, fa); var aa = 0, W = 0; this.renderers.forEach(X => { 0 === X.refCount.value ? (this.renderers.delete(X.key), X.dispose()) : X.forEachRenderable(Z => { aa += Z.statistics.averageEdgeLength; W++ }, Y) }); this.componentColorManager.garbageCollect(); this.componentColorManager.updateTextures(); if (0 !== W) {
                  var U = { distanceFalloffFactor: 40 * aa / W, minimumEdgeLength: da.camera.perScreenPixelRatio, transparency: Y, viewProjectionTransform: ea, transformNormal_ViewFromGlobal: ba }; this.updateObjectCameraDistances(da);
                  this.numberOfRenderedEdges = 0; this.renderers.forEach(X => { this.renderRegularEdges(X, da, U); this.renderSilhouetteEdges(X, da, U) })
                }
              }
            }; T.updateTransparency = function (da) { const Y = K.determineEdgeTransparency(da.components.meta), fa = K.determineObjectTransparency(da.components.meta); if (Y !== da.edgeTransparency || fa !== da.objectTransparency) da.edgeTransparency = Y, da.objectTransparency = fa, this.renderers.get(da.rendererKey).setRenderablesDirty() }; T.computeModelTransformWithLocalOrigin = function (da, Y, fa) {
              da.getCombinedStaticTransformation(Y,
                fa); p.isSome(Y.origin) ? this.localOrigins.register(Y.origin) : (da = e.set(this.tmpModelPosition, fa[12], fa[13], fa[14]), Y.origin = this.localOrigins.acquire(da)); B.applyToModelMatrix(Y.origin.vec3, fa); return Y.origin
            }; T.updateComponentBuffer = function (da) {
              const { meta: Y, buffer: fa } = da; for (da = 0; da < Y.length; da++) {
                var ha = Y[da].material; const ka = Y[da].index, ea = n.clamp(Math.round(ha.size * J.LINE_WIDTH_FRACTION_FACTOR), 0, 255), ba = n.clamp(ha.extensionLength, -J.EXTENSION_LENGTH_OFFSET, 255 - J.EXTENSION_LENGTH_OFFSET) + J.EXTENSION_LENGTH_OFFSET,
                  aa = "solid" === ha.type ? 0 : 1, W = 255 * ha.opacity; ha = ha.color; fa.textureBuffer.setData(ka, 0, 255 * ha[0], 255 * ha[1], 255 * ha[2], 255 * ha[3]); fa.textureBuffer.setData(ka, 1, ea, ba, aa, W)
              }
            }; T.createComponentBuffers = function (da) { if (p.isNone(this.componentColorManager)) return null; const Y = [], fa = this.componentColorManager.getBuffer(da.length); for (let ha = 0; ha < da.length; ha++) { const ka = da[ha], ea = fa.acquireIndex(); Y.push({ index: ea, material: ka }) } da = { meta: Y, buffer: fa }; this.updateComponentBuffer(da); return da }; T.extractEdges = function (da,
              Y, fa, ha, ka, ea = ka.length) { return this.worker.process({ data: Y, indices: ka, indicesLength: ea, writerSettings: da, skipDeduplicate: fa }, this.workerAbort.signal, ha) }; T.createEdgeResources = function (da) {
                const Y = {}; if (p.isNone(this.verticesBufferObject)) return Y; if (0 < da.regular.lodInfo.lengths.length) {
                  var fa = new G(this.rctx, E.EdgeShaderAttributeLocations, { vertices: E.glVertexLayout, instances: H.RegularEdgeBufferWriter.glLayout }, { vertices: this.verticesBufferObject, instances: N.createVertex(this.rctx, 35044, da.regular.instancesData.buffer) });
                  Y.regular = { vao: fa, lod: da.regular.lodInfo }
                } 0 < da.silhouette.lodInfo.lengths.length && (fa = new G(this.rctx, E.EdgeShaderAttributeLocations, { vertices: E.glVertexLayout, instances: H.SilhouetteEdgeBufferWriter.glLayout }, { vertices: this.verticesBufferObject, instances: N.createVertex(this.rctx, 35044, da.silhouette.instancesData.buffer) }), Y.silhouette = { vao: fa, lod: da.silhouette.lodInfo }); return Y
              }; T.addGeometry = function () {
                var da = w._asyncToGenerator(function* (Y, fa, ha, ka, ea, ba, aa) {
                  const W = ha.vertexAttributes.get("position"),
                  U = ha.indices.get("position"), X = m.create(); Y = this.computeModelTransformWithLocalOrigin(Y, ka, X); return this.addPositionData(fa, { position: W, indices: U, modelTransform: X, origin: Y }, ha.edgeIndicesLength, ea, ba, aa)
                }); return function (Y, fa, ha, ka, ea, ba, aa) { return da.apply(this, arguments) }
              }(); T.addPositionData = function () {
                var da = w._asyncToGenerator(function* (Y, fa, ha, ka, ea, ba = !1) {
                  if (null != Y.loaded) {
                    var aa = this.createComponentBuffers([ka]); if (!(p.isNone(aa) || 0 >= ha)) {
                      ka = this.acquireRenderer(ka.type, !!ea.slicePlaneEnabled);
                      var { modelTransform: W, origin: U } = fa; ea = fa.indices; fa = fa.position; var X = fa.data.length / fa.size, Z = E.EdgeInputBufferLayout.createBuffer(X); for (let ma = 0; ma < X; ma++)Z.position.set(ma, 0, fa.data[ma * fa.size]), Z.position.set(ma, 1, fa.data[ma * fa.size + 1]), Z.position.set(ma, 2, fa.data[ma * fa.size + 2]); K.fillComponenBufferIndices(aa.meta, [0, Z.componentIndex.count], Z.componentIndex); ba = yield this.updatingHandles.addPromise(this.extractEdges(ka.writerSettings, Z, !1, ba, ea, ha)); if (null != Y.loaded) {
                        var { regular: ia, silhouette: la } =
                          this.createEdgeResources(ba); ha = (ia ? ia.vao.size : 0) + (la ? la.vao.size : 0); aa = { regular: ia, silhouette: la, transform: { modelMatrix: W, origin: U }, statistics: { gpuMemoryUsage: ha, averageEdgeLength: ba.averageEdgeLength }, components: aa, visible: !0, edgeTransparency: K.determineEdgeTransparency(aa.meta), objectTransparency: K.determineObjectTransparency(aa.meta), distanceToCamera: 0, rendererKey: ka.key }; Y.renderables.push(aa); ka.addRenderable(aa); this.gpuMemoryUsage += ha
                      }
                    }
                  }
                }); return function (Y, fa, ha, ka, ea) {
                  return da.apply(this,
                    arguments)
                }
              }(); T.addComponentGeometry = function () {
                var da = w._asyncToGenerator(function* (Y, fa, ha, ka, ea, ba, aa) {
                  if (null != fa.loaded) {
                    var W = this.createComponentBuffers(ba); if (!p.isNone(W) && (ba = K.determineRendererType(ba), aa = this.acquireRenderer(ba, aa.slicePlaneEnabled || !1, !1), ba = E.EdgeInputBufferLayout.createBuffer(ha.count), k.copy(ba.position, ha), K.fillComponenBufferIndices(W.meta, ea, ba.componentIndex, ka), ka = yield this.updatingHandles.addPromise(this.extractEdges(aa.writerSettings, ba, !0, !1, ka)), null != fa.loaded)) {
                      var { regular: U,
                        silhouette: X } = this.createEdgeResources(ka); ha = (U ? U.vao.size : 0) + (X ? X.vao.size : 0); Y = { regular: U, silhouette: X, transform: Y, statistics: { gpuMemoryUsage: ha, averageEdgeLength: ka.averageEdgeLength }, components: W, visible: !0, edgeTransparency: K.determineEdgeTransparency(W.meta), objectTransparency: K.determineObjectTransparency(W.meta), distanceToCamera: 0, rendererKey: aa.key }; fa.renderables.push(Y); aa.addRenderable(Y); this.gpuMemoryUsage += ha
                    }
                  }
                }); return function (Y, fa, ha, ka, ea, ba, aa) { return da.apply(this, arguments) }
              }();
            T.addObjectMergedGeometries = function () {
              var da = w._asyncToGenerator(function* (Y, fa, ha, ka, ea) {
                var ba = new Map, aa = 0, W = null, U = 0; for (var X = 0; X < Y.geometries.length; X++) { var Z = Y.geometries[X], ia = Y.geometryRecords[X]; ia.material.supportsEdges && (!W && ia.origin && (W = ia), ia = Z.vertexAttributes.get("position"), U += ia.data.length / ia.size, aa += Z.edgeIndicesLength) } U = 65536 <= U ? Uint32Array : Uint16Array; aa = aa ? new U(aa) : null; U = []; X = 0; for (Z = 0; Z < Y.geometries.length; Z++) {
                  ia = Y.geometries[Z]; if (!Y.geometryRecords[Z].material.supportsEdges) continue;
                  var la = ia.vertexAttributes.get("position"); const ma = ia.indices.get("position"); let ra = ba.get(la.data); if (null == ra) { ra = U.length / 3; for (let Aa = 0; Aa < la.data.length; Aa += la.size)U.push(la.data[Aa + 0]), U.push(la.data[Aa + 1]), U.push(la.data[Aa + 2]); ba.set(la.data, ra) } if (ma) for (la = 0; la < ia.edgeIndicesLength; la++)aa[X++] = ra + ma[la]
                } W = W || Y.geometryRecords[0]; ba = m.create(); W = this.computeModelTransformWithLocalOrigin(Y, W, ba); for (X = 0; X < Y.geometryRecords.length; X++)Y.geometryRecords[X].origin = W; yield this.updatingHandles.addPromise(this.addPositionData(fa,
                  { position: { data: U, size: 3 }, indices: aa, modelTransform: ba, origin: W }, aa.length, ha[0], ka, ea))
              }); return function (Y, fa, ha, ka, ea) { return da.apply(this, arguments) }
            }(); T.acquireRenderer = function (da, Y, fa = !0) {
              const ha = J.EdgeRenderer.getKey(da, Y, fa); let ka = this.renderers.get(ha); p.isNone(this.strokesTexture) && (this.strokesTexture = F.generateStrokesTexture(this.rctx)); ka || (ka = new J.EdgeRenderer(this.rctx, this.techniqueRepository, { type: da, slicePlaneEnabled: Y, strokesTexture: this.strokesTexture, legacy: fa }), this.renderers.set(ha,
                ka)); ka.refCount.increment(); return ka
            }; T.removeRenderable = function (da) {
            da.regular && (da.regular.vao.vertexBuffers.instances.dispose(), da.regular.vao.dispose(!1), da.regular.vao = null); da.silhouette && (da.silhouette.vao.vertexBuffers.instances.dispose(), da.silhouette.vao.dispose(!1), da.silhouette.vao = null); const Y = this.renderers.get(da.rendererKey); if (Y) {
              Y.removeRenderable(da); Y.refCount.decrement(); "origin" in da.transform && this.localOrigins.release(da.transform.origin); this.gpuMemoryUsage -= da.statistics.gpuMemoryUsage;
              for (const fa of da.components.meta) da.components.buffer.releaseIndex(fa.index)
            }
            }; T.updateObjectCameraDistances = function (da) { const Y = da.camera.eye, fa = da.camera.viewForward, ha = g.create(); da = ka => { const { center: ea, radius: ba } = ka; e.sub(ha, ea, Y); const aa = e.dot(ha, fa), W = aa < -ba ? Infinity : aa < ba ? 0 : aa - ba; ka.renderables.forEach(U => U.distanceToCamera = W) }; this.perObjectData.forEach(da); this.perObjectDataEvictionCache.forEach(da) }; T.renderRegularEdges = function (da, Y, fa) {
              da.bindRegularEdges(Y, fa); da.forEachRenderable(ha => { if (ha.visible && ha.regular) { var ka = K.computeEdgeCount(ha.regular.lod.lengths, ha.distanceToCamera, fa); "origin" in ha.transform && (Y.localViewMatrixForEdges = this.localOrigins.getViewMatrix(ha.transform.origin)); da.renderRegularEdges(ha, Y, ka); this.numberOfRenderedEdges += ka } }, fa.transparency)
            }; T.renderSilhouetteEdges = function (da, Y, fa) {
              da.bindSilhouetteEdges(Y, fa); da.forEachRenderable(ha => {
                if (ha.visible && ha.silhouette) {
                  var ka = K.computeEdgeCount(ha.silhouette.lod.lengths, ha.distanceToCamera, fa); "origin" in
                    ha.transform && (Y.localViewMatrixForEdges = this.localOrigins.getViewMatrix(ha.transform.origin)); da.renderSilhouetteEdges(ha, Y, ka); this.numberOfRenderedEdges += ka
                }
              }, fa.transparency)
            }; w._createClass(Q, [{ key: "updating", get: function () { return this.updatingHandles.updating } }, { key: "usedMemory", get: function () { return this.gpuMemoryUsage } }, { key: "numberOfRenderedPrimitives", get: function () { return this.numberOfRenderedEdges } }]); return Q
          }(q); c.__decorate([l.property({ constructOnly: !0 })], a.EdgeView.prototype, "rctx",
            void 0); c.__decorate([l.property({ constructOnly: !0 })], a.EdgeView.prototype, "renderSR", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.EdgeView.prototype, "techniqueRepository", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.EdgeView.prototype, "setNeedsRender", void 0); c.__decorate([l.property({ constructOnly: !0 })], a.EdgeView.prototype, "schedule", void 0); c.__decorate([l.property({ readOnly: !0 })], a.EdgeView.prototype, "updatingHandles", void 0); c.__decorate([l.property({ readOnly: !0 })], a.EdgeView.prototype,
              "updating", null); a.EdgeView = c.__decorate([d.subclass("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView")], a.EdgeView); let R = function (S, Q, T) { this.center = Q; this.radius = T; this.renderables = []; this.loaded = S; this.loaded.then(() => { null != this.loaded && (this.loaded = !0) }) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/localOriginHelper": function () {
      define(["exports"], function (a) {
      a.applyToModelMatrix = function (w, c) {
        const q = -w[0], u = -w[1]; w = -w[2]; const y = c[3], n = c[7], p = c[11],
          l = c[15]; c[0] += y * q; c[1] += y * u; c[2] += y * w; c[4] += n * q; c[5] += n * u; c[6] += n * w; c[8] += p * q; c[9] += p * u; c[10] += p * w; c[12] += l * q; c[13] += l * u; c[14] += l * w
      }; a.applyToViewMatrix = function (w, c) { const q = w[0], u = w[1]; w = w[2]; c[12] += q * c[0] + u * c[4] + w * c[8]; c[13] += q * c[1] + u * c[5] + w * c[9]; c[14] += q * c[2] + u * c[6] + w * c[10]; c[14] += q * c[3] + u * c[7] + w * c[11] }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/LocalOriginManager": function () {
      define(["exports", "../../../../chunks/mat4", "../../../../chunks/mat4f64", "./localOriginHelper"],
        function (a, w, c, q) {
          let u = function () {
            function y(p) { this.factory = p; this.originData = new Map } var n = y.prototype; n.acquire = function (p) { return this.register(this.factory.getOrigin(p)) }; n.register = function (p) { const l = this.originData.get(p.id); if (l) return l.refCount++ , l.origin; this.originData.set(p.id, { refCount: 1, viewMatrix: c.create(), origin: p }); return p }; n.release = function (p) { const l = this.originData.get(p.id); l && (l.refCount-- , 0 === l.refCount && this.originData.delete(p.id)) }; n.updateViewMatrices = function (p) {
              this.originData.forEach(l => { w.copy(l.viewMatrix, p); q.applyToViewMatrix(l.origin.vec3, l.viewMatrix) })
            }; n.getViewMatrix = function (p) { return this.originData.get(p.id).viewMatrix }; return y
          }(); a.LocalOriginManager = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts": function () {
      define(["exports", "../../../support/buffer/glUtil", "../../../support/buffer/InterleavedLayout"], function (a, w, c) {
        const q = c.newLayout().vec3f("position").u16("componentIndex").u16("u16padding"), u =
          c.newLayout().vec2u8("sideness"); w = w.glLayout(u); c = c.newLayout().vec3f("position0").vec3f("position1").u16("componentIndex").u8("variantOffset", { glNormalized: !0 }).u8("variantStroke").u8("variantExtension", { glNormalized: !0 }).u8("u8padding", { glPadding: !0 }).u16("u16padding", { glPadding: !0 }); const y = c.clone().vec3f("normal"), n = c.clone().vec3f("normalA").vec3f("normalB"), p = new Map([["position0", 0], ["position1", 1], ["componentIndex", 2], ["variantOffset", 3], ["variantStroke", 4], ["variantExtension", 5], ["normal",
            6], ["normalA", 6], ["normalB", 7], ["sideness", 8]]); a.CommonInstancesLayout = c; a.EdgeInputBufferLayout = q; a.EdgeShaderAttributeLocations = p; a.RegularEdgeInstancesLayout = y; a.SilhouetteEdgeInstancesLayout = n; a.VertexLayout = u; a.glVertexLayout = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters": function () {
      define("exports ../../../../../core/RandomLCG ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../support/buffer/glUtil ./bufferLayouts".split(" "),
        function (a, w, c, q, u, y) {
          function n(g) { const x = b; x[0] = g.position0[0]; x[1] = g.position0[1]; x[2] = g.position0[2]; x[3] = g.position1[0]; x[4] = g.position1[1]; x[5] = g.position1[2]; f[0] = 5381; for (g = 0; g < d.length; g++)f[0] = 31 * f[0] + d[g]; return f[0] } function p(g) { const x = b; x[0] = l(g.position0[0]); x[1] = l(g.position0[1]); x[2] = l(g.position0[2]); x[3] = l(g.position1[0]); x[4] = l(g.position1[1]); x[5] = l(g.position1[2]); f[0] = 5381; for (g = 0; g < d.length; g++)f[0] = 31 * f[0] + d[g]; return f[0] } function l(g) { return Math.round(1E4 * g) / 1E4 } let h =
            function () {
              function g() { } var x = g.prototype; x.updateSettings = function (k) { this.settings = k; this.edgeHashFunction = k.reducedPrecision ? p : n }; x.write = function (k, r, A) {
                var z = this.edgeHashFunction(A); e.seed = z; z = e.getIntRange(0, 255); const B = e.getIntRange(0, this.settings.variants - 1); var C = e.getFloat(); C = -(1 - Math.min(C / .7, 1)) + Math.max(0, C - .7) / (1 - .7); C = 255 * (Math.abs(C) ** 1.2 * (0 > C ? -1 : 1) * .5 + .5); k.position0.setVec(r, A.position0); k.position1.setVec(r, A.position1); k.componentIndex.set(r, A.componentIndex); k.variantOffset.set(r,
                  z); k.variantStroke.set(r, B); k.variantExtension.set(r, C)
              }; x.trim = function (k, r) { return k.slice(0, r) }; return g
            }(); const b = new Float32Array(6), d = new Uint32Array(b.buffer), f = new Uint32Array(1); let t = function () {
              function g() { this.commonWriter = new h } var x = g.prototype; x.updateSettings = function (k) { this.commonWriter.updateSettings(k) }; x.allocate = function (k) { return y.RegularEdgeInstancesLayout.createBuffer(k) }; x.write = function (k, r, A) {
                this.commonWriter.write(k, r, A); c.add(m, A.faceNormal0, A.faceNormal1); c.normalize(m,
                  m); k.normal.setVec(r, m)
              }; x.trim = function (k, r) { return this.commonWriter.trim(k, r) }; return g
            }(); t.Layout = y.RegularEdgeInstancesLayout; t.glLayout = u.glLayout(y.RegularEdgeInstancesLayout, 1); let v = function () {
              function g() { this.commonWriter = new h } var x = g.prototype; x.updateSettings = function (k) { this.commonWriter.updateSettings(k) }; x.allocate = function (k) { return y.SilhouetteEdgeInstancesLayout.createBuffer(k) }; x.write = function (k, r, A) {
                this.commonWriter.write(k, r, A); k.normalA.setVec(r, A.faceNormal0); k.normalB.setVec(r,
                  A.faceNormal1)
              }; x.trim = function (k, r) { return this.commonWriter.trim(k, r) }; return g
            }(); v.Layout = y.SilhouetteEdgeInstancesLayout; v.glLayout = u.glLayout(y.SilhouetteEdgeInstancesLayout, 1); const m = q.create(), e = new w; a.CommonBufferWriter = h; a.RegularEdgeBufferWriter = t; a.SilhouetteEdgeBufferWriter = v; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/EdgeRenderer": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/maybe ../../../../../core/PooledArray ../../../../../chunks/mat3 ../../../../../chunks/mat3f32 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../support/debugFlags ../../collections/Component/Material/ComponentTechnique ../../core/shaderLibrary/Slice.glsl ../../core/shaderLibrary/attributes/VertexPosition.glsl ../../core/shaderLibrary/shading/MultipassTerrainTest.glsl ../../core/shaderLibrary/util/DoublePrecision.glsl ../../core/util/TwoVectorPosition ./EdgeShaderTechnique".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = { type: "uber", slicePlaneEnabled: !1, sliceHighlightDisabled: !1, strokesTexture: null, legacy: !0 }; let g = function () { function z() { this._value = 0 } var B = z.prototype; B.increment = function () { this._value++ }; B.decrement = function () { this._value-- }; w._createClass(z, [{ key: "value", get: function () { return this._value } }]); return z }(); const x = { solid: 0, sketch: 1, uber: 2 }; let k = function () {
            function z(C, D, E) {
            this.rctx = C; this.shaderTechniqueRepository = D; this.config = new m.EdgeShaderTechnique.Configuration;
              this.technique = null; this.refCount = new g; this.renderables = new Set; this.sortedRenderables = { [1]: { [1]: new q, [2]: new q }, [2]: { [1]: new q, [2]: new q } }; this.renderablesDirty = !1; this.settings = { ...e, ...E }; this.key = z.getKey(this.settings.type, this.settings.slicePlaneEnabled, this.settings.legacy); this.writerSettings = { variants: this.settings.strokesTexture.variants, reducedPrecision: l.TESTS_DISABLE_OPTIMIZATIONS }; this.config.legacy = this.settings.legacy; this.config.mode = x[this.settings.type]; this.config.silhouette =
                !1; this.config.antialiasing = !!this.rctx.capabilities.blendMinMax; this.config.slicePlaneEnabled = this.settings.slicePlaneEnabled; this.config.doublePrecisionRequiresObfuscation = t.doublePrecisionRequiresObfuscation(C)
            } var B = z.prototype; B.dispose = function () { this.technique = c.releaseMaybe(this.technique) }; B.addRenderable = function (C) { this.renderables.add(C); this.renderablesDirty = !0 }; B.removeRenderable = function (C) { this.renderables.delete(C); this.renderablesDirty = !0 }; B.setRenderablesDirty = function () {
            this.renderablesDirty =
              !0
            }; B.forEachRenderable = function (C, D) { this.renderablesDirty && this.sortRenderables(); this.sortedRenderables[D][1].forAll(C); this.sortedRenderables[D][2].forAll(C) }; B.setMultipassParameters = function (C) { this.config.multipassTerrainEnabled = C.multipassTerrainEnabled ? C.multipassTerrainEnabled : !1; this.config.cullAboveGround = C.cullAboveGround ? C.cullAboveGround : !1 }; B.bindRegularEdges = function (C, D) {
              this.setMultipassParameters(C); this.config.silhouette = !1; this.technique = this.shaderTechniqueRepository.releaseAndAcquire(m.EdgeShaderTechnique,
                this.config, this.technique); this.technique.bindPass({ bindParameters: C, edgeRenderParameters: D }); this.technique.bindPipelineState(this.rctx, C.slot); this.rctx.useProgram(this.technique.program)
            }; B.bindSilhouetteEdges = function (C, D) {
              this.setMultipassParameters(C); this.config.silhouette = !0; this.technique = this.shaderTechniqueRepository.releaseAndAcquire(m.EdgeShaderTechnique, this.config, this.technique); this.technique.bindPass({ bindParameters: C, edgeRenderParameters: D }); this.technique.bindPipelineState(this.rctx,
                C.slot); this.rctx.useProgram(this.technique.program)
            }; B.renderRegularEdges = function (C, D, E) { this.render(C, C.regular.vao, D, E) }; B.renderSilhouetteEdges = function (C, D, E) { this.render(C, C.silhouette.vao, D, E) }; B.render = function (C, D, E, H) { this.setUniforms(C, E); this.rctx.bindVAO(D); this.rctx.capabilities.instancing.drawArraysInstanced(6, 0, 4, H) }; B.setUniforms = function (C, D) {
              const E = this.technique.program; C.components.buffer.textureBuffer.bind(E, "uComponentDataTex", "uComponentDataTexInvDim"); D.multipassTerrainEnabled &&
                (E.setUniform2fv("cameraNearFar", D.camera.nearFar), E.setUniform2fv("inverseViewport", D.inverseViewport), f.bindMultipassTerrainTexture(E, D)); if ("origin" in C.transform) E.setUniformMatrix4fv("uView", D.localViewMatrixForEdges), E.setUniformMatrix4fv("uModel", C.transform.modelMatrix), b.bindSliceUniforms(E, this.settings, D.slicePlane, C.transform.origin.vec3); else {
                  const H = new v.TwoVectorPosition(C.transform.position), J = u.transpose(r, u.invert(r, C.transform.rotationScale)), M = new h.ComponentDrawParameters; n.copy(M.worldFromModel_TL,
                    H.low); n.copy(M.worldFromModel_TH, H.high); u.copy(M.worldFromModel_RS, C.transform.rotationScale); u.copy(M.transformNormal_GlobalFromModel, J); d.VertexPosition.bindModelTransform(E, M); E.setUniformMatrix3fv("uTransformNormal_GlobalFromModel", M.transformNormal_GlobalFromModel); C = D.camera.viewInverseTransposeMatrix; C = n.set(A, C[3], C[7], C[11]); b.bindSliceUniforms(E, this.settings, D.slicePlane, C)
                } "uber" !== this.settings.type && "sketch" !== this.settings.type || this.setSketchUniforms(E); E.setUniform1f("uWorldLineRadiusPerDistance",
                  Math.tan(D.camera.fovY / 2) / (D.camera.fullViewport[3] / 2))
            }; B.setSketchUniforms = function (C) { const D = this.settings.strokesTexture, E = D.texture; c.isNone(E) || (C.bindTexture(E, "uStrokesTexture"), C.setUniform2f("uStrokesTextureScale", 1 / E.descriptor.width, 1 / E.descriptor.height), C.setUniform1f("uStrokesLog2Resolution", Math.log2(D.resolution)), C.setUniform1f("uStrokesNormalizationScale", D.normalizationScale), C.setUniform1f("uStrokesAmplitude", D.amplitude), C.setUniform1f("uStrokeVariants", D.variants)) }; B.sortRenderables =
              function () {
              this.renderablesDirty = !1; this.sortedRenderables[1][1].clear(); this.sortedRenderables[1][2].clear(); this.sortedRenderables[2][1].clear(); this.sortedRenderables[2][2].clear(); this.renderables.forEach(D => { 0 !== D.objectTransparency && 0 !== D.edgeTransparency && this.sortedRenderables[D.objectTransparency][D.edgeTransparency].push(D) }); const C = (D, E) => "origin" in D.transform && "origin" in E.transform ? D.transform.origin.id < E.transform.origin.id ? -1 : D.transform.origin.id > E.transform.origin.id ? 1 : 0 : 0; this.sortedRenderables[1][1].sort(C);
                this.sortedRenderables[1][2].sort(C); this.sortedRenderables[2][1].sort(C); this.sortedRenderables[2][2].sort(C)
              }; z.getKey = function (C, D, E) { return `edges-t:${C}:${D}:${E}` }; return z
          }(); const r = y.create(), A = p.create(); a.EXTENSION_LENGTH_OFFSET = 128; a.EdgeRenderer = k; a.LINE_WIDTH_FRACTION_FACTOR = 8; a.componentDataInvDimName = "uComponentDataTexInvDim"; a.componentDataTexName = "uComponentDataTex"; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/EdgeShaderTechnique": function () {
      define("require exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../core/shaderLibrary/attributes/VertexPosition.glsl ../../core/shaderTechnique/ReloadableShaderModule ../../core/shaderTechnique/ShaderTechnique ../../core/shaderTechnique/ShaderTechniqueConfiguration ../Program ./bufferLayouts ../../../../../chunks/EdgeShaderProgram.glsl ../../../../webgl/renderState".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        w.EdgeShaderTechnique = function (f) {
          function t() { return f.apply(this, arguments) || this } c._inheritsLoose(t, f); var v = t.prototype; v.bindPass = function (m) {
            const e = this.program, { edgeRenderParameters: g, bindParameters: x } = m; u.VertexPosition.bindViewProjTransform(e, g.viewProjectionTransform); e.setUniformMatrix3fv("uTransformNormal_ViewFromGlobal", g.transformNormal_ViewFromGlobal); e.setUniformMatrix4fv("uProj", x.camera.projectionMatrix); e.setUniform2f("uDepthBias", .5, -4E-4); e.setUniform2f("uPixelToNDC",
              2 / x.camera.fullViewport[2], 2 / x.camera.fullViewport[3]); e.setUniform2f("uNDCToPixel", x.camera.fullViewport[2] / 2, x.camera.fullViewport[3] / 2); e.setUniform1f("uDistanceFalloffFactor", g.distanceFalloffFactor); e.setUniform2f("uViewportDimInv", 1 / x.camera.fullViewport[2], 1 / x.camera.fullViewport[3]); e.setUniform1f("uPixelRatio", x.camera.pixelRatio || 1)
          }; v.initializeProgram = function (m) {
            var e = t.shader.get(); const g = this.configuration; e = e.build({
              slicePlaneEnabled: g.slicePlaneEnabled, sliceHighlightDisabled: !1,
              sliceEnabledForVertexPrograms: !1, silhouette: g.silhouette, legacy: g.legacy, antialiasing: g.antialiasing, mode: g.mode, doublePrecisionRequiresObfuscation: g.doublePrecisionRequiresObfuscation, multipassTerrainEnabled: g.multipassTerrainEnabled, cullAboveGround: g.cullAboveGround
            }); return new l.Program(m.rctx, e, h.EdgeShaderAttributeLocations)
          }; v.initializePipeline = function (m) {
            return (m = m.rctx.capabilities.blendMinMax) ? d.makePipelineState({
              blending: d.separateBlendingParams(1, 1, 0, 1, 32774, m.MAX), depthTest: { func: 515 },
              colorWrite: d.defaultColorWriteParams
            }) : d.makePipelineState({ depthTest: { func: 515 }, depthWrite: d.defaultDepthWriteParams, colorWrite: d.defaultColorWriteParams })
          }; return t
        }(n.ShaderTechnique); w.EdgeShaderTechnique.shader = new y.ReloadableShaderModule(b.EdgeShaderProgram, () => new Promise((f, t) => a(["../../shaders/sources/edgeRenderer/EdgeShaderProgram.glsl"], f, t))); (function (f) {
          let t = function (v) {
            function m() {
              var e = v.apply(this, arguments) || this; e.slicePlaneEnabled = !1; e.silhouette = !1; e.legacy = !1; e.antialiasing =
                !1; e.mode = 0; e.doublePrecisionRequiresObfuscation = !1; e.multipassTerrainEnabled = !1; e.cullAboveGround = !1; return e
            } c._inheritsLoose(m, v); return m
          }(p.ShaderTechniqueConfiguration); q.__decorate([p.parameter()], t.prototype, "slicePlaneEnabled", void 0); q.__decorate([p.parameter()], t.prototype, "silhouette", void 0); q.__decorate([p.parameter()], t.prototype, "legacy", void 0); q.__decorate([p.parameter()], t.prototype, "antialiasing", void 0); q.__decorate([p.parameter({ count: 3 })], t.prototype, "mode", void 0); q.__decorate([p.parameter()],
            t.prototype, "doublePrecisionRequiresObfuscation", void 0); q.__decorate([p.parameter()], t.prototype, "multipassTerrainEnabled", void 0); q.__decorate([p.parameter()], t.prototype, "cullAboveGround", void 0); f.Configuration = t
        })(w.EdgeShaderTechnique || (w.EdgeShaderTechnique = {})); Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/chunks/EdgeShaderProgram.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl ../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder ../views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardShortEdges.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl ../views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          function v(e) {
            const g = new y.ShaderBuilder, x = g.vertex, k = g.fragment; e.legacy && x.uniforms.add("uModel", "mat4"); e.antialiasing && (x.code.add(u.glsl`#define ANTIALIASING 1`), k.code.add(u.glsl`#define ANTIALIASING 1`)); g.include(n.AdjustProjectedPosition, e); g.include(d.LineAmplitude, e); g.include(b.EdgeUtil, e); g.include(t.UnpackAttributes, e); g.include(f.LineOffset, e); g.include(w.Slice, e); g.include(l.DiscardNonSilhouetteEdges, e); g.include(p.DiscardByCoverage, e); g.include(h.DiscardShortEdges,
              e); g.varyings.add("vColor", "vec4"); g.varyings.add("vRadius", "float"); g.varyings.add("vPosition", "vec3"); g.varyings.add("vWorldPosition", "vec3"); g.varyings.add("vViewPos", "vec3"); g.varyings.add("vLineLengthPixels", "float"); g.varyings.add("vSizeFalloffFactor", "float"); x.uniforms.add("uPixelToNDC", "vec2"); x.uniforms.add("uNDCToPixel", "vec2"); x.uniforms.add("uPixelRatio", "float"); g.attributes.add("position0", "vec3"); g.attributes.add("position1", "vec3"); g.attributes.add("variantOffset", "float"); g.attributes.add("variantStroke",
                "float"); g.attributes.add("variantExtension", "float"); x.code.add(u.glsl`const float opaqueCutoff = 1.0 / 255.0;
void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {
vec2 sideness = unpackedAttributes.sideness;
vec2 sidenessNorm = unpackedAttributes.sidenessNorm;
vWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;
vec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);
vViewPos = viewPos;
vec4 projPosV0 = projFromViewPosition(viewPosV0);
vec4 projPosV1 = projFromViewPosition(viewPosV1);
vec4 projPos = projFromViewPosition(viewPos);
vec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);
vec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * uNDCToPixel;
float lineLengthPixels = length(screenSpaceLinePixels);
float dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;
vec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;
vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;
float falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;
float lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;
float extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;
float lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * uPixelRatio;
vSizeFalloffFactor = falloffFactor;
float lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;
float extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;
#ifdef ANTIALIASING
const float aaPaddingPixels = 1.0;
float halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;
float aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;
#else
float halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;
float aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;
#endif
vec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;
vec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * uPixelToNDC;
vec2 extensionLengthNDC = extensionLengthPixels * uPixelToNDC;
vec2 ndcOffset = (
screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)
+ perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC
);
projPos.xy += ndcOffset * projPos.w;
projPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;
projPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));
float aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;
float pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;
vPosition = vec3(
halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,
pixelPositionAlongLine,
pixelPositionAlongLine / extendedLineLengthPixels
);
vRadius = lineWidthPixels * 0.5;
vLineLengthPixels = extendedLineLengthPixels;
discardShortEdges(unpackedAttributes, lineLengthPixels);
gl_Position = projPos;
}
void main() {
ComponentData component = readComponentData();
UnpackedAttributes unpackedAttributes = unpackAttributes(component);
vec3 worldPosV0 = worldFromModelPosition(position0);
vec3 worldPosV1 = worldFromModelPosition(position1);
vec3 viewPosV0 = viewFromModelPosition(position0);
vec3 viewPosV1 = viewFromModelPosition(position1);
vColor = component.color;
if (vColor.a < opaqueCutoff) {
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return;
}
if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {
return;
}
calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);
calculateStyleOutputs(unpackedAttributes);
}`); e.multipassTerrainEnabled && (g.fragment.include(c.ReadLinearDepth), g.include(q.multipassTerrainTest, e)); g.fragment.code.add(u.glsl`
    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {
      float lineOffset = calculateLineOffset();
      float positionX = position.x - lineOffset;

      if (radius < 1.0) {
        // Handle this specifically for subpixel sizes:
        // 1. Compute correct coverage (note coverage is computed by
        //    0.5 - dist, so we make sure that that will lead to correct
        //    subpixel coverage
        // 2. Ignore rounded caps
        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);
        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);

        float coverage = min(coverageX, coverageY);

        return vec2(0.5 - coverage, 0.0);
      }
      else {
        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius
        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);

        vec2 lineToPosition = vec2(positionX, positionOnCap);
        return vec2(length(lineToPosition) - radius, positionOnCap / radius);
      }
    }

    void main() {
      ${e.multipassTerrainEnabled ? "terrainDepthTest(gl_FragCoord, vViewPos.z);" : ""}
      float radius = vRadius * calculateLinePressure();

      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);
      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);

      discardByCoverage(radius, coverage);
      discardBySlice(vWorldPosition);

      float alpha = vColor.a * coverage;

      gl_FragColor = vec4(vColor.rgb, alpha);

    }
  `); return g
          } const m = Object.freeze({ __proto__: null, build: v }); a.EdgeShaderProgram = m; a.build = v
        })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl": function () {
      define(["exports", "../../../core/shaderLibrary/attributes/VertexPosition.glsl", "../../../core/shaderLibrary/util/IsNaN.glsl", "../../../core/shaderModules/interfaces"], function (a, w, c, q) {
      a.AdjustProjectedPosition = function (u, y) {
        u.vertex.include(c.IsNaN); u.include(w.VertexPosition, y); u = u.vertex; u.uniforms.add("uDepthBias",
          "vec2"); u.uniforms.add("uViewportDimInv", "vec2"); y.legacy ? (u.uniforms.add("uView", "mat4"), u.uniforms.add("uProj", "mat4")) : u.uniforms.add("uTransformNormal_ViewFromGlobal", "mat3"); y.legacy ? u.code.add(q.glsl`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {
float offsetXY = uDepthBias.x;
float offsetZ  = uDepthBias.y;
vec4 projNormal = uProj * uView * vec4(globalNormal, 0.0);
return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;
}`) : u.code.add(q.glsl`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {
float offsetXY = uDepthBias.x;
float offsetZ  = uDepthBias.y;
vec4 projNormal = uTransform_ProjFromView * vec4(uTransformNormal_ViewFromGlobal * globalNormal, 0.0);
return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;
}`); u.code.add(q.glsl`float _calculateProjectedBiasZ(vec4 projPos) {
float offsetZ = uDepthBias.y;
return sqrt(max(projPos.z,0.0)) * offsetZ;
}
vec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {
vec2 offsetXY = calculateProjectedBiasXY(projPos, worldNormal);
if (!isNaN(offsetXY.x) && !isNaN(offsetXY.y)) {
projPos.xy += offsetXY;
}
projPos.z += _calculateProjectedBiasZ(projPos);
return projPos;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/IsNaN.glsl": function () {
      define(["exports", "../../shaderModules/interfaces"], function (a, w) {
      a.IsNaN = function (c) {
        const q = w.glsl`bool isNaN( float val )
{
return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
}`; c.code.add(q)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl": function () {
      define(["exports", "../../../core/shaderModules/interfaces"], function (a, w) {
      a.DiscardByCoverage = function (c, q) { c = c.fragment; c.constants.add("coverageTestThreshold", "float", .01); q.antialiasing ? c.code.add(w.glsl`#define discardByCoverage(radius, coverage) { if (coverage < coverageTestThreshold) discard; }`) : c.code.add(w.glsl`#define discardByCoverage(radius, coverage) { float coverageLimit = radius <= 0.5 ? coverageTestThreshold : 0.75; if (coverage < coverageLimit) discard; }`) };
        Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl": function () {
      define(["exports", "../../../core/shaderModules/interfaces"], function (a, w) {
      a.DiscardNonSilhouetteEdges = function (c, q) {
        c = c.vertex; q.silhouette ? (c.code.add(w.glsl`bool isSilhouetteEdge(vec3 viewDir, vec3 normalA, vec3 normalB) {
float faceAVisible = dot(viewDir, normalA);
float faceBVisible = dot(viewDir, normalB);
return faceAVisible * faceBVisible < 0.0;
}`), q.legacy ? c.code.add(w.glsl`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
vec3 viewNormalA = _modelToViewNormal(normalA);
vec3 viewNormalB = _modelToViewNormal(normalB);
vec3 viewDir = -viewPos;
if (isSilhouetteEdge(viewDir, viewNormalA, viewNormalB)) {
return false;
}
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return true;
}`) : c.code.add(w.glsl`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
vec3 worldNormalA = _modelToWorldNormal(normalA);
vec3 worldNormalB = _modelToWorldNormal(normalB);
vec3 viewDir = -worldPos;
if (isSilhouetteEdge(viewDir, worldNormalA, worldNormalB)) {
return false;
}
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return true;
}`)) : c.code.add(w.glsl`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
return false;
}`)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardShortEdges.glsl": function () {
      define(["exports", "../../../core/shaderModules/interfaces"], function (a, w) {
      a.DiscardShortEdges = function (c, q) {
        c = c.vertex; switch (q.mode) {
          case 1: c.code.add(w.glsl`#define discardShortEdges(unpackedAttributes, lineLengthPixels) { if (lineLengthPixels <= 3.0) { gl_Position = vec4(10.0, 10.0, 10.0, 1.0); return; }}`); break; case 2: c.code.add(w.glsl`#define discardShortEdges(unpackedAttributes, lineLengthPixels) { if (unpackedAttributes.type <= 0.0 && lineLengthPixels <= 3.0) { gl_Position = vec4(10.0, 10.0, 10.0, 1.0); return; }}`);
            break; case 0: c.code.add(w.glsl`#define discardShortEdges(unpackedAttributes, lineLengthPixels) {}`)
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl": function () {
      define(["exports", "../../../core/shaderLibrary/util/DoublePrecision.glsl", "../../../core/shaderModules/interfaces"], function (a, w, c) {
        function q(u, y) {
          const n = u.vertex; n.uniforms.add("uDistanceFalloffFactor", "float"); n.code.add(c.glsl`float distanceBasedPerspectiveFactor(float distance) {
return clamp(sqrt(uDistanceFalloffFactor / distance), 0.0, 1.0);
}`); n.uniforms.add("uComponentDataTex", "sampler2D"); n.uniforms.add("uComponentDataTexInvDim", "vec2"); u.attributes.add("componentIndex", "float"); n.constants.add("componentColorFieldOffset", "float", 0); n.constants.add("componentOtherFieldOffset", "float", 1); n.constants.add("componentFieldCount", "float", 2); n.constants.add("lineWidthFractionFactor", "float", 8); n.constants.add("extensionLengthOffset", "float", 128); n.constants.add("componentTexWidth", "float", 4096); n.code.add(c.glsl`vec2 _componentTextureCoords(float componentIndex, float fieldOffset) {
float fieldIndex = componentFieldCount * componentIndex + fieldOffset;
float rowIndex = floor(fieldIndex / componentTexWidth);
float colIndex = mod(fieldIndex, componentTexWidth);
vec2 linearIndex = vec2(
(colIndex + 0.5) / componentTexWidth,
(rowIndex + 0.5) * uComponentDataTexInvDim.y
);
return linearIndex;
}
struct ComponentData {
vec4 color;
float lineWidth;
float extensionLength;
float type;
};
ComponentData readComponentData() {
vec2 colorIndex = _componentTextureCoords(componentIndex, componentColorFieldOffset);
vec2 otherIndex = _componentTextureCoords(componentIndex, componentOtherFieldOffset);
vec4 colorValue = texture2D(uComponentDataTex, colorIndex);
vec4 otherValue = texture2D(uComponentDataTex, otherIndex);
return ComponentData(
vec4(colorValue.rgb, colorValue.a * otherValue.w),
otherValue.x * (255.0 / lineWidthFractionFactor),
otherValue.y * 255.0 - extensionLengthOffset,
-(otherValue.z * 255.0) + 0.5
);
}`); y.legacy ? n.code.add(c.glsl`vec3 _modelToWorldNormal(vec3 normal) {
return (uModel * vec4(normal, 0.0)).xyz;
}
vec3 _modelToViewNormal(vec3 normal) {
return (uView * uModel * vec4(normal, 0.0)).xyz;
}`) : (n.uniforms.add("uTransformNormal_GlobalFromModel ", "mat3"), n.code.add(c.glsl`vec3 _modelToWorldNormal(vec3 normal) {
return uTransformNormal_GlobalFromModel * normal;
}`)); y.silhouette ? (u.attributes.add("normalA", "vec3"), u.attributes.add("normalB", "vec3"), n.code.add(c.glsl`vec3 worldNormal() {
return _modelToWorldNormal(normalize(normalA + normalB));
}`)) : (u.attributes.add("normal", "vec3"), n.code.add(c.glsl`vec3 worldNormal() {
return _modelToWorldNormal(normal);
}`)); y.legacy ? n.code.add(c.glsl`vec3 worldFromModelPosition(vec3 position) {
return (uModel * vec4(position, 1.0)).xyz;
}
vec3 viewFromModelPosition(vec3 position) {
return (uView * vec4(worldFromModelPosition(position), 1.0)).xyz;
}
vec4 projFromViewPosition(vec3 position) {
return uProj * vec4(position, 1.0);
}`) : (u.vertex.include(w.DoublePrecision, y), n.code.add(c.glsl`vec3 worldFromModelPosition(vec3 position) {
vec3 rotatedModelPosition = uTransform_WorldFromModel_RS * position;
vec3 transform_CameraRelativeFromModel = dpAdd(
uTransform_WorldFromModel_TL,
uTransform_WorldFromModel_TH,
-uTransform_WorldFromView_TL,
-uTransform_WorldFromView_TH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}
vec3 viewFromModelPosition(vec3 position) {
return uTransform_ViewFromCameraRelative_RS * worldFromModelPosition(position);
}
vec4 projFromViewPosition(vec3 position) {
return uTransform_ProjFromView * vec4(position, 1.0);
}`)); n.code.add(c.glsl`float calculateExtensionLength(float extensionLength, float lineLength) {
return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);
}`)
        } (function (u) { u.usesSketchLogic = function (y) { return 1 === y.mode || 2 === y.mode }; u.usesSolidLogic = function (y) { return 0 === y.mode || 2 === y.mode } })(q || (q = {})); a.EdgeUtil = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl": function () {
      define(["exports", "../../../core/shaderModules/interfaces", "./EdgeUtil.glsl", "./UnpackAttributes.glsl"], function (a, w, c, q) {
      a.LineAmplitude = function (u, y) {
        const n = u.vertex; u.include(q.UnpackAttributes,
          y); c.EdgeUtil.usesSketchLogic(y) && n.uniforms.add("uStrokesAmplitude", "float"); switch (y.mode) {
            case 0: n.code.add(w.glsl`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
return 0.0;
}`); break; case 1: n.code.add(w.glsl`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
return uStrokesAmplitude;
}`); break; case 2: n.code.add(w.glsl`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
float type = unpackedAttributes.type;
if (type <= 0.0) {
return uStrokesAmplitude;
}
else {
return 0.0;
}
}`)
          }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl": function () {
      define(["exports", "../../../core/shaderModules/interfaces", "./EdgeUtil.glsl"], function (a, w, c) {
      a.UnpackAttributes = function (q, u) {
        const y = q.vertex; q.include(c.EdgeUtil, u); q.attributes.add("sideness", "vec2"); 2 === u.mode ? y.code.add(w.glsl`struct UnpackedAttributes {
vec2 sideness;
vec2 sidenessNorm;
float lineWidthPixels;
float extensionLengthPixels;
float type;
};`) : y.code.add(w.glsl`struct UnpackedAttributes {
vec2 sideness;
vec2 sidenessNorm;
float lineWidthPixels;
float extensionLengthPixels;
};`); switch (u.mode) {
          case 2: y.code.add(w.glsl`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float fType = component.type;
float extensionLengthPixels = component.extensionLength;
float lineWidth = component.lineWidth;
if (fType <= 0.0) {
extensionLengthPixels *= variantExtension * 2.0 - 1.0;
}
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);
}`); break; case 1: y.code.add(w.glsl`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float extensionLengthPixels = component.extensionLength;
extensionLengthPixels *= variantExtension * 2.0 - 1.0;
float lineWidth = component.lineWidth;
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);
}`); break; case 0: y.code.add(w.glsl`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float extensionLengthPixels = component.extensionLength;
float lineWidth = component.lineWidth;
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);
}`)
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl": function () {
      define(["exports", "../../../core/shaderLibrary/util/RgbaFloatEncoding.glsl", "../../../core/shaderModules/interfaces", "./EdgeUtil.glsl", "./UnpackAttributes.glsl"], function (a, w, c, q, u) {
      a.LineOffset = function (y, n) {
        const p = y.vertex; y.include(u.UnpackAttributes, n); const l = y.fragment; q.EdgeUtil.usesSketchLogic(n) && (p.uniforms.add("uStrokesTextureScale", "vec2"), p.uniforms.add("uStrokesLog2Resolution",
          "float"), p.uniforms.add("uStrokeVariants", "float"), y.varyings.add("vStrokeUV", "vec2"), l.uniforms.add("uStrokesTexture", "sampler2D"), l.uniforms.add("uStrokesNormalizationScale", "float"), p.code.add(c.glsl`void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {
vec2 sidenessNorm = unpackedAttributes.sidenessNorm;
float lineIndex = clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);
vStrokeUV = vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + variantStroke + 0.5) * uStrokesTextureScale;
vStrokeUV.x += variantOffset;
}`), y.fragment.include(w.RgbaFloatEncoding), l.code.add(c.glsl`float calculateLineOffsetSketch() {
float offsetNorm = rgba2float(texture2D(uStrokesTexture, vStrokeUV));
return (offsetNorm - 0.5) * uStrokesNormalizationScale;
}
float calculateLinePressureSketch() {
return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0.0, 0.5)));
}`)); switch (n.mode) {
          case 0: p.code.add(c.glsl`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes) {}`); l.code.add(c.glsl`float calculateLineOffset() {
return 0.0;
}
float calculateLinePressure() {
return 1.0;
}`); break; case 1: p.code.add(c.glsl`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes)
{
calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);
}`); l.code.add(c.glsl`float calculateLineOffset() {
return calculateLineOffsetSketch();
}
float calculateLinePressure() {
return calculateLinePressureSketch();
}`); break; case 2: y.varyings.add("vType", "float"), p.code.add(c.glsl`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes)
{
vType = unpackedAttributes.type;
if (unpackedAttributes.type <= 0.0) {
calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);
}
}`), l.code.add(c.glsl`float calculateLineOffset() {
if (vType <= 0.0) {
return calculateLineOffsetSketch();
}
else {
return 0.0;
}
}
float calculateLinePressure() {
if (vType <= 0.0) {
return calculateLinePressureSketch();
}
else {
return 1.0;
}
}`)
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/EdgeWorkerHandle": function () {
      define(["../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../core/typedArrayUtil", "../../../../../core/workers/WorkerHandle", "../../../support/buffer/workerHelper", "./EdgeProcessingWorker"], function (a, w, c, q, u) {
        return function (y) {
          function n(l) { return y.call(this, "EdgeProcessingWorker", "wrappedWork", l) || this } a._inheritsLoose(n, y); var p = n.prototype; p.process =
            function () { var l = a._asyncToGenerator(function* (h, b, d) { if (d) return u.work(h); h = this._packInput(h); b = yield this.invoke(h, b); return this._unpackOutput(b) }); return function (h, b, d) { return l.apply(this, arguments) } }(); p.getTransferList = function (l) { return [l.dataBuffer] }; p._packInput = function (l) { return { dataBuffer: l.data.buffer, writerSettings: l.writerSettings, skipDeduplicate: l.skipDeduplicate, indicesBuffer: l.indices.buffer, indicesType: w.isUint32Array(l.indices) ? "Uint32Array" : "Uint16Array", indicesLength: l.indicesLength } };
          p._unpackOutput = function (l) { return { regular: { instancesData: q.unpackInterleavedBuffer(l.regular.instancesData), lodInfo: { lengths: new Float32Array(l.regular.lodInfo.lengths) } }, silhouette: { instancesData: q.unpackInterleavedBuffer(l.silhouette.instancesData), lodInfo: { lengths: new Float32Array(l.silhouette.lodInfo.lengths) } }, averageEdgeLength: l.averageEdgeLength } }; return n
        }(c.WorkerHandle)
      })
    }, "esri/views/3d/support/buffer/workerHelper": function () {
      define(["exports", "../../../../geometry/support/buffer/BufferView",
        "./InterleavedLayout"], function (a, w, c) {
          function q(n) { const p = []; n.fields.forEach((l, h) => { var b = l.constructor; p.push([h, { ...l, constructor: `${b.ElementType}_${b.ElementCount}` }]) }); return { stride: n.stride, fields: p, fieldNames: n.fieldNames } } function u(n) { const p = c.newLayout(); p.stride = n.stride; p.fieldNames = n.fieldNames; n.fields.forEach(l => p.fields.set(l[0], { ...l[1], constructor: y.get(l[1].constructor) })); return p } w = [w.BufferViewFloat, w.BufferViewVec2f, w.BufferViewVec3f, w.BufferViewVec4f, w.BufferViewMat3f,
          w.BufferViewMat4f, w.BufferViewFloat64, w.BufferViewVec2f64, w.BufferViewVec3f64, w.BufferViewVec4f64, w.BufferViewMat3f64, w.BufferViewMat4f64, w.BufferViewUint8, w.BufferViewVec2u8, w.BufferViewVec3u8, w.BufferViewVec4u8, w.BufferViewUint16, w.BufferViewVec2u16, w.BufferViewVec3u16, w.BufferViewVec4u16, w.BufferViewUint32, w.BufferViewVec2u32, w.BufferViewVec3u32, w.BufferViewVec4u32, w.BufferViewInt8, w.BufferViewVec2i8, w.BufferViewVec3i8, w.BufferViewVec4i8, w.BufferViewInt16, w.BufferViewVec2i16, w.BufferViewVec3i16,
          w.BufferViewVec4i16, w.BufferViewInt32, w.BufferViewVec2i32, w.BufferViewVec3i32, w.BufferViewVec4i32]; const y = new Map; w.forEach(n => y.set(`${n.ElementType}_${n.ElementCount}`, n)); a.packInterleavedBuffer = function (n, p) { p.push(n.buffer); return { buffer: n.buffer, layout: q(n.layout) } }; a.packLayout = q; a.unpackInterleavedBuffer = function (n) { return u(n.layout).createView(n.buffer) }; a.unpackLayout = u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/EdgeProcessingWorker": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../geometry/support/meshUtils/deduplicate ../../../support/meshProcessing ../../../support/buffer/workerHelper ./bufferLayouts ./edgeBufferWriters ./edgePreprocessing".split(" "),
        function (a, w, c, q, u, y, n, p) {
          function l() {
            l = w._asyncToGenerator(function* (f) {
              var t = { data: y.EdgeInputBufferLayout.createView(f.dataBuffer), indices: "Uint32Array" === f.indicesType ? new Uint32Array(f.indicesBuffer) : "Uint16Array" === f.indicesType ? new Uint16Array(f.indicesBuffer) : void 0, indicesLength: f.indicesLength, writerSettings: f.writerSettings, skipDeduplicate: f.skipDeduplicate }; f = h(t); t = [t.data.buffer]; t.push(f.regular.lodInfo.lengths.buffer); t.push(f.silhouette.lodInfo.lengths.buffer); return {
                result: {
                  regular: {
                    instancesData: u.packInterleavedBuffer(f.regular.instancesData,
                      t), lodInfo: { lengths: f.regular.lodInfo.lengths.buffer }
                  }, silhouette: { instancesData: u.packInterleavedBuffer(f.silhouette.instancesData, t), lodInfo: { lengths: f.silhouette.lodInfo.lengths.buffer } }, averageEdgeLength: f.averageEdgeLength
                }, transferList: t
              }
            }); return l.apply(this, arguments)
          } function h(f) {
            var t = f.data, v = f.indices; var m = f.indicesLength; if (f.skipDeduplicate) { const e = q.computeNeighbors(v, m, t.count); m = { faces: v, facesLength: m, neighbors: e, vertices: t } } else t = c.deduplicate(t.buffer, t.stride / 4, {
              originalIndices: v,
              originalIndicesLength: m
            }), m = q.computeNeighbors(t.indices, m, t.uniqueCount), m = { faces: t.indices, facesLength: t.indices.length, neighbors: m, vertices: y.EdgeInputBufferLayout.createView(t.buffer) }; b.updateSettings(f.writerSettings); d.updateSettings(f.writerSettings); return p.extractEdges(m, b, d)
          } const b = new n.RegularEdgeBufferWriter, d = new n.SilhouetteEdgeBufferWriter; a.work = h; a.wrappedWork = function (f) { return l.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/meshProcessing": function () {
      define(["exports"],
        function (a) {
        a.computeNeighbors = function (w, c, q) {
          c /= 3; const u = new Uint32Array(q + 1), y = new Uint32Array(q + 1); var n = (m, e) => { m < e ? u[m + 1]++ : y[e + 1]++ }; for (var p = 0; p < c; p++) { var l = w[3 * p], h = w[3 * p + 1], b = w[3 * p + 2]; n(l, h); n(h, b); n(b, l) } p = n = 0; for (l = 0; l < q; l++)h = u[l + 1], b = y[l + 1], u[l + 1] = n, y[l + 1] = p, n += h, p += b; const d = new Uint32Array(6 * c), f = u[q]; n = (m, e, g) => { m < e ? (m = u[m + 1]++ , d[2 * m] = e, d[2 * m + 1] = g) : (e = y[e + 1]++ , d[2 * f + 2 * e] = m, d[2 * f + 2 * e + 1] = g) }; for (p = 0; p < c; p++)l = w[3 * p], h = w[3 * p + 1], b = w[3 * p + 2], n(l, h, p), n(h, b, p), n(b, l, p); n = (m, e) => {
            const g =
              2 * m; m = e - m; for (e = 1; e < m; e++) { const x = d[g + 2 * e], k = d[g + 2 * e + 1]; let r = e - 1; for (r; 0 <= r && d[g + 2 * r] > x; r--)d[g + 2 * r + 2] = d[g + 2 * r], d[g + 2 * r + 3] = d[g + 2 * r + 1]; d[g + 2 * r + 2] = x; d[g + 2 * r + 3] = k }
          }; for (p = 0; p < q; p++)n(u[p], u[p + 1]), n(f + y[p], f + y[p + 1]); const t = new Int32Array(3 * c), v = (m, e) => m === w[3 * e] ? 0 : m === w[3 * e + 1] ? 1 : m === w[3 * e + 2] ? 2 : -1; c = (m, e) => { m = v(m, e); t[3 * e + m] = -1 }; n = (m, e, g, x) => { m = v(m, e); t[3 * e + m] = x; g = v(g, x); t[3 * x + g] = e }; for (p = 0; p < q; p++) {
            l = u[p]; h = u[p + 1]; b = y[p]; const m = y[p + 1]; for (; l < h && b < m;) {
              const e = d[2 * l], g = d[2 * f + 2 * b]; e === g ? (n(p, d[2 * l + 1],
                g, d[2 * f + 2 * b + 1]), l++ , b++) : e < g ? (c(p, d[2 * l + 1]), l++) : (c(g, d[2 * f + 2 * b + 1]), b++)
            } for (; l < h;)c(p, d[2 * l + 1]), l++; for (; b < m;)c(d[2 * f + 2 * b], d[2 * f + 2 * b + 1]), b++
          } return t
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing": function () {
      define("exports ../../../../../core/arrayUtils ../../../../../core/mathUtils ../../../../../core/typedArrayUtil ../../../../../chunks/vec3 ../../../../../chunks/vec3f64".split(" "), function (a, w, c, q, u, y) {
        function n(f, t) {
          const v =
            c.acosClamped(f.cosAngle), m = h.fwd, e = h.ortho; u.direction(m, f.position1, f.position0); f = 0 < u.dot(u.cross(e, f.faceNormal0, f.faceNormal1), m) ? -1 : 1; return v * f > t
        } function p(f) {
          const t = f.faces.length / 3, v = f.faces; f = f.neighbors; var m = 0; for (var e = 0; e < t; e++) { var g = f[3 * e + 1], x = f[3 * e + 2], k = v[3 * e], r = v[3 * e + 1], A = v[3 * e + 2]; m += -1 === f[3 * e] || k < r ? 1 : 0; m += -1 === g || r < A ? 1 : 0; m += -1 === x || A < k ? 1 : 0 } m = new Int32Array(4 * m); e = 0; for (g = 0; g < t; g++) {
            x = f[3 * g]; k = f[3 * g + 1]; r = f[3 * g + 2]; A = v[3 * g]; const z = v[3 * g + 1], B = v[3 * g + 2]; if (-1 === x || A < z) m[e++] = A, m[e++] =
              z, m[e++] = g, m[e++] = x; if (-1 === k || z < B) m[e++] = z, m[e++] = B, m[e++] = g, m[e++] = k; if (-1 === r || B < A) m[e++] = B, m[e++] = A, m[e++] = g, m[e++] = r
          } return m
        } function l(f) { const t = f.faces.length / 3, v = f.vertices.position; f = f.faces; const m = b.v0, e = b.v1, g = b.v2, x = new Float32Array(3 * t); for (let k = 0; k < t; k++) { const r = f[3 * k + 1], A = f[3 * k + 2]; v.getVec(f[3 * k], m); v.getVec(r, e); v.getVec(A, g); u.subtract(e, e, m); u.subtract(g, g, m); u.cross(m, e, g); u.normalize(m, m); x[3 * k] = m[0]; x[3 * k + 1] = m[1]; x[3 * k + 2] = m[2] } return x } const h = {
          edge: {
            position0: y.create(),
            position1: y.create(), faceNormal0: y.create(), faceNormal1: y.create(), componentIndex: 0, cosAngle: 0
          }, ortho: y.create(), fwd: y.create()
        }, b = { v0: y.create(), v1: y.create(), v2: y.create() }, d = { anglePlanar: 4, angleSignificantEdge: 35 }; a.extractEdges = function (f, t, v, m = d) {
          const e = f.vertices.position; var g = f.vertices.componentIndex, x = c.deg2rad(m.anglePlanar); m = c.deg2rad(m.angleSignificantEdge); const k = Math.cos(m), r = Math.cos(x), A = h.edge, z = A.position0, B = A.position1, C = A.faceNormal0, D = A.faceNormal1, E = l(f), H = p(f), J = H.length /
            4; f = t.allocate(J); m = 0; const M = v.allocate(J); let F = 0, K = 0, P = 0; const L = w.range(0, J), N = new Float32Array(J); q.forEach(N, (R, S, Q) => { e.getVec(H[4 * S], z); e.getVec(H[4 * S + 1], B); Q[S] = u.distance(z, B) }); L.sort((R, S) => N[S] - N[R]); const G = [], I = []; for (let R = 0; R < J; R++) {
              var O = L[R]; const S = N[O], Q = H[4 * O], T = H[4 * O + 1], da = H[4 * O + 2]; O = H[4 * O + 3]; const Y = -1 === O; e.getVec(Q, z); e.getVec(T, B); if (Y) u.set(C, E[3 * da], E[3 * da + 1], E[3 * da + 2]), u.copy(D, C), A.componentIndex = g.get(Q), A.cosAngle = u.dot(C, D); else {
                u.set(C, E[3 * da], E[3 * da + 1], E[3 * da + 2]);
                u.set(D, E[3 * O], E[3 * O + 1], E[3 * O + 2]); A.componentIndex = g.get(Q); A.cosAngle = u.dot(C, D); if (A.cosAngle > r) continue; -.9999 > A.cosAngle && u.copy(D, C)
              } K += S; P++; Y || A.cosAngle < k ? (t.write(f, m++, A), G.push(S)) : n(A, x) && (v.write(M, F++, A), I.push(S))
            } g = new Float32Array(G.reverse()); x = new Float32Array(I.reverse()); return { regular: { instancesData: t.trim(f, m), lodInfo: { lengths: g } }, silhouette: { instancesData: v.trim(M, F), lodInfo: { lengths: x } }, averageEdgeLength: K / P }
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/strokes": function () {
      define(["exports",
        "../../../../../core/floatRGBA", "../../../../../core/mathUtils", "../../../../../core/maybe", "../../../../webgl/Texture"], function (a, w, c, q, u) {
          function y(l, h) { if (!l) return null; var b = l.length / 2; const d = .1 * b; b = Array(b); let f = 0; h = 1 === h; for (let t = 0; t < l.length; t += 2) { const v = (l[t] + l[t + 1]) / 2; h ? b[f++] = Math.min(d, 1 - .5 * (1 - v)) : b[f++] = Math.min(d, .5 * v) } return b } let n = function () {
            function l(h, b, d, f, t) { this.resolution = h; this.normalizationScale = b; this.amplitude = d; this.variants = f; this.texture = t } l.prototype.dispose =
              function () { this.texture = q.disposeMaybe(this.texture) }; return l
          }(); const p = {
            amplitude: 8, resolution: 256, strokes: [{
              distance: [-1.59027, -1.59426, -1.59674, -1.59766, -1.59702, -1.59479, -1.59095, -1.5855, -1.57843, -1.56973, -1.55942, -1.5475, -1.53398, -1.5189, -1.50226, -1.4841, -1.46446, -1.44337, -1.42088, -1.39703, -1.37188, -1.34547, -1.31786, -1.28912, -1.2593, -1.22847, -1.19668, -1.16402, -1.13053, -1.09629, -1.06137, -1.02582, -.98972, -.95313, -.91611, -.87872, -.84102, -.80306, -.76488, -.72654, -.68807, -.64952, -.61092, -.57232,
              -.53375, -.49527, -.45692, -.41874, -.38078, -.34309, -.3057, -.26867, -.23204, -.19585, -.16015, -.12497, -.09036, -.05634, -.02296, .00977, .04183, .07321, .10389, .13386, .16313, .19169, .21956, .24672, .27321, .299, .32413, .34858, .37237, .3955, .41798, .43981, .461, .48154, .50145, .52073, .53939, .55744, .57488, .5917, .6079, .62347, .63837, .65259, .66609, .67885, .69083, .70201, .71235, .72183, .73042, .73812, .7449, .75076, .7557, .75973, .76284, .76507, .76642, .76692, .76659, .76545, .76352, .76083, .7574, .75324, .74837, .74279, .73652, .72959, .72199,
                .71377, .70493, .69553, .68558, .67515, .66426, .65298, .64135, .62944, .6173, .60499, .59257, .58008, .56759, .55513, .54275, .5305, .51842, .50654, .4949, .48353, .47246, .4617, .45128, .44121, .43149, .42213, .41313, .40448, .39617, .38818, .3805, .37309, .36594, .35902, .35229, .34572, .33927, .33292, .32663, .32035, .31407, .30774, .30135, .29486, .28824, .28148, .27454, .26739, .26002, .25241, .24454, .23639, .22796, .21922, .21016, .20076, .19098, .18082, .17023, .1592, .14768, .13566, .1231, .10996, .09624, .08188, .06688, .05121, .03485, .01778, 0, -.0185, -.03771,
              -.05763, -.07824, -.09952, -.12144, -.14396, -.16706, -.19069, -.21481, -.23938, -.26436, -.28971, -.31539, -.34136, -.36759, -.39404, -.42067, -.44746, -.47437, -.50136, -.52839, -.55544, -.58248, -.60948, -.63642, -.66329, -.6901, -.71684, -.74352, -.77015, -.79675, -.82332, -.84988, -.87644, -.90301, -.92958, -.95615, -.98272, -1.00926, -1.03575, -1.06217, -1.08847, -1.11463, -1.1406, -1.16633, -1.19178, -1.2169, -1.24164, -1.26595, -1.28979, -1.31312, -1.3359, -1.35809, -1.37963, -1.4005, -1.42064, -1.44, -1.45853, -1.47616, -1.49285, -1.50853, -1.52313,
              -1.53659, -1.54886, -1.55986, -1.56955, -1.57788, -1.5848], pressure: [-.01365, -.00206, .01025, .02327, .03696, .05129, .06619, .08163, .09755, .11393, .1307, .14784, .16531, .18308, .20111, .21938, .23786, .25651, .2753, .29419, .31315, .33215, .35115, .37015, .38913, .40806, .42694, .44576, .46449, .48313, .50167, .5201, .53839, .55653, .57448, .59222, .60971, .62692, .6438, .66033, .67648, .69221, .70753, .72242, .73688, .75093, .76456, .77779, .79063, .80309, .81517, .82686, .83817, .84911, .85967, .86987, .87972, .88924, .89845, .90734, .91594, .92425, .93229,
                .94005, .94754, .95475, .96166, .96826, .97451, .9804, .98588, .99092, .99549, .99957, .99685, .99381, .99131, .98936, .98796, .98711, .98681, .98706, .98787, .98923, .99113, .99357, .99654, 1, .99607, .99171, .98695, .98181, .97634, .97057, .96452, .95824, .95175, .94506, .93818, .93113, .92389, .91647, .90887, .90109, .89314, .88501, .87672, .86831, .85978, .85119, .84256, .83393, .82533, .8168, .80836, .80002, .79181, .78374, .77582, .7681, .76059, .75331, .74629, .73955, .73311, .72697, .72116, .71568, .71054, .70572, .70121, .697, .69304, .68931, .68576, .68236,
                .67905, .67582, .67262, .66941, .66619, .66291, .65957, .65613, .65259, .64892, .6451, .6411, .6369, .63248, .62783, .62295, .61783, .61247, .60688, .60104, .59498, .58868, .58216, .57542, .56845, .56125, .5538, .5461, .53813, .52986, .52129, .51239, .50316, .49359, .4837, .47349, .46299, .45223, .44124, .43005, .41869, .40719, .39557, .38386, .37207, .36023, .34836, .33648, .32464, .31287, .30119, .28963, .27822, .26698, .25594, .2451, .23448, .22409, .21391, .20394, .19415, .18452, .17503, .16565, .15636, .14713, .13794, .1288, .11968, .11058, .10151, .09247, .08346,
                .07447, .06552, .05659, .0477, .03885, .03007, .02137, .01278, .00433, -.00393, -.012, -.01983, -.02738, -.03463, -.04155, -.0481, -.05429, -.0601, -.06553, -.07057, -.07524, -.07954, -.08347, -.08703, -.09022, -.09303, -.09544, -.09744, -.09898, -.10004, -.10059, -.1006, -.10005, -.09892, -.0972, -.09487, -.09192, -.08833, -.08409, -.07918, -.07357, -.06724, -.06019, -.0524, -.04386, -.03455, -.02448]
            }, {
              distance: [-3.46259, -3.47131, -3.47668, -3.47863, -3.47712, -3.4721, -3.46352, -3.45138, -3.43566, -3.41635, -3.39347, -3.36704, -3.33709, -3.30368, -3.26684,
              -3.22667, -3.18322, -3.1366, -3.08689, -3.0342, -2.97865, -2.92036, -2.85946, -2.79607, -2.73034, -2.66241, -2.59242, -2.52052, -2.44686, -2.37159, -2.29485, -2.2168, -2.13757, -2.05731, -1.97616, -1.89426, -1.81174, -1.72875, -1.64543, -1.56191, -1.47833, -1.39483, -1.3115, -1.22847, -1.14581, -1.06361, -.98193, -.90083, -.82036, -.74054, -.66141, -.583, -.50532, -.4284, -.35228, -.277, -.20261, -.12916, -.05672, .01463, .08485, .15384, .22153, .28784, .35269, .41602, .47776, .53787, .59629, .653, .70799, .76123, .81274, .86253, .9106, .95698, 1.0017, 1.04477,
                1.0862, 1.126, 1.16415, 1.20065, 1.23546, 1.26857, 1.29994, 1.32953, 1.35731, 1.38321, 1.40719, 1.42921, 1.44922, 1.46719, 1.48309, 1.49691, 1.50862, 1.51825, 1.52581, 1.53133, 1.53486, 1.53644, 1.53616, 1.53409, 1.53031, 1.52493, 1.51803, 1.50972, 1.50009, 1.48924, 1.47725, 1.46421, 1.45019, 1.43527, 1.4195, 1.40295, 1.38568, 1.36778, 1.34929, 1.3303, 1.31087, 1.29108, 1.27099, 1.25066, 1.23018, 1.2096, 1.18898, 1.16838, 1.14785, 1.12745, 1.10721, 1.08719, 1.06741, 1.04791, 1.02871, 1.00986, .99136, .97324, .95551, .93819, .92127, .90476, .88866, .87296, .85767,
                .84277, .82823, .81406, .80022, .7867, .77346, .76049, .74774, .73519, .72278, .71049, .69827, .68606, .67381, .66145, .64893, .63618, .62313, .60973, .5959, .5816, .56675, .5513, .53516, .51826, .50053, .4819, .46231, .44169, .42002, .39725, .37336, .34834, .32219, .2949, .2665, .23698, .20638, .17469, .14193, .10809, .07316, .03714, 0, -.03827, -.07772, -.11836, -.16022, -.20332, -.24768, -.29332, -.34024, -.38844, -.43788, -.48854, -.54036, -.59329, -.64724, -.70211, -.75782, -.81425, -.87128, -.92881, -.98674, -1.04498, -1.10346, -1.1621, -1.22086, -1.27969, -1.33854,
              -1.3974, -1.45625, -1.51511, -1.57396, -1.63283, -1.69173, -1.75067, -1.80968, -1.86875, -1.9279, -1.98712, -2.04639, -2.10568, -2.16495, -2.22416, -2.28322, -2.34208, -2.40063, -2.4588, -2.51647, -2.57354, -2.62989, -2.68543, -2.74002, -2.79357, -2.84597, -2.89711, -2.94689, -2.99521, -3.04195, -3.087, -3.13023, -3.17152, -3.21075, -3.24779, -3.28252, -3.3148, -3.34451, -3.37154, -3.39577, -3.41709, -3.43539, -3.45059], pressure: [.87183, .87151, .87129, .87118, .87117, .87128, .87149, .87182, .87225, .8728, .87347, .87424, .87513, .87613, .87723, .87845,
                .87978, .88122, .88276, .88441, .88616, .88801, .88996, .892, .89414, .89637, .89868, .90108, .90356, .90611, .90874, .91144, .91421, .91704, .91993, .92287, .92587, .92892, .93201, .93514, .93831, .94151, .94474, .94799, .95126, .95456, .95786, .96118, .9645, .96783, .97116, .97448, .9778, .98111, .98441, .9877, .99096, .99421, .99742, .99938, .99622, .9931, .99001, .98697, .98397, .98101, .97811, .97526, .97246, .96972, .96703, .96441, .96185, .95935, .95691, .95455, .95225, .95002, .94786, .94577, .94376, .94182, .93995, .93817, .93646, .93483, .93328, .93181, .93042,
                .92911, .92788, .92673, .92566, .92467, .92376, .92293, .92217, .92149, .92088, .92034, .91987, .91947, .91913, .91886, .91864, .91849, .91838, .91833, .91834, .91839, .91849, .91863, .91883, .91907, .91935, .91968, .92005, .92046, .92092, .92142, .92195, .92253, .92314, .9238, .92449, .92521, .92598, .92677, .9276, .92847, .92936, .93029, .93125, .93224, .93325, .9343, .93537, .93646, .93758, .93872, .93988, .94106, .94225, .94346, .94469, .94593, .94718, .94844, .94971, .95098, .95226, .95354, .95482, .9561, .95738, .95867, .95995, .96122, .9625, .96377, .96504, .9663,
                .96757, .96883, .97009, .97135, .97261, .97387, .97513, .9764, .97767, .97895, .98023, .98153, .98284, .98416, .98549, .98684, .98821, .9896, .99101, .99244, .99389, .99537, .99688, .99842, 1, .99839, .99675, .99508, .99336, .99161, .98982, .98799, .98613, .98422, .98228, .98029, .97827, .97622, .97414, .97202, .96987, .9677, .96551, .9633, .96107, .95882, .95656, .9543, .95202, .94975, .94747, .94519, .94292, .94065, .93838, .93613, .93388, .93164, .92941, .9272, .92499, .9228, .92062, .91846, .91631, .91418, .91207, .90998, .90792, .90588, .90387, .90189, .89995, .89804,
                .89617, .89434, .89256, .89083, .88914, .88752, .88595, .88443, .88299, .88161, .8803, .87907, .87791, .87683, .87584, .87494, .87412, .8734, .87278, .87225]
            }, {
              distance: [.39335, .43437, .47737, .52234, .56923, .61801, .66864, .72109, .7753, .83123, .88882, .94801, 1.00875, 1.07097, 1.13461, 1.1996, 1.26586, 1.33333, 1.40193, 1.47158, 1.54221, 1.61373, 1.68607, 1.75913, 1.83284, 1.90711, 1.98186, 2.05699, 2.13243, 2.20809, 2.28387, 2.35971, 2.4355, 2.51117, 2.58663, 2.66179, 2.73658, 2.81092, 2.88473, 2.95792, 3.03043, 3.10217, 3.17308, 3.24309, 3.31211, 3.3801,
                3.44697, 3.51267, 3.57712, 3.64028, 3.70208, 3.76247, 3.8214, 3.87881, 3.93467, 3.98892, 4.04152, 4.09244, 4.14164, 4.18908, 4.23474, 4.27859, 4.32061, 4.36077, 4.39905, 4.43544, 4.46992, 4.50249, 4.53314, 4.56185, 4.58864, 4.61349, 4.63642, 4.65745, 4.67657, 4.69381, 4.7092, 4.72274, 4.73447, 4.74441, 4.75259, 4.75903, 4.76376, 4.76682, 4.76822, 4.768, 4.76618, 4.76279, 4.75786, 4.75142, 4.74348, 4.73409, 4.72326, 4.71102, 4.69739, 4.68241, 4.6661, 4.64849, 4.6296, 4.60948, 4.58816, 4.56567, 4.54204, 4.51732, 4.49154, 4.46473, 4.43694, 4.4082, 4.37854, 4.348,
                4.31662, 4.28443, 4.25145, 4.21773, 4.1833, 4.14819, 4.11243, 4.07606, 4.03912, 4.00162, 3.96361, 3.92512, 3.88618, 3.84683, 3.80708, 3.76697, 3.72653, 3.68579, 3.64478, 3.60351, 3.56202, 3.52033, 3.47845, 3.43642, 3.39425, 3.35196, 3.30957, 3.2671, 3.22455, 3.18196, 3.13933, 3.09668, 3.05402, 3.01136, 2.96873, 2.92613, 2.88357, 2.84108, 2.79865, 2.75631, 2.71407, 2.67195, 2.62994, 2.58807, 2.54634, 2.50477, 2.46338, 2.42216, 2.38114, 2.34032, 2.29971, 2.25933, 2.21916, 2.17923, 2.13954, 2.10008, 2.06087, 2.02189, 1.98316, 1.94468, 1.90644, 1.86845, 1.83069,
                1.79316, 1.75586, 1.71877, 1.68189, 1.6452, 1.60868, 1.57232, 1.53611, 1.50004, 1.46407, 1.4282, 1.39241, 1.35668, 1.321, 1.28535, 1.24972, 1.2141, 1.17849, 1.14286, 1.10723, 1.07158, 1.03593, 1.00028, .96464, .92902, .89344, .85793, .8225, .78719, .75203, .71705, .68231, .64784, .61369, .57991, .54656, .51368, .48134, .44959, .41849, .3881, .35848, .32967, .30174, .27474, .24872, .22373, .19982, .17702, .15539, .13497, .11579, .09791, .08137, .06621, .05248, .04022, .02948, .02029, .01271, .00677, .00252, 0, -7.6E-4, 2.7E-4, .00314, .00788, .01451, .02307, .03357,
                .04604, .0605, .07697, .09546, .11599, .13858, .16322, .18992, .21869, .24952, .28241, .31735, .35434], pressure: [.95248, .95236, .95228, .95223, .95222, .95224, .95231, .95241, .95256, .95274, .95296, .95322, .95352, .95385, .95423, .95465, .9551, .9556, .95613, .9567, .95731, .95796, .95864, .95936, .96012, .96091, .96173, .96259, .96348, .9644, .96535, .96633, .96734, .96838, .96944, .97053, .97164, .97277, .97393, .9751, .97629, .9775, .97873, .97997, .98122, .98249, .98376, .98505, .98634, .98763, .98893, .99023, .99154, .99284, .99414, .99544, .99673, .99802,
                  .9993, .99942, .99816, .99691, .99568, .99445, .99324, .99205, .99087, .98972, .98858, .98746, .98636, .98528, .98423, .9832, .98219, .98121, .98025, .97931, .9784, .97752, .97666, .97582, .97501, .97423, .97347, .97274, .97203, .97135, .9707, .97007, .96948, .9689, .96836, .96784, .96735, .96689, .96646, .96605, .96567, .96533, .965, .96471, .96445, .96421, .964, .96382, .96367, .96355, .96346, .96339, .96335, .96334, .96336, .9634, .96348, .96358, .9637, .96385, .96403, .96423, .96446, .96471, .96499, .96529, .96561, .96595, .96631, .96669, .96709, .96751, .96795, .9684,
                  .96887, .96935, .96984, .97035, .97087, .9714, .97194, .97249, .97304, .97361, .97418, .97476, .97534, .97592, .97651, .97711, .9777, .9783, .9789, .9795, .9801, .9807, .9813, .9819, .9825, .98309, .98369, .98428, .98486, .98545, .98603, .98661, .98718, .98775, .98832, .98888, .98944, .99, .99056, .99112, .99167, .99223, .99279, .99335, .99392, .99449, .99507, .99565, .99624, .99684, .99745, .99807, .9987, .99934, 1, .99933, .99866, .99797, .99727, .99656, .99583, .9951, .99435, .99359, .99283, .99205, .99126, .99046, .98966, .98885, .98803, .9872, .98637, .98554, .9847,
                  .98387, .98303, .98219, .98134, .9805, .97967, .97883, .978, .97717, .97634, .97552, .97471, .97389, .97309, .97229, .9715, .97071, .96993, .96915, .96838, .96762, .96687, .96612, .96539, .96466, .96395, .96324, .96255, .96187, .9612, .96055, .95991, .95929, .95869, .95811, .95754, .957, .95648, .95599, .95552, .95508, .95467, .95428, .95393, .9536, .95331, .95305, .95283, .95264]
            }, {
              distance: [2.85606, 2.86149, 2.86432, 2.8645, 2.862, 2.85686, 2.84912, 2.83886, 2.82618, 2.81117, 2.79393, 2.77456, 2.75314, 2.72975, 2.70447, 2.67734, 2.64844, 2.61784, 2.58564, 2.55196,
                2.5169, 2.48057, 2.44305, 2.40438, 2.36462, 2.32383, 2.28208, 2.23943, 2.19591, 2.15153, 2.10628, 2.06016, 2.01321, 1.96548, 1.91702, 1.86793, 1.8183, 1.76829, 1.71803, 1.66767, 1.61737, 1.56726, 1.51746, 1.46803, 1.41902, 1.37044, 1.32228, 1.27452, 1.22716, 1.18023, 1.13376, 1.08781, 1.04244, .99769, .95357, .91003, .86701, .82447, .78238, .74069, .69938, .65836, .61758, .57699, .53656, .49627, .45611, .41611, .37632, .33683, .29776, .25924, .22141, .18441, .14839, .11346, .07972, .04727, .01619, -.01348, -.0417, -.0684, -.09351, -.11698, -.13875, -.1588, -.17713,
                -.19381, -.20889, -.22242, -.23444, -.24501, -.25421, -.26216, -.26897, -.27473, -.27951, -.28336, -.28631, -.28836, -.28948, -.28963, -.28873, -.28673, -.28355, -.27916, -.27354, -.26673, -.25878, -.2498, -.23992, -.22929, -.21802, -.20623, -.19398, -.18134, -.16836, -.1551, -.14163, -.12809, -.11461, -.1013, -.08826, -.07557, -.06335, -.0517, -.04077, -.03065, -.02143, -.01321, -.00606, 0, .00496, .00888, .01181, .01385, .01511, .0157, .01574, .01533, .01458, .01358, .0124, .01112, .00979, .00851, .00738, .0065, .006, .00596, .00646, .00754, .00924, .01161, .01471,
                .01858, .02323, .02865, .03481, .04169, .0493, .05765, .06677, .07671, .08754, .09934, .11222, .12628, .14159, .15823, .17624, .19561, .21632, .23828, .26142, .28563, .31083, .33696, .36397, .39185, .42057, .4501, .48036, .51125, .54264, .5744, .60646, .63871, .67105, .70337, .73556, .76751, .79918, .83048, .86139, .8919, .92202, .95184, .98144, 1.01094, 1.04045, 1.0701, 1.10002, 1.13029, 1.16103, 1.1923, 1.22416, 1.25664, 1.28979, 1.32364, 1.35824, 1.39363, 1.42985, 1.4669, 1.50475, 1.54332, 1.58252, 1.62227, 1.6625, 1.70312, 1.744, 1.78501, 1.82598, 1.8668, 1.90734,
                1.94754, 1.98732, 2.02666, 2.06555, 2.10402, 2.1421, 2.17985, 2.2173, 2.25448, 2.29139, 2.328, 2.36424, 2.4, 2.43515, 2.46955, 2.50309, 2.53565, 2.56717, 2.59761, 2.62692, 2.65505, 2.68191, 2.7074, 2.73138, 2.75375, 2.7744, 2.79324, 2.81017, 2.82504, 2.83772, 2.8481], pressure: [.22758, .23641, .24578, .25568, .26609, .27699, .28835, .30016, .31237, .32495, .33789, .35113, .36466, .37843, .39241, .40658, .4209, .43535, .44989, .4645, .47916, .49385, .50853, .5232, .53784, .55243, .56696, .58141, .59578, .61004, .62419, .63821, .65209, .6658, .67934, .69268, .70582,
                  .71873, .73139, .7438, .75594, .76779, .77935, .79061, .80156, .81221, .82254, .83258, .84231, .85176, .86091, .86978, .87837, .88669, .89473, .9025, .91, .91725, .92425, .931, .93752, .9438, .94985, .95566, .96124, .96658, .97168, .97652, .98109, .98539, .98939, .99309, .99646, .99949, .99783, .99552, .99361, .99209, .99098, .99029, .99003, .99019, .99079, .99181, .99324, .9951, .99735, 1, .99698, .99361, .98992, .98592, .98163, .97709, .97231, .96731, .96212, .95676, .95122, .94554, .93973, .93378, .92773, .92157, .91532, .90899, .90258, .89612, .88961, .88308, .87653,
                  .87, .8635, .85705, .85068, .8444, .83823, .83219, .82628, .82052, .81493, .80952, .8043, .79929, .7945, .78994, .78561, .78151, .77765, .77402, .77062, .76742, .76443, .76161, .75896, .75645, .75406, .75175, .74951, .7473, .74511, .74289, .74064, .73833, .73592, .73341, .73078, .728, .72507, .72197, .71869, .71522, .71156, .70769, .70363, .69936, .69489, .69021, .68533, .68023, .67492, .66939, .66363, .65765, .65145, .64501, .63833, .63143, .62428, .61691, .60931, .60148, .59344, .58521, .57679, .5682, .55948, .55063, .54167, .53264, .52354, .51439, .50522, .49603, .48686,
                  .47773, .46865, .45964, .45072, .44192, .43324, .42469, .41629, .40804, .39994, .392, .3842, .37655, .36903, .36164, .35437, .3472, .34012, .33312, .3262, .31933, .31251, .30574, .299, .2923, .28563, .27899, .27239, .26583, .25933, .25288, .24652, .24025, .2341, .22808, .22221, .21653, .21104, .20576, .20072, .19592, .19138, .18712, .18313, .17943, .17602, .17292, .17013, .16766, .16551, .16369, .16222, .1611, .16036, .16001, .16007, .16055, .16148, .16286, .16471, .16705, .16988, .17321, .17706, .18144, .18636, .19182, .19785, .20443, .21158, .2193]
            }, {
              distance: [-2.31317,
              -2.3191, -2.32189, -2.32154, -2.31811, -2.31174, -2.30254, -2.29062, -2.27609, -2.25904, -2.23954, -2.21767, -2.19355, -2.16732, -2.13907, -2.10885, -2.07672, -2.04268, -2.00677, -1.96911, -1.92985, -1.88914, -1.84713, -1.80397, -1.75979, -1.71467, -1.66864, -1.62171, -1.57395, -1.52546, -1.47625, -1.42628, -1.3755, -1.32384, -1.27131, -1.218, -1.16408, -1.10972, -1.05508, -1.00031, -.94551, -.89077, -.83615, -.7817, -.72757, -.6739, -.62076, -.56821, -.51625, -.46484, -.41397, -.36366, -.314, -.26506, -.21689, -.16957, -.12316, -.07766, -.03301, .01085,
                .05399, .09643, .13827, .17967, .22079, .26176, .30265, .34342, .38397, .42414, .46381, .50285, .54115, .57863, .61524, .65093, .6856, .71914, .75153, .78275, .81283, .84182, .86972, .89651, .92208, .94634, .96919, .99052, 1.01025, 1.02835, 1.04484, 1.05976, 1.07309, 1.08479, 1.09492, 1.1036, 1.11096, 1.11714, 1.12224, 1.12627, 1.12916, 1.13083, 1.13125, 1.13036, 1.12816, 1.12466, 1.11992, 1.11397, 1.10677, 1.09827, 1.08849, 1.07746, 1.06527, 1.05203, 1.03786, 1.02283, 1.00695, .99025, .97279, .9546, .93573, .9163, .8965, .8765, .85647, .83652, .81687, .79775, .77939,
                .76199, .74568, .73049, .71635, .70316, .69082, .67925, .66834, .65804, .64831, .63911, .63032, .62184, .61363, .60564, .59788, .59036, .58308, .57597, .5689, .56177, .55447, .5469, .53896, .53062, .5219, .51283, .5034, .49355, .48335, .47287, .46223, .45154, .44085, .43012, .41923, .40805, .39648, .38441, .37176, .35849, .34458, .32999, .31461, .29833, .28109, .26288, .2437, .22361, .20265, .18082, .15807, .13434, .1096, .0838, .0569, .02894, 0, -.0298, -.0604, -.09173, -.12364, -.15594, -.18843, -.22092, -.25331, -.28559, -.31781, -.35006, -.38244, -.41502, -.44785,
              -.48098, -.5144, -.54811, -.58218, -.61666, -.65153, -.68677, -.72232, -.75807, -.79397, -.83002, -.86628, -.90281, -.93968, -.97693, -1.01465, -1.05282, -1.09139, -1.13031, -1.16956, -1.20917, -1.24905, -1.28907, -1.32908, -1.36891, -1.40844, -1.44765, -1.48658, -1.52527, -1.56376, -1.60206, -1.64016, -1.67801, -1.71552, -1.75264, -1.78936, -1.8257, -1.86161, -1.89702, -1.93182, -1.96584, -1.99894, -2.03102, -2.06203, -2.0919, -2.12056, -2.14794, -2.17397, -2.19852, -2.22138, -2.24235, -2.26129, -2.27805, -2.29243, -2.30422], pressure: [.9681, .97424,
                .98046, .98674, .99309, .9995, .99404, .98754, .981, .97444, .96785, .96124, .95462, .94801, .94139, .93479, .92822, .92167, .91515, .90868, .90225, .89589, .88959, .88336, .87722, .87115, .86519, .85932, .85356, .84792, .84239, .83699, .83173, .8266, .82162, .81679, .81211, .80759, .80324, .79906, .79505, .79121, .78756, .78409, .78081, .77771, .77481, .77211, .76959, .76728, .76516, .76324, .76153, .76001, .75869, .75757, .75665, .75593, .7554, .75507, .75493, .75498, .75523, .75565, .75627, .75706, .75803, .75917, .76049, .76197, .76361, .76541, .76737, .76947, .77172,
                .77409, .7766, .77923, .78198, .78484, .7878, .79086, .79401, .79724, .80055, .80394, .8074, .81092, .8145, .81813, .82182, .82556, .82934, .83317, .83703, .84093, .84487, .84884, .85284, .85687, .86094, .86503, .86915, .87329, .87746, .88166, .88587, .89011, .89436, .89863, .90291, .9072, .91149, .91579, .92009, .92438, .92867, .93295, .9372, .94144, .94566, .94985, .954, .95812, .96219, .96623, .97021, .97415, .97802, .98184, .9856, .9893, .99293, .9965, 1, .99657, .9932, .98991, .98668, .98352, .98042, .97738, .9744, .97148, .9686, .96577, .96298, .96023, .95751, .95482,
                .95214, .94949, .94684, .9442, .94156, .93892, .93627, .93361, .93094, .92825, .92555, .92284, .9201, .91735, .91458, .91179, .90899, .90616, .90332, .90047, .8976, .89472, .89183, .88893, .88603, .88314, .88024, .87735, .87448, .87162, .86878, .86597, .86319, .86044, .85774, .85508, .85247, .84993, .84744, .84503, .84269, .84042, .83825, .83616, .83417, .83227, .83048, .8288, .82724, .82578, .82445, .82324, .82215, .82119, .82037, .81967, .81911, .81868, .81839, .81824, .81823, .81835, .81862, .81903, .81957, .82026, .82109, .82206, .82317, .82443, .82583, .82737, .82906,
                .83089, .83287, .83499, .83726, .83968, .84223, .84494, .84778, .85077, .8539, .85717, .86058, .86412, .86781, .87163, .87559, .87968, .88391, .88826, .89275, .89737, .90211, .90698, .91198, .91709, .92233, .92768, .93315, .93873, .94441, .95019, .95607, .96205]
            }, {
              distance: [4.72925, 4.81721, 4.9037, 4.98859, 5.07177, 5.15311, 5.23249, 5.3098, 5.38491, 5.45772, 5.52811, 5.59598, 5.66122, 5.72375, 5.78346, 5.84028, 5.8941, 5.94486, 5.99248, 6.03689, 6.07803, 6.11584, 6.15028, 6.18128, 6.20882, 6.23285, 6.25336, 6.27031, 6.28369, 6.29348, 6.29969, 6.3023, 6.30133,
                6.29678, 6.28867, 6.27703, 6.26187, 6.24324, 6.22116, 6.19567, 6.16683, 6.13468, 6.09928, 6.06068, 6.01896, 5.97417, 5.92639, 5.87569, 5.82217, 5.76589, 5.70696, 5.64545, 5.58147, 5.5151, 5.44644, 5.37559, 5.30265, 5.2277, 5.15085, 5.0722, 4.99184, 4.90987, 4.82639, 4.74151, 4.65533, 4.56794, 4.47945, 4.38996, 4.29959, 4.20843, 4.11658, 4.02416, 3.93125, 3.83796, 3.74437, 3.65057, 3.55666, 3.46272, 3.36884, 3.27509, 3.18155, 3.08831, 2.99545, 2.90303, 2.81114, 2.71984, 2.62922, 2.53933, 2.45026, 2.36207, 2.27484, 2.18862, 2.10349, 2.01951, 1.93675, 1.85528,
                1.77515, 1.69644, 1.61919, 1.54348, 1.46935, 1.39685, 1.32605, 1.25698, 1.18967, 1.12417, 1.06049, .99863, .93862, .88044, .82408, .76953, .71676, .66574, .61644, .56882, .52282, .47841, .43553, .39413, .35414, .31551, .27817, .24206, .20712, .17328, .14048, .10866, .07776, .04772, .01848, -.00999, -.03776, -.06487, -.09134, -.11721, -.14251, -.16725, -.19144, -.21509, -.2382, -.26076, -.28275, -.30416, -.32496, -.34511, -.36459, -.38334, -.40134, -.41852, -.43485, -.45026, -.46471, -.47815, -.49052, -.50179, -.51189, -.52081, -.52849, -.5349, -.54003, -.54383,
                -.54627, -.54734, -.54702, -.54528, -.54211, -.53752, -.53149, -.52403, -.51515, -.50487, -.4932, -.48015, -.46575, -.45001, -.43297, -.41463, -.39503, -.37419, -.35213, -.32887, -.30443, -.27885, -.25214, -.22432, -.19541, -.16544, -.13442, -.10235, -.06926, -.03514, 0, .03616, .07336, .11159, .15088, .19125, .23272, .27531, .31906, .36401, .41019, .45764, .5064, .55651, .60802, .66096, .71538, .77129, .82874, .88776, .94836, 1.01056, 1.07438, 1.13982, 1.20687, 1.27554, 1.34581, 1.41766, 1.49107, 1.56599, 1.64239, 1.72025, 1.79951, 1.88013, 1.96209, 2.04532, 2.12979,
                2.21546, 2.30226, 2.39017, 2.47911, 2.56905, 2.65991, 2.75164, 2.84416, 2.93742, 3.03133, 3.12582, 3.2208, 3.31619, 3.41191, 3.50785, 3.60393, 3.70006, 3.79612, 3.89202, 3.98765, 4.08291, 4.17767, 4.27182, 4.36525, 4.45783, 4.54944, 4.63995], pressure: [.30942, .30838, .30765, .30724, .30715, .30738, .30795, .30884, .31007, .31164, .31354, .31578, .31837, .32129, .32455, .32815, .33209, .33636, .34097, .34591, .35117, .35675, .36265, .36887, .37539, .38221, .38933, .39674, .40442, .41238, .4206, .42907, .43779, .44675, .45593, .46533, .47493, .48473, .49471, .50486,
                  .51517, .52563, .53623, .54694, .55777, .5687, .57971, .59079, .60194, .61313, .62435, .6356, .64686, .65811, .66935, .68056, .69174, .70286, .71391, .72489, .73579, .74659, .75728, .76785, .7783, .7886, .79876, .80877, .81861, .82827, .83776, .84706, .85617, .86507, .87378, .88227, .89056, .89863, .90649, .91412, .92153, .92872, .93568, .94241, .94892, .95519, .96122, .96702, .97258, .97791, .98299, .98783, .99242, .99677, .99911, .99525, .99164, .98827, .98515, .98228, .97966, .97728, .97514, .97324, .97159, .97017, .96898, .96801, .96727, .96674, .96641, .96629, .96635,
                  .96661, .96703, .96762, .96838, .96928, .97032, .97149, .97279, .9742, .97572, .97734, .97905, .98085, .98273, .98468, .98669, .98877, .99091, .99311, .99535, .99765, 1, .9976, .99516, .99267, .99014, .98755, .98491, .98222, .97947, .97666, .97378, .97083, .96781, .96471, .96153, .95826, .9549, .95144, .94787, .9442, .94042, .93651, .93249, .92834, .92407, .91966, .91512, .91045, .90564, .90069, .8956, .89037, .885, .87949, .87384, .86806, .86214, .85608, .84988, .84356, .83711, .83053, .82383, .81702, .81009, .80306, .79594, .78872, .78141, .77403, .76657, .75905, .75148,
                  .74385, .73619, .72849, .72076, .71302, .70526, .69749, .68972, .68195, .67419, .66644, .65871, .65099, .64329, .63561, .62795, .62032, .61271, .60512, .59755, .59001, .58248, .57497, .56749, .56002, .55256, .54512, .5377, .5303, .52291, .51554, .50819, .50087, .49358, .48632, .4791, .47192, .4648, .45773, .45072, .44378, .43692, .43015, .42346, .41687, .41039, .40403, .39779, .39168, .38571, .37989, .37423, .36873, .36342, .35828, .35335, .34862, .34409, .3398, .33573, .3319, .32831, .32498, .32192, .31912, .3166, .31436, .31242, .31077]
            }]
          }; a.StrokesTexture = n; a.generateStrokesTexture =
            function (l) {
              const h = p.resolution; var b = h / 2; const d = new Uint8Array(4 * h * h), f = 4 * h * b; b = p.amplitude; const t = 2 * b, v = 4 * h, m = Math.log2(h) + 1, e = p.strokes.length; let g = (m - 1) * e * v; for (const { distance: x, pressure: k } of p.strokes) { let r = x, A = k, z = g; for (let B = 0; B < m; B++) { 0 !== B && (r = y(r, 0), A = y(A, 1)); for (let C = 0; C < p.resolution; C++) { const D = A ? A[C % A.length] : 1; w.packFloatRGBA((r ? r[C % r.length] / t : 0) + .5, d, z); w.packFloatRGBA(D, d, z + f); z += 4 } z -= v * (e + 1) } g += v } l = new u(l, {
                pixelFormat: 6408, dataType: 5121, hasMipmap: !1, samplingMode: 9729, width: h,
                height: h, wrapMode: 10497
              }, d); return new n(h, t, b, e, l)
            }; a.rasterizeStrokes = function () {
              var l = p.resolution; const h = Math.log2(l) + 1; var b = p.strokes.length; const d = p.amplitude, f = Math.ceil(2 * d + .5); var t; for (t = 0; 1 <= l;)t += l, l /= 2; t += 6 * (h + 1); b *= f; l = new Uint8ClampedArray(4 * t * b); const v = 4 * t; l.fill(255); let m = 24; for (const { distance: e, pressure: g } of p.strokes) {
                let x = e, k = g, r = m; for (let A = 0; A < h; A++) {
                0 !== A && (x = y(x, 0), k = y(k, 1)); for (let z = 0; z < x.length; z++) {
                  const B = x ? x[z] : 0, C = k ? c.clamp(k[z], 0, 1) : 1; let D = r; for (let E = -d; E <
                    f - d; E++) { const H = 255 - 255 * c.clamp(1 - (Math.abs(E - B + .5) - .5 * C), 0, 1); l[D + 0] = H; l[D + 1] = H; l[D + 2] = H; l[D + 3] = 255; D += v } r += 4
                } r += 24
                } m += f * v
              } return new ImageData(l, t, b)
            }; a.strokesDefinition = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/lib/edgeRendering/util": function () {
      define(["exports", "../../../../../core/arrayUtils", "../../../../../core/maybe"], function (a, w, c) {
      a.computeEdgeCount = function (q, u, y) {
        const n = q.length; u *= y.minimumEdgeLength; y = w.binaryIndexOf(q, u, !0); q = -1 === y ? u < q[0] ?
          0 : q.length : y; return n - q
      }; a.determineEdgeTransparency = function (q) { let u = 0; for (const { material: y } of q) if (0 < y.size * y.color[3] * y.opacity) { if (1 > y.color[3] * y.opacity) return 1; u = 2 } return u }; a.determineObjectTransparency = function (q) { let u = 0; for (const { material: y } of q) if (0 < y.size * y.color[3] * y.opacity) { switch (y.objectTransparency) { case 1: case 0: return 1; case 2: if (1 > y.opacity) return 1 }u = 2 } return u }; a.determineRendererType = function (q) {
        let u = null; for (const y of q) if (q = y.type, 0 < y.size * y.color[3]) if (c.isNone(u)) u =
          q; else if (u !== q) return "uber"; return c.isSome(u) ? u : "uber"
      }; a.estimateLengthAtDistance = function (q, u, y, n) { return n / q * y * 2 * Math.tan(.5 * u) }; a.fillComponenBufferIndices = function (q, u, y, n) { for (let l = 0; l < q.length; l++) { const h = q[l].index; var p = u[l]; const b = u[l + 1]; if (n) for (; p < b; p++)y.set(n[p], h); else for (; p < b; p++)y.set(p, h) } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/statistics/RendererPerformanceInfo": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/PerformanceSampler ../../../../core/accessorSupport/utils ../../../webgl/Measurement".split(" "),
        function (a, w, c, q, u, y) {
          const n = "prepare;shadowmap;lineardepth;normals;ssao;opaque;opaque edges;transparent;transparent edges;hudvisibility;transparent terrain;atmosphere;laserline;occluded;antialiasing;highlights;hudOccluded;hudNotoccluded".split(";"); let p = function (h) { function b() { var d = h.call(this, "total") || this; d.total = 0; d.frameCount = 0; return d } w._inheritsLoose(b, h); return b }(q), l = function () {
            function h() {
            this._enableGPUTimer = this._lastSample = this._startTime = 0; this.totalTime = new p; this.gpuTime = new q("gpu",
              9); this.renderPassTimings = n.map(d => new q(d))
            } var b = h.prototype; b.enableGPUTimer = function () { ++this._enableGPUTimer; return { remove: u.once(() => --this._enableGPUTimer) } }; b.prerender = function (d) { this._startTime = this._lastSample = performance.now(); this._enableGPUTimer && (this._gpuTimer = y.startMeasurement(d)) }; b.advance = function (d) { const f = performance.now(); this.renderPassTimings[d].record(f - this._lastSample); this._lastSample = f }; b.postrender = function () {
              c.isSome(this._gpuTimer) && (this._gpuTimer.stop(f => c.isSome(f) &&
                this.gpuTime.record(f), 16), this._gpuTimer = null); const d = performance.now() - this._startTime; this.totalTime.record(d); this.totalTime.total += d; this.totalTime.frameCount++
            }; return h
          }(); a.RenderTime = p; a.RendererPerformanceInfo = l; a.performanceStatsCategories = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/Measurement": function () {
      define(["exports", "../../core/maybe"], function (a, w) {
        let c = function () {
          function y(p) { this.timer = p; this.start = p.createQuery(); p.createTimestamp(this.start) }
          var n = y.prototype; n.stop = function (p, l = 50) { this.end = this.timer.createQuery(); this.timer.createTimestamp(this.end); this.checkQueryResult(p, l) }; n.checkQueryResult = function (p, l) { if (this.timer.resultAvailable(this.end)) if (this.timer.disjoint()) p(null); else { var h = this.timer.getResult(this.start), b = this.timer.getResult(this.end); p((b - h) / 1E6) } else setTimeout(() => this.checkQueryResult(p, l), l) }; return y
        }(), q = function () {
          function y(p) { this.timer = p; this.query = p.createQuery(); u = !0; this.timer.beginTimeElapsed(this.query) }
          var n = y.prototype; n.stop = function (p, l = 50) { this.timer.endTimeElapsed(); u = !1; this.checkQueryResult(p, l) }; n.checkQueryResult = function (p, l) { var h = this.timer.resultAvailable(this.query); const b = this.timer.disjoint(); h && !b ? (h = this.timer.getResult(this.query), p(h / 1E6)) : b ? p(null) : setTimeout(() => this.checkQueryResult(p, l), l) }; return y
        }(), u = !1; a.startMeasurement = function (y) { y = y.capabilities.disjointTimerQuery; return w.isNone(y) ? null : 0 < y.timestampBits() ? new c(y) : u ? null : new q(y) }; Object.defineProperty(a, "__esModule",
          { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/RenderingContext": function () { define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../webgl/RenderingContext"], function (a, w, c) { c = function (q) { function u(y, n, p) { y = q.call(this, y, n) || this; y.newCache = p; return y } w._inheritsLoose(u, q); return u }(c.RenderingContext); a.RenderingContext = c; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/webgl/RenderingContext": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/maybe ./checkWebGLError ./enums ./InstanceCounter ./renderState ./Texture ./WebGLDriverTest ./capabilities/isWebGL2Context ./capabilities/load".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          function d(v, m, e, g) { m ? g !== m && v.bindBuffer(e, m.glName) : v.bindBuffer(e, null); return m } function f(v, m) { switch (v) { case 0: return 2 * m; case 4: return m / 3; case 5: return m - 2; case 6: return m - 2; default: return 0 } } let t = function () {
            function v(e, g) {
            this.gl = e; this.instanceCounter = new y.InstanceCounter; this._blendEnabled = !1; this._blendColorState = { r: 0, g: 0, b: 0, a: 0 }; this._blendFunctionState = { srcRGB: 1, dstRGB: 0, srcAlpha: 1, dstAlpha: 0 }; this._blendEquationState = { mode: 32774, modeAlpha: 32774 };
              this._colorMaskState = { r: !0, g: !0, b: !0, a: !0 }; this._polygonCullingEnabled = !1; this._cullFace = 1029; this._frontFace = 2305; this._scissorTestEnabled = !1; this._scissorRect = { x: 0, y: 0, width: 0, height: 0 }; this._depthTestEnabled = !1; this._depthFunction = 513; this._clearDepth = 1; this._depthWriteEnabled = !0; this._depthRange = { zNear: 0, zFar: 1 }; this._viewport = null; this._polygonOffsetFillEnabled = this._stencilTestEnabled = !1; this._polygonOffset = [0, 0]; this._stencilFunction = { face: 1032, func: 519, ref: 0, mask: 1 }; this._clearStencil = 0; this._stencilWriteMask =
                1; this._stencilOperation = { face: 1032, fail: 7680, zFail: 7680, zPass: 7680 }; this._clearColor = { r: 0, g: 0, b: 0, a: 0 }; this._activeRenderbuffer = this._activeFramebuffer = this._activeIndexBuffer = this._activeVertexBuffer = this._activeShaderProgram = null; this._activeTextureUnit = 0; this._textureUnitMap = []; this._numOfTriangles = this._numOfDrawCalls = 0; this.webglVersion = h(e) ? "webgl2" : "webgl"; "webgl" === this.webglVersion && this.gl.getExtension("OES_element_index_uint"); this._capabilities = b.loadCapabilities(e, g); this._parameters =
                  this._loadParameters(g); e = this.gl.getParameter(this.gl.VIEWPORT); this._viewport = { x: e[0], y: e[1], width: e[2], height: e[3] }; this._stateTracker = new n.StateTracker({
                    setBlending: x => { x ? (this.setBlendingEnabled(!0), this.setBlendEquationSeparate(x.opRgb, x.opAlpha), this.setBlendFunctionSeparate(x.srcRgb, x.dstRgb, x.srcAlpha, x.dstAlpha), x = x.color, this.setBlendColor(x.r, x.g, x.b, x.a)) : this.setBlendingEnabled(!1) }, setCulling: x => {
                      x ? (this.setFaceCullingEnabled(!0), this.setCullFace(x.face), this.setFrontFace(x.mode)) :
                        this.setFaceCullingEnabled(!1)
                    }, setPolygonOffset: x => { x ? (this.setPolygonOffsetFillEnabled(!0), this.setPolygonOffset(x.factor, x.units)) : this.setPolygonOffsetFillEnabled(!1) }, setDepthTest: x => { x ? (this.setDepthTestEnabled(!0), this.setDepthFunction(x.func)) : this.setDepthTestEnabled(!1) }, setStencilTest: x => { if (x) { this.setStencilTestEnabled(!0); const k = x.function; this.setStencilFunction(k.func, k.ref, k.mask); x = x.operation; this.setStencilOp(x.fail, x.zFail, x.zPass) } else this.setStencilTestEnabled(!1) }, setDepthWrite: x => { x ? (this.setDepthWriteEnabled(!0), this.setDepthRange(x.zNear, x.zFar)) : this.setDepthWriteEnabled(!1) }, setColorWrite: x => { x ? this.setColorMask(x.r, x.g, x.b, x.a) : this.setColorMask(!1, !1, !1, !1) }, setStencilWrite: x => { x ? this.setStencilWriteMask(x.mask) : this.setStencilWriteMask(0) }
                  }); this.enforceState(); this.driverTest = new l.WebGLDriverTest(this)
            } var m = v.prototype; m.dispose = function () { this.bindVAO(null); this.unbindBuffer(34962); this.unbindBuffer(34963); this._textureUnitMap.length = 0; q.webglDebugEnabled() && this.instanceCounter.printResourceCount() };
            m.setPipelineState = function (e) { this._stateTracker.setPipeline(e) }; m.setBlendingEnabled = function (e) { this._blendEnabled !== e && (!0 === e ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._blendEnabled = e, this._stateTracker.invalidateBlending()) }; m.externalProgramUpdate = function () { var e; null == (e = this._activeShaderProgram) ? void 0 : e.stop(); this._activeShaderProgram = null }; m.externalTextureUnitUpdate = function (e, g) {
              for (let x = 0; x < e.length; ++x)this._textureUnitMap[e[x]] = null; 0 <= g && (this._activeTextureUnit =
                g)
            }; m.externalVertexArrayObjectUpdate = function () { const e = this.capabilities.vao; e && (e.bindVertexArray(null), this._activeVertexArrayObject = null); this._activeIndexBuffer = this._activeVertexBuffer = null }; m.externalVertexBufferUpdate = function () { this._activeVertexBuffer = null }; m.externalIndexBufferUpdate = function () { this._activeIndexBuffer = null }; m.setBlendColor = function (e, g, x, k) {
              if (e !== this._blendColorState.r || g !== this._blendColorState.g || x !== this._blendColorState.b || k !== this._blendColorState.a) this.gl.blendColor(e,
                g, x, k), this._blendColorState.r = e, this._blendColorState.g = g, this._blendColorState.b = x, this._blendColorState.a = k, this._stateTracker.invalidateBlending()
            }; m.setBlendFunction = function (e, g) { if (e !== this._blendFunctionState.srcRGB || g !== this._blendFunctionState.dstRGB) this.gl.blendFunc(e, g), this._blendFunctionState.srcRGB = e, this._blendFunctionState.srcAlpha = e, this._blendFunctionState.dstRGB = g, this._blendFunctionState.dstAlpha = g, this._stateTracker.invalidateBlending() }; m.setBlendFunctionSeparate = function (e,
              g, x, k) { if (this._blendFunctionState.srcRGB !== e || this._blendFunctionState.srcAlpha !== x || this._blendFunctionState.dstRGB !== g || this._blendFunctionState.dstAlpha !== k) this.gl.blendFuncSeparate(e, g, x, k), this._blendFunctionState.srcRGB = e, this._blendFunctionState.srcAlpha = x, this._blendFunctionState.dstRGB = g, this._blendFunctionState.dstAlpha = k, this._stateTracker.invalidateBlending() }; m.setBlendEquation = function (e) {
                this._blendEquationState.mode !== e && (this.gl.blendEquation(e), this._blendEquationState.mode = e,
                  this._blendEquationState.modeAlpha = e, this._stateTracker.invalidateBlending())
              }; m.setBlendEquationSeparate = function (e, g) { if (this._blendEquationState.mode !== e || this._blendEquationState.modeAlpha !== g) this.gl.blendEquationSeparate(e, g), this._blendEquationState.mode = e, this._blendEquationState.modeAlpha = g, this._stateTracker.invalidateBlending() }; m.setColorMask = function (e, g, x, k) {
                if (this._colorMaskState.r !== e || this._colorMaskState.g !== g || this._colorMaskState.b !== x || this._colorMaskState.a !== k) this.gl.colorMask(e,
                  g, x, k), this._colorMaskState.r = e, this._colorMaskState.g = g, this._colorMaskState.b = x, this._colorMaskState.a = k, this._stateTracker.invalidateColorWrite()
              }; m.setClearColor = function (e, g, x, k) { if (this._clearColor.r !== e || this._clearColor.g !== g || this._clearColor.b !== x || this._clearColor.a !== k) this.gl.clearColor(e, g, x, k), this._clearColor.r = e, this._clearColor.g = g, this._clearColor.b = x, this._clearColor.a = k }; m.setFaceCullingEnabled = function (e) {
              this._polygonCullingEnabled !== e && (!0 === e ? this.gl.enable(this.gl.CULL_FACE) :
                this.gl.disable(this.gl.CULL_FACE), this._polygonCullingEnabled = e, this._stateTracker.invalidateCulling())
              }; m.setPolygonOffsetFillEnabled = function (e) { this._polygonOffsetFillEnabled !== e && (!0 === e ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._polygonOffsetFillEnabled = e, this._stateTracker.invalidatePolygonOffset()) }; m.setPolygonOffset = function (e, g) {
                if (this._polygonOffset[0] !== e || this._polygonOffset[1] !== g) this._polygonOffset[0] = e, this._polygonOffset[1] = g,
                  this.gl.polygonOffset(e, g), this._stateTracker.invalidatePolygonOffset()
              }; m.setCullFace = function (e) { this._cullFace !== e && (this.gl.cullFace(e), this._cullFace = e, this._stateTracker.invalidateCulling()) }; m.setFrontFace = function (e) { this._frontFace !== e && (this.gl.frontFace(e), this._frontFace = e, this._stateTracker.invalidateCulling()) }; m.setScissorTestEnabled = function (e) {
              this._scissorTestEnabled !== e && (!0 === e ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._scissorTestEnabled =
                e)
              }; m.setScissorRect = function (e, g, x, k) { if (this._scissorRect.x !== e || this._scissorRect.y !== g || this._scissorRect.width !== x || this._scissorRect.height !== k) this.gl.scissor(e, g, x, k), this._scissorRect.x = e, this._scissorRect.y = g, this._scissorRect.width = x, this._scissorRect.height = k }; m.setDepthTestEnabled = function (e) { this._depthTestEnabled !== e && (!0 === e ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._depthTestEnabled = e, this._stateTracker.invalidateDepthTest()) }; m.setClearDepth = function (e) {
              this._clearDepth !==
                e && (this.gl.clearDepth(e), this._clearDepth = e)
              }; m.setDepthFunction = function (e) { this._depthFunction !== e && (this.gl.depthFunc(e), this._depthFunction = e, this._stateTracker.invalidateDepthTest()) }; m.setDepthWriteEnabled = function (e) { this._depthWriteEnabled !== e && (this.gl.depthMask(e), this._depthWriteEnabled = e, this._stateTracker.invalidateDepthWrite()) }; m.setDepthRange = function (e, g) {
                if (this._depthRange.zNear !== e || this._depthRange.zFar !== g) this.gl.depthRange(e, g), this._depthRange.zNear = e, this._depthRange.zFar =
                  g, this._stateTracker.invalidateDepthWrite()
              }; m.setStencilTestEnabled = function (e) { this._stencilTestEnabled !== e && (!0 === e ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._stencilTestEnabled = e, this._stateTracker.invalidateStencilTest()) }; m.setClearStencil = function (e) { e !== this._clearStencil && (this.gl.clearStencil(e), this._clearStencil = e) }; m.setStencilFunction = function (e, g, x) {
                if (this._stencilFunction.func !== e || this._stencilFunction.ref !== g || this._stencilFunction.mask !== x) this.gl.stencilFunc(e,
                  g, x), this._stencilFunction.face = 1032, this._stencilFunction.func = e, this._stencilFunction.ref = g, this._stencilFunction.mask = x, this._stateTracker.invalidateStencilTest()
              }; m.setStencilFunctionSeparate = function (e, g, x, k) { if (this._stencilFunction.face !== e || this._stencilFunction.func !== g || this._stencilFunction.ref !== x || this._stencilFunction.mask !== k) this.gl.stencilFuncSeparate(e, g, x, k), this._stencilFunction.face = e, this._stencilFunction.func = g, this._stencilFunction.ref = x, this._stencilFunction.mask = k, this._stateTracker.invalidateStencilTest() };
            m.setStencilWriteMask = function (e) { this._stencilWriteMask !== e && (this.gl.stencilMask(e), this._stencilWriteMask = e, this._stateTracker.invalidateStencilWrite()) }; m.setStencilOp = function (e, g, x) { if (this._stencilOperation.fail !== e || this._stencilOperation.zFail !== g || this._stencilOperation.zPass !== x) this.gl.stencilOp(e, g, x), this._stencilOperation.face = 1032, this._stencilOperation.fail = e, this._stencilOperation.zFail = g, this._stencilOperation.zPass = x, this._stateTracker.invalidateStencilTest() }; m.setStencilOpSeparate =
              function (e, g, x, k) { if (this._stencilOperation.face !== e || this._stencilOperation.fail !== g || this._stencilOperation.zFail !== x || this._stencilOperation.zPass !== k) this.gl.stencilOpSeparate(e, g, x, k), this._stencilOperation.face = e, this._stencilOperation.face = e, this._stencilOperation.fail = g, this._stencilOperation.zFail = x, this._stencilOperation.zPass = k, this._stateTracker.invalidateStencilTest() }; m.setActiveTexture = function (e, g = !1) {
                const x = this._activeTextureUnit; 0 <= e && (g || e !== this._activeTextureUnit) && (this.gl.activeTexture(u.BASE_TEXTURE_UNIT +
                  e), this._activeTextureUnit = e); return x
              }; m.clear = function (e) { e && this.gl.clear(e) }; m.clearSafe = function (e, g = 255) { e && (e & 16384 && this.setColorMask(!0, !0, !0, !0), e & 256 && this.setDepthWriteEnabled(!0), e & 1024 && this.setStencilWriteMask(g), this.gl.clear(e)) }; m.drawArrays = function (e, g, x) { q.webglDebugEnabled() && (this._numOfDrawCalls++ , this._numOfTriangles += f(e, x)); this.gl.drawArrays(e, g, x) }; m.drawElements = function (e, g, x, k) {
                q.webglDebugEnabled() && (this._numOfDrawCalls++ , this._numOfTriangles += f(e, g)); this.gl.drawElements(e,
                  g, x, k)
              }; m.logIno = function () { q.webglDebugEnabled() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`) }; m.setViewport = function (e, g, x, k) { x = Math.max(Math.round(x), 1); k = Math.max(Math.round(k), 1); const r = this._viewport; if (r.x !== e || r.y !== g || r.width !== x || r.height !== k) r.x = e, r.y = g, r.width = x, r.height = k, this.gl.viewport(e, g, x, k) }; m.getViewport = function () { return { x: this._viewport.x, y: this._viewport.y, width: this._viewport.width, height: this._viewport.height } }; m.useProgram = function (e) {
                var g,
                x; this._activeShaderProgram !== e && (null == (g = this._activeShaderProgram) ? void 0 : g.stop(), this._activeShaderProgram = e, this.gl.useProgram(null != (x = null == e ? void 0 : e.glName) ? x : null))
              }; m.bindTexture = function (e, g, x = !1) {
              (g >= this.parameters.maxTextureImageUnits || 0 > g) && console.error("Input texture unit is out of range of available units!"); const k = this._textureUnitMap[g]; if (c.isNone(e) || null == e.glName) return c.isSome(k) && (this.setActiveTexture(g, x), this.gl.bindTexture(k.descriptor.target, null)), this._textureUnitMap[g] =
                null, k; if (!x && k === e) return e.isDirty && (this.setActiveTexture(g, x), e.applyChanges()), k; this.setActiveTexture(g, x); this.gl.bindTexture(e.descriptor.target, e.glName); e.applyChanges(); this._textureUnitMap[g] = e; return k
              }; m.unbindTextureAllUnits = function (e) { for (let g = 0; g < this.parameters.maxTextureImageUnits; g++)this._textureUnitMap[g] === e && (this.bindTexture(null, g), this._textureUnitMap[g] = null) }; m.bindFramebuffer = function (e, g = !1, x = 3553) {
                if (c.isNone(e)) this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this._activeFramebuffer =
                  null; else if (g || this._activeFramebuffer !== e) e.initializeAndBind(x), this._activeFramebuffer = e
              }; m.bindBuffer = function (e) { e && (34962 === e.bufferType ? this._activeVertexBuffer = d(this.gl, e, e.bufferType, this._activeVertexBuffer) : this._activeIndexBuffer = d(this.gl, e, e.bufferType, this._activeIndexBuffer)) }; m.bindRenderbuffer = function (e) {
                const g = this.gl; e || (g.bindRenderbuffer(g.RENDERBUFFER, null), this._activeRenderbuffer = null); this._activeRenderbuffer !== e && (g.bindRenderbuffer(g.RENDERBUFFER, e.glName), this._activeRenderbuffer =
                  e)
              }; m.unbindBuffer = function (e) { 34962 === e ? this._activeVertexBuffer = d(this.gl, null, e, this._activeVertexBuffer) : this._activeIndexBuffer = d(this.gl, null, e, this._activeIndexBuffer) }; m.bindVAO = function (e = null) { c.isNone(e) ? this._activeVertexArrayObject && (this._activeVertexArrayObject.unbind(), this._activeVertexArrayObject = null) : this._activeVertexArrayObject !== e && (e.bind(), this._activeVertexArrayObject = e) }; m.getBoundFramebufferObject = function () { return this._activeFramebuffer }; m.getBoundVAO = function () { return this._activeVertexArrayObject };
            m.resetState = function () {
              this.useProgram(null); this.bindVAO(null); this.bindFramebuffer(null); this.unbindBuffer(34962); this.unbindBuffer(34963); for (let e = 0; e < this.parameters.maxTextureImageUnits; ++e)this.bindTexture(null, e); this.setBlendingEnabled(!1); this.setBlendFunction(1, 0); this.setBlendEquation(32774); this.setBlendColor(0, 0, 0, 0); this.setFaceCullingEnabled(!1); this.setCullFace(1029); this.setFrontFace(2305); this.setPolygonOffsetFillEnabled(!1); this.setPolygonOffset(0, 0); this.setScissorTestEnabled(!1);
              this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height); this.setDepthTestEnabled(!1); this.setDepthFunction(513); this.setDepthRange(0, 1); this.setStencilTestEnabled(!1); this.setStencilFunction(519, 0, 0); this.setStencilOp(7680, 7680, 7680); this.setClearColor(0, 0, 0, 0); this.setClearDepth(1); this.setClearStencil(0); this.setColorMask(!0, !0, !0, !0); this.setStencilWriteMask(4294967295); this.setDepthWriteEnabled(!0); this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height)
            }; m.enforceState = function () {
              var e,
              g, x, k; const r = this.gl; var A = this.capabilities.vao; A && A.bindVertexArray(null); for (let z = 0; z < this.parameters.maxVertexAttributes; z++)r.disableVertexAttribArray(z); this._activeVertexBuffer ? r.bindBuffer(this._activeVertexBuffer.bufferType, this._activeVertexBuffer.glName) : r.bindBuffer(34962, null); this._activeIndexBuffer ? r.bindBuffer(this._activeIndexBuffer.bufferType, this._activeIndexBuffer.glName) : r.bindBuffer(34963, null); if (A && this._activeVertexArrayObject) {
                if (A = this._activeVertexArrayObject) this._activeVertexArrayObject.unbind(),
                  this._activeVertexArrayObject = null; this.bindVAO(A)
              } r.bindFramebuffer(r.FRAMEBUFFER, null != (e = null == (g = this._activeFramebuffer) ? void 0 : g.glName) ? e : null); r.useProgram(null != (x = null == (k = this._activeShaderProgram) ? void 0 : k.glName) ? x : null); r.blendColor(this._blendColorState.r, this._blendColorState.g, this._blendColorState.b, this._blendColorState.a); r.bindRenderbuffer(r.RENDERBUFFER, this._activeRenderbuffer ? this._activeRenderbuffer.glName : null); !0 === this._blendEnabled ? r.enable(this.gl.BLEND) : r.disable(this.gl.BLEND);
              r.blendEquationSeparate(this._blendEquationState.mode, this._blendEquationState.modeAlpha); r.blendFuncSeparate(this._blendFunctionState.srcRGB, this._blendFunctionState.dstRGB, this._blendFunctionState.srcAlpha, this._blendFunctionState.dstAlpha); r.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a); r.clearDepth(this._clearDepth); r.clearStencil(this._clearStencil); r.colorMask(this._colorMaskState.r, this._colorMaskState.g, this._colorMaskState.b, this._colorMaskState.a);
              r.cullFace(this._cullFace); r.depthFunc(this._depthFunction); r.depthRange(this._depthRange.zNear, this._depthRange.zFar); !0 === this._depthTestEnabled ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST); r.depthMask(this._depthWriteEnabled); r.frontFace(this._frontFace); r.lineWidth(1); !0 === this._polygonCullingEnabled ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE); r.polygonOffset(this._polygonOffset[0], this._polygonOffset[1]); !0 === this._polygonOffsetFillEnabled ? r.enable(r.POLYGON_OFFSET_FILL) : r.disable(r.POLYGON_OFFSET_FILL);
              r.scissor(this._scissorRect.x, this._scissorRect.y, this._scissorRect.width, this._scissorRect.height); !0 === this._scissorTestEnabled ? r.enable(r.SCISSOR_TEST) : r.disable(r.SCISSOR_TEST); r.stencilFunc(this._stencilFunction.func, this._stencilFunction.ref, this._stencilFunction.mask); r.stencilOpSeparate(this._stencilOperation.face, this._stencilOperation.fail, this._stencilOperation.zFail, this._stencilOperation.zPass); !0 === this._stencilTestEnabled ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST); r.stencilMask(this._stencilWriteMask);
              for (e = 0; e < this.parameters.maxTextureImageUnits; e++)r.activeTexture(u.BASE_TEXTURE_UNIT + e), r.bindTexture(3553, null), r.bindTexture(34067, null), h(r) && r.bindTexture(32879, null), g = this._textureUnitMap[e], c.isSome(g) && r.bindTexture(g.descriptor.target, g.glName); r.activeTexture(u.BASE_TEXTURE_UNIT + this._activeTextureUnit); r.viewport(this._viewport.x, this._viewport.y, this._viewport.width, this._viewport.height); q.webglDebugEnabled() && (this._numOfTriangles = this._numOfDrawCalls = 0)
            }; m._loadParameters = function (e) {
              var g;
              const x = this.capabilities.textureFilterAnisotropic; e = null != (g = e.maxAnisotropy) ? g : Infinity; g = { versionString: this.gl.getParameter(this.gl.VERSION), maxVertexTextureImageUnits: this.gl.getParameter(this.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxVertexAttributes: this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS), maxMaxAnisotropy: x ? Math.min(this.gl.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY), e) : 1, maxTextureImageUnits: this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), maxTextureSize: this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE) };
              p.TEXTURE_UNIT_FOR_UPDATES = g.maxTextureImageUnits - 1; return g
            }; w._createClass(v, [{ key: "contextAttributes", get: function () { return this.gl.getContextAttributes() } }, { key: "parameters", get: function () { return this._parameters } }, { key: "capabilities", get: function () { return this._capabilities } }]); return v
          }(); a.RenderingContext = t; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/InstanceCounter": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../support/AllocationTracer",
        "./enums"], function (a, w, c, q) {
          let u = function () {
            function y() { this._current = []; this._max = []; for (this._allocations = new c.AllocationTracer(!1); this._current.length < q.ResourceType.COUNT;)this._current.push(0), this._max.push(0) } var n = y.prototype; n.resetMax = function () { for (this._max.length = 0; this._max.length < this._current.length;)this._max.push(0) }; n.increment = function (p, l) { const h = ++this._current[p]; this._max[p] = Math.max(h, this._max[p]); this._allocations.add(l) }; n.decrement = function (p, l) {
              --this._current[p];
              this._allocations.remove(l)
            }; n.printResourceCount = function () { if (0 < this.total) { console.log("Live objects:"); for (let p = 0; p < q.ResourceType.COUNT; ++p) { const l = this._current[p]; 0 < l && console.log(`${q.ResourceType[p]}: ${l}`) } } this._allocations.print() }; w._createClass(y, [{ key: "max", get: function () { return this._max } }, { key: "current", get: function () { return this._current } }, { key: "total", get: function () { return this.current.reduce((p, l) => p + l, 0) } }]); return y
          }(); a.InstanceCounter = u; Object.defineProperty(a, "__esModule",
            { value: !0 })
        })
    }, "esri/views/support/AllocationTracer": function () {
      define(["exports"], function (a) {
        let w = function () {
          function c(u) { this._allocations = new Map; u ? Error.stackTraceLimit = Infinity : (this.add = () => { }, this.remove = () => { }) } var q = c.prototype; q.add = function (u) { this._allocations.set(u, Error().stack) }; q.remove = function (u) { this._allocations.delete(u) }; q.print = function () {
            if (0 < this._allocations.size) {
              console.log(`${this._allocations.size} live object allocations:`); const u = new Map; this._allocations.forEach(y => { var n; u.set(y, (null != (n = u.get(y)) ? n : 0) + 1) }); u.forEach((y, n) => { n = n.split("\n"); n.shift(); n.shift(); console.log(`${y}: ${n.shift()}`); n.forEach(p => console.log("   ", p)) })
            }
          }; return c
        }(); a.AllocationTracer = w; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/WebGLDriverTest": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/maybe ./testDoublePrecisionArithmetic ./testFloatBufferBlend ./testSamplerPrecision ./testSVGPremultipliedAlpha".split(" "), function (a,
        w, c, q, u, y, n) {
          let p = function () {
            function l(h) { this.context = h; this._floatBufferBlendWorking = u.testFloatBufferBlend(h); n.testSVGPremultipliedAlpha(h).then(b => this._svgAlwaysPremultipliesAlpha = !b) } w._createClass(l, [{ key: "floatBufferBlendWorking", get: function () { if (c.isNone(this._floatBufferBlendWorking)) throw Error("floatBufferBlendWorking test not yet available"); return this._floatBufferBlendWorking } }, {
              key: "svgAlwaysPremultipliesAlpha", get: function () {
                if (c.isNone(this._svgAlwaysPremultipliesAlpha)) throw Error("svgAlwaysPremultipliesAlpha test not yet available");
                return this._svgAlwaysPremultipliesAlpha
              }
            }, { key: "doublePrecisionRequiresObfuscation", get: function () { if (c.isNone(this._doublePrecisionRequiresObfuscation)) { const h = q.testDoublePrecisionArithmetic(this.context, !1), b = q.testDoublePrecisionArithmetic(this.context, !0); this._doublePrecisionRequiresObfuscation = 0 !== h && (0 === b || 5 < h / b) } return this._doublePrecisionRequiresObfuscation } }, {
              key: "ignoresSamplerPrecision", get: function () {
                c.isNone(this._ignoresSamplerPrecision) && (this._ignoresSamplerPrecision = y.testSamplerPrecision(this.context));
                return this._ignoresSamplerPrecision
              }
            }]); return l
          }(); a.WebGLDriverTest = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/testDoublePrecisionArithmetic": function () {
      define("exports ../../core/floatRGBA ../../chunks/vec3f64 ./BufferObject ./doublePrecisionUtils ./FramebufferObject ./Program ./VertexArrayObject".split(" "), function (a, w, c, q, u, y, n, p) {
      a.testDoublePrecisionArithmetic = function (l, h) {
        var b = new y(l, { colorTarget: 0, depthStencilTarget: 0 }, {
          target: 3553, wrapMode: 33071, pixelFormat: 6408,
          dataType: 5121, samplingMode: 9728, width: 1, height: 1
        }); const d = q.createVertex(l, 35044, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), f = new p(l, new Map([["position", 0]]), { geometry: [{ name: "position", count: 2, type: 5123, offset: 0, stride: 4, normalized: !1 }] }, { geometry: d }), t = c.fromValues(5633261.287538229, 2626832.878767164, 1434988.0495278358), v = c.fromValues(5633271.46742708, 2626873.6381334523, 1434963.231608387); h = new n.Program(l, `\n\n  precision highp float;\n\n  attribute vec2 position;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  ${h ?
          "#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION" : ""}\n\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\n\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n  }\n\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n  }\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = dpPlusFrc(hiA, hiB);\n    vec3 e = dpMinusFrc(t1, hiA);\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n    return t1 + t2;\n  }\n\n  #else\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = hiA + hiB;\n    vec3 e = t1 - hiA;\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n    return t1 + t2;\n  }\n\n  #endif\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\n  }\n  `,
          "\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor \x3d v_color;\n  }\n  ", new Map([["position", 0]])); var m = new Float32Array(6); u.encodeDoubleArray(t, m, 3); var e = new Float32Array(6); u.encodeDoubleArray(v, e, 3); l.useProgram(h); h.setUniform3f("u_highA", m[0], m[2], m[4]); h.setUniform3f("u_lowA", m[1], m[3], m[5]); h.setUniform3f("u_highB", e[0], e[2], e[4]); h.setUniform3f("u_lowB", e[1], e[3], e[5]); m = h; e = l.getBoundFramebufferObject(); const { x: g, y: x, width: k, height: r } = l.getViewport();
        l.bindFramebuffer(b); l.setViewport(0, 0, 1, 1); l.bindVAO(f); l.drawArrays(5, 0, 4); h = new Uint8Array(4); b.readPixels(0, 0, 1, 1, 6408, 5121, h); m.dispose(); f.dispose(!1); d.dispose(); b.dispose(); l.setViewport(g, x, k, r); l.bindFramebuffer(e); l = (t[2] - v[2]) / 25; b = w.unpackFloatRGBA(h); return Math.abs(l - b)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/testFloatBufferBlend": function () {
      define("exports ../3d/webgl-engine/lib/OrderIndependentTransparency ./BufferObject ./FramebufferObject ./Program ./renderState ./VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n) {
          var p = { exports: {} }; (function (l) {
            (function (h) { h = h(); void 0 !== h && (l.exports = h) })(function () {
              function h(k) { if (null == g) { g = {}; x = {}; for (var r in k) "number" == typeof k[r] && (g[k[r]] = r, x[r] = k[r]) } } function b() { if (null == g) throw "WebGLDebugUtils.init(ctx) not called"; } function d(k) { b(); var r = g[k]; return void 0 !== r ? "gl." + r : "/*UNKNOWN WebGL ENUM*/ 0x" + k.toString(16) } function f(k, r, A, z) {
                k = e[k]; if (void 0 !== k && (k = k[r], void 0 !== k && k[A])) {
                  if ("object" === typeof k[A] && void 0 !== k[A].enumBitwiseOr) {
                    r =
                    k[A].enumBitwiseOr; A = 0; k = []; for (var B = 0; B < r.length; ++B) { var C = x[r[B]]; 0 !== (z & C) && (A |= C, k.push(d(C))) } return A === z ? k.join(" | ") : d(z)
                  } return d(z)
                } return null === z ? "null" : void 0 === z ? "undefined" : z.toString()
              } function t(k, r, A) { k.__defineGetter__(A, function () { return r[A] }); k.__defineSetter__(A, function (z) { r[A] = z }) } function v(k, r, A, z) {
                function B(J, M) { return function () { A && A(M, arguments); var F = J[M].apply(J, arguments), K = z.getError(); 0 != K && (C[K] = !0, r(K, M, arguments)); return F } } z = z || k; h(k); r = r || function (J, M, F) {
                  for (var K =
                    "", P = F.length, L = 0; L < P; ++L)K += (0 == L ? "" : ", ") + f(M, P, L, F[L]); J = "WebGL error " + d(J) + " in " + M + "(" + K + ")"; window.console && window.console.error ? window.console.error(J) : window.console && window.console.log && window.console.log(J)
                }; var C = {}, D = {}, E; for (E in k) if ("function" == typeof k[E]) if ("getExtension" != E) D[E] = B(k, E); else { var H = B(k, E); D[E] = function () { var J = H.apply(k, arguments); return v(J, r, A, z) } } else t(D, k, E); D.getError = function () { for (var J in C) if (C.hasOwnProperty(J) && C[J]) return C[J] = !1, J; return k.NO_ERROR };
                return D
              } function m(k) {
                var r = k.getParameter(k.MAX_VERTEX_ATTRIBS), A = k.createBuffer(); k.bindBuffer(k.ARRAY_BUFFER, A); for (var z = 0; z < r; ++z)k.disableVertexAttribArray(z), k.vertexAttribPointer(z, 4, k.FLOAT, !1, 0, 0), k.vertexAttrib1f(z, 0); k.deleteBuffer(A); r = k.getParameter(k.MAX_TEXTURE_IMAGE_UNITS); for (z = 0; z < r; ++z)k.activeTexture(k.TEXTURE0 + z), k.bindTexture(k.TEXTURE_CUBE_MAP, null), k.bindTexture(k.TEXTURE_2D, null); k.activeTexture(k.TEXTURE0); k.useProgram(null); k.bindBuffer(k.ARRAY_BUFFER, null); k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,
                  null); k.bindFramebuffer(k.FRAMEBUFFER, null); k.bindRenderbuffer(k.RENDERBUFFER, null); k.disable(k.BLEND); k.disable(k.CULL_FACE); k.disable(k.DEPTH_TEST); k.disable(k.DITHER); k.disable(k.SCISSOR_TEST); k.blendColor(0, 0, 0, 0); k.blendEquation(k.FUNC_ADD); k.blendFunc(k.ONE, k.ZERO); k.clearColor(0, 0, 0, 0); k.clearDepth(1); k.clearStencil(-1); k.colorMask(!0, !0, !0, !0); k.cullFace(k.BACK); k.depthFunc(k.LESS); k.depthMask(!0); k.depthRange(0, 1); k.frontFace(k.CCW); k.hint(k.GENERATE_MIPMAP_HINT, k.DONT_CARE); k.lineWidth(1);
                k.pixelStorei(k.PACK_ALIGNMENT, 4); k.pixelStorei(k.UNPACK_ALIGNMENT, 4); k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL, !1); k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1); k.UNPACK_COLORSPACE_CONVERSION_WEBGL && k.pixelStorei(k.UNPACK_COLORSPACE_CONVERSION_WEBGL, k.BROWSER_DEFAULT_WEBGL); k.polygonOffset(0, 0); k.sampleCoverage(1, !1); k.scissor(0, 0, k.canvas.width, k.canvas.height); k.stencilFunc(k.ALWAYS, 0, 4294967295); k.stencilMask(4294967295); k.stencilOp(k.KEEP, k.KEEP, k.KEEP); k.viewport(0, 0, k.canvas.width, k.canvas.height);
                for (k.clear(k.COLOR_BUFFER_BIT | k.DEPTH_BUFFER_BIT | k.STENCIL_BUFFER_BIT); k.getError(););
              } var e = {
                enable: { 1: { 0: !0 } }, disable: { 1: { 0: !0 } }, getParameter: { 1: { 0: !0 } }, drawArrays: { 3: { 0: !0 } }, drawElements: { 4: { 0: !0, 2: !0 } }, createShader: { 1: { 0: !0 } }, getShaderParameter: { 2: { 1: !0 } }, getProgramParameter: { 2: { 1: !0 } }, getShaderPrecisionFormat: { 2: { 0: !0, 1: !0 } }, getVertexAttrib: { 2: { 1: !0 } }, vertexAttribPointer: { 6: { 2: !0 } }, bindTexture: { 2: { 0: !0 } }, activeTexture: { 1: { 0: !0 } }, getTexParameter: { 2: { 0: !0, 1: !0 } }, texParameterf: { 3: { 0: !0, 1: !0 } },
                texParameteri: { 3: { 0: !0, 1: !0, 2: !0 } }, texImage2D: { 9: { 0: !0, 2: !0, 6: !0, 7: !0 }, 6: { 0: !0, 2: !0, 3: !0, 4: !0 } }, texSubImage2D: { 9: { 0: !0, 6: !0, 7: !0 }, 7: { 0: !0, 4: !0, 5: !0 } }, copyTexImage2D: { 8: { 0: !0, 2: !0 } }, copyTexSubImage2D: { 8: { 0: !0 } }, generateMipmap: { 1: { 0: !0 } }, compressedTexImage2D: { 7: { 0: !0, 2: !0 } }, compressedTexSubImage2D: { 8: { 0: !0, 6: !0 } }, bindBuffer: { 2: { 0: !0 } }, bufferData: { 3: { 0: !0, 2: !0 } }, bufferSubData: { 3: { 0: !0 } }, getBufferParameter: { 2: { 0: !0, 1: !0 } }, pixelStorei: { 2: { 0: !0, 1: !0 } }, readPixels: { 7: { 4: !0, 5: !0 } }, bindRenderbuffer: { 2: { 0: !0 } },
                bindFramebuffer: { 2: { 0: !0 } }, checkFramebufferStatus: { 1: { 0: !0 } }, framebufferRenderbuffer: { 4: { 0: !0, 1: !0, 2: !0 } }, framebufferTexture2D: { 5: { 0: !0, 1: !0, 2: !0 } }, getFramebufferAttachmentParameter: { 3: { 0: !0, 1: !0, 2: !0 } }, getRenderbufferParameter: { 2: { 0: !0, 1: !0 } }, renderbufferStorage: { 4: { 0: !0, 1: !0 } }, clear: { 1: { 0: { enumBitwiseOr: ["COLOR_BUFFER_BIT", "DEPTH_BUFFER_BIT", "STENCIL_BUFFER_BIT"] } } }, depthFunc: { 1: { 0: !0 } }, blendFunc: { 2: { 0: !0, 1: !0 } }, blendFuncSeparate: { 4: { 0: !0, 1: !0, 2: !0, 3: !0 } }, blendEquation: { 1: { 0: !0 } }, blendEquationSeparate: {
                  2: {
                    0: !0,
                    1: !0
                  }
                }, stencilFunc: { 3: { 0: !0 } }, stencilFuncSeparate: { 4: { 0: !0, 1: !0 } }, stencilMaskSeparate: { 2: { 0: !0 } }, stencilOp: { 3: { 0: !0, 1: !0, 2: !0 } }, stencilOpSeparate: { 4: { 0: !0, 1: !0, 2: !0, 3: !0 } }, cullFace: { 1: { 0: !0 } }, frontFace: { 1: { 0: !0 } }, drawArraysInstancedANGLE: { 4: { 0: !0 } }, drawElementsInstancedANGLE: { 5: { 0: !0, 2: !0 } }, blendEquationEXT: { 1: { 0: !0 } }
              }, g = null, x = null; return {
                init: h, mightBeEnum: function (k) { b(); return void 0 !== g[k] }, glEnumToString: d, glFunctionArgToString: f, glFunctionArgsToString: function (k, r) {
                  for (var A = "", z = r.length,
                    B = 0; B < z; ++B)A += (0 == B ? "" : ", ") + f(k, z, B, r[B]); return A
                }, makeDebugContext: v, makeLostContextSimulatingCanvas: function (k) {
                  function r(R) { return "function" == typeof R ? R : function (S) { R.handleEvent(S) } } function A() { for (var R = Object.keys(O), S = 0; S < R.length; ++S)delete O[R] } function z() { ++N; K || L == N && k.loseContext() } function B(R, S) { var Q = R[S]; return function () { z(); if (!K) return Q.apply(R, arguments) } } function C(R) { return { statusMessage: R, preventDefault: function () { G = !0 } } } function D(R) {
                    for (var S in R) "function" == typeof R[S] ?
                      M[S] = B(R, S) : t(M, R, S); M.getError = function () { z(); if (!K) for (var da; da = E.getError();)O[da] = !0; for (da in O) if (O[da]) return delete O[da], da; return M.NO_ERROR }; var Q = "createBuffer createFramebuffer createProgram createRenderbuffer createShader createTexture".split(" "); for (S = 0; S < Q.length; ++S) { var T = Q[S]; M[T] = function (da) { return function () { z(); if (K) return null; var Y = da.apply(R, arguments); Y.__webglDebugContextLostId__ = F; P.push(Y); return Y } }(R[T]) } Q = "getActiveAttrib getActiveUniform getBufferParameter getContextAttributes getAttachedShaders getFramebufferAttachmentParameter getParameter getProgramParameter getProgramInfoLog getRenderbufferParameter getShaderParameter getShaderInfoLog getShaderSource getTexParameter getUniform getUniformLocation getVertexAttrib".split(" ");
                    for (S = 0; S < Q.length; ++S)T = Q[S], M[T] = function (da) { return function () { z(); return K ? null : da.apply(R, arguments) } }(M[T]); Q = "isBuffer isEnabled isFramebuffer isProgram isRenderbuffer isShader isTexture".split(" "); for (S = 0; S < Q.length; ++S)T = Q[S], M[T] = function (da) { return function () { z(); return K ? !1 : da.apply(R, arguments) } }(M[T]); M.checkFramebufferStatus = function (da) { return function () { z(); return K ? M.FRAMEBUFFER_UNSUPPORTED : da.apply(R, arguments) } }(M.checkFramebufferStatus); M.getAttribLocation = function (da) {
                      return function () {
                        z();
                        return K ? -1 : da.apply(R, arguments)
                      }
                    }(M.getAttribLocation); M.getVertexAttribOffset = function (da) { return function () { z(); return K ? 0 : da.apply(R, arguments) } }(M.getVertexAttribOffset); M.isContextLost = function () { return K }; return M
                  } var E, H = [], J = []; var M = {}; var F = 1, K = !1, P = [], L = 0, N = 0, G = !1, I = 0, O = {}; k.getContext = function (R) { return function () { var S = R.apply(k, arguments); if (S instanceof WebGLRenderingContext) { if (S != E) { if (E) throw "got different context"; E = S; M = D(E) } return M } return S } }(k.getContext); (function (R) {
                    var S =
                      R.addEventListener; R.addEventListener = function (Q, T, da) { switch (Q) { case "webglcontextlost": H.push(r(T)); break; case "webglcontextrestored": J.push(r(T)); break; default: S.apply(R, arguments) } }
                  })(k); k.loseContext = function () { if (!K) { K = !0; L = 0; for (++F; E.getError();); A(); O[E.CONTEXT_LOST_WEBGL] = !0; var R = C("context lost"), S = H.slice(); setTimeout(function () { for (var Q = 0; Q < S.length; ++Q)S[Q](R); 0 <= I && setTimeout(function () { k.restoreContext() }, I) }, 0) } }; k.restoreContext = function () {
                  K && J.length && setTimeout(function () {
                    if (!G) throw "can not restore. webglcontestlost listener did not call event.preventDefault";
                    for (var R = 0; R < P.length; ++R) { var S = P[R]; S instanceof WebGLBuffer ? E.deleteBuffer(S) : S instanceof WebGLFramebuffer ? E.deleteFramebuffer(S) : S instanceof WebGLProgram ? E.deleteProgram(S) : S instanceof WebGLRenderbuffer ? E.deleteRenderbuffer(S) : S instanceof WebGLShader ? E.deleteShader(S) : S instanceof WebGLTexture && E.deleteTexture(S) } m(E); K = !1; N = 0; G = !1; R = J.slice(); S = C("context restored"); for (var Q = 0; Q < R.length; ++Q)R[Q](S)
                  }, 0)
                  }; k.loseContextInNCalls = function (R) {
                    if (K) throw "You can not ask a lost contet to be lost";
                    L = N + R
                  }; k.getNumCalls = function () { return N }; k.setRestoreTimeout = function (R) { I = R }; return k
                }, resetToInitialState: m
              }
            })
          })(p); a.testFloatBufferBlend = function (l) {
            var h, b, d; if (!l.gl) return !1; if ("webgl" === l.webglVersion) { var f, t; return (null == (f = l.capabilities.textureFloat) ? void 0 : f.textureFloat) && (null == (t = l.capabilities.colorBufferFloat) ? void 0 : t.textureFloat) } if (!((null == (h = l.capabilities.textureFloat) ? 0 : h.textureFloat) && (null == (b = l.capabilities.colorBufferFloat) ? 0 : b.textureFloat) && (null == (d = l.capabilities.colorBufferFloat) ?
              0 : d.floatBlend))) return !1; h = new q(l, { colorTarget: 0, depthStencilTarget: 0 }, { target: 3553, wrapMode: 33071, pixelFormat: 6408, dataType: 5126, internalFormat: 34836, samplingMode: 9728, width: 1, height: 1 }); b = c.createVertex(l, 35044, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])); d = new n(l, new Map([["a_pos", 0]]), { geometry: [{ name: "a_pos", count: 2, type: 5123, offset: 0, stride: 4, normalized: !1 }] }, { geometry: b }); f = new u.Program(l, "\n  precision highp float;\n  attribute vec2 a_pos;\n\n  void main() {\n    gl_Position \x3d vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ",
                "\n   precision highp float;\n\n   void main() {\n    gl_FragColor \x3d vec4(0.5, 0.5, 0.5, 0.5);\n   }\n  ", new Map([["a_pos", 0]])); l.useProgram(f); t = l.getBoundFramebufferObject(); const { x: v, y: m, width: e, height: g } = l.getViewport(); l.bindFramebuffer(h); l.setViewport(0, 0, 1, 1); l.bindVAO(d); l.drawArrays(5, 0, 4); var x = y.makePipelineState({ blending: w.blendingAlpha }); l.setPipelineState(x); l.drawArrays(5, 0, 4); p.exports.init(l); x = l.gl.getError(); l.setViewport(v, m, e, g); l.bindFramebuffer(t); f.dispose(); d.dispose(!1);
            b.dispose(); h.dispose(); return 1282 === x ? (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), !1) : !0
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/testSamplerPrecision": function () {
      define("exports ../../core/Logger ./BufferObject ./FramebufferObject ./Program ../../chunks/_rollupPluginBabelHelpers ./enums ./Texture ./VertexArrayObject".split(" "), function (a, w, c, q, u, y, n, p, l) {
        const h = w.getLogger("esri.views.WebGLDriverTest");
        a.testSamplerPrecision = b => {
          var d = new q(b, { colorTarget: 0, depthStencilTarget: 0 }, { target: 3553, wrapMode: 33071, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: 1, height: 1 }); const f = new Uint8Array(4), t = c.createVertex(b, 35044, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), v = new l(b, new Map([["a_position", 0]]), { geometry: [{ name: "a_position", count: 2, type: 5122, offset: 0, stride: 4, normalized: !1 }] }, { geometry: t }), m = new u.Program(b, "\nprecision highp float;\nattribute vec2 a_pos;\nuniform highp sampler2D u_texture;\nvarying vec4 v_color;\n\nfloat getBit(in float bitset, in int bitIndex) {\n  float offset \x3d pow(2.0, float(bitIndex));\n  return mod(floor(bitset / offset), 2.0);\n}\n\nvoid main() {\n  vec4 value \x3d texture2D(u_texture, vec2(0.0));\n  float bit \x3d getBit(value.x * 255.0, 1);\n\n  v_color \x3d bit * vec4(1.0);\n  gl_Position \x3d vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n}\n",
            "\nprecision highp float;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor \x3d v_color;\n}\n", new Map([["a_pos", 0]])); var e = new p(b, { target: 3553, wrapMode: 33071, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: 1, height: 1 }, new Uint8Array([2, 255, 0, 0])); m.setUniform1i("u_texture", 0); b.bindTexture(e, 0); e = b.getBoundFramebufferObject(); b.bindFramebuffer(d); b.useProgram(m); const { x: g, y: x, width: k, height: r } = b.getViewport(); b.setViewport(0, 0, 1, 1); b.bindVAO(v); b.drawArrays(5, 0, 4); b.setViewport(g,
              x, k, r); d.readPixels(0, 0, 1, 1, 6408, 5121, f); m.dispose(); v.dispose(!1); t.dispose(); d.dispose(); (d = 255 !== f[0] || 255 !== f[1] || 255 !== f[2] || 255 !== f[3]) && h.warn(`A problem was detected with your graphics driver. Your driver does not appear to honor sampler precision specifiers, which may result in rendering issues due to numerical instability. We recommend ensuring that your drivers have been updated to the latest version. Applying lowp sampler workaround. [${f[0]}.${f[1]}.${f[2]}.${f[3]}]`); b.bindFramebuffer(e);
          return d
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/testSVGPremultipliedAlpha": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ./BufferObject ./FramebufferObject ./Program ./Texture ./VertexArrayObject".split(" "), function (a, w, c, q, u, y, n) {
        function p() {
          p = w._asyncToGenerator(function* (l) {
            const h = new Image; h.src = "data:image/svg+xml,%3C%3Fxml version\x3d'1.0' encoding\x3d'UTF-8'%3F%3E%3Csvg width\x3d'5' height\x3d'5' version\x3d'1.1' viewBox\x3d'0 0 5 5' xmlns\x3d'http://www.w3.org/2000/svg'%3E%3Crect width\x3d'5' height\x3d'5' fill\x3d'%23f00' fill-opacity\x3d'.5'/%3E%3C/svg%3E%0A";
            h.width = 5; h.height = 5; yield h.decode(); if (!l.gl) return !0; const b = new q(l, { colorTarget: 0, depthStencilTarget: 0 }, { target: 3553, wrapMode: 33071, pixelFormat: 6408, dataType: 5121, samplingMode: 9728, width: 1, height: 1 }), d = c.createVertex(l, 35044, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), f = new n(l, new Map([["a_pos", 0]]), { geometry: [{ name: "a_pos", count: 2, type: 5123, offset: 0, stride: 4, normalized: !1 }] }, { geometry: d }), t = new u.Program(l, "\n  precision highp float;\n\n  attribute vec2 a_pos;\n  varying vec2 v_uv;\n\n  void main() {\n    v_uv \x3d a_pos;\n    gl_Position \x3d vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ",
              "\n  precision highp float;\n\n  varying vec2 v_uv;\n  uniform sampler2D u_texture;\n\n  void main() {\n    gl_FragColor \x3d texture2D(u_texture, v_uv);\n  }\n  ", new Map([["a_pos", 0]])); l.useProgram(t); const v = new y(l, { dataType: 5121, pixelFormat: 6408, preMultiplyAlpha: !1, wrapMode: 33071, samplingMode: 9729 }, h); l.bindTexture(v, 0); t.setUniform1i("u_texture", 0); const m = l.getBoundFramebufferObject(), { x: e, y: g, width: x, height: k } = l.getViewport(); l.bindFramebuffer(b); l.setViewport(0, 0, 1, 1); l.setClearColor(0,
                0, 0, 0); l.setBlendingEnabled(!1); l.clearSafe(16384); l.bindVAO(f); l.drawArrays(5, 0, 4); const r = new Uint8Array(4); b.readPixels(0, 0, 1, 1, 6408, 5121, r); t.dispose(); f.dispose(!1); d.dispose(); b.dispose(); v.dispose(); l.setViewport(e, g, x, k); l.bindFramebuffer(m); h.src = ""; return 255 === r[0]
          }); return p.apply(this, arguments)
        } a.testSVGPremultipliedAlpha = function (l) { return p.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/capabilities/load": function () {
      define("exports ./DisjointTimerQuery ./DrawBuffers ./Instancing ./isWebGL2Context ./LoseContext ./VertexArrayObjects".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(l, h, b, d, f) { if (d && u(l)) return !0; if (h[b]) return !1; for (const t of f) if (l.getExtension(t)) return !0; return !1 } a.loadCapabilities = function (l, h) {
            const b = h.disabledExtensions || {}, d = h.debugWebGLExtensions || {}; let f, t, v, m, e, g, x, k, r, A, z, B, C = null, D = null, E = null, H = null; return {
              get drawBuffers() { z || (z = c.load(l, b)); return z }, get instancing() { f || (f = q.load(l)); return f }, get vao() { t || (t = n.load(l, b)); return t }, get compressedTextureETC() {
                if (!v) if (b.compressedTextureETC) v = null; else {
                  var J =
                    l.getExtension("WEBGL_compressed_texture_etc"); v = J ? {
                      COMPRESSED_R11_EAC: J.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: J.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: J.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: J.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: J.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: J.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: J.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: J.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                      COMPRESSED_RGBA8_ETC2_EAC: J.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: J.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                    } : null
                } return v
              }, get compressedTextureS3TC() {
                if (!m) if (b.compressedTextureS3TC) m = null; else {
                  var J = l.getExtension("WEBGL_compressed_texture_s3tc"); m = J ? { COMPRESSED_RGB_S3TC_DXT1: J.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: J.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: J.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: J.COMPRESSED_RGBA_S3TC_DXT5_EXT } :
                    null
                } return m
              }, get textureFilterAnisotropic() { if (!e) if (b.textureFilterAnisotropic) e = null; else { var J = l.getExtension("EXT_texture_filter_anisotropic") || l.getExtension("MOZ_EXT_texture_filter_anisotropic") || l.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); e = J ? { MAX_TEXTURE_MAX_ANISOTROPY: J.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: J.TEXTURE_MAX_ANISOTROPY_EXT } : null } return e }, get disjointTimerQuery() { g || (g = w.createDisjointTimerQuery(l, b)); return g }, get textureFloat() {
                if (!x) if (u(l)) x =
                  { textureFloat: !0, textureFloatLinear: !b.textureFloatLinear && !!l.getExtension("OES_texture_float_linear"), textureHalfFloat: !0, textureHalfFloatLinear: !b.textureHalfFloatLinear && !!l.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: l.HALF_FLOAT }; else if (l instanceof WebGLRenderingContext) {
                    const J = !b.textureHalfFloat && l.getExtension("OES_texture_half_float"); x = {
                      textureFloat: !b.textureFloat && !!l.getExtension("OES_texture_float"), textureFloatLinear: !b.textureFloatLinear && !!l.getExtension("OES_texture_float_linear"),
                      textureHalfFloat: !!J, textureHalfFloatLinear: !b.textureHalfFloatLinear && !!l.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: J ? J.HALF_FLOAT_OES : void 0
                    }
                  } else x = null; return x
              }, get colorBufferFloat() {
                if (!k) if (u(l)) {
                  var J = !b.colorBufferFloat && l.getExtension("EXT_color_buffer_half_float"), M = !b.colorBufferFloat && l.getExtension("EXT_color_buffer_float"), F = !b.colorBufferFloat && l.getExtension("EXT_float_blend"); k = J || M || F ? {
                    textureFloat: !!M, textureHalfFloat: !!J, floatBlend: !!F, R16F: l.R16F, RG16F: l.RG16F,
                    RGBA16F: l.RGBA16F, R32F: l.R32F, RG32F: l.RG32F, RGBA32F: l.RGBA32F, R11F_G11F_B10F: l.R11F_G11F_B10F, RGB16F: l.RGB16F
                  } : null
                } else l instanceof WebGLRenderingContext ? (J = !b.colorBufferFloat && l.getExtension("EXT_color_buffer_half_float"), M = !b.colorBufferFloat && l.getExtension("WEBGL_color_buffer_float"), F = !b.colorBufferFloat && l.getExtension("EXT_float_blend"), k = J || M || F ? { textureFloat: !!M, textureHalfFloat: !!J, floatBlend: !!F, RGBA16F: J ? J.RGBA16F_EXT : void 0, RGB16F: J ? J.RGB16F_EXT : void 0, RGBA32F: M ? M.RGBA32F_EXT : void 0 } :
                  null) : k = null; return k
              }, get blendMinMax() { if (!r) if (u(l)) r = { MIN: l.MIN, MAX: l.MAX }; else if (b.blendMinMax) r = null; else { { const J = l.getExtension("EXT_blend_minmax"); r = J ? { MIN: J.MIN_EXT, MAX: J.MAX_EXT } : null } } return r }, get depthTexture() { null === C && (C = p(l, b, "depthTexture", !0, ["WEBGL_depth_texture", "MOZ_WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"])); return C }, get standardDerivatives() { null === D && (D = p(l, b, "standardDerivatives", !0, ["OES_standard_derivatives"])); return D }, get shaderTextureLOD() {
              null === E && (E =
                p(l, b, "shaderTextureLOD", !0, ["EXT_shader_texture_lod"])); return E
              }, get fragDepth() { null === H && (H = p(l, b, "fragDepth", !0, ["EXT_frag_depth"])); return H }, get loseContext() { A || (A = y.load(l, d)); return A }, get textureNorm16() { if (!B) if (!u(l) || b.textureNorm16) B = null; else { var J = l.getExtension("EXT_texture_norm16"); B = J ? { R16: J.R16, RG16: J.RG16, RGB16: J.RGB16, RGBA16: J.RGBA16, R16_SNORM: J.R16_SNORM, RG16_SNORM: J.RG16_SNORM, RGB16_SNORM: J.RGB16_SNORM, RGBA16_SNORM: J.RGBA16_SNORM } : null } return B }, enable(J) { return this[J] }
            }
          };
          Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/webgl/capabilities/DisjointTimerQuery": function () {
      define(["exports", "./isWebGL2Context"], function (a, w) {
        let c = function (q, u, y, n, p, l, h, b) { this.createQuery = q; this.resultAvailable = u; this.getResult = y; this.disjoint = n; this.beginTimeElapsed = p; this.endTimeElapsed = l; this.createTimestamp = h; this.timestampBits = b }; a.DisjointTimerQuery = c; a.createDisjointTimerQuery = function (q, u) {
          if (u.disjointTimerQuery) return null; let y = q.getExtension("EXT_disjoint_timer_query_webgl2");
          return y && w(q) ? new c(() => q.createQuery(), n => q.getQueryParameter(n, q.QUERY_RESULT_AVAILABLE), n => q.getQueryParameter(n, q.QUERY_RESULT), () => q.getParameter(y.GPU_DISJOINT_EXT), n => q.beginQuery(y.TIME_ELAPSED_EXT, n), () => q.endQuery(y.TIME_ELAPSED_EXT), n => y.queryCounterEXT(n, y.TIMESTAMP_EXT), () => q.getQuery(y.TIMESTAMP_EXT, y.QUERY_COUNTER_BITS_EXT)) : (y = q.getExtension("EXT_disjoint_timer_query")) ? new c(() => y.createQueryEXT(), n => y.getQueryObjectEXT(n, y.QUERY_RESULT_AVAILABLE_EXT), n => y.getQueryObjectEXT(n, y.QUERY_RESULT_EXT),
            () => q.getParameter(y.GPU_DISJOINT_EXT), n => y.beginQueryEXT(y.TIME_ELAPSED_EXT, n), () => y.endQueryEXT(y.TIME_ELAPSED_EXT), n => y.queryCounterEXT(n, y.TIMESTAMP_EXT), () => y.getQueryEXT(y.TIMESTAMP_EXT, y.QUERY_COUNTER_BITS_EXT)) : null
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/capabilities/DrawBuffers": function () {
      define(["exports", "./isWebGL2Context"], function (a, w) {
      a.load = function (c, q) {
        return q.disjointTimerQuery ? null : w(c) ? {
          drawBuffers: c.drawBuffers.bind(c), MAX_DRAW_BUFFERS: c.MAX_DRAW_BUFFERS,
          MAX_COLOR_ATTACHMENTS: c.MAX_COLOR_ATTACHMENTS
        } : q.drawBuffers ? null : (c = c.getExtension("WEBGL_draw_buffers")) ? { drawBuffers: c.drawBuffersWEBGL.bind(c), MAX_DRAW_BUFFERS: c.MAX_DRAW_BUFFERS_WEBGL, MAX_COLOR_ATTACHMENTS: c.MAX_COLOR_ATTACHMENTS_WEBGL } : null
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/capabilities/Instancing": function () {
      define(["exports", "./isWebGL2Context"], function (a, w) {
      a.load = function (c) {
        return w(c) ? {
          drawArraysInstanced: c.drawArraysInstanced.bind(c), drawElementsInstanced: c.drawElementsInstanced.bind(c),
          vertexAttribDivisor: c.vertexAttribDivisor.bind(c)
        } : (c = c.getExtension("ANGLE_instanced_arrays")) ? { drawArraysInstanced: c.drawArraysInstancedANGLE.bind(c), drawElementsInstanced: c.drawElementsInstancedANGLE.bind(c), vertexAttribDivisor: c.vertexAttribDivisorANGLE.bind(c) } : null
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/capabilities/LoseContext": function () {
      define(["exports"], function (a) {
      a.load = function (w, c) {
        const q = c.loseContext && w.getExtension("WEBGL_lose_context"); return q ?
          { loseRenderingContext: () => q.loseContext() } : null
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/capabilities/VertexArrayObjects": function () {
      define(["exports", "./isWebGL2Context"], function (a, w) {
      a.load = function (c, q) {
        return w(c) ? { createVertexArray: c.createVertexArray.bind(c), deleteVertexArray: c.deleteVertexArray.bind(c), bindVertexArray: c.bindVertexArray.bind(c) } : q.vao ? null : (c = c.getExtension("OES_vertex_array_object") || c.getExtension("MOZ_OES_vertex_array_object") || c.getExtension("WEBKIT_OES_vertex_array_object")) ?
          { createVertexArray: c.createVertexArrayOES.bind(c), deleteVertexArray: c.deleteVertexArrayOES.bind(c), bindVertexArray: c.bindVertexArrayOES.bind(c) } : null
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/TextureRepository": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ./TextureTechnique ./Util ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = y.getLogger("esri.views.3d.webgl-engine.lib.TextureRepository"); a.TextureRepository = function (x) {
            function k(A, z, B) { var C = x.call(this, {}) || this; C._stage = A; C._techniqueRepository = z; C._rctx = B; C._idToRefCountedTexture = new Map; C._loadingCount = 0; C._frameUpdates = new Map; C.events = new u; C._frameTask = A.resourceController.scheduler.registerTask(m.TaskPriority.TEXTURE_UNLOAD); return C } w._inheritsLoose(k, x); var r = k.prototype; r.normalizeCtorArgs = function () { return {} };
            r.dispose = function () { this._frameTask.remove(); this._stage.forEachOfType(4, A => A.unload()) }; r.acquire = function (A) { const z = this._idToRefCountedTexture.get(A); return z ? (z.ref(), Promise.resolve(z)) : this._createNewRef(A) }; r.update = function () { let A = !1; this._frameUpdates.forEach(z => { const B = z.texture.frameUpdate(this._rctx, this.textureTechnique, z.previousToken); 0 <= B && B !== z.previousToken && (z.previousToken = B, A = !0) }); A && this.events.emit("changed", 0) }; r._createNewRef = function () {
              var A = w._asyncToGenerator(function* (z) {
                const B =
                  this._stage.getObject(z); if (n.isNone(B)) return v.assert(void 0 !== B), null; const C = B.events.on("unloaded", () => { C.remove(); this._onTextureUnloaded(z) }), D = new g(z, () => { this._frameTask.schedule(() => { D.isUnreferenced && B.unload() }) }); this._idToRefCountedTexture.set(z, D); D.ref(); n.isSome(B.glTexture) ? (this._updateGLTexture(D, B.glTexture), B.requiresFrameUpdates && this._frameUpdates.set(z, { texture: B, previousToken: -1 })) : (this._loadingCount++ , yield this._stage.schedule(() => {
                    const E = B.load(this._rctx, () => this.textureTechnique),
                    H = M => { this._loadingCount--; this._updateGLTexture(D, M); B.requiresFrameUpdates && this._frameUpdates.set(z, { texture: B, previousToken: -1 }); return D }, J = M => { this._loadingCount--; p.isAbortError(M) || e.error(M) }; return p.isPromiseLike(E) ? E.then(H, J) : H(E)
                  })); return D
              }); return function (z) { return A.apply(this, arguments) }
            }(); r._updateGLTexture = function (A, z) { A.glTexture = z; this.events.emit("changed", 1) }; r._onTextureUnloaded = function (A) { this._idToRefCountedTexture.delete(A); this._frameUpdates.delete(A) }; w._createClass(k,
              [{ key: "updating", get: function () { return 0 < this._loadingCount || this._frameTask.updating } }, { key: "textureTechnique", get: function () { n.isNone(this._textureTechnique) && (this._textureTechnique = this._techniqueRepository.acquire(t.TextureTechnique, new t.TextureTechniqueConfiguration)); return this._textureTechnique } }]); return k
          }(q); c.__decorate([l.property()], a.TextureRepository.prototype, "_loadingCount", void 0); c.__decorate([l.property()], a.TextureRepository.prototype, "_frameTask", void 0); c.__decorate([l.property()],
            a.TextureRepository.prototype, "updating", null); a.TextureRepository = c.__decorate([f.subclass("esri.views.3d.webgl-engine.lib.TextureRepository")], a.TextureRepository); let g = function () {
              function x(r, A) { this.id = r; this._release = A; this._refCount = 0 } var k = x.prototype; k.ref = function () { ++this._refCount }; k.release = function () { --this._refCount; 0 < this._refCount || (0 === this._refCount ? this._release() : (e.error("Cannot dereference texture that has no references!"), this._refCount = 0)) }; w._createClass(x, [{
                key: "isUnreferenced",
                get: function () { return 0 === this._refCount }
              }]); return x
            }(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/materials/internal/WaterTextureRepository": function () {
      define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../chunks/tslib.es6 ../../../../../assets ../../../../../core/Accessor ../../../../../core/Logger ../../../../../core/accessorSupport/decorators/property ../../../../../core/arrayUtils ../../../../../core/has ../../../../../core/accessorSupport/ensureType ../../../../../core/accessorSupport/decorators/subclass ../../../../../support/requestImageUtils ../../../../webgl/Texture".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          const t = y.getLogger("esri.views.3d.webgl-engine.materials.internal.waterMaterialUtils"); a.WaterTextureRepository = function (v) {
            function m() { var g = v.apply(this, arguments) || this; g._data = []; g.loadingState = 0; return g } w._inheritsLoose(m, v); var e = m.prototype; e.dispose = function () { this.loadingState = 0; this._data.forEach(g => g.dispose()); this._data.length = 0 }; e.loadTextures = function (g) {
              const x = [q.getAssetUrl("esri/images/materials/water/normals.jpg"), q.getAssetUrl("esri/images/materials/water/perturbation.jpg")];
              this.loadingState = 1; Promise.all(x.map(k => d.requestImage(k))).then(k => { k.forEach(r => this._data.push(new f(g, { target: 3553, pixelFormat: 6408, dataType: 5121, wrapMode: 10497, samplingMode: 9987, hasMipmap: !0, maxAnisotropy: 8, width: r.width, height: r.height }, r))); this.loadingState = 2 }).catch(k => { t.error("Failed to load textures for water material.", k); this.loadingState = 0 })
            }; e.bind = function (g) { this.ready && (g.bindTexture(this._data[0], "texWaveNormal"), g.bindTexture(this._data[1], "texWavePerturbation")) }; w._createClass(m,
              [{ key: "updating", get: function () { return 1 === this.loadingState } }, { key: "ready", get: function () { return 2 === this.loadingState } }]); return m
          }(u); c.__decorate([n.property()], a.WaterTextureRepository.prototype, "loadingState", void 0); c.__decorate([n.property({ type: Boolean, readOnly: !0 })], a.WaterTextureRepository.prototype, "updating", null); a.WaterTextureRepository = c.__decorate([b.subclass("esri.views.3d.webgl-engine.materials.internal.WaterTextureRepository")], a.WaterTextureRepository); Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/parts/ScreenshotManager": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/promiseUtils ../../../../chunks/vec4f64 ../lib/AutoDisposable ../../../support/screenshotUtils ../../../webgl/FramebufferObject".split(" "), function (a, w, c, q, u, y, n, p) {
        y = function (l) {
          function h(d, f, t, v = null, m, e = !0) {
            var g = l.call(this) || this; g._rctx = d; g._renderScene = f; g._requestRenderScene = t; g._renderOverlay = v; g.forceCameraHook =
              m; g.supersample = e; g._screenshotQueue = []; return g
          } w._inheritsLoose(h, l); var b = h.prototype; b.dispose = function () { this._rctx = null }; b.takeScreenshot = function (d) { this._requestRenderScene(0); const f = q.createResolver(); this._screenshotQueue.push({ settings: d, resolver: f }); return f.promise }; b.update = function (d) {
            for (const t of this._screenshotQueue) {
              if (this.isDisposed) { t.resolver.reject(); continue } var f = { ...t.settings, pixelRatio: t.settings.pixelRatio * d.viewCamera.pixelRatio }; const v = this._ensureScreenshotEncodeCanvas(),
                m = this._renderScreenshot(d, f); f = n.encodeResult(m, f, v, { flipY: !0, premultipliedAlpha: !0 }); t.resolver(f)
            } this._screenshotQueue.length = 0
          }; b._renderScreenshotOverlay = function (d, f, t) { if (c.isNone(this._renderOverlay)) return f; d.width = f.width; d.height = f.height; const v = d.getContext("2d"), m = t.pixelRatio; v.save(); v.translate(0, f.height); v.scale(1, -1); t.region && v.translate(-t.region.x, -t.region.y); v.scale(m, m); f = this._renderOverlay(d, f); v.restore(); return f }; b._readbackScreenshot = function (d) {
            return d.resample ?
              this._readbackScreenshotResampled(d) : this._readbackScreenshotImmediate(d)
          }; b._readbackScreenshotResampled = function (d) {
            const { framebufferWidth: f, framebufferHeight: t, region: v, resample: m } = d, e = this._ensureScreenshotEncodeCanvas(); let g = n.createEmptyImageData(f, t, e); this._rctx.gl.readPixels(0, 0, f, t, 6408, 5121, new Uint8Array(g.data.buffer)); g = this._renderScreenshotOverlay(e, g, { ...d, region: null }); d = n.createEmptyImageData(v.width, v.height, e); return n.resampleHermite(g, d, !0, m.region.x, t - (m.region.y + m.region.height),
              m.region.width, m.region.height)
          }; b._readbackScreenshotImmediate = function (d) { const { framebufferHeight: f, region: t } = d, v = this._ensureScreenshotEncodeCanvas(), m = n.createEmptyImageData(t.width, t.height, v); this._rctx.gl.readPixels(t.x, f - (t.y + t.height), t.width, t.height, 6408, 5121, new Uint8Array(m.data.buffer)); return this._renderScreenshotOverlay(v, m, d) }; b._renderScreenshot = function (d, f) {
            var t = null; const v = d.viewCamera, { framebufferWidth: m, framebufferHeight: e } = f; var g = !1; d = f.disableDecorations && d.frameHasDecorations;
            var x = f.ignorePadding && v.pixelRatio !== f.pixelRatio; if (d = m !== v.fullWidth || e !== v.fullHeight || d || x) {
              x = v.clone(); if (f.ignorePadding) { t = u.clone(x.padding); for (g = 0; 4 > g; g++)t[g] = Math.round(t[g] / x.pixelRatio * f.pixelRatio); x.padding = t } x.fullWidth = m; x.fullHeight = e; x.pixelRatio = f.pixelRatio; t = v.fovX - x.fovX; g = v.fovY - x.fovY; 0 > t && t < g ? x.fovX = v.fovX : 0 > g && g < t && (x.fovY = v.fovY); this.forceCameraHook(x); g = !0; t = new p(this._rctx, { width: x.fullWidth, height: x.fullHeight, colorTarget: 0, depthStencilTarget: 3 }); this._renderScene(t,
                x, f.disableDecorations ? 0 : 1); !0 === f.renderScreenshotTwice && this._renderScene(t, x, f.disableDecorations ? 0 : 1)
            } f = this._readbackScreenshot(f); if (d && !this._rctx.contextAttributes.alpha) for (d = 3; d < f.data.length; d += 4)f.data[d] = 255; t && t.dispose(); this._rctx.bindFramebuffer(null); g && this.forceCameraHook(v); return f
          }; b._ensureScreenshotEncodeCanvas = function () { this._screenshotEncodeCanvas || (this._screenshotEncodeCanvas = document.createElement("canvas")); return this._screenshotEncodeCanvas }; return h
        }(y.AutoDisposable);
        a.ScreenshotManager = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/context-util": function () {
      define(["exports", "../../core/maybe"], function (a, w) {
        function c(u, y, n = {}) { y = 1 === y ? ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"] : ["webgl2"]; let p = null; for (const l of y) { try { p = u.getContext(l, n) } catch (h) { } if (p) break } return p } function q(u, y) {
        (u = u.parentNode) && (u.innerHTML = '\x3ctable style\x3d"background-color: #8CE; width: 100%; height: 100%;"\x3e\x3ctr\x3e\x3ctd align\x3d"center"\x3e\x3cdiv style\x3d"display: table-cell; vertical-align: middle;"\x3e\x3cdiv style\x3d""\x3e' +
          y + "\x3c/div\x3e\x3c/div\x3e\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e")
        } a.createContext = c; a.createContextOrErrorHTML = function (u, y, n = {}) {
          if (!window.WebGLRenderingContext) return q(u, 'This page requires a browser that supports WebGL.\x3cbr/\x3e\x3ca href\x3d"http://get.webgl.org"\x3eClick here to upgrade your browser.\x3c/a\x3e'), null; y = c(u, y, n); w.isNone(y) && q(u, 'It doesn\'t appear your computer can support WebGL.\x3cbr/\x3e\x3ca href\x3d"http://get.webgl.org/troubleshooting/"\x3eClick here for more information.\x3c/a\x3e');
          return y
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/lib/intersectorUtilsConversions": function () {
      define("exports ../../../../core/maybe ../../layers/i3s/Intersector ../../terrain/Intersector ./intersectorUtils ./lodRendering/Intersector".split(" "), function (a, w, c, q, u, y) {
        function n(h, b) {
          if (w.isNone(h) || w.isNone(h.graphicUid)) return null; const d = l(h, b); return w.isNone(d) ? null : d === b.graphics ? w.isSome(b.graphicsView) ? b.graphicsView.getGraphicFromGraphicUid(h.graphicUid) :
            null : (b = b.allLayerViews.find(f => f.layer === d)) && !b.suspended && "getGraphicFromGraphicUid" in b && w.isSome(h.graphicUid) ? b.getGraphicFromGraphicUid(h.graphicUid) : null
        } function p(h, b) { const d = l(h, b); return w.isNone(d) ? null : (b = b.allLayerViews.find(f => f.layer === d)) && !b.suspended && "getGraphicFromIntersectorTarget" in b ? b.getGraphicFromIntersectorTarget(h) : null } function l(h, b) { return w.isNone(h.layerUid) ? null : w.isSome(b.graphicsView) && h.layerUid === b.graphicsView.graphics3d.layer.id ? b.graphics : b.map.findLayerByUid(h.layerUid) }
        a.toGraphic = function (h, b) { return u.isObjectIntersectorResult(h) || u.isHudIntersectorResult(h) ? n(h.target.object.metadata, b) : c.isPclIntersectorResult(h) ? h.target.createGraphic() : q.isOverlayIntersectorResult(h) || y.isLodIntersectorResult(h) ? n(h.target, b) : c.isI3sIntersectorResult(h) ? p(h.target, b) : null }; a.toOwner = function (h, b) {
          if (u.isObjectIntersectorResult(h) || u.isHudIntersectorResult(h)) return l(h.target.object.metadata, b); if (q.isTerrainIntersectorResult(h)) { var d; return null == (d = b.map) ? void 0 : d.ground } return c.isPclIntersectorResult(h) ||
            c.isI3sIntersectorResult(h) || q.isOverlayIntersectorResult(h) ? l(h.target, b) : null
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/Intersector": function () {
      define(["exports", "../../webgl-engine/lib/intersectorUtils"], function (a, w) {
      a.isI3sIntersectorResult = function (c) { return w.isValidIntersectorResult(c) && 4 === c.intersector && !!c.target }; a.isPclIntersectorResult = function (c) { return w.isValidIntersectorResult(c) && 5 === c.intersector && !!c.target }; Object.defineProperty(a, "__esModule",
        { value: !0 })
      })
    }, "esri/views/3d/terrain/Intersector": function () { define(["exports", "../webgl-engine/lib/intersectorUtils"], function (a, w) { a.isOverlayIntersectorResult = function (c) { return w.isValidIntersectorResult(c) && 3 === c.intersector && !!c.target }; a.isTerrainIntersectorResult = function (c) { return w.isValidIntersectorResult(c) && 2 === c.intersector && !!c.target }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/views/3d/webgl-engine/lib/lodRendering/Intersector": function () {
      define(["exports", "../intersectorUtils"],
        function (a, w) { a.isLodIntersectorResult = function (c) { return w.isValidIntersectorResult(c) && 6 === c.intersector && !!c.target }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/support/hitTestSelectUtils": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers"], function (a, w) {
        function c() {
          c = w._asyncToGenerator(function* (q, u) {
            if ("2d" === q.type) return q.hitTest(u); q = yield q.hitTest(u); const y = q.results[0]; u = q.results.findIndex(n => n.distance !== y.distance); -1 !== u && (q.results = q.results.slice(0,
              u)); return q
          }); return c.apply(this, arguments)
        } a.hitTestSelectSameDistance = function (q, u) { return c.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/support/WebGLRequirements": function () {
      define(["exports", "../../core/Error", "../webgl/capabilities"], function (a, w, c) {
        const q = { checkMajorWebPerformanceCaveat: !0 }; a.check = function (u) {
          u = { ...q, ...u }; const y = c(); return y.available ? u.checkMajorWebPerformanceCaveat && y.majorPerformanceCaveat ? new w("webgl:major-performance-caveat-detected",
            "Your WebGL implementation doesn't seem to support hardware accelerated rendering. Check your browser settings or if your GPU is in a blocklist.") : y.supportsHighPrecisionFragment ? y.supportsVertexShaderSamplers ? y.supportsElementIndexUint ? y.supportsStandardDerivatives ? y.supportsInstancedArrays ? null : new w("webgl:instanced-arrays-required", "WebGL support for instanced rendering is required but not supported.") : new w("webgl:standard-derivatives-required", "WebGL support for standard derivatives is required but not supported.") :
              new w("webgl:element-index-uint-required", "WebGL support for uint vertex indices is required but not supported.") : new w("webgl:vertex-shader-samplers-required", "WebGL support for vertex shader samplers is required but not supported.") : new w("webgl:high-precision-fragment-required", "WebGL support for high precision fragment shaders is required but not supported.") : new w("webgl:required", "WebGL is required but not supported.")
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/webgl/capabilities": function () {
      define(["../../core/maybe",
        "./context-util"], function (a, w) {
          function c() {
            const u = { available: !1, version: 0, majorPerformanceCaveat: !1, maxTextureSize: 0, supportsHighPrecisionFragment: !1, supportsVertexShaderSamplers: !1, supportsElementIndexUint: !1, supportsStandardDerivatives: !1, supportsInstancedArrays: !1, supportsTextureFloat: !1, supportsColorBufferFloat: !1 }; var y = document.createElement("canvas"); if (!y) return u; var n = w.createContext(y, 1, { failIfMajorPerformanceCaveat: !0 }); a.isNone(n) && (n = w.createContext(y, 1), a.isSome(n) && (u.majorPerformanceCaveat =
              !0)); if (a.isNone(n)) return u; y = n.getParameter(n.VERSION); if (!y) return u; if (y = y.match(/^WebGL\s+([\d.]*)/)) {
                y = parseFloat(y[1]); u.available = .94 <= y; if (y = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT)) u.supportsHighPrecisionFragment = 0 < y.precision; u.supportsVertexShaderSamplers = 0 < n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS); u.supportsElementIndexUint = null !== n.getExtension("OES_element_index_uint"); u.supportsStandardDerivatives = null !== n.getExtension("OES_standard_derivatives"); u.supportsInstancedArrays =
                  null !== n.getExtension("ANGLE_instanced_arrays"); u.supportsTextureFloat = null !== n.getExtension("OES_texture_float"); u.supportsColorBufferFloat = null !== n.getExtension("WEBGL_color_buffer_float") && null !== n.getExtension("EXT_float_blend")
              } u.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE); (n = document.createElement("canvas")) ? (n = w.createContext(n, 2), n = a.isSome(n) ? !0 : !1) : n = !1; u.version = n ? 2 : 1; return u
          } let q; return function () { q || (q = c()); return q }
        })
    }, "esri/views/ui/3d/DefaultUI3D": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../DefaultUI".split(" "),
        function (a, w, c, q, u, y, n, p) { q = function (l) { function h(b) { b = l.call(this, b) || this; b.components = ["attribution", "zoom", "navigation-toggle", "compass"]; return b } a._inheritsLoose(h, l); return h }(p); w.__decorate([c.property()], q.prototype, "components", void 0); return q = w.__decorate([n.subclass("esri.views.ui.3d.DefaultUI3D")], q) })
    }, "esri/views/ui/DefaultUI": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/has ../../core/Logger ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Component ./UI ../../widgets/Attribution ../../widgets/Compass ../../widgets/NavigationToggle ../../widgets/Zoom".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          q.getLogger("esri.views.ui.DefaultUI"); c = function (m) {
            function e(x) { x = m.call(this, x) || this; x._defaultPositionLookup = { attribution: "manual", compass: "top-leading", "navigation-toggle": "top-leading", zoom: "top-leading" }; x.components = []; return x } a._inheritsLoose(e, m); var g = e.prototype; g.initialize = function () { this._handles.add([u.init(this, "components", this._componentsWatcher.bind(this)), u.init(this, "view", this._updateViewAwareWidgets.bind(this))]) }; g._add = function (x,
              k, r, A) { if ("string" === typeof x && this._defaultPositionLookup[x]) { if (this._find(x)) return; x = this._createComponent(x) } m.prototype._add.call(this, x, k, r, A) }; g._removeComponents = function (x) { x.forEach(k => { if (k = this._find(k)) this.remove(k), k.destroy() }) }; g._updateViewAwareWidgets = function (x) { this.components.forEach(k => { (k = (k = this._find(k)) && k.widget) && void 0 !== k.view && (k.view = x) }) }; g._componentsWatcher = function (x, k) { this._removeComponents(k); this._addComponents(x); this._adjustPadding(x) }; g._adjustPadding =
                function (x) { -1 !== x.indexOf("attribution") || this._isOverridden("padding") || ({ top: x } = this.padding, this.padding = x) }; g._addComponents = function (x) { this.initialized && x.forEach(k => this.add(this._createComponent(k), this._defaultPositionLookup[k])) }; g._createComponent = function (x) { const k = this._createWidget(x); if (k) return new h({ id: x, node: k }) }; g._createWidget = function (x) {
                  if ("attribution" === x) return this._createAttribution(); if ("compass" === x) return this._createCompass(); if ("navigation-toggle" === x) return this._createNavigationToggle();
                  if ("zoom" === x) return this._createZoom()
                }; g._createAttribution = function () { return new d({ view: this.view }) }; g._createCompass = function () { return new f({ view: this.view }) }; g._createNavigationToggle = function () { return new t({ view: this.view }) }; g._createZoom = function () { return new v({ view: this.view }) }; return e
          }(b); w.__decorate([y.property()], c.prototype, "components", void 0); return c = w.__decorate([l.subclass("esri.views.ui.DefaultUI")], c)
        })
    }, "esri/views/ui/Component": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/domUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          c = function (h) {
            function b() { var f = h.apply(this, arguments) || this; f.widget = null; return f } a._inheritsLoose(b, h); var d = b.prototype; d.destroy = function () { this.widget && this.widget.destroy(); this.node = null }; d.castNode = function (f) { if (!f) return this._set("widget", null), null; if ("string" === typeof f || f && "nodeType" in f) return this._set("widget", null), q.byId(f); f && "function" === typeof f.render && !f.domNode && (f.domNode = document.createElement("div")); this._set("widget", f); return f.domNode };
            a._createClass(b, [{ key: "id", get: function () { return this.get("widget.id") || this.get("node.id") } }, { key: "node", set: function (f) { const t = this._get("node"); f !== t && (f && f.classList.add("esri-component"), t && t.classList.remove("esri-component"), this._set("node", f)) } }]); return b
          }(c); w.__decorate([u.property({ dependsOn: [] })], c.prototype, "id", null); w.__decorate([u.property()], c.prototype, "node", null); w.__decorate([p.cast("node")], c.prototype, "castNode", null); w.__decorate([u.property({ readOnly: !0 })], c.prototype,
            "widget", void 0); return c = w.__decorate([l.subclass("esri.views.ui.Component")], c)
        })
    }, "esri/views/ui/UI": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/domUtils ../../core/Evented ../../core/Handles ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ./Component ../../widgets/support/widgetUtils".split(" "), function (a,
        w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(g) { const x = "object" === typeof g && null !== g && Object.getPrototypeOf(g); return null !== x && x !== Object.prototype || !("component" in g || "index" in g || "position" in g) ? null : g } function v(g, { top: x, bottom: k, left: r, right: A }) { g.style.top = x; g.style.bottom = k; g.style.left = r; g.style.right = A } const m = { left: 0, top: 0, bottom: 0, right: 0 }, e = { bottom: 30, top: 15, right: 15, left: 15 }; q = function (g) {
            function x(r) {
              r = g.call(this, r) || this; r._cornerNameToContainerLookup = {}; r._positionNameToContainerLookup =
                {}; r._components = []; r._componentToKey = new Map; r._handles = new u; r.view = null; r._initContainers(); return r
            } a._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this._handles.add([y.init(this, "view.padding, container", this._applyViewPadding.bind(this)), y.init(this, "padding", this._applyUIPadding.bind(this))]) }; k.destroy = function () { this.container = null; for (const r of this._components) r.destroy(); this._components.length = 0; this._handles.destroy(); this._componentToKey.clear() }; k.castPadding = function (r) {
              return "number" ===
                typeof r ? { bottom: r, top: r, right: r, left: r } : { ...e, ...r }
            }; k.add = function (r, A) { let z, B; if (Array.isArray(r)) r.forEach(D => this.add(D, A)); else { var C = t(r); C && ({ index: z, position: A, component: r, key: B } = C); A && "object" === typeof A && ({ index: z, key: B, position: A } = A); !r || A && !this._isValidPosition(A) || this._add(r, A, z, B) } }; k.remove = function (r, A) {
              if (r) {
                if (Array.isArray(r)) return r.map(C => this.remove(C, A)); var z = this._find(r); if (z) {
                  var B = this._componentToKey; if (!B.has(r) || B.get(r) === A) return B = this._components.indexOf(z),
                    z.node.parentNode && z.node.parentNode.removeChild(z.node), this._componentToKey.delete(r), this._components.splice(B, 1)[0]
                }
              }
            }; k.empty = function (r) {
              if (Array.isArray(r)) return r.map(A => this.empty(A)).reduce((A, z) => A.concat(z)); r = r || "manual"; return "manual" === r ? Array.prototype.slice.call(this._manualContainer.children).filter(A => !A.classList.contains("esri-ui-corner")).map(A => this.remove(A)) : this._isValidPosition(r) ? Array.prototype.slice.call(this._cornerNameToContainerLookup[r].children).map(this.remove,
                this) : null
            }; k.move = function (r, A) { Array.isArray(r) && r.forEach(C => this.move(C, A)); if (r) { var z = t(r) || t(A); if (z) { var B = z.index; A = z.position; r = z.component || r } (!A || this._isValidPosition(A)) && (r = this.remove(r)) && this.add(r, { position: A, index: B }) } }; k.find = function (r) { return r ? (r = this._findById(r)) && (r.widget || r.node) : null }; k.getPosition = function (r) { for (const A in this._positionNameToContainerLookup) if (this._positionNameToContainerLookup[A].contains(r)) return A; return null }; k._add = function (r, A, z, B) {
            r instanceof
              d || (r = new d({ node: r })); this._place({ component: r, position: A, index: z }); this._components.push(r); B && this._componentToKey.set(r, B)
            }; k._find = function (r) { return r ? r instanceof d ? this._findByComponent(r) : "string" === typeof r ? this._findById(r) : this._findByNode(r.domNode || r) : null }; k._getViewPadding = function () { return this.get("view.padding") || m }; k._attachContainers = function (r) { r.appendChild(this._innerContainer); r.appendChild(this._manualContainer) }; k._initContainers = function () {
              var r = document.createElement("div");
              r.classList.add("esri-ui-inner-container"); r.classList.add("esri-ui-corner-container"); const A = document.createElement("div"); A.classList.add("esri-ui-inner-container"); A.classList.add("esri-ui-manual-container"); const z = document.createElement("div"); z.classList.add("esri-ui-top-left"); z.classList.add("esri-ui-corner"); r.appendChild(z); const B = document.createElement("div"); B.classList.add("esri-ui-top-right"); B.classList.add("esri-ui-corner"); r.appendChild(B); const C = document.createElement("div");
              C.classList.add("esri-ui-bottom-left"); C.classList.add("esri-ui-corner"); r.appendChild(C); const D = document.createElement("div"); D.classList.add("esri-ui-bottom-right"); D.classList.add("esri-ui-corner"); r.appendChild(D); this._innerContainer = r; this._manualContainer = A; r = f.isRTL(); this._cornerNameToContainerLookup = { "top-left": z, "top-right": B, "bottom-left": C, "bottom-right": D, "top-leading": r ? B : z, "top-trailing": r ? z : B, "bottom-leading": r ? D : C, "bottom-trailing": r ? C : D }; this._positionNameToContainerLookup = {
                manual: A,
                ...this._cornerNameToContainerLookup
              }
            }; k._isValidPosition = function (r) { return !!this._positionNameToContainerLookup[r] }; k._place = function (r) {
              const A = r.component, z = r.index; r = this._positionNameToContainerLookup[r.position || "manual"]; var B = -1 < z, C = A.widget; C && !C._started && "function" === typeof C.postMixInProperties && "function" === typeof C.buildRendering && "function" === typeof C.postCreate && "function" === typeof C.startup && A.widget.startup(); B ? (B = Array.prototype.slice.call(r.children), 0 === z ? r.firstChild ? c.insertBefore(A.node,
                r.firstChild) : r.appendChild(A.node) : z >= B.length ? r.appendChild(A.node) : c.insertBefore(A.node, B[z])) : r.appendChild(A.node)
            }; k._applyViewPadding = function () { const r = this.container; r && v(r, this._toPxPosition(this._getViewPadding())) }; k._applyUIPadding = function () { const r = this._innerContainer; r && v(r, this._toPxPosition(this.padding)) }; k._toPxPosition = function (r) { return { top: this._toPxUnit(r.top), left: this._toPxUnit(r.left), right: this._toPxUnit(r.right), bottom: this._toPxUnit(r.bottom) } }; k._toPxUnit = function (r) {
              return 0 ===
                r ? "0" : r + "px"
            }; k._findByComponent = function (r) { let A = null, z; this._components.some(B => { (z = B === r) && (A = B); return z }); return A }; k._findById = function (r) { let A = null, z; this._components.some(B => { (z = B.id === r) && (A = B); return z }); return A }; k._findByNode = function (r) { let A = null, z; this._components.some(B => { (z = B.node === r) && (A = B); return z }); return A }; a._createClass(x, [{
              key: "container", set: function (r) {
                const A = this._get("container"); r !== A && (r && (r.classList.add("esri-ui"), r.classList.add(f.getCalciteThemeClass()), this._attachContainers(r)),
                  A && (A.classList.remove("esri-ui"), v(A, { top: "", bottom: "", left: "", right: "" }), c.empty(A)), this._set("container", r))
              }
            }, { key: "height", get: function () { const r = this.get("view.height") || 0; if (0 === r) return r; const A = this._getViewPadding(); return Math.max(r - (A.top + A.bottom), 0) } }, { key: "padding", get: function () { return this._get("padding") }, set: function (r) { r ? this._override("padding", r) : this._clearOverride("padding") } }, {
              key: "width", get: function () {
                const r = this.get("view.width") || 0; if (0 === r) return r; const A = this._getViewPadding();
                return Math.max(r - (A.left + A.right), 0)
              }
            }]); return x
          }(q.EventedAccessor); w.__decorate([n.property()], q.prototype, "container", null); w.__decorate([n.property()], q.prototype, "height", null); w.__decorate([n.property({ value: e })], q.prototype, "padding", null); w.__decorate([h.cast("padding")], q.prototype, "castPadding", null); w.__decorate([n.property()], q.prototype, "view", void 0); w.__decorate([n.property()], q.prototype, "width", null); return q = w.__decorate([b.subclass("esri.views.ui.UI")], q)
      })
    }, "esri/widgets/Attribution": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/watchUtils ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./Attribution/AttributionViewModel ./support/decorators/accessibleHandler ./support/decorators/messageBundle ../core/Logger ./support/jsxFactory ./support/widgetUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          u = function (e) {
            function g(k, r) { k = e.call(this, k, r) || this; k._isOpen = !1; k._attributionTextOverflowed = !1; k._prevSourceNodeHeight = 0; k.iconClass = "esri-icon-description"; k.itemDelimiter = " | "; k.label = void 0; k.messages = null; k.view = null; k.viewModel = new b; return k } a._inheritsLoose(g, e); var x = g.prototype; x.initialize = function () { this.own(c.on(this, "viewModel.items", "change", () => this.scheduleRender())) }; x.render = function () {
              return v.tsx("div", {
                bind: this, class: this.classes("esri-attribution esri-widget",
                  { ["esri-attribution--open"]: this._isOpen }), onclick: this._toggleState, onkeydown: this._toggleState
              }, this.renderSourcesNode(), this.renderPoweredBy())
            }; x.renderPoweredBy = function () { return v.tsx("div", { class: "esri-attribution__powered-by" }, "Powered by", " ", v.tsx("a", { class: "esri-attribution__link", href: "http://www.esri.com/", target: "_blank", rel: "noreferrer" }, "Esri")) }; x.renderSourcesNode = function () {
              const k = this._isOpen, r = this._isInteractive, A = r ? 0 : -1, { attributionText: z } = this, B = r ? "button" : void 0; return v.tsx("div",
                { afterCreate: this._afterSourcesNodeCreate, afterUpdate: this._afterSourcesNodeUpdate, bind: this, class: this.classes("esri-attribution__sources", { ["esri-attribution__sources--open"]: k, ["esri-interactive"]: r }), innerHTML: z, role: B, tabIndex: A })
            }; x._afterSourcesNodeCreate = function (k) { this._prevSourceNodeHeight = k.clientWidth }; x._afterSourcesNodeUpdate = function (k) {
              let r = !1; const { clientHeight: A, clientWidth: z, scrollWidth: B } = k; k = B >= z; const C = this._attributionTextOverflowed !== k; this._attributionTextOverflowed = k;
              C && (r = !0); this._isOpen && (k = A < this._prevSourceNodeHeight, this._prevSourceNodeHeight = A, k && (this._isOpen = !1, r = !0)); r && this.scheduleRender()
            }; x._toggleState = function () { this._isInteractive && (this._isOpen = !this._isOpen) }; a._createClass(g, [{ key: "_isInteractive", get: function () { return this._isOpen || this._attributionTextOverflowed } }, { key: "attributionText", get: function () { return this.viewModel.items.reduce((k, r) => { -1 === k.indexOf(r.text) && k.push(r.text); return k }, []).join(this.itemDelimiter) } }]); return g
          }(h);
          w.__decorate([p.property()], u.prototype, "_isOpen", void 0); w.__decorate([p.property()], u.prototype, "_isInteractive", null); w.__decorate([p.property()], u.prototype, "_attributionTextOverflowed", void 0); w.__decorate([p.property()], u.prototype, "_prevSourceNodeHeight", void 0); w.__decorate([p.property({ readOnly: !0, dependsOn: ["viewModel.items.length", "itemDelimiter"] })], u.prototype, "attributionText", null); w.__decorate([p.property()], u.prototype, "iconClass", void 0); w.__decorate([p.property()], u.prototype, "itemDelimiter",
            void 0); w.__decorate([p.property({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], u.prototype, "label", void 0); w.__decorate([p.property(), f.messageBundle("esri/widgets/Attribution/t9n/Attribution")], u.prototype, "messages", void 0); w.__decorate([q.aliasOf("viewModel.view")], u.prototype, "view", void 0); w.__decorate([p.property({ type: b })], u.prototype, "viewModel", void 0); w.__decorate([d.accessibleHandler()], u.prototype, "_toggleState", null); return u = w.__decorate([l.subclass("esri.widgets.Attribution")],
              u)
        })
    }, "esri/widgets/Attribution/AttributionViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../core/asyncUtils ../../core/Collection ../../core/HandleOwner ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../geometry/support/contains ../../geometry/support/webMercatorUtils ../../geometry/SpatialReference".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          function m(k, r) { return k && "copyright" in k && (!r || "function" === typeof k.originOf && "user" === k.originOf("copyright")) } function e(k, r) { return k.length !== r.length || k.some((A, z) => A.text !== r[z].text) } function g(k, r, A) { A && r && (k.find(z => z.layerView === r && z.text === A) || k.push({ text: A, layerView: r })) } const x = []; c = function (k) {
            function r(z) {
              var B = k.call(this, z) || this; B.clear = () => {
                B._fetchedAttributionData.clear(); B._pendingAttributions.clear(); B.handles.remove("suspension");
                B.notifyChange("state")
              }; B._pendingAttributions = new Set; B._fetchedAttributionData = new Map; B.items = new u; B.view = null; B._allLayerViewsChange = C => { B.handles.remove("suspension"); const D = B.get("view.allLayerViews"); D && B.handles.add(D.map(E => E.watch(["suspended", "attributionVisible"], B._updateAttributionItems)), "suspension"); C && C.removed && C.removed.forEach(E => { B._pendingAttributions.delete(E); B._fetchedAttributionData.delete(E) }); B._updateAttributionItems() }; B._updateAttributionItems = () => {
                const C = B.get("view.allLayerViews");
                x.length = 0; C ? (C.forEach(D => { if (!D.suspended && D.get("layer.attributionVisible")) { var E = D.layer; if (m(E, "user")) g(x, D, E.copyright); else if (E.hasAttributionData) if (B._fetchedAttributionData.has(D)) { var H = B._fetchedAttributionData.get(D); H ? g(x, D, B._getDynamicAttribution(H, B.view, E)) : m(E) && g(x, D, E.copyright) } else B._fetchAttributionData(D); else (H = E.get("portalItem.accessInformation")) ? g(x, D, H) : g(x, D, E.copyright) } }), e(B.items, x) && (B.items.removeAll(), B.items.addMany(x)), x.length = 0, B.notifyChange("state")) :
                  B.clear()
              }; B.handles.add([n.on(a._assertThisInitialized(B), "view.allLayerViews", "change", B._allLayerViewsChange, B._allLayerViewsChange, B.clear), n.whenTrue(a._assertThisInitialized(B), "view.stationary", () => B._updateAttributionItems())]); return B
            } a._inheritsLoose(r, k); var A = r.prototype; A.destroy = function () { this.view = null; this._fetchedAttributionData.clear(); this._pendingAttributions.clear(); this.items.removeAll() }; A._fetchAttributionData = function () {
              var z = a._asyncToGenerator(function* (B) {
                if (!this._pendingAttributions.has(B)) {
                  this._pendingAttributions.add(B);
                  var C = yield q.result(B.layer.fetchAttributionData()); this._pendingAttributions.has(B) && (C = C.ok ? this._createContributionIndex(C.value, "bing-maps" === B.layer.type) : null, this._pendingAttributions.delete(B), this._fetchedAttributionData.set(B, C)); this._updateAttributionItems()
                }
              }); return function (B) { return z.apply(this, arguments) }
            }(); A._createContributionIndex = function (z, B) {
              z = z.contributors; const C = {}; if (!z) return C; for (let J = 0; J < z.length; J++) {
                const M = z[J]; var D = M.coverageAreas; if (!D) return; for (const F of D) {
                  var E =
                    F.bbox, H = F.zoomMin - (B && F.zoomMin ? 1 : 0); D = F.zoomMax - (B && F.zoomMax ? 1 : 0); for (E = { extent: t.geographicToWebMercator({ xmin: E[1], ymin: E[0], xmax: E[3], ymax: E[2], spatialReference: v.WGS84 }), attribution: M.attribution || "", score: null != F.score ? F.score : 100, id: J }; H <= D; H++)C[H] = C[H] || [], C[H].push(E)
                }
              } C.maxKey = Math.max.apply(null, Object.keys(C)); return C
            }; A._getDynamicAttribution = function (z, B, C) {
              const { extent: D, scale: E } = B; C = C.tileInfo.scaleToZoom(E); C = Math.min(z.maxKey, Math.round(C)); if (!D || null == C || -1 >= C) return ""; z =
                z[C]; const H = t.project(D.center.clone().normalize(), B.spatialReference), J = {}; return z ? z.filter(M => { const F = !J[M.id] && H && f.extentContainsPoint(M.extent, H); F && (J[M.id] = !0); return F }).sort((M, F) => F.score - M.score || M.objectId - F.objectId).map(M => M.attribution).join(", ") : ""
            }; a._createClass(r, [{ key: "state", get: function () { return this.get("view.ready") ? 0 < this._pendingAttributions.size ? "loading" : "ready" : "disabled" } }]); return r
          }(y.HandleOwner); w.__decorate([p.property({ readOnly: !0, type: u })], c.prototype, "items",
            void 0); w.__decorate([p.property({ readOnly: !0 })], c.prototype, "state", null); w.__decorate([p.property()], c.prototype, "view", void 0); return c = w.__decorate([d.subclass("esri.widgets.Attribution.AttributionViewModel")], c)
        })
    }, "esri/widgets/Compass": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./Compass/CompassViewModel ./support/decorators/accessibleHandler ./support/decorators/messageBundle ../core/Logger ./support/jsxFactory ./support/widgetUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          q = function (m) {
            function e(x, k) { x = m.call(this, x, k) || this; x.goToOverride = null; x.iconClass = "esri-icon-locate-circled"; x.label = void 0; x.messages = null; x.view = null; x.viewModel = new h; return x } a._inheritsLoose(e, m); var g = e.prototype; g.reset = function () { return this.viewModel.reset() }; g.render = function () {
              const { orientation: x, state: k } = this.viewModel; var r = "disabled" === k, A = "compass" === ("rotation" === k ? "rotation" : "compass"); const z = r ? -1 : 0; r = { ["esri-disabled"]: r, ["esri-interactive"]: !r };
              A = { ["esri-icon-compass"]: A, ["esri-icon-dial"]: !A }; const { messages: B } = this; return t.tsx("div", { bind: this, class: this.classes("esri-compass esri-widget--button esri-widget", r), onclick: this._reset, onkeydown: this._reset, role: "button", tabIndex: z, "aria-label": B.reset, title: B.reset }, t.tsx("span", { "aria-hidden": "true", class: this.classes("esri-compass__icon", A), styles: this._toRotationTransform(x) }), t.tsx("span", { class: "esri-icon-font-fallback-text" }, B.reset))
            }; g._reset = function () { this.viewModel.reset() }; g._toRotationTransform =
              function (x) { return { transform: `rotateZ(${x.z}deg)` } }; return e
          }(l); w.__decorate([c.aliasOf("viewModel.goToOverride")], q.prototype, "goToOverride", void 0); w.__decorate([n.property()], q.prototype, "iconClass", void 0); w.__decorate([n.property({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], q.prototype, "label", void 0); w.__decorate([n.property(), d.messageBundle("esri/widgets/Compass/t9n/Compass")], q.prototype, "messages", void 0); w.__decorate([c.aliasOf("viewModel.view")], q.prototype, "view", void 0);
          w.__decorate([n.property({ type: h })], q.prototype, "viewModel", void 0); w.__decorate([b.accessibleHandler()], q.prototype, "_reset", null); return q = w.__decorate([p.subclass("esri.widgets.Compass")], q)
        })
    }, "esri/widgets/Compass/CompassViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/Handles ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/GoTo".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          c = function (d) {
            function f(v) { v = d.call(this, v) || this; v._handles = new q; v.orientation = { x: 0, y: 0, z: 0 }; v.view = null; v._updateForCamera = v._updateForCamera.bind(a._assertThisInitialized(v)); v._updateForRotation = v._updateForRotation.bind(a._assertThisInitialized(v)); v._updateRotationWatcher = v._updateRotationWatcher.bind(a._assertThisInitialized(v)); return v } a._inheritsLoose(f, d); var t = f.prototype; t.initialize = function () { this._handles.add(u.init(this, "view", this._updateRotationWatcher)) };
            t.destroy = function () { this._handles.destroy(); this.view = this._handles = null }; t.reset = function () { if (this.get("view.ready")) { var v = {}; "2d" === this.view.type ? v.rotation = 0 : v.heading = 0; this.callGoTo({ target: v }) } }; t._updateForRotation = function (v) { void 0 !== v && null !== v && (this.orientation = { z: v }) }; t._updateForCamera = function (v) { v && (this.orientation = { x: 0, y: 0, z: -v.heading }) }; t._updateRotationWatcher = function (v) {
              this._handles.removeAll(); v && ("2d" === v.type ? this._handles.add(u.init(this, "view.rotation", this._updateForRotation)) :
                this._handles.add(u.init(this, "view.camera", this._updateForCamera)))
            }; a._createClass(f, [{ key: "canShowNorth", get: function () { const v = this.get("view.spatialReference"); return !(!v || !v.isWebMercator && !v.isGeographic) } }, { key: "state", get: function () { return this.get("view.ready") ? this.canShowNorth ? "compass" : "rotation" : "disabled" } }]); return f
          }(b.GoToMixin(c)); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "canShowNorth", null); w.__decorate([y.property()], c.prototype, "orientation", void 0); w.__decorate([y.property({ readOnly: !0 })],
            c.prototype, "state", null); w.__decorate([y.property()], c.prototype, "view", void 0); return c = w.__decorate([h.subclass("esri.widgets.CompassViewModel")], c)
        })
    }, "esri/widgets/NavigationToggle": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./NavigationToggle/NavigationToggleViewModel ./support/decorators/accessibleHandler ./support/decorators/messageBundle ../core/Logger ./support/jsxFactory ./support/widgetUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
          q = function (m) {
            function e(x, k) { x = m.call(this, x, k) || this; x.iconClass = "esri-icon-pan2"; x.label = void 0; x.messages = null; x.view = null; x.viewModel = new h; return x } a._inheritsLoose(e, m); var g = e.prototype; g.toggle = function () { return this.viewModel.toggle() }; g.render = function () {
              const x = "disabled" === this.get("viewModel.state"); var k = "pan" === this.get("viewModel.navigationMode"); const r = { ["esri-navigation-toggle__button--active"]: k }; k = { ["esri-navigation-toggle__button--active"]: !k };
              const A = x ? -1 : 0, z = this.messages.toggle; return t.tsx("div", { bind: this, class: this.classes("esri-navigation-toggle esri-widget", { ["esri-disabled"]: x, ["esri-navigation-toggle--horizontal"]: "horizontal" === this.layout }), onclick: this._toggle, onkeydown: this._toggle, tabIndex: A, "aria-label": z, title: z }, t.tsx("div", { class: this.classes("esri-navigation-toggle__button esri-widget--button", "esri-navigation-toggle__button--pan", r) }, t.tsx("span", { class: "esri-icon-pan" })), t.tsx("div", {
                class: this.classes("esri-navigation-toggle__button esri-widget--button",
                  "esri-navigation-toggle__button--rotate", k)
              }, t.tsx("span", { class: "esri-icon-rotate" })))
            }; g._toggle = function () { this.toggle() }; a._createClass(e, [{ key: "layout", set: function (x) { "horizontal" !== x && (x = "vertical"); this._set("layout", x) } }]); return e
          }(l); w.__decorate([n.property()], q.prototype, "iconClass", void 0); w.__decorate([n.property({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], q.prototype, "label", void 0); w.__decorate([n.property({ value: "vertical" })], q.prototype, "layout", null); w.__decorate([n.property(),
          d.messageBundle("esri/widgets/NavigationToggle/t9n/NavigationToggle")], q.prototype, "messages", void 0); w.__decorate([c.aliasOf("viewModel.view")], q.prototype, "view", void 0); w.__decorate([n.property({ type: h })], q.prototype, "viewModel", void 0); w.__decorate([b.accessibleHandler()], q.prototype, "_toggle", null); return q = w.__decorate([p.subclass("esri.widgets.NavigationToggle")], q)
        })
    }, "esri/widgets/NavigationToggle/NavigationToggleViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/Handles ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          c = function (b) {
            function d(t) { t = b.call(this, t) || this; t._handles = new q; t.navigationMode = "pan"; t.view = null; return t } a._inheritsLoose(d, b); var f = d.prototype; f.initialize = function () { this._handles.add(u.when(this, "view.inputManager", this._setNavigationMode.bind(this))) }; f.destroy = function () { this._handles.destroy(); this.view = this._handles = null }; f.toggle = function () { "disabled" !== this.state && (this.navigationMode = "pan" !== this.navigationMode ? "pan" : "rotate", this._setNavigationMode()) };
            f._setNavigationMode = function () { this.get("view.inputManager").primaryDragAction = "pan" === this.navigationMode ? "pan" : "rotate" }; a._createClass(d, [{ key: "state", get: function () { return this.get("view.ready") && "3d" === this.view.type ? "ready" : "disabled" } }]); return d
          }(c); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "state", null); w.__decorate([y.property()], c.prototype, "navigationMode", void 0); w.__decorate([y.property()], c.prototype, "view", void 0); return c = w.__decorate([h.subclass("esri.widgets.NavigationToggleViewModel")],
            c)
        })
    }, "esri/widgets/Zoom": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/accessorSupport/decorators/aliasOf ../core/arrayUtils ../core/has ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ./Widget ./support/widgetUtils ./support/decorators/messageBundle ../core/Logger ./support/jsxFactory ./Zoom/IconButton ./Zoom/ZoomViewModel".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v) {
        q = function (m) {
          function e(x,
            k) { x = m.call(this, x, k) || this; x.iconClass = "esri-icon-zoom-in-magnifying-glass"; x.label = void 0; x.messages = null; x.view = null; x.viewModel = new v; return x } a._inheritsLoose(e, m); var g = e.prototype; g.initialize = function () { this._zoomInButton = new t({ action: this.zoomIn.bind(this), iconClass: "esri-icon-plus" }); this._zoomOutButton = new t({ action: this.zoomOut.bind(this), iconClass: "esri-icon-minus" }) }; g.destroy = function () {
              this._zoomInButton.destroy(); this._zoomOutButton.destroy(); this._zoomOutButton = this._zoomInButton =
                null
            }; g.render = function () { const x = this.viewModel, k = { ["esri-zoom--horizontal"]: "horizontal" === this.layout }; this._zoomInButton.enabled = "ready" === x.state && x.canZoomIn; this._zoomOutButton.enabled = "ready" === x.state && x.canZoomOut; this._zoomInButton.title = this.messages.zoomIn; this._zoomOutButton.title = this.messages.zoomOut; return f.tsx("div", { class: this.classes("esri-zoom esri-widget", k) }, this._zoomInButton.render(), this._zoomOutButton.render()) }; g.zoomIn = function () { return this.viewModel.zoomIn() }; g.zoomOut =
              function () { return this.viewModel.zoomOut() }; a._createClass(e, [{ key: "layout", set: function (x) { "horizontal" !== x && (x = "vertical"); this._set("layout", x) } }]); return e
        }(l); w.__decorate([n.property()], q.prototype, "iconClass", void 0); w.__decorate([n.property({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], q.prototype, "label", void 0); w.__decorate([n.property({ value: "vertical" })], q.prototype, "layout", null); w.__decorate([n.property(), b.messageBundle("esri/widgets/Zoom/t9n/Zoom")], q.prototype, "messages",
          void 0); w.__decorate([c.aliasOf("viewModel.view")], q.prototype, "view", void 0); w.__decorate([n.property({ type: v })], q.prototype, "viewModel", void 0); return q = w.__decorate([p.subclass("esri.widgets.Zoom")], q)
      })
    }, "esri/widgets/Zoom/IconButton": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../Widget ../support/decorators/accessibleHandler ../../core/Logger ../support/jsxFactory ../support/widgetUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          q = function (f) {
            function t() { var m = f.apply(this, arguments) || this; m.enabled = !0; m.iconClass = ""; m.title = ""; return m } a._inheritsLoose(t, f); var v = t.prototype; v.render = function () {
              const m = this.enabled ? 0 : -1, e = { [this.iconClass]: !!this.iconClass }; return b.tsx("div", {
                bind: this, class: this.classes("esri-widget--button esri-widget", { ["esri-disabled"]: !this.enabled, ["esri-interactive"]: this.enabled }), onclick: this._triggerAction, onkeydown: this._triggerAction, role: "button", tabIndex: m,
                title: this.title
              }, b.tsx("span", { "aria-hidden": "true", role: "presentation", class: this.classes("esri-icon", e) }), b.tsx("span", { class: "esri-icon-font-fallback-text" }, this.title))
            }; v._triggerAction = function () { this.action.call(this) }; return t
          }(p); w.__decorate([c.property()], q.prototype, "action", void 0); w.__decorate([c.property()], q.prototype, "enabled", void 0); w.__decorate([c.property()], q.prototype, "iconClass", void 0); w.__decorate([c.property()], q.prototype, "title", void 0); w.__decorate([l.accessibleHandler()],
            q.prototype, "_triggerAction", null); return q = w.__decorate([n.subclass("esri.widgets.IconButton")], q)
        })
    }, "esri/widgets/Zoom/ZoomViewModel": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/promiseUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./ZoomConditions2D ./ZoomConditions3D".split(" "), function (a, w, c, q, u, y,
        n, p, l, h, b) {
          c = function (d) {
            function f(v) { v = d.call(this, v) || this; v.canZoomIn = !1; v.canZoomOut = !1; return v } a._inheritsLoose(f, d); var t = f.prototype; t.destroy = function () { this.view = null }; t.zoomIn = function () { if (this.canZoomIn) { var v = this.view; "2d" === v.type ? v.mapViewNavigation.zoomIn() : q.ignoreAbortErrors(v.goTo({ zoomFactor: 2 })) } }; t.zoomOut = function () { if (this.canZoomOut) { var v = this.view; "2d" === v.type ? v.mapViewNavigation.zoomOut() : q.ignoreAbortErrors(v.goTo({ zoomFactor: .5 })) } }; a._createClass(f, [{
              key: "state",
              get: function () { return this.get("view.ready") ? "ready" : "disabled" }
            }, { key: "view", set: function (v) { v ? "2d" === v.type ? this._zoomConditions = new h({ view: v }) : "3d" === v.type && (this._zoomConditions = new b({ view: v })) : this._zoomConditions = null; this._set("view", v) } }]); return f
          }(c); w.__decorate([u.property()], c.prototype, "_zoomConditions", void 0); w.__decorate([u.property({ aliasOf: "_zoomConditions.canZoomIn", readOnly: !0 })], c.prototype, "canZoomIn", void 0); w.__decorate([u.property({
            aliasOf: "_zoomConditions.canZoomOut",
            readOnly: !0
          })], c.prototype, "canZoomOut", void 0); w.__decorate([u.property({ readOnly: !0 })], c.prototype, "state", null); w.__decorate([u.property()], c.prototype, "view", null); return c = w.__decorate([l.subclass("esri.widgets.Zoom.ZoomViewModel")], c)
      })
    }, "esri/widgets/Zoom/ZoomConditions2D": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p) {
          c = function (l) {
            function h() { return l.apply(this, arguments) || this } a._inheritsLoose(h, l); a._createClass(h, [{ key: "canZoomIn", get: function () { if (!this.get("view.ready")) return !1; const b = this.get("view.animation.target.scale") || this.get("view.scale"), d = this.get("view.constraints.effectiveMaxScale"); return 0 === d || b > d } }, {
              key: "canZoomOut", get: function () {
                if (!this.get("view.ready")) return !1; const b = this.get("view.animation.target.scale") || this.get("view.scale"), d = this.get("view.constraints.effectiveMinScale");
                return 0 === d || b < d
              }
            }]); return h
          }(c); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "canZoomIn", null); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "canZoomOut", null); w.__decorate([q.property()], c.prototype, "view", void 0); return c = w.__decorate([p.subclass("esri.widgets.Zoom.ZoomConditions2D")], c)
        })
    }, "esri/widgets/Zoom/ZoomConditions3D": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p) {
          c = function (l) { function h() { return l.apply(this, arguments) || this } a._inheritsLoose(h, l); a._createClass(h, [{ key: "canZoomIn", get: function () { return !!this.get("view.ready") } }, { key: "canZoomOut", get: function () { return !!this.get("view.ready") } }]); return h }(c); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "canZoomIn", null); w.__decorate([q.property({ readOnly: !0 })], c.prototype, "canZoomOut", null); w.__decorate([q.property()], c.prototype, "view", void 0); return c = w.__decorate([p.subclass("esri.widgets.Zoom.ZoomConditions3D")],
            c)
        })
    }, "esri/layers/SceneLayer": function () {
      define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../PopupTemplate ../renderers/ClassBreaksRenderer ../renderers/DictionaryRenderer ../renderers/DotDensityRenderer ../renderers/HeatmapRenderer ../renderers/Renderer ../renderers/SimpleRenderer ../renderers/UniqueValueRenderer ../renderers/support/jsonUtils ../renderers/support/types ../request ../core/Error ../core/Logger ../core/maybe ../core/MultiOriginJSONSupport ../core/promiseUtils ../core/urlUtils ../core/watchUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/has ../core/accessorSupport/utils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ./Layer ./mixins/APIKeyMixin ./mixins/ArcGISService ./mixins/OperationalLayer ./mixins/PortalLayer ./mixins/ScaleRangeLayer ./mixins/SceneService ./support/capabilities ./support/commonProperties ./support/FeatureReduction ./support/FeatureReductionSelection ./support/FetchAssociatedFeatureLayer ./support/fieldProperties ./support/FieldsIndex ./support/fieldUtils ./support/I3SLayerDefinitions ./support/LabelClass ./support/labelingInfo ./support/LayerFloorInfo ./support/RangeInfo ../renderers/support/styleUtils ../rest/support/Query ../support/popupUtils ../webdoc/support/opacityUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q, T, da, Y, fa, ha, ka, ea, ba, aa, W, U) {
          const X = ["3DObject", "Point"], Z = m.getLogger("esri.layers.SceneLayer"); u = Q.defineFieldProperties(); g = function (ma) {
            function ra(...za) {
              za = ma.call(this, ...za) || this; za.featureReduction = null; za.rangeInfos = null; za.operationalLayerType = "ArcGISSceneServiceLayer"; za.type = "scene"; za.fields = null; za.floorInfo = null; za.outFields = null; za.nodePages = null; za.materialDefinitions = null; za.textureSetDefinitions =
                null; za.geometryDefinitions = null; za.serviceUpdateTimeStamp = null; za.definitionExpression = null; za.path = null; za.labelsVisible = !0; za.labelingInfo = null; za.legendEnabled = !0; za.cachedDrawingInfo = { color: !1 }; za.popupEnabled = !0; za.popupTemplate = null; za.objectIdField = null; za.globalIdField = null; za._fieldUsageInfo = {}; za.screenSizePerspectiveEnabled = !0; return za
            } w._inheritsLoose(ra, ma); var Aa = ra.prototype; Aa.normalizeCtorArgs = function (za, Ka) { return "string" === typeof za ? { url: za, ...Ka } : za }; Aa.getField = function (za) { return this.fieldsIndex.get(za) };
            Aa.getFieldDomain = function (za, Ka) { var Ea, Ua, Na, ya; return (Ka = null == (Ea = this.getFeatureType(null == Ka ? void 0 : Ka.feature)) ? void 0 : null == (Ua = Ea.domains) ? void 0 : Ua[za]) && "inherited" !== Ka.type ? Ka : null != (Na = null == (ya = this.getField(za)) ? void 0 : ya.domain) ? Na : null }; Aa.getFeatureType = function (za) { return za && e.isSome(this.associatedLayer) ? this.associatedLayer.getFeatureType(za) : null }; Aa.readNodePages = function (za, Ka, Ea) {
            "Point" === Ka.layerType && (za = Ka.pointNodePages); return null == za || "object" !== typeof za ? null : Y.I3SNodePageDefinition.fromJSON(za,
              Ea)
            }; Aa.readCachedDrawingInfo = function (za) { if (null == za || "object" !== typeof za) za = {}; null == za.color && (za.color = !1); return za }; Aa.readObjectIdField = function (za, Ka) { !za && Ka.fields && Ka.fields.some(Ea => { "esriFieldTypeOID" === Ea.type && (za = Ea.name); return !!za }); return za || void 0 }; Aa.readGlobalIdField = function (za, Ka) { !za && Ka.fields && Ka.fields.some(Ea => { "esriFieldTypeGlobalID" === Ea.type && (za = Ea.name); return !!za }); return za || void 0 }; Aa.readProfile = function (za, Ka) {
              za = Ka.store.profile; if (null != za && ia[za]) return ia[za];
              Z.error("Unknown or missing profile", { profile: za, layer: this }); return "mesh-pyramids"
            }; Aa.load = function (za) {
              const Ka = e.isSome(za) ? za.signal : null, Ea = this.loadFromPortal({ supportedTypes: ["Scene Service"] }, za).catch(x.throwIfAbortError).then(() => this._fetchService(Ka)).then(() => Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, Ka), this._setAssociatedFeatureLayer(Ka)])).then(() => this._validateElevationInfo()).then(() => this._applyAssociatedLayerOverrides()).then(() => this._populateFieldUsageInfo()).then(() =>
                ba.loadStyleRenderer(this, { origin: "service" }, Ka)).then(() => da.fixRendererFields(this.renderer, this.fieldsIndex)).then(() => this.finishLoadEditablePortalLayer(za)); this.addResolvingPromise(Ea); return Promise.resolve(this)
            }; Aa.createQuery = function () { const za = new aa; "mesh" !== this.geometryType && (za.returnGeometry = !0, za.returnZ = !0); za.where = this.definitionExpression || "1\x3d1"; za.sqlFormat = "standard"; return za }; Aa.queryExtent = function (za, Ka) {
              return this._getAssociatedLayerForQuery().then(Ea => Ea.queryExtent(za ||
                this.createQuery(), Ka))
            }; Aa.queryFeatureCount = function (za, Ka) { return this._getAssociatedLayerForQuery().then(Ea => Ea.queryFeatureCount(za || this.createQuery(), Ka)) }; Aa.queryFeatures = function (za, Ka) { return this._getAssociatedLayerForQuery().then(Ea => Ea.queryFeatures(za || this.createQuery(), Ka)).then(Ea => { if (null != Ea && Ea.features) for (const Ua of Ea.features) Ua.layer = this, Ua.sourceLayer = this; return Ea }) }; Aa.queryObjectIds = function (za, Ka) {
              return this._getAssociatedLayerForQuery().then(Ea => Ea.queryObjectIds(za ||
                this.createQuery(), Ka))
            }; Aa.queryAttachments = function (za, Ka) { return this._getAssociatedLayerForQuery().then(Ea => Ea.queryAttachments(za, Ka)) }; Aa.getFieldUsageInfo = function (za) { const Ka = { supportsLabelingInfo: !1, supportsRenderer: !1, supportsPopupTemplate: !1, supportsLayerQuery: !1 }; return this.loaded ? this._fieldUsageInfo[za] || Ka : (Z.error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), Ka) }; Aa.createPopupTemplate = function (za) { return W.createPopupTemplate(this, za) }; Aa._getAssociatedLayerForQuery =
              function () { const za = this.associatedLayer; return e.isSome(za) && za.loaded ? Promise.resolve(za) : this._loadAssociatedLayerForQuery() }; Aa._loadAssociatedLayerForQuery = function () {
                var za = w._asyncToGenerator(function* () {
                  yield this.load(); if (e.isNone(this.associatedLayer)) throw new v("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this }); try { yield this.associatedLayer.load() } catch (Ka) {
                    throw new v("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded",
                      { layer: this, error: Ka });
                  } return this.associatedLayer
                }); return function () { return za.apply(this, arguments) }
              }(); Aa.hasCachedStatistics = function (za) { return null != this.statisticsInfo && this.statisticsInfo.some(Ka => Ka.name === za) }; Aa.queryCachedStatistics = function () {
                var za = w._asyncToGenerator(function* (Ka, Ea) {
                  yield this.load(Ea); if (!this.statisticsInfo) throw new v("scenelayer:no-cached-statistics", "Cached statistics are not available for this layer"); const Ua = this.fieldsIndex.get(Ka); if (!Ua) throw new v("scenelayer:field-unexisting",
                    `Field '${Ka}' does not exist on the layer`); for (const Na of this.statisticsInfo) if (Na.name === Ua.name) return Ka = k.join(this.parsedUrl.path, Na.href), t(Ka, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: Ea ? Ea.signal : null }).then(ya => ya.data); throw new v("scenelayer:no-cached-statistics", "Cached statistics for this attribute are not available");
                }); return function (Ka, Ea) { return za.apply(this, arguments) }
              }(); Aa.saveAs = function () {
                var za = w._asyncToGenerator(function* (Ka, Ea) {
                  return this._debouncedSaveOperations(1,
                    { ...Ea, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, Ka)
                }); return function (Ka, Ea) { return za.apply(this, arguments) }
              }(); Aa.save = function () { var za = w._asyncToGenerator(function* () { return this._debouncedSaveOperations(0, { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }) }); return function () { return za.apply(this, arguments) } }(); Aa.applyEdits = function () {
                var za = w._asyncToGenerator(function* (Ka, Ea) {
                  const Ua = yield new Promise((Na, ya) => a(["./graphics/editingSupport"],
                    Na, ya)); yield this.load(); if (e.isNone(this.associatedLayer)) throw new v(`${this.type}-layer:not-editable`, "Service is not editable"); yield this.associatedLayer.load(); return Ua.applyEdits(this, this.associatedLayer.source, Ka, Ea)
                }); return function (Ka, Ea) { return za.apply(this, arguments) }
              }(); Aa.on = function (za, Ka) { return ma.prototype.on.call(this, za, Ka) }; Aa.validateLayer = function (za) {
                if (za.layerType && -1 === X.indexOf(za.layerType)) throw new v("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type",
                  { layerType: za.layerType }); if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new v("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" }); if (1 < this.version.major) throw new v("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" }); {
                    za = this.normalReferenceFrame; var Ka = this.spatialReference; let Ea = !1, Ua = !1; if (null == za) Ua = Ea = !0; else switch (Ka =
                      Ka && Ka.isGeographic, za) { case "east-north-up": case "earth-centered": Ea = !0; Ua = Ka; break; case "vertex-reference-frame": Ea = !0; Ua = !Ka; break; default: Ea = !1 }if (!Ea) throw new v("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid."); if (!Ua) throw new v("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
                }
              }; Aa._getTypeKeywords = function () {
                const za = []; if ("points" === this.profile) za.push("Point"); else if ("mesh-pyramids" ===
                  this.profile) za.push("3DObject"); else throw new v("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile); return za
              }; Aa._populateFieldUsageInfo = function () {
              this._fieldUsageInfo = {}; if (this.fields) for (const za of this.fields) {
                const Ka = !(!this.attributeStorageInfo || !this.attributeStorageInfo.some(Ua => Ua.name === za.name)), Ea = !!(e.isSome(this.associatedLayer) && this.associatedLayer.fields && this.associatedLayer.fields.some(Ua => Ua && za.name === Ua.name)); this._fieldUsageInfo[za.name] =
                  { supportsLabelingInfo: Ka, supportsRenderer: Ka, supportsPopupTemplate: Ka || Ea, supportsLayerQuery: Ea }
              }
              }; Aa._applyAssociatedLayerOverrides = function () { this._applyAssociatedLayerFieldsOverrides(); this._applyAssociatedLayerPopupOverrides() }; Aa._applyAssociatedLayerFieldsOverrides = function () {
                if (!e.isNone(this.associatedLayer) && this.associatedLayer.fields) {
                  var za = null; for (const Ka of this.associatedLayer.fields) {
                    const Ea = this.getField(Ka.name); Ea ? (!Ea.domain && Ka.domain && (Ea.domain = Ka.domain.clone()), Ea.editable =
                      Ka.editable, Ea.nullable = Ka.nullable, Ea.length = Ka.length) : (za || (za = this.fields ? this.fields.slice() : []), za.push(Ka.clone()))
                  } za && this._set("fields", za)
                }
              }; Aa._applyAssociatedLayerPopupOverrides = function () { if (!e.isNone(this.associatedLayer)) { var za = ["popupTemplate", "popupEnabled"], Ka = C.getProperties(this); for (let Ea = 0; Ea < za.length; Ea++) { const Ua = za[Ea], Na = this.originIdOf(Ua), ya = this.associatedLayer.originIdOf(Ua); Na < ya && (2 === ya || 3 === ya) && Ka.setAtOrigin(Ua, this.associatedLayer[Ua], ya) } } }; Aa._setAssociatedFeatureLayer =
                function () { var za = w._asyncToGenerator(function* (Ka) { if (-1 !== ["mesh-pyramids", "points"].indexOf(this.profile)) { Ka = new S.FetchAssociatedFeatureLayer(this.parsedUrl, this.portalItem, this.apiKey, Ka); try { this.associatedLayer = yield Ka.fetch() } catch (Ea) { x.isAbortError(Ea) || this._logWarningOnPopupEnabled() } } }); return function (Ka) { return za.apply(this, arguments) } }(); Aa._logWarningOnPopupEnabled = function () {
                  r.whenValidOnce(this, ["popupTemplate", "popupEnabled"], () => this.popupEnabled && null != this.popupTemplate).then(() =>
                    () => { const za = `this SceneLayer: ${this.title}`; null == this.attributeStorageInfo ? Z.warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${za}`) : Z.info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${za}`) })
                }; Aa._validateElevationInfo = function () {
                  const za = this.elevationInfo; za && ("mesh-pyramids" === this.profile && "absolute-height" !== za.mode && Z.warn(".elevationInfo\x3d", "Mesh scene layers only support absolute-height elevation mode"),
                    za.featureExpressionInfo && "0" !== za.featureExpressionInfo.expression && Z.warn(".elevationInfo\x3d", "Scene layers do not support featureExpressionInfo"))
                }; w._createClass(ra, [{ key: "types", get: function () { return e.isSome(this.associatedLayer) ? this.associatedLayer.types : [] } }, { key: "typeIdField", get: function () { return e.isSome(this.associatedLayer) ? this.associatedLayer.typeIdField : null } }, { key: "formTemplate", get: function () { return e.isSome(this.associatedLayer) ? this.associatedLayer.formTemplate : null } }, {
                  key: "fieldsIndex",
                  get: function () { return new T(this.fields) }
                }, { key: "elevationInfo", set: function (za) { this._set("elevationInfo", za); this.loaded && this._validateElevationInfo() } }, { key: "geometryType", get: function () { return la[this.profile] || "mesh" } }, { key: "renderer", set: function (za) { da.fixRendererFields(za, this.fieldsIndex); this._set("renderer", za) } }, {
                  key: "capabilities", get: function () {
                    var za = e.isSome(this.associatedLayer) && this.associatedLayer.capabilities ? this.associatedLayer.capabilities : G.zeroCapabilities; const { query: Ka,
                      editing: { supportsGlobalId: Ea, supportsRollbackOnFailure: Ua, supportsUploadWithItemId: Na, supportsReturnServiceEditsInSourceSpatialReference: ya }, data: { supportsZ: pa, supportsM: wa, isVersioned: Ia, supportsAttachment: Ha }, operations: { supportsEditing: Oa, supportsUpdate: Ba, supportsQuery: sa, supportsQueryAttachments: Ca } } = za; za = za.operations.supportsChangeTracking; return {
                        query: Ka, editing: {
                          supportsGlobalId: Ea, supportsReturnServiceEditsInSourceSpatialReference: ya, supportsRollbackOnFailure: Ua, supportsGeometryUpdate: !1,
                          supportsUploadWithItemId: Na
                        }, data: { supportsAttachment: Ha, supportsZ: pa, supportsM: wa, isVersioned: Ia }, operations: { supportsQuery: sa, supportsQueryAttachments: Ca, supportsEditing: Oa && za, supportsAdd: !1, supportsDelete: !1, supportsUpdate: Ba && za }
                      }
                  }
                }, { key: "editingEnabled", get: function () { return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this.userHasEditingPrivileges }, set: function (za) { null != za ? this._override("editingEnabled", za) : this._clearOverride("editingEnabled") } }, {
                  key: "defaultPopupTemplate",
                  get: function () { return e.isSome(this.associatedLayer) || this.attributeStorageInfo ? this.createPopupTemplate() : null }
                }, { key: "displayField", get: function () { return e.isSome(this.associatedLayer) ? this.associatedLayer.displayField : null } }]); return ra
          }(N.SceneService(F.ArcGISService(K.OperationalLayer(P.PortalLayer(L.ScaleRangeLayer(g.MultiOriginJSONMixin(M.APIKeyMixin(J)))))))); c.__decorate([A.property({
            types: { key: "type", base: O.default, typeMap: { selection: R } }, json: {
              origins: {
                "web-scene": {
                  name: "layerDefinition.featureReduction",
                  write: !0
                }, "portal-item": { name: "layerDefinition.featureReduction", write: !0 }
              }
            }
          })], g.prototype, "featureReduction", void 0); c.__decorate([A.property({ type: [ea.default], json: { read: !1, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: !0 }, "portal-item": { name: "layerDefinition.rangeInfos", write: !0 } } } })], g.prototype, "rangeInfos", void 0); c.__decorate([A.property({ json: { read: !1 } })], g.prototype, "associatedLayer", void 0); c.__decorate([A.property({ type: ["show", "hide"] })], g.prototype, "listMode", void 0);
          c.__decorate([A.property({ type: ["ArcGISSceneServiceLayer"] })], g.prototype, "operationalLayerType", void 0); c.__decorate([A.property({ json: { read: !1 }, readOnly: !0 })], g.prototype, "type", void 0); c.__decorate([A.property({ ...u.fields, readOnly: !0, json: { read: !1, origins: { service: { read: !0 } } } })], g.prototype, "fields", void 0); c.__decorate([A.property()], g.prototype, "types", null); c.__decorate([A.property()], g.prototype, "typeIdField", null); c.__decorate([A.property()], g.prototype, "formTemplate", null); c.__decorate([A.property({ readOnly: !0 })],
            g.prototype, "fieldsIndex", null); c.__decorate([A.property({ type: ka, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], g.prototype, "floorInfo", void 0); c.__decorate([A.property(u.outFields)], g.prototype, "outFields", void 0); c.__decorate([A.property({ type: Y.I3SNodePageDefinition, readOnly: !0, json: { read: !1 } })], g.prototype, "nodePages", void 0); c.__decorate([E.reader("service", "nodePages", ["nodePages", "pointNodePages"])], g.prototype, "readNodePages", null); c.__decorate([A.property({
              type: [Y.I3SMaterialDefinition],
              readOnly: !0
            })], g.prototype, "materialDefinitions", void 0); c.__decorate([A.property({ type: [Y.I3STextureSetDefinition], readOnly: !0 })], g.prototype, "textureSetDefinitions", void 0); c.__decorate([A.property({ type: [Y.I3SGeometryDefinition], readOnly: !0 })], g.prototype, "geometryDefinitions", void 0); c.__decorate([A.property({ readOnly: !0 })], g.prototype, "serviceUpdateTimeStamp", void 0); c.__decorate([A.property({ readOnly: !0 })], g.prototype, "attributeStorageInfo", void 0); c.__decorate([A.property({ readOnly: !0 })], g.prototype,
              "statisticsInfo", void 0); c.__decorate([A.property({ type: String, json: { origins: { service: { read: !1, write: !1 } }, name: "layerDefinition.definitionExpression", write: { enabled: !0, allowNull: !0 } } })], g.prototype, "definitionExpression", void 0); c.__decorate([A.property({ type: String, json: { origins: { "web-scene": { read: !0, write: !0 } }, read: !1 } })], g.prototype, "path", void 0); c.__decorate([A.property(I.elevationInfo)], g.prototype, "elevationInfo", null); c.__decorate([A.property({ type: String })], g.prototype, "geometryType", null);
          c.__decorate([A.property(I.labelsVisible)], g.prototype, "labelsVisible", void 0); c.__decorate([A.property({ type: [fa], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: ha.reader }, write: !1 } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: ha.reader }, write: !0 } })], g.prototype, "labelingInfo", void 0); c.__decorate([A.property(I.legendEnabled)], g.prototype, "legendEnabled", void 0); c.__decorate([A.property({
            type: Number, json: {
              origins: {
                "web-document": {
                  default: 1, write: {
                    enabled: !0,
                    target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } }
                  }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(ma, ra) { var Aa, za; if ("number" === typeof ma && 0 <= ma && 1 >= ma) return ma; ma = null == (Aa = ra.layerDefinition) ? void 0 : null == (za = Aa.drawingInfo) ? void 0 : za.transparency; return void 0 !== ma ? U.transparencyToOpacity(ma) : void 0 } }
                }, "portal-item": { write: !0 }, service: { read: !1 }
              }
            }
          })], g.prototype, "opacity", void 0); c.__decorate([A.property({
            types: f.webSceneRendererTypes,
            json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: !0 }, value: null
          })], g.prototype, "renderer", null); c.__decorate([A.property({ json: { read: !1 } })], g.prototype, "cachedDrawingInfo", void 0); c.__decorate([E.reader("service", "cachedDrawingInfo")], g.prototype, "readCachedDrawingInfo", null); c.__decorate([A.property({ readOnly: !0, json: { read: !1 } })], g.prototype, "capabilities", null); c.__decorate([A.property({ type: Boolean, json: { read: !1 } })], g.prototype, "editingEnabled",
            null); c.__decorate([A.property(I.popupEnabled)], g.prototype, "popupEnabled", void 0); c.__decorate([A.property({ type: q, json: { name: "popupInfo", write: !0 } })], g.prototype, "popupTemplate", void 0); c.__decorate([A.property({ readOnly: !0, json: { read: !1 } })], g.prototype, "defaultPopupTemplate", null); c.__decorate([A.property({ type: String, json: { read: !1 } })], g.prototype, "objectIdField", void 0); c.__decorate([E.reader("service", "objectIdField", ["objectIdField", "fields"])], g.prototype, "readObjectIdField", null); c.__decorate([A.property({
              type: String,
              json: { read: !1 }
            })], g.prototype, "globalIdField", void 0); c.__decorate([E.reader("service", "globalIdField", ["globalIdField", "fields"])], g.prototype, "readGlobalIdField", null); c.__decorate([A.property({ readOnly: !0, type: String, json: { read: !1 } })], g.prototype, "displayField", null); c.__decorate([A.property({ type: String, json: { read: !1 } })], g.prototype, "profile", void 0); c.__decorate([E.reader("service", "profile", ["store.profile"])], g.prototype, "readProfile", null); c.__decorate([A.property({
              readOnly: !0, type: String,
              json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: !1 }
            })], g.prototype, "normalReferenceFrame", void 0); c.__decorate([A.property(I.screenSizePerspectiveEnabled)], g.prototype, "screenSizePerspectiveEnabled", void 0); g = c.__decorate([H.subclass("esri.layers.SceneLayer")], g); const ia = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" },
              la = { "mesh-pyramids": "mesh", points: "point", lines: "polyline", polygons: "polygon" }; return g
        })
    }, "esri/layers/mixins/SceneService": function () {
      define("require exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../request ../../core/Error ../../core/has ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/accessorSupport/originUtils ../../geometry/Extent ../../geometry/HeightModelInfo ../../geometry/SpatialReference ../support/arcgisLayerUrl ../support/commonProperties ../support/I3SIndexInfo ../../portal/Portal ../../portal/PortalItem ../../webdoc/support/saveUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E) {
          const H = p.getLogger("esri.layers.mixins.SceneService"), J = { getTypeKeywords: () => [], portalItemLayerType: "unknown", validationOptions: { enabled: !0, ignoreUnsupported: !1, failPolicy: "throw" } }; w.SCENE_SERVICE_ITEM_TYPE = "Scene Service"; w.SceneService = M => {
            M = function (F) {
              function K() {
                var L = F.apply(this, arguments) || this; L.spatialReference = null; L.fullExtent = null; L.heightModelInfo = null; L.minScale = 0; L.maxScale = 0; L.version = {
                  major: Number.NaN, minor: Number.NaN,
                  versionString: ""
                }; L.copyright = null; L.sublayerTitleMode = "item-title"; L.title = null; L.layerId = null; L.indexInfo = null; L._debouncedSaveOperations = h.debounce(function () { var N = c._asyncToGenerator(function* (G, I, O) { switch (G) { case 0: return L._save(I); case 1: return L._saveAs(O, I) } }); return function (G, I, O) { return N.apply(this, arguments) } }()); return L
              } c._inheritsLoose(K, F); var P = K.prototype; P.readSpatialReference = function (L, N) { return this._readSpatialReference(N) }; P._readSpatialReference = function (L) {
                if (null != L.spatialReference) return r.fromJSON(L.spatialReference);
                L = L.store; L = (L = L.indexCRS || L.geographicCRS) && parseInt(L.substring(L.lastIndexOf("/") + 1, L.length), 10); return null != L ? new r(L) : null
              }; P.readFullExtent = function (L, N, G) {
                if (null != L && "object" === typeof L) return N = null == L.spatialReference ? { ...L, spatialReference: this._readSpatialReference(N) } : L, x.fromJSON(N, G); G = N.store; N = this._readSpatialReference(N); return null == N || null == G || null == G.extent || !Array.isArray(G.extent) || G.extent.some(I => -1E38 > I) ? null : new x({
                  xmin: G.extent[0], ymin: G.extent[1], xmax: G.extent[2], ymax: G.extent[3],
                  spatialReference: N
                })
              }; P.parseVersionString = function (L) { const N = { major: Number.NaN, minor: Number.NaN, versionString: L }; L = L.split("."); 2 <= L.length && (N.major = parseInt(L[0], 10), N.minor = parseInt(L[1], 10)); return N }; P.readVersion = function (L, N) { L = N.store; return this.parseVersionString(null != L.version ? L.version.toString() : "") }; P.readTitlePortalItem = function (L) { return "item-title" !== this.sublayerTitleMode ? void 0 : L }; P.readTitleService = function (L, N) {
                L = this.portalItem && this.portalItem.title; if ("item-title" === this.sublayerTitleMode) return A.titleFromUrlAndName(this.url,
                  N.name); N = N.name; if (!N && this.url) { const G = A.parse(this.url); l.isSome(G) && (N = G.title) } "item-title-and-service-name" === this.sublayerTitleMode && L && (N = L + " - " + N); return A.cleanTitle(N)
              }; P.writeUrl = function (L, N, G, I) { A.writeUrlWithLayerId(this, L, "layers", N, I) }; P._fetchIndexAndUpdateExtent = function () {
                var L = c._asyncToGenerator(function* (N, G) { this.indexInfo = B.fetchIndexInfo(this.parsedUrl.path, this.rootNode, N, this.apiKey, H, G); null == this.fullExtent || this.fullExtent.hasZ || this._updateExtent(yield this.indexInfo) });
                return function (N, G) { return L.apply(this, arguments) }
              }(); P._updateExtent = function (L) {
                if ("page" === (null == L ? void 0 : L.type)) {
                  var N, G, I = L.rootIndex % L.pageSize; L = null == (N = L.rootPage) ? void 0 : null == (G = N.nodes) ? void 0 : G[I]; if (null == L || null == L.obb || null == L.obb.center || null == L.obb.halfSize) throw new y("sceneservice:invalid-node-page", "Invalid node page."); -1E38 > L.obb.center[0] || null == this.fullExtent || this.fullExtent.hasZ || (N = L.obb.halfSize, G = L.obb.center[2], N = Math.sqrt(N[0] * N[0] + N[1] * N[1] + N[2] * N[2]), this.fullExtent.zmin =
                    G - N, this.fullExtent.zmax = G + N)
                } else "node" === (null == L ? void 0 : L.type) && (G = null == (I = L.rootNode) ? void 0 : I.mbs, !Array.isArray(G) || 4 !== G.length || -1E38 > G[0] || (N = G[2], G = G[3], this.fullExtent.zmin = N - G, this.fullExtent.zmax = N + G))
              }; P._fetchService = function () {
                var L = c._asyncToGenerator(function* (N) {
                  if (null == this.url) throw new y("sceneservice:url-not-set", "Scene service can not be loaded without valid portal item or url"); if (null == this.layerId && /SceneServer\/*$/i.test(this.url)) {
                    const G = yield this._fetchFirstLayerId(N);
                    null != G && (this.layerId = G)
                  } return this._fetchServiceLayer(N)
                }); return function (N) { return L.apply(this, arguments) }
              }(); P._fetchFirstLayerId = function () { var L = c._asyncToGenerator(function* (N) { N = yield u(this.url, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: N }); if (N.data && Array.isArray(N.data.layers) && 0 < N.data.layers.length) return N.data.layers[0].id }); return function (N) { return L.apply(this, arguments) } }(); P._fetchServiceLayer = function () {
                var L = c._asyncToGenerator(function* (N) {
                  N = yield u(this.parsedUrl.path,
                    { query: { f: "json", token: this.apiKey }, responseType: "json", signal: N }); N.ssl && (this.url = this.url.replace(/^http:/i, "https:")); let G = !1; N.data.layerType && "Voxel" === N.data.layerType && (G = !0); if (G) return this.read(N.data, { origin: "service", url: this.parsedUrl }), this._fetchVoxelServiceLayer(); N = N.data; this.read(N, { origin: "service", url: this.parsedUrl }); this.validateLayer(N)
                }); return function (N) { return L.apply(this, arguments) }
              }(); P._fetchVoxelServiceLayer = function () {
                var L = c._asyncToGenerator(function* (N) {
                  N = (yield u(this.parsedUrl.path +
                    "/layer", { query: { f: "json", token: this.apiKey }, responseType: "json", signal: N })).data; this.read(N, { origin: "service", url: this.parsedUrl }); this.validateLayer(N)
                }); return function (N) { return L.apply(this, arguments) }
              }(); P._ensureLoadBeforeSave = function () { var L = c._asyncToGenerator(function* () { yield this.load(); "beforeSave" in this && "function" === typeof this.beforeSave && (yield this.beforeSave()) }); return function () { return L.apply(this, arguments) } }(); P.validateLayer = function (L) { }; P._updateTypeKeywords = function (L,
                N, G) { L.typeKeywords || (L.typeKeywords = []); N = N.getTypeKeywords(); for (const I of N) L.typeKeywords.push(I); L.typeKeywords && (L.typeKeywords = L.typeKeywords.filter((I, O, R) => R.indexOf(I) === O), 1 === G && (L.typeKeywords = L.typeKeywords.filter(I => "Hosted Service" !== I))) }; P._saveAs = function () {
                  var L = c._asyncToGenerator(function* (N, G) {
                    G = { ...J, ...G }; N = D.from(N); N || (H.error("_saveAs(): requires a portal item parameter"), yield Promise.reject(new y("sceneservice:portal-item-required", "_saveAs() requires a portal item to save to")));
                    N.id && (N = N.clone(), N.id = null); const I = N.portal || C.getDefault(); yield this._ensureLoadBeforeSave(); N.type = "Scene Service"; N.portal = I; const O = { origin: "portal-item", url: null, messages: [], portal: I, portalItem: N, writtenProperties: [], blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, R = { layers: [this.write({}, O)] }; yield Promise.all(O.resources.pendingOperations); yield this._validateAgainstJSONSchema(R, O, G); N.url = this.url; N.title || (N.title = this.title); this._updateTypeKeywords(N,
                      G, 1); yield I._signIn(); yield I.user.addItem({ item: N, folder: G && G.folder, data: R }); yield E.saveResources(this.resourceReferences, O, null); this.portalItem = N; g.updateOrigins(O); return O.portalItem = N
                  }); return function (N, G) { return L.apply(this, arguments) }
                }(); P._save = function () {
                  var L = c._asyncToGenerator(function* (N) {
                    N = { ...J, ...N }; this.portalItem || (H.error("_save(): requires the .portalItem property to be set"), yield Promise.reject(new y("sceneservice:portal-item-not-set", "Portal item to save to has not been set on this SceneService")));
                    "Scene Service" !== this.portalItem.type && (H.error("_save(): Non-matching portal item type. Got " + this.portalItem.type + ", expected Scene Service"), yield Promise.reject(new y("sceneservice:portal-item-wrong-type", 'Portal item needs to have type "Scene Service"'))); yield this._ensureLoadBeforeSave(); const G = {
                      origin: "portal-item", url: this.portalItem.itemUrl && b.urlToObject(this.portalItem.itemUrl), messages: [], portal: this.portalItem.portal || C.getDefault(), portalItem: this.portalItem, writtenProperties: [],
                      blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] }
                    }, I = { layers: [this.write({}, G)] }; yield Promise.all(G.resources.pendingOperations); yield this._validateAgainstJSONSchema(I, G, N); this.portalItem.url = this.url; this.portalItem.title || (this.portalItem.title = this.title); this._updateTypeKeywords(this.portalItem, N, 0); yield this.portalItem.update({ data: I }); yield E.saveResources(this.resourceReferences, G, null); g.updateOrigins(G); return this.portalItem
                  }); return function (N) {
                    return L.apply(this,
                      arguments)
                  }
                }(); P._validateAgainstJSONSchema = function () {
                  var L = c._asyncToGenerator(function* (N, G, I) {
                    G = G.messages.filter(O => "error" === O.type).map(O => new y(O.name, O.message, O.details)); I && I.validationOptions.ignoreUnsupported && (G = G.filter(O => "layer:unsupported" !== O.name && "symbol:unsupported" !== O.name && "symbol-layer:unsupported" !== O.name && "property:unsupported" !== O.name && "url:unsupported" !== O.name && "scenemodification:unsupported" !== O.name)); if (I.validationOptions.enabled && (N = (yield new Promise((O, R) =>
                      a(["../support/schemaValidator"], O, R))).validate(N, I.portalItemLayerType), 0 < N.length)) { const O = `Layer item did not validate:\n${N.join("\n")}`; H.error(`_validateAgainstJSONSchema(): ${O}`); if ("throw" === I.validationOptions.failPolicy) throw I = N.map(R => new y("sceneservice:schema-validation", R)).concat(G), new y("sceneservice-validate:error", "Failed to save layer item due to schema validation, see `details.errors`.", { combined: I }); } if (0 < G.length) throw new y("sceneservice:save", "Failed to save SceneService due to unsupported or invalid content. See 'details.errors' for more detailed information",
                        { errors: G });
                  }); return function (N, G, I) { return L.apply(this, arguments) }
                }(); c._createClass(K, [{ key: "url", set: function (L) { L = A.sanitizeUrlWithLayerId({ layer: this, url: L, nonStandardUrlAllowed: !1, logger: H }); this._set("url", L.url); null != L.layerId && this._set("layerId", L.layerId) } }, { key: "parsedUrl", get: function () { var L = this._get("url"); if (!L) return null; L = b.urlToObject(L); null != this.layerId && (L.path = `${L.path}/layers/${this.layerId}`); return L } }]); return K
            }(M); q.__decorate([d.property(z.id)], M.prototype, "id",
              void 0); q.__decorate([d.property({ type: r })], M.prototype, "spatialReference", void 0); q.__decorate([v.reader("spatialReference", ["spatialReference", "store.indexCRS", "store.geographicCRS"])], M.prototype, "readSpatialReference", null); q.__decorate([d.property({ type: x })], M.prototype, "fullExtent", void 0); q.__decorate([v.reader("fullExtent", ["fullExtent", "store.extent", "spatialReference", "store.indexCRS", "store.geographicCRS"])], M.prototype, "readFullExtent", null); q.__decorate([d.property({ readOnly: !0, type: k })],
                M.prototype, "heightModelInfo", void 0); q.__decorate([d.property({ type: Number, json: { name: "layerDefinition.minScale", write: !0, origins: { service: { read: { source: "minScale" }, write: !1 } } } })], M.prototype, "minScale", void 0); q.__decorate([d.property({ type: Number, json: { name: "layerDefinition.maxScale", write: !0, origins: { service: { read: { source: "maxScale" }, write: !1 } } } })], M.prototype, "maxScale", void 0); q.__decorate([d.property({ readOnly: !0 })], M.prototype, "version", void 0); q.__decorate([v.reader("version", ["store.version"])],
                  M.prototype, "readVersion", null); q.__decorate([d.property({ type: String, json: { read: { source: "copyrightText" } } })], M.prototype, "copyright", void 0); q.__decorate([d.property({ type: String, json: { read: !1 } })], M.prototype, "sublayerTitleMode", void 0); q.__decorate([d.property({ type: String })], M.prototype, "title", void 0); q.__decorate([v.reader("portal-item", "title")], M.prototype, "readTitlePortalItem", null); q.__decorate([v.reader("service", "title", ["name"])], M.prototype, "readTitleService", null); q.__decorate([d.property({
                    type: Number,
                    json: { origins: { service: { read: { source: "id" } }, "portal-item": { write: { target: "id", isRequired: !0, ignoreOrigin: !0 }, read: !1 } } }
                  })], M.prototype, "layerId", void 0); q.__decorate([d.property(z.url)], M.prototype, "url", null); q.__decorate([e.writer("url")], M.prototype, "writeUrl", null); q.__decorate([d.property()], M.prototype, "parsedUrl", null); q.__decorate([d.property({ readOnly: !0 })], M.prototype, "store", void 0); q.__decorate([d.property({ type: String, readOnly: !0, json: { read: { source: "store.rootNode" } } })], M.prototype, "rootNode",
                    void 0); return M = q.__decorate([m.subclass("esri.layers.mixins.SceneService")], M)
          }; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/core/accessorSupport/originUtils": function () { define(["exports", "../multiOriginJSONSupportUtils"], function (a, w) { a.updateOrigins = function (c) { c && c.writtenProperties && c.writtenProperties.forEach(q => { const u = q.target; q.newOrigin && q.oldOrigin !== q.newOrigin && w.isMultiOriginJSONMixin(u) && u.updateOrigin(q.propName, q.newOrigin) }) }; Object.defineProperty(a, "__esModule", { value: !0 }) }) },
    "esri/core/multiOriginJSONSupportUtils": function () { define(["exports"], function (a) { a.isMultiOriginJSONMixin = function (w) { return w && "getAtOrigin" in w && "originOf" in w }; Object.defineProperty(a, "__esModule", { value: !0 }) }) }, "esri/layers/support/I3SIndexInfo": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../request", "../../core/Error", "../../core/maybe"], function (a, w, c, q, u) {
        function y() {
          y = w._asyncToGenerator(function* (n, p, l, h, b, d) {
            var f = null; if (u.isSome(l)) {
              f = `${n}/nodepages/`;
              const t = f + Math.floor(l.rootIndex / l.nodesPerPage); try { return { type: "page", rootPage: (yield c(t, { query: { f: "json", token: h }, responseType: "json", signal: d })).data, rootIndex: l.rootIndex, pageSize: l.nodesPerPage, lodMetric: l.lodSelectionMetricType, urlPrefix: f } } catch (v) { u.isSome(b) && b.warn("#fetchIndexInfo()", "Failed to load root node page. Falling back to node documents.", t, v), f = v }
            } if (!p) return null; p = p && p.split("/").pop(); n = `${n}/nodes/`; p = n + p; try {
              return {
                type: "node", rootNode: (yield c(p, {
                  query: { f: "json", token: h },
                  responseType: "json", signal: d
                })).data, urlPrefix: n
              }
            } catch (t) { throw new q("sceneservice:root-node-missing", "Root node missing.", { pageError: f, nodeError: t, url: p }); }
          }); return y.apply(this, arguments)
        } a.fetchIndexInfo = function (n, p, l, h, b, d) { return y.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/webdoc/support/saveUtils": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/asyncUtils ../../core/Error ../../core/promiseUtils ../../core/uuid ../../portal/support/resourceUtils".split(" "),
        function (a, w, c, q, u, y, n) {
          function p() {
            p = w._asyncToGenerator(function* (f, t, v) {
              if (t && t.resources) {
                var m = t.portalItem === f.portalItem ? new Set(f.paths) : new Set; f.paths.length = 0; f.portalItem = t.portalItem; var e = new Set(t.resources.toKeep.map(k => k.resource.path)), g = new Set, x = []; e.forEach(k => { m.delete(k); f.paths.push(k) }); for (const k of t.resources.toUpdate) if (m.delete(k.resource.path), e.has(k.resource.path) || g.has(k.resource.path)) {
                  const { resource: r, content: A, finish: z, error: B } = k, C = n.getSiblingOfSameTypeI(r,
                    y.generateUUID()); f.paths.push(C.path); x.push(l({ resource: C, content: A, finish: z, error: B }, v))
                } else f.paths.push(k.resource.path), x.push(b(k, v)), g.add(k.resource.path); for (const k of t.resources.toAdd) x.push(l(k, v)), f.paths.push(k.resource.path); m.forEach(k => { k = t.portalItem.resourceFromPath(k); x.push(k.portalItem.removeResource(k).catch(() => { })) }); if (0 !== x.length && (e = yield u.eachAlways(x), u.throwIfAborted(v), v = e.filter(k => "error" in k).map(k => k.error), 0 < v.length)) throw new q("save:resources", "Failed to save one or more resources",
                  { errors: v });
              }
            }); return p.apply(this, arguments)
          } function l(f, t) { return h.apply(this, arguments) } function h() { h = w._asyncToGenerator(function* (f, t) { t = yield c.result(f.resource.portalItem.addResource(f.resource, f.content, t)); if (!0 === t.ok) f.finish && f.finish(f.resource); else throw f.error && f.error(t.error), t.error; }); return h.apply(this, arguments) } function b(f, t) { return d.apply(this, arguments) } function d() {
            d = w._asyncToGenerator(function* (f, t) {
              t = yield c.result(f.resource.update(f.content, t)); if (!0 === t.ok) f.finish(f.resource);
              else throw f.error(t.error), t.error;
            }); return d.apply(this, arguments)
          } a.saveResources = function (f, t, v) { return p.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/portal/support/resourceUtils": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../request ../../core/Error ../../core/maybe ../../core/urlUtils".split(" "), function (a, w, c, q, u, y) {
        function n() {
          n = w._asyncToGenerator(function* (v, m = {}, e) {
            yield v.load(e); var g = y.join(v.itemUrl, "resources"); const { start: x =
              1, num: k = 10, sortOrder: r = "asc", sortField: A = "created" } = m; m = { query: { start: x, num: k, sortOrder: r, sortField: A, token: v.apiKey }, signal: u.get(e, "signal") }; g = yield v.portal._request(g, m); return { total: g.total, nextStart: g.nextStart, resources: g.resources.map(({ created: z, size: B, resource: C }) => ({ created: new Date(z), size: B, resource: v.resourceFromPath(C) })) }
          }); return n.apply(this, arguments)
        } function p() {
          p = w._asyncToGenerator(function* (v, m, e, g) {
            if (!v.hasPath()) throw new q(`portal-item-resource-${m}:invalid-path`, "Resource does not have a valid path");
            const x = v.portalItem; yield x.load(g); m = y.join(x.userItemUrl, "add" === m ? "addResources" : "updateResources"); const [k, r] = b(v.path); e = yield f(e); const A = new FormData; k && "." !== k && A.append("resourcesPrefix", k); A.append("fileName", r); A.append("file", e, r); A.append("f", "json"); u.isSome(g) && g.access && A.append("access", g.access); yield x.portal._request(m, { method: "post", body: A, signal: u.get(g, "signal") }); return v
          }); return p.apply(this, arguments)
        } function l() {
          l = w._asyncToGenerator(function* (v, m, e) {
            if (!m.hasPath()) throw new q("portal-item-resources-remove:invalid-path",
              "Resource does not have a valid path"); yield v.load(e); const g = y.join(v.userItemUrl, "removeResources"); yield v.portal._request(g, { method: "post", query: { resource: m.path }, signal: u.get(e, "signal") }); m.portalItem = null
          }); return l.apply(this, arguments)
        } function h() { h = w._asyncToGenerator(function* (v, m) { yield v.load(m); const e = y.join(v.userItemUrl, "removeResources"); return v.portal._request(e, { method: "post", query: { deleteAll: !0 }, signal: u.get(m, "signal") }) }); return h.apply(this, arguments) } function b(v) {
          const m =
            v.lastIndexOf("/"); return -1 === m ? [".", v] : [v.slice(0, m), v.slice(m + 1)]
        } function d(v) { { const k = y.getPathExtension(v); v = u.isNone(k) ? [v, ""] : [v.slice(0, v.length - k.length - 1), `.${k}`] } const [m, e] = v, [g, x] = b(m); return [g, x, e] } function f(v) { return t.apply(this, arguments) } function t() { t = w._asyncToGenerator(function* (v) { return v instanceof Blob ? v : (yield c(v.url, { responseType: "blob" })).data }); return t.apply(this, arguments) } a.addOrUpdateResource = function (v, m, e, g) { return p.apply(this, arguments) }; a.contentToBlob = f;
        a.fetchResources = function (v) { return n.apply(this, arguments) }; a.getSiblingOfSameType = function (v, m) { if (!v.hasPath()) return null; const [e, , g] = d(v.path); return v.portalItem.resourceFromPath(y.join(e, m + g)) }; a.getSiblingOfSameTypeI = function (v, m) { if (!v.hasPath()) return null; const [e, , g] = d(v.path); return v.portalItem.resourceFromPath(y.join(e, m + g)) }; a.removeAllResources = function (v, m) { return h.apply(this, arguments) }; a.removeResource = function (v, m, e) { return l.apply(this, arguments) }; a.splitPrefixFileNameAndExtension =
          d; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/support/capabilities": function () {
      define(["exports"], function (a) {
      a.zeroCapabilities = {
        attachment: { supportsContentType: !1, supportsExifInfo: !1, supportsKeywords: !1, supportsName: !1, supportsSize: !1 }, data: { isVersioned: !1, supportsAttachment: !1, supportsM: !1, supportsZ: !1 }, editing: {
          supportsDeleteByAnonymous: !1, supportsDeleteByOthers: !1, supportsGeometryUpdate: !1, supportsGlobalId: !1, supportsReturnServiceEditsInSourceSpatialReference: !1, supportsRollbackOnFailure: !1,
          supportsUpdateByAnonymous: !1, supportsUpdateByOthers: !1, supportsUpdateWithoutM: !1, supportsUploadWithItemId: !1
        }, metadata: { supportsAdvancedFieldProperties: !1 }, operations: { supportsCalculate: !1, supportsTruncate: !1, supportsValidateSql: !1, supportsAdd: !1, supportsDelete: !1, supportsEditing: !1, supportsChangeTracking: !1, supportsQuery: !1, supportsQueryAttachments: !1, supportsResizeAttachments: !1, supportsSync: !1, supportsUpdate: !1, supportsExceedsLimitStatistics: !1 }, queryRelated: {
          supportsCount: !1, supportsOrderBy: !1,
          supportsPagination: !1
        }, query: {
          maxRecordCount: 0, maxRecordCountFactor: 0, standardMaxRecordCount: 0, supportsCacheHint: !1, supportsCentroid: !1, supportsDisjointSpatialRelationship: !1, supportsDistance: !1, supportsDistinct: !1, supportsExtent: !1, supportsFormatPBF: !1, supportsGeometryProperties: !1, supportsHavingClause: !1, supportsHistoricMoment: !1, supportsMaxRecordCountFactor: !1, supportsOrderBy: !1, supportsPagination: !1, supportsPercentileStatistics: !1, supportsQuantization: !1, supportsQuantizationEditMode: !1, supportsQueryByOthers: !1,
          supportsQueryGeometry: !1, supportsResultType: !1, supportsSqlExpression: !1, supportsStandardizedQueriesOnly: !1, supportsTopFeaturesQuery: !1, supportsStatistics: !1, tileMaxRecordCount: 0
        }
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/support/FetchAssociatedFeatureLayer": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../kernel ../../request ../../core/maybe ../../core/promiseUtils ../FeatureLayer ../../portal/Portal ../../portal/PortalItem".split(" "), function (a, w,
        c, q, u, y, n, p, l) {
          let h = function () {
            function b(f, t, v, m) { this.parsedUrl = f; this.portalItem = t; this.apiKey = v; this.signal = m; this.rootDocument = null; if (f = this.parsedUrl.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i)) this.urlParts = { root: f[1], layerId: parseInt(f[2], 10) } } var d = b.prototype; d.fetch = function () {
              var f = w._asyncToGenerator(function* () {
                var t; if (!this.urlParts) return null; const v = null != (t = this.portalItem) ? t : yield this.portalItemFromServiceItemId(); if (u.isNone(v)) return this.loadFromUrl(); t = yield this.findAndLoadRelatedPortalItem(v);
                return u.isNone(t) ? null : this.loadFeatureLayerFromPortalItem(t)
              }); return function () { return f.apply(this, arguments) }
            }(); d.fetchPortalItem = function () { var f = w._asyncToGenerator(function* () { var t; if (!this.urlParts) return null; const v = null != (t = this.portalItem) ? t : yield this.portalItemFromServiceItemId(); return u.isNone(v) ? null : this.findAndLoadRelatedPortalItem(v) }); return function () { return f.apply(this, arguments) } }(); d.fetchRootDocument = function () {
              var f = w._asyncToGenerator(function* () {
                if (u.isSome(this.rootDocument)) return this.rootDocument;
                if (u.isNone(this.urlParts)) return this.rootDocument = {}, {}; const t = { query: { f: "json", token: this.apiKey }, responseType: "json", signal: this.signal }, v = `${this.urlParts.root}/SceneServer`; try { this.rootDocument = (yield q(v, t)).data } catch{ this.rootDocument = {} } return this.rootDocument
              }); return function () { return f.apply(this, arguments) }
            }(); d.fetchServiceOwningPortalUrl = function () {
              var f = w._asyncToGenerator(function* () {
                var t; const v = null == (t = c.id) ? void 0 : t.findServerInfo(this.parsedUrl.path); if (null != v && v.owningSystemUrl) return v.owningSystemUrl;
                t = this.parsedUrl.path.replace(/(.*\/rest)\/.*/i, "$1") + "/info"; try { const m = (yield q(t, { query: { f: "json" }, responseType: "json", signal: this.signal })).data.owningSystemUrl; if (m) return m } catch (m) { y.throwIfAbortError(m) } return null
              }); return function () { return f.apply(this, arguments) }
            }(); d.findAndLoadRelatedPortalItem = function () {
              var f = w._asyncToGenerator(function* (t) {
                try {
                  return (yield t.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, { signal: this.signal })).find(v => "Feature Service" ===
                    v.type) || null
                } catch (v) { return y.throwIfAbortError(v), null }
              }); return function (t) { return f.apply(this, arguments) }
            }(); d.loadFeatureLayerFromPortalItem = function () { var f = w._asyncToGenerator(function* (t) { yield t.load({ signal: this.signal }); const v = yield this.findMatchingAssociatedSublayerUrl(t.url); return (new n({ url: v, portalItem: t })).load({ signal: this.signal }) }); return function (t) { return f.apply(this, arguments) } }(); d.loadFromUrl = function () {
              var f = w._asyncToGenerator(function* () {
                const t = yield this.findMatchingAssociatedSublayerUrl(`${this.urlParts.root}/FeatureServer`);
                return (new n({ url: t })).load({ signal: this.signal })
              }); return function () { return f.apply(this, arguments) }
            }(); d.findMatchingAssociatedSublayerUrl = function () {
              var f = w._asyncToGenerator(function* (t) {
                t = t.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i, "$1"); var v = { query: { f: "json" }, responseType: "json", authMode: "no-prompt", signal: this.signal }; const m = this.urlParts.layerId; var e = this.fetchRootDocument(); v = q(t, v); const [g, x] = yield Promise.all([v, e]); e = x && x.layers; v = g.data && g.data.layers; if (!Array.isArray(v)) throw Error("expected layers array");
                if (!Array.isArray(e)) { if (m < v.length) return `${t}/${v[m].id}` } else for (let k = 0; k < Math.min(e.length, v.length); k++)if (e[k].id === m) return `${t}/${v[k].id}`; throw Error("could not find matching associated sublayer");
              }); return function (t) { return f.apply(this, arguments) }
            }(); d.portalItemFromServiceItemId = function () {
              var f = w._asyncToGenerator(function* () {
                var t = (yield this.fetchRootDocument()).serviceItemId; if (!t) return null; t = new l({ id: t, apiKey: this.apiKey }); const v = yield this.fetchServiceOwningPortalUrl(); u.isSome(v) &&
                  (t.portal = new p({ url: v })); try { return t.load({ signal: this.signal }) } catch (m) { return y.throwIfAbortError(m), null }
              }); return function () { return f.apply(this, arguments) }
            }(); return b
          }(); a.FetchAssociatedFeatureLayer = h; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/support/I3SLayerDefinitions": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
        a.I3SNodePageDefinition = function (b) { function d() { var f = b.apply(this, arguments) || this; f.nodesPerPage = null; f.rootIndex = 0; f.lodSelectionMetricType = null; return f } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([u.property({ type: Number })], a.I3SNodePageDefinition.prototype, "nodesPerPage", void 0); c.__decorate([u.property({ type: Number })], a.I3SNodePageDefinition.prototype, "rootIndex", void 0); c.__decorate([u.property({ type: String })], a.I3SNodePageDefinition.prototype,
          "lodSelectionMetricType", void 0); a.I3SNodePageDefinition = c.__decorate([h.subclass("esri.layer.support.I3SNodePageDefinition")], a.I3SNodePageDefinition); a.I3SMaterialTexture = function (b) { function d() { var f = b.apply(this, arguments) || this; f.factor = 1; return f } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([u.property({ type: Number, json: { read: { source: "textureSetDefinitionId" } } })], a.I3SMaterialTexture.prototype, "id", void 0); c.__decorate([u.property({ type: Number })], a.I3SMaterialTexture.prototype,
            "factor", void 0); a.I3SMaterialTexture = c.__decorate([h.subclass("esri.layer.support.I3SMaterialTexture")], a.I3SMaterialTexture); a.I3SMaterialPBRMetallicRoughness = function (b) { function d() { var f = b.apply(this, arguments) || this; f.baseColorFactor = [1, 1, 1, 1]; f.baseColorTexture = null; f.metallicRoughnessTexture = null; f.metallicFactor = 1; f.roughnessFactor = 1; return f } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([u.property({ type: [Number] })], a.I3SMaterialPBRMetallicRoughness.prototype, "baseColorFactor",
              void 0); c.__decorate([u.property({ type: a.I3SMaterialTexture })], a.I3SMaterialPBRMetallicRoughness.prototype, "baseColorTexture", void 0); c.__decorate([u.property({ type: a.I3SMaterialTexture })], a.I3SMaterialPBRMetallicRoughness.prototype, "metallicRoughnessTexture", void 0); c.__decorate([u.property({ type: Number })], a.I3SMaterialPBRMetallicRoughness.prototype, "metallicFactor", void 0); c.__decorate([u.property({ type: Number })], a.I3SMaterialPBRMetallicRoughness.prototype, "roughnessFactor", void 0); a.I3SMaterialPBRMetallicRoughness =
                c.__decorate([h.subclass("esri.layer.support.I3SMaterialPBRMetallicRoughness")], a.I3SMaterialPBRMetallicRoughness); a.I3SMaterialDefinition = function (b) { function d() { var f = b.apply(this, arguments) || this; f.alphaMode = "opaque"; f.alphaCutoff = .25; f.doubleSided = !1; f.cullFace = "none"; f.normalTexture = null; f.occlusionTexture = null; f.emissiveTexture = null; f.emissiveFactor = null; f.pbrMetallicRoughness = null; return f } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([l.enumeration({
                  opaque: "opaque", mask: "mask",
                  blend: "blend"
                })], a.I3SMaterialDefinition.prototype, "alphaMode", void 0); c.__decorate([u.property({ type: Number })], a.I3SMaterialDefinition.prototype, "alphaCutoff", void 0); c.__decorate([u.property({ type: Boolean })], a.I3SMaterialDefinition.prototype, "doubleSided", void 0); c.__decorate([l.enumeration({ none: "none", back: "back", front: "front" })], a.I3SMaterialDefinition.prototype, "cullFace", void 0); c.__decorate([u.property({ type: a.I3SMaterialTexture })], a.I3SMaterialDefinition.prototype, "normalTexture", void 0);
          c.__decorate([u.property({ type: a.I3SMaterialTexture })], a.I3SMaterialDefinition.prototype, "occlusionTexture", void 0); c.__decorate([u.property({ type: a.I3SMaterialTexture })], a.I3SMaterialDefinition.prototype, "emissiveTexture", void 0); c.__decorate([u.property({ type: [Number] })], a.I3SMaterialDefinition.prototype, "emissiveFactor", void 0); c.__decorate([u.property({ type: a.I3SMaterialPBRMetallicRoughness })], a.I3SMaterialDefinition.prototype, "pbrMetallicRoughness", void 0); a.I3SMaterialDefinition = c.__decorate([h.subclass("esri.layer.support.I3SMaterialDefinition")],
            a.I3SMaterialDefinition); a.I3STextureFormat = function (b) { function d() { return b.apply(this, arguments) || this } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([u.property({ type: String, json: { read: { source: ["name", "index"], reader: (b, d) => null != b ? b : `${d.index}` } } })], a.I3STextureFormat.prototype, "name", void 0); c.__decorate([l.enumeration({ jpg: "jpg", png: "png", dds: "dds", "ktx-etc2": "ktx-etc2", ktx2: "ktx2", basis: "basis" })], a.I3STextureFormat.prototype, "format", void 0); a.I3STextureFormat = c.__decorate([h.subclass("esri.layer.support.I3STextureFormat")],
              a.I3STextureFormat); a.I3STextureSetDefinition = function (b) { function d() { var f = b.apply(this, arguments) || this; f.atlas = !1; return f } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([u.property({ type: [a.I3STextureFormat] })], a.I3STextureSetDefinition.prototype, "formats", void 0); c.__decorate([u.property({ type: Boolean })], a.I3STextureSetDefinition.prototype, "atlas", void 0); a.I3STextureSetDefinition = c.__decorate([h.subclass("esri.layer.support.I3STextureSetDefinition")], a.I3STextureSetDefinition);
          a.I3SGeometryAttribute = function (b) { function d() { return b.apply(this, arguments) || this } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([l.enumeration({ Float32: "Float32", UInt64: "UInt64", UInt32: "UInt32", UInt16: "UInt16", UInt8: "UInt8" })], a.I3SGeometryAttribute.prototype, "type", void 0); c.__decorate([u.property({ type: Number })], a.I3SGeometryAttribute.prototype, "component", void 0); a.I3SGeometryAttribute = c.__decorate([h.subclass("esri.layer.support.I3SGeometryAttribute")], a.I3SGeometryAttribute);
          a.I3SGeometryCompressedAttributes = function (b) { function d() { return b.apply(this, arguments) || this } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([l.enumeration({ draco: "draco" })], a.I3SGeometryCompressedAttributes.prototype, "encoding", void 0); c.__decorate([u.property({ type: [String] })], a.I3SGeometryCompressedAttributes.prototype, "attributes", void 0); a.I3SGeometryCompressedAttributes = c.__decorate([h.subclass("esri.layer.support.I3SGeometryCompressedAttributes")], a.I3SGeometryCompressedAttributes);
          a.I3SGeometryBuffer = function (b) { function d() { var f = b.apply(this, arguments) || this; f.offset = 0; return f } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([u.property({ type: Number })], a.I3SGeometryBuffer.prototype, "offset", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })], a.I3SGeometryBuffer.prototype, "position", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })], a.I3SGeometryBuffer.prototype, "normal", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })],
            a.I3SGeometryBuffer.prototype, "uv0", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })], a.I3SGeometryBuffer.prototype, "color", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })], a.I3SGeometryBuffer.prototype, "uvRegion", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })], a.I3SGeometryBuffer.prototype, "featureId", void 0); c.__decorate([u.property({ type: a.I3SGeometryAttribute })], a.I3SGeometryBuffer.prototype, "faceRange", void 0); c.__decorate([u.property({ type: a.I3SGeometryCompressedAttributes })],
              a.I3SGeometryBuffer.prototype, "compressedAttributes", void 0); a.I3SGeometryBuffer = c.__decorate([h.subclass("esri.layer.support.I3SGeometryBuffer")], a.I3SGeometryBuffer); a.I3SGeometryDefinition = function (b) { function d() { return b.apply(this, arguments) || this } w._inheritsLoose(d, b); return d }(q.JSONSupport); c.__decorate([l.enumeration({ triangle: "triangle" })], a.I3SGeometryDefinition.prototype, "topology", void 0); c.__decorate([u.property()], a.I3SGeometryDefinition.prototype, "geometryBuffers", void 0); a.I3SGeometryDefinition =
                c.__decorate([h.subclass("esri.layer.support.I3SGeometryDefinition")], a.I3SGeometryDefinition); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/support/RangeInfo": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p, l) {
      a.RangeInfo =
        function (h) { function b() { var d = h.apply(this, arguments) || this; d.name = null; d.field = null; d.currentRangeExtent = null; d.fullRangeExtent = null; d.type = "rangeInfo"; return d } w._inheritsLoose(b, h); return b }(q.JSONSupport); c.__decorate([u.property({ type: String, json: { read: !0, write: !0 } })], a.RangeInfo.prototype, "name", void 0); c.__decorate([u.property({ type: String, json: { read: !0, write: !0 } })], a.RangeInfo.prototype, "field", void 0); c.__decorate([u.property({ type: [Number], json: { read: !0, write: !0 } })], a.RangeInfo.prototype,
          "currentRangeExtent", void 0); c.__decorate([u.property({ type: [Number], json: { read: !0, write: !0 } })], a.RangeInfo.prototype, "fullRangeExtent", void 0); c.__decorate([u.property({ type: ["rangeInfo"], readOnly: !0, json: { read: !1, write: !0 } })], a.RangeInfo.prototype, "type", void 0); a.RangeInfo = c.__decorate([l.subclass("esri.layers.support.RangeInfo")], a.RangeInfo); a.default = a.RangeInfo; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/FeatureLayerView3D": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Error ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/projection ../../../support/featureFlags ./FeatureLayerViewBase3D".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          u = function (d) {
            function f() { var t = d.apply(this, arguments) || this; t.type = "feature-3d"; t.direct3DObjectFeatureLayerDisplayEnabled = h.enableDirect3DObjectFeatureLayerDisplay(); return t } a._inheritsLoose(f, d); f.prototype.initialize = function () {
              this.layer.infoFor3D && !this.direct3DObjectFeatureLayerDisplayEnabled && this.addResolvingPromise(Promise.reject(new c("featurelayerview3d:unsupported-geometry-type", `Unsupported geometry type ${this.layer.geometryType}`))); "mesh" !== this.layer.geometryType ||
                l.canProjectWithoutEngine(this.layer.spatialReference, this.view.spatialReference) || this.addResolvingPromise(Promise.reject(new c("layerview:spatial-reference-incompatible", "The spatial references of the feature layer layer is incompatible with the spatial reference of the view")))
            }; return f
          }(b); w.__decorate([q.property({ constructOnly: !0 })], u.prototype, "direct3DObjectFeatureLayerDisplayEnabled", void 0); w.__decorate([q.property()], u.prototype, "layer", void 0); return u = w.__decorate([p.subclass("esri.views.3d.layers.FeatureLayerView3D")],
            u)
        })
    }, "esri/views/3d/layers/FeatureLayerViewBase3D": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Error ../../../core/maybe ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../layers/graphics/hydratedFeatures ../../../layers/graphics/controllers/FeatureTileController3D ./FeatureLikeLayerView3D ./LayerView3D ./support/FeatureTileFetcher3DLayerViewContext ../support/EventedSet ../support/updatingProperties ../../layers/FeatureLayerView ../../layers/LayerView ../../layers/RefreshableLayerView".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k) {
          n = function (A) {
            function z(C) { C = A.call(this, C) || this; C._controllerTotal = 0; C._graphicsCoreTotal = 0; C.suspendResumeExtentMode = "data"; return C } a._inheritsLoose(z, A); var B = z.prototype; B.initialize = function () { this.updatingHandles.add(this, "view.floors", () => this.graphics3d.filterVisibility.filterChanged()) }; B.destroy = function () { this.fetcherContext && (this.fetcherContext.destroy(), this.fetcherContext = null) }; B.setVisibility = function (C, D) {
            this.graphics3d && this.graphics3d.graphicsCore.setObjectIdVisibility(C,
              D)
            }; B.createQuery = function () { return A.prototype.createQuery.call(this) }; B.queryFeatures = function (C, D) { const E = () => A.prototype.queryFeatures.call(this, C, D); return "mesh" === this.layer.geometryType ? this._queryFeaturesMesh(this._ensureQuery(C), E) : E() }; B.beforeSetController = function (C) { C.maximumNumberOfFeatures = this.maximumNumberOfFeatures }; B.createController = function () {
            this.fetcherContext = new v.FeatureTileFetcher3DLayerViewContext({ layerView: this, returnZ: this.hasZ, returnM: this.hasM }); const C = new d.FeatureTileController3D({
              layerView: this,
              context: this.fetcherContext, graphics: new m.EventedSet, extent: this.clippingExtent
            }); this.updatingHandles.add(C, "serviceDataExtent", D => { this.graphics3d && (this.graphics3d.dataExtent = D) }, 2); this.handles.add(u.init(this, "suspended", D => { D ? C.suspend() : C.resume() }, !0)); this.updatingHandles.add(this.graphics3d.graphicsCore, "displayFeatureLimit", () => this.updateDisplayFeatureLimit(C), 2); this.handles.add([this.view.resourceController.memoryController.events.on("quality-changed", () => this.updateDisplayFeatureLimit()),
            u.whenFalse(this, "updating", () => { this._graphicsCoreTotal = this._controllerTotal = 0; this.notifyChange("updatingProgressValue") })]); return C
            }; B.doRefresh = function () { var C = a._asyncToGenerator(function* (D) { D && !this.suspended && this.controller && this.controller.refetch(); this.graphics3d.filterVisibility.dirty = !0 }); return function (D) { return C.apply(this, arguments) } }(); B.getUsedMemory = function () {
              const C = this.graphics3d && this.graphics3d.graphicsCore; return (C ? C.usedMemory : 0) + (this.controller ? this.controller.memoryForUnusedFeatures :
                0)
            }; B.getUnloadedMemory = function () { const C = this.graphics3d && this.graphics3d.graphicsCore; return (C ? C.unprocessedMemoryEstimate : 0) + (this.controller ? this.controller.expectedFeatureDiff * C.usedMemoryPerGraphic : 0) }; B.ignoresMemoryFactor = function () { return this.controller && this.controller.hasMaximumNumberOfFeaturesOverride }; B.updateDisplayFeatureLimit = function (C = this.controller) {
              if (C && this.graphics3d && this.graphics3d.graphicsCore) {
                var D = this.graphics3d.graphicsCore.displayFeatureLimit, E = this.view.resourceController.memoryController.memoryFactor;
                C.displayFeatureLimit = 1 === E ? D : { ...D, maximumNumberOfFeatures: Math.ceil(D.maximumNumberOfFeatures * E), maximumTotalNumberOfFeatures: Math.ceil(D.maximumTotalNumberOfFeatures * E), minimumTotalNumberOfFeatures: Math.ceil(D.minimumTotalNumberOfFeatures * E) }
              }
            }; B._queryFeaturesMesh = function () {
              var C = a._asyncToGenerator(function* (D, E) {
                yield this._validateQueryFeaturesMesh(D); E = yield E(); if (D && D.outStatistics) return E; D = this.layer.objectIdField; const H = this.graphics3d.graphicsCore.graphics3DGraphicsByObjectID, J = [];
                for (const M of E.features) if (M.geometry) { const F = H.get(M.attributes[D]); F && (M.geometry = b.hydrateGeometry(F.graphic.geometry), J.push(M)) } else J.push(M); E.features = J; return E
              }); return function (D, E) { return C.apply(this, arguments) }
            }(); B._validateQueryFeaturesMesh = function () {
              var C = a._asyncToGenerator(function* (D) {
                if (D) {
                  var E = J => { throw new c("feature-layer-view:unsupported-query", `Queries on Mesh feature collection layers do not support '${J}'`); }, H = ["quantizationParameters", "geometryPrecision", "maxAllowableOffset"];
                  for (const J of H) null != D[J] && E(J); "returnM" in D && D.returnM && E("returnM"); "returnCentroid" in D && D.returnCentroid && E("returnCentroid"); q.isSome(D.outSpatialReference) && !D.outSpatialReference.equals(this.view.spatialReference) && E("outSpatialReference")
                }
              }); return function (D) { return C.apply(this, arguments) }
            }(); a._createClass(z, [{
              key: "maximumNumberOfFeatures", get: function () { var C, D; return null != (C = null == (D = this.controller) ? void 0 : D.maximumNumberOfFeatures) ? C : this._get("maximumNumberOfFeatures") }, set: function (C) {
                this._set("maximumNumberOfFeatures",
                  C); this.controller && (this.controller.maximumNumberOfFeatures = C)
              }
            }, { key: "maximumNumberOfFeaturesExceeded", get: function () { return this.controller ? !(this.suspended || !this.controller.maximumNumberOfFeaturesExceeded) : !1 } }, {
              key: "updatingProgressValue", get: function () {
                var C, D, E; let H = 0; if (null != (C = this.controller) && C.updating) { C = this.controller.updatingRemaining; const J = Math.max(this.controller.updatingTotal, this._controllerTotal); 0 < J && (H = (J - C) / J, this._controllerTotal = J) } C = 0; null != (D = this.graphics3d) && null !=
                  (E = D.graphicsCore) && E.updating && (D = this.graphics3d.graphicsCore.updatingRemaining, E = Math.max(D, this._graphicsCoreTotal), 0 < E && (C = (E - D) / E, this._graphicsCoreTotal = E)); return .5 * (H + C)
              }
            }, { key: "updatePolicy", get: function () { if (!this.controller) return 0; switch (this.controller.mode) { case "snapshot": { const C = r[this.layer.geometryType]; return null == C || this.controller.serviceDataCount > C ? 0 : 1 } case "tiles": return 0 } } }, {
              key: "hasZ", get: function () {
                const C = this.layer, D = C.capabilities && C.capabilities.data; return D && D.supportsZ ?
                  "returnZ" in C && null != C.returnZ ? C.returnZ : D.supportsZ : !1
              }
            }, { key: "hasM", get: function () { const C = this.layer, D = C.capabilities && C.capabilities.data; return D && D.supportsM ? "returnM" in C && null != C.returnM ? C.returnM : !1 : !1 } }, {
              key: "performanceInfo", get: function () {
                var C = this.controller && this.controller.displayFeatureLimit; C = q.isSome(C) && C.averageSymbolComplexity; C = q.isSome(C) ? `f:${C.primitivesPerFeature},v:${C.primitivesPerCoordinate}` : "n/a"; C = {
                  ...this._getResourceInfo(), storedFeatures: 0, totalVertices: 0, partial: this.maximumNumberOfFeaturesExceeded,
                  mode: this.controller ? this.controller.mode : "n/a", symbolComplexity: C, nodes: this.controller ? this.controller.tileDescriptors.length : 0
                }; if (this.controller && C.displayedNumberOfFeatures) { const D = this.controller.debug; C.storedFeatures = D.storedFeatures; C.totalVertices = D.totalVertices } return C
              }
            }, { key: "test", get: function () { return { updatePolicy: this.updatePolicy, controller: this.controller } } }]); return z
          }(k.RefreshableLayerView(f.FeatureLikeLayerView3D(g.FeatureLayerView(t.LayerView3D(x))))); w.__decorate([y.property()],
            n.prototype, "layer", void 0); w.__decorate([y.property()], n.prototype, "controller", void 0); w.__decorate([y.property()], n.prototype, "maximumNumberOfFeatures", null); w.__decorate([y.property()], n.prototype, "maximumNumberOfFeaturesExceeded", null); w.__decorate([y.property(e.updatingProgress)], n.prototype, "updatingProgress", void 0); w.__decorate([y.property({ readOnly: !0, dependsOn: ["controller.updatingRemaining", "controller.updatingTotal", "graphics3d.graphicsCore.updatingRemaining"] })], n.prototype, "updatingProgressValue",
              null); w.__decorate([y.property({ readOnly: !0 })], n.prototype, "updatePolicy", null); w.__decorate([y.property({ readOnly: !0 })], n.prototype, "hasZ", null); w.__decorate([y.property({ readOnly: !0 })], n.prototype, "hasM", null); w.__decorate([y.property()], n.prototype, "suspendResumeExtentMode", void 0); n = w.__decorate([h.subclass("esri.views.3d.layers.FeatureLayerViewBase3D")], n); const r = { point: 5E3, polygon: 500, polyline: 1E3 }; return n
        })
    }, "esri/layers/graphics/controllers/FeatureTileController3D": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/asyncUtils ../../../core/Collection ../../../core/has ../../../core/Error ../../../core/Handles ../../../core/lang ../../../core/Logger ../../../core/maybe ../../../core/Promise ../../../core/promiseUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../support/arcgisLayerUrl ../../../portal/support/geometryServiceUtils ../../../rest/support/StatisticDefinition ../../../views/3d/layers/support/FeatureTileFetcher3D ../../../views/3d/layers/support/FeatureTileFetcher3DDebugger ../../../views/3d/support/debugFlags ../../../views/support/WatchUpdatingTracking".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C) {
          function D(H, J) { if (!J) return !1; for (const M of J) if (!H.has(M)) return !0; return !1 } const E = b.getLogger("esri.layers.graphics.controllers.FeatureTileController3D"); a.FeatureTileController3D = function (H) {
            function J(F) {
              F = H.call(this, F) || this; F.type = "feature-tile-3d"; F.watchUpdatingTracking = new C.WatchUpdatingTracking; F.serviceDataExtent = null; F.serviceDataCount = a.FeatureTileController3DConstants.NO_SERVICE_DATA_COUNT; F.vertexLimitExceeded = !1; F.displayFeatureLimit =
                null; F.suspended = !1; F.tileFetcher = null; F.handles = new l; F.fetchDataInfoPromise = null; F.fetchDataInfoAbortController = null; F.lifeCycleAbortController = new AbortController; return F
            } w._inheritsLoose(J, H); var M = J.prototype; M.approximateExtentSizeAtScale = function (F, K) { const P = this.layerView.view, L = K.levels[0]; return (L.tileSize[0] / (L.scale / F) + L.tileSize[1] / (L.scale / F)) / 2 * Math.ceil((P.width / K.pixelSize + P.height / K.pixelSize) / 2) }; M.initialize = function () {
              this.watchUpdatingTracking.add(this, "vertexLimitInfo", () =>
                this.watchUpdatingTracking.addPromise(this.updateVertexLimitExceeded(null, this.lifeCycleAbortController.signal))); this.watchUpdatingTracking.add(this, "mode", () => this.modeChanged(), 2); this.addResolvingPromise(Promise.resolve().then(() => this.verifyCapabilities()).then(() => this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo())).then(() => this.initializeTileFetcher()))
            }; M.verifyCapabilities = function () {
              const F = this.layerView.layer; if (!F.get("capabilities.operations.supportsQuery") && "ogc-feature" !==
                F.type) throw new p("graphicscontroller:query-capability-required", "Service requires query capabilities to be used as a feature layer", { layer: F });
            }; M.destroy = function () {
              this.cancelFetchServiceDataInfo(); this.tileFetcher = d.destroyMaybe(this.tileFetcher); this.handles = d.destroyMaybe(this.handles); this.tilesHandle = d.removeMaybe(this.tilesHandle); this.lifeCycleAbortController && (this.lifeCycleAbortController.abort(), this.lifeCycleAbortController = null); this.watchUpdatingTracking.destroy(); this._set("watchUpdatingTracking",
                null)
            }; M.suspend = function () { this.suspended || (this.suspended = !0, d.isSome(this.tileFetcher) && this.tileFetcher.suspend()) }; M.resume = function () { this.suspended && (this.suspended = !1, d.isSome(this.tileFetcher) && this.tileFetcher.resume()) }; M.restart = function () { const F = () => { d.isSome(this.tileFetcher) && this.tileFetcher.restart() }; this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo().then(F, F)) }; M.refetch = function () {
              const F = () => { d.isSome(this.tileFetcher) && this.tileFetcher.refetch() }; this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo().then(F,
                F))
            }; M.initializeTileFetcher = function () {
              const F = this.layerView.view; if (F) {
                var K = v.whenOnce(F.featureTiles, "tilingScheme", this.lifeCycleAbortController.signal); this.watchUpdatingTracking.addPromise(K); K.then(() => {
                  const { layerView: P, tileDescriptors: L } = this, N = P.layer, G = new A.FeatureTileFetcher3D({ context: this.context, filterExtent: this.extent, tileDescriptors: L, features: this.graphics }); this.tileFetcher = G; this.suspended ? this.tileFetcher.suspend() : this.tileFetcher.resume(); var I = this.layerView.view.resourceController;
                  I && (this.handles.add(I.memoryController.events.on("quality-changed", O => { G.memoryFactor = O })), this.tileFetcher.memoryFactor = I.memoryController.memoryFactor); (I = "polygon" === this.context.geometryType ? "polygonLodFactor" : "polyline" === this.context.geometryType ? "polylineLodFactor" : null) && this.handles.add(v.init(this.layerView.view, "qualitySettings.graphics3D." + I, O => { G.lodFactor = O || 1 })); this.watchUpdatingTracking.add(N, "createQueryVersion", () => this.dataFilterChanged()); this.watchUpdatingTracking.add(P, "availableFields",
                    (O, R) => this.availableFieldsChanged(R, O)); this.watchUpdatingTracking.add(P, "requiredFields", (O, R) => this.requiredFieldsChanged(R, O)); this.handles.add([N.on("apply-edits", O => this.applyEdits(O)), this.watch("extent", O => G.filterExtent = O, !0), this.watch("tileDescriptors", O => G.tileDescriptors = O, !0), v.init(this, "maximumNumberOfFeatures", O => { G.maximumNumberOfFeatures = O; G.useTileCount = this.serviceDataCount > O }, !0), v.init(this, "serviceDataCount", O => G.useTileCount = O > this.maximumNumberOfFeatures, !0), v.init(B, "FEATURE_TILE_FETCH_SHOW_TILES",
                      O => { O && G && !G.debugger ? (G.debugger = new z.FeatureTileFetcher3DDebugger(G, F.featureTiles.tilingScheme.toTileInfo(), F), G.debugger.update()) : !O && this.tileFetcher && G.debugger && (G.debugger.destroy(), G.debugger = null) })]); this.supportsExceedsLimitQuery || this.watchUpdatingTracking.add(this, "maxTotalSnapshotVertices", () => this.watchUpdatingTracking.addPromise(this.updateVertexLimitExceeded(null, this.lifeCycleAbortController.signal)))
                }).catch(() => { })
              }
            }; M.modeChanged = function () {
              switch (this.mode) {
                case "tiles": this.tilesHandle ||
                  (this.tilesHandle = this.layerView.view.featureTiles.addClient()); break; default: E.warn("Unhandled feature layer mode " + this.mode); case "snapshot": d.isSome(this.tilesHandle) && (this.tilesHandle.remove(), this.tilesHandle = null)
              }
            }; M.dataFilterChanged = function () { this._set("maxTotalSnapshotVertices", 0); this.notifyChange("maxTotalSnapshotVertices"); this.refetch() }; M.applyEdits = function (F) {
              d.isNone(this.tileFetcher) || this.tileFetcher.applyEdits(F).then(K => {
              K && (K.deletedFeatures.length || K.updatedFeatures.length ||
                K.addedFeatures.length) && this.watchUpdatingTracking.addPromise(this.updateServiceDataExtent(this.lifeCycleAbortController.signal))
              }).catch(K => { if (!t.isAbortError(K)) throw K; })
            }; M.availableFieldsChanged = function (F, K) { d.isSome(this.tileFetcher) && D(this.tileFetcher.availableFields, K) && this.refetch() }; M.requiredFieldsChanged = function (F, K) { d.isSome(this.tileFetcher) && D(this.tileFetcher.availableFields, K) && this.restart() }; M.createVertexLimitExceededQuery = function (F) {
              const K = this.layerView.layer, P = K.createQuery();
              P.outStatistics = [new r({ statisticType: "exceedslimit", maxVertexCount: F, outStatisticFieldName: "exceedslimit", maxPointCount: 1E8, maxRecordCount: 1E8 })]; K.capabilities.query.supportsCacheHint && (P.cacheHint = !0); return P
            }; M.createDataInfoQuery = function () { const F = this.layerView.layer, K = F.createQuery(); K.outSpatialReference = this.layerView.view.spatialReference; F.capabilities.query.supportsCacheHint && (K.cacheHint = !0); return K }; M.fullExtentIsAccurate = function () {
              const F = this.layerView.layer; if (F.definitionExpression) return !1;
              switch (F.type) { case "feature": return x.isHostedAgolService(F.url); case "csv": case "geojson": case "ogc-feature": case "wfs": return !0 }
            }; M.updateServiceDataExtent = function () { var F = w._asyncToGenerator(function* (K) { try { yield this.tryUpdateServiceDataExtent(K) } catch (P) { t.isAbortError(P) || this._set("serviceDataExtent", h.clone(this.layerView.fullExtentInLocalViewSpatialReference)) } }); return function (K) { return F.apply(this, arguments) } }(); M.tryUpdateServiceDataExtent = function () {
              var F = w._asyncToGenerator(function* (K) {
                var P =
                  this.layerView; const L = P.layer, N = L.capabilities.query.supportsExtent, G = h.clone(P.fullExtentInLocalViewSpatialReference), I = L.fullExtent, O = this.fullExtentIsAccurate(), R = this.serviceDataCount; N && R <= a.FeatureTileController3DConstants.MAX_FEATURE_COUNT_FOR_EXTENT && (!G || !O) && "queryExtent" in L ? (P = this.createDataInfoQuery(), K = yield L.queryExtent(P, { timeout: a.FeatureTileController3DConstants.QUERY_EXTENT_TIMEOUT, signal: K }), this._set("serviceDataExtent", K.extent)) : G ? this._set("serviceDataExtent", G) : d.isSome(I) ?
                    (K = yield k.projectGeometry(I, P.view.spatialReference, "portalItem" in L ? L.portalItem : null, K), this._set("serviceDataExtent", K)) : this._set("serviceDataExtent", null)
              }); return function (K) { return F.apply(this, arguments) }
            }(); M.updateServiceDataCount = function () {
              var F = w._asyncToGenerator(function* (K) {
                const P = this.layerView.layer; if ("queryFeatureCount" in P) if (K = yield u.result(P.queryFeatureCount(this.createDataInfoQuery(), { timeout: a.FeatureTileController3DConstants.QUERY_STATISTICS_TIMEOUT, signal: K })), !0 ===
                  K.ok) this._set("serviceDataCount", K.value); else { if (t.isAbortError(K.error)) throw K.error; this._set("serviceDataCount", a.FeatureTileController3DConstants.NO_SERVICE_DATA_COUNT) } else this._set("serviceDataCount", a.FeatureTileController3DConstants.NO_SERVICE_DATA_COUNT)
              }); return function (K) { return F.apply(this, arguments) }
            }(); M.updateVertexLimitExceeded = function () {
              var F = w._asyncToGenerator(function* (K, P) {
                var L = this.vertexLimitInfo; if (d.isNone(L)) this._set("vertexLimitExceeded", !1); else {
                  var N = 1 < this.minimumNumberOfVerticesForGeometry;
                  if (0 >= L.primitivesPerFeature || N) {
                    var { primitivesPerFeature: G, primitivesPerCoordinate: I, maximumTotalNumberOfPrimitives: O } = L; 0 !== G && d.isSome(K) && (yield K); L = this.serviceDataCount; var R = L !== a.FeatureTileController3DConstants.NO_SERVICE_DATA_COUNT; K = R ? Math.ceil((O - L * G) / (I || 1)) : Math.ceil(O / (I || 1)); N && (K = Math.min(K, 5E6)); if (R && this.minimumNumberOfVerticesForGeometry * L > K) this._set("vertexLimitExceeded", !0); else if (this.supportsExceedsLimitQuery) if (P = yield u.result(this.layerView.layer.queryFeatures(this.createVertexLimitExceededQuery(K),
                      { timeout: a.FeatureTileController3DConstants.QUERY_STATISTICS_TIMEOUT, signal: P })), !1 === P.ok) { if (t.isAbortError(P.error)) throw P.error; this._set("vertexLimitExceeded", !1) } else (P = P.value.features[0]) && P.attributes ? this._set("vertexLimitExceeded", !!P.attributes.exceedslimit) : this._set("vertexLimitExceeded", !1); else this._set("vertexLimitExceeded", this.maxTotalSnapshotVertices > K)
                  } else this._set("vertexLimitExceeded", !1)
                }
              }); return function (K, P) { return F.apply(this, arguments) }
            }(); M.fetchServiceDataInfo =
              function () {
                var F = w._asyncToGenerator(function* () {
                  this.cancelFetchServiceDataInfo(); let K = new AbortController; const P = K.signal; var L = this.updateServiceDataCount(P); L = t.eachAlways([L, this.updateVertexLimitExceeded(L, P)]); const N = L.then(() => this.updateServiceDataExtent(P)).catch(G => { t.isAbortError(G) || E.error("#fetchServiceDataInfo()", G) }).then(() => { N === this.fetchDataInfoPromise && (this.fetchDataInfoAbortController = this.fetchDataInfoPromise = null); K = null }); K && (this.fetchDataInfoPromise = N); this.fetchDataInfoAbortController =
                    K; return L.then(() => { }, () => { })
                }); return function () { return F.apply(this, arguments) }
              }(); M.cancelFetchServiceDataInfo = function () { const F = this.fetchDataInfoAbortController; F && (this.fetchDataInfoPromise = this.fetchDataInfoAbortController = null, F.abort()) }; w._createClass(J, [{
                key: "extent", set: function (F) {
                  if (F && !F.spatialReference.equals(this.layerView.view.spatialReference)) E.error("#extent\x3d", "extent needs to be in the same spatial reference as the view"); else {
                    var K = this._get("extent"); K === F || K && F && K.equals(F) ||
                      (F = F ? F.clone() : null, this._set("extent", F))
                  }
                }
              }, { key: "updating", get: function () { return !!(d.isSome(this.tileFetcher) && this.tileFetcher.updating || null != this.fetchDataInfoPromise || "tiles" === this.mode && this.layerView.view.featureTiles && this.layerView.view.featureTiles.updating || this.watchUpdatingTracking && this.watchUpdatingTracking.updating) } }, { key: "updatingTotal", get: function () { return this.updating && d.isSome(this.tileFetcher) ? this.tileFetcher.updatingTotal : 0 } }, {
                key: "updatingRemaining", get: function () {
                  return this.updating &&
                    d.isSome(this.tileFetcher) ? this.tileFetcher.updatingRemaining : 0
                }
              }, { key: "expectedFeatureDiff", get: function () { return this.updating && d.isSome(this.tileFetcher) ? this.tileFetcher.expectedFeatureDiff : 0 } }, { key: "memoryForUnusedFeatures", get: function () { return d.isSome(this.tileFetcher) ? this.tileFetcher.memoryForUnusedFeatures : 0 } }, { key: "maximumNumberOfFeaturesExceeded", get: function () { return !(!d.isSome(this.tileFetcher) || !this.tileFetcher.maximumNumberOfFeaturesExceeded) } }, {
                key: "maximumNumberOfFeatures", get: function () {
                  return d.isSome(this.displayFeatureLimit) ?
                    this.displayFeatureLimit.maximumNumberOfFeatures : 0
                }, set: function (F) { F !== this.maximumNumberOfFeatures && (null == F ? this._clearOverride("maximumNumberOfFeatures") : this._override("maximumNumberOfFeatures", F)) }
              }, { key: "hasMaximumNumberOfFeaturesOverride", get: function () { return this._isOverridden("maximumNumberOfFeatures") } }, {
                key: "mode", get: function () {
                  var F, K, P = this.layerView.layer; if ("feature" === P.type && d.isSome(P.infoFor3D)) return "snapshot"; if (!1 === (null == (F = this.layerView.view.qualitySettings) ? void 0 : null ==
                    (K = F.graphics3D) ? void 0 : K.snapshotAvailable) || this.serviceDataCount === a.FeatureTileController3DConstants.NO_SERVICE_DATA_COUNT || this.vertexLimitExceeded) return "tiles"; F = (F = (F = this.layerView.view) && F.featureTiles) && F.tilingScheme; return P && P.minScale && this.serviceDataExtent && F && (P = this.approximateExtentSizeAtScale(P.minScale, F), (this.serviceDataExtent.width / P + this.serviceDataExtent.height / P) / 2 > a.FeatureTileController3DConstants.MAX_SNAPSHOT_MIN_SCALE_FACTOR) ? "tiles" : !this.maximumNumberOfFeatures ||
                      this.serviceDataCount <= this.maximumNumberOfFeatures ? "snapshot" : "tiles"
                }
              }, { key: "maxTotalSnapshotVertices", get: function () { const F = this._get("maxTotalSnapshotVertices") || 0, K = "snapshot" === this.mode && d.isSome(this.tileFetcher) && this.tileFetcher.totalVertices || 0; return Math.max(F, K) } }, { key: "tileDescriptors", get: function () { return "snapshot" === this.mode ? new y([{ id: "dummy-tile-full-extent", lij: [0, 0, 0] }]) : this.layerView.view.featureTiles ? this.layerView.view.featureTiles.tiles : new y } }, {
                key: "test", get: function () {
                  return {
                    fetchDataInfoPromise: this.fetchDataInfoPromise,
                    tileFetcher: this.tileFetcher
                  }
                }
              }, {
                key: "vertexLimitInfo", get: function () {
                  if (d.isNone(this.displayFeatureLimit) || d.isNone(this.displayFeatureLimit.averageSymbolComplexity)) return null; const { averageSymbolComplexity: F, maximumTotalNumberOfPrimitives: K } = this.displayFeatureLimit, { primitivesPerCoordinate: P, primitivesPerFeature: L } = F, N = this._get("vertexLimitInfo"); return d.isNone(N) || N.maximumTotalNumberOfPrimitives !== K || N.primitivesPerCoordinate !== P || N.primitivesPerFeature !== L ? {
                    primitivesPerCoordinate: P, primitivesPerFeature: L,
                    maximumTotalNumberOfPrimitives: K
                  } : N
                }
              }, { key: "supportsExceedsLimitQuery", get: function () { const F = this.layerView.layer; return F.capabilities && F.capabilities.operations && F.capabilities.operations.supportsExceedsLimitStatistics } }, { key: "minimumNumberOfVerticesForGeometry", get: function () { switch (this.layerView.layer.geometryType) { case "point": return 1; case "multipoint": return 1; case "polygon": return 4; case "polyline": return 2; case "multipatch": case "mesh": return 3; default: return 0 } } }, {
                key: "debug", get: function () {
                  return {
                    storedFeatures: d.isSome(this.tileFetcher) ?
                      this.tileFetcher.storedFeatures : 0, totalFeatures: d.isSome(this.tileFetcher) ? this.tileFetcher.totalFeatures : 0, totalVertices: d.isSome(this.tileFetcher) ? this.tileFetcher.totalVertices : 0
                  }
                }
              }]); return J
          }(f.EsriPromiseMixin(q)); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "type", void 0); c.__decorate([m.property({ constructOnly: !0 })], a.FeatureTileController3D.prototype, "graphics", void 0); c.__decorate([m.property({ constructOnly: !0 })], a.FeatureTileController3D.prototype, "layerView",
            void 0); c.__decorate([m.property({ constructOnly: !0 })], a.FeatureTileController3D.prototype, "context", void 0); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "extent", null); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "updating", null); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "watchUpdatingTracking", void 0); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "updatingTotal", null); c.__decorate([m.property()], a.FeatureTileController3D.prototype,
              "updatingRemaining", null); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "expectedFeatureDiff", null); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "memoryForUnusedFeatures", null); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "maximumNumberOfFeaturesExceeded", null); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "serviceDataExtent", void 0); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "serviceDataCount",
                void 0); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "vertexLimitExceeded", void 0); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "displayFeatureLimit", void 0); c.__decorate([m.property({ type: Number })], a.FeatureTileController3D.prototype, "maximumNumberOfFeatures", null); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "mode", null); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "maxTotalSnapshotVertices",
                  null); c.__decorate([m.property({ readOnly: !0, dependsOn: ["mode"] })], a.FeatureTileController3D.prototype, "tileDescriptors", null); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "tileFetcher", void 0); c.__decorate([m.property()], a.FeatureTileController3D.prototype, "fetchDataInfoPromise", void 0); c.__decorate([m.property({ readOnly: !0 })], a.FeatureTileController3D.prototype, "vertexLimitInfo", null); a.FeatureTileController3D = c.__decorate([g.subclass("esri.layers.graphics.controllers.FeatureTileController3D")],
                    a.FeatureTileController3D); a.FeatureTileController3DConstants = void 0; (function (H) { H.NO_SERVICE_DATA_COUNT = Infinity; H.MAX_SNAPSHOT_MIN_SCALE_FACTOR = 5; H.reset = function () { H.MAX_FEATURE_COUNT_FOR_EXTENT = 1E4; H.QUERY_STATISTICS_TIMEOUT = 12E3; H.QUERY_EXTENT_TIMEOUT = 1E4 } })(a.FeatureTileController3DConstants || (a.FeatureTileController3DConstants = {})); a.FeatureTileController3DConstants.reset(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/FeatureTileFetcher3D": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/Logger ../../../../core/MapUtils ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/scheduling ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/support/aaBoundingRect ../../../../layers/graphics/dehydratedFeatures ../../../../rest/support/QuantizationParameters ../../../../rest/support/Query ./featureReference ./FeatureTile ../../terrain/tileUtils ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B) {
          function C(P) { return "dummy-tile-full-extent" === P.id } function D(P) { let L = 0; for (const N of P) N.features && 0 < N.features.length && N.alive && (L = Math.max(L, N.descriptor.lij[0])); return L } function E(P) { P.setFeatures([], 0, null); P.featuresMissing = !1; return 4 } function H(P) { return p.isNone(P) ? new Set : new Set(P.map(L => L.name)) } function J(P, L) { if (p.isNone(P) || p.isNone(L)) return H(L); const N = new Set; for (const { name: G } of L) P.has(G) && N.add(G); return N } const M =
            y.getLogger("esri.views.3d.layers.support.FeatureTileFetcher3D"); a.FeatureTileFetcher3D = function (P) {
              function L(G) {
                G = P.call(this, G) || this; G._useTileCount = !1; G.updating = !1; G.updatingTotal = 0; G.updatingRemaining = 0; G.expectedFeatureDiff = 0; G.maximumNumberOfFeaturesExceeded = !1; G.maximumNumberOfFeaturesExceededThrottle = 1E3; G._fullRatio = 1; G._farRatio = 1; G.changes = { updates: { adds: [], removes: [] }, adds: [], removes: [] }; G.handles = new u; G._frameTask = B.ImmediateTask; G._dirty = !1; G.featureTiles = new Map; G.displayingFeatureReferences =
                  new Map; G.numDisplayingFeatureReferences = 0; G.suspended = !0; G.pendingEdits = null; return G
              } w._inheritsLoose(L, P); var N = L.prototype; N.initialize = function () {
                this.handles.add(b.on(this, "tileDescriptors", "change", () => this.setDirty(), () => this.setDirty())); this.objectIdField = this.context.objectIdField; this.FeatureReferenceClass = this.context.capabilities.supportsMultipleResolutions ? r.MultiFeatureReference : r.SingleFeatureReference; const G = this.context.scheduler; p.isSome(G) && (this._frameTask = G.registerTask(B.TaskPriority.FEATURE_TILE_FETCHER,
                  this)); this.setDirty()
              }; N.destroy = function () { this._frameTask.remove(); this.handles = p.destroyMaybe(this.handles); this.featureTiles.forEach(G => { this.cancelFetchTile(G); this.removeTile(G) }); this.featureTiles.clear(); this.displayingFeatureReferences.clear(); this.pendingEdits && (this.pendingEdits.controller.abort(), this.pendingEdits = null) }; N.restart = function () {
                this.featureTiles.forEach(G => { this.cancelFetchTile(G); this.clearTile(G); this.resetFetchTile(G) }); p.isSome(this.context.memoryCache) && this.context.memoryCache.clear();
                this.setDirty()
              }; N.refetch = function () { this.featureTiles.forEach(G => { this.cancelFetchTile(G); this.resetFetchTile(G) }); p.isSome(this.context.memoryCache) && this.context.memoryCache.clear(); this.setDirty() }; N.suspend = function () { this.suspended || (this.suspended = !0, this.pause(), this.setDirty()) }; N.resume = function () { this.suspended && (this.suspended = !1, this.unpause()) }; N.pause = function () { this.paused && (this.featureTiles.forEach(G => this.cancelFetchTile(G)), this.updated()) }; N.unpause = function () {
              this.paused || (this.setDirty(),
                this.updated())
              }; N.applyEdits = function (G) {
              this.pendingEdits || (this.pendingEdits = { edits: Promise.resolve(), count: 0, controller: new AbortController }, this.pause()); const I = this.pendingEdits; I.count++; const O = I.edits.then(() => G.result.catch(R => { if (l.isAbortError(R)) throw R; return null }).then(R => { if (!R) return R; this.applyEditsDeleteFeatures(R.deletedFeatures); return this.applyEditsAddUpdateFeatures(R.addedFeatures, R.updatedFeatures, I.controller.signal).then(() => R) }).then(R => {
              0 === --I.count && (this.pendingEdits ===
                I && (this.pendingEdits = null), p.isSome(this.context.memoryCache) && this.context.memoryCache.clear(), this.unpause(), this.updated()); return R
              })); I.edits = O; this.updated(); return O
              }; N.applyEditsDeleteFeatures = function (G) {
                if (0 !== G.length) {
                  var I = this.context.globalIdField, O = I && this.availableFields.has(I), R = new Set, S = this.objectIdField; G.forEach(({ objectId: Q, globalId: T }) => {
                  (!Q || 0 > Q) && I ? (O || M.errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${I} to be included the layer's outFields for updates to be reflected in the view`),
                    (Q = this.features.find(da => da.attributes && da.attributes[I] === T)) && R.add(g.getObjectId(Q, S))) : R.add(Q)
                  }); this.featureTiles.forEach(Q => { if (Q.features) { var T = Q.features.filter(da => !R.has(g.getObjectId(da, this.objectIdField))); T.length !== Q.features.length && (Q.setFeatures(T, 0, Q.availableFields), this.invalidateCounts()) } })
                }
              }; N.applyEditsAddUpdateFeatures = function () {
                var G = w._asyncToGenerator(function* (I, O, R) {
                  const S = [], Q = new Set; I.forEach(da => S.push(da.objectId)); O.forEach(da => { S.push(da.objectId); Q.add(da.objectId) });
                  if (0 !== S.length) { var T = []; this.featureTiles.forEach(da => { (da = this.applyEditsAddUpdateTile(da, S, Q, R)) && T.push(da) }); yield l.eachAlways(T) }
                }); return function (I, O, R) { return G.apply(this, arguments) }
              }(); N.applyEditsAddUpdateTile = function () {
                var G = w._asyncToGenerator(function* (I, O, R, S) {
                  if (I.features) {
                    var Q = this.createQuery(I); Q.resultType = void 0; Q.cacheHint = !1; Q.objectIds = O; O = yield this.queryFeatures(Q, S); S = null; 0 < R.size && (Q = I.features.filter(T => !R.has(g.getObjectId(T, this.objectIdField))), Q.length !== I.features.length &&
                      (S = Q)); if (0 < O.features.length) { S || (S = I.features.slice()); for (const T of O.features) S.push(T) } S && (I.hasPreciseFeatureCount && (I.numFeatures = Math.max(I.numFeatures, S.length)), I.setFeatures(S, 0, J(I.availableFields, O.fields)), this.invalidateCounts())
                  }
                }); return function (I, O, R, S) { return G.apply(this, arguments) }
              }(); N.queryFeatures = function (G, I) { return this.context.query.queryFeaturesDehydrated(G, { signal: I, timeout: 6E5 }) }; N.setDirty = function () { this._dirty = !0; this.updated() }; N.runTask = function (G) {
                this._frameTask.processQueue(G);
                if (this._dirty && this.constructed) { this._dirty = !1; var I = this.getListOfTiles(); this.markTilesNotAlive(I); if (G.run(() => this.addTiles(I, G)) && G.run(() => this.filterExtentTiles(I, G)) && G.run(() => this.removeTiles(I, G)) && !G.done) { var O = this.sortTiles(I); G.run(() => this.displayTiles(O, G)) && G.run(() => this.fetchTiles(O, G)) && G.run(() => this.updateMemoryEstimates(O, G)) || this.setDirty(); this.updated(); this.updating || this.updateMaximumNumberOfFeaturesExceeded() } else this.setDirty() }
              }; N.markTilesNotAlive = function (G) {
                for (const I of G) I.alive =
                  !1
              }; N.addTiles = function (G, I) { if (this.suspended) return !1; this.tileDescriptors.forEach(O => { const R = this.featureTiles.get(O.id); R ? R.alive = !0 : I.done || (G.push(this.addTile(O)), I.madeProgress()) }); return I.hasProgressed }; N.filterExtentTiles = function (G, I) { for (const O of G) { if (I.done) break; O.alive && (O.filtered = !O.intersects(this.filterExtent), O.filtered && (this.clearTile(O), I.madeProgress())) } return I.hasProgressed }; N.removeTiles = function (G, I) {
                for (let O = G.length - 1; 0 <= O && !I.done; O--) {
                  const R = G[O]; R.alive ||
                    (this.removeTile(R), O !== G.length - 1 && (G[O] = G[G.length - 1]), G.pop(), I.madeProgress())
                } return I.hasProgressed
              }; N.sortTiles = function (G) { G.sort((I, O) => I.descriptor.loadPriority - O.descriptor.loadPriority); return G }; N.displayTiles = function (G, I) { const O = this.updateRatio(G), R = S => { const Q = 1 > this._fullRatio ? O(S) * this._farRatio : 1; S.reduceFeatures(Q, this.memoryFactor, this.objectIdField) && this.setDirty(); return this.showTile(S) }; for (const S of G) if (!I.run(() => R(S))) { this.setDirty(); break } return I.hasProgressed };
              N.fetchTiles = function (G, I) {
                if (this.paused) return !1; var O = !1; for (const S of G) if (S.needsFetching) { var R = p.isSome(this.context.memoryCache) ? this.context.memoryCache.pop(S.id) : null; if (p.isSome(R)) S.cache = R, this.setDirty(), this.scheduleUpdated(), I.madeProgress(); else if (this.needsNumFeatures(S) && (O = new AbortController, R = this.fetchTileCount(S, O.signal), this._handleRequest(S, R, O, () => S.numFeatures = A.FAILED_FEATURE_COUNT), O = !0, I.madeProgress()), I.done) return !0 } if (O) return I.hasProgressed; for (const S of G) if (S.needsFetching &&
                  (G = new AbortController, O = this.fetchTile(S, G.signal), this._handleRequest(S, O, G, Q => { S.setFeatures([], 0, null); this.invalidateCounts(); S.featuresMissing = !1; this.context.logFetchError(M, Q) }), I.madeProgress(), I.done)) return !0; return I.hasProgressed
              }; N.updateMemoryEstimates = function (G, I) { G.some(O => I.run(() => O.updateMemoryEstimates()) ? !1 : (this.setDirty(), !0)); return I.hasProgressed }; N.reclip = function (G, I) {
                if (this.constructed) {
                  var O = []; this.featureTiles.forEach(R => {
                    p.isNone(R.displayingFeatures) || 0 === R.displayingFeatures.length ||
                    (R.intersectionIncludingBorrowed(I, F), R.intersectionIncludingBorrowed(G, K), e.equals(F, K) || O.push(R))
                  }); this.refreshDisplayingFeatures(O); this.updated()
                }
              }; N.refreshDisplayingFeatures = function (G) { const I = new Set, O = this.changes.updates; for (const R of G) if (!p.isNone(R.displayingFeatures)) for (const S of R.displayingFeatures) G = g.getObjectId(S, this.objectIdField), I.has(G) || (I.add(G), { feature: G } = this.displayingFeatureReferences.get(G), O.removes.push(G), O.adds.push(G)); this.applyChanges() }; N.updated = function () {
                let G =
                  0; this.paused || this.featureTiles.forEach(O => O.isFetching ? ++G : 0); var I = this._dirty || 0 < G || !!this.pendingEdits; this._set("updating", I); if (I) {
                    let O = 0, R = 0, S = 0, Q = 0, T = 0; const da = this.displayingFeatureReferences.size / this.numDisplayingFeatureReferences; this.featureTiles.forEach(fa => {
                      ++R; if (fa.isFetching && fa.hasPreciseFeatureCount) { const ha = this.maximumFeaturesForTile(fa) * (1 - fa.emptyFeatureRatio), ka = p.isSome(fa.displayingFeatures) ? fa.displayingFeatures.length * da : 0; T += ha - ka } fa.needsFetching ? ++Q : 0 < fa.numFeatures &&
                        (++S, O += fa.numFeatures)
                    }); Q += G; let Y = I = 0; O ? (Y = O, I = Math.min(Q * O / S, O)) : (Y = R, I = Q); T = Math.min(this.maximumNumberOfFeatures - this.features.length, T); this._set("updatingTotal", Y); this._set("updatingRemaining", I); this._set("expectedFeatureDiff", T)
                  } else this._set("updatingTotal", 0), this._set("updatingRemaining", 0), this._set("expectedFeatureDiff", 0); this.debugger && this.debugger.update()
              }; N.updateMaximumNumberOfFeaturesExceeded = function () {
                const G = n.someMap(this.featureTiles, I => I.perTileMaximumNumberOfFeaturesExceeded);
                this._set("maximumNumberOfFeaturesExceeded", G)
              }; N.updateRatio = function (G) { const I = D(G), O = Q => 1 / (1 << Math.max(0, I - Q.descriptor.lij[0])); let R = 0, S = 0; for (const Q of G) G = Q.numFeatures, R += G, S += G * O(Q); this._fullRatio = Math.min(1, this.maximumNumberOfFeatures / R); this._farRatio = this.maximumNumberOfFeatures / S; this.scheduleUpdated(); return O }; N.maximumFeaturesUpdated = function (G, I) {
              G !== I && (I > G && this.featureTiles.forEach(O => {
                if (O.featuresMissing) {
                  var R = this.maximumFeaturesForTile(O); O.features && (O.features.length >=
                    R || 5 === O.fetchStatus) || (this.cancelFetchTile(O), this.resetFetchTile(O))
                }
              }), this.setDirty())
              }; N.addTile = function (G) { G = new A.FeatureTile(G); this.featureTiles.set(G.id, G); this.resetFetchTile(G); this.referenceDisplayingFeaturesFromRelatedTiles(G); return G }; N.referenceDisplayingFeaturesFromRelatedTiles = function (G) {
                const I = G.descriptor.resolution; this.featureTiles.forEach(O => {
                  if (!(p.isNone(O.displayingFeatures) || G === O || G.descriptor.lij && O.descriptor.lij && !z.tilesAreRelated(G.descriptor.lij, O.descriptor.lij))) {
                    p.isNone(G.displayingFeatures) &&
                    (G.displayingFeatures = []); G.descriptor.extent && O.descriptor.extent && (p.isNone(G.extentIncludingBorrowedFeatures) && (G.extentIncludingBorrowedFeatures = e.clone(G.descriptor.extent)), e.expand(G.extentIncludingBorrowedFeatures, O.descriptor.extent, G.extentIncludingBorrowedFeatures)); for (const R of O.displayingFeatures) G.displayingFeatures.push(R), O = this.displayingFeatureReferences.get(g.getObjectId(R, this.objectIdField)), O.ref(O.feature, I), this.numDisplayingFeatureReferences++
                  }
                }); G.featureLimit = p.isSome(G.displayingFeatures) ?
                  G.displayingFeatures.length : 0
              }; N.removeTile = function (G) { this.clearTile(G); this.featureTiles.delete(G.id) }; N.resetFetchTile = function (G) { G.filtered = !G.intersects(this.filterExtent); G.filtered ? G.needsFetching && (G.fetchStatus = 4) : G.fetchStatus = 0 }; N.cancelFetchTile = function (G) { const I = G.requestController; p.isSome(I) && (G.requestController = null, G.resetFetching(), I.abort()) }; N.fetchTileCount = function () {
                var G = w._asyncToGenerator(function* (I, O) {
                I.numFeatures = yield this.fetchCount(I, O); this.updateRatio(this.getListOfTiles());
                  return 3 === I.fetchStatus ? 1 : 0
                }); return function (I, O) { return G.apply(this, arguments) }
              }(); N.fetchTile = function () {
                var G = w._asyncToGenerator(function* (I, O) {
                  var R = this.maximumFeaturesForTile(I); if (0 >= R) return E(I); const S = this.getMaxRecordCount(I); var Q = Math.ceil(R / S); if (C(I) || !this.context.capabilities.supportsMaxRecordCountFactor || I.numFeatures <= R && Q > k.MAX_MAX_RECORD_COUNT_FACTOR) return this.fetchPagedTile(I, O); Q = this.createQuery(I); Q.maxRecordCountFactor = Math.ceil(R / S); I.isRefetching && I.features && 0 <
                    I.features.length && (Q.maxRecordCountFactor = Math.max(Math.ceil(I.features.length / (1 - I.emptyFeatureRatio) / S) + 1, Q.maxRecordCountFactor)); const { features: T, exceededTransferLimit: da, fields: Y } = yield this.queryFeatures(Q, O); R = da ? Q.maxRecordCountFactor >= k.MAX_MAX_RECORD_COUNT_FACTOR ? 5 : 4 : 5; yield this._frameTask.schedule(() => { I.featuresMissing = T.length < I.numFeatures || da; const fa = this._removeEmptyFeatures(T); I.setFeatures(T, fa, H(Y)) }, O); this.invalidateCounts(); return R
                }); return function (I, O) {
                  return G.apply(this,
                    arguments)
                }
              }(); N.fetchCount = function () { var G = w._asyncToGenerator(function* (I, O) { return this.context.query.queryFeatureCount(this.createFeatureCountQuery(I), { signal: O }) }); return function (I, O) { return G.apply(this, arguments) } }(); N.fetchPagedTile = function () {
                var G = w._asyncToGenerator(function* (I, O) {
                  let R = 0, S = 0, Q, T = 0, da = this.maximumFeaturesForTile(I) - T; const Y = this.getMaxRecordCount(I); let fa = null; for (; ;) {
                    const ha = this.createQuery(I), ka = this.setPagingParameters(ha, R, da, Y), { features: ea, exceededTransferLimit: ba,
                      fields: aa } = yield this.queryFeatures(ha, O); yield this._frameTask.schedule(() => { ka && (R += p.unwrap(ha.num)); T += ea.length; S += this._removeEmptyFeatures(ea); I.featuresMissing = R < I.numFeatures || ba; Q = Q ? Q.concat(ea) : ea; fa = J(fa, aa); I.setFeatures(Q, S, fa) }, O); this.invalidateCounts(); this.setDirty(); da = this.maximumFeaturesForTile(I) - T; if (!ka || !ba || 0 >= da) return ba ? 4 : 5
                  }
                }); return function (I, O) { return G.apply(this, arguments) }
              }(); N.createFeatureCountQuery = function (G) {
                G = this.createQuery(G); this.context.capabilities.supportsCacheHint &&
                  (G.resultType = void 0, G.cacheHint = !0); return G
              }; N.createQuery = function (G) { const I = this.context.createQuery(), O = G.descriptor.extent; O && (I.geometry = e.toExtent(O, this.context.tilingScheme.spatialReference)); this.setResolutionParams(I, G); this.useTileQuery(G) ? I.resultType = "tile" : this.context.capabilities.supportsCacheHint && (I.cacheHint = !0); return I }; N.setPagingParameters = function (G, I, O, R) {
                if (!this.context.capabilities.supportsPagination) return !1; G.start = I; 0 < O && this.context.capabilities.supportsMaxRecordCountFactor ?
                  (G.maxRecordCountFactor = Math.ceil(O / R), G.num = Math.min(G.maxRecordCountFactor * R, O)) : G.num = Math.min(R); return !0
              }; N.getEffectiveTileResolution = function (G) { if (null == G.descriptor.resolution) return null; const I = 1 === this.context.viewingMode ? this.context.tilingScheme.resolutionAtLevel(3) : Infinity; return Math.min(G.descriptor.resolution, I) / this.lodFactor }; N.setResolutionParams = function (G, I) {
              this.supportsResolution && (I = this.getEffectiveTileResolution(I), null != I && (this.context.capabilities.supportsQuantization ?
                G.quantizationParameters = new x({ mode: "view", originPosition: "upper-left", tolerance: I, extent: this.context.fullExtent }) : "polyline" === this.context.geometryType && (G.maxAllowableOffset = I)))
              }; N._removeEmptyFeatures = function (G) { const I = G.length; for (let O = 0; O < G.length;)g.hasVertices(G[O].geometry) ? ++O : (G[O] = G[G.length - 1], --G.length); return I - G.length }; N.needsNumFeatures = function (G) { return this.useTileCount && G.needsFeatureCount && !C(G) }; N.getMaxRecordCount = function (G) {
                const { tileMaxRecordCount: I, maxRecordCount: O } =
                  this.context; return this.useTileQuery(G) && p.isSome(I) && 0 < I && this.context.capabilities.supportsResultType ? I : p.isSome(O) && 0 < O ? O : 2E3
              }; N.useTileQuery = function (G) { return C(G) && this.context.capabilities.supportsCacheHint ? !1 : this.context.capabilities.supportsResultType }; N._handleRequest = function (G, I, O, R) {
              G.fetchStatus = G.needsRefetching ? 3 : 2; G.requestController = O; let S = !1; I.then(Q => { G.requestController = null; G.fetchStatus = Q }).catch(Q => {
              G.requestController === O && (G.requestController = null, G.fetchStatus = 4); l.isAbortError(Q) ?
                S = !0 : R(Q)
              }).then(() => { S || this.setDirty(); this.scheduleUpdated() })
              }; N.scheduleUpdated = function () { this.handles && !this.handles.has("scheduleUpdated") && this.handles.add(h.schedule(() => { this.handles.remove("scheduleUpdated"); this.updated() }), "scheduleUpdated") }; N.showTile = function (G) {
                if (p.isSome(G.displayingFeatures) && !G.needsDisplayUpdate) return !1; var I = G.features; if (0 === G.featureLimit || !I) return I = p.isSome(G.displayingFeatures) && 0 < G.displayingFeatures.length, this.hideTileFeatures(G), G.displayingFeatures =
                  [], I; const O = G.descriptor.resolution, R = this.changes.updates, S = this.changes.adds, Q = Math.min(G.featureLimit, I.length); G.featureLimit = Q; for (let da = 0; da < Q; ++da) { var T = I[da]; const Y = g.getObjectId(T, this.objectIdField), fa = this.displayingFeatureReferences.get(Y); fa ? (T = fa.ref(T, O), T.oldVersion !== T.newVersion && (R.removes.push(T.oldVersion), R.adds.push(T.newVersion))) : (this.displayingFeatureReferences.set(Y, new this.FeatureReferenceClass(T, O)), S.push(T)); this.numDisplayingFeatureReferences++ } this.hideTileFeatures(G);
                this.applyChanges(); G.displayingFeatures = I.slice(0, Q); return !0
              }; N.hideTile = function (G) { this.cancelFetchTile(G); this.hideTileFeatures(G) }; N.hideTileFeatures = function (G) {
                if (!p.isNone(G.displayingFeatures)) {
                  var I = this.changes.updates, O = this.changes.removes; for (const S of G.displayingFeatures) {
                    const Q = g.getObjectId(S, this.objectIdField); var R = this.displayingFeatureReferences.get(Q); R && ((R = R.unref(G.descriptor.resolution), this.numDisplayingFeatureReferences-- , R) ? R.oldVersion !== R.newVersion && (null == R.newVersion ?
                      (this.displayingFeatureReferences.delete(Q), O.push(R.oldVersion)) : (I.adds.push(R.newVersion), I.removes.push(R.oldVersion))) : console.error("Hiding unreferenced feature"))
                  } this.applyChanges(); G.displayingFeatures = null
                }
              }; N.applyChanges = function () {
                var G = this.changes.updates; 0 < G.removes.length && (this.features.removeMany(G.removes), G.removes.length = 0); 0 < G.adds.length && (this.features.addMany(G.adds), G.adds.length = 0); G = this.changes.adds; const I = this.changes.removes, O = Math.min(G.length, I.length); let R = 0; for (; R <
                  O;) { const S = Math.min(R + 200, O); this.features.addMany(G.slice(R, S)); this.features.removeMany(I.slice(R, S)); R = S } G.length > O && this.features.addMany(0 === R ? G : G.slice(R)); I.length > O && this.features.removeMany(0 === R ? I : I.slice(R)); G.length = 0; I.length = 0
              }; N.clearTile = function (G) { this.hideTile(G); G.features && p.isSome(this.context.memoryCache) && this.context.memoryCache.put(G.id, G.cache, 16 + G.estimatedSize); G.setFeatures(null, 0, null); this.invalidateCounts() }; N.invalidateCounts = function () {
                this.notifyChange("totalVertices");
                this.notifyChange("totalFeatures"); this.notifyChange("memoryForUnusedFeatures")
              }; N.getListOfTiles = function () { return Array.from(this.featureTiles.values()) }; N.maximumFeaturesForTile = function (G) { const I = G.hasPreciseFeatureCount ? G.numFeatures : Infinity; return Math.min(Math.ceil((G.hasPreciseFeatureCount ? I : this.maximumNumberOfFeatures) * (1 > this._fullRatio ? this._farRatio : 1) / (1 - G.emptyFeatureRatio)), I) }; w._createClass(L, [{
                key: "maximumNumberOfFeatures", set: function (G) {
                  G = G || Infinity; const I = this._get("maximumNumberOfFeatures");
                  G === I || 1 > G || (this._set("maximumNumberOfFeatures", G), this.maximumFeaturesUpdated(I, G))
                }
              }, { key: "memoryFactor", set: function (G) { this.memoryFactor !== G && (this._set("memoryFactor", G), this.setDirty()) } }, { key: "lodFactor", set: function (G) { this.lodFactor !== G && (this._set("lodFactor", G), this.supportsResolution && this.refetch()) } }, { key: "useTileCount", get: function () { return this._useTileCount && p.isSome(this.context.query.queryFeatureCount) }, set: function (G) { this._useTileCount = G; this.notifyChange("useTileCount") } }, {
                key: "memoryForUnusedFeatures",
                get: function () { let G = 0; this.featureTiles.forEach(I => G += I.estimatedUnusedSize); return G }
              }, { key: "totalVertices", get: function () { let G = 0; this.featureTiles.forEach(I => G += I.numVertices); return G } }, { key: "totalFeatures", get: function () { let G = 0; this.featureTiles.forEach(I => G += I.numFeatures); return G } }, {
                key: "filterExtent", set: function (G) {
                  if (G && this.context.tilingScheme && !G.spatialReference.equals(this.context.tilingScheme.spatialReference)) M.error("#filterExtent\x3d", "extent needs to be in the same spatial reference as the tiling scheme");
                  else { var I = this._get("filterExtent"); I === G || I && G && I.equals(G) || (G = G ? G.clone() : null, this._set("filterExtent", G), this.reclip(G, I)) }
                }
              }, { key: "paused", get: function () { return this.suspended || !!this.pendingEdits } }, { key: "availableFields", get: function () { let G = null; this.featureTiles.forEach(I => { p.isNone(I.displayingFeatures) || 0 === I.displayingFeatures.length || (p.isNone(G) ? G = new Set(I.availableFields) : G.forEach(O => { I.availableFields.has(O) || p.unwrap(G).delete(O) })) }); return p.isSome(G) ? G : new Set } }, {
                key: "running",
                get: function () { return this.updating }
              }, { key: "supportsResolution", get: function () { return this.context.capabilities.supportsMultipleResolutions && "point" !== this.context.geometryType } }, { key: "storedFeatures", get: function () { return this.getListOfTiles().reduce((G, I) => G + (I.features ? I.features.length : 0), 0) } }, { key: "test", get: function () { return { process: G => this.runTask(G), getFeatureTileById: G => this.featureTiles.get(G), forEachFeatureTile: G => this.featureTiles.forEach(G) } } }]); return L
            }(q); c.__decorate([d.property({ constructOnly: !0 })],
              a.FeatureTileFetcher3D.prototype, "features", void 0); c.__decorate([d.property()], a.FeatureTileFetcher3D.prototype, "tileDescriptors", void 0); c.__decorate([d.property({ value: Infinity })], a.FeatureTileFetcher3D.prototype, "maximumNumberOfFeatures", null); c.__decorate([d.property({ value: 1 })], a.FeatureTileFetcher3D.prototype, "memoryFactor", null); c.__decorate([d.property({ value: 1 })], a.FeatureTileFetcher3D.prototype, "lodFactor", null); c.__decorate([d.property()], a.FeatureTileFetcher3D.prototype, "useTileCount",
                null); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "updating", void 0); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "updatingTotal", void 0); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "updatingRemaining", void 0); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "expectedFeatureDiff", void 0); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "memoryForUnusedFeatures",
                  null); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "maximumNumberOfFeaturesExceeded", void 0); c.__decorate([d.property({ constructOnly: !0 })], a.FeatureTileFetcher3D.prototype, "maximumNumberOfFeaturesExceededThrottle", void 0); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "totalVertices", null); c.__decorate([d.property({ readOnly: !0 })], a.FeatureTileFetcher3D.prototype, "totalFeatures", null); c.__decorate([d.property()], a.FeatureTileFetcher3D.prototype,
                    "filterExtent", null); c.__decorate([d.property({ constructOnly: !0 })], a.FeatureTileFetcher3D.prototype, "context", void 0); a.FeatureTileFetcher3D = c.__decorate([m.subclass("esri.views.3d.layers.support.FeatureTileFetcher3D")], a.FeatureTileFetcher3D); const F = e.create(), K = e.create(); c = a.FeatureTileFetcher3D; a.contextCapabilitiesFromLayer = function (P) {
                      const L = P.capabilities.query; a: switch (P.geometryType) {
                        case "polyline": P = !0; break a; case "polygon": P = P.capabilities && P.capabilities.query && P.capabilities.query.supportsQuantization;
                          break a; default: P = !1
                      }return { supportsMultipleResolutions: P, supportsPagination: !(!L || !L.supportsPagination), supportsResultType: !(!L || !L.supportsResultType), supportsCacheHint: !(!L || !L.supportsCacheHint), supportsQuantization: !(!L || !L.supportsQuantization), supportsQuantizationEditMode: !(!L || !L.supportsQuantizationEditMode), supportsMaxRecordCountFactor: !(!L || !L.supportsMaxRecordCountFactor), supportsFormatPBF: !(!L || !L.supportsFormatPBF) }
                    }; a.default = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/featureReference": function () {
      define(["exports",
        "../../../../chunks/_rollupPluginBabelHelpers", "../../../../layers/graphics/dehydratedFeatures", "../../../../layers/graphics/dehydratedFeatureComparison"], function (a, w, c, q) {
          c = function () {
            function n(l, h) { this.highestResolutionVersion = null; this.versions = []; this.ref(l, h) } var p = n.prototype; p.ref = function (l, h) {
              const b = this.feature; y.oldVersion = b; this.feature && Object.defineProperty(l, "uid", { value: this.feature.uid, configurable: !0 }); for (var d of this.versions) if (d.resolution === h) {
              d.refCount++; if ((h = this.highestResolutionVersion ===
                d && !q.equals(l, d.feature)) || this.highestResolutionVersion !== d) d.feature = l; y.newVersion = h ? l : b; return y
              } d = { feature: l, resolution: h, refCount: 1 }; this.versions.push(d); !this.highestResolutionVersion || h < this.highestResolutionVersion.resolution ? (y.newVersion = l, this.highestResolutionVersion = d) : y.newVersion = b; return y
            }; p.unref = function (l) {
              for (let h = 0; h < this.versions.length; h++) {
                const b = this.versions[h]; if (b.resolution === l) return b.refCount-- , y.oldVersion = this.feature, 0 === b.refCount && (this.versions[h] = this.versions[this.versions.length -
                  1], this.versions.length-- , this.highestResolutionVersion === b && (this.recalculateHighestResolutionVersion(), y.oldVersion = b.feature)), y.newVersion = this.feature, y
              } return null
            }; p.recalculateHighestResolutionVersion = function () { if (0 === this.versions.length) this.highestResolutionVersion = null; else { var l = this.versions[0]; for (let h = 1; h < this.versions.length; h++) { const b = this.versions[h]; b.resolution < l.resolution && (l = b) } this.highestResolutionVersion = l } }; w._createClass(n, [{
              key: "isReferenced", get: function () {
                return 0 !==
                  this.versions.length
              }
            }, { key: "isSingle", get: function () { return 1 === this.versions.length && 1 === this.versions[0].refCount } }, { key: "feature", get: function () { return this.highestResolutionVersion ? this.highestResolutionVersion.feature : null } }]); return n
          }(); let u = function () {
            function n(l) { this._feature = l; this.refCount = 1 } var p = n.prototype; p.ref = function (l) {
              ++this.refCount; y.oldVersion = this._feature; this.feature && Object.defineProperty(l, "uid", { value: this.feature.uid, configurable: !0 }); q.equals(this._feature, l) || (this._feature =
                l); y.newVersion = this._feature; return y
            }; p.unref = function () { y.oldVersion = this._feature; if (0 < this.refCount && (this.refCount-- , !this.isReferenced)) return y.newVersion = null, y; y.newVersion = this._feature; return y }; w._createClass(n, [{ key: "isReferenced", get: function () { return 0 !== this.refCount } }, { key: "isSingle", get: function () { return 1 === this.refCount } }, { key: "feature", get: function () { return this._feature } }]); return n
          }(); const y = { oldVersion: null, newVersion: null }; a.MultiFeatureReference = c; a.SingleFeatureReference =
            u; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/FeatureTile": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/arrayUtils ../../../../core/maybe ../../../../geometry/support/aaBoundingRect ../../../../layers/graphics/dehydratedFeatures".split(" "), function (a, w, c, q, u, y) {
        const n = new Set; let p = function () {
          function h(d) {
          this.descriptor = d; this.fetchStatus = 0; this._features = null; this._featureLimit = this._numVertices = 0; this.featuresMissing =
            !0; this._shuffled = !1; this._numFeatures = -1; this._emptyFeatureRatio = 0; this._estimatedSize = -1; this._estimatedUnusedSize = 0; this._estimatedUnusedSizeDirty = !1; this._availableFields = n; this._displayingFeatures = null; this.alive = !0; this.filtered = !1
          } var b = h.prototype; b.setFeatures = function (d, f, t) {
          this._availableFields = q.unwrapOr(t, n); this._features = d; this._shuffled = !1; this._estimatedSize = -1; this._estimatedUnusedSizeDirty = !0; d && 0 < d.length ? (this._emptyFeatureRatio = f / (d.length + f), this._numVertices = d.reduce((v, m) =>
            v + y.numVertices(m.geometry), 0)) : this._numVertices = this._emptyFeatureRatio = 0
          }; b.updateMemoryEstimates = function () {
            if (0 > this._estimatedSize) { this._estimatedUnusedSize = this._estimatedSize = 0; if (this._features) for (var d = 0; d < this._features.length; ++d) { const f = y.estimateSize(this._features[d]); this._estimatedSize += f; d >= this.featureLimit && (this._estimatedUnusedSize += f) } return !0 } if (this._estimatedUnusedSizeDirty) {
            this._estimatedUnusedSize = 0; this._estimatedUnusedSizeDirty = !1; if (this._features) for (d = this.featureLimit; d <
              this._features.length; ++d)this._estimatedUnusedSize += y.estimateSize(this._features[d]); return !0
            } return !1
          }; b.resetFetching = function () { this.fetchStatus = 3 === this.fetchStatus ? 1 : 0 }; b.intersects = function (d) { if (!d || !this.descriptor.extent) return !0; u.fromExtent(d, l); return u.intersects(this.descriptor.extent, l) }; b.intersectionIncludingBorrowed = function (d, f) {
            const t = q.isSome(this.extentIncludingBorrowedFeatures) ? this.extentIncludingBorrowedFeatures : this.descriptor.extent; if (!d && !t) return u.copy(f, u.POSITIVE_INFINITY),
              f; d ? (u.fromExtent(d, f), u.intersection(f, t, f)) : u.copy(f, t); return f
          }; b._shuffle = function (d) { this._features.sort((f, t) => y.getObjectId(f, d) - y.getObjectId(t, d)); c.shuffle(this._features, 16438); this._estimatedUnusedSizeDirty = this._shuffled = !0 }; b.reduceFeatures = function (d, f, t) {
            if (0 >= d) return !1; if (!this._features) return this.featureLimit = 0, !1; let v = !1; this.featureLimit = Math.ceil(this.numFeatures * d); this.featureLimit > this._features.length && (this.featureLimit = this._features.length, 4 === this.fetchStatus && 0 <
              this._features.length && (this.fetchStatus = 1, v = !0)); !this._shuffled && 1 > d && this._shuffle(t); d = Math.max(this.featureLimit, Math.ceil(f * this.numFeatures)); this._features.length > d && (this._features.length = d, this.featuresMissing = !0, 5 === this.fetchStatus && (this.fetchStatus = 4)); return v
          }; w._createClass(h, [{ key: "displayingFeatures", get: function () { return this._displayingFeatures }, set: function (d) { this._displayingFeatures = d; this.extentIncludingBorrowedFeatures = null } }, {
            key: "perTileMaximumNumberOfFeaturesExceeded",
            get: function () { return !this.filtered && (this.featuresMissing || this.features && this.featureLimit !== this.features.length) }
          }, { key: "features", get: function () { return this._features } }, { key: "featureLimit", get: function () { return this._featureLimit }, set: function (d) { this._featureLimit !== d && (this._featureLimit = d, this._estimatedUnusedSizeDirty = !0) } }, { key: "availableFields", get: function () { return this._availableFields } }, { key: "emptyFeatureRatio", get: function () { return this._emptyFeatureRatio } }, {
            key: "numFeatures", get: function () {
              return this.hasPreciseFeatureCount ?
                this._numFeatures : this._features ? this._features.length : 0
            }, set: function (d) { this._numFeatures = d }
          }, { key: "hasPreciseFeatureCount", get: function () { return -1 < this._numFeatures } }, { key: "needsFeatureCount", get: function () { return -1 === this._numFeatures } }, { key: "numVertices", get: function () { return this._numVertices } }, { key: "id", get: function () { return this.descriptor.id } }, { key: "estimatedSize", get: function () { this.updateMemoryEstimates(); return this._estimatedSize } }, { key: "estimatedUnusedSize", get: function () { return this._estimatedUnusedSize } },
          { key: "isFetching", get: function () { return 2 === this.fetchStatus || 3 === this.fetchStatus } }, { key: "isRefetching", get: function () { return 3 === this.fetchStatus } }, { key: "needsFetching", get: function () { return 0 === this.fetchStatus || 1 === this.fetchStatus } }, { key: "needsRefetching", get: function () { return 1 === this.fetchStatus } }, { key: "isFetched", get: function () { return 4 === this.fetchStatus || 5 === this.fetchStatus } }, {
            key: "needsDisplayUpdate", get: function () {
              var d; if (d = !!this._features) {
                a: {
                  d = this._features; var f = this.displayingFeatures,
                    t = this.featureLimit; if (q.isNone(f) || q.isNone(d) || t !== f.length || t > d.length) d = !1; else { for (let v = 0; v < t; ++v)if (d[v] !== f[v]) { d = !1; break a } d = !0 }
                } d = !d
              } return d
            }
          }, {
            key: "cache", get: function () { return { availableFields: this._availableFields, features: this.features, numFeatures: this._numFeatures, emptyFeatureRatio: this._emptyFeatureRatio, fetchStatus: this.fetchStatus, featuresMissing: this.featuresMissing } }, set: function (d) {
            this.requestController = null; this._availableFields = d.availableFields; this._features = d.features;
              this._numFeatures = d.numFeatures; this._emptyFeatureRatio = d.emptyFeatureRatio; this.fetchStatus = d.fetchStatus; this.featuresMissing = d.featuresMissing; this._estimatedSize = -1; this._estimatedUnusedSizeDirty = !0
            }
          }]); return h
        }(); const l = u.create(); a.FAILED_FEATURE_COUNT = -2; a.FeatureTile = p; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/FeatureTileFetcher3DDebugger": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Graphic ../../../../geometry/Polygon ../../../../symbols/FillSymbol3DLayer ../../../../symbols/PointSymbol3D ../../../../symbols/PolygonSymbol3D ../../../../symbols/TextSymbol3DLayer ../../terrain/TilingScheme".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          const h = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]]; let b = function () {
            function d(t, v, m) {
            this.loadingGraphics = new Map; this.loadedGraphics = new Map; this.pendingGraphics = new Map; this._enabled = !0; this.tileFetcher = t; this.view = m; this.tilingScheme = new l(v); this.loadedSymbols = h.map(e => new n(new u({
              material: {
                color: [e[0],
                e[1], e[2], .6]
              }, outline: { color: "black", size: 1 }
            }))); this.loadingSymbols = [new n(new u({ material: { color: [200, 200, 200, .4] }, outline: { color: [30, 30, 30], size: 1 } }))]; this.pendingSymbols = [new n(new u({ material: { color: [100, 100, 100, .4] }, outline: { color: [30, 30, 30], size: 1 } }))]; this.dataExtentSymbol = new n(new u({ material: { color: [0, 0, 0, 0] }, outline: { color: "green", size: 4 } }))
            } var f = d.prototype; f.destroy = function () { this.enabled = !1 }; f.update = function () {
              this._enabled ? (this.synchronizeMaps(this.loadingGraphics, {
                filter: t =>
                  t.isFetching, symbols: this.loadingSymbols
              }), this.synchronizeMaps(this.loadedGraphics, { filter: t => !t.isFetching, symbols: this.loadedSymbols }), this.synchronizeMaps(this.pendingGraphics, { filter: t => !t.isFetching, symbols: this.pendingSymbols }), this.showDataExtent(this.tileFetcher.filterExtent)) : (this.loadingGraphics.forEach(t => { this.view.graphics.removeMany(t) }), this.loadingGraphics.clear(), this.loadedGraphics.forEach(t => { this.view.graphics.removeMany(t) }), this.loadedGraphics.clear(), this.pendingGraphics.forEach(t => { this.view.graphics.removeMany(t) }), this.pendingGraphics.clear(), this.dataExtentGraphic && (this.view.graphics.remove(this.dataExtentGraphic), this.dataExtentGraphic = null))
            }; f.showDataExtent = function (t) { this.dataExtentGraphic && (this.view.graphics.remove(this.dataExtentGraphic), this.dataExtentGraphic = null); t && (t = q.fromExtent(t), this.dataExtentGraphic = new c({ geometry: t, symbol: this.dataExtentSymbol }), this.view.graphics.add(this.dataExtentGraphic)) }; f.synchronizeMaps = function (t, v) {
              const m = []; t.forEach((e,
                g) => { const x = this.tileFetcher.test.getFeatureTileById(g); x && v.filter(x) || (this.view.graphics.removeMany(e), m.push(g)) }); m.forEach(e => t.delete(e)); this.tileFetcher.test.forEachFeatureTile(e => {
                  if (v.filter(e) && !t.has(e.id)) {
                    const [k, r, A] = e.descriptor.lij; this.tilingScheme.ensureMaxLod(k); var g = this.tilingScheme.getExtentGeometry(k, r, A), x = new c({ geometry: g, symbol: v.symbols[k % v.symbols.length] }); g = new c({
                      geometry: g.center, symbol: new y({
                        verticalOffset: { screenLength: 40 / .75 }, callout: {
                          type: "line", color: "white",
                          border: { color: "black" }
                        }, symbolLayers: [new p({ text: `${k}/${r}/${A}`, halo: { color: "white", size: 1 / .75 }, material: { color: "black" }, size: 16 })]
                      })
                    }); x = [x, g]; t.set(e.id, x); this.view.graphics.addMany(x)
                  }
                })
            }; w._createClass(d, [{ key: "enabled", get: function () { return this._enabled }, set: function (t) { this._enabled = t; this.update() } }]); return d
          }(); a.FeatureTileFetcher3DDebugger = b; a.default = b; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/FeatureLikeLayerView3D": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Error ../../../core/maybe ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../layers/graphics/hydratedFeatures ../../../layers/graphics/controllers/FeatureTileController3D ../../../renderers/support/renderingInfoUtils ../../../rest/support/Query ./graphics/Graphics3DFeatureLikeLayerView ./graphics/QueryEngine ./support/projectExtentUtils ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x) {
        a.FeatureLikeLayerView3D = k => {
          k = function (r) {
            function A() { var B = r.apply(this, arguments) || this; B.controller = null; B.updatePolicy = 1; B.suspendResumeExtentMode = "computed"; B.slicePlaneEnabled = !1; B.drapeSourceType = 1; B.fullExtentInLocalViewSpatialReference = null; B.suspendResumeExtent = null; B._controllerCreated = !1; B.clippingExtent = null; B.supportsHeightUnitConversion = !0; B.pendingController = null; B.queryEngine = null; return B } w._inheritsLoose(A, r); var z = A.prototype; z.initialize =
              function () {
                const B = this.layer; "isTable" in B && B.isTable ? this.addResolvingPromise(Promise.reject(new q("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: B }))) : (this._set("graphics3d", new m({
                  owner: this, layer: B, frustumVisibilityEnabled: !0, scaleVisibilityEnabled: !0, filterVisibilityEnabled: !0, timeExtentVisibilityEnabled: !0, elevationAlignmentEnabled: !0, elevationFeatureExpressionEnabled: !0, preferredUpdatePolicy: this.updatePolicy, suspendResumeExtentMode: this.suspendResumeExtentMode,
                  updateClippingExtent: C => this.updateClippingExtent(C)
                })), this.updatingHandles.add(this, "updatePolicy", C => this.graphics3d.graphicsCore.preferredUpdatePolicy = C), this.updatingHandles.add(this, "suspendResumeExtentMode", C => { this.graphics3d.suspendResumeExtentMode = C }), this.addResolvingPromise(this.graphics3d.setup().then(() => this.validateGeometryType()).then(() => this.queryEngine = new e.default({ layerView: this, priority: x.TaskPriority.FEATURE_QUERY_ENGINE })).then(() => g.toViewIfLocal(this)).then(C => this.fullExtentInLocalViewSpatialReference =
                  C).then(() => this.initializeController())), this.notifyChange("updating"))
              }; z.destroy = function () { this.destroyPendingController(); this.controller = u.destroyMaybe(this.controller); this._set("graphics3d", u.destroyMaybe(this.graphics3d)); this.queryEngine = u.destroyMaybe(this.queryEngine); this.loadedGraphics = null }; z.destroyPendingController = function () { this.pendingController && (this.pendingController.destroy(), this.pendingController = null) }; z.notifyGraphicGeometryChanged = function (B) { this.graphics3d.graphicsCore.notifyGraphicGeometryChanged(B) };
            z.notifyGraphicVisibilityChanged = function (B) { this.graphics3d.graphicsCore.notifyGraphicVisibilityChanged(B) }; z.getRenderingInfo = function (B, C, D) { B = t.getRenderingInfo(B, { renderer: C, arcade: D }); u.isSome(B) && B.color && (C = B.color, C[0] /= 255, C[1] /= 255, C[2] /= 255); return B }; z.getRenderingInfoAsync = function () { var B = w._asyncToGenerator(function* (C, D, E, H) { return t.getRenderingInfoAsync(C, { renderer: D, arcade: E, ...H }) }); return function (C, D, E, H) { return B.apply(this, arguments) } }(); z.getGraphicFromGraphicUid = function (B) {
              var C;
              let D = null; null == (C = this.loadedGraphics) ? void 0 : C.forEach(E => { E.uid === B && (D = d.hydrateGraphic(E, this.layer)) }); return D
            }; z.whenGraphicBounds = function (B, C) { return this.graphics3d ? this.graphics3d.graphicsCore.whenGraphicBounds(B, C) : null }; z.computeAttachmentOrigin = function (B, C) { return this.graphics3d ? this.graphics3d.graphicsCore.computeAttachmentOrigin(B, C) : null }; z.getSymbolLayerSize = function (B, C) { return this.graphics3d ? this.graphics3d.graphicsCore.getSymbolLayerSize(B, C) : null }; z.queryFeatures = function (B,
              C) { return this.queryEngine.executeQuery(this._ensureQuery(B), u.get(C, "signal")) }; z.queryObjectIds = function (B, C) { return this.queryEngine.executeQueryForIds(this._ensureQuery(B), u.get(C, "signal")) }; z.queryFeatureCount = function (B, C) { return this.queryEngine.executeQueryForCount(this._ensureQuery(B), u.get(C, "signal")) }; z.queryExtent = function (B, C) { return this.queryEngine.executeQueryForExtent(this._ensureQuery(B), u.get(C, "signal")) }; z._ensureQuery = function (B) { return u.isNone(B) ? this.createQuery() : v.from(B) };
            z.highlight = function (B) { return this.graphics3d.highlight(B, this.layer.objectIdField) }; z.maskOccludee = function (B) { return this.graphics3d.maskOccludee(B) }; z.canResume = function () { return r.prototype.canResume.call(this) && (!this.graphics3d || !this.graphics3d.suspended) }; z.getSuspendInfo = function () { const B = r.prototype.getSuspendInfo.call(this); return this.graphics3d ? { ...B, ...this.graphics3d.suspendInfo } : B }; z.isUpdating = function () {
              var B, C; return !this.graphics3d || this.graphics3d.destroyed ? !1 : !(this._controllerCreated &&
                (null == (B = this.controller) || !B.updating) && null != (C = this.view.basemapTerrain) && C.ready && !this.graphics3d.updating)
            }; z.initializeController = function () { var B = w._asyncToGenerator(function* () { const C = this.createController(); this.pendingController = C; yield C.when(); this.setControllerWhenInitialized(C) }); return function () { return B.apply(this, arguments) } }(); z.setControllerWhenInitialized = function () {
              var B = w._asyncToGenerator(function* (C) {
                try { yield this.when() } catch (D) { } this._controllerCreated = !0; this.notifyChange("updating");
                !this.isResolved() || this.destroyed ? this.destroyPendingController() : (yield y.whenTrueOnce(this.view, "basemapTerrain.ready"), this.beforeSetController(C), this.pendingController = null, this.controller = C, this.loadedGraphics = C.graphics, this.notifyChange("updating"))
              }); return function (C) { return B.apply(this, arguments) }
            }(); z.updateClippingExtent = function (B) {
            this.clippingExtent = B; if (!this.controller) return !1; switch (this.controller.type) {
              case "stream": return !1; case "feature-tile-3d": return this.controller.extent =
                B, !0
            }
            }; z.validateGeometryType = function () { switch (this.layer.geometryType) { case "multipatch": case "multipoint": return Promise.reject(new q("featurelayerview3d:unsupported-geometry-type", "Unsupported geometry type ${geometryType}", { geometryType: this.layer.geometryType })) } }; z._getResourceInfo = function () {
              const B = this.controller && this.controller instanceof f.FeatureTileController3D ? this.controller : null; return {
                displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: B ? B.maximumNumberOfFeatures :
                  -1, totalNumberOfFeatures: B ? B.serviceDataCount : -1, nodes: 0, core: this.graphics3d.graphicsCore.performanceInfo, elevationUpdating: this.graphics3d.elevationAlignment.updating, visibilityFrustum: !this.graphics3d.frustumVisibility.suspended, visibilityScale: !this.graphics3d.scaleVisibility.suspended
              }
            }; w._createClass(A, [{ key: "legendEnabled", get: function () { var B, C; return this.canResume() && !(null != (B = this.graphics3d) && null != (C = B.frustumVisibility) && C.suspended) } }, {
              key: "graphics3DGraphics", get: function () {
                return this.graphics3d ?
                  this.graphics3d.graphicsCore.graphics3DGraphics : null
              }
            }, { key: "graphics3DGraphicsByObjectID", get: function () { return this.graphics3d ? this.graphics3d.graphicsCore.graphics3DGraphicsByObjectID : null } }, { key: "symbolUpdateType", get: function () { return this.graphics3d ? this.graphics3d.graphicsCore.symbolUpdateType : null } }, { key: "performanceInfo", get: function () { return this._getResourceInfo() } }]); return A
          }(k); c.__decorate([n.property()], k.prototype, "loadedGraphics", void 0); c.__decorate([n.property()], k.prototype, "suspended",
            void 0); c.__decorate([n.property({ readOnly: !0 })], k.prototype, "legendEnabled", null); c.__decorate([n.property()], k.prototype, "updating", void 0); c.__decorate([n.property()], k.prototype, "controller", void 0); c.__decorate([n.property()], k.prototype, "graphics3d", void 0); c.__decorate([n.property({ readOnly: !0 })], k.prototype, "updatePolicy", void 0); c.__decorate([n.property({ readOnly: !0 })], k.prototype, "suspendResumeExtentMode", void 0); c.__decorate([n.property({ type: Boolean })], k.prototype, "slicePlaneEnabled",
              void 0); c.__decorate([n.property({ readOnly: !0 })], k.prototype, "suspendInfo", void 0); return k = c.__decorate([b.subclass("esri.views.3d.layers.FeatureLikeLayerView3D")], k)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DFeatureLikeLayerView": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../Graphic ../../../../core/Accessor ../../../../core/compilerUtils ../../../../core/Handles ../../../../core/promiseUtils ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../core/accessorSupport/diffUtils ../../../../geometry/support/webMercatorUtils ../../../../rest/support/Query ./constants ./Graphics3DCore ./Graphics3DElevationAlignment ./Graphics3DFilterVisibility ./Graphics3DFrustumVisibility ./Graphics3DObjectStates ./Graphics3DScaleVisibility ./graphicUtils ../support/attributeUtils ../../../support/WatchUpdatingTracking".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D) {
          q = function (H) {
            function J(F) { F = H.call(this, F) || this; F._handles = new y; F.watchUpdatingTracking = new D.WatchUpdatingTracking; F.suspendResumeExtentMode = "computed"; F.dataExtent = null; F.suspendResumeExtent = null; return F } a._inheritsLoose(J, H); var M = J.prototype; M.normalizeCtorArgs = function (F) {
              const K = F.frustumVisibilityEnabled ? new r : null, P = F.scaleVisibilityEnabled ? new z : null, L = (F.filterVisibilityEnabled || F.timeExtentVisibilityEnabled) && "multipatch" !==
                F.layer.geometryType ? new k.Graphics3DFilterVisibility : null, N = F.elevationAlignmentEnabled ? new x : null, G = new g.Graphics3DCore({ owner: F.owner, layer: F.layer, preferredUpdatePolicy: F.preferredUpdatePolicy, elevationFeatureExpressionEnabled: F.elevationFeatureExpressionEnabled, graphicSymbolSupported: !1, hasZ: F.owner.hasZ, hasM: F.owner.hasM }), { updateClippingExtent: I, suspendResumeExtentMode: O, dataExtent: R } = F; return {
                  graphicsCore: G, frustumVisibility: K, scaleVisibility: P, filterVisibility: L, elevationAlignment: N, updateClippingExtent: I,
                  suspendResumeExtentMode: O, dataExtent: R
                }
            }; M.initialize = function () {
            this.scaleVisibility && this.watchUpdatingTracking.add(this.layer, "scaleRangeId", () => this.scaleVisibility.layerMinMaxScaleChangeHandler()); this.filterVisibility && (this.watchUpdatingTracking.add(this.owner, "filter", () => this.filterVisibility.filterChanged()), this.watchUpdatingTracking.add(this.owner, "timeExtent", () => this.filterVisibility.filterChanged())); this.elevationAlignment && this.watchUpdatingTracking.add(this.layer, "elevationInfo",
              (F, K) => { t.diff(F, K) && this.watchUpdatingTracking.addPromise(this.graphicsCore.elevationInfoChange()) }); this.watchUpdatingTracking.add(this.layer, "labelsVisible", () => this.graphicsCore.updateVisibilityInfo()); this.watchUpdatingTracking.add(this.layer, "labelingInfo", (F, K) => { t.diff(F, K) && this.graphicsCore.updateLabelingInfo() })
            }; M.setup = function () {
              var F = a._asyncToGenerator(function* () {
              this.frustumVisibility && this.frustumVisibility.setup(this.owner); const K = this.owner, P = this.owner.view.basemapTerrain, L =
                (N, G, I) => this.graphicsCore.spatialIndex.queryGraphicUIDsInExtent(N, G, I); this.scaleVisibility && this.scaleVisibility.setup(K, this.layer, L, this.graphicsCore, P); this.filterVisibility && ("filter" in K || "timeExtent" in K) && this.filterVisibility.setup(K, this.graphicsCore); this.elevationAlignment && this.elevationAlignment.setup(K, L, this.graphicsCore, K.view.elevationProvider); this._set("objectStates", new A.Graphics3DObjectStates(this.graphicsCore)); this._set("labeling", this.owner.view.labeler.addGraphicsOwner(this.graphicsCore,
                  this.scaleVisibility)); this._set("deconfliction", K.view.deconflictor.addGraphicsOwner(this.graphicsCore)); yield n.logOnError(this.graphicsCore.setup({ elevationAlignment: this.elevationAlignment, scaleVisibility: this.scaleVisibility, filterVisibility: this.filterVisibility, deconflictor: this.deconfliction, labeler: this.labeling, objectStates: this.objectStates })); this.watchUpdatingTracking.add(this.layer, "renderer", N => this.watchUpdatingTracking.addPromise(this.graphicsCore.rendererChange(N))); this.watchUpdatingTracking.add(K,
                    "fullOpacity", () => this.graphicsCore.opacityChange()); this.setupSuspendResumeExtent(); this.updateClippingExtent && (this.watchUpdatingTracking.add(K.view, "clippingArea", () => this._updateClippingExtent()), this._updateClippingExtent()); this.graphicsCore.startCreateGraphics(); this.graphicsCore.labelsEnabled && (yield n.logOnError(this.graphicsCore.updateLabelingInfo()))
              }); return function () { return F.apply(this, arguments) }
            }(); M.destroy = function () {
            this._handles && (this._handles.destroy(), this._handles = null); var F =
              "watchUpdatingTracking frustumVisibility scaleVisibility filterVisibility elevationAlignment objectStates graphicsCore".split(" "); for (const K of F) if (F = this[K]) F.destroy(), this._set(K, null); this._set("layer", null); this._set("owner", null)
            }; M.maskOccludee = function (F) { const { set: K, handle: P } = this.objectStates.acquireSet(1, null); this.objectStates.setUid(K, F.uid); return P }; M.highlight = function (F, K) {
              if (F instanceof m) {
                const { set: P, handle: L } = this.objectStates.acquireSet(0, K); this.owner.queryObjectIds(F).then(N =>
                  this.objectStates.setObjectIds(P, N)); return L
              } if ("number" === typeof F || "string" === typeof F || F instanceof c) return this.highlight([F], K); "toArray" in F && (F = F.toArray()); if (Array.isArray(F) && 0 < F.length) {
                if (F[0] instanceof c) if (null != C.attributeLookup(this.layer.fieldsIndex, F[0].attributes, K)) F = F.map(P => C.attributeLookup(this.layer.fieldsIndex, P.attributes, K)); else { F = F.map(N => N.uid); const { set: P, handle: L } = this.objectStates.acquireSet(0, null); this.objectStates.setUids(P, F); return L } if ("number" === typeof F[0] ||
                  "string" === typeof F[0]) { const { set: P, handle: L } = this.objectStates.acquireSet(0, K); this.objectStates.setObjectIds(P, F); return L }
              } return E
            }; M._updateClippingExtent = function () { const F = this.owner.view.clippingArea; this.graphicsCore.setClippingExtent(F, this.owner.view.spatialReference) && (this.updateClippingExtent(F) || this.graphicsCore.recreateAllGraphics()) }; M.setupSuspendResumeExtent = function () {
            (this.frustumVisibility || this.scaleVisibility) && this._handles.add(p.init(this, "suspendResumeExtentMode", () => {
              this._handles.remove("suspendResumeExtentMode"); switch (this.suspendResumeExtentMode) {
                case "computed": this._handles.add([p.init(this.graphicsCore, "computedExtent", F => this.updateSuspendResumeExtent(F)), this.graphicsCore.watch("extentPadding", () => this.updateSuspendResumeExtent(this.graphicsCore.computedExtent))], "suspendResumeExtentMode"); break; case "data": this._handles.add([p.init(this, "dataExtent", F => this.updateSuspendResumeExtent(F)), this.graphicsCore.watch("extentPadding", () => this.updateSuspendResumeExtent(this.dataExtent))],
                  "suspendResumeExtentMode"); break; default: u.neverReached(this.suspendResumeExtentMode)
              }
            }))
            }; M.updateSuspendResumeExtent = function (F) { F ? this.suspendResumeExtentChanged(this.extentToSuspendResumeRect(F, this.suspendResumeExtent)) : this.suspendResumeExtentChanged(null) }; M.extentToSuspendResumeRect = function (F, K) { const P = this.owner.view.spatialReference; if (!F.spatialReference.equals(P)) { if (!v.canProject(F, P)) return; F = v.project(F, P) } return B.enlargeExtent(F, K, e.SUSPEND_RESUME_EXTENT_OPTIMISM, this.graphicsCore.extentPadding) };
            M.suspendResumeExtentChanged = function (F) { this.frustumVisibility && this.frustumVisibility.setExtent(F); this.scaleVisibility && this.scaleVisibility.setExtent(F) }; a._createClass(J, [{ key: "suspended", get: function () { var F; return null == (F = this.scaleVisibility) ? void 0 : F.suspended } }, { key: "suspendInfo", get: function () { var F, K; const P = {}; null != (F = this.scaleVisibility) && F.suspended && (P.outsideScaleRange = !0); null != (K = this.frustumVisibility) && K.suspended && (P.outsideOfView = !0); return P } }, {
              key: "updating", get: function () {
                var F,
                K, P; return !!(null != (F = this.graphicsCore) && F.updating || null != (K = this.frustumVisibility) && K.updating || null != (P = this.watchUpdatingTracking) && P.updating)
              }
            }]); return J
          }(q); w.__decorate([l.property({ aliasOf: "graphicsCore.layer" })], q.prototype, "layer", void 0); w.__decorate([l.property({ aliasOf: "graphicsCore.owner" })], q.prototype, "owner", void 0); w.__decorate([l.property({ constructOnly: !0 })], q.prototype, "updateClippingExtent", void 0); w.__decorate([l.property({ constructOnly: !0 })], q.prototype, "graphicsCore",
            void 0); w.__decorate([l.property({ constructOnly: !0 })], q.prototype, "scaleVisibility", void 0); w.__decorate([l.property({ constructOnly: !0 })], q.prototype, "filterVisibility", void 0); w.__decorate([l.property({ constructOnly: !0 })], q.prototype, "elevationAlignment", void 0); w.__decorate([l.property({ constructOnly: !0 })], q.prototype, "frustumVisibility", void 0); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "deconfliction", void 0); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "labeling", void 0); w.__decorate([l.property({ readOnly: !0 })],
              q.prototype, "objectStates", void 0); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "watchUpdatingTracking", void 0); w.__decorate([l.property()], q.prototype, "suspendResumeExtentMode", void 0); w.__decorate([l.property()], q.prototype, "dataExtent", void 0); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "suspended", null); w.__decorate([l.property({ readOnly: !0 })], q.prototype, "suspendInfo", null); w.__decorate([l.property({
                readOnly: !0, dependsOn: ["graphicsCore.updating", "frustumVisibility.updating",
                  "watchUpdatingTracking.updating"]
              })], q.prototype, "updating", null); q = w.__decorate([f.subclass("esri.views.3d.layers.graphics.Graphics3DFeatureLikeLayerView")], q); const E = { remove() { }, pause() { }, resume() { } }; return q
        })
    }, "esri/views/3d/layers/graphics/Graphics3DCore": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../geometry ../../../../renderers/ClassBreaksRenderer ../../../../renderers/DictionaryRenderer ../../../../renderers/DotDensityRenderer ../../../../renderers/HeatmapRenderer ../../../../renderers/Renderer ../../../../renderers/SimpleRenderer ../../../../renderers/UniqueValueRenderer ../../../../renderers/support/jsonUtils ../../../../symbols ../../../../core/Accessor ../../../../core/has ../../../../core/Error ../../../../core/Handles ../../../../core/Logger ../../../../core/MapUtils ../../../../core/maybe ../../../../core/PooledArray ../../../../core/promiseUtils ../../../../core/scheduling ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../core/accessorSupport/diffUtils ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ../../../../layers/Layer ../../../../layers/graphics/dehydratedFeatures ../../../../layers/graphics/hydratedFeatures ../../../../renderers/support/rendererConversion ../../../../support/arcadeOnDemand ../../../../symbols/support/defaults3D ../../../../symbols/support/symbolConversion ./ElevationQuery ./featureExpressionInfoUtils ./Graphics3DFeatureStore ./Graphics3DGraphicCreationContext ./Graphics3DSymbolCreationContext ./Graphics3DSymbolFactory ./Graphics3DWebStyleSymbol ./GraphicStateTracking ./graphicUtils ./SpatialIndex2D ./symbolComplexity ../support/StageLayerElevationProvider ../../support/extentUtils ../../support/PropertiesPool ../../webgl-engine/lib/GridLocalOriginFactory ../../webgl-engine/lib/WebGLLayer ../../../support/Scheduler ../../../../geometry/Extent ../../../../geometry/Point ../../../../symbols/LabelSymbol3D ../../../../symbols/TextSymbol ../../../../symbols/WebStyleSymbol".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q, T, da, Y, fa, ha, ka, ea, ba, aa, W, U, X, Z, ia, la, ma, ra, Aa, za, Ka, Ea, Ua) {
          var Na; const ya = F.create(), pa = P.create(), wa = g.getLogger("esri.views.3d.layers.graphics.Graphics3DCore"); a.Graphics3DCore = Na = function (sa) {
            function Ca(ca) {
              var qa = sa.call(this, ca) || this; qa.propertiesPool = new ia.PropertiesPool({ computedExtent: Aa }, w._assertThisInitialized(qa)); qa.computedExtent = null; qa.currentRenderer = null; qa.rendererHasGeometryOperations =
                !1; qa.graphicStateTracking = null; qa.symbolCreationContext = new ha.Graphics3DSymbolCreationContext((Da, na) => qa._frameTask.schedule(Da, na)); qa.graphics3DGraphics = new Map; qa.stageLayer = null; qa.stage = null; qa.graphicsDrapedUids = new Set; qa.graphicsBySymbol = new Map; qa.symbolConversionCache = new Map; qa.symbols = new Map; qa.graphicsWithoutSymbol = new Map; qa.graphicsWaitingForSymbol = new Map; qa.graphicsUpdateId = 0; qa._handles = new e; qa._frameTask = ra.ImmediateTask; qa.suspendSymbolCleanup = !1; qa._spatialReference = null;
              qa.arcadeOnDemand = null; qa.rendererChangeAbortController = null; qa.elevationInfoChangeAbortController = null; qa.setupAbortController = null; qa.elevationAlignment = null; qa.scaleVisibility = null; qa.filterVisibility = null; qa._spatialIndex = null; qa.extentPadding = 0; qa._updatingPendingLoadedGraphicsChange = null; qa.featureStore = null; qa.deconflictor = null; qa.labeler = null; qa.objectStates = null; qa.viewElevationProvider = null; qa.stageLayerElevationProvider = null; qa.sharedSymbolResourcesOwnerHandle = null; qa.whenGraphics3DGraphicRequests =
                {}; qa.pendingUpdates = new Map; qa.numberOfGraphics = 0; qa.numberOfGraphicsProvidingElevation = 0; qa.pendingAdds = 0; qa.pendingRemoves = 0; qa.pendingUpdatesPool = new r({ allocator: Da => Da || new Ia, deallocator: Da => { Da.clear(); return Da } }); qa.symbolWarningLogged = !1; qa.geometryWarningLogged = !1; qa.objectIdInvisibleSet = new Set; qa._whenSymbolRemoved = new r; qa.preferredUpdatePolicy = 1; qa.forcedUpdatePolicy = null; qa.elevationFeatureExpressionEnabled = !0; qa.owner = null; qa.layer = null; qa.graphicSymbolSupported = !0; qa.getRenderingInfoWithoutRenderer =
                  !1; qa.hasZ = null; qa.hasM = null; qa._usedMemory = 0; qa._visible = void 0; qa._startCreateGraphics = !1; return qa
            } w._inheritsLoose(Ca, sa); var Ja = Ca.prototype; Ja.getConvertedSymbol = function (ca) { if ("web-style" === ca.type) return ca.clone(); var qa = this.symbolConversionCache.get(ca.id); if (k.isSome(qa)) return qa; qa = Q.to3D(ca, { retainId: !0, hasLabelingContext: this.hasLabelingContext(ca) }); const Da = qa.symbol || null; k.isNone(Da) && qa.error && wa.error(qa.error.message); this.symbolConversionCache.set(ca.id, Da); return Da }; Ja.getSymbolComplexitiesUsedOrRenderer =
              function (ca) { if (k.isNone(ca)) return []; var qa = ca.getSymbols(), Da = "backgroundFillSymbol" in ca && ca.backgroundFillSymbol; if (!(Da || qa && qa.length)) return []; ca = []; Da = this.getSymbolComplexityUsedOrRenderer(Da); k.isSome(Da) && ca.push(Da); for (const na of qa) qa = this.getSymbolComplexityUsedOrRenderer(na), k.isSome(qa) && ca.push(qa); return ca }; Ja.getSymbolComplexityUsedOrRenderer = function (ca) {
                if (k.isNone(ca)) return null; const qa = this.symbols.get(ca.id); if (k.isSome(qa)) return qa.complexity; ca = this.getConvertedSymbol(ca);
                return k.isSome(ca) ? U.defaultSymbolComplexity(ca) : null
              }; Ja.getSymbolComplexitiesUsed = function () { const ca = []; this.symbols.forEach(qa => { k.isSome(qa) && ca.push(qa.complexity) }); return ca }; Ja.initialize = function () { this._spatialReference = this.owner.view.spatialReference; this._set("featureStore", new Y.default({ objectIdField: this.owner.layer && this.owner.layer.objectIdField, hasZ: this.hasZ, hasM: this.hasM, spatialReference: this._spatialReference, getSpatialIndex: () => this.spatialIndex, forAllGraphics: ca => this.graphics3DGraphics.forEach(ca) })) };
            Ja.setup = function () {
              var ca = w._asyncToGenerator(function* (qa) {
              this.setupAbortController = new AbortController; const Da = this.setupAbortController.signal; this._set("elevationAlignment", qa.elevationAlignment); this._set("scaleVisibility", qa.scaleVisibility); this._set("filterVisibility", qa.filterVisibility); this._set("deconflictor", qa.deconflictor); this._set("labeler", qa.labeler); this._set("objectStates", qa.objectStates); const na = this.owner.view; this.viewElevationProvider = new T.ViewElevationProvider(this._spatialReference,
                na); this.initializeStage(na, this.layer.uid); this.symbolCreationContext.sharedResources = na.sharedSymbolResources; this.sharedSymbolResourcesOwnerHandle = na.sharedSymbolResources.addGraphicsOwner(this.owner); k.isSome(this.currentRenderer) && (this.symbolCreationContext.renderer = this.currentRenderer); this.symbolCreationContext.stage = this.stage; this.symbolCreationContext.streamDataRequester = na.sharedSymbolResources.streamDataRequester; this.symbolCreationContext.renderCoordsHelper = na.renderCoordsHelper; this.symbolCreationContext.layer =
                  this.layer; this.symbolCreationContext.layerView = this.owner; this.symbolCreationContext.localOriginFactory = new la.GridLocalOriginFactory(na.renderSpatialReference); this.symbolCreationContext.elevationProvider = na.elevationProvider; this.symbolCreationContext.notifyGraphicGeometryChanged = xa => this.notifyGraphicGeometryChanged(xa); this.symbolCreationContext.notifyGraphicVisibilityChanged = xa => this.notifyGraphicVisibilityChanged(xa); qa = da.extractExpressionInfo(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
                this.symbolCreationContext.featureExpressionInfoContext = yield da.createContext(qa, this._spatialReference, wa); A.throwIfAborted(Da); this.symbolCreationContext.screenSizePerspectiveEnabled = na.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled; this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled; this.symbolCreationContext.physicalBasedRenderingEnabled = !!this.owner.view.qualitySettings.physicallyBasedRenderingEnabled; qa = "layer" in this.owner ? ["layer.screenSizePerspectiveEnabled,view.screenSizePerspectiveEnabled"] :
                  "view.screenSizePerspectiveEnabled"; this._handles.add([this.watch("suspendedOrOutsideOfView", () => this._frameTask.reschedule(() => this.updateLayerVisibility())), this.owner.watch(qa, () => { const xa = na.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled; if (xa !== this.symbolCreationContext.screenSizePerspectiveEnabled) { var Qa; this.symbolCreationContext.screenSizePerspectiveEnabled = xa; null == (Qa = this.labeler) ? void 0 : Qa.reset(); this.recreateAllGraphics() } }), this.owner.watch("slicePlaneEnabled",
                    xa => this.slicePlaneEnabledChange(!!xa)), this.owner.view.watch("pixelRatio", () => this.pixelRatioChange()), this.owner.view.watch("qualitySettings.physicallyBasedRenderingEnabled", xa => this.physicalBasedRenderingChange(xa)), B.when(na.basemapTerrain, "tilingScheme", xa => {
                      xa.spatialReference.equals(this.symbolCreationContext.overlaySR) || (this.symbolCreationContext.overlaySR = na.basemapTerrain.spatialReference); this._handles.has("loaded-graphics") ? this.recreateAllGraphics() : this._handles.add([B.on(this.owner,
                        "loadedGraphics", "change", Qa => this.graphicsCollectionChanged(Qa), () => this.recreateAllGraphics()), B.on(this.owner, "loadedGraphics", "after-changes", () => this._signalUpdatingDuringAsyncLoadedGraphicsChange(), () => this._signalUpdatingDuringAsyncLoadedGraphicsChange())], "loaded-graphics")
                    }), B.whenFalse(this, "asyncUpdates", () => this.runTask(ra.noBudget), !0), B.init(this, "effectiveUpdatePolicy", xa => {
                      k.isSome(this.stageLayer) && (this.stageLayer.updatePolicy = xa); this.symbolCreationContext.isAsync = 0 === this.effectiveUpdatePolicy;
                      1 === xa && this.runTask(ra.noBudget)
                    }, !0)]); this._frameTask = na.resourceController.scheduler.registerTask(ra.TaskPriority.GRAPHICS_CORE, this); this.owner.layer && "featureReduction" in this.owner.layer && this._handles.add(this.owner.watch("layer.featureReduction", () => this.deconflictor.featureReductionChange())); this.notifyChange("averageSymbolComplexity"); try { yield this.rendererChange(this.layer.renderer) } catch{ } A.throwIfAborted(Da); this.setupAbortController = null
              }); return function (qa) {
                return ca.apply(this,
                  arguments)
              }
            }(); Ja.abortSetup = function () { this.setupAbortController && (this.setupAbortController.abort(), this.setupAbortController = null) }; Ja.destroy = function () {
              this.abortSetup(); this.abortRendererChange(); this.abortElevationInfoChange(); this.owner.view.deconflictor.removeGraphicsOwner(this); this.owner.view.labeler.removeGraphicsOwner(this); this._updatingPendingLoadedGraphicsChange = k.removeMaybe(this._updatingPendingLoadedGraphicsChange); this.clear(); this.graphicStateTracking = k.destroyMaybe(this.graphicStateTracking);
              this.stage && (this.stage.remove(this.stageLayer), this.stage = this.stageLayer = null); this._handles = k.destroyMaybe(this._handles); this._frameTask.remove(); this._frameTask = ra.ImmediateTask; this._spatialReference = null; this._set("owner", null); for (const ca in this.whenGraphics3DGraphicRequests) this.whenGraphics3DGraphicRequests[ca].reject(new m("graphic:layer-destroyed", "Layer has been destroyed")); this.whenGraphics3DGraphicRequests = null; this.sharedSymbolResourcesOwnerHandle = k.removeMaybe(this.sharedSymbolResourcesOwnerHandle);
              this.propertiesPool = k.destroyMaybe(this.propertiesPool); this.pendingUpdatesPool = null; this.symbolConversionCache.clear(); this.objectIdInvisibleSet.clear(); this._spatialIndex = k.destroyMaybe(this._spatialIndex); this._set("featureStore", k.destroyMaybe(this.featureStore))
            }; Ja.clear = function () {
              var ca, qa; null == (ca = this.objectStates) ? void 0 : ca.allGraphicsDeleted(); k.isSome(this.graphicStateTracking) && this.graphicStateTracking.allGraphicsDeleted(); this.graphics3DGraphics.forEach(Da => Da.destroy()); null == (qa =
                this._spatialIndex) ? void 0 : qa.clear(); this.graphics3DGraphics.clear(); this._usedMemory = this.numberOfGraphics = 0; this.updateLayerVisibility(); this.symbols.forEach(k.destroyMaybe); this.symbols.clear(); this.graphicsBySymbol.clear(); this.graphicsWithoutSymbol.clear(); this.graphicsWaitingForSymbol.clear(); this.pendingUpdates.clear(); this.pendingUpdatesPool.clear(); this.pendingRemoves = this.pendingAdds = 0; this.notifyChange("updating"); this.notifyChange("running"); this.notifyChange("updatingRemaining"); this.featureStore.events.emit("changed")
            };
            Ja.initializeStage = function (ca, qa) {
            this.stage = ca._stage; this.stageLayer = new ma.WebGLLayer({ isPickable: !this.suspendedOrOutsideOfView, updatePolicy: this.effectiveUpdatePolicy }, qa); this.stage.add(this.stageLayer); ca = this.stageLayer.events; ca.on("objectTransformation", Da => this.notifyGraphicGeometryChanged(Da.metadata.graphicUid)); ca.on("visibilityChanged", Da => this.notifyGraphicVisibilityChanged(Da.metadata.graphicUid)); ca.on("objectGeometryAdded", Da => this.notifyGraphicGeometryChanged(Da.object.metadata.graphicUid));
              ca.on("objectGeometryRemoved", Da => this.notifyGraphicGeometryChanged(Da.object.metadata.graphicUid)); ca.on("vertexAttrsUpdated", Da => this.notifyGraphicGeometryChanged(Da.object.metadata.graphicUid))
            }; Ja.notifyGraphicGeometryChanged = function (ca) { k.isNone(this.graphicStateTracking) || k.isNone(ca) || (ca = this.graphics3DGraphics.get(ca)) && this.graphicStateTracking.updateGraphicGeometry(ca) }; Ja.notifyGraphicVisibilityChanged = function (ca) {
              k.isNone(this.graphicStateTracking) || k.isNone(ca) || (ca = this.graphics3DGraphics.get(ca)) &&
                this.graphicStateTracking.updateGraphicVisibility(ca)
            }; Ja.updateLayerVisibility = function () { var ca = this.numberOfGraphics > 10 * this.displayFeatureLimit.maximumNumberOfFeatures; ca = !this.suspendedOrOutsideOfView && !ca; ca !== this._visible && ((this._visible = ca) ? (this.stageLayer.isPickable = !0, this.updateAllGraphicsVisibility()) : (this.stageLayer.isPickable = !1, this.hideAllGraphics()), this.updateStageLayerVisibility()) }; Ja.updateStageLayerVisibility = function () {
              this.stageLayer.isVisible = this._visible && (null == this.layer.opacity ||
                0 < this.layer.opacity)
            }; Ja.getGraphics3DGraphicById = function (ca) { return this.graphics3DGraphics.get(ca) }; Ja.getGraphics3DGraphicByObjectId = function (ca) { var qa; return null != (qa = this.owner.layer) && qa.objectIdField ? this._findGraphics3DGraphicByObjectId(ca) : null }; Ja._getGraphicObjectID = function (ca, qa = this.owner.layer && this.owner.layer.objectIdField) { return G.getObjectId(ca, qa) }; Ja.updateLabelingInfo = function () {
              var ca = w._asyncToGenerator(function* (qa) {
                const Da = this.deconflictor && this.deconflictor.labelingInfoChange(qa);
                qa = this.labeler && this.labeler.labelingInfoChange(qa); yield A.eachAlways([Da, qa])
              }); return function (qa) { return ca.apply(this, arguments) }
            }(); Ja.updateVisibilityInfo = function () { this.deconflictor && this.deconflictor.labelingInfoChange(); this.labeler && this.labeler.visibilityInfoChange() }; Ja.runTask = function (ca) { this._frameTask.processQueue(ca); this._applyPendingUpdates(ca); this.notifyChange("running"); this.running || this.notifyChange("updating"); this.notifyChange("updatingRemaining") }; Ja.setObjectIdVisibility =
              function (ca, qa) { qa ? this.objectIdInvisibleSet.delete(ca) : this.objectIdInvisibleSet.add(ca); ca = this._findGraphics3DGraphicByObjectId(ca); k.isSome(ca) && this._updateUserVisibility(ca) }; Ja._findGraphics3DGraphicByObjectId = function (ca) { return x.findInMap(this.graphics3DGraphics, qa => this._getGraphicObjectID(qa.graphic) === ca) }; Ja._updateUserVisibility = function (ca) {
                if (k.isNone(ca)) return !1; var qa = ca.graphic; const Da = this._getGraphicObjectID(qa); qa = qa.visible && !this.owner.suspended && (k.isNone(Da) || !this.objectIdInvisibleSet.has(Da));
                return ca.setVisibilityFlag(0, qa, 0)
              }; Ja.whenGraphics3DGraphic = function (ca) { var qa = this.graphics3DGraphics.get(ca.uid); if (qa) return Promise.resolve(qa); if (qa = this.whenGraphics3DGraphicRequests[ca.uid]) return qa.promise; qa = A.createDeferred(); this.whenGraphics3DGraphicRequests[ca.uid] = qa; return qa.promise }; Ja.boundsForGraphics3DGraphic = function () {
                var ca = w._asyncToGenerator(function* (qa, Da) {
                  const na = this._spatialReference, xa = this.owner.view.renderSpatialReference, Qa = this.owner.view.basemapTerrain.spatialReference;
                  var Wa = this.viewElevationProvider ? { service: this.viewElevationProvider, useViewElevation: k.isSome(Da) && Da.useViewElevation, minDemResolution: k.isSome(Da) && Da.minDemResolution, minDemResolutionForPoints: this.owner.view.resolution } : null; qa = yield qa.getProjectedBoundingBox((Ra, ta, Fa) => K.projectBuffer(Ra, xa, ta, Ra, na, ta, Fa), (Ra, ta, Fa) => K.projectBuffer(Ra, Qa, ta, Ra, na, ta, Fa), Wa, k.get(Da, "signal")); if (!qa) return null; Da = qa.boundingBox; qa.requiresDrapedElevation && (Wa = this.symbolCreationContext.elevationProvider) &&
                    (P.center(Da, ya), Wa = k.unwrapOr(Wa.getElevation(ya[0], ya[1], 0, na, "ground"), 0), Da[2] = Math.min(Da[2], Wa), Da[5] = Math.max(Da[5], Wa)); return { boundingBox: Da, screenSpaceObjects: qa.screenSpaceObjects }
                }); return function (qa, Da) { return ca.apply(this, arguments) }
              }(); Ja.whenGraphicBounds = function () {
                var ca = w._asyncToGenerator(function* (qa, Da) {
                  yield B.whenOnce(this.owner, "loadedGraphics"); const na = this.owner.layer && this.owner.layer.objectIdField; var xa = this.owner.loadedGraphics.find(Qa => Qa === qa ? !0 : na && Qa.attributes &&
                    qa.attributes && Qa.attributes[na] === qa.attributes[na]); if (!xa) throw new m("internal:graphic-not-part-of-view", "Graphic is not part of this view"); xa = yield this.whenGraphics3DGraphic(xa); return this.boundsForGraphics3DGraphic(xa, Da)
                }); return function (qa, Da) { return ca.apply(this, arguments) }
              }(); Ja.computeAttachmentOrigin = function (ca, qa) {
                ca = this.graphics3DGraphics.get(ca.uid); if (!ca) return null; var Da = ca.computeAttachmentOrigin(); if (0 === Da.render.num && 0 === Da.draped.num) return null; M.set(Ha, 0, 0, 0); ca = 0;
                if (0 < Da.render.num) { if (!K.projectVectorToVector(Da.render.origin, this.symbolCreationContext.renderCoordsHelper.spatialReference, Oa, qa)) return null; M.add(Ha, Ha, Oa); ca++ } if (0 < Da.draped.num) { const [na, xa] = Da.draped.origin; Da = k.unwrapOr(this.viewElevationProvider.getElevation(na, xa, "ground"), 0); M.set(Oa, na, xa, Da); if (!K.projectVectorToVector(Oa, this.viewElevationProvider.spatialReference, Oa, qa)) return null; M.add(Ha, Ha, Oa); ca++ } 1 < ca && M.scale(Ha, Ha, 1 / ca); return new za({ x: Ha[0], y: Ha[1], z: Ha[2], spatialReference: qa })
              };
            Ja.getSymbolLayerSize = function (ca, qa) { var Da = this.symbols.get(ca.id); if (k.isNone(Da)) throw new m("internal:symbol-not-part-of-view", "Symbol is not part of this view"); ca = ca.symbolLayers.indexOf(qa); if (-1 === ca) throw new m("internal:missing-symbol-layer", "Symbol layer is not in symbol"); Da = Da.getSymbolLayerSize(ca); if (null == Da) throw new m("internal:missing-size", "Symbol layer has no valid size"); return Da }; Ja.graphicsCollectionChanged = function (ca) { this._startCreateGraphics && (this.add(ca.added), this.remove(ca.removed)) };
            Ja.graphicUpdateHandler = function (ca) { var qa = ca.graphic.uid; const Da = this.graphics3DGraphics.get(qa); qa = this.graphicsWithoutSymbol.get(qa); if (Da || qa) switch (ca.property) { case "visible": this.graphicUpdateVisibleHandler(Da); break; case "geometry": this.graphicUpdateGeometryHandler(Da, ca); break; case "symbol": this.graphicUpdateSymbolHandler(Da, ca) } }; Ja.graphicUpdateGeometryHandler = function (ca, qa) {
              const Da = qa.graphic.geometry; if (k.isNone(Da)) this.recreateGraphic(qa.graphic); else if (k.isNone(ca)) {
                if (ca = qa.graphic.symbol &&
                  qa.graphic.symbol.id) if (ca = this.symbols.get(ca), k.isSome(ca) && 0 === ca.loadStatus) return; this.recreateGraphic(qa.graphic)
              } else { var na = ca.graphics3DSymbol; !k.isNone(qa.newValue) && na.updateGeometry(ca, qa.newValue) || this.recreateGraphic(ca.graphic); this.expandComputedExtent(Da) }
            }; Ja.graphicUpdateSymbolHandler = function (ca, qa) {
              var Da = qa.graphic; const na = k.isSome(ca) ? ca.graphics3DSymbol : k.isSome(qa.oldValue) ? this.symbols.get(qa.oldValue.id) : null; if (k.isNone(na) || k.isNone(qa.newValue)) this.recreateGraphic(Da);
              else {
                var xa = na.symbol; qa = this.getConvertedSymbol(qa.newValue); if (k.isSome(qa) && (qa.type !== xa.type || "web-style" === qa.type) || "web-style" === xa.type) this.recreateGraphic(Da); else {
                  var Qa = this.graphicsBySymbol.get(xa.id); if (Qa && 1 !== Qa.size) this.recreateGraphic(Da); else if (Qa = J.diff(xa, qa), k.isNone(Qa)) this.updateSymbolMapping(xa.id, qa); else if (Qa = { diff: Qa, graphics3DGraphicPatches: [], symbolStatePatches: [] }, na.prepareSymbolPatch(Qa), J.isEmpty(Qa.diff)) {
                    var Wa = this._getRenderingInfo(Da); if (k.isNone(Wa)) this.recreateGraphic(Da);
                    else { Da = na.extentPadding; for (const Ra of Qa.symbolStatePatches) Ra(); Da !== na.extentPadding && this.recomputeExtentPadding(); if (k.isSome(ca)) for (const Ra of Qa.graphics3DGraphicPatches) Ra(ca, Wa); this.updateSymbolMapping(xa.id, qa) }
                  } else this.recreateGraphic(Da)
                }
              }
            }; Ja.graphicUpdateVisibleHandler = function (ca) { this._updateUserVisibility(ca) && (this.labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty()) }; Ja.recreateGraphics = function (ca) {
            this.suspendSymbolCleanup = !0; this.remove(ca);
              this.add(ca); this.suspendSymbolCleanup = !1; 1 === this.effectiveUpdatePolicy && this._cleanupSymbols()
            }; Ja.recreateGraphic = function (ca) { this.recreateGraphics([ca]) }; Ja._beginGraphicUpdate = function (ca) { const qa = this.graphicsUpdateId; this.graphicsUpdateId++; this.graphicsWaitingForSymbol.set(ca.uid, qa); 1 === this.graphicsWaitingForSymbol.size && this.notifyChange("updating"); return qa }; Ja._endGraphicUpdate = function (ca) {
              ca && (this.graphicsWaitingForSymbol.delete(ca.uid), 0 === this.graphicsWaitingForSymbol.size && (this._cleanupSymbols(),
                this.notifyChange("updating")))
            }; Ja.recomputeExtentPadding = function () { let ca = 0; this.symbols.forEach(qa => { k.isSome(qa) && (ca = Math.max(ca, qa.extentPadding)) }); this._set("extentPadding", ca) }; Ja.expandComputedExtent = function (ca) {
              var qa = ca.spatialReference; G.computeAABB(ca, pa); ca = this._spatialReference; var Da = Na.tmpVec; !qa.equals(ca) && K.projectXYZToVector(pa[0], pa[1], 0, qa, Da, ca) && (pa[0] = Da[0], pa[1] = Da[1], K.projectXYZToVector(pa[3], pa[4], 0, qa, Da, ca), pa[3] = Da[0], pa[4] = Da[1]); if (isFinite(pa[0]) && isFinite(pa[3]) &&
                isFinite(pa[1]) && isFinite(pa[4])) {
                  qa = this.computedExtent; Da = null; var na = isFinite(pa[2]) && isFinite(pa[5]), xa = na && (!qa || null == qa.zmin || pa[2] < qa.zmin); na = na && (!qa || null == qa.zmax || pa[5] > qa.zmax); if (qa) { if (pa[0] < qa.xmin || pa[1] < qa.ymin || pa[3] > qa.xmax || pa[4] > qa.ymax || xa || na) Da = this.propertiesPool.get("computedExtent"), Da.xmin = Math.min(pa[0], qa.xmin), Da.ymin = Math.min(pa[1], qa.ymin), Da.xmax = Math.max(pa[3], qa.xmax), Da.ymax = Math.max(pa[4], qa.ymax), Da.spatialReference = ca } else Da = this.propertiesPool.get("computedExtent"),
                    Da.xmin = pa[0], Da.ymin = pa[1], Da.xmax = pa[3], Da.ymax = pa[4], Da.spatialReference = ca; Da && (xa && (Da.zmin = pa[2]), na && (Da.zmax = pa[5]), this._set("computedExtent", Da))
              }
            }; Ja.abortElevationInfoChange = function () { this.elevationInfoChangeAbortController && (this.elevationInfoChangeAbortController.abort(), this.elevationInfoChangeAbortController = null) }; Ja.elevationInfoChange = function () {
              var ca = w._asyncToGenerator(function* () {
                var qa, Da; this.abortElevationInfoChange(); const na = new AbortController; this.elevationInfoChangeAbortController =
                  na; const xa = da.extractExpressionInfo(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled); this.symbolCreationContext.featureExpressionInfoContext = yield da.createContext(xa, this._spatialReference, wa); A.throwIfAborted(na); this.elevationInfoChangeAbortController = null; null == (qa = this.labeler) ? void 0 : qa.elevationInfoChange(); this.forEachGraphics3DSymbol((Qa, Wa, Ra) => {
                    Qa.globalPropertyChanged("elevationInfo", Wa) ? Wa.forEach(ta => {
                      const Fa = ta.graphic; ta = ta.labelGraphics; for (const Sa of ta) Sa.graphics3DSymbolLayer.updateGraphicElevationContext(Fa,
                        Sa)
                    }) : this._recreateSymbol(Ra)
                  }); this.updateStageLayerElevationProvider(); null == (Da = this.elevationAlignment) ? void 0 : Da.elevationInfoChange()
              }); return function () { return ca.apply(this, arguments) }
            }(); Ja.updateStageLayerElevationProvider = function () {
              if (this.stageLayerElevationProvider) {
                if (this.layer.elevationInfo && "relative-to-scene" === this.layer.elevationInfo.mode || 0 === this.numberOfGraphicsProvidingElevation) this.owner.view.elevationProvider.unregister(this.stageLayerElevationProvider), this.stageLayerElevationProvider.dispose(),
                  this.stageLayerElevationProvider = null
              } else (!this.layer.elevationInfo || this.layer.elevationInfo && "relative-to-scene" !== this.layer.elevationInfo.mode) && 0 < this.numberOfGraphicsProvidingElevation && (this.stageLayerElevationProvider = new X.StageLayerElevationProvider({ layer: this.layer, stageLayer: this.stageLayer, view: this.owner.view }), this.owner.view.elevationProvider.register("scene", this.stageLayerElevationProvider))
            }; Ja.clearSymbolsAndGraphics = function () {
              var ca, qa, Da, na, xa; this.clear(); null == (ca = this.filterVisibility) ?
                void 0 : ca.clear(); null == (qa = this.labeler) ? void 0 : qa.reset(); null == (Da = this.deconflictor) ? void 0 : Da.clear(); null == (na = this.elevationAlignment) ? void 0 : na.clear(); null == (xa = this.stageLayer) ? void 0 : xa.invalidateSpatialQueryAccelerator(); this.stageLayerElevationProvider && (this.owner.view.elevationProvider.unregister(this.stageLayerElevationProvider), this.stageLayerElevationProvider.dispose(), this.stageLayerElevationProvider = null)
            }; Ja.startCreateGraphics = function () { this._startCreateGraphics = !0; this.recreateAllGraphics() };
            Ja.recreateAllGraphics = function () { this._recreateAllGraphics(!1) }; Ja.recreateAllGraphicsAndSymbols = function () { this._recreateAllGraphics(!0) }; Ja._recreateAllGraphics = function (ca = !1) {
              if (this._startCreateGraphics) {
                var { loadedGraphics: qa, view: Da } = this.owner, na = Da.basemapTerrain.tilingScheme && qa && qa.length ? qa.toArray() : null; !ca && na || this.clearSymbolsAndGraphics(); this.symbolCreationContext.screenSizePerspectiveEnabled = this.owner.view.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled;
                this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled; this._set("computedExtent", null); na && (ca ? this.add(na) : this.recreateGraphics(na))
              }
            }; Ja._recreateSymbol = function (ca) {
              var qa = this.graphicsBySymbol.get(ca); const Da = []; qa && (qa.forEach((na, xa) => { var Qa; const Wa = na.usedMemory; this._conditionalRemove(na, xa); null == (Qa = this._spatialIndex) ? void 0 : Qa.remove(na); Da.push(na.graphic); na.destroy(); this.removeGraphics3DGraphic(xa, Wa); this.updateLayerVisibility(); this.featureStore.events.emit("changed") }),
                this.graphicsBySymbol.set(ca, new Map)); qa = this.symbols.get(ca); k.destroyMaybe(qa); this.symbols.delete(ca); this.add(Da)
            }; Ja._recreateGraphicsForSymbol = function (ca) { if (ca = this.graphicsBySymbol.get(ca)) { const qa = []; ca.forEach(Da => qa.push(Da.graphic)); this.recreateGraphics(qa) } }; Ja._conditionalRemove = function (ca, qa) {
              var Da, na, xa; this.graphicsDrapedUids.delete(qa); null == (Da = this.objectStates) ? void 0 : Da.removeGraphic(ca); null == (na = this.labeler) ? void 0 : na.removeGraphic(ca); null == (xa = this.deconflictor) ? void 0 :
                xa.removeGraphic(ca); k.isSome(this.graphicStateTracking) && this.graphicStateTracking.removeGraphic(ca)
            }; Ja.add = function (ca) { ca && 0 !== ca.length && (this.owner.view.basemapTerrain && this.owner.view.basemapTerrain.tilingScheme ? (0 === this._updatePolicyForGraphics(ca) ? this._addDelayed(ca) : this._addImmediate(ca), this.notifyChange("updating")) : wa.error("#add()", "Cannot add graphics before terrain surface has been initialized")) }; Ja._updatePolicyForGraphics = function (ca) {
              if (1 === this.effectiveUpdatePolicy && ("mesh" ===
                this.layer.geometryType || null == this.layer.geometryType)) for (const qa of ca) if (k.isSome(qa.geometry) && "mesh" === qa.geometry.type && !qa.geometry.loaded) return 0; return this.effectiveUpdatePolicy
            }; Ja._addImmediate = function (ca) { this.symbolWarningLogged = this.geometryWarningLogged = !1; for (const qa of ca) this._addGraphic(qa, this._getRenderingInfo(qa, wa), 1); this._cleanupSymbols(); this.labeler && (this.owner.view.labeler.setDirty(), this._cleanupSymbols()); this.owner.view.deconflictor.setDirty() }; Ja._addDelayed =
              function (ca) { for (const qa of ca) { ca = qa.uid; let Da = this.pendingUpdates.get(ca); Da ? Da.add ? 0 !== Da.state && Da.abortController.abort() : this.pendingAdds++ : (Da = this.pendingUpdatesPool.pushNew(), this.pendingAdds++ , this.pendingUpdates.set(ca, Da)); Da.add = qa } this.notifyChange("running"); this.notifyChange("updatingRemaining") }; Ja.remove = function (ca) { 0 === this.effectiveUpdatePolicy ? this._removeDelayed(ca) : this._removeImmediate(ca); this.notifyChange("updating") }; Ja._removeImmediate = function (ca) {
                for (const qa of ca) this._removeGraphic(qa);
                this._cleanupSymbols(); this.labeler && this.owner.view.labeler.setDirty(); this.owner.view.deconflictor.setDirty()
              }; Ja._removeDelayed = function (ca) {
                for (const Da of ca) { ca = Da.uid; var qa = this.pendingUpdates.get(ca); qa ? qa.add && (qa.remove ? qa.add = null : this.pendingUpdates.delete(ca), 1 === qa.state && qa.abortController.abort(), this.pendingAdds--) : (qa = this.pendingUpdatesPool.pushNew(), qa.remove = Da, this.pendingUpdates.set(ca, qa), this.pendingRemoves++) } 0 === this.pendingUpdates.size && this._finishPendingUpdates(); this.notifyChange("running");
                this.notifyChange("updatingRemaining")
              }; Ja._finishPendingUpdates = function () { this.pendingUpdatesPool.clear(); this._cleanupSymbols(); (this.pendingAdds || this.pendingRemoves) && wa.warn("pendingAdds/Removes in inconsistent state!"); this.pendingRemoves = this.pendingAdds = 0 }; Ja._applyPendingUpdates = function (ca) {
                var qa; this.symbolWarningLogged = this.geometryWarningLogged = !1; if (0 === this.pendingUpdates.size && null != (qa = this._spatialIndex) && qa.updating) this._spatialIndex.update(); else {
                  for (const [Da, na] of this.pendingUpdates) {
                    if (ca.done) break;
                    na.add && 0 === na.state && this._processPendingUpdateNew(na); qa = this.effectiveUpdatePolicy; !na.remove || na.add && 2 !== na.state || (this.pendingRemoves-- , ca.madeProgress(), this._removeGraphic(na.remove), na.remove = null, qa = 1); if (na.add) switch (na.state) { case 2: this._addGraphic(na.add, na.renderingInfo, qa); na.add = null; this.pendingAdds--; ca.madeProgress(); break; case 3: na.add = null, this.pendingAdds-- }null == na.remove && null == na.add && this.pendingUpdates.delete(Da)
                  } 0 === this.pendingUpdates.size && (this._finishPendingUpdates(),
                    this.notifyChange("running"))
                }
              }; Ja._processPendingUpdateNew = function (ca) { if (ca.add) { var qa = ca.add.geometry; k.isSome(qa) && "mesh" === qa.type && !qa.loaded ? this._processPendingUpdateNewMesh(ca, qa) : this._processPendingUpdateNewRenderingInfo(ca) } else ca.state = 2 }; Ja._processPendingUpdateNewMesh = function () {
                var ca = w._asyncToGenerator(function* (qa, Da) {
                qa.state = 1; qa.abortController = new AbortController; const na = qa.abortController.signal; try { yield Da.load({ signal: na }) } catch (xa) {
                  return this._processPendingUpdateNewError(qa,
                    xa)
                } qa.abortController = null; this._processPendingUpdateNewRenderingInfo(qa)
                }); return function (qa, Da) { return ca.apply(this, arguments) }
              }(); Ja._processPendingUpdateNewError = function (ca, qa) { ca.abortController = null; A.isAbortError(qa) ? ca.state = 0 : ca.state = 3 }; Ja._processPendingUpdateNewRenderingInfo = function () {
                var ca = w._asyncToGenerator(function* (qa) {
                  if (k.isNone(this.layer.renderer) || "dictionary" !== this.layer.renderer.type) qa.renderingInfo = this._getRenderingInfo(qa.add, wa); else {
                  qa.state = 1; qa.abortController =
                    new AbortController; var Da = null; try { Da = yield this._getRenderingInfoAsync(qa.add, { signal: qa.abortController.signal }) } catch (na) { qa.abortController = null; A.isAbortError(na) ? qa.state = 0 : qa.state = 3; return } k.isNone(Da) || k.isNone(Da.symbol) ? (wa && !this.symbolWarningLogged && (this.symbolWarningLogged = !0, wa.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), qa.renderingInfo = null) : qa.renderingInfo = Da
                  } qa.state = 2
                }); return function (qa) { return ca.apply(this, arguments) }
              }(); Ja._addGraphic = function (ca,
                qa, Da) {
                  this.graphicsWithoutSymbol.set(ca.uid, ca); if (!k.isNone(qa) && !k.isNone(qa.symbol) && G.hasGeometry(ca)) {
                    var na = this.getOrCreateGraphics3DSymbol(qa.symbol, qa.renderer); if (!k.isNone(na)) {
                      this.expandComputedExtent(ca.geometry); var xa = this._beginGraphicUpdate(ca), Qa = new fa(ca, qa, this.layer), Wa = !1, Ra = Sa => { Sa === na.symbol.id && (Wa = !0) }; this._whenSymbolRemoved.push(Ra); var ta = () => {
                        if (!this.destroyed) {
                          this._whenSymbolRemoved.removeUnordered(Ra); if (this.graphicsWaitingForSymbol.get(ca.uid) !== xa || Wa || na.destroyed ||
                            this.graphicSymbolSupported && ca.symbol && ca.symbol.id !== na.symbol.id)--na.referenced; else { const Sa = this._createGraphics3DGraphic(na, Qa); this._spatialIndex && k.isSome(Sa) && this._spatialIndex.add(Sa); --na.referenced; this._endGraphicUpdate(ca) } this.featureStore.events.emit("changed"); this.labeler && this.owner.view.labeler.setDirty()
                        }
                      }, Fa = Sa => { this.destroyed || (this._whenSymbolRemoved.removeUnordered(Ra), Wa || (A.isAbortError(Sa) ? this.add([ca]) : na.destroyed || this._endGraphicUpdate(ca))) }; 0 === Da ? na.load(() =>
                        this._frameTask.schedule(ta), Sa => this._frameTask.schedule(() => Fa(Sa))) : na.load(ta, Fa)
                    }
                  }
              }; Ja._removeGraphic = function (ca) {
                ca = ca.uid; const qa = this.graphics3DGraphics.get(ca); if (qa) {
                  var Da; qa.graphics3DSymbol.onRemoveGraphic(qa); const na = qa.usedMemory, xa = qa.isElevationSource; this._conditionalRemove(qa, ca); null == (Da = this._spatialIndex) ? void 0 : Da.remove(qa); this.graphicsBySymbol.get(qa.graphics3DSymbol.symbol.id).delete(ca); this.graphicsWithoutSymbol.delete(ca); this.removeGraphics3DGraphic(ca, na, xa); qa.destroy();
                  this.featureStore.events.emit("changed")
                } else this.graphicsWithoutSymbol.delete(ca), this.graphicsWaitingForSymbol.delete(ca), 0 === this.graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("updating"))
              }; Ja.hasLabelingContext = function (ca) { if (ca instanceof Ka || ca instanceof Ea) { const qa = this.symbolCreationContext.layer; return qa.labelingInfo ? qa.labelingInfo.some(Da => Da.symbol === ca) : !1 } return !1 }; Ja.hasValidSymbolCreationContext = function (ca) {
                return ca instanceof Ka && !this.hasLabelingContext(ca) ?
                  (wa.error("LabelSymbol3D is only valid as part of a LabelClass. Using LabelSymbol3D as a renderer symbol is not supported."), !1) : !0
              }; Ja._getRenderingInfo = function (ca, qa) {
                const Da = ca.geometry; if (k.isNone(Da)) return qa && !this.geometryWarningLogged && (this.geometryWarningLogged = !0, qa.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null; if (!K.canProjectWithoutEngine(Da.spatialReference, this._spatialReference)) return qa && !this.geometryWarningLogged && (this.geometryWarningLogged =
                  !0, qa.warn(`Graphic in layer ${this.layer.id} has incompatible spatial reference and will not render`)), null; if (!this.graphicSymbolSupported && k.isSome(ca.symbol)) return qa && !this.symbolWarningLogged && (this.symbolWarningLogged = !0, qa.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null; ca = this.rendererHasGeometryOperations ? I.hydrateGraphic(ca, this.layer) : ca; ca = this.owner.getRenderingInfo && (this.getRenderingInfoWithoutRenderer || k.isSome(this.currentRenderer)) ?
                    this.owner.getRenderingInfo(ca, this.currentRenderer, k.unwrap(this.arcadeOnDemand)) : { symbol: ca.symbol || S.getDefaultSymbol3D(ca.geometry) }; return k.isNone(ca) || k.isNone(ca.symbol) ? (qa && !this.symbolWarningLogged && (this.symbolWarningLogged = !0, qa.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), null) : ca
              }; Ja._getRenderingInfoAsync = function (ca, qa) {
                if (k.isNone(ca.geometry)) return wa && !this.geometryWarningLogged && (this.geometryWarningLogged = !0, wa.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)),
                  null; if (!this.graphicSymbolSupported && k.isSome(ca.symbol)) return wa && !this.symbolWarningLogged && (this.symbolWarningLogged = !0, wa.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null; ca = this.rendererHasGeometryOperations ? I.hydrateGraphic(ca, this.layer) : ca; return this.owner.getRenderingInfoAsync(ca, k.unwrap(this.currentRenderer), k.unwrap(this.arcadeOnDemand), qa)
              }; Ja.createGraphics3DSymbol = function (ca, qa) {
                if (!this.hasValidSymbolCreationContext(ca)) return null;
                ca = this.getConvertedSymbol(ca); if (!ca) return null; let Da; k.isSome(qa) && "backgroundFillSymbol" in qa && qa.backgroundFillSymbol && (qa = Q.to3D(qa.backgroundFillSymbol, { ignoreDrivers: !0 }), k.isSome(qa.symbol) && "web-style" !== qa.symbol.type && "cim" !== qa.symbol.type && (Da = qa.symbol.symbolLayers)); const na = ka.make(ca, this.symbolCreationContext, Da); na.load(() => { const xa = na.extentPadding; xa > this.extentPadding && this._set("extentPadding", xa); this.notifyChange("averageSymbolComplexity") }, () => { }); return na
              }; Ja.getOrCreateGraphics3DSymbol =
                function (ca, qa) { let Da = this.symbols.get(ca.id); void 0 === Da && (Da = ca instanceof Ua ? new ea(ca, na => this._frameTask.schedule(na), na => this.createGraphics3DSymbol(na, qa)) : this.createGraphics3DSymbol(ca, qa), this.symbols.set(ca.id, Da)); k.isSome(Da) && ++Da.referenced; return Da }; Ja.trackGraphicState = function (ca) { k.isNone(this.graphicStateTracking) && (this.graphicStateTracking = new ba.GraphicStateTracking(this)); return this.graphicStateTracking.add(ca) }; Ja.addGraphics3DGraphic = function (ca) {
                this._usedMemory += ca.usedMemory;
                  this.graphics3DGraphics.set(ca.graphic.uid, ca); this.numberOfGraphics++; ca.isElevationSource && (this.numberOfGraphicsProvidingElevation++ , this.updateStageLayerElevationProvider()); this.updateLayerVisibility()
                }; Ja.removeGraphics3DGraphic = function (ca, qa, Da = !1) { this._usedMemory -= qa; this.graphics3DGraphics.delete(ca); this.numberOfGraphics--; Da && (this.numberOfGraphicsProvidingElevation-- , this.updateStageLayerElevationProvider()); this.updateLayerVisibility() }; Ja._createGraphics3DGraphic = function (ca, qa) {
                  var Da,
                  na, xa, Qa; const Wa = qa.graphic; this.graphicsWithoutSymbol.delete(Wa.uid); if (!this.symbols.has(ca.symbol.id)) return this.add([Wa]), null; if (this.graphics3DGraphics.has(Wa.uid)) return null; qa = ca.createGraphics3DGraphic(qa); if (k.isNone(qa)) return null; this.addGraphics3DGraphic(qa); ca = ca.symbol.id; this.graphicsBySymbol.has(ca) || this.graphicsBySymbol.set(ca, new Map); this.graphicsBySymbol.get(ca).set(Wa.uid, qa); qa.isDraped && this.graphicsDrapedUids.add(Wa.uid); qa.centroid = null; k.isSome(Wa.geometry) && "point" !==
                    Wa.geometry.type && (qa.centroid = aa.computeCentroid(Wa.geometry, this._spatialReference)); this._updateUserVisibility(qa); k.isSome(this.scaleVisibility) && this.scaleVisibility.updateVisibility(qa); null == (Da = this.filterVisibility) ? void 0 : Da.updateVisibility(qa); null == (na = this.deconflictor) ? void 0 : na.addGraphic(qa); null == (xa = this.labeler) ? void 0 : xa.addGraphic(qa); null == (Qa = this.objectStates) ? void 0 : Qa.addGraphic(qa); this.deconflictor && this.owner.view.deconflictor.setInitialIconVisibilityFlag(this, qa); qa.initialize(this.stage,
                      this.stageLayer, this.owner); k.isSome(this.graphicStateTracking) && this.graphicStateTracking.addGraphic(qa); if (Da = this.whenGraphics3DGraphicRequests[Wa.uid]) delete this.whenGraphics3DGraphicRequests[Wa.uid], Da.resolve(qa); return qa
                }; Ja.abortRendererChange = function () { this.rendererChangeAbortController && (this.rendererChangeAbortController.abort(), this.rendererChangeAbortController = null) }; Ja.rendererChange = function () {
                  var ca = w._asyncToGenerator(function* (qa) {
                    this.abortRendererChange(); if (qa !== this.currentRenderer) if (this.validateRenderer(qa),
                      k.isNone(qa) && this.currentRendererChange(null, !1), O.isSupportedRenderer3D(qa)) if (k.isSome(qa) && qa.arcadeRequired) {
                        var Da = new AbortController; this.rendererChangeAbortController = Da; const { arcadeUtils: na } = yield this.ensureArcade(); A.throwIfAborted(Da); na.hasGeometryOperations(qa) && (yield na.enableGeometryOperations(), A.throwIfAborted(Da)); 0 === this.effectiveUpdatePolicy ? yield this._frameTask.schedule(() => this.currentRendererChange(qa, !0), Da.signal) : this.currentRendererChange(qa, !0); this.rendererChangeAbortController =
                          null
                      } else 0 === this.effectiveUpdatePolicy ? (this.rendererChangeAbortController = Da = new AbortController, yield this._frameTask.schedule(() => this.currentRendererChange(qa, !1), Da.signal), this.rendererChangeAbortController = null) : this.currentRendererChange(qa, !1); else this.currentRendererChange(qa, !1)
                  }); return function (qa) { return ca.apply(this, arguments) }
                }(); Ja.ensureArcade = function () {
                  var ca = w._asyncToGenerator(function* () { k.isNone(this.arcadeOnDemand) && (this.arcadeOnDemand = yield R.loadArcade()); return this.arcadeOnDemand });
                  return function () { return ca.apply(this, arguments) }
                }(); Ja.currentRendererChange = function (ca, qa) {
                this.currentRenderer = ca; this.rendererHasGeometryOperations = qa; this.symbolCreationContext.arcade = k.unwrap(this.arcadeOnDemand); qa = this.symbolCreationContext.renderer; if (ca !== qa) if (this.symbolConversionCache.clear(), k.isNone(ca)) this.symbolCreationContext.renderer = null, this.recreateAllGraphicsAndSymbols(); else {
                  var Da = J.diff(qa, ca); this.updateUnchangedSymbolMappings(Da, ca, qa); this.symbolCreationContext.renderer =
                    ca; k.isNone(Da) || ("complete" === Da.type ? this.recreateAllGraphicsAndSymbols() : "partial" === Da.type && (this.applyRendererDiff(Da, ca, qa) ? this.volatileGraphicsUpdated() : this.recreateAllGraphicsAndSymbols()), this.notifyChange("averageSymbolComplexity"))
                }
                }; Ja.diffHasSymbolChange = function (ca) { for (const qa in ca.diff) switch (qa) { case "visualVariables": case "defaultSymbol": case "uniqueValueInfos": break; case "authoringInfo": case "fieldDelimiter": delete ca.diff[qa]; break; default: return !0 }return !1 }; Ja.applySymbolSetDiff =
                  function (ca, qa, Da) {
                    ca = ca || []; qa = qa || []; const na = []; for (const xa of qa) {
                      const Qa = this.graphicsBySymbol.get(xa.id); Qa && Qa.forEach((Wa, Ra) => {
                        var ta = Wa.graphic, Fa = this.layer instanceof N ? this.layer : null; const Sa = k.unwrap(this.arcadeOnDemand); if (xa !== Da.defaultSymbol || Da.getSymbol(I.hydrateGraphic(ta, Fa), { arcade: Sa }) !== Da.defaultSymbol) Fa = Wa.usedMemory, ca.length || Da.defaultSymbol ? na.push(ta) : this.graphicsWithoutSymbol.set(Ra, ta), ta = this.graphics3DGraphics.get(Ra), this._conditionalRemove(ta, Ra), Wa.destroy(),
                          Qa.delete(Ra), this.removeGraphics3DGraphic(Ra, Fa), this.updateLayerVisibility()
                      }); this._whenSymbolRemoved.forAll(Wa => Wa(xa.id))
                    } if (ca.length || na.length) this.graphicsWithoutSymbol.forEach(xa => na.push(xa)), this.graphicsWithoutSymbol.clear(), this.add(na); this._cleanupSymbols(); this.labeler && this.owner.view.labeler.setDirty(); this.owner.view.deconflictor.setDirty()
                  }; Ja.applyUniqueValueRendererDiff = function (ca, qa, Da) {
                    const na = ca.diff.defaultSymbol, xa = ca.diff.uniqueValueInfos; if (na || xa) {
                      const Qa = xa ? xa.added.map(Ra =>
                        Ra.symbol) : [], Wa = xa ? xa.removed.map(Ra => Ra.symbol) : []; if (xa) for (let Ra = 0; Ra < xa.changed.length; Ra++)Qa.push(xa.changed[Ra].newValue.symbol), Wa.push(xa.changed[Ra].oldValue.symbol); na ? (Da.defaultSymbol && Wa.push(Da.defaultSymbol), qa.defaultSymbol && Qa.push(qa.defaultSymbol)) : Da.defaultSymbol && Qa.length && Wa.push(qa.defaultSymbol); this.applySymbolSetDiff(Qa, Wa, qa); delete ca.diff.defaultSymbol; delete ca.diff.uniqueValueInfos; return !0
                    } return !1
                  }; Ja.calculateUnchangedSymbolMapping = function (ca, qa, Da) {
                    const na =
                      Qa => k.isSome(Qa) ? Qa.id : null; if (qa instanceof b && Da instanceof b && (k.isNone(ca) || "partial" === ca.type)) { var xa = ca && ca.diff; ca = xa && xa.defaultSymbol; xa = (xa = xa && xa.uniqueValueInfos) ? xa.unchanged.map(Qa => ({ oldId: na(Qa.oldValue.symbol), newId: na(Qa.newValue.symbol) })) : Da.uniqueValueInfos.map((Qa, Wa) => ({ oldId: na(Qa.symbol), newId: na(qa.uniqueValueInfos[Wa].symbol) })); !ca && Da.defaultSymbol && xa.push({ oldId: na(Da.defaultSymbol), newId: na(qa.defaultSymbol) }); return xa } return []
                  }; Ja.updateSymbolMapping = function (ca,
                    qa) { const Da = k.isSome(qa) && qa ? "string" === typeof qa ? qa : qa.id : null; qa = "string" === typeof qa ? null : qa; if (ca && ca !== Da) { var na = this.graphicsBySymbol.get(ca); this.graphicsBySymbol.delete(ca); void 0 !== na && this.graphicsBySymbol.set(Da, na); na = this.symbols.get(ca); void 0 !== na && (this.symbols.delete(ca), this.symbols.set(Da, na), k.isSome(na) && (k.isSome(qa) ? na.symbol = qa : na.symbol.id = Da)) } }; Ja.updateUnchangedSymbolMappings = function (ca, qa, Da) {
                      ca = this.calculateUnchangedSymbolMapping(ca, qa, Da); for (const { oldId: na, newId: xa } of ca) this.updateSymbolMapping(na,
                        xa)
                    }; Ja.applyRendererDiff = function (ca, qa, Da) { if (this.diffHasSymbolChange(ca)) return !1; if (qa instanceof b && Da instanceof b && this.applyUniqueValueRendererDiff(ca, qa, Da) && 0 === Object.keys(ca.diff).length) return !0; for (const [na] of this.graphicsBySymbol) if (Da = this.symbols.get(na), k.isSome(Da)) switch (Da.applyRendererDiff(ca, qa)) { case 0: this._recreateSymbol(na); break; case 1: this._recreateGraphicsForSymbol(na) }return !0 }; Ja.opacityChange = function () {
                      this.forEachGraphics3DSymbol((ca, qa) => ca.globalPropertyChanged("opacity",
                        qa)); this.updateStageLayerVisibility()
                    }; Ja.slicePlaneEnabledChange = function (ca) { ca !== this.symbolCreationContext.slicePlaneEnabled && (this.symbolCreationContext.slicePlaneEnabled = ca, this.stageLayer.isSliceable = ca, this.forEachGraphics3DSymbol((qa, Da) => qa.globalPropertyChanged("slicePlaneEnabled", Da)), this.deconflictor && this.deconflictor.slicePlaneEnabledChange(), this.labeler && this.labeler.slicePlaneEnabledChange()) }; Ja.physicalBasedRenderingChange = function (ca) {
                    ca !== this.symbolCreationContext.physicalBasedRenderingEnabled &&
                      (this.symbolCreationContext.physicalBasedRenderingEnabled = ca, this.forEachGraphics3DSymbol((qa, Da, na) => { qa.globalPropertyChanged("physicalBasedRenderingEnabled", Da) || this._recreateSymbol(na) }))
                    }; Ja.pixelRatioChange = function () { this.forEachGraphics3DSymbol((ca, qa, Da) => { ca.globalPropertyChanged("pixelRatio", qa) || this._recreateSymbol(Da) }) }; Ja._signalUpdatingDuringAsyncLoadedGraphicsChange = function () {
                    this._updatingPendingLoadedGraphicsChange && this._updatingPendingLoadedGraphicsChange.remove(); this._updatingPendingLoadedGraphicsChange =
                      z.schedule(() => { this._updatingPendingLoadedGraphicsChange = null })
                    }; Ja.setClippingExtent = function (ca, qa) { const Da = this.symbolCreationContext.clippingExtent, na = L.create(); Z.toBoundingRect(ca, na, qa) ? this.symbolCreationContext.clippingExtent = P.fromRect(P.create(), na) : this.symbolCreationContext.clippingExtent = null; return !P.equals(this.symbolCreationContext.clippingExtent, Da) }; Ja.modifyGraphics3DGraphicVisibilities = function (ca) {
                      let qa = !1; this.graphics3DGraphics.forEach(Da => { ca(Da) && (qa = !0) }); qa && (this.labeler &&
                        this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty())
                    }; Ja.forEachGraphics3DSymbol = function (ca) { for (const [qa, Da] of this.symbols) { if (k.isNone(Da)) break; const na = this.graphicsBySymbol.get(qa); ca(Da, na || Ba, qa) } }; Ja.updateAllGraphicsVisibility = function () {
                    this.filterVisibility && (this.filterVisibility.dirty = !0); this.modifyGraphics3DGraphicVisibilities(ca => {
                      const qa = this._updateUserVisibility(ca); ca = k.isSome(this.scaleVisibility) && this.scaleVisibility.updateVisibility(ca); return qa ||
                        ca
                    })
                    }; Ja.hideAllGraphics = function () { this.modifyGraphics3DGraphicVisibilities(ca => ca.setVisibilityFlag(0, !1, 0)) }; Ja.validateRenderer = function (ca) { (ca = O.validateTo3D(ca)) && wa.warn(`Renderer for layer '${this.layer.title ? `${this.layer.title}, ` : ""}, id:${this.layer.id}' is not supported in a SceneView`, ca.message) }; Ja.volatileGraphicsUpdated = function () { var ca; null == (ca = this.labeler) ? void 0 : ca.reset(); this.stageLayer.shaderTransformationChanged(); this.notifyChange("updating") }; Ja._cleanupSymbols = function () {
                      if (!(0 <
                        this.graphicsWaitingForSymbol.size || this.suspendSymbolCleanup)) { var ca = !1; this.symbols.forEach((qa, Da) => { if (!(k.isNone(qa) || 0 < qa.referenced)) { var na = this.graphicsBySymbol.get(Da); na && 0 !== na.size || (this.graphicsBySymbol.delete(Da), this.symbols.delete(Da), k.destroyMaybe(qa), ca = !0) } }); ca && (this.recomputeExtentPadding(), this.notifyChange("averageSymbolComplexity")) }
                    }; Ja.snapshotInternals = function () {
                      return {
                        graphics: [...this.graphics3DGraphics.keys()].sort(), symbols: [...this.symbols.keys()].sort(), graphicsBySymbol: [...this.graphicsBySymbol.keys()].sort().map(ca =>
                          ({ symbolId: ca, graphics: [...this.graphicsBySymbol.get(ca).keys()].sort() })), graphicsWithoutSymbol: [...this.graphicsWithoutSymbol.keys()].sort(), graphicsDrapedUids: [...this.graphicsDrapedUids].sort(), pendingUpdates: this.pendingUpdates
                      }
                    }; w._createClass(Ca, [{
                      key: "spatialIndex", get: function () {
                        if (!this._spatialIndex) { var ca; this._spatialIndex = new W.SpatialIndex2D({ objectIdField: null == (ca = this.owner.layer) ? void 0 : ca.objectIdField, spatialReference: this._spatialReference, hasZ: this.hasZ, hasM: this.hasM }); this._spatialIndex.setup(Array.from(this.graphics3DGraphics.values())) } this._spatialIndex.update();
                        return this._spatialIndex
                      }
                    }, { key: "effectiveUpdatePolicy", get: function () { return k.isSome(this.currentRenderer) && "dictionary" === this.currentRenderer.type ? 0 : k.unwrapOr(this.forcedUpdatePolicy, this.preferredUpdatePolicy) } }, {
                      key: "updating", get: function () {
                        var ca, qa; return !!(0 < this.graphicsWaitingForSymbol.size || this.running || null != (ca = this.elevationAlignment) && ca.updating || k.isSome(this.scaleVisibility) && this.scaleVisibility.updating || null != (qa = this.filterVisibility) && qa.updating || this.rendererChangeAbortController ||
                          this.elevationInfoChangeAbortController || this._updatingPendingLoadedGraphicsChange || this._frameTask.updating)
                      }
                    }, { key: "running", get: function () { var ca; return 0 < this.pendingUpdates.size || !(null == (ca = this._spatialIndex) || !ca.updating) } }, { key: "suspendedOrOutsideOfView", get: function () { var ca; return this.owner.suspended || (null == (ca = this.owner.suspendInfo) ? void 0 : ca.outsideOfView) } }, {
                      key: "updatingRemaining", get: function () {
                        var ca, qa; return this.updating ? this.pendingUpdates.size + .1 * ((null == (ca = this._spatialIndex) ?
                          void 0 : ca.updatingRemaining) || 0) + .1 * ((null == (qa = this.elevationAlignment) ? void 0 : qa.updatingRemaining) || 0) : 0
                      }
                    }, {
                      key: "displayFeatureLimit", get: function () {
                        var ca = this.owner && this.owner.view && this.owner.view.qualitySettings; const qa = ca ? ca.graphics3D.minTotalNumberOfFeatures : 0, Da = ca ? ca.graphics3D.maxTotalNumberOfFeatures : 0; ca = ca ? ca.graphics3D.maxTotalNumberOfPrimitives : 0; const na = this.averageSymbolComplexity; var xa = Math.max(1, k.isSome(na) ? na.primitivesPerFeature : 1), Qa = k.isSome(na) && 0 < na.drawCallsPerFeature ?
                          Da / na.drawCallsPerFeature * .3 : Da; xa = Math.max(qa, Math.min(Da, Math.ceil(ca / xa), Qa)); return (Qa = this._get("displayFeatureLimit")) && Qa.minimumTotalNumberOfFeatures === qa && Qa.maximumTotalNumberOfFeatures === Da && Qa.maximumTotalNumberOfPrimitives === ca && Qa.averageSymbolComplexity === na && Qa.maximumNumberOfFeatures === xa ? Qa : { minimumTotalNumberOfFeatures: qa, maximumTotalNumberOfFeatures: Da, maximumTotalNumberOfPrimitives: ca, averageSymbolComplexity: na, maximumNumberOfFeatures: xa }
                      }
                    }, {
                      key: "averageSymbolComplexity", get: function () {
                        const ca =
                          U.averageSymbolComplexities(this.symbolComplexities), qa = this._get("averageSymbolComplexity"); return 0 === ca.numComplexities || k.isSome(qa) && (ca.estimated && (qa.primitivesPerFeature >= ca.primitivesPerFeature || qa.primitivesPerCoordinate >= ca.primitivesPerCoordinate || qa.drawCallsPerFeature >= ca.drawCallsPerFeature) || qa.primitivesPerFeature === ca.primitivesPerFeature && qa.primitivesPerCoordinate === ca.primitivesPerCoordinate && qa.drawCallsPerFeature === ca.drawCallsPerFeature) ? qa : ca
                      }
                    }, { key: "spatialReference", get: function () { return this._spatialReference } },
                    { key: "usedMemory", get: function () { const ca = k.isSome(this.averageSymbolComplexity) && this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel * this.numberOfGraphics : 0; return this._usedMemory + ca } }, {
                      key: "usedMemoryPerGraphic", get: function () {
                        return this._usedMemory && this.numberOfGraphics ? 30 < Math.abs(this.pendingAdds - this.pendingRemoves) / this.numberOfGraphics ? 0 : this._usedMemory / this.numberOfGraphics : k.isSome(this.averageSymbolComplexity) ? this.averageSymbolComplexity.memory.bytesPerFeature +
                          (this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel : 0) : 0
                      }
                    }, { key: "unprocessedMemoryEstimate", get: function () { return Math.max(0, (this.pendingAdds - this.pendingRemoves) * this.usedMemoryPerGraphic) } }, { key: "symbolComplexities", get: function () { return this.currentRenderer ? this.getSymbolComplexitiesUsedOrRenderer(this.currentRenderer) : this.getSymbolComplexitiesUsed() } }, {
                      key: "graphics3DGraphicsByObjectID", get: function () {
                        const ca = this.owner.layer && this.owner.layer.objectIdField; if (!ca) return null;
                        const qa = new Map; this.graphics3DGraphics.forEach(Da => { if (Da) { var na = this._getGraphicObjectID(Da.graphic, ca); k.isSome(na) && qa.set(na, Da) } }); return qa
                      }
                    }, { key: "labelsEnabled", get: function () { return !(!this.labeler || !this.labeler.layerLabelsEnabled()) } }, {
                      key: "symbolUpdateType", get: function () {
                        if (0 < this.pendingUpdates.size) return "unknown"; let ca = 0, qa = 0; return x.someMap(this.symbols, (Da, na) => {
                          if (k.isSome(Da)) {
                            Da = Da.getFastUpdateStatus(); if (0 < Da.loading) return !0; this.graphicsBySymbol.has(na) && (qa += Da.fast,
                              ca += Da.slow)
                          } return !1
                        }) ? "unknown" : 0 <= qa && 0 === ca ? "fast" : 0 <= ca && 0 === qa ? "slow" : "mixed"
                      }
                    }, { key: "test", get: function () { return { symbols: this.symbols, filterVisibility: this.filterVisibility, numPending: this.pendingUpdates.size, forceUpdatePolicy: ca => { this.forcedUpdatePolicy = ca } } } }, { key: "performanceInfo", get: function () { return { visible: this.graphics3DGraphics.size, missing: this.graphicsWithoutSymbol.size, pending: this.pendingUpdates.size } } }]); return Ca
          }(t); a.Graphics3DCore.tmpVec = F.create(); c.__decorate([C.property({ readOnly: !0 })],
            a.Graphics3DCore.prototype, "computedExtent", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "currentRenderer", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "rendererHasGeometryOperations", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "_frameTask", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "rendererChangeAbortController", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "elevationInfoChangeAbortController", void 0); c.__decorate([C.property()],
              a.Graphics3DCore.prototype, "setupAbortController", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "elevationAlignment", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "scaleVisibility", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "filterVisibility", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "_spatialIndex", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "extentPadding",
                void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "_updatingPendingLoadedGraphicsChange", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "featureStore", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "deconflictor", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "labeler", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "objectStates", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype,
                  "preferredUpdatePolicy", void 0); c.__decorate([C.property()], a.Graphics3DCore.prototype, "forcedUpdatePolicy", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "effectiveUpdatePolicy", null); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype, "elevationFeatureExpressionEnabled", void 0); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype, "owner", void 0); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype, "layer",
                    void 0); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype, "graphicSymbolSupported", void 0); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype, "getRenderingInfoWithoutRenderer", void 0); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "updating", null); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "running", null); c.__decorate([C.property({ readOnly: !0 })], a.Graphics3DCore.prototype, "suspendedOrOutsideOfView", null); c.__decorate([C.property({
                      readOnly: !0,
                      dependsOn: []
                    })], a.Graphics3DCore.prototype, "updatingRemaining", null); c.__decorate([C.property({ readOnly: !0, dependsOn: ["owner.view.qualitySettings.graphics3D.maxTotalNumberOfPrimitives", "owner.view.qualitySettings.graphics3D.maxTotalNumberOfFeatures", "averageSymbolComplexity"] })], a.Graphics3DCore.prototype, "displayFeatureLimit", null); c.__decorate([C.property({ readOnly: !0, dependsOn: [] })], a.Graphics3DCore.prototype, "averageSymbolComplexity", null); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype,
                      "hasZ", void 0); c.__decorate([C.property({ constructOnly: !0 })], a.Graphics3DCore.prototype, "hasM", void 0); a.Graphics3DCore = Na = c.__decorate([H.subclass("esri.views.3d.layers.graphics.Graphics3DCore")], a.Graphics3DCore); let Ia = function () { function sa() { this.renderingInfo = this.add = null; this.state = 0; this.remove = null } sa.prototype.clear = function () { this.renderingInfo = this.add = null; this.state = 0; this.remove = this.abortController = null }; return sa }(); const Ha = F.create(), Oa = F.create(), Ba = new Map; Object.defineProperty(a,
                        "__esModule", { value: !0 })
        })
    }, "esri/renderers/support/rendererConversion": function () {
      define(["exports", "../../core/has", "../../core/Error", "../../core/maybe", "../../symbols/support/symbolConversion"], function (a, w, c, q, u) {
        function y(h) { return q.isNone(h) || "simple" === h.type || "unique-value" === h.type || "class-breaks" === h.type || "dictionary" === h.type } function n(h, b) {
          if (!b) return null; b = Array.isArray(b) ? b : [b]; if (0 < b.length) {
            const d = b.map(t => t.details.symbol.type || t.details.symbol.declaredClass).filter(t => !!t);
            d.sort(); const f = []; d.forEach((t, v) => { 0 !== v && t === d[v - 1] || f.push(t) }); return new c("renderer-conversion-3d:unsupported-symbols", `Renderer contains symbols (${f.join(", ")}) which are not supported in 3D`, { renderer: h, symbolErrors: b })
          } return null
        } function p(h) { const b = h.uniqueValueInfos.map(f => u.to3D(f.symbol).error).filter(f => !!f), d = u.to3D(h.defaultSymbol); d.error && b.unshift(d.error); return n(h, b) } function l(h) {
          const b = h.classBreakInfos.map(f => u.to3D(f.symbol).error).filter(f => !!f), d = u.to3D(h.defaultSymbol);
          d.error && b.unshift(d.error); return n(h, b)
        } a.isSupportedRenderer3D = y; a.validateTo3D = function (h) { if (q.isNone(h)) return null; if (!y(h)) return new c("renderer-conversion-3d:unsupported-renderer", `Unsupported renderer of type '${h.type || h.declaredClass}'`, { renderer: h }); switch (h.type) { case "simple": return n(h, u.to3D(h.symbol).error); case "unique-value": return p(h); case "class-breaks": return l(h) }return null }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/symbols/support/defaults3D": function () {
      define("exports ../../core/has ../../core/maybe ../FillSymbol3DLayer ../LineSymbol3D ../MeshSymbol3D ../PointSymbol3D ../PolygonSymbol3D ../edges/SolidEdges3D ./defaults ./defaultsJSON".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          const d = n.fromSimpleMarkerSymbol(h.defaultPointSymbol2D), f = u.fromSimpleLineSymbol(h.defaultPolylineSymbol2D), t = p.fromSimpleFillSymbol(h.defaultPolygonSymbol2D), v = new y({ symbolLayers: [new q({ material: { color: b.defaultColor }, edges: new l({ size: "1px", color: b.defaultOutlineColor }) })] }); a.getDefaultSymbol3D = function (m) { if (c.isNone(m)) return null; switch (m.type) { case "mesh": return v; case "point": case "multipoint": return d; case "polyline": return f; case "polygon": case "extent": return t }return null };
          Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DFeatureStore": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/projection ../../../../layers/graphics/dehydratedFeatures ../../../../layers/graphics/OptimizedFeature ../../../../layers/graphics/OptimizedGeometry ../../../../layers/graphics/data/optimizedFeatureQueryEngineAdapter".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
        a.Graphics3DFeatureStore = function (g) {
          function x(r) {
            var A = g.call(this, r) || this; A.events = new u; A.hasZ = null; A.hasM = null; A.objectIdField = null; A.spatialReference = null; A.featureAdapter = {
              getAttribute(z, B) { return "graphic" in z ? z.graphic.attributes[B] : m.optimizedFeatureQueryEngineAdapter.getAttribute(z, B) }, getAttributes(z) { return "graphic" in z ? z.graphic.attributes : m.optimizedFeatureQueryEngineAdapter.getAttributes(z) }, getObjectId: z => "graphic" in z ? f.getObjectId(z.graphic,
                A.objectIdField) : m.optimizedFeatureQueryEngineAdapter.getObjectId(z), getGeometry: z => "graphic" in z ? z.getAsOptimizedGeometry(A.hasZ, A.hasM) : m.optimizedFeatureQueryEngineAdapter.getGeometry(z), getCentroid: (z, B) => {
                  if ("graphic" in z) {
                    let C = null; y.isSome(z.centroid) ? C = z.centroid : "point" === z.graphic.geometry.type && d.projectPoint(z.graphic.geometry, e, A.spatialReference) && (C = e); z = Array(2 + (B.hasZ ? 1 : 0) + (B.hasM ? 1 : 0)); y.isNone(C) ? (z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0) : (z[0] = C.x, z[1] = C.y, B.hasZ && (z[2] = C.hasZ ? C.z : 0), B.hasM &&
                      (z[B.hasZ ? 3 : 2] = C.hasM ? C.m : 0)); return new v([], z)
                  } return m.optimizedFeatureQueryEngineAdapter.getCentroid(z, B)
                }, cloneWithGeometry: (z, B) => "graphic" in z ? new t.default(B, A.featureAdapter.getAttributes(z), null, A.featureAdapter.getObjectId(z)) : m.optimizedFeatureQueryEngineAdapter.cloneWithGeometry(z, B)
            }; return A
          } w._inheritsLoose(x, g); var k = x.prototype; k.forEach = function (r) { this.forAllGraphics(A => { r(A) }) }; k.forEachInBounds = function (r, A) { this.getSpatialIndex().forEachInBounds(r, A) }; k.forEachBounds = function (r,
            A, z) { const B = this.getSpatialIndex(); for (const C of r) r = this.featureAdapter.getObjectId(C), y.isSome(B.getBounds(r, z)) && A(z) }; return x
        }(q); c.__decorate([n.property({ constructOnly: !0 })], a.Graphics3DFeatureStore.prototype, "getSpatialIndex", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.Graphics3DFeatureStore.prototype, "forAllGraphics", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.Graphics3DFeatureStore.prototype, "hasZ", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.Graphics3DFeatureStore.prototype,
          "hasM", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.Graphics3DFeatureStore.prototype, "objectIdField", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.Graphics3DFeatureStore.prototype, "spatialReference", void 0); a.Graphics3DFeatureStore = c.__decorate([b.subclass("esri.views.3d.layers.graphics.Graphics3DFeatureStore")], a.Graphics3DFeatureStore); const e = { type: "point", x: 0, y: 0, hasZ: !1, hasM: !1, spatialReference: null }; a.default = a.Graphics3DFeatureStore; Object.defineProperty(a, "__esModule",
            { value: !0 })
        })
    }, "esri/layers/graphics/data/optimizedFeatureQueryEngineAdapter": function () {
      define(["exports", "../centroid", "../OptimizedFeature", "../OptimizedGeometry"], function (a, w, c, q) {
        const u = {
          getObjectId(y) { return y.objectId }, getAttributes(y) { return y.attributes }, getAttribute(y, n) { return y.attributes[n] }, cloneWithGeometry(y, n) { return new c.default(n, y.attributes, null, y.objectId) }, getGeometry(y) { return y.geometry }, getCentroid(y, n) {
          y.centroid || (y.centroid = w.getCentroidOptimizedGeometry(new q, y.geometry,
            n.hasZ, n.hasM)); return y.centroid
          }
        }; a.default = u; a.optimizedFeatureQueryEngineAdapter = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/graphics/centroid": function () {
      define(["exports", "../../core/maybe"], function (a, w) {
        function c(u, y, n, p, l, h, b = 1) {
          h = l ? h ? 4 : 3 : h ? 3 : 2; let d = n, f = n + h, t = 0, v = 0, m = n = 0, e = 0; for (let g = 0, x = p - 1; g < x; g++ , d += h, f += h) {
            p = y[d]; const k = y[d + 1], r = y[d + 2], A = y[f], z = y[f + 1], B = y[f + 2]; let C = p * z - A * k; m += C; t += (p + A) * C; v += (k + z) * C; l && (C = p * B - A * r, n += (r + B) * C, e += C); p < u[0] && (u[0] = p); p > u[1] && (u[1] =
              p); k < u[2] && (u[2] = k); k > u[3] && (u[3] = k); l && (r < u[4] && (u[4] = r), r > u[5] && (u[5] = r))
          } 0 < m * b && (m *= -1); 0 < e * b && (e *= -1); if (!m) return null; u = [t, v, .5 * m]; l && (u[3] = n, u[4] = .5 * e); return u
        } function q(u, y, n, p, l) {
          l = p ? l ? 4 : 3 : l ? 3 : 2; let h = y, b = y + l, d = 0, f = 0, t = 0, v = 0; for (let x = 0, k = n - 1; x < k; x++ , h += l, b += l) {
            var m = u[h]; const r = u[h + 1], A = u[h + 2], z = u[b], B = u[b + 1], C = u[b + 2]; if (p) { { var e = z - m; var g = B - r; const D = C - A; e = Math.sqrt(e * e + g * g + D * D) } } else e = z - m, g = B - r, e = Math.sqrt(e * e + g * g); e && (d += e, p ? (m = [m + .5 * (z - m), r + .5 * (B - r), A + .5 * (C - A)], f += e * m[0], t += e * m[1],
              v += e * m[2]) : (m = [m + .5 * (z - m), r + .5 * (B - r)], f += e * m[0], t += e * m[1]))
          } return 0 < d ? p ? [f / d, t / d, v / d] : [f / d, t / d] : 0 < n ? p ? [u[y], u[y + 1], u[y + 2]] : [u[y], u[y + 1]] : null
        } a.getCentroidOptimizedGeometry = function (u, y, n, p, l) {
          if (w.isNone(y) || !y.lengths.length) return null; const h = "upperLeft" === (null == l ? void 0 : l.originPosition) ? -1 : 1; u.lengths.length && (u.lengths.length = 0); u.coords.length && (u.coords.length = 0); l = u.coords; const b = [], d = n ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY,
          Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY], { lengths: f, coords: t } = y, v = n ? p ? 4 : 3 : p ? 3 : 2; let m = 0; for (var e of f) { const g = c(d, t, m, e, n, p, h); g && b.push(g); m += e * v } b.sort((g, x) => { let k = h * g[2] - h * x[2]; 0 === k && n && (k = g[4] - x[4]); return k }); b.length && (e = 6 * b[0][2], l[0] = b[0][0] / e, l[1] = b[0][1] / e, n && (e = 6 * b[0][4], l[2] = 0 !== e ? b[0][3] / e : 0), l[0] < d[0] || l[0] > d[1] || l[1] < d[2] || l[1] > d[3] || n && (l[2] < d[4] || l[2] > d[5])) && (l.length =
            0); if (!l.length) if (y = y.lengths[0] ? q(t, 0, f[0], n, p) : null) l[0] = y[0], l[1] = y[1], n && 2 < y.length && (l[2] = y[2]); else return null; return u
        }; a.lineCentroid = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DSymbolCreationContext": function () {
      define(["exports"], function (a) {
      a.Graphics3DSymbolCreationContext = function (w) {
      this.schedule = w; this.featureExpressionInfoContext = this.localOriginFactory = this.layerView = this.layer = this.overlaySR = this.renderCoordsHelper = this.clippingExtent =
        this.stage = this.renderer = this.elevationProvider = this.streamDataRequester = this.sharedResources = null; this.screenSizePerspectiveEnabled = !0; this.isAsync = this.physicalBasedRenderingEnabled = this.slicePlaneEnabled = !1
      }; a.Graphics3DSymbolLayerCreationContext = function () { }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DSymbolFactory": function () {
      define(["exports", "./Graphics3DPointSymbol", "./Graphics3DSymbol"], function (a, w, c) {
      a.make = function (q, u, y) {
        let n; switch (q.type) {
          case "point-3d": n =
            w; break; default: n = c
        }return new n(q, u, y)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DPointSymbol": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/asyncUtils ../../../../core/maybe ../../../../core/promiseUtils ./Graphics3DCalloutSymbolLayerFactory ./Graphics3DSymbol".split(" "), function (a, w, c, q, u, y) {
        return function (n) {
          function p(h, b, d) {
            h = n.call(this, h, b, d) || this; h.calloutSymbolLayer = null; h.symbol.hasVisibleCallout() &&
              (h.calloutSymbolLayer = u.make(h.symbol, b)); return h
          } a._inheritsLoose(p, n); var l = p.prototype; l.doLoad = function () { var h = a._asyncToGenerator(function* (b) { const d = this.calloutSymbolLayer ? w.result(this.calloutSymbolLayer.load()) : null; try { yield n.prototype.doLoad.call(this, b), q.throwIfAborted(b) } catch (t) { var f; null == (f = this.calloutSymbolLayer) ? void 0 : f.abortLoad(); throw t; } d && (yield d) }); return function (b) { return h.apply(this, arguments) } }(); l.destroy = function () {
            n.prototype.destroy.call(this); this.calloutSymbolLayer =
              c.destroyMaybe(this.calloutSymbolLayer)
          }; l.createGraphics3DGraphic = function (h, b) { b = n.prototype.createGraphics3DGraphic.call(this, h, b); this.calloutSymbolLayer && (h = this.createCalloutGraphic(h)) && b.addAuxiliaryGraphic(h); return b }; l.globalPropertyChanged = function (h, b) { return n.prototype.globalPropertyChanged.call(this, h, b) ? this.calloutSymbolLayer ? this.calloutSymbolLayer.globalPropertyChanged(h, b, d => this._getCalloutGraphicLayer(d)) : !0 : !1 }; l.updateGeometry = function (h, b) {
            const d = n.prototype.updateGeometry.call(this,
              h, b); return d && this.calloutSymbolLayer && (h = this._getCalloutGraphicLayer(h)) ? this.calloutSymbolLayer.updateGeometry(h, b) : d
          }; l.createCalloutGraphic = function (h) { const b = h.renderingInfo; h.renderingInfo = { renderer: b.renderer, symbol: b.symbol, translation: [0, 0, 0], centerOffset: [0, 0, 0, 0], screenOffset: [0, 0], centerOffsetUnits: "world", elevationOffset: 0, materialCollection: null }; return this.calloutSymbolLayer.createGraphics3DGraphic(h) }; l._getCalloutGraphicLayer = function (h) {
            for (const b of h._auxiliaryGraphics) if (b.graphics3DSymbolLayer ===
              this.calloutSymbolLayer) return b
          }; return p
        }(y)
      })
    }, "esri/views/3d/layers/graphics/GraphicStateTracking": function () {
      define(["exports", "../../../../core/arrayUtils", "../../../../core/maybe", "../../../../layers/graphics/dehydratedFeatures"], function (a, w, c, q) {
        let u = function () {
          function y(p) {
          this.graphicsCore = p; this.idToState = new Map; this.states = new Set; const l = p.owner.layer && p.owner.layer.objectIdField; l ? (this.getGraphicId = h => q.getObjectId(h, l), this.getGraphics3DGraphicById = h => this.graphicsCore.getGraphics3DGraphicByObjectId(h)) :
            (this.getGraphicId = h => h.uid, this.getGraphics3DGraphicById = h => this.graphicsCore.getGraphics3DGraphicById(h))
          } var n = y.prototype; n.destroy = function () { this.idToState.clear(); this.states.forEach((p, l) => this.remove(l)) }; n.add = function (p) {
            const l = { remove: () => this.remove(p) }; if (this.states.has(p)) return l; const h = this.getGraphicId(p.graphic), b = this.getGraphics3DGraphicById(h); this.states.has(p) || this.states.add(p); this.ensureStateList(h).push(p); p.displaying = c.isSome(b) ? b.isVisible() : !1; p.isDraped = c.isSome(b) ?
              b.isDraped : !1; p.tracking = !0; c.isSome(b) && p.emit("changed", {}); return l
          }; n.remove = function (p) { if (this.states.has(p)) { if (this.idToState.size) { const l = this.getGraphicId(p.graphic), h = this.idToState.get(l); h && (w.remove(h, p), 0 === h.length && this.idToState.delete(l)) } this.states.delete(p); p.tracking = !1; p.displaying = !1 } }; n.addGraphic = function (p) { this.forEachState(p, l => { l.displaying = p.isVisible(); l.isDraped = p.isDraped; l.emit("changed", {}) }) }; n.removeGraphic = function (p) {
            this.forEachState(p, l => {
            l.displaying = !1;
              l.isDraped = !1
            })
          }; n.updateGraphicGeometry = function (p) { this.forEachState(p, l => { l.emit("changed", {}) }) }; n.updateGraphicVisibility = function (p) { this.forEachState(p, l => { l.displaying = p.isVisible() }) }; n.allGraphicsDeleted = function () { this.states.forEach(p => { p.displaying = !1 }) }; n.ensureStateList = function (p) { var l = this.idToState.get(p); if (l) return l; l = []; this.idToState.set(p, l); return l }; n.forEachState = function (p, l) {
          0 !== this.states.size && 0 !== this.idToState.size && (p = this.getGraphicId(p.graphic), p = this.idToState.get(p),
            null != p && p.forEach(l))
          }; return y
        }(); a.GraphicStateTracking = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/SpatialIndex2D": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/has ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../core/libs/rbush/PooledRBush ../../../../geometry/support/aaBoundingBox ../../../../layers/graphics/dehydratedFeatures".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
        a.SpatialIndex2D = function (t) {
          function v(e) { e = t.call(this, e) || this; e._index = new h.PooledRBush(9, u("esri-csp-restrictions") ? g => ({ minX: g.extent[0], minY: g.extent[1], maxX: g.extent[2], maxY: g.extent[3] }) : [".extent[0]", ".extent[1]", ".extent[2]", ".extent[3]"]); e._missing = new Set; e._boundsByFeature = new Map; e.spatialReference = null; e.hasZ = null; e.hasM = null; e.objectIdField = null; e.updating = !1; return e } w._inheritsLoose(v, t); var m = v.prototype; m.setup = function (e) { this._addMany(e) };
          m.destroy = function () { this._missing.clear(); this._index.destroy(); this._index = null; this._boundsByFeature.clear(); this._boundsByFeature = null }; m.update = function () { 0 < this._missing.size && (this._addMany(Array.from(this._missing.values())), this.updating = !1, this._missing.clear()) }; m.queryGraphicUIDsInExtent = function (e, g, x) { g.equals(this.spatialReference) && (f.minX = e[0], f.minY = e[1], f.maxX = e[2], f.maxY = e[3], this.update(), this._index.search(f, k => x(k.graphic.uid))) }; m.add = function (e) {
            this._missing.add(e); this.updating =
              !0
          }; m.remove = function (e) { this._missing.delete(e) ? this.updating = 0 < this._missing.size : (this._index.remove(e), e = d.getObjectId(e.graphic, this._get("objectIdField")), null != e && this._boundsByFeature.delete(e)) }; m._addMany = function (e) { if (0 !== e.length) { var g = this._get("objectIdField"); for (const x of e) { x.computeExtent(this.spatialReference); const k = d.getObjectId(x.graphic, g); null != k && this._boundsByFeature.set(k, x.extent) } this._index.load(e) } }; m.clear = function () {
            this._index.clear(); this._missing.clear(); this._boundsByFeature.clear();
            this.updating = !1
          }; m.forEachInBounds = function (e, g) { f.minX = e[0]; f.minY = e[1]; f.maxX = e[2]; f.maxY = e[3]; this.update(); this._index.search(f, x => { g(x) }) }; m.getBounds = function (e, g) { this.update(); return (e = this._boundsByFeature.get(e)) ? b.fromRect(g, e) : null }; w._createClass(v, [{ key: "updatingRemaining", get: function () { return this._missing.size } }]); return v
        }(q); c.__decorate([y.property({ constructOnly: !0 })], a.SpatialIndex2D.prototype, "spatialReference", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.SpatialIndex2D.prototype,
          "hasZ", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.SpatialIndex2D.prototype, "hasM", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.SpatialIndex2D.prototype, "objectIdField", void 0); c.__decorate([y.property()], a.SpatialIndex2D.prototype, "updating", void 0); c.__decorate([y.property({ readOnly: !0 })], a.SpatialIndex2D.prototype, "updatingRemaining", null); a.SpatialIndex2D = c.__decorate([l.subclass("esri.views.3d.layers.graphics.SpatialIndex2D")], a.SpatialIndex2D); const f = {
            minX: 0, minY: 0, maxX: 0,
            maxY: 0
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/libs/rbush/PooledRBush": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../arrayUtils ../../maybe ../../PooledArray ../../../chunks/quickselect".split(" "), function (a, w, c, q, u, y) {
        function n(C, D) { p(C, 0, C.children.length, D, C) } function p(C, D, E, H, J) { J || (J = new z([])); J.minX = Infinity; J.minY = Infinity; J.maxX = -Infinity; J.maxY = -Infinity; for (let M = D, F; M < E; M++)F = C.children[M], l(J, C.leaf ? H(F) : F); return J } function l(C,
          D) { C.minX = Math.min(C.minX, D.minX); C.minY = Math.min(C.minY, D.minY); C.maxX = Math.max(C.maxX, D.maxX); C.maxY = Math.max(C.maxY, D.maxY) } function h(C, D) { return C.minX - D.minX } function b(C, D) { return C.minY - D.minY } function d(C) { return (C.maxX - C.minX) * (C.maxY - C.minY) } function f(C) { return C.maxX - C.minX + (C.maxY - C.minY) } function t(C, D) { return C.minX <= D.minX && C.minY <= D.minY && D.maxX <= C.maxX && D.maxY <= C.maxY } function v(C, D) { return D.minX <= C.maxX && D.minY <= C.maxY && D.maxX >= C.minX && D.maxY >= C.minY } function m(C, D, E, H, J) {
            for (D =
              [D, E]; D.length;) { E = q.assumeNonNull(D.pop()); const M = q.assumeNonNull(D.pop()); if (E - M <= H) continue; const F = M + Math.ceil((E - M) / H / 2) * H; y.quickselect(C, F, M, E, J); D.push(M, F, F, E) }
          } let e = function () {
            function C(E = 9, H) { this.compareMinX = h; this.compareMinY = b; this.toBBox = function (J) { return J }; this._maxEntries = Math.max(4, E || 9); this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)); H && ("function" === typeof H ? this.toBBox = H : this._initFormat(H)); this.clear() } var D = C.prototype; D.destroy = function () {
              this.clear(); g.prune();
              x.prune(); k.prune(); r.prune()
            }; D.all = function (E) { this._all(this.data, E) }; D.search = function (E, H) { let J = this.data; const M = this.toBBox; if (v(E, J)) for (g.clear(); J;) { for (let F = 0, K = J.children.length; F < K; F++) { const P = J.children[F], L = J.leaf ? M(P) : P; v(E, L) && (J.leaf ? H(P) : t(E, L) ? this._all(P, H) : g.push(P)) } J = g.pop() } }; D.collides = function (E) {
              let H = this.data; const J = this.toBBox; if (!v(E, H)) return !1; for (g.clear(); H;) {
                for (let M = 0, F = H.children.length; M < F; M++) {
                  const K = H.children[M], P = H.leaf ? J(K) : K; if (v(E, P)) {
                    if (H.leaf ||
                      t(E, P)) return !0; g.push(K)
                  }
                } H = g.pop()
              } return !1
            }; D.load = function (E) { if (!E.length) return this; if (E.length < this._minEntries) { for (let H = 0, J = E.length; H < J; H++)this.insert(E[H]); return this } E = this._build(E.slice(0, E.length), 0, E.length - 1, 0); if (this.data.children.length) if (this.data.height === E.height) this._splitRoot(this.data, E); else { if (this.data.height < E.height) { const H = this.data; this.data = E; E = H } this._insert(E, this.data.height - E.height - 1, !0) } else this.data = E; return this }; D.insert = function (E) {
              E && this._insert(E,
                this.data.height - 1); return this
            }; D.clear = function () { this.data = new z([]); return this }; D.remove = function (E) {
              if (!E) return this; let H = this.data, J = null, M = 0, F = !1, K; const P = this.toBBox(E); k.clear(); for (r.clear(); H || 0 < k.length;) {
                if (!H) { var L; H = q.assumeNonNull(k.pop()); J = k.data[k.length - 1]; M = null != (L = r.pop()) ? L : 0; F = !0 } if (H.leaf && (K = c.indexOf(H.children, E, H.children.length, H.indexHint), -1 !== K)) { H.children.splice(K, 1); k.push(H); this._condense(k); break } F || H.leaf || !t(H, P) ? J ? (M++ , H = J.children[M], F = !1) : H = null : (k.push(H),
                  r.push(M), M = 0, J = H, H = H.children[0])
              } return this
            }; D.toJSON = function () { return this.data }; D.fromJSON = function (E) { this.data = E; return this }; D._all = function (E, H) { for (x.clear(); E;) { var J; if (!0 === E.leaf) for (const M of E.children) H(M); else x.pushArray(E.children); E = null != (J = x.pop()) ? J : null } }; D._build = function (E, H, J, M) {
              var F = J - H + 1, K = this._maxEntries; if (F <= K) return E = new z(E.slice(H, J + 1)), n(E, this.toBBox), E; M || (M = Math.ceil(Math.log(F) / Math.log(K)), K = Math.ceil(F / K ** (M - 1))); const P = new B([]); P.height = M; F = Math.ceil(F /
                K); K = F * Math.ceil(Math.sqrt(K)); for (m(E, H, J, K, this.compareMinX); H <= J; H += K) { const L = Math.min(H + K - 1, J); m(E, H, L, F, this.compareMinY); for (let N = H; N <= L; N += F)P.children.push(this._build(E, N, Math.min(N + F - 1, L), M - 1)) } n(P, this.toBBox); return P
            }; D._chooseSubtree = function (E, H, J, M) {
              for (; ;) {
                M.push(H); if (!0 === H.leaf || M.length - 1 === J) break; let F = Infinity, K = Infinity, P = void 0; for (let L = 0, N = H.children.length; L < N; L++) {
                  const G = H.children[L], I = d(G), O = (Math.max(G.maxX, E.maxX) - Math.min(G.minX, E.minX)) * (Math.max(G.maxY, E.maxY) -
                    Math.min(G.minY, E.minY)) - I; O < K ? (K = O, F = I < F ? I : F, P = G) : O === K && I < F && (F = I, P = G)
                } H = P || H.children[0]
              } return H
            }; D._insert = function (E, H, J) { var M = this.toBBox; J = J ? E : M(E); k.clear(); M = this._chooseSubtree(J, this.data, H, k); M.children.push(E); for (l(M, J); 0 <= H;)if (k.data[H].children.length > this._maxEntries) this._split(k, H), H--; else break; this._adjustParentBBoxes(J, k, H) }; D._split = function (E, H) {
              const J = E.data[H]; var M = J.children.length; const F = this._minEntries; this._chooseSplitAxis(J, F, M); (M = this._chooseSplitIndex(J, F,
                M)) ? (M = J.children.splice(M, J.children.length - M), M = J.leaf ? new z(M) : new B(M), M.height = J.height, n(J, this.toBBox), n(M, this.toBBox), H ? E.data[H - 1].children.push(M) : this._splitRoot(J, M)) : console.log("  Error: assertion failed at PooledRBush._split: no valid split index")
            }; D._splitRoot = function (E, H) { this.data = new B([E, H]); this.data.height = E.height + 1; n(this.data, this.toBBox) }; D._chooseSplitIndex = function (E, H, J) {
              let M, F, K = void 0; M = F = Infinity; for (let L = H; L <= J - H; L++) {
                var P = p(E, 0, L, this.toBBox); const N = p(E, L,
                  J, this.toBBox), G = Math.max(0, Math.min(P.maxX, N.maxX) - Math.max(P.minX, N.minX)) * Math.max(0, Math.min(P.maxY, N.maxY) - Math.max(P.minY, N.minY)); P = d(P) + d(N); G < M ? (M = G, K = L, F = P < F ? P : F) : G === M && P < F && (F = P, K = L)
              } return K
            }; D._chooseSplitAxis = function (E, H, J) { const M = E.leaf ? this.compareMinX : h, F = E.leaf ? this.compareMinY : b, K = this._allDistMargin(E, H, J, M); H = this._allDistMargin(E, H, J, F); K < H && E.children.sort(M) }; D._allDistMargin = function (E, H, J, M) {
              E.children.sort(M); M = this.toBBox; var F = p(E, 0, H, M); const K = p(E, J - H, J, M); let P =
                f(F) + f(K); for (let L = H; L < J - H; L++) { const N = E.children[L]; l(F, E.leaf ? M(N) : N); P += f(F) } for (J = J - H - 1; J >= H; J--)F = E.children[J], l(K, E.leaf ? M(F) : F), P += f(K); return P
            }; D._adjustParentBBoxes = function (E, H, J) { for (; 0 <= J; J--)l(H.data[J], E) }; D._condense = function (E) { for (let H = E.length - 1; 0 <= H; H--) { const J = E.data[H]; if (0 === J.children.length) if (0 < H) { const M = E.data[H - 1], F = M.children; F.splice(c.indexOf(F, J, F.length, M.indexHint), 1) } else this.clear(); else n(J, this.toBBox) } }; D._initFormat = function (E) {
              const H = ["return a", " - b",
                ";"]; this.compareMinX = new Function("a", "b", H.join(E[0])); this.compareMinY = new Function("a", "b", H.join(E[1])); this.toBBox = new Function("a", "return {minX: a" + E[0] + ", minY: a" + E[1] + ", maxX: a" + E[2] + ", maxY: a" + E[3] + "};")
            }; return C
          }(); const g = new u, x = new u, k = new u, r = new u({ deallocator: void 0 }); u = function () { this.minY = this.minX = Infinity; this.maxY = this.maxX = -Infinity }; let A = function (C) {
            function D() { var E = C.apply(this, arguments) || this; E.height = 1; E.indexHint = new c.PositionHint; return E } w._inheritsLoose(D,
              C); return D
          }(u), z = function (C) { function D(E) { var H = C.call(this) || this; H.children = E; H.leaf = !0; return H } w._inheritsLoose(D, C); return D }(A), B = function (C) { function D(E) { var H = C.call(this) || this; H.children = E; H.leaf = !1; return H } w._inheritsLoose(D, C); return D }(A); a.BBox = u; a.PooledRBush = e; a.default = e; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/chunks/quickselect": function () {
      define(["exports"], function (a) {
        var w = { exports: {} }; (function (c) {
          (function (q) { q = q(); void 0 !== q && (c.exports = q) })(function () {
            function q(n,
              p, l, h, b) { for (; h > l;) { if (600 < h - l) { var d = h - l + 1, f = p - l + 1, t = Math.log(d), v = .5 * Math.exp(2 * t / 3); t = .5 * Math.sqrt(t * v * (d - v) / d) * (0 > f - d / 2 ? -1 : 1); q(n, p, Math.max(l, Math.floor(p - f * v / d + t)), Math.min(h, Math.floor(p + (d - f) * v / d + t)), b) } d = n[p]; f = l; v = h; u(n, l, p); for (0 < b(n[h], d) && u(n, l, h); f < v;) { u(n, f, v); f++; for (v--; 0 > b(n[f], d);)f++; for (; 0 < b(n[v], d);)v-- } 0 === b(n[l], d) ? u(n, l, v) : (v++ , u(n, v, h)); v <= p && (l = v + 1); p <= v && (h = v - 1) } } function u(n, p, l) { var h = n[p]; n[p] = n[l]; n[l] = h } function y(n, p) { return n < p ? -1 : n > p ? 1 : 0 } return function (n, p, l, h,
                b) { q(n, p, l || 0, h || n.length - 1, b || y) }
          })
        })(w); a.quickselect = w.exports
      })
    }, "esri/views/3d/layers/support/StageLayerElevationProvider": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/Handles ../../../../core/Logger ../../../../core/maybe ../../../../core/unitUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ../../../../symbols/support/unitConversionUtils ../../webgl-engine/lib/Intersector".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k) {
          const r = n.getLogger("esri.views.3d.layers.support.StageLayerElevationProvider"); a.StageLayerElevationProvider = function (H) {
            function J(F) { F = H.call(this, F) || this; F.elevationOffset = 0; F._layerHandes = new y; return F } w._inheritsLoose(J, H); var M = J.prototype; M.initialize = function () {
            this.renderCoordsHelper = this.view.renderCoordsHelper; this.intersectLayers = [this.stageLayer]; this.intersector = k.newIntersector(this.view.state.viewingMode); this.intersector.options.store =
              0; var F = this.computeLayerExtent(this.stageLayer); this.zmin = F[2]; this.zmax = F[5]; F = this.stageLayer.events; this._layerHandes.add([F.on("layerObjectAdded", K => this.objectChanged(K.object)), F.on("layerObjectRemoved", K => this.objectChanged(K.object)), F.on("objectGeometryAdded", K => this.objectChanged(K.object)), F.on("objectGeometryRemoved", K => this.objectChanged(K.object)), F.on("vertexAttrsUpdated", K => this.objectChanged(K.object)), F.on("objectTransformation", K => this.objectChanged(K))])
            }; M.dispose = function () { this._layerHandes.destroy() };
            M.elevationInfoChanged = function () { const F = null != this.layer ? this.layer.elevationInfo : null; if (null != F && "on-the-ground" !== F.mode) { const K = l.getMetersPerVerticalUnitForSR(this.layer.spatialReference), P = x.getMetersPerUnit(F.unit); this.elevationOffset = p.unwrapOr(F.offset, 0) * P / K } else this.elevationOffset = 0 }; M.getElevation = function (F, K, P, L) {
            C[0] = F; C[1] = K; C[2] = P; if (!this.renderCoordsHelper.toRenderCoords(C, L, C)) return r.error("could not project point for elevation alignment"), null; F = this.elevationOffset; K =
              this.zmin + F; this.renderCoordsHelper.setAltitude(D, this.zmax + F, C); this.renderCoordsHelper.setAltitude(E, K, C); this.intersector.reset(D, E, null); this.intersector.intersect(this.intersectLayers, null, 1, null, N => N.metadata && N.metadata.isElevationSource); return this.intersector.results.min.getIntersectionPoint(C) ? this.renderCoordsHelper.getAltitude(C) : null
            }; M.objectChanged = function (F) {
              var K; if (null != (K = F.metadata) && K.isElevationSource && this.spatialReference) {
                e.empty(A); F.metadata.lastValidElevationBB.isEmpty() ||
                  this.expandExtent(F.metadata.lastValidElevationBB.min, F.metadata.lastValidElevationBB.max, A); K = F.boundingVolumeWorldSpace.min; var P = F.boundingVolumeWorldSpace.max; this.expandExtent(K, P, A); e.toRect(A, z); this.zmin = Math.min(this.zmin, A[2]); this.zmax = Math.max(this.zmax, A[5]); B.extent = z; B.spatialReference = this.spatialReference; this.emit("elevation-change", B); v.copy(F.metadata.lastValidElevationBB.min, K); v.copy(F.metadata.lastValidElevationBB.max, P)
              }
            }; M.computeLayerExtent = function (F) {
              e.empty(A); F.objects.forAll(K =>
                this.expandExtent(K.boundingVolumeWorldSpace.min, K.boundingVolumeWorldSpace.max, A)); return A
            }; M.expandExtent = function (F, K, P) { for (let L = 0; 8 > L; ++L)C[0] = L & 1 ? F[0] : K[0], C[1] = L & 2 ? F[1] : K[1], C[2] = L & 4 ? F[2] : K[2], this.renderCoordsHelper.fromRenderCoords(C, C, this.spatialReference), e.expandWithVec3(P, C); return P }; return J
          }(u.EventedMixin(q)); c.__decorate([h.property({ constructOnly: !0 })], a.StageLayerElevationProvider.prototype, "layer", void 0); c.__decorate([h.property({ constructOnly: !0 })], a.StageLayerElevationProvider.prototype,
            "stageLayer", void 0); c.__decorate([h.property({ constructOnly: !0 })], a.StageLayerElevationProvider.prototype, "view", void 0); c.__decorate([h.property({ readOnly: !0, aliasOf: "view.spatialReference" })], a.StageLayerElevationProvider.prototype, "spatialReference", void 0); a.StageLayerElevationProvider = c.__decorate([t.subclass("esri.views.3d.layers.support.StageLayerElevationProvider")], a.StageLayerElevationProvider); const A = e.empty(), z = g.empty(), B = { spatialReference: null, extent: z, context: "scene" }, C = m.create(),
              D = m.create(), E = m.create(); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DElevationAlignment": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/Handles ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ./ExtentSet ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          c = function (t) {
            function v() { var e = t.apply(this, arguments) || this; e.dirtyExtents = new d.ExtentSet; e.globalDirty = !1; e.averageExtentUpdateSize = 0; e.dirtyGraphicsSet = new Set; e.handles = new u; e.updateElevation = !1; e.layerView = null; e.graphicsCore = null; e.events = new q; return e } a._inheritsLoose(v, t); var m = v.prototype; m.setup = function (e, g, x, k) {
            this.layerView = e; this.queryGraphicUIDsInExtent = g; this.graphicsCore = x; this.elevationProvider = k; e = this.layerView.view.resourceController.scheduler;
              this.handles.add([k.on("elevation-change", r => this._elevationChanged(r)), this.layerView.watch("suspended", () => this.suspendedChange()), e.registerTask(f.TaskPriority.ELEVATION_ALIGNMENT, this)])
            }; m.destroy = function () { this.dirtyGraphicsSet.clear(); this.handles.destroy(); this.queryGraphicUIDsInExtent = this.graphicsCore = this.layerView = this.handles = null }; m.clear = function () { this.dirtyGraphicsSet.clear(); this.notifyChange("updating") }; m.suspendedChange = function () {
            !0 === this.layerView.suspended ? this.updateElevation =
              !1 : !1 === this.layerView.suspended && this.updateElevation && (this.globalDirty = !0, this.notifyChange("updating"))
            }; m.elevationInfoChange = function () { this.globalDirty = !0; this.notifyChange("updating") }; m.runTask = function (e) { this.globalDirty && (this.markAllGraphicsElevationDirty(), this.globalDirty = !1, e.madeProgress()); for (e.run(() => this.dirtyExtents.merge(e)); this.running && !e.done;)this._updateDirtyGraphics(e), this._updateDirtyExtents(e); this.layerView.view.deconflictor.setDirty(); this.notifyChange("updating") };
            m._updateDirtyGraphics = function (e) { const g = this.layerView.view.renderCoordsHelper, x = 0 === this.graphicsCore.effectiveUpdatePolicy; for (const k of this.dirtyGraphicsSet.keys()) { const r = this.graphicsCore.getGraphics3DGraphicById(k); this.dirtyGraphicsSet.delete(k); y.isSome(r) && (r.alignWithElevation(this.elevationProvider, g, x), e.madeProgress()); if (e.done) break } }; m._updateDirtyExtents = function (e) {
              for (; !this.dirtyExtents.empty && !e.done;) {
                const g = this.dirtyExtents.pop(), x = this.elevationProvider.spatialReference;
                this.events.emit("invalidate-elevation", { extent: g, spatialReference: x }); const k = this.dirtyGraphicsSet.size; this.queryGraphicUIDsInExtent(g, x, r => { const A = this.graphicsCore.getGraphics3DGraphicById(r); y.isSome(A) && A.needsElevationUpdates() && this.dirtyGraphicsSet.add(r) }); this.averageExtentUpdateSize = .1 * (this.dirtyGraphicsSet.size - k) + .9 * this.averageExtentUpdateSize; e.madeProgress()
              }
            }; m.markAllGraphicsElevationDirty = function () {
              this.dirtyExtents.clear(); this.dirtyGraphicsSet.clear(); this.graphicsCore.graphics3DGraphics.forEach((e,
                g) => this.dirtyGraphicsSet.add(g))
            }; m._elevationChanged = function (e) {
              if ("scene" !== e.context || this.graphicsCore.layer.elevationInfo && "relative-to-scene" === this.graphicsCore.layer.elevationInfo.mode) {
                var { extent: g, spatialReference: x } = e; this.layerView.suspended ? (this.updateElevation || (e = this.graphicsCore.computedExtent) && g[2] > e.xmin && g[0] < e.xmax && g[3] > e.ymin && g[1] < e.ymax && (this.updateElevation = !0), this.events.emit("invalidate-elevation", { extent: g, spatialReference: x })) : (-Infinity === g[0] ? this.globalDirty =
                  !0 : this.dirtyExtents.add(g), this.notifyChange("updating"))
              }
            }; a._createClass(v, [{ key: "updating", get: function () { return this.running } }, { key: "running", get: function () { return 0 < this.dirtyGraphicsSet.size || this.dirtyExtents && !this.dirtyExtents.empty || this.globalDirty } }, { key: "updatingRemaining", get: function () { return this.dirtyGraphicsSet.size + this.dirtyExtents.size * this.averageExtentUpdateSize } }]); return v
          }(c); w.__decorate([n.property({ readOnly: !0 })], c.prototype, "updating", null); w.__decorate([n.property({ readOnly: !0 })],
            c.prototype, "updatingRemaining", null); return c = w.__decorate([b.subclass("esri.views.3d.layers.graphics.Graphics3DElevationAlignment")], c)
        })
    }, "esri/views/3d/layers/graphics/ExtentSet": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/PooledArray", "../../../../geometry/support/aaBoundingRect", "../../../support/Scheduler"], function (a, w, c, q, u) {
        let y = function () {
          function n() {
          this._extents = new c({ allocator: l => l || q.create() }); this._tmpExtent = q.create(); this._dirty =
            !1
          } var p = n.prototype; p.clear = function () { this._extents.clear() }; p.add = function (l) { this.contains(l) || (this.removeContained(l), q.copy(this._extents.pushNew(), l), this._dirty = !0) }; p.pop = function () { this._dirty && this.mergeTight(); return this._extents.pop() }; p.merge = function (l) { this.mergeTight(l); return l.hasProgressed }; p.mergeTight = function (l = u.noBudget) {
            const h = this._extents, b = new Set; let d = 0; for (; d !== h.length;) {
              h.sort((f, t) => f[0] - t[0]); d = h.length; b.clear(); for (let f = 0; f < h.length; ++f) {
                if (l.done) return;
                const t = h.getItemAt(f); for (let v = f + 1; v < h.length; ++v) { const m = h.getItemAt(v); if (m[0] >= t[2]) break; b.add(m) } b.forEach(v => { if (t !== v) if (v[2] <= t[0]) b.delete(v); else { var m = q.area(t), e = q.area(v), g = this._tmpExtent; q.expand(t, v, g); m += e; .05 > (q.area(g) - m) / m && (q.copy(t, g), b.delete(v), h.remove(v), l.madeProgress()) } }); b.add(t)
              }
            } this._dirty = !1
          }; p.contains = function (l) { return this._extents.some(h => q.contains(h, l)) }; p.removeContained = function (l) { this._extents.filterInPlace(h => !q.contains(l, h)) }; w._createClass(n, [{
            key: "empty",
            get: function () { return 0 === this._extents.length }
          }, { key: "size", get: function () { return this._extents.length } }, { key: "test", get: function () { const l = this; return { containsPoint: h => l._extents.some(b => q.containsPoint(b, h)) } } }]); return n
        }(); a.ExtentSet = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DFilterVisibility": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../layers/support/FeatureFilter ./QueryEngine ../../../support/floorFilterUtils ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g) {
          const x = y.getLogger("esri.views.3d.layers.graphics.Graphics3DFilterVisibility"); a.Graphics3DFilterVisibility = function (k) {
            function r(...z) { z = k.call(this, ...z) || this; z._dirty = !1; z._querying = !1; z._handles = new u; return z } w._inheritsLoose(r, k); var A = r.prototype; A.setup = function (z, B) {
            this._layerView = z; this._core = B; this._objectIdField = z.layer.objectIdField; this._queryEngine = new m.default({ layerView: this._layerView, priority: g.TaskPriority.FILTER_VISIBILITY });
              this._handles.add(this._layerView.view.resourceController.scheduler.registerTask(g.TaskPriority.FILTER_VISIBILITY, this)); this._handles.add(l.on(B.owner, "loadedGraphics", "after-changes", C => this._graphicsChanged(C), () => this.dirty = !0)); this.filterChanged()
            }; A.destroy = function () { this._handles.destroy(); this._handles = null; this.clear(); this._core = this._layerView = null }; A.clear = function () {
              this._queryEngine.clear() && (this._core.modifyGraphics3DGraphicVisibilities(z => z.clearVisibilityFlag(2)), this._queryResult =
                null, this._querying = !1); this.dirty = !1
            }; A._graphicsChanged = function (z) { this._queryEngine && 0 === (z.type & 1) || (this.dirty = !0) }; A.updateVisibility = function (z) { this.active && (z.hasVisibilityFlag(2, 0) || z.setVisibilityFlag(2, !1, 0), this.dirty = !0) }; A.filterChanged = function () { const z = this.recomputeFilter(); z !== this._filter && (this._filter = z, this.dirty = !0) }; A.recomputeFilter = function () {
              var z = "filter" in this._layerView ? this._layerView.filter : null; const B = "timeExtent" in this._layerView ? this._layerView.timeExtent :
                null, C = e.getFloorFilterClause(this._layerView); if (n.isNone(B) && n.isNone(C)) return z; z = n.isSome(z) ? z.clone() : new v; n.isSome(B) && (z.timeExtent = n.isSome(z.timeExtent) ? z.timeExtent.intersection(B) : B); n.isSome(C) && (z.where = null == z.where || "" === z.where ? C : `(${z.where}) AND (${C})`); return z
            }; A.runTask = function (z) {
              if (this.active) {
              !this._dirty || this._querying || z.done || (this._querying = !0, this.dirty = !1, this._queryEngine.executeQueryForIdSet(this._filter).then(C => { this._queryResult = C; this._querying = !1 }).catch(C => { if (!p.isAbortError(C)) { x.warn("FeatureFilter query failed: " + C, { error: C }); const D = new Set; this._core.graphics3DGraphics.forEach(E => D.add(this._getFeatureId(E.graphic))); this._queryResult = D; this._querying = !1 } }), z.madeProgress()); var B = this._queryResult; n.isSome(B) && !z.done && (this._core.modifyGraphics3DGraphicVisibilities(C => { if (z.done) return !1; const D = B.has(this._getFeatureId(C.graphic)); return C.setVisibilityFlag(2, D, 0) ? (z.madeProgress(), !0) : !1 }), z.done || (this._queryResult = null))
              } else this.clear()
            };
            A._getFeatureId = function (z) { return null == z.objectId ? z.attributes[this._objectIdField] : z.objectId }; w._createClass(r, [{ key: "updating", get: function () { return this._dirty || this._querying || n.isSome(this._queryResult) } }, { key: "active", get: function () { return this._filter && 0 < this._core.graphics3DGraphics.size } }, { key: "running", get: function () { return this._dirty && !this._querying || n.isSome(this._queryResult) } }, { key: "dirty", set: function (z) { this._dirty = z } }]); return r
          }(q); c.__decorate([h.property({ readOnly: !0 })], a.Graphics3DFilterVisibility.prototype,
            "updating", null); c.__decorate([h.property({ readOnly: !0 })], a.Graphics3DFilterVisibility.prototype, "running", null); c.__decorate([h.property()], a.Graphics3DFilterVisibility.prototype, "_dirty", void 0); c.__decorate([h.property()], a.Graphics3DFilterVisibility.prototype, "_querying", void 0); c.__decorate([h.property()], a.Graphics3DFilterVisibility.prototype, "_queryResult", void 0); a.Graphics3DFilterVisibility = c.__decorate([t.subclass("esri.views.3d.layers.graphics.Graphics3DFilterVisibility")], a.Graphics3DFilterVisibility);
          Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/QueryEngine": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../geometry ../../../../core/Accessor ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/Extent ../../../../layers/graphics/data/QueryEngine ../../../../rest/support/FeatureSet ../../../../rest/support/Query ../../../../geometry/support/typeUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = f.default; a.QueryEngine = function (g) {
            function x(r) { r = g.call(this, r) || this; r._dataQueryEngineInstance = null; return r } w._inheritsLoose(x, g); var k = x.prototype; k.destroy = function () { this.clear() }; k.clear = function () { return this._dataQueryEngineInstance ? (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null, !0) : !1 }; k.executeQueryForIdSet = function () {
              var r = w._asyncToGenerator(function* (A, z) {
                return this.dataQueryEngine.executeQueryForIdSet(this._ensureQueryJSON(A),
                  z)
              }); return function (A, z) { return r.apply(this, arguments) }
            }(); k.executeQueryForCount = function () { var r = w._asyncToGenerator(function* (A, z) { return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(A), z) }); return function (A, z) { return r.apply(this, arguments) } }(); k.executeQueryForExtent = function () {
              var r = w._asyncToGenerator(function* (A, z) { const { count: B, extent: C } = yield this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(A), z); A = d.fromJSON(C); return { count: B, extent: A } }); return function (A,
                z) { return r.apply(this, arguments) }
            }(); k.executeQueryForIds = function () { var r = w._asyncToGenerator(function* (A, z) { return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(A), z) }); return function (A, z) { return r.apply(this, arguments) } }(); k.executeQueryForLatestObservations = function () {
              var r = w._asyncToGenerator(function* (A, z) {
                A = yield this.dataQueryEngine.executeQueryForLatestObservations(this._ensureQueryJSON(A), z); A = t.fromJSON(A); A.features.forEach(B => { B.layer = this.layer; B.sourceLayer = this.layer });
                return A
              }); return function (A, z) { return r.apply(this, arguments) }
            }(); k.executeQuery = function () { var r = w._asyncToGenerator(function* (A, z) { A = yield this.dataQueryEngine.executeQuery(this._ensureQueryJSON(A), z); A = t.fromJSON(A); A.features.forEach(B => { B.layer = this.layer; B.sourceLayer = this.layer }); return A }); return function (A, z) { return r.apply(this, arguments) } }(); k._ensureQueryJSON = function (r) {
              if (y.isNone(r)) return this.defaultQueryJSON; "outSpatialReference" in r && !r.outSpatialReference && (r.outSpatialReference =
                this.spatialReference); return r.toJSON()
            }; k.ensureDataQueryEngine = function () {
              if (this._dataQueryEngineInstance) return this._dataQueryEngineInstance; const r = "timeInfo" in this.layer && this.layer.timeInfo && this.layer.timeInfo.toJSON() || null, A = this.layer.objectIdField, z = m.featureGeometryTypeKebabDictionary.toJSON(this.queryGeometryType), B = this.layer.fields.map(F => F.toJSON()), C = this.layerView.view.resourceController.scheduler, D = this.priority, E = this.spatialReference.toJSON(), H = this.layerView.graphics3d.graphicsCore.featureStore,
                { hasZ: J, hasM: M } = this.layerView; return this._dataQueryEngineInstance = new e({ hasZ: J, hasM: M, geometryType: z, fields: B, timeInfo: r, spatialReference: E, objectIdField: A, featureStore: H, scheduler: C, priority: D })
            }; w._createClass(x, [{ key: "queryGeometryType", get: function () { switch (this.layer.geometryType) { case "multipoint": case "point": case "polygon": case "polyline": return this.layer.geometryType; case "mesh": return "polygon" } } }, { key: "defaultQueryJSON", get: function () { return (new v({ outSpatialReference: this.spatialReference })).toJSON() } },
            { key: "dataQueryEngine", get: function () { return this.ensureDataQueryEngine() } }]); return x
          }(u); c.__decorate([n.property({ constructOnly: !0 })], a.QueryEngine.prototype, "layerView", void 0); c.__decorate([n.property({ constructOnly: !0 })], a.QueryEngine.prototype, "priority", void 0); c.__decorate([n.property({ readOnly: !0, aliasOf: "layerView.view.spatialReference" })], a.QueryEngine.prototype, "spatialReference", void 0); c.__decorate([n.property({ readOnly: !0, aliasOf: "layerView.layer" })], a.QueryEngine.prototype, "layer",
            void 0); c.__decorate([n.property({ readOnly: !0 })], a.QueryEngine.prototype, "queryGeometryType", null); c.__decorate([n.property({ readOnly: !0 })], a.QueryEngine.prototype, "defaultQueryJSON", null); a.QueryEngine = c.__decorate([b.subclass("esri.views.3d.layers.graphics.QueryEngine")], a.QueryEngine); a.default = a.QueryEngine; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/data/QueryEngine": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Error ../../../core/lang ../../../core/maybe ../../../core/MemCache ../../../core/unitUtils ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ../../../geometry/support/boundsUtils ../../../geometry/support/jsonUtils ../../../geometry/support/normalizeUtils ../../../geometry/support/spatialReferenceUtils ./attributeSupport ./projectionSupport ./QueryEngineCapabilities ./QueryEngineResult ./spatialQuerySupport ./timeSupport ./utils ../../support/FieldsIndex ../../../support/arcadeOnDemand ../../../views/support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z) {
          function B(F) { return F.every(K => "exceedslimit" !== K.statisticType) } const C = new Set, D = new y.MemCacheStorage(2E6); let E = 0, H = function () {
            function F(P) {
            this.capabilities = { query: m.queryCapabilities }; this.geometryType = P.geometryType; this.hasM = P.hasM; this.hasZ = P.hasZ; this.objectIdField = P.objectIdField; this.spatialReference = P.spatialReference; this.definitionExpression = P.definitionExpression; this.featureStore = P.featureStore; this.aggregateAdapter = P.aggregateAdapter;
              this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()); this.timeInfo = P.timeInfo; P.cacheSpatialQueries && (this._geometryQueryCache = new y.MemCache(E++ + "$$", D)); this.fieldsIndex = new r(P.fields); P.scheduler && P.priority && (this._frameTask = P.scheduler.registerTask(P.priority))
            } var K = F.prototype; K.destroy = function () { this._frameTask = u.removeMaybe(this._frameTask); this.clearCache(); u.destroyMaybe(this._geometryQueryCache); this._changeHandle = u.removeMaybe(this._changeHandle); u.destroyMaybe(this.fieldsIndex) };
            K.clearCache = function () { this._geometryQueryCache && this._geometryQueryCache.clear(); this._timeExtent = this._allItems = null }; K.executeQuery = function () {
              var P = w._asyncToGenerator(function* (L = {}, N) {
                let G = q.clone(L), I; try {
                G = yield this._schedule(() => k.normalizeQuery(G, this.definitionExpression, this.spatialReference), N), G = yield this._reschedule(() => this._checkQuerySupport(G), N), I = yield this._reschedule(() => this._executeGeometryQuery(G, N), N), I = yield this._reschedule(() => I.executeAggregateIdsQuery(G), N), I = yield this._reschedule(() =>
                  I.executeObjectIdsQuery(G), N), I = yield this._reschedule(() => I.executeTimeQuery(G), N), I = yield this._reschedule(() => I.executeAttributesQuery(G), N)
                } catch (O) { if (O !== k.QUERY_ENGINE_EMPTY_RESULT) throw O; I = new e([], null, this) } return I.createQueryResponse(G)
              }); return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForCount = function () {
              var P = w._asyncToGenerator(function* (L = {}, N) {
                let G = q.clone(L); G.returnGeometry = !1; G.returnCentroid = !1; G.outSR = null; try {
                  G = yield this._schedule(() => k.normalizeQuery(G,
                    this.definitionExpression, this.spatialReference), N); G = yield this._reschedule(() => this._checkQuerySupport(G), N); let I = yield this._reschedule(() => this._executeGeometryQuery(G, N), N); I = yield this._reschedule(() => I.executeAggregateIdsQuery(G), N); I = yield this._reschedule(() => I.executeObjectIdsQuery(G), N); I = yield this._reschedule(() => I.executeTimeQuery(G), N); I = yield this._reschedule(() => I.executeAttributesQuery(G), N); return I.createQueryResponseForCount(G)
                } catch (I) {
                  if (I !== k.QUERY_ENGINE_EMPTY_RESULT) throw I;
                  return 0
                }
              }); return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForExtent = function () {
              var P = w._asyncToGenerator(function* (L = {}, N) {
                let G = q.clone(L), I; L = G.outSR; try {
                  G = yield this._schedule(() => k.normalizeQuery(G, this.definitionExpression, this.spatialReference), N); G = yield this._reschedule(() => this._checkQuerySupport(G), N); G.returnGeometry = !0; G.returnCentroid = !1; G.outSR = null; I = yield this._reschedule(() => this._executeGeometryQuery(G, N), N); I = yield this._reschedule(() => I.executeAggregateIdsQuery(G),
                    N); I = yield this._reschedule(() => I.executeObjectIdsQuery(G), N); I = yield this._reschedule(() => I.executeTimeQuery(G), N); I = yield this._reschedule(() => I.executeAttributesQuery(G), N); const O = I.size; if (!O) return { count: O, extent: null }; p.set(M, p.NEGATIVE_INFINITY); this.featureStore.forEachBounds(I.items, Q => p.expandWithAABB(M, Q), J); const R = { xmin: M[0], ymin: M[1], xmax: M[3], ymax: M[4], spatialReference: k.cleanFromGeometryEngine(this.spatialReference) }; this.hasZ && isFinite(M[2]) && isFinite(M[5]) && (R.zmin = M[2], R.zmax =
                      M[5]); const S = v.project(R, I.spatialReference, L); S.spatialReference = k.cleanFromGeometryEngine(L || this.spatialReference); if (0 === S.xmax - S.xmin) { const Q = n.getMetersPerUnitForSR(S.spatialReference); S.xmin -= Q; S.xmax += Q } if (0 === S.ymax - S.ymin) { const Q = n.getMetersPerUnitForSR(S.spatialReference); S.ymin -= Q; S.ymax += Q } if (this.hasZ && null != S.zmin && null != S.zmax && 0 === S.zmax - S.zmin) { const Q = n.getMetersPerUnitForSR(S.spatialReference); S.zmin -= Q; S.zmax += Q } return { count: O, extent: S }
                } catch (O) {
                  if (O === k.QUERY_ENGINE_EMPTY_RESULT) return {
                    count: 0,
                    extent: null
                  }; throw O;
                }
              }); return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForIds = function () { var P = w._asyncToGenerator(function* (L = {}, N) { return this.executeQueryForIdSet(L, N).then(G => Array.from(G)) }); return function () { return P.apply(this, arguments) } }(); K.executeQueryForIdSet = function () {
              var P = w._asyncToGenerator(function* (L = {}, N) {
                let G = q.clone(L), I; G.returnGeometry = !1; G.returnCentroid = !1; G.outSR = null; try {
                  G = yield this._schedule(() => k.normalizeQuery(G, this.definitionExpression, this.spatialReference),
                    N); G = yield this._reschedule(() => this._checkQuerySupport(G), N); I = yield this._reschedule(() => this._executeGeometryQuery(G, N), N); I = yield this._reschedule(() => I.executeAggregateIdsQuery(G), N); I = yield this._reschedule(() => I.executeObjectIdsQuery(G), N); I = yield this._reschedule(() => I.executeTimeQuery(G), N); I = yield this._reschedule(() => I.executeAttributesQuery(G), N); const O = I.items, R = new Set; yield this._reschedule(() => { for (const S of O) R.add(I.featureAdapter.getObjectId(S)) }, N); return R
                } catch (O) {
                  if (O === k.QUERY_ENGINE_EMPTY_RESULT) return new Set;
                  throw O;
                }
              }); return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForSnapping = function () {
              var P = w._asyncToGenerator(function* (L, N) {
                const { point: G, distance: I, types: O } = L; if (0 === O) return { candidates: [] }; const R = yield this._reschedule(() => this._checkQuerySupport(L.query), N), S = !f.equals(G.spatialReference, this.spatialReference); S && (yield v.checkProjectionSupport(G.spatialReference, this.spatialReference)); var Q = "number" === typeof I ? I : I.x, T = "number" === typeof I ? I : I.y; Q = {
                  xmin: G.x - Q, xmax: G.x + Q, ymin: G.y -
                    T, ymax: G.y + T, spatialReference: G.spatialReference
                }; Q = S ? v.project(Q, this.spatialReference) : Q; if (!Q) return { candidates: [] }; T = (yield d.normalizeCentralMeridian(b.fromJSON(G), null, { signal: N }))[0]; const da = (yield d.normalizeCentralMeridian(b.fromJSON(Q), null, { signal: N }))[0]; if (u.isNone(T) || u.isNone(da)) return { candidates: [] }; let Y = new e(this._searchFeatures(this._getQueryBBoxes(da.toJSON())), null, this); Y = yield this._reschedule(() => Y.executeObjectIdsQuery(R), N); Y = yield this._reschedule(() => Y.executeTimeQuery(R),
                  N); Y = yield this._reschedule(() => Y.executeAttributesQuery(R), N); N = T.toJSON(); N = S ? v.project(N, this.spatialReference) : N; return Y.createSnappingResponse({ ...L, point: N, distance: S ? Math.max(Q.xmax - Q.xmin, Q.ymax - Q.ymin) / 2 : I }, G.spatialReference)
              }); return function (L, N) { return P.apply(this, arguments) }
            }(); K.executeQueryForLatestObservations = function () {
              var P = w._asyncToGenerator(function* (L = {}, N) {
                if (!this.timeInfo || !this.timeInfo.trackIdField) throw new c("feature-store:unsupported-query", "Missing timeInfo or timeInfo.trackIdField",
                  { query: L, timeInfo: this.timeInfo }); let G = q.clone(L), I; try {
                  G = yield this._schedule(() => k.normalizeQuery(G, this.definitionExpression, this.spatialReference), N), G = yield this._reschedule(() => this._checkQuerySupport(G), N), I = yield this._reschedule(() => this._executeGeometryQuery(G, N), N), I = yield this._reschedule(() => I.executeAggregateIdsQuery(G), N), I = yield this._reschedule(() => I.executeObjectIdsQuery(G), N), I = yield this._reschedule(() => I.executeTimeQuery(G), N), I = yield this._reschedule(() => I.executeAttributesQuery(G),
                    N), I = yield this._reschedule(() => I.filterLatest(), N)
                  } catch (O) { if (O !== k.QUERY_ENGINE_EMPTY_RESULT) throw O; I = new e([], null, this) } return I.createQueryResponse(G)
              }); return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForSummaryStatistics = function () {
              var P = w._asyncToGenerator(function* (L = {}, N, G) { const { field: I, normalizationField: O, valueExpression: R } = N; return (yield this._getQueryEngineResultForStats(L, { field: I, normalizationField: O, valueExpression: R }, G)).createSummaryStatisticsResponse(L, N) });
              return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForUniqueValues = function () { var P = w._asyncToGenerator(function* (L = {}, N, G) { const { field: I, valueExpression: O } = N; return (yield this._getQueryEngineResultForStats(L, { field: I, valueExpression: O }, G)).createUniqueValuesResponse(L, N) }); return function () { return P.apply(this, arguments) } }(); K.executeQueryForClassBreaks = function () {
              var P = w._asyncToGenerator(function* (L = {}, N, G) {
                const { field: I, normalizationField: O, valueExpression: R } = N; return (yield this._getQueryEngineResultForStats(L,
                  { field: I, normalizationField: O, valueExpression: R }, G)).createClassBreaksResponse(L, N)
              }); return function () { return P.apply(this, arguments) }
            }(); K.executeQueryForHistogram = function () { var P = w._asyncToGenerator(function* (L = {}, N, G) { const { field: I, normalizationField: O, valueExpression: R } = N; return (yield this._getQueryEngineResultForStats(L, { field: I, normalizationField: O, valueExpression: R }, G)).createHistogramResponse(L, N) }); return function () { return P.apply(this, arguments) } }(); K._schedule = function () {
              var P = w._asyncToGenerator(function* (L,
                N) { return u.isSome(this._frameTask) ? this._frameTask.schedule(L, N) : L(z.noBudget) }); return function (L, N) { return P.apply(this, arguments) }
            }(); K._reschedule = function () { var P = w._asyncToGenerator(function* (L, N) { return u.isSome(this._frameTask) ? this._frameTask.reschedule(L, N) : L(z.noBudget) }); return function (L, N) { return P.apply(this, arguments) } }(); K._getAll = function () { if (!this._allItems) { const P = []; this.featureStore.forEach(L => P.push(L)); this._allItems = new e(P, null, this) } return this._allItems }; K._executeGeometryQuery =
              function () {
                var P = w._asyncToGenerator(function* (L, N) {
                  var G = this; const { geometry: I, outSR: O, spatialRel: R, returnGeometry: S, returnCentroid: Q } = L, T = S || Q, da = f.isValid(O) && !f.equals(this.spatialReference, O), Y = this._geometryQueryCache ? da && T ? JSON.stringify({ geometry: I, spatialRelationship: R, outSpatialReference: O }) : JSON.stringify({ geometry: I, spatialRelationship: R }) : null; if (Y) { var fa = this._geometryQueryCache.get(Y); if (!u.isUndefined(fa)) return fa } fa = function () {
                    var ba = w._asyncToGenerator(function* (aa) {
                      if (da && T) return aa =
                        yield aa.project(O), Y && G._geometryQueryCache.put(Y, aa, aa.size || 1), aa; Y && G._geometryQueryCache.put(Y, aa, aa.size || 1); return aa
                    }); return function (aa) { return ba.apply(this, arguments) }
                  }(); if (!I) return fa(this._getAll()); const ha = this.featureAdapter; if ("esriSpatialRelDisjoint" === R) {
                    L = this._searchFeatures(this._getQueryBBoxes(I)); if (!L.length) return fa(this._getAll()); let ba, aa; const W = new Set; for (var ka of L) W.add(ha.getObjectId(ka)); yield this._reschedule(() => {
                      let U = 0; ba = Array(W.size); this.featureStore.forEach(X =>
                        ba[U++] = X); aa = W
                    }, N); L = yield this._reschedule(w._asyncToGenerator(function* () { const U = yield g.getSpatialQueryOperator(R, I, G.geometryType, G.hasZ, G.hasM); return new e(yield G._runSpatialFilter(ba, X => !aa.has(ha.getObjectId(X)) || U(ha.getGeometry(X)), N), I, G) }), N); return fa(L)
                  } ka = this._searchFeatures(this._getQueryBBoxes(I)); if (!ka.length) return fa = new e([], I, this), Y && this._geometryQueryCache.put(Y, fa, fa.size || 1), fa; if (this._canExecuteSoloPass(I, L)) return fa(new e(ka, I, this)); const ea = yield g.getSpatialQueryOperator(R,
                    I, this.geometryType, this.hasZ, this.hasM); L = yield this._runSpatialFilter(ka, ba => ea(ha.getGeometry(ba)), N); return fa(new e(L, I, this))
                }); return function (L, N) { return P.apply(this, arguments) }
              }(); K._runSpatialFilter = function () {
                var P = w._asyncToGenerator(function* (L, N, G) {
                  var I = this; if (!N) return L; if (u.isNone(this._frameTask)) return L.filter(Q => N(Q)); let O = 0; const R = [], S = function () {
                    var Q = w._asyncToGenerator(function* (T) {
                      for (; O < L.length;) {
                        const da = L[O++]; N(da) && (R.push(da), T.madeProgress()); T.done && (yield I._reschedule(Y =>
                          S(Y), G))
                      }
                    }); return function (T) { return Q.apply(this, arguments) }
                  }(); return this._reschedule(Q => S(Q), G).then(() => R)
                }); return function (L, N, G) { return P.apply(this, arguments) }
              }(); K._canExecuteSoloPass = function (P, L) { const { geometryType: N } = this; ({ spatialRel: L } = L); return g.canQueryWithRBush(P) && ("esriSpatialRelEnvelopeIntersects" === L || "esriGeometryPoint" === N && ("esriSpatialRelIntersects" === L || "esriSpatialRelContains" === L || "esriSpatialRelWithin" === L)) }; K._getQueryBBoxes = function (P) {
                if (g.canQueryWithRBush(P)) {
                  if (b.isExtent(P)) return [l.fromValues(P.xmin,
                    P.ymin, P.xmax, P.ymax)]; if (b.isPolygon(P)) return P.rings.map(L => l.fromValues(Math.min(L[0][0], L[2][0]), Math.min(L[0][1], L[2][1]), Math.max(L[0][0], L[2][0]), Math.max(L[0][1], L[2][1])))
                } return [h.getBoundsXY(l.create(), P)]
              }; K._searchFeatures = function (P) { for (const G of P) this.featureStore.forEachInBounds(G, I => { C.add(I) }); const L = Array(C.size); let N = 0; C.forEach(G => L[N++] = G); C.clear(); return L }; K._checkStatisticsSupport = function () {
                var P = w._asyncToGenerator(function* (L, N) {
                  if (0 > L.distance || null != L.geometryPrecision ||
                    L.multipatchOption || L.pixelSize || L.relationParam || L.text || L.outStatistics || L.groupByFieldsForStatistics || L.having || L.orderByFields) throw new c("feature-store:unsupported-query", "Unsupported query options", { query: L }); return Promise.all([this._checkAttributesQuerySupport(L), this._checkStatisticsParamsSupport(N), g.checkSpatialQuerySupport(L, this.geometryType, this.spatialReference), v.checkProjectionSupport(this.spatialReference, L.outSR)]).then(() => L)
                }); return function (L, N) { return P.apply(this, arguments) }
              }();
            K._checkStatisticsParamsSupport = function () {
              var P = w._asyncToGenerator(function* (L) { var N = []; L.valueExpression && ({ arcadeUtils: N } = yield A.loadArcade(), N = N.extractFieldNames(L.valueExpression)); L.field && N.push(L.field); L.normalizationField && N.push(L.normalizationField); if (!N.length) throw new c("feature-store:unsupported-query", "params should have at least a field or valueExpression", { params: L }); t.validateFields(this.fieldsIndex, N, "params contains missing fields") }); return function (L) {
                return P.apply(this,
                  arguments)
              }
            }(); K._checkQuerySupport = function () {
              var P = w._asyncToGenerator(function* (L) {
                if (0 > L.distance || null != L.geometryPrecision || L.multipatchOption || L.pixelSize || L.relationParam || L.text) throw new c("feature-store:unsupported-query", "Unsupported query options", { query: L }); return Promise.all([this._checkAttributesQuerySupport(L), this._checkStatisticsQuerySupport(L), g.checkSpatialQuerySupport(L, this.geometryType, this.spatialReference), v.checkProjectionSupport(this.spatialReference, L.outSR)]).then(() =>
                  L)
              }); return function (L) { return P.apply(this, arguments) }
            }(); K._checkAttributesQuerySupport = function (P) {
              const { outFields: L, orderByFields: N, returnDistinctValues: G, outStatistics: I } = P, O = I ? I.map(R => R.outStatisticFieldName && R.outStatisticFieldName.toLowerCase()) : []; if (N && 0 < N.length) { const R = N.map(S => { const Q = S.toLowerCase(); return -1 < Q.indexOf(" asc") ? Q.split(" asc")[0] : -1 < Q.indexOf(" desc") ? Q.split(" desc")[0] : S }).filter(S => -1 === O.indexOf(S)); t.validateFields(this.fieldsIndex, R, "orderByFields contains missing fields") } if (L &&
                0 < L.length) t.validateFields(this.fieldsIndex, L, "outFields contains missing fields"); else if (G) throw new c("feature-store:unsupported-query", "outFields should be specified for returnDistinctValues", { query: P }); t.validateWhere(this.fieldsIndex, P.where)
            }; K._checkStatisticsQuerySupport = function () {
              var P = w._asyncToGenerator(function* (L) {
                const { outStatistics: N, groupByFieldsForStatistics: G, having: I } = L; var O = G && G.length, R = N && N.length; if (I) {
                  if (!O || !R) throw new c("feature-store:unsupported-query", "outStatistics and groupByFieldsForStatistics should be specified with having",
                    { query: L }); t.validateHaving(this.fieldsIndex, I, N)
                } if (R && B(N)) {
                  R = N.map(S => S.onStatisticField); t.validateFields(this.fieldsIndex, R, "onStatisticFields contains missing fields"); O && t.validateFields(this.fieldsIndex, G, "groupByFieldsForStatistics contains missing fields"); for (const S of N) {
                    const { onStatisticField: Q, statisticType: T } = S; if (("percentile_disc" === T || "percentile_cont" === T) && "statisticParameters" in S) {
                      if ({ statisticParameters: O } = S, !O) throw new c("feature-store:unsupported-query", "statisticParamters should be set for percentile type",
                        { definition: S, query: L });
                    } else if ("count" !== T && Q && t.hasInvalidFieldType(Q, this.fieldsIndex)) throw new c("feature-store:unsupported-query", "outStatistics contains non-numeric fields", { definition: S, query: L });
                  }
                }
              }); return function (L) { return P.apply(this, arguments) }
            }(); K._getQueryEngineResultForStats = function () {
              var P = w._asyncToGenerator(function* (L = {}, N, G) {
                L = q.clone(L); let I; try {
                L = yield this._schedule(() => k.normalizeQuery(L, this.definitionExpression, this.spatialReference), G), L = yield this._reschedule(() =>
                  this._checkStatisticsSupport(L, N), G), I = yield this._reschedule(() => this._executeGeometryQuery(L, G), G), I = yield this._reschedule(() => I.executeAggregateIdsQuery(L), G), I = yield this._reschedule(() => I.executeObjectIdsQuery(L), G), I = yield this._reschedule(() => I.executeTimeQuery(L), G), I = yield this._reschedule(() => I.executeAttributesQuery(L), G)
                } catch (O) { if (O !== k.QUERY_ENGINE_EMPTY_RESULT) throw O; I = new e([], null, this) } return I
              }); return function () { return P.apply(this, arguments) }
            }(); w._createClass(F, [{
              key: "featureAdapter",
              get: function () { return this.featureStore.featureAdapter }
            }, { key: "fullExtent", get: function () { const P = this.featureStore.fullBounds; return P ? { xmin: P[0], ymin: P[1], xmax: P[2], ymax: P[3], spatialReference: k.cleanFromGeometryEngine(this.spatialReference) } : null } }, { key: "timeExtent", get: function () { return this.timeInfo ? this._timeExtent ? this._timeExtent : this._timeExtent = x.getTimeExtent(this.timeInfo, this.featureStore) : null } }]); return F
          }(); const J = p.create(), M = p.create(); a.Feature = function (F, K = null, P, L, N) {
          this.attributes =
            F; this.geometry = P; this.centroid = L; this.filterFlags = N; this.groupId = -1; this.displayId = K
          }; a.default = H; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/data/attributeSupport": function () {
      define(["exports", "../../../core/Error", "../../../core/sql/WhereClauseCache"], function (a, w, c) {
        function q(l, h) { return l ? n.get(l, h) : null } function u(l, h, b, d = !0) {
          const f = []; for (const t of h) if ("*" !== t && !l.has(t)) if (d) {
            h = y(t); try {
              const v = q(h, l); if (!v) throw new w("feature-store:unsupported-query", "invalid SQL expression",
                { where: h }); if (!v.isStandardized) throw new w("feature-store:unsupported-query", "expression is not standard", { clause: v }); u(l, v.fieldNames, "expression contains missing fields")
            } catch (v) { if ((h = v && v.details) && (h.clause || h.where)) throw v; h && h.missingFields ? f.push(...h.missingFields) : f.push(t) }
          } else f.push(t); if (f.length) throw new w("feature-store:unsupported-query", b, { missingFields: f });
        } function y(l) { return l.split(" as ")[0] } const n = new c.WhereClauseCache(50, 500), p = new Set("esriFieldTypeOID esriFieldTypeSmallInteger esriFieldTypeInteger esriFieldTypeSingle esriFieldTypeDouble esriFieldTypeLong esriFieldTypeDate".split(" "));
        a.getAliasFromFieldName = function (l) { return l.split(" as ")[1] }; a.getExpressionFromFieldName = y; a.getWhereClause = q; a.hasInvalidFieldType = function (l, h) { return (l = h.get(l)) ? !p.has(l.type) : !1 }; a.validateFields = u; a.validateHaving = function (l, h, b) {
          if (!h) return !0; const d = n.get(h, l); if (!d) throw new w("feature-store:unsupported-query", "invalid SQL expression", { having: h }); if (!d.isAggregate) throw new w("feature-store:unsupported-query", "having does not contain a valid aggregate function", { having: h }); u(l, d.fieldNames,
            "having contains missing fields"); if (!d.getExpressions().every(f => { const { aggregateType: t, field: v } = f, m = l.has(v) && l.get(v).name; return b.some(e => { const { onStatisticField: g, statisticType: x } = e; return (l.has(g) && l.get(g).name) === m && x.toLowerCase().trim() === t }) })) throw new w("feature-store:unsupported-query", "expressions in having should also exist in outStatistics", { having: h }); return !0
        }; a.validateWhere = function (l, h) {
          if (!h) return !0; const b = n.get(h, l); if (!b) throw new w("feature-store:unsupported-query",
            "invalid SQL expression", { where: h }); if (!b.isStandardized) throw new w("feature-store:unsupported-query", "where clause is not standard", { where: h }); u(l, b.fieldNames, "where clause contains missing fields"); return !0
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/sql/WhereClauseCache": function () {
      define(["exports", "../ItemCache", "./WhereClause"], function (a, w, c) {
        let q = function () {
          function u(y, n) { this._cache = new w(y); this._invalidCache = new w(n) } u.prototype.get = function (y, n) {
            const p = `${n.uid}:${y}`,
            l = this._cache.get(p); if (l) return l; if (void 0 !== this._invalidCache.get(p)) return null; try { const h = c.WhereClause.create(y, n); this._cache.put(p, h); return h } catch{ return this._invalidCache.put(p, null), null }
          }; return u
        }(); a.WhereClauseCache = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/sql/WhereClause": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../has ./AggregateFunctions ./StandardizedFunctions ./WhereGrammar".split(" "), function (a, w, c, q, u, y) {
        function n(M, F) {
          M +=
          ""; return M.length >= F ? M : Array(F - M.length + 1).join("0") + M
        } function p(M, F, K = "0", P = "0", L = "0", N = "0", G = "", I = "0", O = "0") { return "+" === G || "-" === G ? (M = `${n(parseInt(M, 10), 4)}-${n(parseInt(F, 10), 2)}-${n(parseInt(K, 10), 2)}`, F = "", 10 > parseFloat(N) && (F = "0"), P = `${n(parseInt(P, 10), 2)}:${n(parseInt(L, 10), 2)}:${F + parseFloat(N).toString()}`, G = `${G}${n(parseInt(I, 10), 2)}:${n(parseInt(O, 10), 2)}`, new Date(M + "T" + P + G)) : new Date(parseInt(M, 10), parseInt(F, 10) - 1, parseInt(K, 10), parseInt(P, 10), parseInt(L, 10), parseFloat(N)) } function l(M) {
          let F =
            A.exec(M); if (null !== F) { const [, K, P, L, N, G, I] = F; return p(K, P, L, N, G, I) } F = z.exec(M); if (null !== F) { const [, K, P, L, N, G, I, O, R, S] = F; return p(K, P, L, N, G, I, O, R, S) } F = B.exec(M); if (null !== F) { const [, K, P, L, N, G, I, O, R] = F; return p(K, P, L, N, G, "0", I, O, R) } F = C.exec(M); if (null !== F) { const [, K, P, L, N, G] = F; return p(K, P, L, N, G) } F = r.exec(M); if (null !== F) { const [, K, P, L] = F; return p(K, P, L) } throw Error("SQL Invalid Timestamp");
        } function h(M) {
          M = r.exec(M); if (null === M) throw Error("SQL Invalid Date"); const [, F, K, P] = M; return new Date(parseInt(F,
            10), parseInt(K, 10) - 1, parseInt(P, 10))
        } function b(M) { return Array.isArray(M) ? M : [M] } function d(M) { return null !== M ? !0 !== M : null } function f(M, F) { return null != M && null != F ? !0 === M && !0 === F : !1 === M || !1 === F ? !1 : null } function t(M, F) { return null != M && null != F ? !0 === M || !0 === F : !0 === M || !0 === F ? !0 : null } function v(M, F) { if (null == M) return null; let K = !1; for (const P of F) if (null == P) K = null; else if (M === P) { K = !0; break } return K } function m(M, F, K) {
          if (null == M) return null; let P = "", L = 0; for (let N = 0; N < F.length; N++) {
            const G = F.charAt(N); switch (L) {
              case 0: G ===
                K ? L = 1 : P = 0 <= "-[]/{}()*+?.\\^$|".indexOf(G) ? P + ("\\" + G) : "%" === G ? P + ".*" : "_" === G ? P + "." : P + G; break; case 1: P = 0 <= "-[]/{}()*+?.\\^$|".indexOf(G) ? P + ("\\" + G) : P + G, L = 0
            }
          } return (new RegExp("^" + P + "$")).test(M)
        } function e(M) { return M instanceof Date ? M.valueOf() : M } function g(M, F, K) { if (null == F || null == K) return null; F = e(F); K = e(K); switch (M) { case "\x3c\x3e": return F !== K; case "\x3d": return F === K; case "\x3e": return F > K; case "\x3c": return F < K; case "\x3e\x3d": return F >= K; case "\x3c\x3d": return F <= K } } function x(M, F, K) {
          if (F instanceof
            u.SqlInterval) if (K instanceof Date) switch (M) { case "+": return new Date(F.valueInMilliseconds() + K.getTime()); case "-": return F.valueInMilliseconds() - K.getTime(); case "*": return F.valueInMilliseconds() * K.getTime(); case "/": return F.valueInMilliseconds() / K.getTime() } else if (K instanceof u.SqlInterval) switch (M) {
              case "+": return u.SqlInterval.createFromMilliseconds(F.valueInMilliseconds() + K.valueInMilliseconds()); case "-": return u.SqlInterval.createFromMilliseconds(F.valueInMilliseconds() - K.valueInMilliseconds());
              case "*": return F.valueInMilliseconds() * K.valueInMilliseconds(); case "/": return F.valueInMilliseconds() / K.valueInMilliseconds()
            } else F = F.valueInMilliseconds(); else if (K instanceof u.SqlInterval) if (F instanceof Date) switch (M) { case "+": return new Date(K.valueInMilliseconds() + F.getTime()); case "-": return new Date(F.getTime() - K.valueInMilliseconds()); case "*": return F.getTime() * K.valueInMilliseconds(); case "/": return F.getTime() / K.valueInMilliseconds() } else K = K.valueInMilliseconds(); else if (F instanceof
              Date && "number" === typeof K) switch (K *= 864E5, F = F.getTime(), M) { case "+": return new Date(F + K); case "-": return new Date(F - K); case "*": return new Date(F * K); case "/": return new Date(F / K) } else if (K instanceof Date && "number" === typeof F) switch (F *= 864E5, K = K.getTime(), M) { case "+": return new Date(F + K); case "-": return new Date(F - K); case "*": return new Date(F * K); case "/": return new Date(F / K) }switch (M) { case "+": return F + K; case "-": return F - K; case "*": return F * K; case "/": return F / K }
        } function k(M, F, K, P) {
          M = P.getAttribute(M,
            F); return null != M && 1 === K[F] ? new Date(M) : M
        } const r = /^(\d{4})-(\d{1,2})-(\d{1,2})$/, A = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2}(\.[0-9]+)?)$/, z = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2}(\.[0-9]+)?)(\+|\-)(\d{1,2}):(\d{1,2})$/, B = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})(\+|\-)(\d{1,2}):(\d{1,2})$/, C = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})$/, D = new Set(["current_timestamp", "current_date", "current_time"]); let E = function () {
          function M() { } M.makeBool = function (F) {
            return !0 ===
              F
          }; M.featureValue = function (F, K, P, L) { return k(F, K, P, L) }; M.equalsNull = function (F) { return null === F }; M.applyLike = function (F, K, P) { return m(F, K, P) }; M.ensureArray = function (F) { return b(F) }; M.applyIn = function (F, K) { return v(F, K) }; M.currentDate = function () { const F = new Date; F.setHours(0, 0, 0, 0); return F }; M.makeSqlInterval = function (F, K, P) { return u.SqlInterval.createFromValueAndQualifer(F, K, P) }; M.convertInterval = function (F) { return F instanceof u.SqlInterval ? F.valueInMilliseconds() : F }; M.currentTimestamp = function () { return new Date };
          M.compare = function (F, K, P) { return g(F, K, P) }; M.calculate = function (F, K, P) { return x(F, K, P) }; M.makeComparable = function (F) { return e(F) }; M.evaluateFunction = function (F, K) { return u.evaluateFunction(F, K) }; M.lookup = function (F, K) { F = K[F]; return void 0 === F ? null : F }; M.between = function (F, K) { return null == F || null == K[0] || null == K[1] ? null : F >= K[0] && F <= K[1] }; M.notbetween = function (F, K) { return null == F || null == K[0] || null == K[1] ? null : F < K[0] || F > K[1] }; M.ternaryNot = function (F) { return d(F) }; M.ternaryAnd = function (F, K) { return f(F, K) };
          M.ternaryOr = function (F, K) { return t(F, K) }; return M
        }(), H = function () {
          function M(K, P) { this.fieldsIndex = P; this.datefields = {}; this.parameters = {}; this._hasDateFunctions = void 0; this.parseTree = y.WhereGrammar.parse(K); const { isStandardized: L, isAggregate: N, referencedFieldNames: G } = this.extractExpressionInfo(P); this.referencedFieldNames = G; this.isStandardized = L; this.isAggregate = N } M.create = function (K, P) { return new M(K, P) }; var F = M.prototype; F.testSet = function (K, P = J) {
            const L = {}; for (const N of this.fieldNames) L[N] =
              K.map(G => P.getAttribute(G, N)); return !!this.evaluateNode(this.parseTree, { attributes: L }, J)
          }; F.calculateValue = function (K, P = J) { K = this.evaluateNode(this.parseTree, K, P); return K instanceof u.SqlInterval ? K.valueInMilliseconds() / 864E5 : K }; F.calculateValueCompiled = function (K, P = J) {
            if (null != this.parseTree._compiledVersion) return this.parseTree._compiledVersion(K, this.parameters, P, this.datefields); if (c("esri-csp-restrictions")) return this.calculateValue(K, P); this.compileMe(); return this.parseTree._compiledVersion(K,
              this.parameters, P, this.datefields)
          }; F.testFeature = function (K, P = J) { return !!this.evaluateNode(this.parseTree, K, P) }; F.testFeatureCompiled = function (K, P = J) { if (null != this.parseTree._compiledVersion) return !!this.parseTree._compiledVersion(K, this.parameters, P, this.datefields); if (c("esri-csp-restrictions")) return this.testFeature(K, P); this.compileMe(); return !!this.parseTree._compiledVersion(K, this.parameters, P, this.datefields) }; F.getFunctions = function () {
            const K = new Set; this.visitAll(this.parseTree, P => {
            "function" ===
              P.type && K.add(P.name.toLowerCase())
            }); return Array.from(K)
          }; F.getExpressions = function () { const K = new Map; this.visitAll(this.parseTree, P => { if ("function" === P.type) { const L = P.name.toLowerCase(); P = P.args.value[0]; if ("column_ref" === P.type) { P = P.column; const N = `${L}-${P}`; K.has(N) || K.set(N, { aggregateType: L, field: P }) } } }); return [...K.values()] }; F.getVariables = function () { const K = new Set; this.visitAll(this.parseTree, P => { "param" === P.type && K.add(P.value.toLowerCase()) }); return Array.from(K) }; F.compileMe = function () {
            const K =
              "return this.convertInterval(" + this.evaluateNodeToJavaScript(this.parseTree) + ")"; this.parseTree._compiledVersion = (new Function("feature", "lookups", "attributeAdapter", "datefields", K)).bind(E)
          }; F.extractExpressionInfo = function (K) {
            const P = [], L = new Set; let N = !0, G = !0; this.visitAll(this.parseTree, I => {
              switch (I.type) {
                case "column_ref": {
                  const O = K.get(I.column); let R, S; O ? R = S = O.name : (S = I.column, R = S.toLowerCase()); !O || "date" !== O.type && "esriFieldTypeDate" !== O.type || (this.datefields[O.name] = 1); L.has(R) || (L.add(R),
                    P.push(S)); I.column = S; break
                } case "function": { const { name: O, args: R } = I; I = R.value.length; N && (N = u.isStandardized(O, I)); G && (G = q.isAggregate(O, I)) }
              }
            }); return { referencedFieldNames: Array.from(P), isStandardized: N, isAggregate: G }
          }; F.visitAll = function (K, P) {
            if (null != K) switch (P(K), K.type) {
              case "when_clause": this.visitAll(K.operand, P); this.visitAll(K.value, P); break; case "case_expression": for (const L of K.clauses) this.visitAll(L, P); "simple" === K.format && this.visitAll(K.operand, P); null !== K.else && this.visitAll(K.else,
                P); break; case "expr_list": for (const L of K.value) this.visitAll(L, P); break; case "unary_expr": this.visitAll(K.expr, P); break; case "binary_expr": this.visitAll(K.left, P); this.visitAll(K.right, P); break; case "function": this.visitAll(K.args, P)
            }
          }; F.evaluateNodeToJavaScript = function (K) {
            switch (K.type) {
              case "interval": return "this.makeSqlInterval(" + this.evaluateNodeToJavaScript(K.value) + ", " + JSON.stringify(K.qualifier) + "," + JSON.stringify(K.op) + ")"; case "case_expression": var P = ""; if ("simple" === K.format) {
                var L =
                  "this.makeComparable(" + this.evaluateNodeToJavaScript(K.operand) + ")"; P = "( "; for (let N = 0; N < K.clauses.length; N++)P += " (" + L + " \x3d\x3d\x3d this.makeComparable(" + this.evaluateNodeToJavaScript(K.clauses[N].operand) + ")) ? (" + this.evaluateNodeToJavaScript(K.clauses[N].value) + ") : "
              } else for (P = "( ", L = 0; L < K.clauses.length; L++)P += " this.makeBool(" + this.evaluateNodeToJavaScript(K.clauses[L].operand) + ")\x3d\x3d\x3dtrue ? (" + this.evaluateNodeToJavaScript(K.clauses[L].value) + ") : "; P = null !== K.else ? P + this.evaluateNodeToJavaScript(K.else) :
                P + "null"; return P += " )"; case "param": return "this.lookup(" + JSON.stringify(K.value.toLowerCase()) + ",lookups)"; case "expr_list": P = "["; for (L of K.value) "[" !== P && (P += ","), P += this.evaluateNodeToJavaScript(L); return P += "]"; case "unary_expr": return "this.ternaryNot(" + this.evaluateNodeToJavaScript(K.expr) + ")"; case "binary_expr": switch (K.operator) {
                  case "AND": return "this.ternaryAnd(" + this.evaluateNodeToJavaScript(K.left) + "," + this.evaluateNodeToJavaScript(K.right) + " )"; case "OR": return "this.ternaryOr(" + this.evaluateNodeToJavaScript(K.left) +
                    "," + this.evaluateNodeToJavaScript(K.right) + " )"; case "IS": if ("null" !== K.right.type) throw Error("Unsupported RHS for IS"); return "this.equalsNull(" + this.evaluateNodeToJavaScript(K.left) + ")"; case "ISNOT": if ("null" !== K.right.type) throw Error("Unsupported RHS for IS"); return "(!(this.equalsNull(" + this.evaluateNodeToJavaScript(K.left) + ")))"; case "IN": return "this.applyIn(" + this.evaluateNodeToJavaScript(K.left) + ",this.ensureArray(" + this.evaluateNodeToJavaScript(K.right) + "))"; case "NOT IN": return "this.ternaryNot(this.applyIn(" +
                      this.evaluateNodeToJavaScript(K.left) + ",this.ensureArray(" + this.evaluateNodeToJavaScript(K.right) + ")))"; case "BETWEEN": return "this.between(" + this.evaluateNodeToJavaScript(K.left) + "," + this.evaluateNodeToJavaScript(K.right) + ")"; case "NOTBETWEEN": return "this.notbetween(" + this.evaluateNodeToJavaScript(K.left) + "," + this.evaluateNodeToJavaScript(K.right) + ")"; case "LIKE": return "this.applyLike(" + this.evaluateNodeToJavaScript(K.left) + "," + this.evaluateNodeToJavaScript(K.right) + "," + JSON.stringify(K.escape) + ")";
                  case "NOT LIKE": return "this.ternaryNot(this.applyLike(" + this.evaluateNodeToJavaScript(K.left) + "," + this.evaluateNodeToJavaScript(K.right) + "," + JSON.stringify(K.escape) + "))"; case "\x3c\x3e": case "\x3c": case "\x3e": case "\x3e\x3d": case "\x3c\x3d": case "\x3d": return "this.compare(" + JSON.stringify(K.operator) + "," + this.evaluateNodeToJavaScript(K.left) + "," + this.evaluateNodeToJavaScript(K.right) + ")"; case "*": case "-": case "+": case "/": return "this.calculate(" + JSON.stringify(K.operator) + "," + this.evaluateNodeToJavaScript(K.left) +
                    "," + this.evaluateNodeToJavaScript(K.right) + ")"
                }throw Error("Not Supported Operator " + K.operator); case "null": case "bool": case "string": case "number": return JSON.stringify(K.value); case "date": return "(new Date(" + h(K.value).getTime().toString() + "))"; case "timestamp": return "(new Date(" + l(K.value).getTime().toString() + "))"; case "current_time": return "date" === K.mode ? "this.currentDate()" : "this.currentTimestamp()"; case "column_ref": return "this.featureValue(feature," + JSON.stringify(K.column) + ",datefields,attributeAdapter)";
              case "function": return "this.evaluateFunction(" + JSON.stringify(K.name) + "," + this.evaluateNodeToJavaScript(K.args) + ")"
            }throw Error("Unsupported sql syntax " + K.type);
          }; F.evaluateNode = function (K, P, L) {
            switch (K.type) {
              case "interval": return P = this.evaluateNode(K.value, P, L), u.SqlInterval.createFromValueAndQualifer(P, K.qualifier, K.op); case "case_expression": if ("simple" === K.format) {
                var N = e(this.evaluateNode(K.operand, P, L)); for (var G = 0; G < K.clauses.length; G++)if (N === e(this.evaluateNode(K.clauses[G].operand, P,
                  L))) return this.evaluateNode(K.clauses[G].value, P, L)
              } else for (N = 0; N < K.clauses.length; N++)if (!0 === this.evaluateNode(K.clauses[N].operand, P, L)) return this.evaluateNode(K.clauses[N].value, P, L); return null !== K.else ? this.evaluateNode(K.else, P, L) : null; case "param": return this.parameters[K.value.toLowerCase()]; case "expr_list": N = []; for (G of K.value) N.push(this.evaluateNode(G, P, L)); return N; case "unary_expr": return d(this.evaluateNode(K.expr, P, L)); case "binary_expr": switch (K.operator) {
                case "AND": return f(this.evaluateNode(K.left,
                  P, L), this.evaluateNode(K.right, P, L)); case "OR": return t(this.evaluateNode(K.left, P, L), this.evaluateNode(K.right, P, L)); case "IS": if ("null" !== K.right.type) throw Error("Unsupported RHS for IS"); return null === this.evaluateNode(K.left, P, L); case "ISNOT": if ("null" !== K.right.type) throw Error("Unsupported RHS for IS"); return null !== this.evaluateNode(K.left, P, L); case "IN": return N = b(this.evaluateNode(K.right, P, L)), v(this.evaluateNode(K.left, P, L), N); case "NOT IN": return N = b(this.evaluateNode(K.right, P, L)), d(v(this.evaluateNode(K.left,
                    P, L), N)); case "BETWEEN": return N = this.evaluateNode(K.left, P, L), K = this.evaluateNode(K.right, P, L), null == N || null == K[0] || null == K[1] ? null : N >= e(K[0]) && N <= e(K[1]); case "NOTBETWEEN": return N = this.evaluateNode(K.left, P, L), K = this.evaluateNode(K.right, P, L), null == N || null == K[0] || null == K[1] ? null : N < e(K[0]) || N > e(K[1]); case "LIKE": return m(this.evaluateNode(K.left, P, L), this.evaluateNode(K.right, P, L), K.escape); case "NOT LIKE": return d(m(this.evaluateNode(K.left, P, L), this.evaluateNode(K.right, P, L), K.escape)); case "\x3c\x3e": case "\x3c": case "\x3e": case "\x3e\x3d": case "\x3c\x3d": case "\x3d": return g(K.operator,
                      this.evaluateNode(K.left, P, L), this.evaluateNode(K.right, P, L)); case "-": case "+": case "*": case "/": return x(K.operator, this.evaluateNode(K.left, P, L), this.evaluateNode(K.right, P, L))
              }case "null": case "bool": case "string": case "number": return K.value; case "date": return h(K.value); case "timestamp": return l(K.value); case "current_time": return P = new Date, "date" === K.mode && P.setHours(0, 0, 0, 0), P; case "column_ref": return k(P, K.column, this.datefields, L); case "function": return P = this.evaluateNode(K.args, P, L),
                this.isAggregate ? q.aggregateFunction(K.name, P) : u.evaluateFunction(K.name, P)
            }throw Error("Unsupported sql syntax " + K.type);
          }; w._createClass(M, [{ key: "fieldNames", get: function () { return this.referencedFieldNames } }, {
            key: "hasDateFunctions", get: function () {
              if (null != this._hasDateFunctions) return this._hasDateFunctions; this._hasDateFunctions = !1; this.visitAll(this.parseTree, K => { "current_time" === K.type ? this._hasDateFunctions = !0 : "function" === K.type && (this._hasDateFunctions = this._hasDateFunctions || D.has(K.name.toLowerCase())) });
              return this._hasDateFunctions
            }
          }]); return M
        }(); const J = { getAttribute(M, F) { return (M && "object" === typeof M.attributes ? M.attributes : M)[F] } }; a.WhereClause = H; a.defaultAttributeAdapter = J; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/sql/AggregateFunctions": function () {
      define(["exports"], function (a) {
        function w(u) { let y = 0; for (let n = 0; n < u.length; n++)y += u[n]; return y / u.length } function c(u) { const y = w(u), n = u.length; let p = 0; for (const l of u) p += (l - y) ** 2; return 1 < n ? p / (n - 1) : 0 } const q = {
          min: {
            minParams: 1,
            maxParams: 1, evaluate: u => null == u[0] ? null : Math.min.apply(Math, u[0])
          }, max: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.max.apply(Math, u[0]) }, avg: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : w(u[0]) }, sum: { minParams: 1, maxParams: 1, evaluate: u => { if (null == u[0]) u = null; else { { u = u[0]; let y = 0; for (let n = 0; n < u.length; n++)y += u[n]; u = y } } return u } }, stddev: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.sqrt(c(u[0])) }, count: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : u[0].length },
          var: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : c(u[0]) }
        }; a.aggregateFunction = function (u, y) { const n = q[u.toLowerCase()]; if (null == n) throw Error("Function Not Recognised"); if (y.length < n.minParams || y.length > n.maxParams) throw Error(`Invalid Parameter count for call to ${u.toUpperCase()}`); return n.evaluate(y) }; a.isAggregate = function (u, y) { u = q[u.toLowerCase()]; return null != u && y >= u.minParams && y <= u.maxParams }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/core/sql/StandardizedFunctions": function () {
      define(["exports",
        "../string"], function (a, w) {
          let c = function () {
            function u() { this.op = "+"; this.minute = this.year = this.month = this.hour = this.second = this.day = 0 } u.fixDefaults = function (y) { if (null !== y.precision || null !== y.secondary) throw Error("Primary and Secondary SqlInterval qualifiers not supported"); }; u.createFromMilliseconds = function (y) { const n = new u; n.second = y / 1E3; return n }; u.createFromValueAndQualifer = function (y, n, p) {
              let l = null; const h = new u; h.op = "-" === p ? "-" : "+"; if ("interval-period" === n.type) {
                u.fixDefaults(n); if ("year" ===
                  n.period || "month" === n.period) throw Error("Year-Month Intervals not supported"); if (/^[0-9]{1,}$/.test(y)) h[n.period] = parseFloat(y); else throw Error("Illegal Interval");
              } else {
                u.fixDefaults(n.start); u.fixDefaults(n.end); if ("year" === n.start.period || "month" === n.start.period) throw Error("Year-Month Intervals not supported"); if ("year" === n.end.period || "month" === n.end.period) throw Error("Year-Month Intervals not supported"); switch (n.start.period) {
                  case "day": switch (n.end.period) {
                    case "hour": l = /^[0-9]{1,} [0-9]{1,}$/;
                      if (l.test(y)) h[n.start.period] = parseFloat(y.split(" ")[0]), h[n.end.period] = parseFloat(y.split(" ")[1]); else throw Error("Illegal Interval"); break; case "minute": l = /^[0-9]{1,} [0-9]{1,2}:[0-9]{1,}$/; if (l.test(y)) h[n.start.period] = parseFloat(y.split(" ")[0]), y = y.split(" ")[1].split(":"), h.hour = parseFloat(y[0]), h.minute = parseFloat(y[1]); else throw Error("Illegal Interval"); break; case "second": l = /^[0-9]{1,} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,}([.]{1}[0-9]{1,}){0,1}$/; if (l.test(y)) h[n.start.period] = parseFloat(y.split(" ")[0]),
                        y = y.split(" ")[1].split(":"), h.hour = parseFloat(y[0]), h.minute = parseFloat(y[1]), h.second = parseFloat(y[2]); else throw Error("Illegal Interval"); break; default: throw "Invalid Interval.";
                  }break; case "hour": switch (n.end.period) {
                    case "minute": l = /^[0-9]{1,}:[0-9]{1,}$/; if (l.test(y)) h.hour = parseFloat(y.split(":")[0]), h.minute = parseFloat(y.split(":")[1]); else throw Error("Illegal Interval"); break; case "second": l = /^[0-9]{1,}:[0-9]{1,2}:[0-9]{1,}([.]{1}[0-9]{1,}){0,1}$/; if (l.test(y)) y = y.split(":"), h.hour = parseFloat(y[0]),
                      h.minute = parseFloat(y[1]), h.second = parseFloat(y[2]); else throw Error("Illegal Interval"); break; default: throw "Invalid Interval.";
                  }break; case "minute": switch (n.end.period) { case "second": l = /^[0-9]{1,}:[0-9]{1,}([.]{1}[0-9]{1,}){0,1}$/; if (l.test(y)) y = y.split(":"), h.minute = parseFloat(y[0]), h.second = parseFloat(y[1]); else throw Error("Illegal Interval"); break; default: throw "Invalid Interval."; }break; default: throw "Invalid Interval.";
                }
              } return h
            }; u.prototype.valueInMilliseconds = function () {
              return ("-" === this.op ?
                -1 : 1) * (1E3 * this.second + 6E4 * this.minute + 36E5 * this.hour + 864E5 * this.day + 365 / 12 * this.month * 864E5 + 31536E6 * this.year)
            }; return u
          }(); const q = {
            extract: {
              minParams: 2, maxParams: 2, evaluate: ([u, y]) => {
                if (null == y) return null; if (y instanceof Date) switch (u.toUpperCase()) { case "SECOND": return y.getSeconds(); case "MINUTE": return y.getMinutes(); case "HOUR": return y.getHours(); case "DAY": return y.getDate(); case "MONTH": return y.getMonth() + 1; case "YEAR": return y.getFullYear() }throw Error("Invalid Parameter for call to EXTRACT");
              }
            }, substring: { minParams: 2, maxParams: 3, evaluate: u => { if (2 === u.length) { const [y, n] = u; return null == y || null == n ? null : y.toString().substring(n - 1) } if (3 === u.length) { const [y, n, p] = u; return null == y || null == n || null == p ? null : 0 >= p ? "" : y.toString().substring(n - 1, n + p - 1) } } }, position: { minParams: 2, maxParams: 2, evaluate: ([u, y]) => null == u || null == y ? null : y.indexOf(u) + 1 }, trim: {
              minParams: 2, maxParams: 3, evaluate: u => {
                var y = 3 === u.length, n = y ? u[1] : " "; y = y ? u[2] : u[1]; if (null == n || null == y) return null; n = `(${w.escapeRegExpString(n)})`; switch (u[0]) {
                  case "BOTH": return y.replace(new RegExp(`^${n}*|${n}*$`,
                    "g"), ""); case "LEADING": return y.replace(new RegExp(`^${n}*`, "g"), ""); case "TRAILING": return y.replace(new RegExp(`${n}*$`, "g"), "")
                }throw Error("Invalid Parameter for call to TRIM");
              }
            }, abs: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.abs(u[0]) }, ceiling: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.ceil(u[0]) }, floor: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.floor(u[0]) }, log: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.log(u[0]) }, log10: {
              minParams: 1,
              maxParams: 1, evaluate: u => null == u[0] ? null : Math.log(u[0]) * Math.LOG10E
            }, sin: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.sin(u[0]) }, cos: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.cos(u[0]) }, tan: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.tan(u[0]) }, asin: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.asin(u[0]) }, acos: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.acos(u[0]) }, atan: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : Math.atan(u[0]) },
            sign: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : 0 < u[0] ? 1 : 0 > u[1] ? -1 : 0 }, power: { minParams: 2, maxParams: 2, evaluate: u => null == u[0] || null == u[1] ? null : u[0] ** u[1] }, mod: { minParams: 2, maxParams: 2, evaluate: u => null == u[0] || null == u[1] ? null : u[0] % u[1] }, round: { minParams: 1, maxParams: 2, evaluate: u => { const y = u[0]; u = 2 === u.length ? 10 ** u[1] : 1; return null == y ? null : Math.round(y * u) / u } }, truncate: { minParams: 1, maxParams: 2, evaluate: u => null == u[0] ? null : 1 === u.length ? parseInt(u[0].toFixed(0), 10) : parseFloat(u[0].toFixed(u[1])) },
            char_length: { minParams: 1, maxParams: 1, evaluate: u => "string" === typeof u[0] || u[0] instanceof String ? u[0].length : 0 }, concat: { minParams: 1, maxParams: Infinity, evaluate: u => { let y = ""; for (let n = 0; n < u.length; n++) { if (null == u[n]) return null; y += u[n].toString() } return y } }, lower: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : u[0].toString().toLowerCase() }, upper: { minParams: 1, maxParams: 1, evaluate: u => null == u[0] ? null : u[0].toString().toUpperCase() }
          }; a.SqlInterval = c; a.evaluateFunction = function (u, y) {
            const n = q[u.toLowerCase()];
            if (null == n) throw Error("Function Not Recognised"); if (y.length < n.minParams || y.length > n.maxParams) throw Error(`Invalid Parameter count for call to ${u.toUpperCase()}`); return n.evaluate(y)
          }; a.isStandardized = function (u, y) { u = q[u.toLowerCase()]; return null != u && y >= u.minParams && y <= u.maxParams }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/sql/WhereGrammar": function () {
      define(["exports", "../../chunks/_commonjsHelpers"], function (a, w) {
        var c = { exports: {} }; (function (u) {
          (function (y, n) {
          u.exports &&
            (u.exports = n())
          })(w.commonjsGlobal, function () {
            function y(p, l, h, b) { p = Error.call(this, p); Object.setPrototypeOf && Object.setPrototypeOf(p, y.prototype); p.expected = l; p.found = h; p.location = b; p.name = "SyntaxError"; return p } function n(p, l, h) { h = h || " "; if (p.length > l) return p; l -= p.length; h += h.repeat(l); return p + h.slice(0, l) } (function (p, l) { function h() { this.constructor = p } h.prototype = l.prototype; p.prototype = new h })(y, Error); y.prototype.format = function (p) {
              var l = "Error: " + this.message; if (this.location) {
                var h = null,
                b; for (b = 0; b < p.length; b++)if (p[b].source === this.location.source) { h = p[b].text.split(/\r\n|\n|\r/g); break } p = this.location.start; b = this.location.source + ":" + p.line + ":" + p.column; if (h) { var d = this.location.end, f = n("", p.line.toString().length); h = h[p.line - 1]; d = p.line === d.line ? d.column : h.length + 1; l += "\n --\x3e " + b + "\n" + f + " |\n" + p.line + " | " + h + "\n" + f + " | " + n("", p.column - 1) + n("", d - p.column, "^") } else l += "\n at " + b
              } return l
            }; y.buildMessage = function (p, l) {
              function h(v) { return v.charCodeAt(0).toString(16).toUpperCase() }
              function b(v) { return v.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (m) { return "\\x0" + h(m) }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (m) { return "\\x" + h(m) }) } function d(v) {
                return v.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (m) {
                  return "\\x0" +
                    h(m)
                }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (m) { return "\\x" + h(m) })
              } function f(v) { return t[v.type](v) } var t = { literal: function (v) { return '"' + b(v.text) + '"' }, class: function (v) { var m = v.parts.map(function (e) { return Array.isArray(e) ? d(e[0]) + "-" + d(e[1]) : d(e) }); return "[" + (v.inverted ? "^" : "") + m + "]" }, any: function () { return "any character" }, end: function () { return "end of input" }, other: function (v) { return v.description } }; return "Expected " + function (v) {
                v = v.map(f); var m, e; v.sort(); if (0 < v.length) {
                  for (e = m = 1; m < v.length; m++)v[m -
                    1] !== v[m] && (v[e] = v[m], e++); v.length = e
                } switch (v.length) { case 1: return v[0]; case 2: return v[0] + " or " + v[1]; default: return v.slice(0, -1).join(", ") + ", or " + v[v.length - 1] }
              }(p) + " but " + (l ? '"' + b(l) + '"' : "end of input") + " found."
            }; return {
              SyntaxError: y, parse: function (p, l) {
                function h(ua, V) { return { type: "literal", text: ua, ignoreCase: V } } function b(ua, V, ja) { return { type: "class", parts: ua, inverted: V, ignoreCase: ja } } function d(ua) {
                  var V = xc[ua], ja; if (!V) {
                    for (ja = ua - 1; !xc[ja];)ja--; V = xc[ja]; for (V = { line: V.line, column: V.column }; ja <
                      ua;)10 === p.charCodeAt(ja) ? (V.line++ , V.column = 1) : V.column++ , ja++; xc[ua] = V
                  } return V
                } function f(ua, V) { var ja = d(ua), va = d(V); return { source: qa, start: { offset: ua, line: ja.line, column: ja.column }, end: { offset: V, line: va.line, column: va.column } } } function t(ua) { oa < Pb || (oa > Pb && (Pb = oa, lc = []), lc.push(ua)) } function v() { var ua = oa; Ba(); var V = e(); V !== ca ? (Ba(), ua = V) : (oa = ua, ua = ca); return ua } function m() {
                  var ua = oa; var V = e(); if (V !== ca) {
                    ua = []; var ja = oa; var va = Ba(); var Ga = Ia(); if (Ga !== ca) {
                      var Pa = Ba(); var Ta = e(); Ta !== ca ? ja = va =
                        [va, Ga, Pa, Ta] : (oa = ja, ja = ca)
                    } else oa = ja, ja = ca; for (; ja !== ca;)ua.push(ja), ja = oa, va = Ba(), Ga = Ia(), Ga !== ca ? (Pa = Ba(), Ta = e(), Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca)) : (oa = ja, ja = ca); ja = { type: "expr_list" }; V = [V]; for (va = 0; va < ua.length; va++)V.push(ua[va][3]); ja.value = V; ua = ja
                  } else oa = ua, ua = ca; return ua
                } function e() {
                  var ua = oa; var V = g(); if (V !== ca) {
                    ua = []; var ja = oa; var va = Ba(); var Ga = X(); if (Ga !== ca) { var Pa = Ba(); var Ta = g(); Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca) } else oa = ja, ja = ca; for (; ja !== ca;)ua.push(ja), ja = oa, va =
                      Ba(), Ga = X(), Ga !== ca ? (Pa = Ba(), Ta = g(), Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca)) : (oa = ja, ja = ca); ua = Ja(V, ua)
                  } else oa = ua, ua = ca; return ua
                } function g() { var ua = oa; var V = x(); if (V !== ca) { ua = []; var ja = oa; var va = Ba(); var Ga = U(); if (Ga !== ca) { var Pa = Ba(); var Ta = x(); Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca) } else oa = ja, ja = ca; for (; ja !== ca;)ua.push(ja), ja = oa, va = Ba(), Ga = U(), Ga !== ca ? (Pa = Ba(), Ta = x(), Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca)) : (oa = ja, ja = ca); ua = Ja(V, ua) } else oa = ua, ua = ca; return ua } function x() {
                  var ua = oa; var V =
                    W(); if (V === ca) { V = oa; if (33 === p.charCodeAt(oa)) { var ja = xa; oa++ } else ja = ca, 0 === Xa && t(rc); if (ja !== ca) { var va = oa; Xa++; if (61 === p.charCodeAt(oa)) { var Ga = Qa; oa++ } else Ga = ca, 0 === Xa && t(pd); Xa--; Ga === ca ? va = void 0 : (oa = va, va = ca); va !== ca ? V = ja = [ja, va] : (oa = V, V = ca) } else oa = V, V = ca } V !== ca ? (ja = Ba(), va = x(), va !== ca ? ua = { type: "unary_expr", operator: "NOT", expr: va } : (oa = ua, ua = ca)) : (oa = ua, ua = ca); if (ua === ca) {
                      V = oa; ua = z(); if (ua !== ca) {
                        Ba(); V = []; ja = oa; va = Ba(); Ga = k(); if (Ga !== ca) {
                          var Pa = Ba(); var Ta = z(); Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa =
                            ja, ja = ca)
                        } else oa = ja, ja = ca; if (ja !== ca) for (; ja !== ca;)V.push(ja), ja = oa, va = Ba(), Ga = k(), Ga !== ca ? (Pa = Ba(), Ta = z(), Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca)) : (oa = ja, ja = ca); else V = ca; V !== ca && (V = { type: "arithmetic", tail: V }); V === ca && (V = oa, ja = A(), ja !== ca ? (Ba(), va = Ha(), va !== ca ? (Ba(), va = m(), va !== ca ? (Ba(), Ga = Oa(), Ga !== ca ? V = { op: ja, right: va } : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca), V === ca && (V = oa, ja = A(), ja !== ca ? (Ba(), va = Ha(), va !== ca ? (Ba(), va = Oa(), va !== ca ? V = { op: ja, right: { type: "expr_list", value: [] } } : (oa = V,
                          V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca), V === ca && (V = oa, ja = A(), ja !== ca ? (Ba(), va = K(), va !== ca ? V = { op: ja, right: va } : (oa = V, V = ca)) : (oa = V, V = ca))), V === ca && (V = oa, Ga = W(), Ga !== ca ? (Ba(), ja = Z(), ja !== ca ? (Ba(), va = z(), va !== ca ? (Ba(), Pa = U(), Pa !== ca ? (Ba(), Ga = z(), Ga !== ca ? V = { op: "NOT" + ja, right: { type: "expr_list", value: [va, Ga] } } : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca), V === ca && (V = oa, Ga = Z(), Ga !== ca ? (Ba(), ja = z(), ja !== ca ? (Ba(), va = U(), va !== ca ? (Ba(), Pa = z(), Pa !== ca ? V = { op: Ga, right: { type: "expr_list", value: [ja, Pa] } } :
                            (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca)), V === ca && (V = oa, ja = ba(), ja !== ca ? (Ba(), va = W(), va !== ca ? (Ba(), va = z(), va !== ca ? V = { op: ja + "NOT", right: va } : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca), V === ca && (V = oa, ja = ba(), ja !== ca ? (Ba(), va = z(), va !== ca ? V = { op: ja, right: va } : (oa = V, V = ca)) : (oa = V, V = ca)), V === ca && (V = oa, ja = r(), ja !== ca ? (Ba(), va = O(), va !== ca ? (Ba(), Ga = oa, p.substr(oa, 6).toLowerCase() === gb ? (Pa = p.substr(oa, 6), oa += 6) : (Pa = ca, 0 === Xa && t(ce)), Pa !== ca ? (Pa = oa, Xa++ , Ta = M(), Xa-- , Ta === ca ? Pa = void 0 : (oa = Pa, Pa = ca), Pa !== ca ? Ga =
                              "ESCAPE" : (oa = Ga, Ga = ca)) : (oa = Ga, Ga = ca), Ga !== ca ? (Ba(), Ga = R(), Ga !== ca ? V = { op: ja, right: va, escape: Ga.value } : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca)) : (oa = V, V = ca), V === ca && (V = oa, ja = r(), ja !== ca ? (Ba(), va = O(), va !== ca ? V = { op: ja, right: va, escape: "" } : (oa = V, V = ca)) : (oa = V, V = ca)))))); V === ca && (V = null); "" == V || void 0 == V || null == V ? V = ua : (ja = null, V = ja = "arithmetic" == V.type ? Ja(ua, V.tail) : Ca(V.op, ua, V.right, V.escape))
                      } else oa = V, V = ca; ua = V
                    } return ua
                } function k() {
                  if (p.substr(oa, 2) === Wa) { var ua = Wa; oa += 2 } else ua = ca, 0 === Xa && t(sc); ua ===
                    ca && (62 === p.charCodeAt(oa) ? (ua = Ra, oa++) : (ua = ca, 0 === Xa && t(Ob)), ua === ca && (p.substr(oa, 2) === ta ? (ua = ta, oa += 2) : (ua = ca, 0 === Xa && t(Mc)), ua === ca && (p.substr(oa, 2) === Fa ? (ua = Fa, oa += 2) : (ua = ca, 0 === Xa && t(Eb)), ua === ca && (60 === p.charCodeAt(oa) ? (ua = Sa, oa++) : (ua = ca, 0 === Xa && t(ad)), ua === ca && (61 === p.charCodeAt(oa) ? (ua = Qa, oa++) : (ua = ca, 0 === Xa && t(pd)), ua === ca && (p.substr(oa, 2) === Va ? (ua = Va, oa += 2) : (ua = ca, 0 === Xa && t(qd)))))))); return ua
                } function r() {
                  var ua = ua = oa; var V = W(); if (V !== ca) {
                    var ja = Ba(); var va = aa(); va !== ca ? ua = V = [V, ja, va] :
                      (oa = ua, ua = ca)
                  } else oa = ua, ua = ca; ua !== ca && (ua = ua[0] + " " + ua[2]); ua === ca && (ua = aa()); return ua
                } function A() { var ua = ua = oa; var V = W(); if (V !== ca) { var ja = Ba(); var va = ea(); va !== ca ? ua = V = [V, ja, va] : (oa = ua, ua = ca) } else oa = ua, ua = ca; ua !== ca && (ua = ua[0] + " " + ua[2]); ua === ca && (ua = ea()); return ua } function z() {
                  var ua = oa; var V = C(); if (V !== ca) {
                    ua = []; var ja = oa; var va = Ba(); var Ga = B(); if (Ga !== ca) { var Pa = Ba(); var Ta = C(); Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca) } else oa = ja, ja = ca; for (; ja !== ca;)ua.push(ja), ja = oa, va = Ba(), Ga = B(), Ga !==
                      ca ? (Pa = Ba(), Ta = C(), Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca)) : (oa = ja, ja = ca); ua = Ja(V, ua)
                  } else oa = ua, ua = ca; return ua
                } function B() { if (43 === p.charCodeAt(oa)) { var ua = Ya; oa++ } else ua = ca, 0 === Xa && t(tc); ua === ca && (45 === p.charCodeAt(oa) ? (ua = bb, oa++) : (ua = ca, 0 === Xa && t(uc))); return ua } function C() {
                  var ua = oa; var V = E(); if (V !== ca) {
                    ua = []; var ja = oa; var va = Ba(); var Ga = D(); if (Ga !== ca) { var Pa = Ba(); var Ta = E(); Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca) } else oa = ja, ja = ca; for (; ja !== ca;)ua.push(ja), ja = oa, va = Ba(), Ga = D(), Ga !==
                      ca ? (Pa = Ba(), Ta = E(), Ta !== ca ? ja = va = [va, Ga, Pa, Ta] : (oa = ja, ja = ca)) : (oa = ja, ja = ca); ua = Ja(V, ua)
                  } else oa = ua, ua = ca; return ua
                } function D() { if (42 === p.charCodeAt(oa)) { var ua = hb; oa++ } else ua = ca, 0 === Xa && t(rd); ua === ca && (47 === p.charCodeAt(oa) ? (ua = ib, oa++) : (ua = ca, 0 === Xa && t(sd))); return ua } function E() {
                  var ua = R(); if (ua === ca) {
                    var V = oa; var ja = oa; var va = da(); if (va !== ca) { var Ga = Y(); if (Ga !== ca) { var Pa = fa(); Pa !== ca ? ja = parseFloat(va + Ga + Pa) : (oa = ja, ja = ca) } else oa = ja, ja = ca } else oa = ja, ja = ca; ja === ca && (ja = oa, va = da(), va !== ca ? (Ga =
                      Y(), Ga !== ca ? ja = parseFloat(va + Ga) : (oa = ja, ja = ca)) : (oa = ja, ja = ca), ja === ca && (ja = oa, va = da(), va !== ca ? (Ga = fa(), Ga !== ca ? ja = parseFloat(va + Ga) : (oa = ja, ja = ca)) : (oa = ja, ja = ca), ja === ca && (ja = oa, va = da(), va !== ca && (va = parseFloat(va)), ja = va))); var Ta = ja; if (Ta !== ca) { var $a = oa; Xa++; var ab = J(); Xa--; ab === ca ? $a = void 0 : (oa = $a, $a = ca); $a !== ca ? V = { type: "number", value: Ta } : (oa = V, V = ca) } else oa = V, V = ca; ua = V; if (ua === ca) {
                        var eb = oa; var nb = oa; if (p.substr(oa, 4).toLowerCase() === La) { var jb = p.substr(oa, 4); oa += 4 } else jb = ca, 0 === Xa && t(Oc); if (jb !==
                          ca) { var lb = oa; Xa++; var qb = M(); Xa--; qb === ca ? lb = void 0 : (oa = lb, lb = ca); lb !== ca ? nb = jb = [jb, lb] : (oa = nb, nb = ca) } else oa = nb, nb = ca; var Fb = nb; Fb !== ca && (Fb = { type: "bool", value: !0 }); eb = Fb; if (eb === ca) { eb = oa; var Lb = oa; if (p.substr(oa, 5).toLowerCase() === Ma) { var Sb = p.substr(oa, 5); oa += 5 } else Sb = ca, 0 === Xa && t($d); if (Sb !== ca) { var ec = oa; Xa++; var af = M(); Xa--; af === ca ? ec = void 0 : (oa = ec, ec = ca); ec !== ca ? Lb = Sb = [Sb, ec] : (oa = Lb, Lb = ca) } else oa = Lb, Lb = ca; Fb = Lb; Fb !== ca && (Fb = { type: "bool", value: !1 }); eb = Fb } ua = eb; if (ua === ca) {
                            var yc = oa; if (p.substr(oa,
                              4).toLowerCase() === db) { var Ad = p.substr(oa, 4); oa += 4 } else Ad = ca, 0 === Xa && t(xd); if (Ad !== ca) { var Qc = oa; Xa++; var bf = M(); Xa--; bf === ca ? Qc = void 0 : (oa = Qc, Qc = ca); Qc !== ca ? yc = Ad = [Ad, Qc] : (oa = yc, yc = ca) } else oa = yc, yc = ca; var xe = yc; xe !== ca && (xe = { type: "null", value: null }); ua = xe; if (ua === ca) {
                                var zc = oa; var Ac = oa; if (p.substr(oa, 4).toLowerCase() === xb) { var Je = p.substr(oa, 4); oa += 4 } else Je = ca, 0 === Xa && t(ne); if (Je !== ca) { var Bd = oa; Xa++; var cf = M(); Xa--; cf === ca ? Bd = void 0 : (oa = Bd, Bd = ca); Bd !== ca ? Ac = "DATE" : (oa = Ac, Ac = ca) } else oa = Ac, Ac =
                                  ca; if (Ac !== ca) { Ba(); var Ke = O(); Ke !== ca ? zc = { type: "date", value: Ke.value } : (oa = zc, zc = ca) } else oa = zc, zc = ca; ua = zc; if (ua === ca) {
                                    var Bc = oa; var Cc = oa; if (p.substr(oa, 9).toLowerCase() === oc) { var Le = p.substr(oa, 9); oa += 9 } else Le = ca, 0 === Xa && t(me); if (Le !== ca) { var Cd = oa; Xa++; var df = M(); Xa--; df === ca ? Cd = void 0 : (oa = Cd, Cd = ca); Cd !== ca ? Cc = "TIMESTAMP" : (oa = Cc, Cc = ca) } else oa = Cc, Cc = ca; if (Cc !== ca) { Ba(); var Me = O(); Me !== ca ? Bc = { type: "timestamp", value: Me.value } : (oa = Bc, Bc = ca) } else oa = Bc, Bc = ca; ua = Bc; if (ua === ca) {
                                      var Cb = oa; var ye = ma();
                                      if (ye !== ca) { Ba(); if (45 === p.charCodeAt(oa)) { var Wb = bb; oa++ } else Wb = ca, 0 === Xa && t(uc); Wb === ca && (43 === p.charCodeAt(oa) ? (Wb = Ya, oa++) : (Wb = ca, 0 === Xa && t(tc))); if (Wb !== ca) { Ba(); var Rc = O(); if (Rc !== ca) { Ba(); var Ne = L(); Ne !== ca ? Cb = { type: "interval", value: Rc, qualifier: Ne, op: Wb } : (oa = Cb, Cb = ca) } else oa = Cb, Cb = ca } else oa = Cb, Cb = ca } else oa = Cb, Cb = ca; Cb === ca && (Cb = oa, ye = ma(), ye !== ca ? (Ba(), Wb = O(), Wb !== ca ? (Ba(), Rc = L(), Rc !== ca ? Cb = { type: "interval", value: Wb, qualifier: Rc, op: "" } : (oa = Cb, Cb = ca)) : (oa = Cb, Cb = ca)) : (oa = Cb, Cb = ca)); ua = Cb
                                    }
                                  }
                              }
                          }
                      }
                  } var sb =
                    ua; if (sb === ca) {
                      var Ib = oa; var Dc = oa; if (p.substr(oa, 7).toLowerCase() === gc) { var Oe = p.substr(oa, 7); oa += 7 } else Oe = ca, 0 === Xa && t(je); if (Oe !== ca) { var Dd = oa; Xa++; var ef = M(); Xa--; ef === ca ? Dd = void 0 : (oa = Dd, Dd = ca); Dd !== ca ? Dc = "EXTRACT" : (oa = Dc, Dc = ca) } else oa = Dc, Dc = ca; if (Dc !== ca) {
                        Ba(); var ff = Ha(); if (ff !== ca) {
                          Ba(); var Qb = ra(); Qb === ca && (Qb = Aa(), Qb === ca && (Qb = za(), Qb === ca && (Qb = Ka(), Qb === ca && (Qb = Ea(), Qb === ca && (Qb = Ua()))))); var Pe = Qb; if (Pe !== ca) {
                            Ba(); var gf = ia(); if (gf !== ca) {
                              Ba(); var Qe = e(); if (Qe !== ca) {
                                Ba(); var hf = Oa();
                                hf !== ca ? Ib = { type: "function", name: "extract", args: { type: "expr_list", value: [{ type: "string", value: Pe }, Qe] } } : (oa = Ib, Ib = ca)
                              } else oa = Ib, Ib = ca
                            } else oa = Ib, Ib = ca
                          } else oa = Ib, Ib = ca
                        } else oa = Ib, Ib = ca
                      } else oa = Ib, Ib = ca; sb = Ib; if (sb === ca) {
                        var Jb = oa; var Ec = oa; if (p.substr(oa, 9).toLowerCase() === Vb) { var Re = p.substr(oa, 9); oa += 9 } else Re = ca, 0 === Xa && t(ie); if (Re !== ca) { var Ed = oa; Xa++; var jf = M(); Xa--; jf === ca ? Ed = void 0 : (oa = Ed, Ed = ca); Ed !== ca ? Ec = "SUBSTRING" : (oa = Ec, Ec = ca) } else oa = Ec, Ec = ca; if (Ec !== ca) {
                          Ba(); var kf = Ha(); if (kf !== ca) {
                            Ba();
                            var ze = e(); if (ze !== ca) {
                              Ba(); var lf = ia(); if (lf !== ca) {
                                Ba(); var Ae = e(); if (Ae !== ca) {
                                  Ba(); var Xb = oa; var Fc = oa; if (p.substr(oa, 3).toLowerCase() === ac) { var Se = p.substr(oa, 3); oa += 3 } else Se = ca, 0 === Xa && t(he); if (Se !== ca) { var Fd = oa; Xa++; var mf = M(); Xa--; mf === ca ? Fd = void 0 : (oa = Fd, Fd = ca); Fd !== ca ? Fc = "FOR" : (oa = Fc, Fc = ca) } else oa = Fc, Fc = ca; var Sc = Fc; if (Sc !== ca) { var nf = Ba(); var Te = e(); if (Te !== ca) { var of = Ba(); Xb = Sc = [Sc, nf, Te, of] } else oa = Xb, Xb = ca } else oa = Xb, Xb = ca; Xb === ca && (Xb = null); Sc = Oa(); Sc !== ca ? Jb = {
                                    type: "function", name: "substring",
                                    args: { type: "expr_list", value: Xb ? [ze, Ae, Xb[2]] : [ze, Ae] }
                                  } : (oa = Jb, Jb = ca)
                                } else oa = Jb, Jb = ca
                              } else oa = Jb, Jb = ca
                            } else oa = Jb, Jb = ca
                          } else oa = Jb, Jb = ca
                        } else oa = Jb, Jb = ca; sb = Jb; if (sb === ca) {
                          var ub = oa; var Be = la(); if (Be !== ca) {
                            Ba(); var Ce = Ha(); if (Ce !== ca) {
                              Ba(); var Yb = P(); Yb === ca && (Yb = null); Ba(); var Tc = e(); if (Tc !== ca) {
                                Ba(); var De = ia(); if (De !== ca) {
                                  Ba(); var Ue = e(); if (Ue !== ca) {
                                    Ba(); var pf = Oa(); pf !== ca ? ub = { type: "function", name: "trim", args: { type: "expr_list", value: [{ type: "string", value: null == Yb ? "BOTH" : Yb }, Tc, Ue] } } : (oa = ub, ub =
                                      ca)
                                  } else oa = ub, ub = ca
                                } else oa = ub, ub = ca
                              } else oa = ub, ub = ca
                            } else oa = ub, ub = ca
                          } else oa = ub, ub = ca; ub === ca && (ub = oa, Be = la(), Be !== ca ? (Ba(), Ce = Ha(), Ce !== ca ? (Ba(), Yb = P(), Yb === ca && (Yb = null), Ba(), Tc = e(), Tc !== ca ? (Ba(), De = Oa(), De !== ca ? ub = { type: "function", name: "trim", args: { type: "expr_list", value: [{ type: "string", value: null == Yb ? "BOTH" : Yb }, Tc] } } : (oa = ub, ub = ca)) : (oa = ub, ub = ca)) : (oa = ub, ub = ca)) : (oa = ub, ub = ca)); sb = ub; if (sb === ca) {
                            var Kb = oa; var Gc = oa; if (p.substr(oa, 8).toLowerCase() === Ab) { var Ve = p.substr(oa, 8); oa += 8 } else Ve = ca,
                              0 === Xa && t(le); if (Ve !== ca) { var Gd = oa; Xa++; var qf = M(); Xa--; qf === ca ? Gd = void 0 : (oa = Gd, Gd = ca); Gd !== ca ? Gc = "POSITION" : (oa = Gc, Gc = ca) } else oa = Gc, Gc = ca; if (Gc !== ca) { Ba(); var rf = Ha(); if (rf !== ca) { Ba(); var We = e(); if (We !== ca) { Ba(); var sf = ea(); if (sf !== ca) { Ba(); var Xe = e(); if (Xe !== ca) { Ba(); var tf = Oa(); tf !== ca ? Kb = { type: "function", name: "position", args: { type: "expr_list", value: [We, Xe] } } : (oa = Kb, Kb = ca) } else oa = Kb, Kb = ca } else oa = Kb, Kb = ca } else oa = Kb, Kb = ca } else oa = Kb, Kb = ca } else oa = Kb, Kb = ca; sb = Kb; if (sb === ca) {
                                var cc = oa; var Hd;
                                var Rb = oa; Rb = Hd = H(); if (Rb === ca) if (Rb = oa, 96 === p.charCodeAt(oa) ? (Hd = $c, oa++) : (Hd = ca, 0 === Xa && t(dd)), Hd !== ca) { var Id = []; if (od.test(p.charAt(oa))) { var Zb = p.charAt(oa); oa++ } else Zb = ca, 0 === Xa && t(ic); if (Zb !== ca) for (; Zb !== ca;)Id.push(Zb), od.test(p.charAt(oa)) ? (Zb = p.charAt(oa), oa++) : (Zb = ca, 0 === Xa && t(ic)); else Id = ca; Id !== ca ? (96 === p.charCodeAt(oa) ? (Zb = $c, oa++) : (Zb = ca, 0 === Xa && t(dd)), Zb !== ca ? Rb = Id.join("") : (oa = Rb, Rb = ca)) : (oa = Rb, Rb = ca) } else oa = Rb, Rb = ca; var Ye = Rb; if (Ye !== ca) {
                                  Ba(); var uf = Ha(); if (uf !== ca) {
                                    Ba(); var Jd =
                                      m(); Jd === ca && (Jd = null); Ba(); var vf = Oa(); vf !== ca ? cc = { type: "function", name: Ye, args: Jd ? Jd : { type: "expr_list", value: [] } } : (oa = cc, cc = ca)
                                  } else oa = cc, cc = ca
                                } else oa = cc, cc = ca; sb = cc; if (sb === ca) {
                                  var Tb; var Db = oa; var Ee = Na(); if (Ee !== ca) { Ba(); var Uc = e(); if (Uc !== ca) { Ba(); var Vc = []; for (Tb = Q(); Tb !== ca;)Vc.push(Tb), Tb = Q(); Tb = Ba(); var Kd = ya(); Kd !== ca ? Db = { type: "case_expression", format: "simple", operand: Uc, clauses: Vc, else: null } : (oa = Db, Db = ca) } else oa = Db, Db = ca } else oa = Db, Db = ca; if (Db === ca) if (Db = oa, Ee = Na(), Ee !== ca) if (Ba(),
                                    Uc = e(), Uc !== ca) { Ba(); Vc = []; for (Tb = Q(); Tb !== ca;)Vc.push(Tb), Tb = Q(); Tb = Ba(); Kd = T(); if (Kd !== ca) { Ba(); var wf = ya(); wf !== ca ? Db = { type: "case_expression", format: "simple", operand: Uc, clauses: Vc, else: Kd.value } : (oa = Db, Db = ca) } else oa = Db, Db = ca } else oa = Db, Db = ca; else oa = Db, Db = ca; var Fe = Db; if (Fe === ca) {
                                      var Ub; var Hb = oa; var Ge = Na(); if (Ge !== ca) { Ba(); var Wc = []; for (Ub = S(); Ub !== ca;)Wc.push(Ub), Ub = S(); Ub = Ba(); var Ld = ya(); Ld !== ca ? Hb = { type: "case_expression", format: "searched", clauses: Wc, else: null } : (oa = Hb, Hb = ca) } else oa = Hb, Hb =
                                        ca; if (Hb === ca) if (Hb = oa, Ge = Na(), Ge !== ca) { Ba(); Wc = []; for (Ub = S(); Ub !== ca;)Wc.push(Ub), Ub = S(); Ub = Ba(); Ld = T(); if (Ld !== ca) { Ba(); var xf = ya(); xf !== ca ? Hb = { type: "case_expression", format: "searched", clauses: Wc, else: Ld.value } : (oa = Hb, Hb = ca) } else oa = Hb, Hb = ca } else oa = Hb, Hb = ca; Fe = Hb
                                    } sb = Fe; if (sb === ca) {
                                      var Md; var Nd = oa; var Ze = J(); if (Ze !== ca) { var $e = []; for (Md = F(); Md !== ca;)$e.push(Md), Md = F(); Nd = Ze + $e.join("") } else oa = Nd, Nd = ca; var Od = Nd; if (Od !== ca) {
                                        var He = Od; Od = /^CURRENT_DATE$/i.test(He) ? { type: "current_time", mode: "date" } :
                                          /^CURRENT_TIMESTAMP$/i.test(He) ? { type: "current_time", mode: "timestamp" } : { type: "column_ref", table: "", column: He }
                                      } sb = Od; if (sb === ca && (sb = K(), sb === ca)) { sb = oa; var yf = Ha(); if (yf !== ca) { Ba(); var Ie = e(); if (Ie !== ca) { Ba(); var zf = Oa(); zf !== ca ? (Ie.paren = !0, sb = Ie) : (oa = sb, sb = ca) } else oa = sb, sb = ca } else oa = sb, sb = ca }
                                    }
                                }
                              }
                          }
                        }
                      }
                    } return sb
                } function H() { var ua; var V = oa; var ja = J(); if (ja !== ca) { V = []; for (ua = M(); ua !== ca;)V.push(ua), ua = M(); V = ja + V.join("") } else oa = V, V = ca; return V } function J() {
                  if (Td.test(p.charAt(oa))) {
                    var ua = p.charAt(oa);
                    oa++
                  } else ua = ca, 0 === Xa && t(td); return ua
                } function M() { if (Sd.test(p.charAt(oa))) { var ua = p.charAt(oa); oa++ } else ua = ca, 0 === Xa && t(zb); return ua } function F() { if (Yd.test(p.charAt(oa))) { var ua = p.charAt(oa); oa++ } else ua = ca, 0 === Xa && t(Hc); return ua } function K() { var ua = oa; if (64 === p.charCodeAt(oa)) { var V = mb; oa++ } else V = ca, 0 === Xa && t(Ic); if (V !== ca) { var ja = H(); ja !== ca ? ua = V = [V, ja] : (oa = ua, ua = ca) } else oa = ua, ua = ca; ua !== ca && (ua = { type: "param", value: ua[1] }); return ua } function P() {
                  var ua = oa; if (p.substr(oa, 7).toLowerCase() ===
                    Nb) { var V = p.substr(oa, 7); oa += 7 } else V = ca, 0 === Xa && t(oe); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "LEADING" : (oa = ua, ua = ca) } else oa = ua, ua = ca; ua === ca && (ua = oa, p.substr(oa, 8).toLowerCase() === pc ? (V = p.substr(oa, 8), oa += 8) : (V = ca, 0 === Xa && t(pe)), V !== ca ? (V = oa, Xa++ , ja = M(), Xa-- , ja === ca ? V = void 0 : (oa = V, V = ca), V !== ca ? ua = "TRAILING" : (oa = ua, ua = ca)) : (oa = ua, ua = ca), ua === ca && (ua = oa, p.substr(oa, 4).toLowerCase() === qc ? (V = p.substr(oa, 4), oa += 4) : (V = ca, 0 === Xa && t(qe)), V !== ca ? (V = oa, Xa++ , ja = M(), Xa-- ,
                      ja === ca ? V = void 0 : (oa = V, V = ca), V !== ca ? ua = "BOTH" : (oa = ua, ua = ca)) : (oa = ua, ua = ca))); return ua
                } function L() {
                  var ua = oa; var V = oa; var ja = N(); if (ja !== ca) { Ba(); var va = Ha(); if (va !== ca) if (Ba(), va = I(), va !== ca) { Ba(); var Ga = Oa(); Ga !== ca ? V = { type: "interval-period", period: ja.value, precision: va, secondary: null } : (oa = V, V = ca) } else oa = V, V = ca; else oa = V, V = ca } else oa = V, V = ca; V === ca && (V = oa, ja = N(), ja !== ca && (ja = kc(ja)), V = ja); if (V !== ca) if (Ba(), ja = oa, p.substr(oa, 2).toLowerCase() === ed ? (va = p.substr(oa, 2), oa += 2) : (va = ca, 0 === Xa && t(re)),
                    va !== ca ? (va = oa, Xa++ , Ga = M(), Xa-- , Ga === ca ? va = void 0 : (oa = va, va = ca), va !== ca ? ja = "TO" : (oa = ja, ja = ca)) : (oa = ja, ja = ca), ja !== ca) {
                      Ba(); ja = oa; va = N(); va !== ca && (va = { type: "interval-period", period: va.value, precision: null, secondary: null }); ja = va; if (ja === ca) {
                        ja = oa; va = Ua(); if (va !== ca) if (Ba(), va = Ha(), va !== ca) if (Ba(), va = I(), va !== ca) if (Ba(), Ga = Ia(), Ga !== ca) if (Ba(), Ga = G(), Ga !== ca) { Ba(); var Pa = Oa(); Pa !== ca ? ja = jc(va, Ga) : (oa = ja, ja = ca) } else oa = ja, ja = ca; else oa = ja, ja = ca; else oa = ja, ja = ca; else oa = ja, ja = ca; else oa = ja, ja = ca; ja ===
                          ca && (ja = oa, va = Ua(), va !== ca ? (Ba(), va = Ha(), va !== ca ? (Ba(), va = I(), va !== ca ? (Ba(), Ga = Oa(), Ga !== ca ? ja = { type: "interval-period", period: "second", precision: va, secondary: null } : (oa = ja, ja = ca)) : (oa = ja, ja = ca)) : (oa = ja, ja = ca)) : (oa = ja, ja = ca), ja === ca && (ja = oa, va = Ua(), va !== ca && (va = { type: "interval-period", period: "second", precision: null, secondary: null }), ja = va))
                      } ja !== ca ? ua = { type: "interval-qualifier", start: V, end: ja } : (oa = ua, ua = ca)
                  } else oa = ua, ua = ca; else oa = ua, ua = ca; ua === ca && (ua = oa, ja = N(), ja !== ca ? (Ba(), V = Ha(), V !== ca ? (Ba(), V =
                    G(), V !== ca ? (Ba(), va = Oa(), va !== ca ? ua = { type: "interval-period", period: ja.value, precision: V, secondary: null } : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca), ua === ca && (ua = oa, ja = N(), ja !== ca && (ja = kc(ja)), ua = ja, ua === ca && (ua = oa, ja = Ua(), ja !== ca ? (Ba(), V = Ha(), V !== ca ? (Ba(), V = I(), V !== ca ? (Ba(), va = Ia(), va !== ca ? (Ba(), ja = G(), ja !== ca ? (Ba(), va = Oa(), va !== ca ? ua = jc(V, ja) : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca), ua === ca && (ua = oa, ja = Ua(), ja !== ca ? (Ba(), V = Ha(), V !== ca ?
                      (Ba(), V = G(), V !== ca ? (Ba(), va = Oa(), va !== ca ? ua = { type: "interval-period", period: "second", precision: V, secondary: null } : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca)) : (oa = ua, ua = ca), ua === ca && (ua = oa, ja = Ua(), ja !== ca && (ja = { type: "interval-period", period: "second", precision: null, secondary: null }), ua = ja))))); return ua
                } function N() {
                  var ua = oa; ua = za(); ua !== ca && (ua = { type: "string", value: "day" }); ua === ca && (ua = oa, ua = Ka(), ua !== ca && (ua = { type: "string", value: "hour" }), ua === ca && (ua = oa, ua = Ea(), ua !== ca && (ua = { type: "string", value: "minute" }),
                    ua === ca && (ua = oa, ua = Aa(), ua !== ca && (ua = { type: "string", value: "month" }), ua === ca && (ua = oa, ua = ra(), ua !== ca && (ua = { type: "string", value: "year" }))))); return ua
                } function G() { var ua = ha(); ua !== ca && (ua = parseFloat(ua)); return ua } function I() { var ua = ha(); ua !== ca && (ua = parseFloat(ua)); return ua } function O() { var ua = R(); ua === ca && (ua = K()); return ua } function R() {
                  var ua = oa; if (39 === p.charCodeAt(oa)) { var V = tb; oa++ } else V = ca, 0 === Xa && t(hc); V === ca && (p.substr(oa, 2) === rb ? (V = rb, oa += 2) : (V = ca, 0 === Xa && t(vc))); if (V !== ca) {
                    V = []; var ja =
                      oa; p.substr(oa, 2) === ob ? (ja = ob, oa += 2) : (ja = ca, 0 === Xa && t(ud)); ja !== ca && (ja = "'"); ja === ca && (Gb.test(p.charAt(oa)) ? (ja = p.charAt(oa), oa++) : (ja = ca, 0 === Xa && t(vd))); for (; ja !== ca;)V.push(ja), ja = oa, p.substr(oa, 2) === ob ? (ja = ob, oa += 2) : (ja = ca, 0 === Xa && t(ud)), ja !== ca && (ja = "'"), ja === ca && (Gb.test(p.charAt(oa)) ? (ja = p.charAt(oa), oa++) : (ja = ca, 0 === Xa && t(vd))); 39 === p.charCodeAt(oa) ? (ja = tb, oa++) : (ja = ca, 0 === Xa && t(hc)); ja !== ca ? ua = { type: "string", value: V.join("") } : (oa = ua, ua = ca)
                  } else oa = ua, ua = ca; return ua
                } function S() {
                  var ua = oa;
                  if (pa() !== ca) { Ba(); var V = e(); if (V !== ca) { Ba(); var ja = wa(); ja !== ca ? (Ba(), ja = e(), ja !== ca ? ua = { type: "when_clause", operand: V, value: ja } : (oa = ua, ua = ca)) : (oa = ua, ua = ca) } else oa = ua, ua = ca } else oa = ua, ua = ca; return ua
                } function Q() { var ua = oa; if (pa() !== ca) { Ba(); var V = e(); if (V !== ca) { Ba(); var ja = wa(); ja !== ca ? (Ba(), ja = e(), ja !== ca ? ua = { type: "when_clause", operand: V, value: ja } : (oa = ua, ua = ca)) : (oa = ua, ua = ca) } else oa = ua, ua = ca } else oa = ua, ua = ca; return ua } function T() {
                  var ua = oa; var V = oa; if (p.substr(oa, 4).toLowerCase() === Zc) {
                    var ja =
                      p.substr(oa, 4); oa += 4
                  } else ja = ca, 0 === Xa && t(Jc); if (ja !== ca) { ja = oa; Xa++; var va = M(); Xa--; va === ca ? ja = void 0 : (oa = ja, ja = ca); ja !== ca ? V = "ELSE" : (oa = V, V = ca) } else oa = V, V = ca; V !== ca ? (Ba(), V = e(), V !== ca ? ua = { type: "else_clause", value: V } : (oa = ua, ua = ca)) : (oa = ua, ua = ca); return ua
                } function da() {
                  var ua = ha(); if (ua === ca) {
                    ua = oa; if (45 === p.charCodeAt(oa)) { var V = bb; oa++ } else V = ca, 0 === Xa && t(uc); V === ca && (43 === p.charCodeAt(oa) ? (V = Ya, oa++) : (V = ca, 0 === Xa && t(tc))); if (V !== ca) { var ja = ha(); ja !== ca ? ua = V[0] + ja : (oa = ua, ua = ca) } else oa = ua, ua =
                      ca
                  } return ua
                } function Y() { var ua = oa; if (46 === p.charCodeAt(oa)) { var V = wb; oa++ } else V = ca, 0 === Xa && t(Zd); V !== ca ? (ua = ha(), ua === ca && (ua = null), ua = "." + (null != ua ? ua : "")) : (oa = ua, ua = ca); return ua } function fa() { var ua; var V = ua = oa; if (dc.test(p.charAt(oa))) { var ja = p.charAt(oa); oa++ } else ja = ca, 0 === Xa && t(wd); ja !== ca ? (Lc.test(p.charAt(oa)) ? (V = p.charAt(oa), oa++) : (V = ca, 0 === Xa && t(Nc)), V === ca && (V = null), V = "e" + (null === V ? "" : V)) : (oa = V, V = ca); V !== ca ? (ja = ha(), ja !== ca ? ua = V + ja : (oa = ua, ua = ca)) : (oa = ua, ua = ca); return ua } function ha() {
                  var ua =
                    []; var V = ka(); if (V !== ca) for (; V !== ca;)ua.push(V), V = ka(); else ua = ca; ua !== ca && (ua = ua.join("")); return ua
                } function ka() { if (Mb.test(p.charAt(oa))) { var ua = p.charAt(oa); oa++ } else ua = ca, 0 === Xa && t(vb); return ua } function ea() { var ua = oa; if (p.substr(oa, 2).toLowerCase() === Za) { var V = p.substr(oa, 2); oa += 2 } else V = ca, 0 === Xa && t(ae); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "IN" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function ba() {
                  var ua = oa; if (p.substr(oa, 2).toLowerCase() === cb) {
                    var V =
                      p.substr(oa, 2); oa += 2
                  } else V = ca, 0 === Xa && t(yd); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "IS" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua
                } function aa() { var ua = oa; if (p.substr(oa, 4).toLowerCase() === fb) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(be); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "LIKE" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function W() {
                  var ua = oa; if (p.substr(oa, 3).toLowerCase() === kb) { var V = p.substr(oa, 3); oa += 3 } else V = ca,
                    0 === Xa && t(de); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "NOT" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua
                } function U() { var ua = oa; if (p.substr(oa, 3).toLowerCase() === Bb) { var V = p.substr(oa, 3); oa += 3 } else V = ca, 0 === Xa && t(Ud); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "AND" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function X() {
                  var ua = oa; if (p.substr(oa, 2).toLowerCase() === fc) { var V = p.substr(oa, 2); oa += 2 } else V = ca, 0 === Xa && t(ee); if (V !== ca) {
                    V = oa; Xa++;
                    var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "OR" : (oa = ua, ua = ca)
                  } else oa = ua, ua = ca; return ua
                } function Z() { var ua = oa; if (p.substr(oa, 7).toLowerCase() === mc) { var V = p.substr(oa, 7); oa += 7 } else V = ca, 0 === Xa && t(fe); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "BETWEEN" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function ia() {
                  var ua = oa; if (p.substr(oa, 4).toLowerCase() === $b) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(ge); if (V !== ca) {
                    V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 :
                      (oa = V, V = ca); V !== ca ? ua = "FROM" : (oa = ua, ua = ca)
                  } else oa = ua, ua = ca; return ua
                } function la() { var ua = oa; if (p.substr(oa, 4).toLowerCase() === nc) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(ke); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "TRIM" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function ma() {
                  var ua = oa; if (p.substr(oa, 8).toLowerCase() === fd) { var V = p.substr(oa, 8); oa += 8 } else V = ca, 0 === Xa && t(se); if (V !== ca) {
                    V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "INTERVAL" :
                      (oa = ua, ua = ca)
                  } else oa = ua, ua = ca; return ua
                } function ra() { var ua = oa; if (p.substr(oa, 4).toLowerCase() === gd) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(te); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "YEAR" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function Aa() {
                  var ua = oa; if (p.substr(oa, 5).toLowerCase() === Xd) { var V = p.substr(oa, 5); oa += 5 } else V = ca, 0 === Xa && t(ue); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "MONTH" : (oa = ua, ua = ca) } else oa = ua, ua =
                    ca; return ua
                } function za() { var ua = oa; if (p.substr(oa, 3).toLowerCase() === hd) { var V = p.substr(oa, 3); oa += 3 } else V = ca, 0 === Xa && t(zd); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "DAY" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function Ka() { var ua = oa; if (p.substr(oa, 4).toLowerCase() === id) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(ve); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "HOUR" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function Ea() {
                  var ua =
                    oa; if (p.substr(oa, 6).toLowerCase() === jd) { var V = p.substr(oa, 6); oa += 6 } else V = ca, 0 === Xa && t(we); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "MINUTE" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua
                } function Ua() { var ua = oa; if (p.substr(oa, 6).toLowerCase() === kd) { var V = p.substr(oa, 6); oa += 6 } else V = ca, 0 === Xa && t(bc); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "SECOND" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function Na() {
                  var ua = oa; if (p.substr(oa, 4).toLowerCase() ===
                    ld) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(Vd); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "CASE" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua
                } function ya() { var ua = oa; if (p.substr(oa, 3).toLowerCase() === Qd) { var V = p.substr(oa, 3); oa += 3 } else V = ca, 0 === Xa && t(pb); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "END" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function pa() {
                  var ua = oa; if (p.substr(oa, 4).toLowerCase() === Xc) {
                    var V = p.substr(oa, 4); oa +=
                      4
                  } else V = ca, 0 === Xa && t(yb); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "WHEN" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua
                } function wa() { var ua = oa; if (p.substr(oa, 4).toLowerCase() === Pd) { var V = p.substr(oa, 4); oa += 4 } else V = ca, 0 === Xa && t(wc); if (V !== ca) { V = oa; Xa++; var ja = M(); Xa--; ja === ca ? V = void 0 : (oa = V, V = ca); V !== ca ? ua = "THEN" : (oa = ua, ua = ca) } else oa = ua, ua = ca; return ua } function Ia() { if (44 === p.charCodeAt(oa)) { var ua = Yc; oa++ } else ua = ca, 0 === Xa && t(bd); return ua } function Ha() {
                  if (40 === p.charCodeAt(oa)) {
                    var ua =
                      Rd; oa++
                  } else ua = ca, 0 === Xa && t(Wd); return ua
                } function Oa() { if (41 === p.charCodeAt(oa)) { var ua = md; oa++ } else ua = ca, 0 === Xa && t(cd); return ua } function Ba() { var ua; var V = []; for (ua = sa(); ua !== ca;)V.push(ua), ua = sa(); return V } function sa() { if (nd.test(p.charAt(oa))) { var ua = p.charAt(oa); oa++ } else ua = ca, 0 === Xa && t(Kc); return ua } function Ca(ua, V, ja, va) { ua = { type: "binary_expr", operator: ua, left: V, right: ja }; void 0 !== va && (ua.escape = va); return ua } function Ja(ua, V) {
                  for (var ja = 0; ja < V.length; ja++)ua = Ca(V[ja][1], ua, V[ja][3]);
                  return ua
                } l = void 0 !== l ? l : {}; var ca = {}, qa = l.grammarSource, Da = { start: v }, na = v, xa = "!", Qa = "\x3d", Wa = "\x3e\x3d", Ra = "\x3e", ta = "\x3c\x3d", Fa = "\x3c\x3e", Sa = "\x3c", Va = "!\x3d", Ya = "+", bb = "-", hb = "*", ib = "/", mb = "@", tb = "'", rb = "N'", ob = "''", wb = ".", db = "null", La = "true", Ma = "false", Za = "in", cb = "is", fb = "like", gb = "escape", kb = "not", Bb = "and", fc = "or", mc = "between", $b = "from", ac = "for", Vb = "substring", gc = "extract", nc = "trim", Ab = "position", oc = "timestamp", xb = "date", Nb = "leading", pc = "trailing", qc = "both", ed = "to", fd = "interval", gd = "year",
                  Xd = "month", hd = "day", id = "hour", jd = "minute", kd = "second", ld = "case", Qd = "end", Xc = "when", Pd = "then", Zc = "else", Yc = ",", Rd = "(", md = ")", $c = "`", Td = /^[A-Za-z_\x80-\uFFFF]/, Sd = /^[A-Za-z0-9_]/, Yd = /^[A-Za-z0-9_.\x80-\uFFFF]/, Gb = /^[^']/, Mb = /^[0-9]/, dc = /^[eE]/, Lc = /^[+\-]/, nd = /^[ \t\n\r]/, od = /^[^`]/, rc = h("!", !1), pd = h("\x3d", !1), sc = h("\x3e\x3d", !1), Ob = h("\x3e", !1), Mc = h("\x3c\x3d", !1), Eb = h("\x3c\x3e", !1), ad = h("\x3c", !1), qd = h("!\x3d", !1), tc = h("+", !1), uc = h("-", !1), rd = h("*", !1), sd = h("/", !1), td = b([["A", "Z"], ["a", "z"], "_",
                  ["\u0080", "\uffff"]], !1, !1), zb = b([["A", "Z"], ["a", "z"], ["0", "9"], "_"], !1, !1), Hc = b([["A", "Z"], ["a", "z"], ["0", "9"], "_", ".", ["\u0080", "\uffff"]], !1, !1), Ic = h("@", !1), hc = h("'", !1), vc = h("N'", !1), ud = h("''", !1), vd = b(["'"], !0, !1), Zd = h(".", !1), vb = b([["0", "9"]], !1, !1), wd = b(["e", "E"], !1, !1), Nc = b(["+", "-"], !1, !1), xd = h("NULL", !0), Oc = h("TRUE", !0), $d = h("FALSE", !0), ae = h("IN", !0), yd = h("IS", !0), be = h("LIKE", !0), ce = h("ESCAPE", !0), de = h("NOT", !0), Ud = h("AND", !0), ee = h("OR", !0), fe = h("BETWEEN", !0), ge = h("FROM", !0), he = h("FOR",
                    !0), ie = h("SUBSTRING", !0), je = h("EXTRACT", !0), ke = h("TRIM", !0), le = h("POSITION", !0), me = h("TIMESTAMP", !0), ne = h("DATE", !0), oe = h("LEADING", !0), pe = h("TRAILING", !0), qe = h("BOTH", !0), re = h("TO", !0), se = h("INTERVAL", !0), te = h("YEAR", !0), ue = h("MONTH", !0), zd = h("DAY", !0), ve = h("HOUR", !0), we = h("MINUTE", !0), bc = h("SECOND", !0), Vd = h("CASE", !0), pb = h("END", !0), yb = h("WHEN", !0), wc = h("THEN", !0), Jc = h("ELSE", !0), bd = h(",", !1), Wd = h("(", !1), cd = h(")", !1), Kc = b([" ", "\t", "\n", "\r"], !1, !1), dd = h("`", !1), ic = b(["`"], !0, !1), kc = function (ua) {
                      return {
                        type: "interval-period",
                        period: ua.value, precision: null, secondary: null
                      }
                    }, jc = function (ua, V) { return { type: "interval-period", period: "second", precision: ua, secondary: V } }, oa = 0, xc = [{ line: 1, column: 1 }], Pb = 0, lc = [], Xa = 0; if ("startRule" in l) { if (!(l.startRule in Da)) throw Error("Can't start parsing from rule \"" + l.startRule + '".'); na = Da[l.startRule] } var Pc = na(); if (Pc !== ca && oa === p.length) return Pc; Pc !== ca && oa < p.length && t({ type: "end" }); throw function (ua, V, ja) { return new y(y.buildMessage(ua, V), ua, V, ja) }(lc, Pb < p.length ? p.charAt(Pb) : null, Pb <
                      p.length ? f(Pb, Pb + 1) : f(Pb, Pb));
              }
            }
          })
        })(c); let q = function () { function u() { } u.parse = function (y) { return c.exports.parse(y) }; return u }(); a.WhereGrammar = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/graphics/data/projectionSupport": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../geometry/projection ../../../geometry/geometryAdapters/json ../../../geometry/support/spatialReferenceUtils ../../../geometry/support/webMercatorUtils".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(m, e) {
            if (!e) return null; if ("x" in e) { var g = { x: 0, y: 0 };[g.x, g.y] = m(e.x, e.y, d); null != e.z && (g.z = e.z); null != e.m && (g.m = e.m); return g } if ("xmin" in e) return g = { xmin: 0, ymin: 0, xmax: 0, ymax: 0 }, [g.xmin, g.ymin] = m(e.xmin, e.ymin, d), [g.xmax, g.ymax] = m(e.xmax, e.ymax, d), e.hasZ && (g.zmin = e.zmin, g.zmax = e.zmax, g.hasZ = !0), e.hasM && (g.mmin = e.mmin, g.mmax = e.mmax, g.hasM = !0), g; if ("rings" in e) return { rings: l(e.rings, m), hasM: e.hasM, hasZ: e.hasZ }; if ("paths" in e) return { paths: l(e.paths, m), hasM: e.hasM, hasZ: e.hasZ };
            if ("points" in e) return { points: h(e.points, m), hasM: e.hasM, hasZ: e.hasZ }
          } function l(m, e) { const g = []; for (const x of m) g.push(h(x, e)); return g } function h(m, e) { const g = []; for (const x of m) m = e(x[0], x[1], [0, 0]), g.push(m), 2 < x.length && m.push(x[2]), 3 < x.length && m.push(x[3]); return g } function b() { b = w._asyncToGenerator(function* (m, e) { e && (m = Array.isArray(m) ? m.map(g => c.isSome(g.geometry) && g.geometry.spatialReference) : [m], yield q.initializeProjection(m.map(g => ({ source: g, dest: e })))) }); return b.apply(this, arguments) }
          const d = [0, 0], f = p.bind(null, n.lngLatToXY), t = p.bind(null, n.xyToLngLat), v = new (function () {
            function m() { this._jobs = []; this._timer = null; this._process = this._process.bind(this) } var e = m.prototype; e.push = function () {
              var g = w._asyncToGenerator(function* (x, k, r) { if (!(x && x.length && k && r) || y.equals(k, r)) return x; const A = { geometries: x, inSpatialReference: k, outSpatialReference: r, resolve: null }; this._jobs.push(A); return new Promise(z => { A.resolve = z; null === this._timer && (this._timer = setTimeout(this._process, 10)) }) }); return function (x,
                k, r) { return g.apply(this, arguments) }
            }(); e._process = function () { this._timer = null; const g = this._jobs.shift(); if (g) { var { geometries: x, inSpatialReference: k, outSpatialReference: r, resolve: A } = g; n.canProject(k, r) ? y.isWebMercator(r) ? A(x.map(f)) : A(x.map(t)) : A(q.projectMany(u.jsonAdapter, x, k, r, null)); 0 < this._jobs.length && (this._timer = setTimeout(this._process, 10)) } }; return m
          }()); a.checkProjectionSupport = function (m, e) { return b.apply(this, arguments) }; a.project = function (m, e, g) {
            if (!m) return m; g || (g = e, e = m.spatialReference);
            return y.isValid(e) && y.isValid(g) && !y.equals(e, g) ? n.canProject(e, g) ? y.isWebMercator(g) ? f(m) : t(m) : q.projectMany(u.jsonAdapter, [m], e, g, null)[0] : m
          }; a.projectMany = function (m, e, g) { return v.push(m, e, g) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/geometry/geometryAdapters/json": function () {
      define(["exports"], function (a) {
        let w = function (n, p, l) { this.x = n; this.y = p; this.spatialReference = l; this.m = this.z = void 0 }, c = function (n, p, l, h) {
        this.rings = n; this.spatialReference = p; this.hasM = this.hasZ = void 0; l &&
          (this.hasZ = l); h && (this.hasM = h)
        }, q = function (n, p, l, h) { this.paths = n; this.spatialReference = p; this.hasM = this.hasZ = void 0; l && (this.hasZ = l); h && (this.hasM = h) }, u = function (n, p, l, h) { this.points = n; this.spatialReference = p; this.hasM = this.hasZ = void 0; l && (this.hasZ = l); h && (this.hasM = h) }, y = function (n, p, l, h, b) { this.xmin = n; this.ymin = p; this.xmax = l; this.ymax = h; this.spatialReference = b; this.mmax = this.mmin = this.zmax = this.zmin = void 0 }; a.jsonAdapter = {
          convertToGEGeometry: function (n, p) { return null == p ? null : n.convertJSONToGeometry(p) },
          exportPoint: function (n, p, l) { l = new w(n.getPointX(p), n.getPointY(p), l); const h = n.hasZ(p), b = n.hasM(p); h && (l.z = n.getPointZ(p)); b && (l.m = n.getPointM(p)); return l }, exportPolygon: function (n, p, l) { return new c(n.exportPaths(p), l, n.hasZ(p), n.hasM(p)) }, exportPolyline: function (n, p, l) { return new q(n.exportPaths(p), l, n.hasZ(p), n.hasM(p)) }, exportMultipoint: function (n, p, l) { return new u(n.exportPoints(p), l, n.hasZ(p), n.hasM(p)) }, exportExtent: function (n, p, l) {
            var h = n.hasZ(p); const b = n.hasM(p); l = new y(n.getXMin(p), n.getYMin(p),
              n.getXMax(p), n.getYMax(p), l); h && (h = n.getZExtent(p), l.zmin = h.vmin, l.zmax = h.vmax); b && (n = n.getMExtent(p), l.mmin = n.vmin, l.mmax = n.vmax); return l
          }
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/graphics/data/QueryEngineResult": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../core/maybe ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../featureConversionUtils ./AttributesBuilder ./attributeSupport ./projectionSupport ./timeSupport ./utils ../../support/fieldUtils ../../../statistics/utils ../../../support/arcadeOnDemand".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(m, e, g, x, k, r) { k -= g; r -= x; m = Math.min(1, Math.max(0, ((m - g) * k + (e - x) * r) / (k * k + r * r))); return { x: g + k * m, y: x + r * m } } function v(m, e) { return m ? e ? 4 : 3 : e ? 3 : 2 } return function () {
            function m(g, x, k) {
            this.items = g; this.queryGeometry = x; this.definitionExpression = k.definitionExpression; this.geometryType = k.geometryType; this.hasM = k.hasM; this.hasZ = k.hasZ; this.objectIdField = k.objectIdField; this.spatialReference = k.spatialReference; this.fieldsIndex = k.fieldsIndex; this.timeInfo = k.timeInfo;
              this.featureAdapter = k.featureAdapter; this.aggregateAdapter = k.aggregateAdapter
            } var e = m.prototype; e.createQueryResponseForCount = function (g) {
              const x = new y(g, this.featureAdapter, this.fieldsIndex); if (!g.outStatistics) return x.countDistinctValues(this.items); const { groupByFieldsForStatistics: k, having: r } = g; if (null == k || !k.length) return 1; const A = new Map, z = new Map, B = new Set; g = g.outStatistics; for (const D of g) {
                ({ statisticType: g } = D); g = "exceedslimit" !== g ? D.onStatisticField : void 0; if (!z.has(g)) {
                  var C = []; for (const E of k) {
                    const H =
                      this._getAttributeValues(x, E, A); C.push(H)
                  } z.set(g, this._calculateUniqueValues(C, x.returnDistinctValues))
                } g = z.get(g); for (const E in g) { const { data: H, items: J } = g[E]; C = H.join(","); r && !x.validateItems(J, r) || B.add(C) }
              } return B.size
            }; e.createQueryResponse = function (g) {
              let x; x = g.outStatistics ? g.outStatistics.some(k => "exceedslimit" === k.statisticType) ? this._createExceedsLimitQueryResponse(g) : this._createStatisticsQueryResponse(g) : this._createFeatureQueryResponse(g); g.returnQueryGeometry && (q.isValid(g.outSR) &&
                !q.equals(this.queryGeometry.spatialReference, g.outSR) ? x.queryGeometry = h.cleanFromGeometryEngine({ spatialReference: g.outSR, ...p.project(this.queryGeometry, this.queryGeometry.spatialReference, g.outSR) }) : x.queryGeometry = h.cleanFromGeometryEngine({ spatialReference: g.outSR, ...this.queryGeometry })); return x
            }; e.createSnappingResponse = function (g, x) {
              const k = this.featureAdapter, r = v(this.hasZ, this.hasM), { x: A, y: z } = g.point, B = "number" === typeof g.distance ? g.distance : g.distance.x, C = "number" === typeof g.distance ?
                g.distance : g.distance.y, D = { candidates: [] }, E = "esriGeometryPolygon" === this.geometryType; x = this.getPointCreator(g.point, this.spatialReference, x); for (const N of this.items) {
                  var H = k.getGeometry(N); if (w.isNone(H)) continue; const { coords: G, lengths: I } = H; if (g.types & 1) {
                    H = 0; for (var J = 0; J < I.length; J++) {
                      var M = I[J]; for (var F = 0; F < M; F++ , H += r) {
                        var K = G[H], P = G[H + 1]; if (F !== M - 1) {
                          const O = G[H + r], R = G[H + r + 1], { x: S, y: Q } = t(A, z, K, P, O, R); var L = (A - S) / B; const T = (z - Q) / C; L = L * L + T * T; 1 >= L && D.candidates.push({
                            type: "edge", objectId: k.getObjectId(N),
                            distance: Math.sqrt(L), target: x(S, Q), start: x(K, P), end: x(O, R)
                          })
                        }
                      }
                    }
                  } if (g.types & 2) for (H = E ? G.length - r : G.length, J = 0; J < H; J += r)M = G[J], F = G[J + 1], K = (A - M) / B, P = (z - F) / C, K = K * K + P * P, 1 >= K && D.candidates.push({ type: "vertex", objectId: k.getObjectId(N), distance: Math.sqrt(K), target: x(M, F) })
                } D.candidates.sort((N, G) => N.distance - G.distance); return D
            }; e.getPointCreator = function (g, x, k) {
              const r = w.isSome(k) && !q.equals(x, k) ? A => p.project(A, x, k) : A => A; return null != g.z && null != g.m ? (A, z) => r({ x: A, y: z, z: g.z, m: g.m }) : null != g.z ? (A, z) => r({
                x: A,
                y: z, z: g.z
              }) : null != g.m ? (A, z) => r({ x: A, y: z, m: g.m }) : (A, z) => r({ x: A, y: z })
            }; e.executeAttributesQuery = function (g) { var x = n.getWhereClause(g.where, this.fieldsIndex); if (!x) return Promise.resolve(this); if (x.isStandardized) { let k = 0; const r = []; for (const A of this.items) x.testFeature(A, this.featureAdapter) && (r[k++] = A); x = new m(r, this.queryGeometry, this); x.definitionExpression = g.where; return Promise.resolve(x) } return Promise.reject(new TypeError("Where clause is not standardized")) }; e.executeAggregateIdsQuery = function (g) {
              if (!g.aggregateIds ||
                !g.aggregateIds.length || w.isNone(this.aggregateAdapter)) return Promise.resolve(this); const x = new Set; for (const r of g.aggregateIds) this.aggregateAdapter.getFeatureObjectIds(r).forEach(A => x.add(A)); const k = this.featureAdapter.getObjectId; return Promise.resolve(new m(this.items.filter(r => x.has(k(r))), this.queryGeometry, this))
            }; e.executeObjectIdsQuery = function (g) {
              if (!g.objectIds || !g.objectIds.length) return Promise.resolve(this); const x = new Set(g.objectIds), k = this.featureAdapter.getObjectId; return Promise.resolve(new m(this.items.filter(r =>
                x.has(k(r))), this.queryGeometry, this))
            }; e.executeTimeQuery = function (g) { g = l.getTimeOperator(this.timeInfo, g.timeExtent, this.featureAdapter); if (!w.isSome(g)) return Promise.resolve(this); g = this.items.filter(g); return Promise.resolve(new m(g, this.queryGeometry, this)) }; e.filterLatest = function () {
              const { trackIdField: g, startTimeField: x, endTimeField: k } = this.timeInfo; var r = k || x; const A = new Map, z = this.featureAdapter.getAttribute; for (const B of this.items) {
                const C = z(B, g), D = z(B, r), E = A.get(C); (!E || D > z(E, r)) && A.set(C,
                  B)
              } r = Array.from(A.values()); return Promise.resolve(new m(r, this.queryGeometry, this))
            }; e.project = function () {
              var g = a._asyncToGenerator(function* (x) {
                if (!x || q.equals(this.spatialReference, x)) return this; const k = this.featureAdapter, r = (yield p.projectMany(this.items.map(A => h.getGeometry(this.geometryType, this.hasZ, this.hasM, k.getGeometry(A))), this.spatialReference, x)).map((A, z) => k.cloneWithGeometry(this.items[z], u.convertFromGeometry(A, this.hasZ, this.hasM))); return new m(r, this.queryGeometry, {
                  definitionExpression: this.definitionExpression,
                  geometryType: this.geometryType, hasM: this.hasM, hasZ: this.hasZ, objectIdField: this.objectIdField, spatialReference: x, fieldsIndex: this.fieldsIndex, timeInfo: this.timeInfo, featureAdapter: this.featureAdapter
                })
              }); return function (x) { return g.apply(this, arguments) }
            }(); e.createSummaryStatisticsResponse = function () {
              var g = a._asyncToGenerator(function* (x, k) {
                const { field: r, valueExpression: A, normalizationField: z, normalizationType: B, normalizationTotal: C, minValue: D, maxValue: E, scale: H } = k; k = this.fieldsIndex.isDateField(r);
                x = yield this._getDataValues(x, { field: r, valueExpression: A, normalizationField: z, normalizationType: B, normalizationTotal: C, scale: H }); const J = d.isNullCountSupported({ normalizationType: B, normalizationField: z, minValue: D, maxValue: E }), M = this.fieldsIndex.get(r), F = { value: .5, fieldType: null == M ? void 0 : M.type }; x = b.isStringField(M) ? d.calculateStringStatistics({ values: x, supportsNullCount: J, percentileParams: F }) : d.calculateStatistics({ values: x, minValue: D, maxValue: E, useSampleStdDev: !B, supportsNullCount: J, percentileParams: F });
                return d.processSummaryStatisticsResult(x, k)
              }); return function (x, k) { return g.apply(this, arguments) }
            }(); e.createUniqueValuesResponse = function () { var g = a._asyncToGenerator(function* (x, k) { const { field: r, valueExpression: A, domain: z, returnAllCodedValues: B, scale: C } = k; x = yield this._getDataValues(x, { field: r, valueExpression: A, scale: C }); x = d.calculateUniqueValuesCount(x); return d.createUVResult(x, z, B) }); return function (x, k) { return g.apply(this, arguments) } }(); e.createClassBreaksResponse = function () {
              var g = a._asyncToGenerator(function* (x,
                k) {
                  const { field: r, valueExpression: A, normalizationField: z, normalizationType: B, normalizationTotal: C, classificationMethod: D, standardDeviationInterval: E, minValue: H, maxValue: J, numClasses: M, scale: F } = k; x = yield this._getDataValues(x, { field: r, valueExpression: A, normalizationField: z, normalizationType: B, normalizationTotal: C, scale: F }); x = d.calculateClassBreaks(x, { field: r, normalizationField: z, normalizationType: B, normalizationTotal: C, classificationMethod: D, standardDeviationInterval: E, minValue: H, maxValue: J, numClasses: M });
                return d.resolveCBResult(x, D)
              }); return function (x, k) { return g.apply(this, arguments) }
            }(); e.createHistogramResponse = function () {
              var g = a._asyncToGenerator(function* (x, k) {
                const { field: r, valueExpression: A, normalizationField: z, normalizationType: B, normalizationTotal: C, classificationMethod: D, standardDeviationInterval: E, minValue: H, maxValue: J, numBins: M, scale: F } = k; x = yield this._getDataValues(x, { field: r, valueExpression: A, normalizationField: z, normalizationType: B, normalizationTotal: C, scale: F }); return d.calculateHistogram(x,
                  { field: r, normalizationField: z, normalizationType: B, normalizationTotal: C, classificationMethod: D, standardDeviationInterval: E, minValue: H, maxValue: J, numBins: M })
              }); return function (x, k) { return g.apply(this, arguments) }
            }(); e._sortFeatures = function (g, x, k) { if (1 < g.length && x && x.length) for (const r of x.reverse()) { x = r.split(" "); const A = x[0], z = this.fieldsIndex.get(A); x = x[1] && "desc" === x[1].toLowerCase(); const B = d.getAttributeComparator(null == z ? void 0 : z.type, x); g.sort((C, D) => { C = k(C, A, z); D = k(D, A, z); return B(C, D) }) } };
            e._createFeatureQueryResponse = function (g) {
              const x = this.items, { geometryType: k, hasM: r, hasZ: A, objectIdField: z, spatialReference: B } = this, { outFields: C, outSR: D, quantizationParameters: E, resultRecordCount: H, resultOffset: J, returnZ: M, returnM: F } = g, K = null != H ? x.length > (J || 0) + H : !1, P = C && (C.includes("*") ? [...this.fieldsIndex.fields] : C.map(L => this.fieldsIndex.get(L))); return {
                exceededTransferLimit: K, features: this._createFeatures(g, x), fields: P, geometryType: k, hasM: r && F, hasZ: A && M, objectIdFieldName: z, spatialReference: h.cleanFromGeometryEngine(D ?
                  D : B), transform: E && c.toQuantizationTransform(E) || null
              }
            }; e._createFeatures = function (g, x) {
              const k = new y(g, this.featureAdapter, this.fieldsIndex), { hasM: r, hasZ: A } = this, { orderByFields: z, quantizationParameters: B, returnGeometry: C, returnCentroid: D, maxAllowableOffset: E, resultOffset: H, resultRecordCount: J, returnZ: M = !1, returnM: F = !1 } = g, K = A && M, P = r && F; g = []; var L = 0; x = [...x]; this._sortFeatures(x, z, (I, O, R) => k.getFieldValue(I, O, R)); if (C || D) {
                var N = c.toQuantizationTransform(B); if (C && !D) for (var G of x) g[L++] = {
                  attributes: k.getAttributes(G),
                  geometry: h.getGeometry(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(G), E, N, K, P)
                }; else if (!C && D) for (const I of x) g[L++] = { attributes: k.getAttributes(I), centroid: h.transformCentroid(this, this.featureAdapter.getCentroid(I, this), N) }; else for (const I of x) g[L++] = { attributes: k.getAttributes(I), centroid: h.transformCentroid(this, this.featureAdapter.getCentroid(I, this), N), geometry: h.getGeometry(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(I), E, N, K, P) }
              } else for (N of x) (G =
                k.getAttributes(N)) && (g[L++] = { attributes: G }); L = H || 0; null != J && (g = g.slice(L, Math.min(g.length, L + J))); return g
            }; e._createExceedsLimitQueryResponse = function (g) {
              var x = !1; let k = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY; x = Number.POSITIVE_INFINITY; for (const A of g.outStatistics) if ("exceedslimit" === A.statisticType) {
                k = null != A.maxPointCount ? A.maxPointCount : Number.POSITIVE_INFINITY; r = null != A.maxRecordCount ? A.maxRecordCount : Number.POSITIVE_INFINITY; x = null != A.maxVertexCount ? A.maxVertexCount : Number.POSITIVE_INFINITY;
                break
              } if ("esriGeometryPoint" === this.geometryType) x = this.items.length > k; else if (this.items.length > r) x = !0; else { g = this.hasZ ? this.hasM ? 4 : 3 : this.hasM ? 3 : 2; const A = this.featureAdapter; x = this.items.reduce((z, B) => { B = A.getGeometry(B); return z + (w.isSome(B) && B.coords.length || 0) }, 0) / g > x } return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(x) } }] }
            }; e._createStatisticsQueryResponse =
              function (g) {
                var x = { attributes: {} }; const k = [], r = new Map, A = new Map, z = new Map, B = new Map, C = new y(g, this.featureAdapter, this.fieldsIndex); var D = g.outStatistics; const { groupByFieldsForStatistics: E, having: H, orderByFields: J } = g; g = E && E.length; const M = !!g, F = M && E[0], K = M && !this.fieldsIndex.get(F); for (const I of D) {
                  const { outStatisticFieldName: O, statisticType: R } = I; D = I; var P = "exceedslimit" !== R ? I.onStatisticField : void 0; const S = "percentile_disc" === R || "percentile_cont" === R, Q = M && 1 === g && (P === F || K) && "count" === R; if (M) {
                    if (!z.has(P)) {
                      var L =
                        []; for (const T of E) { var N = this._getAttributeValues(C, T, r); L.push(N) } z.set(P, this._calculateUniqueValues(L, C.returnDistinctValues))
                    } L = z.get(P); for (const T in L) {
                      const { count: da, data: Y, items: fa, itemPositions: ha } = L[T]; N = Y.join(","); if (!H || C.validateItems(fa, H)) {
                        const ka = B.get(N) || { attributes: {} }; var G = null; if (Q) G = da; else { const ea = this._getAttributeValues(C, P, r); G = ha.map(ba => ea[ba]); G = S && "statisticParameters" in D ? this._getPercentileValue(D, G) : this._getStatisticValue(D, G, null, C.returnDistinctValues) } ka.attributes[O] =
                          G; E.forEach((ea, ba) => ka.attributes[this.fieldsIndex.get(ea) ? ea : `EXPR_${ba + 1}`] = Y[ba]); B.set(N, ka)
                      }
                    }
                  } else P = this._getAttributeValues(C, P, r), x.attributes[O] = S && "statisticParameters" in D ? this._getPercentileValue(D, P) : this._getStatisticValue(D, P, A, C.returnDistinctValues); k.push({ name: O, alias: O, type: "esriFieldTypeDouble" })
                } x = M ? Array.from(B.values()) : [x]; this._sortFeatures(x, J, (I, O) => I.attributes[O]); return { fields: k, features: x }
              }; e._getStatisticValue = function (g, x, k, r) {
                const { onStatisticField: A, statisticType: z } =
                  g; g = null; g = null != k && k.has(A) ? k.get(A) : b.isStringField(this.fieldsIndex.get(A)) ? d.calculateStringStatistics({ values: x, returnDistinct: r }) : d.calculateStatistics({ values: x, minValue: null, maxValue: null, useSampleStdDev: !0 }); k && k.set(A, g); return g["var" === z ? "variance" : z]
              }; e._getPercentileValue = function (g, x) {
                const { onStatisticField: k, statisticParameters: r, statisticType: A } = g, { value: z, orderBy: B } = r; g = this.fieldsIndex.get(k); return d.calculatePercentile(x, {
                  value: z, orderBy: B, fieldType: null == g ? void 0 : g.type, isDiscrete: "percentile_disc" ===
                    A
                })
              }; e._getAttributeValues = function (g, x, k) { if (k.has(x)) return k.get(x); const r = this.fieldsIndex.get(x), A = this.items.map(z => g.getFieldValue(z, x, r)); k.set(x, A); return A }; e._getAttributeNormalizedValues = function (g, x) { return this.items.map(k => g.getNormalizedValue(k, { field: x.field, fieldInfo: this.fieldsIndex.get(x.field), normalizationField: x.normalizationField, normalizationFieldInfo: this.fieldsIndex.get(x.normalizationField), normalizationType: x.normalizationType, normalizationTotal: x.normalizationTotal })) };
            e._getAttributeExpressionValues = function () { var g = a._asyncToGenerator(function* (x, k, r) { const { arcadeUtils: A } = yield f.loadArcade(), z = A.createFunction(k), B = r && A.getViewInfo(r); return this.items.map(C => x.getExpressionValue(C, { compiledFunc: z, viewInfo: B }, A)) }); return function (x, k, r) { return g.apply(this, arguments) } }(); e._calculateUniqueValues = function (g, x) {
              const k = {}, r = this.items, A = r.length; for (let z = 0; z < A; z++) {
                const B = r[z], C = []; for (const E of g) C.push(E[z]); const D = C.join(","); x ? null == k[D] && (k[D] = {
                  count: 1,
                  data: C, items: [B], itemPositions: [z]
                }) : null == k[D] ? k[D] = { count: 1, data: C, items: [B], itemPositions: [z] } : (k[D].count++ , k[D].items.push(B), k[D].itemPositions.push(z))
              } return k
            }; e._getDataValues = function () {
              var g = a._asyncToGenerator(function* (x, k) {
                const r = new y(x, this.featureAdapter, this.fieldsIndex), { valueExpression: A, field: z, normalizationField: B, normalizationType: C, normalizationTotal: D, scale: E } = k; x = A ? { viewingMode: "map", scale: E, spatialReference: x.outSR || this.spatialReference } : null; return A ? this._getAttributeExpressionValues(r,
                  A, x) : this._getAttributeNormalizedValues(r, { field: z, normalizationField: B, normalizationType: C, normalizationTotal: D })
              }); return function (x, k) { return g.apply(this, arguments) }
            }(); a._createClass(m, [{ key: "size", get: function () { return this.items.length } }]); return m
          }()
        })
    }, "esri/layers/graphics/data/AttributesBuilder": function () {
      define(["../../../core/maybe", "./attributeSupport", "../../../statistics/utils"], function (a, w, c) {
        return function () {
          function q(y, n, p) {
          this._fieldDataCache = new Map; this._returnDistinctMap =
            new Map; this.returnDistinctValues = y.returnDistinctValues; this.fieldsIndex = p; this.featureAdapter = n; if ((n = y.outFields) && -1 === n.indexOf("*")) { this.outFields = n; y = 0; for (const h of n) { var l = w.getExpressionFromFieldName(h); l = (n = this.fieldsIndex.get(l)) ? null : w.getWhereClause(l, p); n = n ? n.name : w.getAliasFromFieldName(h) || `FIELD_EXP_${y++}`; this._fieldDataCache.set(h, { alias: n, clause: l }) } }
          } var u = q.prototype; u.countDistinctValues = function (y) {
            if (!this.returnDistinctValues) return y.length; y.forEach(n => this.getAttributes(n));
            return this._returnDistinctMap.size
          }; u.getAttributes = function (y) { y = this._processAttributesForOutFields(y); return this._processAttributesForDistinctValues(y) }; u.getFieldValue = function (y, n, p) { const l = p ? p.name : n; let h = null; this._fieldDataCache.has(l) ? h = this._fieldDataCache.get(l).clause : p || (h = w.getWhereClause(n, this.fieldsIndex), this._fieldDataCache.set(l, { alias: l, clause: h })); return p ? this.featureAdapter.getAttribute(y, l) : h.calculateValue(y, this.featureAdapter) }; u.getNormalizedValue = function (y, n) {
            const p =
              n.normalizationType, l = n.normalizationTotal; let h = this.getFieldValue(y, n.field, n.fieldInfo); p && Number.isFinite(h) && (y = this.getFieldValue(y, n.normalizationField, n.normalizationFieldInfo), h = c.getNormalizedValue(h, p, y, l)); return h
          }; u.getExpressionValue = function (y, n, p) { y = { attributes: this.featureAdapter.getAttributes(y) }; y = p.createExecContext(y, n.viewInfo); return p.executeFunction(n.compiledFunc, y) }; u.validateItem = function (y, n) {
            this._fieldDataCache.has(n) || this._fieldDataCache.set(n, {
              alias: n, clause: w.getWhereClause(n,
                this.fieldsIndex)
            }); return this._fieldDataCache.get(n).clause.testFeature(y, this.featureAdapter)
          }; u.validateItems = function (y, n) { this._fieldDataCache.has(n) || this._fieldDataCache.set(n, { alias: n, clause: w.getWhereClause(n, this.fieldsIndex) }); return this._fieldDataCache.get(n).clause.testSet(y, this.featureAdapter) }; u._processAttributesForOutFields = function (y) {
            const n = this.outFields; if (!n || !n.length) return this.featureAdapter.getAttributes(y); const p = {}; for (const l of n) {
              const { alias: h, clause: b } = this._fieldDataCache.get(l);
              p[h] = b ? b.calculateValue(y, this.featureAdapter) : this.featureAdapter.getAttribute(y, h)
            } return p
          }; u._processAttributesForDistinctValues = function (y) { if (a.isNone(y) || !this.returnDistinctValues) return y; var n = this.outFields, p = []; if (n) for (const h of n) { var { alias: l } = this._fieldDataCache.get(h); p.push(y[l]) } else for (l in y) p.push(y[l]); n = `${(n || ["*"]).join(",")}=${p.join(",")}`; p = this._returnDistinctMap.get(n) || 0; this._returnDistinctMap.set(n, ++p); return 1 < p ? null : y }; return q
        }()
      })
    }, "esri/statistics/utils": function () {
      define(["exports",
        "../rest/support/ClassBreaksDefinition", "../rest/support/generateRendererUtils"], function (a, w, c) {
          function q(k) { const r = null != k.minValue || null != k.maxValue, A = !!k.sqlExpression && k.supportsSQLExpression; return !(null != k.normalizationField || null != k.normalizationType) && !r && !A } function u(k) {
            const { values: r, useSampleStdDev: A, supportsNullCount: z } = k; var B = Number.POSITIVE_INFINITY; let C = Number.NEGATIVE_INFINITY, D = null, E = null; var H = null; let J = null, M = 0; const F = null == k.minValue ? -Infinity : k.minValue, K = null == k.maxValue ?
              Infinity : k.maxValue; for (const P of r) Number.isFinite(P) ? P >= F && P <= K && (D += P, B = Math.min(B, P), C = Math.max(C, P), M++) : "string" === typeof P && M++; if (M && null != D) { E = D / M; H = 0; for (const P of r) Number.isFinite(P) && P >= F && P <= K && (H += (P - E) ** 2); J = A ? 1 < M ? H / (M - 1) : 0 : 0 < M ? H / M : 0; H = Math.sqrt(J) } else C = B = null; B = { avg: E, count: M, max: C, min: B, stddev: H, sum: D, variance: J }; z && (B.nullcount = r.length - M); k.percentileParams && (B.median = y(r, k.percentileParams)); return B
          } function y(k, r) {
            const { fieldType: A, value: z, orderBy: B, isDiscrete: C } = r, D = n(A,
              "desc" === B); k = [...k].filter(M => null != M).sort((M, F) => D(M, F)); if (0 === k.length) return null; if (0 >= z) return k[0]; if (1 <= z) return k[k.length - 1]; var E = (k.length - 1) * z, H = Math.floor(E); r = H + 1; E %= 1; H = k[H]; const J = k[r]; return r >= k.length || C || "string" === typeof H || "string" === typeof J ? H : H * (1 - E) + J * E
          } function n(k, r) {
            const A = r ? 1 : -1, z = l(r), B = p(r); if (!k || !["esriFieldTypeDate", "esriFieldTypeString", "esriFieldTypeGUID", "esriFieldTypeGlobalID", ...g].includes(k)) return (C, D) => "number" === typeof C && "number" === typeof D ? z(C, D) :
              "string" === typeof C && "string" === typeof D ? B(C, D) : A; if ("esriFieldTypeDate" === k) return (C, D) => { C = (new Date(C)).getTime(); D = (new Date(D)).getTime(); return isNaN(C) || isNaN(D) ? A : z(C, D) }; if (g.has(k)) return (C, D) => z(C, D); if ("esriFieldTypeString" === k) return (C, D) => B(C, D); if ("esriFieldTypeGUID" === k || "esriFieldTypeGlobalID" === k) { const C = p(r); return (D, E) => C(h(D), h(E)) } return r ? (C, D) => 1 : (C, D) => -1
          } function p(k) {
            return k ? (r, A) => { r = r.toUpperCase(); A = A.toUpperCase(); return r > A ? -1 : r < A ? 1 : 0 } : (r, A) => {
              r = r.toUpperCase(); A =
                A.toUpperCase(); return r < A ? -1 : r > A ? 1 : 0
            }
          } function l(k) { return k ? (r, A) => A - r : (r, A) => r - A } function h(k) { return k.substr(24, 12) + k.substr(19, 4) + k.substr(16, 2) + k.substr(14, 2) + k.substr(11, 2) + k.substr(9, 2) + k.substr(6, 2) + k.substr(4, 2) + k.substr(2, 2) + k.substr(0, 2) } function b(k, r) {
            const A = f({ field: r.field, normalizationType: r.normalizationType, normalizationField: r.normalizationField, classificationMethod: r.classificationMethod, standardDeviationInterval: r.standardDeviationInterval, breakCount: r.numClasses || 5 }); k = d(k,
              r.minValue, r.maxValue); return c.createGenerateRendererClassBreaks({ definition: A, values: k, normalizationTotal: r.normalizationTotal })
          } function d(k, r, A) { r = null == r ? -Infinity : r; A = null == A ? Infinity : A; return k.filter(z => Number.isFinite(z) && z >= r && z <= A) } function f(k) {
            const r = k.field, A = k.classificationMethod || "equal-interval", z = k.normalizationType, B = k.normalizationField, C = new w; C.classificationField = r; C.breakCount = k.breakCount; C.classificationMethod = A; C.standardDeviationInterval = "standard-deviation" === A ? k.standardDeviationInterval ||
              1 : void 0; C.normalizationType = z; C.normalizationField = "field" === z ? B : void 0; return C
          } function t(k, r) {
            const { field: A, classificationMethod: z, standardDeviationInterval: B, normalizationType: C, normalizationField: D, normalizationTotal: E, minValue: H, maxValue: J } = r, M = r.numBins || 10; let F = r = null, K = null; z && "equal-interval" !== z || C ? ({ classBreaks: k } = b(k, { field: A, normalizationType: C, normalizationField: D, normalizationTotal: E, classificationMethod: z, standardDeviationInterval: B, minValue: H, maxValue: J, numClasses: M }), r = k[0].minValue,
              F = k[k.length - 1].maxValue, K = k.map(P => [P.minValue, P.maxValue])) : (null != H && null != J ? (r = H, F = J) : (k = u({ values: k, minValue: H, maxValue: J, useSampleStdDev: !C, supportsNullCount: q({ normalizationType: C, normalizationField: D, minValue: H, maxValue: J }) }), r = k.min, F = k.max), K = m(r, F, M)); return { min: r, max: F, intervals: K }
          } function v(k, r) { let A = -1; for (let z = k.length - 1; 0 <= z; z--)if (r >= k[z][0]) { A = z; break } return A } function m(k, r, A) {
            const z = (r - k) / A, B = []; let C; for (let D = 1; D <= A; D++)C = k + z, C = Number(C.toFixed(16)), B.push([k, D === A ? r : C]),
              k = C; return B
          } const e = /\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi, g = new Set(["esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]), x = "min max avg stddev count sum variance nullcount median".split(" "); a.calculateClassBreaks = b; a.calculateHistogram = function (k, r) {
            const { min: A, max: z, intervals: B } = t(k, r), C = B.map((D, E) => ({ minValue: B[E][0], maxValue: B[E][1], count: 0 })); for (const D of k) null != D && D >= A && D <= z && (k = v(B, D), -1 < k && C[k].count++); return {
              bins: C, minValue: A, maxValue: z,
              normalizationTotal: r.normalizationTotal
            }
          }; a.calculatePercentile = y; a.calculateStatistics = u; a.calculateStringStatistics = function (k) { const r = k.returnDistinct ? [...new Set(k.values)] : k.values, A = r.filter(B => null != B).length, z = { count: A }; k.supportsNullCount && (z.nullcount = r.length - A); k.percentileParams && (z.median = y(r, k.percentileParams)); return z }; a.calculateUniqueValuesCount = function (k) { const r = {}; for (let A of k) { if (null == A || "string" === typeof A && "" === A.trim()) A = null; null == r[A] ? r[A] = { count: 1, data: A } : r[A].count++ } return { count: r } };
          a.createClassBreaksDefinition = f; a.createUVResult = function (k, r, A) { const z = k.count; k = []; A && r && "coded-value" === r.type && r.codedValues.forEach(B => { B = B.code; z.hasOwnProperty(B) || (z[B] = { data: B, count: 0 }) }); for (const B in z) r = z[B], k.push({ value: r.data, count: r.count, label: r.label }); return { uniqueValueInfos: k } }; a.getAttributeComparator = n; a.getEqualIntervalBins = m; a.getNormalizedValue = function (k, r, A, z) {
            let B = null; switch (r) {
              case "log": 0 !== k && (B = Math.log(k) * Math.LOG10E); break; case "percent-of-total": Number.isFinite(z) &&
                0 !== z && (B = k / z * 100); break; case "field": Number.isFinite(A) && 0 !== A && (B = k / A); break; case "natural-log": 0 < k && (B = Math.log(k)); break; case "square-root": 0 < k && (B = k ** .5)
            }return B
          }; a.isNullCountSupported = q; a.processSummaryStatisticsResult = function (k, r) { let A; for (A in k) -1 < x.indexOf(A) && (Number.isFinite(k[A]) || (k[A] = null)); if (!r) return k;["avg", "stddev", "variance"].forEach(z => { null != k[z] && (k[z] = Math.ceil(k[z])) }); return k }; a.resolveCBResult = function (k, r) {
            let A = k.classBreaks; const z = A[0].minValue, B = A[A.length -
              1].maxValue, C = "standard-deviation" === r; A = A.map(D => { const E = D.label; D = { minValue: D.minValue, maxValue: D.maxValue, label: E }; if (C && E) { const H = E.match(e).map(J => +J.trim()); 2 === H.length ? (D.minStdDev = H[0], D.maxStdDev = H[1], 0 > H[0] && 0 < H[1] && (D.hasAvg = !0)) : 1 === H.length && (E.includes("\x3c") ? (D.minStdDev = null, D.maxStdDev = H[0]) : E.includes("\x3e") && (D.minStdDev = H[0], D.maxStdDev = null)) } return D }); return { minValue: z, maxValue: B, classBreakInfos: A, normalizationTotal: k.normalizationTotal }
          }; a.statisticTypes = x; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/rest/support/ClassBreaksDefinition": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./ClassificationDefinition".split(" "), function (a, w, c, q, u, y, n, p, l) {
        u = new c.JSONMap({
          esriClassifyEqualInterval: "equal-interval", esriClassifyManual: "manual", esriClassifyNaturalBreaks: "natural-breaks",
          esriClassifyQuantile: "quantile", esriClassifyStandardDeviation: "standard-deviation", esriClassifyDefinedInterval: "defined-interval"
        }); c = new c.JSONMap({ esriNormalizeByLog: "log", esriNormalizeByPercentOfTotal: "percent-of-total", esriNormalizeByField: "field" }); l = function (h) {
          function b() { var d = h.apply(this, arguments) || this; d.breakCount = null; d.classificationField = null; d.classificationMethod = null; d.normalizationField = null; d.normalizationType = null; d.type = "class-breaks-definition"; return d } a._inheritsLoose(b,
            h); a._createClass(b, [{ key: "standardDeviationInterval", set: function (d) { "standard-deviation" === this.classificationMethod && this._set("standardDeviationInterval", d) } }, { key: "definedInterval", set: function (d) { "defined-interval" === this.classificationMethod && this._set("definedInterval", d) } }]); return b
        }(l); w.__decorate([q.property({ json: { write: !0 } })], l.prototype, "breakCount", void 0); w.__decorate([q.property({ json: { write: !0 } })], l.prototype, "classificationField", void 0); w.__decorate([q.property({
          type: String,
          json: { read: u.read, write: u.write }
        })], l.prototype, "classificationMethod", void 0); w.__decorate([q.property({ json: { write: !0 } })], l.prototype, "normalizationField", void 0); w.__decorate([q.property({ json: { read: c.read, write: c.write } })], l.prototype, "normalizationType", void 0); w.__decorate([q.property({ value: null, json: { write: !0 } })], l.prototype, "standardDeviationInterval", null); w.__decorate([q.property({ value: null, json: { write: !0 } })], l.prototype, "definedInterval", null); w.__decorate([q.property()], l.prototype,
          "type", void 0); return l = w.__decorate([p.subclass("esri.rest.support.ClassBreaksDefinition")], l)
      })
    }, "esri/rest/support/ClassificationDefinition": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./colorRamps ../../symbols/Symbol".split(" "), function (a, w, c, q, u,
        y, n, p, l, h, b) {
          c = new c.JSONMap({ classBreaksDef: "class-breaks-definition", uniqueValueDef: "unique-value-definition" }); q = function (d) { function f() { var t = d.apply(this, arguments) || this; t.baseSymbol = null; t.colorRamp = null; t.type = null; return t } a._inheritsLoose(f, d); return f }(q.JSONSupport); w.__decorate([u.property({ type: b, json: { write: !0 } })], q.prototype, "baseSymbol", void 0); w.__decorate([u.property({ types: h.types, json: { read: { reader: h.fromJSON }, write: !0 } })], q.prototype, "colorRamp", void 0); w.__decorate([u.property({
            json: {
              read: c.read,
              write: c.write
            }
          })], q.prototype, "type", void 0); return q = w.__decorate([l.subclass("esri.rest.support.ClassificationDefinition")], q)
      })
    }, "esri/rest/support/generateRendererUtils": function () {
      define(["exports"], function (a) {
        function w(b) {
          const { classificationMethod: d, breakCount: f, normalizationType: t, definedInterval: v } = b.definition, m = []; var e = b.values; if (0 === e.length) return []; e = e.sort((z, B) => z - B); var g = e[0], x = e[e.length - 1]; if ("equal-interval" === d) if (e.length >= f) {
            e = (x - g) / f; b = g; for (var k = 1; k < f; k++) {
              var r = Number((g +
                k * e).toFixed(6)); m.push({ minValue: b, maxValue: r, label: c(b, r, t) }); b = r
            } m.push({ minValue: b, maxValue: x, label: c(b, x, t) })
          } else e.forEach(z => { m.push({ minValue: z, maxValue: z, label: c(z, z, t) }) }); else if ("natural-breaks" === d) { e = q(e); b = u(e.uniqueValues, b.valueFrequency || e.valueFrequency, f); for (k = 1; k < f; k++)e.uniqueValues.length > k && (r = Number(e.uniqueValues[b[k]].toFixed(6)), m.push({ minValue: g, maxValue: r, label: c(g, r, t) }), g = r); m.push({ minValue: g, maxValue: x, label: c(g, x, t) }) } else if ("quantile" === d) if (e.length >= f && g !==
            x) { b = Math.ceil(e.length / f); k = 0; for (r = 1; r < f; r++) { var A = b + k - 1; A > e.length && (A = e.length - 1); 0 > A && (A = 0); m.push({ minValue: g, maxValue: e[A], label: c(g, e[A], t) }); g = e[A]; k += b; b = Math.ceil((e.length - k) / (f - r)) } m.push({ minValue: g, maxValue: x, label: c(g, x, t) }) } else for (x = -1, g = 0; g < e.length; g++)b = e[g], b !== x && (x = b, m.push({ minValue: x, maxValue: b, label: c(x, b, t) }), x = b); else if ("standard-deviation" === d) if (b = p(e), k = l(e, b), 0 === k) m.push({ minValue: e[0], maxValue: e[0], label: c(e[0], e[0], t) }); else {
              e = n(g, x, f, b, k) * k; k = 0; for (r = f; 1 <= r; r--)A =
                Number((b - (r - .5) * e).toFixed(6)), m.push({ minValue: g, maxValue: A, label: c(g, A, t) }), g = A, k++; r = Number((b + .5 * e).toFixed(6)); m.push({ minValue: g, maxValue: r, label: c(g, r, t) }); g = r; k++; for (A = 1; A <= f; A++)r = k === 2 * f ? x : Number((b + (A + .5) * e).toFixed(6)), m.push({ minValue: g, maxValue: r, label: c(g, r, t) }), g = r, k++
            } else if ("defined-interval" === d) {
              if (!v) return m; x = e[0]; e = e[e.length - 1]; g = Math.ceil((e - x) / v); b = x; for (k = 1; k < g; k++)r = Number((x + k * v).toFixed(6)), m.push({ minValue: b, maxValue: r, label: c(b, r, t) }), b = r; m.push({
                minValue: b, maxValue: e,
                label: c(b, e, t)
              })
            } return m
        } function c(b, d, f) { let t = null; return t = b === d ? f && "percent-of-total" === f ? b + "%" : b.toString() : f && "percent-of-total" === f ? b + "% - " + d + "%" : b + " - " + d } function q(b) { const d = [], f = []; let t = Number.MIN_VALUE, v = 1, m = -1; for (let e = 0; e < b.length; e++) { const g = b[e]; g === t ? (v++ , f[m] = v) : null !== g && (d.push(g), t = g, v = 1, f.push(v), m++) } return { uniqueValues: d, valueFrequency: f } } function u(b, d, f) {
          var t = b.length; const v = []; f > t && (f = t); for (var m = 0; m < f; m++)v.push(Math.round(m * t / f - 1)); v.push(t - 1); m = y(v, b, d, f); {
            t =
            m.mean; m = m.sdcm; var e = f, g = 0, x = 0; let r = 0, A = 0, z = !0; for (let B = 0; 2 > B && z; B++) { 0 === B && (z = !1); for (var k = 0; k < e - 1; k++)for (; v[k + 1] + 1 !== v[k + 2];)if (v[k + 1] += 1, g = h(k, v, b, d), r = g.sbMean, g = g.sbSdcm, x = h(k + 1, v, b, d), A = x.sbMean, x = x.sbSdcm, g + x < m[k] + m[k + 1]) m[k] = g, m[k + 1] = x, t[k] = r, t[k + 1] = A, z = !0; else { --v[k + 1]; break } for (k = e - 1; 0 < k; k--)for (; v[k] !== v[k - 1] + 1;)if (--v[k], g = h(k - 1, v, b, d), r = g.sbMean, g = g.sbSdcm, x = h(k, v, b, d), A = x.sbMean, x = x.sbSdcm, g + x < m[k - 1] + m[k]) m[k - 1] = g, m[k] = x, t[k - 1] = r, t[k] = A, z = !0; else { v[k] += 1; break } } t = z
          } t && (m = y(v, b,
            d, f)); return v
        } function y(b, d, f, t) {
          let v = []; var m = [], e = []; let g = 0; const x = [], k = []; for (var r = 0; r < t; r++) { var A = h(r, b, d, f); x.push(A.sbMean); k.push(A.sbSdcm); g += k[r] } A = g; for (r = !0; r || g < A;) {
            r = !1; v = []; for (m = 0; m < t; m++)v.push(b[m]); for (e = 0; e < t; e++)for (A = b[e] + 1; A <= b[e + 1]; A++)if (m = d[A], 0 < e && A !== b[e + 1] && Math.abs(m - x[e]) > Math.abs(m - x[e - 1])) b[e] = A; else if (e < t - 1 && b[e] !== A - 1 && Math.abs(m - x[e]) > Math.abs(m - x[e + 1])) { b[e + 1] = A - 1; break } A = g; g = 0; m = []; e = []; for (let z = 0; z < t; z++) {
              m.push(x[z]); e.push(k[z]); const B = h(z, b, d, f);
              x[z] = B.sbMean; k[z] = B.sbSdcm; g += k[z]
            }
          } if (g > A) { for (d = 0; d < t; d++)b[d] = v[d], x[d] = m[d], k[d] = e[d]; g = A } return { mean: x, sdcm: k }
        } function n(b, d, f, t, v) { b = Math.max(t - b, d - t) / v / f; return 1 <= b ? 1 : .5 <= b ? .5 : .25 } function p(b) { let d = 0; for (let f = 0; f < b.length; f++)d += b[f]; return d /= b.length } function l(b, d) { let f = 0; for (let t = 0; t < b.length; t++) { const v = b[t]; f += (v - d) * (v - d) } f /= b.length; return Math.sqrt(f) } function h(b, d, f, t) {
          var v = 0, m = 0; for (var e = d[b] + 1; e <= d[b + 1]; e++) { const g = t[e]; v += f[e] * g; m += g } 0 >= m && console.log("Exception in Natural Breaks calculation");
          v /= m; m = 0; for (e = d[b] + 1; e <= d[b + 1]; e++)m += t[e] * (f[e] - v) ** 2; return { sbMean: v, sbSdcm: m }
        } a.createGenerateRendererClassBreaks = function (b) { const { normalizationTotal: d } = b; return { classBreaks: w(b), normalizationTotal: d } }; a.createGenerateRendererUniqueValues = function (b) { b = q(b); const d = [], f = b.uniqueValues.length; for (let t = 0; t < f; t++) { const v = b.uniqueValues[t]; d.push({ value: v, count: b.valueFrequency[t], label: v.toString() }) } return { uniqueValues: d } }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/graphics/data/timeSupport": function () {
      define(["exports"],
        function (a) {
          function w(u, y, n, p, l) { if (null != p && null != l) return h => { const b = u.getAttribute(h, y); h = u.getAttribute(h, n); return (null == b || b <= l) && (null == h || h >= p) }; if (null != p) return h => { h = u.getAttribute(h, n); return null == h || h >= p }; if (null != l) return h => { h = u.getAttribute(h, y); return null == h || h <= l } } function c(u, y, n, p) {
            if (null != n && null != p && n === p) return l => u.getAttribute(l, y) === n; if (null != n && null != p) return l => { l = u.getAttribute(l, y); return l >= n && l <= p }; if (null != n) return l => u.getAttribute(l, y) >= n; if (null != p) return l =>
              u.getAttribute(l, y) <= p
          } function q() { return () => !1 } a.getTimeExtent = function (u, y) { if (!u) return null; const n = y.featureAdapter, { startTimeField: p, endTimeField: l } = u; let h = Number.POSITIVE_INFINITY, b = Number.NEGATIVE_INFINITY; if (p && l) y.forEach(d => { const f = n.getAttribute(d, p); d = n.getAttribute(d, l); null == f || isNaN(f) || (h = Math.min(h, f)); null == d || isNaN(d) || (b = Math.max(b, d)) }); else { const d = p || l; y.forEach(f => { f = n.getAttribute(f, d); null == f || isNaN(f) || (h = Math.min(h, f), b = Math.max(b, f)) }) } return { start: h, end: b } }; a.getTimeOperator =
            function (u, y, n) { if (!y || !u) return null; const { startTimeField: p, endTimeField: l } = u; if (!p && !l) return null; const { start: h, end: b } = y; return null === h && null === b ? null : void 0 === h && void 0 === b ? q() : p && l ? w(n, p, l, h, b) : c(n, p || l, h, b) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/data/utils": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/jsonMap ../../../core/maybe ../../../core/unitUtils ../../../geometry/support/extentUtils ../../../geometry/support/jsonUtils ../../../geometry/support/normalizeUtils ../../../geometry/support/spatialReferenceUtils ../centroid ../featureConversionUtils ../OptimizedGeometry ./projectionSupport".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          function v(F, K, P, L = F.hasZ, N = F.hasM) { if (u.isNone(K)) return null; const G = F.hasZ && L, I = F.hasM && N; return P ? (F = d.quantizeOptimizedGeometry(H, K, F.hasZ, F.hasM, "esriGeometryPoint", P, L, N), d.convertToPoint(F, G, I)) : d.convertToPoint(K, G, I) } function m() {
            m = c._asyncToGenerator(function* (F, K, P) {
              const { outFields: L, orderByFields: N, groupByFieldsForStatistics: G, outStatistics: I } = F; if (L) for (var O = 0; O < L.length; O++)L[O] = L[O].trim(); if (N) for (O = 0; O < N.length; O++)N[O] = N[O].trim(); if (G) for (O =
                0; O < G.length; O++)G[O] = G[O].trim(); if (I) for (O = 0; O < I.length; O++)I[O].onStatisticField && (I[O].onStatisticField = I[O].onStatisticField.trim()); F.geometry && !F.outSR && (F.outSR = F.geometry.spatialReference); return g(F, K, P)
            }); return m.apply(this, arguments)
          } function e() { e = c._asyncToGenerator(function* (F, K, P) { return g(F, K, P) }); return e.apply(this, arguments) } function g(F, K, P) { return x.apply(this, arguments) } function x() {
            x = c._asyncToGenerator(function* (F, K, P) {
              if (!F) return null; var { where: L } = F; F.where = L = L && L.trim();
              if (!L || /^1 *= *1$/.test(L) || K && K === L) F.where = null; if (!F.geometry) return F; K = yield k(F); F.distance = 0; F.units = null; "esriSpatialRelEnvelopeIntersects" === F.spatialRel && ({ spatialReference: L } = F.geometry, K = n.getGeometryExtent(K), K.spatialReference = L); F.geometry = K; yield t.checkProjectionSupport(K.spatialReference, P); K = (yield l.normalizeCentralMeridian(p.fromJSON(K)))[0]; if (u.isNone(K)) throw C; K = K.toJSON(); K = yield t.project(K, K.spatialReference, P); if (!K) throw C; K.spatialReference = P; F.geometry = K; return F
            });
            return x.apply(this, arguments)
          } function k(F) { return r.apply(this, arguments) } function r() { r = c._asyncToGenerator(function* (F) { const { geometry: K, distance: P, units: L } = F; if (null == P || "vertexAttributes" in K) return K; var N = K.spatialReference; F = L ? B.fromJSON(L) : y.getUnitString(N); N = N && (h.isGeographic(N) || h.isWebMercator(N)) ? K : yield t.checkProjectionSupport(N, h.WGS84).then(() => t.project(K, h.WGS84)); return (yield A())(N.spatialReference, N, P, F) }); return r.apply(this, arguments) } function A() { return z.apply(this, arguments) }
          function z() { z = c._asyncToGenerator(function* () { return (yield new Promise((F, K) => a(["../../../geometry/geometryEngineJSON"], F, K))).geodesicBuffer }); return z.apply(this, arguments) } const B = new q.JSONMap({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" }), C = Object.freeze({}), D = new f, E = new f, H = new f, J = {
            esriGeometryPoint: d.convertToPoint, esriGeometryPolyline: d.convertToPolyline,
            esriGeometryPolygon: d.convertToPolygon, esriGeometryMultipoint: d.convertToMultipoint
          }, M = (F, K) => "_geVersion" !== F ? K : void 0; w.QUERY_ENGINE_EMPTY_RESULT = C; w.cleanFromGeometryEngine = function (F) { return F && "_geVersion" in F ? JSON.parse(JSON.stringify(F, M)) : F }; w.getCentroid = function (F, K, P) { if ("esriGeometryPolygon" !== F.geometryType || !K || !K.centroid && !K.geometry) return null; K.centroid || (K.centroid = b.getCentroidOptimizedGeometry(new f, K.geometry, F.hasZ, F.hasM)); return v(F, K.centroid, P) }; w.getGeometry = function (F,
            K, P, L, N, G, I = K, O = P) { const R = K && I, S = P && O; L = u.isSome(L) ? "coords" in L ? L : L.geometry : null; if (u.isNone(L)) return null; if (N) return K = d.generalizeOptimizedGeometry(E, L, K, P, F, N, I, O), G && (K = d.quantizeOptimizedGeometry(H, K, R, S, F, G)), J[F](K, R, S); if (G) return G = d.quantizeOptimizedGeometry(H, L, K, P, F, G, I, O), J[F](G, R, S); d.removeZMValues(D, L, K, P, I, O); return J[F](D, R, S) }; w.normalizeFilter = function (F, K, P) { return e.apply(this, arguments) }; w.normalizeQuery = function (F, K, P) { return m.apply(this, arguments) }; w.normalizeQueryLike =
              g; w.transformCentroid = v; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/data/spatialQuerySupport": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Error ../../../geometry/support/contains ../../../geometry/support/intersects ../../../geometry/support/jsonUtils ../../../geometry/support/spatialReferenceUtils ../contains ../featureConversionUtils ../OptimizedGeometry ./projectionSupport ./utils".split(" "), function (a, w, c, q, u, y, n, p,
        l, h, b, d, f) {
          function t() { return new Promise((g, x) => a(["../../../geometry/geometryEngineJSON"], g, x)) } function v() {
            v = c._asyncToGenerator(function* (g, x, k) {
              const { spatialRel: r, geometry: A } = g; if (A) {
                if (!0 !== e.spatialRelationship[r]) throw new q("feature-store:unsupported-query", "Unsupported query spatial relationship", { query: g }); if (p.isValid(A.spatialReference) && p.isValid(k)) {
                  if (!0 !== e.queryGeometry[n.getJsonType(A)]) throw new q("feature-store:unsupported-query", "Unsupported query geometry type", { query: g });
                  if (!0 !== e.layerGeometry[x]) throw new q("feature-store:unsupported-query", "Unsupported layer geometry type", { query: g }); if (g.outSR) return d.checkProjectionSupport(g.geometry && g.geometry.spatialReference, g.outSR)
                }
              }
            }); return v.apply(this, arguments)
          } const m = {
            esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "intersects", esriSpatialRelIndexIntersects: null, esriSpatialRelOverlaps: "overlaps",
            esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: null
          }, e = {
            spatialRelationship: { esriSpatialRelIntersects: !0, esriSpatialRelContains: !0, esriSpatialRelWithin: !0, esriSpatialRelCrosses: !0, esriSpatialRelDisjoint: !0, esriSpatialRelTouches: !0, esriSpatialRelOverlaps: !0, esriSpatialRelEnvelopeIntersects: !0, esriSpatialRelIndexIntersects: !1, esriSpatialRelRelation: !1 }, queryGeometry: { esriGeometryPoint: !0, esriGeometryMultipoint: !0, esriGeometryPolyline: !0, esriGeometryPolygon: !0, esriGeometryEnvelope: !0 },
            layerGeometry: { esriGeometryPoint: !0, esriGeometryMultipoint: !0, esriGeometryPolyline: !0, esriGeometryPolygon: !0, esriGeometryEnvelope: !1 }
          }; w.canQueryWithRBush = function (g) { if (n.isExtent(g)) return !0; if (n.isPolygon(g)) { for (const x of g.rings) if (5 !== x.length || x[0][0] !== x[1][0] || x[0][0] !== x[4][0] || x[2][0] !== x[3][0] || x[0][1] !== x[3][1] || x[0][1] !== x[4][1] || x[1][1] !== x[2][1]) return !1; return !0 } return !1 }; w.checkSpatialQuerySupport = function (g, x, k) { return v.apply(this, arguments) }; w.getSpatialQueryOperator = function (g,
            x, k, r, A) {
              if (n.isPolygon(x) && "esriGeometryPoint" === k && ("esriSpatialRelIntersects" === g || "esriSpatialRelContains" === g)) { const z = h.convertFromPolygon(new b, x, !1, !1); return Promise.resolve(B => l.polygonContainsPoint(z, !1, !1, B)) } if (n.isPolygon(x) && "esriGeometryMultipoint" === k) { const z = h.convertFromPolygon(new b, x, !1, !1); if ("esriSpatialRelContains" === g) return Promise.resolve(B => l.polygonContainsMultipoint(z, !1, !1, B, r, A)) } if (n.isExtent(x) && "esriGeometryPoint" === k && ("esriSpatialRelIntersects" === g || "esriSpatialRelContains" ===
                g)) return Promise.resolve(z => u.extentContainsPoint(x, f.getGeometry(k, r, A, z))); if (n.isExtent(x) && "esriGeometryMultipoint" === k && "esriSpatialRelContains" === g) return Promise.resolve(z => u.extentContainsMultipoint(x, f.getGeometry(k, r, A, z))); if (n.isExtent(x) && "esriSpatialRelIntersects" === g) { const z = y.getExtentIntersector(k); return Promise.resolve(B => z(x, f.getGeometry(k, r, A, B))) } return t().then(z => { const B = z[m[g]].bind(null, x.spatialReference, x); return C => B(f.getGeometry(k, r, A, C)) })
          }; Object.defineProperty(w,
            "__esModule", { value: !0 })
      })
    }, "esri/geometry/support/intersects": function () {
      define(["exports", "./intersectsBase"], function (a, w) {
      a.extentIntersectsExtent = w.extentIntersectsExtent; a.extentIntersectsMultipoint = w.extentIntersectsMultipoint; a.extentIntersectsPoint = w.extentIntersectsPoint; a.extentIntersectsPolygon = w.extentIntersectsPolygon; a.extentIntersectsPolyline = w.extentIntersectsPolyline; a.getFeatureExtentIntersector = w.getFeatureExtentIntersector; a.isSelfIntersecting = w.isSelfIntersecting; a.segmentIntersects =
        w.segmentIntersects; a.getExtentIntersector = function (c) { return "mesh" === c ? w.extentIntersectsExtent : w.getFeatureExtentIntersector(c) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/layers/graphics/contains": function () {
      define(["exports"], function (a) {
        function w(c, q, u, y, n) {
          if (!c) return !1; q = q ? u ? 4 : 3 : u ? 3 : 2; const { coords: p, lengths: l } = c; u = !1; c = 0; for (const b of l) {
            var h = c; for (let d = c, f = c + b * q; d < f; d += q) {
              h = d + q; h === f && (h = c); const t = p[d], v = p[d + 1], m = p[h]; h = p[h + 1]; (v < n && h >= n || h < n && v >= n) && t + (n - v) / (h - v) * (m -
                t) < y && (u = !u)
            } c += b * q
          } return u
        } a.polygonContainsCoords = w; a.polygonContainsMultipoint = function (c, q, u, y, n, p) { n = n ? p ? 4 : 3 : p ? 3 : 2; const { coords: l, lengths: h } = y; if (!h) return !1; for (let b = 0, d = 0; b < h.length; b++ , d += n)if (!w(c, q, u, l[d], l[d + 1])) return !1; return !0 }; a.polygonContainsPoint = function (c, q, u, y) { return w(c, q, u, y.coords[0], y.coords[1]) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DFrustumVisibility": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/projectionEllipsoid ../../support/FrustumExtentIntersection ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          c = function (t) {
            function v() { var e = t.apply(this, arguments) || this; e.suspended = !1; e.extent = null; e.extentIntersectionDirty = !0; e._isVisibleBelowSurface = !1; e.handles = new q; e.layerView = null; e.updating = !0; return e } a._inheritsLoose(v, t); var m = v.prototype; m.setup = function (e) {
            this.layerView = e; this.extentIntersection = new d.FrustumExtentIntersection({ renderCoordsHelper: e.view.renderCoordsHelper }); e = e.view; const g = e.basemapTerrain, x = e.resourceController.scheduler; this.handles.add([e.on("resize",
              () => this.viewChange()), e.state.watch("camera", () => this.viewChange(), !0), x.registerTask(f.TaskPriority.FRUSTUM_VISIBILITY, this), g.on("elevation-bounds-change", () => this.elevationBoundsChange())]); "local" === e.viewingMode ? this.isVisibleBelowSurface = !0 : this.handles.add([u.init(g, ["opacity", "wireframe"], () => this.updateIsVisibleBelowSurface()), u.init(e, "map.ground.navigationConstraint.type", () => this.updateIsVisibleBelowSurface())])
            }; m.destroy = function () {
            this.extentIntersection = this.extent = this.layerView =
              null; this.handles && (this.handles.destroy(), this.handles = null)
            }; m._setDirty = function () { this.updating || this._set("updating", !0) }; m.setExtent = function (e) { this.extent = e; this.extentIntersectionDirty = !0; this._setDirty() }; m.viewChange = function () { this._setDirty() }; m.elevationBoundsChange = function () { this._setDirty(); this.extentIntersectionDirty = !0 }; m.updateIsVisibleBelowSurface = function () {
              const e = this.layerView.view, g = e.basemapTerrain, x = e.map.ground && e.map.ground.navigationConstraint && "none" === e.map.ground.navigationConstraint.type;
              this.isVisibleBelowSurface = "local" === e.viewingMode || !g.opaque || x
            }; m.updateExtentIntersection = function () { if (this.extentIntersectionDirty) { this.extentIntersectionDirty = !1; var e = this.layerView.view; if (this._isVisibleBelowSurface) var g = -.3 * b.getReferenceEllipsoid(e.spatialReference).radius; else { const { min: x, max: k } = e.basemapTerrain.elevationBounds; g = x - Math.max(1, (k - x) * (1.2 - 1)) } this.extentIntersection.update(this.extent, e.spatialReference, g) } }; m.runTask = function () {
              this._set("updating", !1); if (this.extent) {
                this.updateExtentIntersection();
                var e = this.layerView.view.frustum, g = b.getReferenceEllipsoid(this.layerView.view.spatialReference).radius; this._set("suspended", !this.extentIntersection.isVisibleInFrustum(e, g))
              } else this._set("suspended", !1)
            }; a._createClass(v, [{ key: "isVisibleBelowSurface", set: function (e) { this._isVisibleBelowSurface = e; this._setDirty(); this.extentIntersectionDirty = !0 } }, { key: "running", get: function () { return this.updating } }]); return v
          }(c); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "suspended", void 0); w.__decorate([y.property({ readOnly: !0 })],
            c.prototype, "updating", void 0); return c = w.__decorate([h.subclass("esri.views.3d.layers.graphics.Graphics3DFrustumVisibility")], c)
        })
    }, "esri/views/3d/layers/graphics/Graphics3DObjectStates": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/handleUtils", "./Graphics3DObjectStateSet"], function (a, w, c, q) {
        let u = function () {
          function y(p) { this._graphicsCore = p; this._stateSets = [] } var n = y.prototype; n.destroy = function () {
          this._stateSets && this._stateSets.forEach(p => p.objectStateSet.removeAll());
            this._stateSets = null
          }; n.acquireSet = function (p, l) { const h = new q.Graphics3DObjectStateSet(p, l); this._stateSets.push(h); p = c.makeHandle(() => this.releaseSet(h)); return { set: h, handle: p } }; n.releaseSet = function (p) { p.objectStateSet.removeAll(); p = this._stateSets ? this._stateSets.indexOf(p) : -1; -1 !== p && this._stateSets.splice(p, 1) }; n._addObjectStateSet = function (p, l) { p.addObjectStateSet(l.stateType, l.objectStateSet) }; n._removeObjectStateSet = function (p, l) { p.removeObjectState(l.objectStateSet) }; n.setUid = function (p,
            l) { p.ids.add(l); (l = this._graphicsCore.graphics3DGraphics.get(l)) && this._addObjectStateSet(l, p) }; n.setUids = function (p, l) { l.forEach(h => this.setUid(p, h)) }; n.setObjectIds = function (p, l) { l.forEach(h => p.ids.add(h)); this.initializeSet(p) }; n.addGraphic = function (p) { this._stateSets.forEach(l => { !l.paused && l.hasGraphic(p) && this._addObjectStateSet(p, l) }) }; n.removeGraphic = function (p) { this._stateSets.forEach(l => { l.hasGraphic(p) && this._removeObjectStateSet(p, l) }) }; n.allGraphicsDeleted = function () {
            this._stateSets &&
              this._stateSets.forEach(p => p.objectStateSet.removeAll())
            }; n.initializeSet = function (p) { const l = this._graphicsCore.graphics3DGraphics; p.objectIdField ? l.forEach(h => { h && p.hasGraphic(h) && this._addObjectStateSet(h, p) }) : p.ids.forEach(h => { (h = l.get(h)) && this._addObjectStateSet(h, p) }) }; w._createClass(y, [{ key: "test", get: function () { return { states: this._stateSets } } }]); return y
        }(); a.Graphics3DObjectStates = u; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/graphics/Graphics3DObjectStateSet": function () {
      define(["exports",
        "../../webgl-engine/lib/Object3DStateSet"], function (a, w) { let c = function () { function q(u, y) { this.stateType = u; this.objectIdField = y; this.objectStateSet = new w.Object3DStateSet; this.ids = new Set; this.paused = !1 } q.prototype.hasGraphic = function (u) { return this.objectIdField ? this.ids.has(u.graphic.attributes[this.objectIdField]) : this.ids.has(u.graphic.uid) }; return q }(); a.Graphics3DObjectStateSet = c; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/webgl-engine/lib/Object3DStateSet": function () {
      define(["exports"],
        function (a) {
          let w = function () {
            function c() { this.items = [] } var q = c.prototype; q.addObject = function (u, y) { this.items.push({ type: 0, objectStateId: y, object: u }) }; q.addRenderGeometry = function (u, y, n) { this.items.push({ type: 1, objectStateId: y, renderGeometry: u, owner: n }) }; q.addExternal = function (u, y) { this.items.push({ type: 2, objectStateId: y, remove: u }) }; q.remove = function (u) { for (let y = this.items.length - 1; 0 <= y; --y) { const n = this.items[y]; n.objectStateId === u && (this._removeObjectStateItem(n), this.items.splice(y, 1)) } }; q.removeObject =
              function (u) { for (let y = this.items.length - 1; 0 <= y; --y) { const n = this.items[y]; 0 === n.type && n.object === u && (this._removeObjectStateItem(n), this.items.splice(y, 1)) } }; q.removeRenderGeometry = function (u) { for (let y = this.items.length - 1; 0 <= y; --y) { const n = this.items[y]; 1 === n.type && n.renderGeometry === u && (this._removeObjectStateItem(n), this.items.splice(y, 1)) } }; q.removeAll = function () { this.items.forEach(u => { this._removeObjectStateItem(u) }); this.items = [] }; q._removeObjectStateItem = function (u) {
                switch (u.type) {
                  case 0: 0 ===
                    u.objectStateId.channel ? u.object.removeHighlight(u.objectStateId) : 1 === u.objectStateId.channel && u.object.removeOcclude(u.objectStateId); break; case 1: u.owner.removeRenderGeometryObjectState(u.renderGeometry, u.objectStateId); break; case 2: u.remove(u.objectStateId)
                }
              }; return c
          }(); a.Object3DStateSet = w; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/graphics/Graphics3DScaleVisibility": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Handles ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../support/layerViewUtils ../../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d) {
          c = function (f) {
            function t() { var m = f.apply(this, arguments) || this; m._scaleRangeActive = !1; m.layerScaleRangeVisibilityQuery = !1; m.handles = new q; m.layerView = null; m.layer = null; m.queryGraphicUIDsInExtent = null; m.extent = null; m.graphicsCore = null; m.basemapTerrain = null; m.layerScaleEnabled = !0; m.suspended = !1; m.updating = !0; return m } a._inheritsLoose(t, f); var v = t.prototype; v.setup = function (m, e, g, x, k) {
            this.layerView = m; this.layer = e; this.queryGraphicUIDsInExtent = g; this.graphicsCore = x;
              this.basemapTerrain = k; this.updateScaleRangeActive(); this.handles.add(this.layerView.view.resourceController.scheduler.registerTask(d.TaskPriority.SCALE_VISIBILITY, this))
            }; v.destroy = function () { this.handles.destroy(); this.graphicsCore = this.queryGraphicUIDsInExtent = this.extent = this.layerView = this.handles = null }; v._setDirty = function () { this.updating || this._set("updating", !0) }; v.setExtent = function (m) { this.extent = m; this._setDirty() }; v.scaleRangeActive = function () { return this._scaleRangeActive }; v.updateScaleRangeActive =
              function () {
                var m = this.layer; let e = this.layerScaleEnabled && (0 < m.minScale || 0 < m.maxScale); m.labelingInfo && !e && (e = m.labelingInfo.some(g => g && (0 < g.minScale || 0 < g.maxScale))); m = this._scaleRangeActive !== e; (this._scaleRangeActive = e) && !this.handles.has("terrain-events") && this.basemapTerrain ? (this.handles.add(this.basemapTerrain.on("scale-change", g => this.scaleUpdateHandler(g)), "terrain-events"), this.layerScaleEnabled && this.handles.add(this.basemapTerrain.on("tiles-visibility-changed", () => this._setDirty()), "terrain-events")) :
                  !e && this.handles.has("terrain-events") && this.handles.remove("terrain-events"); return m
              }; v.runTask = function () { const m = this.layerView.view.basemapTerrain; this.extent && m && m.ready && this._scaleRangeActive && this.layerScaleEnabled ? this.layerScaleRangeVisibilityQuery || (this.layerScaleRangeVisibilityQuery = !0, m.queryVisibleScaleRange(this.extent, this.layer.minScale, this.layer.maxScale, e => this.finishUpdate(e))) : this.finishUpdate(!0) }; v.finishUpdate = function (m) {
              this.layerScaleRangeVisibilityQuery = !1; this._set("suspended",
                !m); this._set("updating", !1)
              }; v.visibleAtLayerScale = function (m) { return !this.layerScaleEnabled || b.scaleBoundsPredicate(m, this.layer.minScale || 0, this.layer.maxScale || 0) }; v.visibleAtLabelScale = function (m, e) { return b.scaleBoundsPredicate(m, e.minScale || 0, e.maxScale || 0) }; v.graphicScale = function (m) {
                let e; u.isSome(m.centroid) ? e = m.centroid : u.isSome(m.graphic.geometry) && "point" === m.graphic.geometry.type && (e = m.graphic.geometry); return e ? this.layerView.view.basemapTerrain ? this.layerView.view.basemapTerrain.getScale(e) :
                  1 : null
              }; v.graphicVisible = function (m) { if (!this.layerScaleEnabled) return !0; m = this.graphicScale(m); return this.visibleAtLayerScale(m) }; v.updateVisibility = function (m) { if (this._scaleRangeActive) { const e = this.graphicVisible(m); return m.setVisibilityFlag(1, e, 0) } return !1 }; v.updateGraphicLabelScaleVisibility = function (m) {
                if (!this._scaleRangeActive || !m.labelGraphics || 0 === m.labelGraphics.length) return !1; const e = this.graphicScale(m); if (m = this.updateLabelScaleVisibility(m, e)) this.layerView.view.deconflictor.setDirty(),
                  this.layerView.view.labeler.setDirty(); return m
              }; v.updateLabelScaleVisibility = function (m, e) { if (!m.labelGraphics || 0 === m.labelGraphics.length) return !1; const g = m.labelGraphics[0]._labelClass; return g && null != g.minScale && null != g.maxScale && (e = this.visibleAtLabelScale(e, g), m.setVisibilityFlag(1, e, 1)) ? !0 : !1 }; v.scaleUpdateHandler = function (m) {
                this._setDirty(); if (!this.layerView.suspended) {
                  var e = m.extent, g = m.scale, x = this.visibleAtLayerScale(g), k = !1; this.queryGraphicUIDsInExtent(e, m.spatialReference, r => {
                    r = this.graphicsCore.getGraphics3DGraphicById(r);
                    if (!u.isNone(r)) { var A = r.centroid; u.isSome(A) && (e[0] > A.x || e[1] > A.y || e[2] < A.x || e[3] < A.y) || (r.setVisibilityFlag(1, x, 0) && (k = !0), this.updateLabelScaleVisibility(r, g) && (k = !0)) }
                  }); k && (this.layerView.view.deconflictor.setDirty(), this.layerView.view.labeler.setDirty())
                }
              }; v.layerMinMaxScaleChangeHandler = function () {
                this.updateScaleRangeActive() && !this._scaleRangeActive ? this.graphicsCore.modifyGraphics3DGraphicVisibilities(m => m.clearVisibilityFlag(1)) : this._scaleRangeActive && this.graphicsCore.updateAllGraphicsVisibility();
                this._setDirty()
              }; a._createClass(t, [{ key: "running", get: function () { return !(!this.layerView.view.basemapTerrain || !this.updating) } }]); return t
          }(c); w.__decorate([y.property({ constructOnly: !0 })], c.prototype, "layerScaleEnabled", void 0); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "suspended", void 0); w.__decorate([y.property({ readOnly: !0 })], c.prototype, "updating", void 0); return c = w.__decorate([h.subclass("esri.views.3d.layers.graphics.Graphics3DScaleVisibility")], c)
        })
    }, "esri/views/3d/layers/support/attributeUtils": function () {
      define(["exports"],
        function (a) { a.attributeLookup = function (w, c, q) { if (!q || null == c) return null; if (!w) { a: { w = q.toLowerCase(); for (var u in c) if (u.toLowerCase() === w) { c = c[u]; break a } c = null } return c } return (u = w.get(q)) ? c[u.name] : null }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/layers/support/projectExtentUtils": function () {
      define(["exports", "../../../../core/maybe", "../../../../geometry/support/webMercatorUtils", "../../../../portal/support/geometryServiceUtils"], function (a, w, c, q) {
      a.toViewIfLocal = function (u) {
        const y =
          u.view.spatialReference, n = u.layer.fullExtent; var p = w.isSome(n) && n.spatialReference; if (w.isNone(n) || !p) return Promise.resolve(null); if (p.equals(y)) return Promise.resolve(n.clone()); p = c.project(n, y); return w.isSome(p) ? Promise.resolve(p) : u.view.state.isLocal ? q.projectGeometry(n, y, u.layer.portalItem).then(l => !u.destroyed && l ? l : void 0).catch(() => null) : Promise.resolve(null)
      }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/FeatureTileFetcher3DLayerViewContext": function () {
      define(["exports",
        "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "./FeatureTileFetcher3D", "./featureTileQuery3D"], function (a, w, c, q, u) {
          let y = function () {
            function n(l) {
            this._capabilities = this._memoryCache = null; const h = l.layerView.layer; this.layerView = l.layerView; this.objectIdField = h.objectIdField; this.globalIdField = "globalIdField" in h ? h.globalIdField : null; this.returnZ = l.returnZ; this.returnM = l.returnM; const b = this.layerView.view.resourceController; this.query = u.createFeatureTileQuery3D(h, d => b.schedule(d));
              b && this.memoryCacheEnabled && (this._memoryCache = b.memoryController.newCache(h.uid))
            } var p = n.prototype; p.destroy = function () { this._memoryCache = c.destroyMaybe(this._memoryCache); this.query.destroy() }; p.createQuery = function () { const l = this.layerView.layer.createQuery(); l.outFields = this.layerView.availableFields; l.returnZ = this.returnZ; l.returnM = this.returnM; l.outSpatialReference = this.tilingScheme.spatialReference; return l }; p.logFetchError = function (l, h) {
              l.error("#fetchTile()", this.layerView.layer, h && h.message ?
                h.message : h)
            }; w._createClass(n, [{ key: "memoryCacheEnabled", get: function () { switch (this.layerView.layer.source.type) { case "feature-layer": case "ogc-feature": return !0; case "csv": case "geojson": case "memory": case "wfs": return !1 } } }, { key: "memoryCache", get: function () { return this._memoryCache } }, { key: "viewingMode", get: function () { return this.layerView.view.state.viewingMode } }, { key: "tilingScheme", get: function () { return this.layerView.view.featureTiles.tilingScheme } }, {
              key: "scheduler", get: function () {
                const l = this.layerView.view.resourceController;
                return l ? l.scheduler : null
              }
            }, { key: "geometryType", get: function () { return this.layerView.layer.geometryType } }, { key: "fullExtent", get: function () { return this.layerView.layer.fullExtent } }, { key: "tileMaxRecordCount", get: function () { return this.layerView.layer.capabilities.query.tileMaxRecordCount } }, { key: "maxRecordCount", get: function () { return this.layerView.layer.capabilities.query.maxRecordCount } }, { key: "capabilities", get: function () { return c.isSome(this._capabilities) ? this._capabilities : this._capabilities = q.contextCapabilitiesFromLayer(this.layerView.layer) } }]);
            return n
          }(); a.FeatureTileFetcher3DLayerViewContext = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/featureTileQuery3D": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../layers/graphics/dehydratedFeatures ../../../../rest/query/operations/query ../../support/PBFDecoder".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          let v = function (x) {
            function k(A) { return x.call(this, A) || this } w._inheritsLoose(k, x); var r = k.prototype; r.queryFeatureCount = function (A, z) { return this.layer.queryFeatureCount(A, z) }; r.destroy = function () { this._decoder = u.destroyMaybe(this._decoder) }; r._createRequestOptions = function (A) { return { ...A, query: { ...this.layer.customParameters, token: this.layer.apiKey, ...null == A ? void 0 : A.query } } }; w._createClass(k, [{
              key: "queryFeaturesDehydrated", get: function () {
                var A = this.layer.capabilities;
                if ((A = A && A.query) && A.supportsFormatPBF) { var z, B; u.isNone(this._decoder) && (this._decoder = new t.PBFDecoder(this.schedule)); const C = { sourceSpatialReference: null != (z = null == (B = this.layer.spatialReference) ? void 0 : B.toJSON()) ? z : null, applyTransform: !0, maxStringAttributeLength: 1024 }; return (D, E) => f.runQuery(this.layer.parsedUrl, D, "pbf", this._createRequestOptions(E)).then(H => { y.throwIfAborted(E); return u.isSome(this._decoder) ? this._decoder.invoke({ buffer: H.data, options: C }, E.signal) : Promise.reject(y.createAbortError()) }) } return (C,
                  D) => f.executeQuery(this.layer.parsedUrl, C, this.layer.spatialReference, this._createRequestOptions(D)).then(E => d.fromFeatureSetJSON(E.data))
              }
            }]); return k
          }(q); c.__decorate([n.property({ constructOnly: !0 })], v.prototype, "layer", void 0); c.__decorate([n.property({ constructOnly: !0 })], v.prototype, "schedule", void 0); c.__decorate([n.property({ readOnly: !0 })], v.prototype, "queryFeaturesDehydrated", null); v = c.__decorate([b.subclass("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceQuery3D")], v); let m =
            function (x) { function k(A) { return x.call(this, A) || this } w._inheritsLoose(k, x); var r = k.prototype; r.queryFeaturesDehydrated = function (A, z) { return this.layer.queryFeatures(A, z) }; r.queryFeatureCount = function (A, z) { return this.layer.queryFeatureCount(A, z) }; return k }(q); c.__decorate([n.property({ constructOnly: !0 })], m.prototype, "layer", void 0); c.__decorate([n.property({ readOnly: !0 })], m.prototype, "queryFeaturesDehydrated", null); m = c.__decorate([b.subclass("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceMeshQuery3D")],
              m); let e = function (x) { function k(r) { return x.call(this, r) || this } w._inheritsLoose(k, x); k.prototype.queryFeaturesDehydrated = function (r, A) { return this.layer.queryFeatures(r, A) }; return k }(q); c.__decorate([n.property({ constructOnly: !0 })], e.prototype, "layer", void 0); e = c.__decorate([b.subclass("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceQuery3D")], e); let g = function (x) {
                function k(A) { return x.call(this, A) || this } w._inheritsLoose(k, x); var r = k.prototype; r.queryFeaturesDehydrated = function (A,
                  z) { return this.source.queryFeaturesJSON(A, z).then(d.fromFeatureSetJSON, B => { if (B && "query-features-json:unsupported" === B.name) return this.layer.queryFeatures(A, z); throw B; }) }; r.queryFeatureCount = function (A, z) { return this.layer.queryFeatureCount(A, z) }; return k
              }(q); c.__decorate([n.property({ constructOnly: !0 })], g.prototype, "layer", void 0); c.__decorate([n.property({ constructOnly: !0 })], g.prototype, "source", void 0); g = c.__decorate([b.subclass("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileClientQuery3D")],
                g); a.createFeatureTileQuery3D = function (x, k) { return "feature" === x.type && "feature-layer" === x.source.type ? u.isSome(x.infoFor3D) ? new m({ layer: x }) : new v({ layer: x, schedule: k }) : "feature" === x.type && "memory" === x.source.type || "csv" === x.type || "geojson" === x.type || "wfs" === x.type ? new g({ layer: x, source: x.source }) : "ogc-feature" === x.type ? new e({ layer: x }) : null }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/PBFDecoder": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../Graphic ../../../core/maybe ../../../core/workers/WorkerHandle ../../../geometry/SpatialReference ../../../layers/support/Field".split(" "),
        function (a, w, c, q, u, y, n) {
          let p = function () {
            function h(d) { this._schedule = d; this._handle = new l(d) } var b = h.prototype; b.destroy = function () { this._handle.destroy() }; b.invoke = function (d, f) {
              if (!d.buffer || 0 === d.buffer.byteLength) return Promise.resolve(null); d.options.sourceSpatialReference && d.options.sourceSpatialReference instanceof y && (d.options = { ...d.options, sourceSpatialReference: d.options.sourceSpatialReference.toJSON() }); return this._handle.invoke(d, f).then(t => this._schedule(() => {
              t.spatialReference = y.fromJSON(t.spatialReference);
                if (t.fields) for (var v = 0; v < t.fields.length; v++)t.fields[v] = n.fromJSON(t.fields[v]); v = t.spatialReference; for (const m of t.features) m.uid = c.generateUID(), q.isSome(m.geometry) && (m.geometry.spatialReference = v); return t
              }))
            }; return h
          }(), l = function (h) { function b(d) { return h.call(this, "PBFDecoderWorker", "_parseFeatureQuery", d) || this } w._inheritsLoose(b, h); b.prototype.getTransferList = function (d) { return [d.buffer] }; return b }(u.WorkerHandle); a.PBFDecoder = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/EventedSet": function () {
      define(["exports",
        "../../../chunks/_rollupPluginBabelHelpers", "../../../core/Evented", "../../../core/SetUtils"], function (a, w, c, q) {
          c = function (u) {
            function y() { var p = u.apply(this, arguments) || this; p._set = new Set; return p } w._inheritsLoose(y, u); var n = y.prototype; n.clear = function () { if (0 < this._set.size) { const p = this.toArray(); this._set.clear(); this.emit("after-changes", { type: 2 }); this.emit("change", { added: [], removed: p }) } }; n.addMany = function (p) {
              if (0 !== p.length) {
                for (const l of p) this._set.add(l); this.emit("after-changes", { type: 1 });
                this.emit("change", { added: p, removed: [] })
              }
            }; n.remove = function (p) { this._set.delete(p) && (this.emit("after-changes", { type: 2 }), this.emit("change", { added: [], removed: [p] })) }; n.removeMany = function (p) { const l = []; for (const h of p) this._set.delete(h) && l.push(h); 0 < l.length && (this.emit("after-changes", { type: 2 }), this.emit("change", { added: [], removed: l })) }; n.toArray = function () { return [...this._set] }; n.find = function (p) { let l; q.someSet(this._set, h => p(h) ? (l = h, !0) : !1); return l }; n.forEach = function (p) {
              this._set.forEach(l =>
                p(l))
            }; w._createClass(y, [{ key: "length", get: function () { return this._set.size } }]); return y
          }(c); a.EventedSet = c; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/layers/FeatureLayerView": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/deprecate ../../core/Error ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../layers/support/commonProperties ../../layers/support/FeatureEffect ../../layers/support/FeatureFilter ../../layers/support/fieldUtils ../../rest/support/Query ../../support/arcadeOnDemand ./support/popupUtils ../support/floorFilterUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A) {
          const z = y.getLogger("esri.views.layers.FeatureLayerView"); y = B => {
            B = function (C) {
              function D(...H) { H = C.call(this, ...H) || this; H._updatingRequiredFieldsPromise = null; H.filter = null; H.timeExtent = null; H.layer = null; H.requiredFields = []; H.view = null; return H } w._inheritsLoose(D, C); var E = D.prototype; E.initialize = function () {
                l.init(this, "layer.renderer layer.labelingInfo layer.elevationInfo.featureExpressionInfo layer.displayField filter featureEffect layer.timeInfo layer.floorInfo timeExtent".split(" "),
                  () => this._handleRequiredFieldsChange(), !0); l.on(this, "view.floors", "change", () => this._handleRequiredFieldsChange()); l.on(this, "layer.sublayer", "change", () => this._handleRequiredFieldsChange())
              }; E.highlight = function (H) { throw Error("missing implementation"); }; E.createQuery = function () {
                var H = { outFields: ["*"], returnGeometry: !0, outSpatialReference: this.view.spatialReference }; H = n.isSome(this.filter) ? this.filter.createQuery(H) : new x(H); if ("feature" === this.layer.type) {
                  const J = A.getFloorFilterClause(this); n.isSome(J) &&
                    (H.where = H.where ? `(${H.where}) AND (${J})` : J)
                } n.isSome(this.timeExtent) && (H.timeExtent = n.isSome(H.timeExtent) ? H.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()); return H
              }; E.queryFeatures = function (H, J) { throw Error("missing implementation"); }; E.queryObjectIds = function (H, J) { throw Error("missing implementation"); }; E.queryFeatureCount = function (H, J) { throw Error("missing implementation"); }; E.queryExtent = function (H, J) { throw Error("missing implementation"); }; E.fetchPopupFeatures = function () {
                var H =
                  w._asyncToGenerator(function* (J, M) { if (J = this.validateFetchPopupFeatures(M)) throw J; return this.fetchClientPopupFeatures(M) }); return function (J, M) { return H.apply(this, arguments) }
              }(); E._loadArcadeModules = function (H) { if (H.get("expressionInfos.length") || Array.isArray(H.content) && H.content.some(J => "expression" === J.type)) return k.loadArcade() }; E._handleRequiredFieldsChange = function () {
                const H = this._updateRequiredFields(); this._set("_updatingRequiredFieldsPromise", H); H.then(() => {
                this._updatingRequiredFieldsPromise ===
                  H && this._set("_updatingRequiredFieldsPromise", null)
                })
              }; E._updateRequiredFields = function () {
                var H = w._asyncToGenerator(function* () {
                  if (this.layer && this.view) {
                    var J = "3d" === this.view.type, { layer: M, layer: { fieldsIndex: F, objectIdField: K } } = this, P = "renderer" in M && M.renderer, L = "orderBy" in M && M.orderBy, N = M.featureReduction, G = new Set; P = yield p.eachAlways([P ? P.collectRequiredFields(G, F) : null, g.collectLabelingFields(G, M), J ? g.collectElevationFields(G, M) : null, n.isSome(this.filter) ? g.collectFilterFields(G, M, this.filter) :
                      null, n.isSome(this.featureEffect) ? g.collectFilterFields(G, M, this.featureEffect.filter) : null, N ? g.collectFeatureReductionFields(G, M, N) : null, L ? g.collectOrderByInfos(G, M, L) : null]); M.timeInfo && this.timeExtent && g.collectFields(G, M.fieldsIndex, [M.timeInfo.startField, M.timeInfo.endField]); "feature" === M.type && M.floorInfo && g.collectFields(G, M.fieldsIndex, [M.floorInfo.floorField]); "subtype-group" === M.type && (g.collectField(G, F, M.subtypeField), L = M.sublayers.map(I => {
                        var O; return Promise.all([null == (O = I.renderer) ?
                          void 0 : O.collectRequiredFields(G, F), g.collectLabelingFields(G, I)])
                      }), yield p.eachAlways(L)); for (const I of P) I.error && z.error(I.error); g.collectField(G, F, K); J && "displayField" in M && M.displayField && g.collectField(G, F, M.displayField); J = Array.from(G).sort(); this._set("requiredFields", J)
                  }
                }); return function () { return H.apply(this, arguments) }
              }(); E.validateFetchPopupFeatures = function (H) {
                if (n.isNone(H)) return null; for (const J of H.clientGraphics) {
                  const M = J.layer; if ("popupEnabled" in M && !M.popupEnabled) return new u("featurelayerview:fetchPopupFeatures",
                    "Popups are disabled", { layer: M }); if ("popupTemplate" in M && !r.getFetchPopupTemplate(M, H)) return new u("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: M }); if (J.isAggregate && !(M.featureReduction && "popupTemplate" in M.featureReduction && M.featureReduction.popupEnabled && M.featureReduction.popupTemplate)) return new u("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: M })
                }
              }; E.fetchClientPopupFeatures = function () {
                var H = w._asyncToGenerator(function* (J) {
                  const M =
                    n.isSome(J) ? J.clientGraphics : null; if (!M || 0 === M.length) return []; const F = Array(M.length), K = new Map, P = yield this.createPopupQuery(J); for (let N = 0; N < M.length; N++) {
                      const G = M[N]; if (G.isAggregate) { F[N] = G; continue } var { layer: L } = G; if (!("popupEnabled" in L)) continue; const I = g.unpackFieldNames(this.layer.fieldsIndex, P.outFields); L = r.getFetchPopupTemplate(L, J); if (!n.isSome(L)) continue; const O = yield this._loadArcadeModules(L); O && O.arcadeUtils.hasGeometryOperations(L) || !g.featureHasFields(I, G) ? K.set(G.getObjectId(),
                        N) : F[N] = G
                    } if ("stream" === this.layer.type || 0 === K.size) return F.filter(Boolean); P.objectIds = Array.from(K.keys()); try { const N = yield this.layer.queryFeatures(P); for (const G of N.features) { const I = K.get(G.getObjectId()); F[I] = G } } catch{ } return F.filter(Boolean)
                }); return function (J) { return H.apply(this, arguments) }
              }(); E.createPopupQuery = function () {
                var H = w._asyncToGenerator(function* (J) {
                  const M = this.layer.createQuery(), F = new Set; var K = !1, P = n.isSome(J) && J.clientGraphics ? J.clientGraphics.map(L => L.layer) : [this.layer];
                  for (const L of P) if ("popupEnabled" in L && (P = r.getFetchPopupTemplate(L, J), n.isSome(P))) { K = (K = yield this._loadArcadeModules(P)) && K.arcadeUtils.hasGeometryOperations(P); K = !("point" !== this.layer.geometryType && !K); P = yield r.getRequiredFields(this.layer, P); for (const N of P) F.add(N) } M.returnGeometry = K; M.returnZ = K; M.returnM = K; M.outFields = Array.from(F); M.outSpatialReference = this.view.spatialReference; "feature" === this.layer.type && (J = A.getFloorFilterClause(this), n.isSome(J) && (M.where = M.where ? `(${M.where}) AND (${J})` :
                    J)); return M
                }); return function (J) { return H.apply(this, arguments) }
              }(); E.canResume = function () { return !C.prototype.canResume.call(this) || n.isSome(this.timeExtent) && this.timeExtent.isEmpty ? !1 : !0 }; w._createClass(D, [{ key: "availableFields", get: function () { const { layer: H, layer: { fieldsIndex: J }, requiredFields: M } = this; return "outFields" in H && H.outFields ? g.fixFields(J, [...g.unpackFieldNames(J, H.outFields), ...M]) : g.fixFields(J, M) } }, {
                key: "effect", get: function () {
                  q.deprecatedProperty(z, "effect", {
                    replacement: "featureEffect",
                    version: "4.22"
                  }); return this.featureEffect
                }, set: function (H) { q.deprecatedProperty(z, "effect", { replacement: "featureEffect", version: "4.22" }); this.featureEffect = H }
              }, { key: "featureEffect", get: function () { return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null }, set: function (H) { void 0 === H ? this._clearOverride("featureEffect") : this._override("featureEffect", H) } }, { key: "maximumNumberOfFeatures", get: function () { return 0 }, set: function (H) { z.error("#maximumNumberOfFeatures\x3d", "Setting maximum number of features is not supported") } },
              { key: "maximumNumberOfFeaturesExceeded", get: function () { return !1 } }]); return D
            }(B); c.__decorate([h.property()], B.prototype, "_updatingRequiredFieldsPromise", void 0); c.__decorate([h.property({ readOnly: !0 })], B.prototype, "availableFields", null); c.__decorate([h.property()], B.prototype, "effect", null); c.__decorate([h.property({ type: m })], B.prototype, "featureEffect", null); c.__decorate([h.property({ type: e })], B.prototype, "filter", void 0); c.__decorate([h.property(v.combinedViewLayerTimeExtentProperty)], B.prototype,
              "timeExtent", void 0); c.__decorate([h.property()], B.prototype, "layer", void 0); c.__decorate([h.property({ type: Number })], B.prototype, "maximumNumberOfFeatures", null); c.__decorate([h.property({ readOnly: !0, type: Boolean })], B.prototype, "maximumNumberOfFeaturesExceeded", null); c.__decorate([h.property({ readOnly: !0 })], B.prototype, "requiredFields", void 0); c.__decorate([h.property()], B.prototype, "suspended", void 0); c.__decorate([h.property()], B.prototype, "view", void 0); return B = c.__decorate([t.subclass("esri.views.layers.FeatureLayerView")],
                B)
          }; a.FeatureLayerView = y; a.default = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/layers/support/popupUtils": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/maybe", "../../../layers/support/fieldUtils"], function (a, w, c, q) {
        function u() {
          u = w._asyncToGenerator(function* (y, n = y.popupTemplate) {
            if (!c.isSome(n)) return []; const p = yield n.getRequiredFields(y.fieldsIndex); ({ lastEditInfoEnabled: n } = n); const { objectIdField: l, typeIdField: h, globalIdField: b, relationships: d } =
              y; if (p.includes("*")) return ["*"]; n = n ? yield q.getFeatureEditFields(y) : []; const f = q.fixFields(y.fieldsIndex, [...p, ...n]); h && f.push(h); f && l && y.fieldsIndex.has(l) && -1 === f.indexOf(l) && f.push(l); f && b && y.fieldsIndex.has(b) && -1 === f.indexOf(b) && f.push(b); d && d.forEach(t => { ({ keyField: t } = t); f && t && y.fieldsIndex.has(t) && -1 === f.indexOf(t) && f.push(t) }); return f
          }); return u.apply(this, arguments)
        } a.getFetchPopupTemplate = function (y, n) {
          return y.popupTemplate ? y.popupTemplate : c.isSome(n) && n.defaultPopupTemplateEnabled &&
            c.isSome(y.defaultPopupTemplate) ? y.defaultPopupTemplate : null
        }; a.getRequiredFields = function (y) { return u.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/layers/RefreshableLayerView": function () {
      define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Logger ../../core/promiseUtils ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          p = d => { d = function (f) { function t() { return f.apply(this, arguments) || this } w._inheritsLoose(t, f); t.prototype.initialize = function () { this.handles.add(y.on(this, "layer", "refresh", v => { this.doRefresh(v.dataChanged).catch(m => { u.isAbortError(m) || q.getLogger(this.declaredClass).error(m) }) }), "RefreshableLayerView") }; return t }(d); c.__decorate([n.property()], d.prototype, "layer", void 0); return d = c.__decorate([b.subclass("esri.layers.mixins.RefreshableLayerView")], d) }; a.RefreshableLayerView =
            p; a.default = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/PointCloudLayerView3D": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/asyncUtils ../../../core/Collection ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../core/screenUtils ../../../core/typedArrayUtil ../../../core/unitUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec3 ../../../chunks/vec3f32 ../../../geometry/projection ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ../../../geometry/support/plane ../../../layers/graphics/dehydratedFeatures ../../../layers/support/CodedValue ../../../layers/support/CodedValueDomain ../../../layers/support/Domain ../../../layers/support/InheritedDomain ../../../layers/support/RangeDomain ../../../layers/support/fieldUtils ../../../layers/support/PromiseQueue ../../../symbols/support/unitConversionUtils ./LayerView3D ./PointCloudWorkerHandle ./i3s/I3SUtil ./i3s/LoDUtil ./i3s/PagedNodeIndex ./i3s/PointCloudRendererUtil ./i3s/PointCloudWorkerUtil ./i3s/PointGraphic ./i3s/PointRenderer ./support/PopupSceneLayerView ../support/extentUtils ../support/orientedBoundingBox ../support/updatingProperties ../../layers/LayerView ../../support/layerViewUtils ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q, T, da, Y, fa, ha) {
          const ka = u.getLogger("esri.views.3d.layers.PointCloudLayerView3D"), ea = r.create(); u = function (aa) {
            function W() {
              var X = aa.apply(this, arguments) || this; X.type = "point-cloud-3d"; X.maximumPointCount = 4E6; X.slicePlaneEnabled = !1; X._renderer = null; X._rendererAdded = !1; X._renderedNodes = new Set; X._nodeScales = new Map; X._updateViewNeeded = !0; X._lodFactor = 1; X._maxLoggedBoxWarnings = 5; X._pageMultiplier = 1; X._nodeLoadEpoch =
                0; X._indexQueue = []; X._workQueue = []; X._idleQueue = new J.PromiseQueue; X._indexPagesLoading = new Map; X._loadingNodes = new Map; X._recalcWork = !0; X._layerIsVisible = !1; X._codedDomainPopulationPromise = null; X._codedDomainPopulationAbortController = null; X._totalWork = 0; X._index = null; X._loadingInitNodePage = !1; X._nodeIdArray = []; return X
            } a._inheritsLoose(W, aa); var U = W.prototype; U.initialize = function () {
              const X = this.view.resourceController; this._worker = new K.PointCloudWorkerHandle(la => X.schedule(la)); this.addResolvingPromise(this._worker.promise);
              this._tmpPoint = A.makeDehydratedPoint(0, 0, 0, this.layer.spatialReference); P.checkPointCloudLayerValid(this.layer); P.checkPointCloudLayerCompatibleWithView(this.layer, this.view); this._indexRequester = X.createStreamDataRequester(2); this._dataRequester = X.createStreamDataRequester(3); this._initRenderer(); const Z = this._initNodePages(), ia = this.view.resourceController.memoryController; this._memCache = ia.newCache(this.layer.uid); this.updatingHandles.add(this, "_clippingBox", () => this._setUpdateViewNeeded(), 2);
              this.updatingHandles.add(this, "_elevationOffset", () => this._elevationOffsetChanged(), 2); this.updatingHandles.add(this.layer, "renderer", () => this._rendererChanged(), 2); this.updatingHandles.add(this.layer, "filters", () => this._reload(), 2); this.updatingHandles.add(this.layer, "outFields", () => this._reload(), 2); this.updatingHandles.add(this.layer, "scaleRangeId", () => this._setUpdateViewNeeded()); this.updatingHandles.add(this, "clippingArea", () => this._setUpdateViewNeeded(), 2); this.updatingHandles.add(this.view.state,
                "contentCamera", () => this._setUpdateViewNeeded()); this.handles.add([this.view.basemapTerrain.on("scale-change", la => this._scaleUpdateHandler(la)), ia.events.on("quality-changed", () => this._setUpdateViewNeeded())]); this.addResolvingPromise(Z); this.when(() => {
                  this.handles.add([X.scheduler.registerTask(ha.TaskPriority.POINT_CLOUD_LAYER, this), X.scheduler.registerIdleStateCallbacks(() => this._idleBegin(), () => this._idleEnd()), this.updatingHandles.add(this, "suspended", la => { la ? this._clearNodeState() : this._setUpdateViewNeeded() },
                    2)])
                }, () => { this.updatingHandles.removeAll(); this.handles.removeAll() })
            }; U._setUpdateViewNeeded = function () { this._updateViewNeeded = !0; this._updateLoading() }; U.destroy = function () {
              this.cancelLoading(); this._worker && (this._worker.destroy(), this._worker = null); this._destroyRenderer(); this._memCache.destroy(); this._memCache = null; this._codedDomainPopulationAbortController && (this._codedDomainPopulationAbortController.abort(), this._codedDomainPopulationAbortController = null); this._codedDomainPopulationPromise =
                null
            }; U._initRenderer = function () {
            this._renderer = new R.PointRenderer({ createGraphic: (X, Z, ia) => this._createGraphic(X, Z, ia) }); this._renderer.layerUid = this.layer.uid; this.updatingHandles.add(this, "_clippingBox", X => this._renderer.clippingBox = X, 2); this.updatingHandles.add(this, "suspended", X => this._setPointsVisible(!X), 2); this.updatingHandles.add(this, "pointScale", X => this._renderer.scaleFactor = X, 2); this._renderer.minSizePx = Math.sqrt(2); this.updatingHandles.add(this, "useRealWorldSymbolSizes", X => this._renderer.useRealWorldSymbolSizes =
              X, 2); this.updatingHandles.add(this, "pointSize", X => { const Z = p.pt2px(X); this._renderer.size = X; this._renderer.sizePx = Z }, 2); this.updatingHandles.add(this, "slicePlaneEnabled", X => this._renderer.slicePlaneEnabled = X, 2); this.updatingHandles.add(this, "inverseDensity", () => this._setUpdateViewNeeded(), 2); this.updatingHandles.add(this, "maximumPointCount", () => this._setUpdateViewNeeded(), 2); this.updatingHandles.add(this.view, "qualitySettings.sceneService.pointCloud.lodFactor", X => { this._lodFactor = X; this._setUpdateViewNeeded() },
                2)
            }; U._destroyRenderer = function () { this._renderer.removeAll(); this._setPointsVisible(!1) }; U._createGraphic = function (X, Z, ia) { const la = y.isSome(X.pointIdFilterMap) ? X.pointIdFilterMap[Z] : Z; ia = this.view.computeMapPointFromVec3d(ia); const ma = this._createGraphicAttributes(X, la); return new O.PointGraphic({ pointCloudMetadata: { nodeId: X.id, pointIndexInNode: Z, attributePointIndexInNode: la, epoch: this._nodeLoadEpoch }, geometry: ia, attributes: ma, layer: this.layer, sourceLayer: this.layer }) }; U._createGraphicAttributes =
              function (X, Z) { const ia = {}; for (const la of X.attributes) this._encodeGraphicAttribute(la.attributeInfo, la.values, Z, ia); return ia }; U._encodeGraphicAttribute = function (X, Z, ia, la) { var ma = X.storageInfo && X.storageInfo.attributeValues; const ra = ma ? ma.valuesPerElement : 1; if (1 === ra) la[X.name] = Z[ia]; else if ("UInt8" === ma.valueType && 4 >= ra) { ma = 0; ia *= ra; for (let Aa = ia; Aa < ia + ra; Aa++)ma = (ma << 8) + Z[Aa]; la[X.name] = ma } else la[X.name] = void 0 }; U._setPointsVisible = function (X) {
                X && !this._rendererAdded ? (this.view._stage.addRenderPlugin([3],
                  this._renderer), this._rendererAdded = !0) : !X && this._rendererAdded && (this.view._stage.removeRenderPlugin(this._renderer), this._rendererAdded = !1)
              }; U._rendererChanged = function () { this._renderer.useFixedSizes = G.rendererUsesFixedSizes(this.layer.renderer); this._reload() }; U._reload = function () { this._clearNodeState(); this._memCache.clear(); this._setUpdateViewNeeded() }; U._elevationOffsetChanged = function () { this._clearNodeState(); this._memCache.clear(); this._initNodePages() }; U._scaleUpdateHandler = function (X) {
                this.layer.minScale ||
                this.layer.maxScale ? g.projectBoundingRect(X.extent, X.spatialReference, ba, this.layer.spatialReference) && (this._nodeScales.forEach((Z, ia) => { this._renderedNodes.has(ia) ? (Z = this._index.getNode(ia), k.containsPoint(ba, Z.obb.center) && this._nodeScales.set(ia, X.scale)) : this._nodeScales.delete(ia) }), this._setUpdateViewNeeded()) : this._nodeScales.clear()
              }; U.displayNodes = function (X) {
              this._workQueue = L.nodeDiff([...this._renderedNodes], X, this._index); L.sortFrontToBack(this._workQueue, this.view.state.contentCamera.viewForward,
                this._index); L.splitWorkEntries(this._workQueue, 8, this._index); this._updateQueues(); this._totalWork = this._computeWork(); this._updateLoading(); this._layerIsVisible = 0 < X.length || this._loadingInitNodePage; this.notifyChange("suspended")
              }; U.cancelLoading = function () { this._cancelNodeLoading(); this._cancelIndexLoading() }; U._cancelNodeLoading = function () {
                const X = []; this._loadingNodes.forEach(({ abortController: Z }) => X.push(Z)); this._loadingNodes.clear(); for (const Z of X) Z.abort(); this._workQueue = []; this._idleQueue.cancelAll();
                this._totalWork = this._computeWork(); this._updateLoading()
              }; U._updateQueues = function () {
                const X = new Set; this._workQueue.forEach(la => la.load.forEach(ma => X.add(ma))); const Z = [], ia = new Map; this._loadingNodes.forEach((la, ma) => { X.has(ma) ? ia.set(ma, la) : Z.push(la) }); this._loadingNodes = ia; for (const { abortController: la } of Z) la.abort(); this._workQueue = this._workQueue.filter(la => { for (const ma of la.load) if (this._loadingNodes.has(ma)) return this._recalcWork = !0, !1; return !0 }); this._totalWork = this._computeWork();
                this._updateLoading()
              }; U._cancelIndexLoading = function () { this._indexQueue = []; this._indexPagesLoading.forEach(({ abortController: X }) => X.abort()); this._indexPagesLoading.clear(); this._totalWork = this._computeWork(); this._updateLoading() }; U._clearNodeState = function () { this._nodeLoadEpoch++; this._renderedNodes.forEach(X => this._removeFromRenderer(X)); this._cancelNodeLoading() }; U._idleBegin = function () { this._setUpdateViewNeeded() }; U._idleEnd = function () { this._setUpdateViewNeeded() }; U.runTask = function (X) {
                if (this.suspended) this._updateViewNeeded &&
                  (this._updateViewNeeded = !1, X = this._isRootNodeVisible(), X !== this._layerIsVisible && (this._layerIsVisible = X, this.notifyChange("suspended")), this._updateLoading()); else { for (X.run(() => this._updateWorkQueues()); 0 < this._indexQueue.length && X.run(() => this._processIndexQueue());); this._processWorkQueue(X); this._idleQueue.runTask(X) }
              }; U._processIndexQueue = function () {
                const X = this._indexQueue.shift(), Z = this._loadNodePage(X); this._indexPagesLoading.set(X, Z); Z.promise.then(ia => {
                  this._index.addPage(X, ia, this._elevationOffset);
                  this._setUpdateViewNeeded()
                }).then(() => { this._indexPagesLoading.delete(X) }, () => { this._indexPagesLoading.delete(X) }); return !0
              }; U._processWorkQueue = function (X) { for (; !X.done;) { const Z = this._scheduleWorkEntry(); if (y.isNone(Z)) break; this._processWorkEntry(Z); X.madeProgress() } }; U._scheduleWorkEntry = function () { let X = this._workQueue.length; for (; X--;) { const Z = this._workQueue.shift(); if (Z.remove.find(ia => !this._renderedNodes.has(ia))) this._workQueue.push(Z); else return Z } return null }; U._processWorkEntry = function (X) {
                if (0 ===
                  X.load.length) for (const Z of X.remove) this._removeFromRenderer(Z); else Promise.all(X.load.map(Z => { const ia = new AbortController, la = this._memCache.pop(Z.toString()); y.isSome(la) ? this._loadingNodes.set(Z, { abortController: ia, promise: Promise.resolve(la) }) : this._loadingNodes.has(Z) || this._loadingNodes.set(Z, { abortController: ia, promise: this.loadNode(Z, ia.signal) }); return this._loadingNodes.get(Z).promise })).then(Z => {
                    for (let ia = 0; ia < X.load.length; ia++)if (Z[ia]) {
                      const la = this._setupRendererData(X.load[ia],
                        Z[ia]); this._addToRenderer(la)
                    } for (const ia of X.remove) this._removeFromRenderer(ia)
                  }).catch(() => { }).then(() => { for (const Z of X.load) this._loadingNodes.delete(Z); this._updateLoading(); this._recalcWork && !this._idleQueue.running && 0 === this._indexQueue.length && 0 === this._loadingNodes.size && (this._recalcWork = !1, this._setUpdateViewNeeded()) }), this._updateLoading()
              }; U.populateClassCodeCodedDomain = function () {
                var X = a._asyncToGenerator(function* (Z, ia) {
                  const la = this.layer.fieldsIndex.get("CLASS_CODE"); la && !la.domain &&
                    -1 !== Z.indexOf(la.name) && (Z = yield c.result(this.layer.queryCachedStatistics("CLASS_CODE", { signal: ia })), !1 !== Z.ok && (Z = (Z = Z.value) && Z.labels && Z.labels.labels) && Array.isArray(Z) && (la.domain = new B({ name: "CLASS_CODE", codedValues: Z.map(ma => new z.default({ code: ma.value, name: ma.label })) })))
                }); return function (Z, ia) { return X.apply(this, arguments) }
              }(); U.prepareFetchPopupFeatures = function () {
                var X = a._asyncToGenerator(function* (Z) {
                this._codedDomainPopulationPromise || (this._codedDomainPopulationAbortController =
                  new AbortController, this._codedDomainPopulationPromise = this.populateClassCodeCodedDomain(Z, this._codedDomainPopulationAbortController.signal).then(() => { this._codedDomainPopulationAbortController = null })); return this._codedDomainPopulationPromise
                }); return function (Z) { return X.apply(this, arguments) }
              }(); U.whenGraphicAttributes = function () {
                var X = a._asyncToGenerator(function* (Z, ia) {
                  var la = this; const ma = this._splitGraphicsPerNode(Z), ra = this.layer.attributeStorageInfo, Aa = ia.map(Ea => G.getAttributeInfo(ra, Ea)),
                    za = function () {
                      var Ea = a._asyncToGenerator(function* (Ua, Na) { const ya = la._index.getNode(Na); yield c.forEach(Aa, function () { var pa = a._asyncToGenerator(function* (wa) { const Ia = wa.useElevation ? yield la._loadElevationAttributeFromGeometry(ya.resourceId) : yield la._loadAndParseAttribute(ya, wa); if (Ia) for (const Ha of Ua) la._isValidPointGraphic(Ha) && la._encodeGraphicAttribute(wa, Ia, Ha.pointCloudMetadata.attributePointIndexInNode, Ha.attributes) }); return function (wa) { return pa.apply(this, arguments) } }()) }); return function (Ua,
                        Na) { return Ea.apply(this, arguments) }
                    }(), Ka = []; ma.forEach((Ea, Ua) => { Ka.push(za(Ea, Ua)) }); yield n.eachAlways(Ka); return Z
                }); return function (Z, ia) { return X.apply(this, arguments) }
              }(); U._isValidPointGraphic = function (X) { return X instanceof O.PointGraphic && X.pointCloudMetadata && X.pointCloudMetadata.epoch === this._nodeLoadEpoch }; U._splitGraphicsPerNode = function (X) {
                const Z = new Map; for (const ia of X) {
                  if (!this._isValidPointGraphic(ia)) continue; X = ia.pointCloudMetadata; const la = Z.get(X.nodeId); la ? la.push(ia) : Z.set(X.nodeId,
                    [ia])
                } return Z
              }; U._loadAndParseAttribute = function () { var X = a._asyncToGenerator(function* (Z, ia) { const la = yield this._loadAttribute(Z.resourceId, ia, null); return y.isSome(la) ? I.getAttributeValues({ attributeInfo: ia, buffer: la }, null, Z.vertexCount) : null }); return function (Z, ia) { return X.apply(this, arguments) } }(); U._loadElevationAttributeFromGeometry = function () {
                var X = a._asyncToGenerator(function* (Z) {
                  Z = I.readGeometry(this.layer.store.defaultGeometrySchema, yield this._loadGeometry(Z, null)); return I.elevationFromPositions(Z,
                    Z.length / 3)
                }); return function (Z) { return X.apply(this, arguments) }
              }(); U.highlight = function (X) { if (!X) return { remove() { } }; X = q.isCollection(X) ? X.toArray() : Array.isArray(X) ? X : [X]; return this._renderer.highlight(X.map(Z => this._graphicToPointDefinition(Z))) }; U._graphicToPointDefinition = function (X) { if (!this._isValidPointGraphic(X)) return null; const { nodeId: Z, pointIndexInNode: ia } = X.pointCloudMetadata; return null != Z && null != ia ? { nodeId: Z, pointId: ia } : null }; U._computeWork = function () {
                let X = 0; for (const Z of this._workQueue) X +=
                  Z.load.length + Z.remove.length; X += this._loadingNodes.size; X += (this._indexQueue.length + this._indexPagesLoading.size) * this._index.pageSize; X += this._loadingInitNodePage ? 100 : 0; return X += this._updateViewNeeded ? 100 : 0
              }; U._updateLoading = function () { this.notifyChange("updating"); this.notifyChange("updatingProgressValue") }; U.canResume = function () { return aa.prototype.canResume.call(this) && this._layerIsVisible }; U.isUpdating = function () { return this.suspended ? this._updateViewNeeded : 0 < this._computeWork() }; U._initNodePages =
                function () {
                  const X = this.layer.store.index; this._index = new N(this.layer.spatialReference, this.view.renderCoordsHelper.spatialReference, X.nodesPerPage || X.nodePerIndexBlock); this._cancelIndexLoading(); this._traverseVisible = this._index.createVisibilityTraverse(); this._layerIsVisible = this._loadingInitNodePage = !0; this.notifyChange("suspended"); this._updateLoading(); this._pageMultiplier = null != X.nodesPerPage ? 1 : X.nodePerIndexBlock; return this._loadNodePage(0).promise.then(Z => {
                    this._index.addPage(0, Z, this._elevationOffset);
                    this._loadingInitNodePage = !1; this._setUpdateViewNeeded()
                  })
                }; U._loadNodePage = function (X) {
                  const Z = new AbortController; return {
                    promise: this._requestNodePage(`${this.baseUrl}/nodepages/${X * this._pageMultiplier}`, Z.signal).then(ia => ia.nodes.map((la, ma) => ({ resourceId: null != la.resourceId ? la.resourceId : X * this._index.pageSize + ma, obb: la.obb, firstChild: la.firstChild, childCount: la.childCount, vertexCount: null != la.vertexCount ? la.vertexCount : la.pointCount, lodThreshold: null != la.lodThreshold ? la.lodThreshold : la.effectiveArea }))),
                    abortController: Z
                  }
                }; U._updateWorkQueues = function () {
                  if (!this._updateViewNeeded) return !1; let X = this.inverseDensity / this._lodFactor * this._getLodMemoryFactor(); const Z = this.maximumPointCount * this._lodFactor * this._getLodMemoryFactor(); let ia = this._computeNodesForMinimumDensity(X), la = this._computePointCount(ia), ma = Math.sqrt(la / (.75 * Z)); for (; la > Z;)X *= ma, ia = this._computeNodesForMinimumDensity(X), la = this._computePointCount(ia), ma = Math.sqrt(2); this.displayNodes(ia); this._updateViewNeeded = !1; this._updateLoading();
                  return !0
                }; U._computePointCount = function (X) { let Z = 0; for (let ia = 0; ia < X.length; ia++) { const la = this._index.getNode(X[ia]); la && (Z += la.vertexCount) } return Z }; U._getLodMemoryFactor = function () { return this.view.resourceController.memoryController.memoryFactor }; U._isRootNodeVisible = function () { let X = !1; this._traverseVisible({ frustum: this.view.state.contentCamera.frustum, clippingBox: this._clippingBox }, { predicate: (Z, ia, la) => { X = la; return !1 }, pageMiss: () => { } }); return X }; U._computeNodesForMinimumDensity = function (X) {
                  const Z =
                    this.view.state.contentCamera, ia = Z.frustum, la = this._clippingBox, ma = Z.viewForward, ra = m.dot(ma, Z.eye), Aa = r.fromNormalAndOffset(ma, -ra, ea), za = Z.perScreenPixelRatio / 2, Ka = X * X, Ea = this._nodeIdArray; Ea.length = 0; const { minScale: Ua, maxScale: Na } = fa.extractSafeScaleBounds(this.layer), ya = 0 === Ua && 0 === Na ? pa => Ea.push(pa) : pa => { const wa = this._getScale(pa); fa.scaleBoundsPredicate(wa, Ua, Na) && Ea.push(pa) }; this._traverseVisible({ frustum: ia, clippingBox: la }, {
                      predicate: (pa, wa, Ia) => {
                        if (!Ia) return !1; if (0 === wa.childCount) return ya(pa),
                          !1; Ia = this._index.getRenderObb(pa); return this._computeAveragePixelArea(Ia, wa.lodThreshold, wa.vertexCount, Aa, za) <= Ka ? (ya(pa), !1) : !0
                      }, pageMiss: (pa, wa) => { ya(pa); 0 > this._indexQueue.indexOf(wa) && this._indexQueue.push(wa) }
                    }); return Ea
                }; U._getScale = function (X) { var Z = this._nodeScales.get(X); null == Z && (Z = this._index.getNode(X).obb.center, this._tmpPoint.x = Z[0], this._tmpPoint.y = Z[1], this._tmpPoint.z = Z[2], Z = this.view.basemapTerrain.getScale(this._tmpPoint), this._nodeScales.set(X, Z)); return Z }; U._computeAveragePixelArea =
                  function (X, Z, ia, la, ma) { X = Math.max(1E-7, T.minimumDistancePlane(X, la)); return Z / (X * X) / (4 * ma * ma) / ia }; U.loadNode = function (X, Z) { try { return this.loadNodeAsync(X, Z) } catch (ia) { throw n.isAbortError(ia) || ka.error(ia), ia; } }; U.loadAdditionalUserAttributes = function () {
                    var X = a._asyncToGenerator(function* (Z, ia, la) {
                      var ma = this.layer.outFields; if (!ma) return []; ma = H.unpackFieldNames(this.layer.fieldsIndex, ma); Z = new Set(Z.map(za => y.isSome(za) ? za.name : null)); const ra = this.layer.attributeStorageInfo, Aa = []; for (const za of ma) Z.has(za) ||
                        (ma = G.getAttributeInfo(ra, za)) && Aa.push(ia(ma)); ia = yield n.eachAlwaysValues(Aa); n.throwIfAborted(la); return y.mapSome(ia, za => za)
                    }); return function (Z, ia, la) { return X.apply(this, arguments) }
                  }(); U.loadNodeAsync = function () {
                    var X = a._asyncToGenerator(function* (Z, ia) {
                      var la = this; const ma = this._index.getNode(Z), ra = G.getRendererInfo(this.layer), Aa = G.getFilterInfo(this.layer), za = ma.resourceId, Ka = function () {
                        var Ea = a._asyncToGenerator(function* (Ua) {
                          if (y.isNone(Ua)) return null; if (Ua.useElevation) return {
                            attributeInfo: Ua,
                            buffer: null
                          }; const Na = yield la._loadAttribute(za, Ua, ia); return y.isSome(Na) ? { attributeInfo: Ua, buffer: Na } : null
                        }); return function (Ua) { return Ea.apply(this, arguments) }
                      }(); return this._idleQueue.push(a._asyncToGenerator(function* () {
                        var Ea = la._loadGeometry(za, ia); const { primaryAttribute: Ua, modulationAttribute: Na } = ra, ya = Ka(Ua), pa = Ka(Na); var wa = Aa.map(Ja => Ja.attributeInfo); const Ia = wa.map(Ja => Ka(Ja)); wa = la.loadAdditionalUserAttributes([Ua, Na, ...wa], Ka, ia); const [Ha, Oa, Ba, sa, Ca] = yield Promise.all([Ea, ya,
                          pa, Promise.all(Ia), wa]); n.throwIfAborted(ia); Ea = { geometryBuffer: Ha, primaryAttributeData: Oa, modulationAttributeData: Ba, filterAttributesData: sa, userAttributesData: Ca, schema: la.layer.store.defaultGeometrySchema, rendererInfo: ra, filterInfo: Aa, obb: la._index.getRenderObb(Z), elevationOffset: la._elevationOffset, inSR: la.layer.spatialReference.toJSON(), outSR: la.view.renderCoordsHelper.spatialReference.toJSON() }; return la._worker.invoke(Ea, ia)
                      }), ia)
                    }); return function (Z, ia) { return X.apply(this, arguments) }
                  }();
            U._loadGeometry = function () { var X = a._asyncToGenerator(function* (Z, ia) { return this._requestData(`${this.baseUrl}/nodes/${Z}/geometries/0`, ia) }); return function (Z, ia) { return X.apply(this, arguments) } }(); U._loadAttribute = function () { var X = a._asyncToGenerator(function* (Z, ia, la) { return y.isNone(ia) || !ia.storageInfo ? null : this._requestData(`${this.baseUrl}/nodes/${Z}/attributes/${ia.storageInfo.key}`, la) }); return function (Z, ia, la) { return X.apply(this, arguments) } }(); U._requestNodePage = function (X, Z) {
              return this._indexRequester.request(X,
                "json", { query: { f: "json", token: this.layer.apiKey }, signal: Z })
            }; U._requestData = function (X, Z) { return this._dataRequester.request(X, "binary", { query: { token: this.layer.apiKey }, signal: Z }) }; U._removeFromRenderer = function (X) { if (this._renderedNodes.has(X)) { const Z = this._renderer.removeNode(X); this._renderedNodes.delete(X); this._nodeScales.delete(X); this._memCache.put(Z.id.toString(), Z, 5 * Z.coordinates.length + 128) } }; U._addToRenderer = function (X) { this._renderedNodes.has(X.id) || (this._renderedNodes.add(X.id), this._renderer.addNode(X)) };
            U._setupRendererData = function (X, Z) {
              const ia = this._index.getNode(X), la = Math.sqrt(ia.lodThreshold / ia.vertexCount), ma = this._index.getRenderObb(X); if (R.PointRenderer.isInstanceOfNode(Z)) return Z.splatSize = la, Z.obb = ma, Z.origin = e.clone(Z.obb.center), Z; var ra = .01 * Math.max(ma.halfSize[0], ma.halfSize[1], ma.halfSize[2]); if (Z.obb.halfSize[0] > ma.halfSize[0] + ra || Z.obb.halfSize[1] > ma.halfSize[1] + ra || Z.obb.halfSize[2] > ma.halfSize[2] + ra) 0 < this._maxLoggedBoxWarnings && (ra = Aa => `[${Aa.halfSize[0]}, ${Aa.halfSize[1]}, ${Aa.halfSize[2]}]`,
                ka.warn(`Node ${X} reported bounding box too small. got ${ra(ma)} but points cover ${ra(Z.obb)}`), 0 === --this._maxLoggedBoxWarnings && ka.warn("  Too many bounding box errors, stopping reporting for this layer.")), this._index.setRenderObb(X, Z.obb); return { id: X, coordinates: Z.points, origin: e.clone(ma.center), rgb: Z.rgb, attributes: Z.attributes, pointIdFilterMap: Z.pointIdFilterMap, highlights: null, splatSize: la, obb: ma, isLeaf: 0 === ia.childCount }
            }; U.getUsedMemory = function () {
              let X = 0; this._renderer.forEachNode(Z => { X += 160; X += l.estimateSize(Z.coordinates); for (const ia of Z.attributes) Z = ia.values, l.isArrayBuffer(Z.buffer) && (X += l.estimateSize(Z)) }); return X
            }; U.getUnloadedMemory = function () {
              var X = this._renderedNodes.size; if (4 > X) return 0; const Z = [...this._renderedNodes].reduce((ma, ra) => ma + this._index.getNode(ra).vertexCount); let ia = this._loadingNodes.size; for (var la = 0; la < this._workQueue.length; la++)ia += this._workQueue[la].load.length, ia -= this._workQueue[la].remove.length; if (0 > ia) return 0; la = ia * Z / X; X = (this.getUsedMemory() -
                160 * X) / Z; return la * X + 160 * ia
            }; U.ignoresMemoryFactor = function () { return !1 }; a._createClass(W, [{ key: "pointScale", get: function () { const X = G.getSplatSizeAlgorithm(this.layer && this.layer.renderer); return X && null != X.scaleFactor ? X.scaleFactor : 1 } }, { key: "useRealWorldSymbolSizes", get: function () { const X = G.getFixedSizeAlgorithm(this.layer && this.layer.renderer); return X && null != X.useRealWorldSymbolSizes ? X.useRealWorldSymbolSizes : !1 } }, {
              key: "pointSize", get: function () {
                const X = G.getFixedSizeAlgorithm(this.layer && this.layer.renderer);
                return X && null != X.size ? X.size : 0
              }
            }, { key: "inverseDensity", get: function () { return this.layer && this.layer.renderer ? 96 / this.layer.renderer.pointsPerInch : 5 } }, {
              key: "availableFields", get: function () {
                var X = G.getRendererInfo(this.layer); const Z = new Set; X.primaryAttribute && Z.add(X.primaryAttribute.name); X.modulationAttribute && Z.add(X.primaryAttribute.name); if (X = G.getFilterInfo(this.layer)) for (const ia of X) Z.add(ia.attributeInfo.name); if (this.layer.outFields) for (const ia of H.unpackFieldNames(this.layer.fieldsIndex,
                  this.layer.outFields)) Z.add(ia); return Array.from(Z)
              }
            }, { key: "_clippingBox", get: function () { if (!this.view || !this.view.clippingArea) return null; const X = x.create(); return Q.projectToBoundingBox(this.view.clippingArea, X, this.view.renderSpatialReference) ? X : null } }, {
              key: "_elevationOffset", get: function () {
                const X = this.layer && this.layer.elevationInfo; if (X && "absolute-height" === X.mode) {
                  const Z = h.getMetersPerVerticalUnitForSR(this.layer.spatialReference), ia = M.getMetersPerUnit(X.unit); return y.unwrapOr(X.offset,
                    0) * ia / Z
                } return 0
              }
            }, { key: "running", get: function () { return this.suspended ? this._updateViewNeeded : this._updateViewNeeded || 0 < this._indexQueue.length || 0 < this._workQueue.length || this._idleQueue.running } }, { key: "updatingProgressValue", get: function () { if (this.suspended) return this._updateViewNeeded ? 0 : 1; const X = this._computeWork(); return 1 - Math.min(this._totalWork, X) / this._totalWork } }, {
              key: "performanceInfo", get: function () {
                return {
                  nodes: this._renderedNodes.size, displayedNumberOfFeatures: [...this._renderedNodes].reduce((X,
                    Z) => X + this._index.getNode(Z).vertexCount, 0), maximumNumberOfFeatures: this.maximumPointCount, totalNumberOfFeatures: -1, core: null, "Loading Nodes": this._loadingNodes.size, "Index Queue": this._indexQueue.length, "Work Queue": this._workQueue.length, "Idle Queue": this._idleQueue.length
                }
              }
            }, { key: "test", get: function () { return { index: this._index, visibleNodes: this._renderedNodes } } }]); return W
          }(S.PopupSceneLayerView(F.LayerView3D(Y))); w.__decorate([b.property()], u.prototype, "layer", void 0); w.__decorate([b.property({
            readOnly: !0,
            aliasOf: "layer.parsedUrl.path"
          })], u.prototype, "baseUrl", void 0); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "pointScale", null); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "useRealWorldSymbolSizes", null); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "pointSize", null); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "inverseDensity", null); w.__decorate([b.property()], u.prototype, "maximumPointCount", void 0); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "availableFields",
            null); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "_clippingBox", null); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "_elevationOffset", null); w.__decorate([b.property({ type: Boolean })], u.prototype, "slicePlaneEnabled", void 0); w.__decorate([b.property()], u.prototype, "updating", void 0); w.__decorate([b.property(da.updatingProgress)], u.prototype, "updatingProgress", void 0); w.__decorate([b.property({ readOnly: !0 })], u.prototype, "updatingProgressValue", null); u = w.__decorate([v.subclass("esri.views.3d.layers.PointCloudLayerView3D")],
              u); const ba = k.create(); return u
        })
    }, "esri/views/3d/layers/PointCloudWorkerHandle": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/maybe", "../../../core/workers/WorkerHandle"], function (a, w, c, q) {
        q = function (u) {
          function y(n) { return u.call(this, "PointCloudWorker", "transform", n) || this } w._inheritsLoose(y, u); y.prototype.getTransferList = function (n) {
            const p = [n.geometryBuffer]; c.isSome(n.primaryAttributeData) && n.primaryAttributeData.buffer && p.push(n.primaryAttributeData.buffer);
            c.isSome(n.modulationAttributeData) && n.modulationAttributeData.buffer && p.push(n.modulationAttributeData.buffer); if (c.isSome(n.filterAttributesData)) for (const l of n.filterAttributesData) c.isSome(l) && l.buffer && p.push(l.buffer); for (const l of n.userAttributesData) l.buffer && p.push(l.buffer); return p
          }; return y
        }(q.WorkerHandle); a.PointCloudWorkerHandle = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/I3SUtil": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../request ../../../../core/arrayUtils ../../../../core/Error ../../../../core/has ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/typedArrayUtil ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/quat ../../../../chunks/quatf32 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/projectionEllipsoid ../../../../geometry/SpatialReference ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/spatialReferenceUtils ../../../../rest/support/Query ./I3SBinaryReader ./I3SProjectionUtil ../support/edgeUtils ../support/symbolColorUtils ../../support/orientedBoundingBox".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J) {
          function M(ya) { return ya && parseInt(ya.substring(ya.lastIndexOf("/") + 1, ya.length), 10) } function F(ya, pa) { var wa = pa[0], Ia = pa[1]; pa = pa[3]; const Ha = ya[0] - wa; wa -= ya[2]; const Oa = ya[1] - Ia; ya = Ia - ya[3]; Ia = Math.max(Ha, wa, 0); const Ba = Math.max(Oa, ya, 0); Ia = Ia * Ia + Ba * Ba; return Ia > pa * pa ? 0 : 0 < Ia ? 1 : -Math.max(Ha, wa, Oa, ya) > pa ? 3 : 2 } function K(ya, pa, wa) {
            const Ia = [], Ha = wa && wa.missingFields; wa = wa && wa.originalFields; for (const Oa of ya) {
              ya = Oa.toLowerCase(); let Ba =
                !1; for (const sa of pa) if (ya === sa.name.toLowerCase()) { Ia.push(sa.name); Ba = !0; wa && wa.push(Oa); break } !Ba && Ha && Ha.push(Oa)
            } return Ia
          } function P() {
            P = w._asyncToGenerator(function* (ya, pa, wa, Ia, Ha) {
              if (0 === pa.length) return []; const Oa = ya.attributeStorageInfo; if (n.isSome(ya.associatedLayer)) try { return yield N(ya.associatedLayer, pa, wa, Ia) } catch (Ba) { if (ya.associatedLayer.loaded) throw Ba; } if (Oa) {
                pa = L(pa, wa, Ha); if (n.isNone(pa)) throw new u("scenelayer:features-not-loaded", "Tried to query attributes for unloaded features");
                const Ba = ya.parsedUrl.path; ya = yield Promise.all(pa.map(sa => O(Ba, Oa, sa.node, sa.indices, Ia).then(Ca => { for (let Ja = 0; Ja < sa.graphics.length; Ja++) { const ca = sa.graphics[Ja], qa = Ca[Ja]; if (ca.attributes) for (const Da in ca.attributes) Da in qa || (qa[Da] = ca.attributes[Da]); ca.attributes = qa } return sa.graphics }))); return q.flatten(ya)
              } throw new u("scenelayer:no-attribute-source", "This scene layer does not have a source for attributes available");
            }); return P.apply(this, arguments)
          } function L(ya, pa, wa) {
            const Ia = new Map,
            Ha = []; wa = wa(); for (const sa of ya) { var Oa = sa.attributes[pa]; for (var Ba = 0; Ba < wa.length; Ba++) { ya = wa[Ba]; const Ca = ya.featureIds.indexOf(Oa); if (0 <= Ca) { Oa = Ia.get(ya.node); Oa || (Oa = { node: ya.node, indices: [], graphics: [] }, Ha.push(Oa), Ia.set(ya.node, Oa)); Oa.indices.push(Ca); for (Oa.graphics.push(sa); 0 < Ba; Ba--)wa[Ba] = wa[Ba - 1]; wa[0] = ya; break } } } return Ha
          } function N(ya, pa, wa, Ia) { return G.apply(this, arguments) } function G() {
            G = w._asyncToGenerator(function* (ya, pa, wa, Ia) {
              pa.sort((Ba, sa) => Ba.attributes[wa] - sa.attributes[wa]);
              var Ha = pa.map(Ba => Ba.attributes[wa]); const Oa = []; Ia = K(Ia, ya.fields, { originalFields: Oa }); ya = yield I(ya, Ha, Ia); for (Ha = 0; Ha < pa.length; Ha++) { const Ba = pa[Ha], sa = ya[Ha], Ca = {}; if (Ba.attributes) for (const Ja in Ba.attributes) Ca[Ja] = Ba.attributes[Ja]; for (let Ja = 0; Ja < Oa.length; Ja++)Ca[Oa[Ja]] = sa[Ia[Ja]]; Ba.attributes = Ca } return pa
            }); return G.apply(this, arguments)
          } function I(ya, pa, wa) {
            var Ia = ya.capabilities.query.maxRecordCount; if (null != Ia && pa.length > Ia) return Ia = q.splitIntoChunks(pa, Ia), Promise.all(Ia.map(Ha =>
              I(ya, Ha, wa))).then(q.flatten); Ia = new B({ objectIds: pa, outFields: wa, orderByFields: [ya.objectIdField] }); return ya.queryFeatures(Ia).then(Ha => { if (Ha && Ha.features && Ha.features.length === pa.length) return Ha.features.map(Oa => Oa.attributes); throw new u("scenelayer:feature-not-in-associated-layer", "Feature not found in associated feature layer"); })
          } function O(ya, pa, wa, Ia, Ha) {
            const Oa = []; for (const Ba of pa) Ba && -1 !== Ha.indexOf(Ba.name) && Oa.push({
              url: `${ya}/nodes/${wa.resources.attributes}/attributes/${Ba.key}/0`,
              storageInfo: Ba
            }); return p.eachAlways(Oa.map(Ba => c(Ba.url, { responseType: "array-buffer" }).then(sa => C.readBinaryAttribute(Ba.storageInfo, sa.data)))).then(Ba => { const sa = []; for (const Ca of Ia) { const Ja = {}; for (let ca = 0; ca < Ba.length; ca++)null != Ba[ca].value && (Ja[Oa[ca].storageInfo.name] = R(Ba[ca].value, Ca)); sa.push(Ja) } return sa })
          } function R(ya, pa) { if (!ya) return null; pa = ya[pa]; return l.isInt16Array(ya) ? -32768 === pa ? null : pa : l.isInt32Array(ya) ? pa === ba ? null : pa : pa !== pa ? null : pa } function S(ya) {
            var pa = ya.store.indexCRS ||
              ya.store.geographicCRS; const wa = void 0 === pa ? ya.store.indexWKT : void 0; if (wa) if (ya.spatialReference) { if (wa !== ya.spatialReference.wkt) throw new u("layerview:store-spatial-reference-wkt-index-incompatible", "The indeWKT of the scene layer store does not match the WKT of the layer spatial reference", {}); } else throw new u("layerview:no-store-spatial-reference-wkt-index-and-no-layer-spatial-reference", "Found indeWKT in the scene layer store but no layer spatial reference", {}); pa = pa ? new r(M(pa)) : ya.spatialReference;
            return pa.equals(ya.spatialReference) ? ya.spatialReference : pa
          } function Q(ya) {
            var pa = ya.store.vertexCRS || ya.store.projectedCRS; const wa = void 0 === pa ? ya.store.vertexWKT : void 0; if (wa) if (ya.spatialReference) { if (wa !== ya.spatialReference.wkt) throw new u("layerview:store-spatial-reference-wkt-vertex-incompatible", "The vertexWKT of the scene layer store does not match the WKT of the layer spatial reference", {}); } else throw new u("layerview:no-store-spatial-reference-wkt-vertex-and-no-layer-spatial-reference",
              "Found vertexWKT in the scene layer store but no layer spatial reference", {}); pa = pa ? new r(M(pa)) : ya.spatialReference; return pa.equals(ya.spatialReference) ? ya.spatialReference : pa
          } function T(ya, pa, wa) {
            if (!x.canProjectWithoutEngine(ya, pa)) throw new u("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {}); if ("local" === wa && !da(ya, pa)) throw new u("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view",
              {});
          } function da(ya, pa) { return ya.equals(pa) || ya.isWGS84 && pa.isWebMercator || ya.isWebMercator && pa.isWGS84 } function Y(ya, pa, wa) { const Ia = S(ya); ya = Q(ya); T(Ia, pa, wa); T(ya, pa, wa) } function fa(ya, pa, wa, Ia, Ha = 0) {
            if (Ia === k.getSphericalPCPF(Ia)) if (pa.isGeographic) {
              var Oa = k.getReferenceEllipsoid(pa); Ia = 1 + Math.max(0, Ha) / (Oa.radius + ya.center[2]); m.set(wa.center, ya.center[0], ya.center[1], ya.center[2] + Ha); x.projectBuffer(wa.center, pa, 0, wa.center, k.getSphericalPCPF(pa), 0, 1); t.copy(wa.quaternion, ya.quaternion); t.conjugate(ma,
                ya.quaternion); m.set(Ea, 0, 0, 1); m.transformQuat(Ea, Ea, ma); m.set(Ea, ya.halfSize[0] * Math.abs(Ea[0]), ya.halfSize[1] * Math.abs(Ea[1]), ya.halfSize[2] * Math.abs(Ea[2])); m.scale(Ea, Ea, Oa.inverseFlattening); m.add(wa.halfSize, ya.halfSize, Ea); m.scale(wa.halfSize, wa.halfSize, Ia)
            } else {
              {
                J.corners(ya, ra); m.set(wa.center, ya.center[0], ya.center[1], ya.center[2] + Ha); x.computeTranslationToOriginAndRotation(pa, wa.center, la, k.getSphericalPCPF(pa)); m.set(wa.center, la[12], la[13], la[14]); Ia = 2 * Math.sqrt(1 + la[0] + la[5] + la[10]);
                ma[0] = (la[6] - la[9]) / Ia; ma[1] = (la[8] - la[2]) / Ia; ma[2] = (la[1] - la[4]) / Ia; ma[3] = .25 * Ia; t.multiply(wa.quaternion, ma, ya.quaternion); t.conjugate(ma, wa.quaternion); let Ba = Ia = ya = 0; for (Oa of ra) Oa[2] += Ha, x.projectBuffer(Oa, pa, 0, Oa, k.getSphericalPCPF(pa), 0, 1), m.sub(Ea, Oa, wa.center), m.transformQuat(Ea, Ea, ma), ya = Math.max(ya, Math.abs(Ea[0])), Ia = Math.max(Ia, Math.abs(Ea[1])), Ba = Math.max(Ba, Math.abs(Ea[2])); m.set(wa.halfSize, ya, Ia, Ba)
              }
            } else pa.isWGS84 && (Ia.isWebMercator || z.isPlateCarree(Ia)) ? (m.copy(Z, ya.center), Z[2] +=
              Ha, Ha = k.getSphericalPCPF(Ia), x.projectBuffer(Z, pa, 0, Z, Ha, 0, 1), ha(Ha, ya, Z, Ia, wa)) : pa.isWebMercator && z.isPlateCarree(Ia) ? (m.copy(Z, ya.center), Z[2] += Ha, ha(pa, ya, Z, Ia, wa)) : ya === wa ? (wa.center[2] += Ha, x.projectBuffer(wa.center, pa, 0, wa.center, Ia, 0, 1)) : (m.set(wa.center, ya.center[0], ya.center[1], ya.center[2] + Ha), x.projectBuffer(wa.center, pa, 0, wa.center, Ia, 0, 1), t.copy(wa.quaternion, ya.quaternion), m.copy(wa.halfSize, ya.halfSize))
          } function ha(ya, pa, wa, Ia, Ha) {
            const Oa = h.fromQuat(ia, pa.quaternion); for (let sa = 0; 8 >
              sa; ++sa) { for (var Ba = 0; 3 > Ba; ++Ba)X[Ba] = pa.halfSize[Ba] * (0 !== (sa & 1 << Ba) ? -1 : 1); for (Ba = 0; 3 > Ba; ++Ba) { let Ca = wa[Ba]; for (let Ja = 0; 3 > Ja; ++Ja)Ca += X[Ja] * Oa[3 * Ja + Ba]; W[3 * sa + Ba] = Ca } } x.projectBuffer(W, ya, 0, W, Ia, 0, 8); J.compute(U, Ha)
          } const ka = A.create(), ea = g.create(), ba = -(2 ** 31); g = E.createSolidEdgeMaterial({ color: [0, 0, 0, 0], opacity: 0 }); let aa = function () { this.material = this.edgeMaterial = null; this.castShadows = !0 }; const W = new Float64Array(24), U = { data: W, size: 3 }, X = e.create(), Z = e.create(), ia = b.create(), la = f.create(), ma =
            v.create(), ra = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], Aa = A.create(), za = A.create(), Ka = J.create(), Ea = [0, 0, 0], Ua = { data: Array(72), size: 3 }, Na = f.create(); a.SymbolInfo = aa; a.addWraparound = function (ya, pa) { return (ya | 0) + (pa | 0) | 0 }; a.checkPointCloudLayerCompatibleWithView = function (ya, pa) { T(ya.spatialReference, pa.spatialReference, pa.viewingMode) }; a.checkPointCloudLayerValid = function (ya) {
              var pa; (pa = null == ya.store || null == ya.store.defaultGeometrySchema) || (ya = ya.store.defaultGeometrySchema,
                pa = !!(null == ya.geometryType || "points" !== ya.geometryType || null != ya.topology && "PerAttributeArray" !== ya.topology || null != ya.encoding && "" !== ya.encoding && "lepcc-xyz" !== ya.encoding || null == ya.vertexAttributes || null == ya.vertexAttributes.position)); if (pa) throw new u("pointcloud:unsupported-geometry-schema", "The geometry schema of this point cloud scene layer is not supported.", {});
            }; a.checkSceneLayerCompatibleWithView = function (ya, pa) { Y(ya, pa.spatialReference, pa.viewingMode) }; a.checkSceneLayerValid = function (ya) {
              var pa;
              (pa = null == ya.store || null == ya.store.defaultGeometrySchema) || (pa = ya.store.defaultGeometrySchema, pa = !!(null != pa.geometryType && "triangles" !== pa.geometryType || null != pa.topology && "PerAttributeArray" !== pa.topology || null == pa.vertexAttributes || null == pa.vertexAttributes.position)); if (pa) throw new u("scenelayer:unsupported-geometry-schema", "The geometry schema of this scene layer is not supported.", { url: ya.parsedUrl.path });
            }; a.checkSpatialReference = T; a.checkSpatialReferences = Y; a.computeVisibilityObb = function (ya,
              pa, wa, Ia, Ha, Oa) {
                if (!Oa || 0 === Oa.length || n.isNone(pa)) return null; const Ba = D.computeGlobalTransformation(ya.mbs, Ha, wa, pa); d.invert(Na, Ba); let sa; const Ca = () => {
                  if (!sa) if (sa = ra, A.empty(za), n.isSome(ya.serviceObb)) { fa(ya.serviceObb, wa, Ka, pa, Ha); J.corners(Ka, sa); for (var Da of sa) m.transformMat4(Da, Da, Na), A.expandPointInPlace(za, Da) } else {
                    var na = ya.mbs; Da = na[3]; x.projectVectorToVector(na, wa, Ea, pa); m.transformMat4(Ea, Ea, Na); Ea[2] += Ha; for (na = 0; 8 > na; ++na) {
                      const xa = sa[na]; m.copy(xa, [Ea[0] + (na & 1 ? Da : -Da), Ea[1] +
                        (na & 2 ? Da : -Da), Ea[2] + (na & 4 ? Da : -Da)]); A.expandPointInPlace(za, xa)
                    }
                  }
                }; let Ja = Infinity, ca = -Infinity; const qa = Da => { if ("replace" === Da.type && (Da = Da.geometry, Da.hasZ)) { A.empty(Aa); var na = Da.spatialReference || Ia; Da = Da.rings.reduce((xa, Qa) => Qa.reduce((Wa, Ra) => { x.projectVectorToVector(Ra, na, Ea, pa); m.transformMat4(Ea, Ea, Na); A.expandPointInPlace(Aa, Ea); return Math.min(Ea[2], Wa) }, xa), Infinity); Ca(); A.intersects(za, Aa) && (Ja = Math.min(Ja, Da), ca = Math.max(ca, Da)) } }; Oa.forEach(Da => qa(Da)); if (Infinity === Ja) return null;
              Oa = (Da, na, xa) => { m.transformMat4(Ea, xa, Ba); Da[na + 0] = Ea[0]; Da[na + 1] = Ea[1]; Da[na + 2] = Ea[2]; na += 24; xa[2] = Ja; m.transformMat4(Ea, xa, Ba); Da[na + 0] = Ea[0]; Da[na + 1] = Ea[1]; Da[na + 2] = Ea[2]; na += 24; xa[2] = ca; m.transformMat4(Ea, xa, Ba); Da[na + 0] = Ea[0]; Da[na + 1] = Ea[1]; Da[na + 2] = Ea[2] }; for (let Da = 0; 8 > Da; ++Da)Oa(Ua.data, 3 * Da, sa[Da]); return J.compute(Ua)
            }; a.containsDraco = function (ya) {
              if (y("disable-feature:i3s-draco") || !ya) return !1; for (const wa of ya) for (const Ia of wa.geometryBuffers) {
                var pa; if ("draco" === (null == (pa = Ia.compressedAttributes) ?
                  void 0 : pa.encoding)) return !0
              } return !1
            }; a.extractWkid = M; a.filterInPlace = function (ya, pa, wa) { let Ia = 0, Ha = 0; for (let Oa = 0; Oa < pa.length && Ia < ya.length; Oa++)ya[Ia] === pa[Oa] && (wa(Oa) && (ya[Ha] = ya[Ia], Ha++), Ia++); ya.length = Ha }; a.findFieldsCaseInsensitive = K; a.findIntersectingNodes = function (ya, pa, wa, Ia, Ha, Oa) { Ha.traverse(wa, Ba => { var sa = Ba.mbs; pa !== Ia && (sa = ea, x.projectBoundingSphere(Ba.mbs, Ia, sa, pa)); sa = F(ya, sa); if (0 === sa) return !1; Oa(Ba, sa); return !0 }) }; a.getCacheKeySuffix = function (ya, pa) {
              return n.isNone(pa) ? "@null" :
                pa === k.getSphericalPCPF(pa) ? "@ECEF" : ya.equals(pa) ? "" : null != pa.wkid ? "@" + pa.wkid : null
            }; a.getCachedAttributeValue = R; a.getClipRect = function (ya, pa) { if (0 === pa.rotationScale[1] && 0 === pa.rotationScale[2] && 0 === pa.rotationScale[3] && 0 === pa.rotationScale[5] && 0 === pa.rotationScale[6] && 0 === pa.rotationScale[7]) return ka[0] = (ya[0] - pa.position[0]) / pa.rotationScale[0], ka[1] = (ya[1] - pa.position[1]) / pa.rotationScale[4], ka[2] = (ya[2] - pa.position[0]) / pa.rotationScale[0], ka[3] = (ya[3] - pa.position[1]) / pa.rotationScale[4], ka };
          a.getIndexCrs = S; a.getSymbolInfo = function (ya) {
            const pa = new aa; var wa = !1; let Ia = !1; for (const Oa of ya.symbolLayers.items) if ("fill" === Oa.type && Oa.enabled) {
              var Ha = Oa.material; ya = Oa.edges; n.isSome(Ha) && !wa && (wa = Ha.color, Ha = H.parseColorMixMode(Ha.colorMixMode), n.isSome(wa) ? pa.material = { color: [wa.r / 255, wa.g / 255, wa.b / 255], alpha: wa.a, colorMixMode: Ha } : pa.material = { color: [1, 1, 1], alpha: 1, colorMixMode: 1 }, pa.castShadows = Oa.castShadows, wa = !0); n.isSome(ya) && !Ia && (pa.edgeMaterial = E.createMaterialFromEdges(ya, {}),
                Ia = !0)
            } pa.material || (pa.material = { color: [1, 1, 1], alpha: 1, colorMixMode: 1 }); return pa
          }; a.getVertexCrs = Q; a.intersectBoundingBoxWithMbs = function (ya, pa) { var wa = pa[0], Ia = pa[1], Ha = pa[2]; pa = pa[3]; const Oa = ya[0] - wa; wa -= ya[3]; const Ba = ya[1] - Ia; Ia -= ya[4]; const sa = ya[2] - Ha; ya = Ha - ya[5]; Ha = Math.max(Oa, wa, 0); const Ca = Math.max(Ba, Ia, 0), Ja = Math.max(sa, ya, 0); Ha = Ha * Ha + Ca * Ca + Ja * Ja; return Ha > pa * pa ? 0 : 0 < Ha ? 1 : -Math.max(Oa, wa, Ba, Ia, sa, ya) > pa ? 3 : 2 }; a.intersectBoundingRectWithMbs = F; a.isSupportedLocalModeProjection = da; a.objectIdFilter =
            function (ya, pa, wa) { let Ia = 0, Ha = 0; for (; Ia < wa.length;)0 <= q.binaryIndexOf(ya, wa[Ia]) === pa && (wa[Ha] = wa[Ia], Ha++), Ia++; wa.length = Ha }; a.rendererNeedsTextures = function (ya) {
              if (null == ya || "simple" !== ya.type && "class-breaks" !== ya.type && "unique-value" !== ya.type || ("unique-value" === ya.type || "class-breaks" === ya.type) && null == ya.defaultSymbol) return !0; ya = ya.getSymbols(); if (0 === ya.length) return !0; for (const pa of ya) {
                if ("mesh-3d" !== pa.type || 0 === pa.symbolLayers.length) return !0; for (const wa of pa.symbolLayers.items) if ("fill" !==
                  wa.type || n.isNone(wa.material) || n.isNone(wa.material.color) || "replace" !== wa.material.colorMixMode) return !0
              } return !1
            }; a.transformObb = fa; a.transparentEdgeMaterial = g; a.whenGraphicAttributes = function (ya, pa, wa, Ia, Ha) { return P.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SBinaryReader": function () {
      define(["exports", "../../../../core/Error", "../../../../core/lang", "../../../../core/Logger", "./LEPCC"], function (a, w, c, q, u) {
        function y(A, z, B) {
          let C = "",
          D = 0; for (; D < B;) {
            var E = A[z + D]; if (128 > E) C += String.fromCharCode(E), D++; else if (192 <= E && 224 > E) { if (D + 1 >= B) throw new w("utf8-decode-error", "UTF-8 Decode failed. Two byte character was truncated."); C += String.fromCharCode((E & 31) << 6 | A[z + D + 1] & 63); D += 2 } else if (224 <= E && 240 > E) { if (D + 2 >= B) throw new w("utf8-decode-error", "UTF-8 Decode failed. Multi byte character was truncated."); C += String.fromCharCode((E & 15) << 12 | (A[z + D + 1] & 63) << 6 | A[z + D + 2] & 63); D += 3 } else if (240 <= E && 248 > E) {
              if (D + 3 >= B) throw new w("utf8-decode-error", "UTF-8 Decode failed. Multi byte character was truncated.");
              E = (E & 7) << 18 | (A[z + D + 1] & 63) << 12 | (A[z + D + 2] & 63) << 6 | A[z + D + 3] & 63; C = 65536 <= E ? C + String.fromCharCode((E - 65536 >> 10) + 55296, (E & 1023) + 56320) : C + String.fromCharCode(E); D += 4
            } else throw new w("utf8-decode-error", "UTF-8 Decode failed. Invalid multi byte sequence.");
          } return C
        } function n(A, z) { const B = { byteOffset: 0, byteCount: 0, fields: Object.create(null) }; let C = 0; for (let D = 0; D < z.length; D++) { const E = z[D], H = E.valueType || E.type; B.fields[E.property] = (0, r[H])(A, C); C += k[H].BYTES_PER_ELEMENT } B.byteCount = C; return B } function p(A,
          z, B) { const C = []; let D, E = 0, H; for (H = 0; H < A; H += 1) { D = z[H]; if (0 < D) { if (C.push(y(B, E, D - 1)), 0 !== B[E + D - 1]) throw new w("string-array-error", "Invalid string array: missing null termination."); } else C.push(null); E += D } return C } function l(A, z) { return new k[z.valueType](A, z.byteOffset, z.count * z.valuesPerElement) } function h(A, z) { return new Uint8Array(A, z.byteOffset, z.byteCount) } function b(A, z, B) {
            A = null != z.header ? n(A, z.header) : { byteOffset: 0, byteCount: 0, fields: { count: B } }; B = {
              header: A, byteOffset: A.byteCount, byteCount: 0,
              entries: Object.create(null)
            }; let C = A.byteCount; for (let D = 0; D < z.ordering.length; D++) {
              const E = z.ordering[D], H = c.clone(z[E]); H.count = A.fields.count; if ("String" === H.valueType) { if (H.byteOffset = C, H.byteCount = A.fields[E + "ByteCount"], "UTF-8" !== H.encoding) throw new w("unsupported-encoding", "Unsupported String encoding.", { encoding: H.encoding }); } else if (m(H.valueType)) { const J = e(H.valueType); C += 0 !== C % J ? J - C % J : 0; H.byteOffset = C; H.byteCount = J * H.valuesPerElement * H.count } else throw new w("unsupported-value-type",
                "Unsupported binary valueType", { valueType: H.valueType }); C += H.byteCount; B.entries[E] = H
            } B.byteCount = C - B.byteOffset; return B
          } function d(A, z, B) { z !== A && g.error(`Invalid ${B} buffer size\n expected: ${A}, actual: ${z})`); if (z < A) throw new w("buffer-too-small", "Binary buffer is too small", { expectedSize: A, actualSize: z }); } function f(A) { return { isDraco: !1, isLegacy: !1, color: null != A.color, normal: null != A.normal, uv0: null != A.uv0, uvRegion: null != A.uvRegion, featureIndex: null != A.faceRange && null != A.featureId } } function t(A) {
            const z =
              { isDraco: !1, isLegacy: !0, color: !1, normal: !1, uv0: !1, uvRegion: !1, featureIndex: !1 }; for (const B of A.ordering) if (A.vertexAttributes[B]) switch (B) { case "normal": z.normal = !0; break; case "color": z.color = !0; break; case "uv0": z.uv0 = !0; break; case "region": z.uvRegion = !0 }A.featureAttributes && A.featureAttributeOrder && (z.featureIndex = !0); return z
          } function v(A) {
            const z = { isDraco: !0, isLegacy: !1, color: !1, normal: !1, uv0: !1, uvRegion: !1, featureIndex: !1 }; for (const B of A) switch (B) {
              case "normal": z.normal = !0; break; case "uv0": z.uv0 =
                !0; break; case "color": z.color = !0; break; case "uv-region": z.uvRegion = !0; break; case "feature-index": z.featureIndex = !0
            }return z
          } function m(A) { return k.hasOwnProperty(A) } function e(A) { return m(A) ? k[A].BYTES_PER_ELEMENT : 0 } const g = q.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader"), x = { position: "position", normal: "normal", color: "color", uv0: "uv0", region: "uvRegion" }, k = { Float32: Float32Array, Float64: Float64Array, UInt8: Uint8Array, Int8: Int8Array, UInt16: Uint16Array, Int16: Int16Array, UInt32: Uint32Array, Int32: Int32Array },
            r = { Float32: (A, z) => (new DataView(A, 0)).getFloat32(z, !0), Float64: (A, z) => (new DataView(A, 0)).getFloat64(z, !0), UInt8: (A, z) => (new DataView(A, 0)).getUint8(z), Int8: (A, z) => (new DataView(A, 0)).getInt8(z), UInt16: (A, z) => (new DataView(A, 0)).getUint16(z, !0), Int16: (A, z) => (new DataView(A, 0)).getInt16(z, !0), UInt32: (A, z) => (new DataView(A, 0)).getUint32(z, !0), Int32: (A, z) => (new DataView(A, 0)).getInt32(z, !0) }; a.createAttributeDataIndex = b; a.createGeometryDescriptor = function (A, z) {
              return A && A.compressedAttributes && "draco" ===
                A.compressedAttributes.encoding ? v(A.compressedAttributes.attributes) : A ? f(A) : t(z)
            }; a.createGeometryDescriptorForDraco = v; a.createGeometryDescriptorFromDefinition = f; a.createGeometryDescriptorFromSchema = t; a.createGeometryIndexFromSchema = function (A, z) {
              var B = n(A, z && z.header); let C = B.byteCount; const D = { isDraco: !1, header: B, byteOffset: B.byteCount, byteCount: 0, vertexAttributes: {} }; B = B.fields; var E = null != B.vertexCount ? B.vertexCount : B.count; for (var H of z.ordering) {
                if (!z.vertexAttributes[H]) continue; const M = {
                  ...z.vertexAttributes[H],
                  byteOffset: C, count: E
                }; D.vertexAttributes[x[H] ? x[H] : "_" + H] = M; C += e(M.valueType) * M.valuesPerElement * E
              } H = B.faceCount; if (z.faces && H) { D.faces = {}; for (var J of z.ordering) z.faces[J] && (E = { ...z.faces[J], byteOffset: C, count: H }, D.faces[J] = E, C += e(E.valueType) * E.valuesPerElement * H) } J = B.featureCount; if (z.featureAttributes && z.featureAttributeOrder && J) {
              D.featureAttributes = {}; for (const M of z.featureAttributeOrder) z.featureAttributes[M] && (B = { ...z.featureAttributes[M], byteOffset: C, count: J }, D.featureAttributes[M] = B, H =
                "UInt64" === B.valueType ? 8 : e(B.valueType), C += H * B.valuesPerElement * J)
              } d(C, A.byteLength, "geometry"); D.byteCount = C - D.byteOffset; return D
            }; a.createRawView = h; a.createTypedView = l; a.getBytesPerValue = e; a.isValueType = m; a.readBinaryAttribute = function (A, z, B) {
              if ("lepcc-rgb" === A.encoding) return u.decodeRGB(z); if ("lepcc-intensity" === A.encoding) return u.decodeIntensity(z); if (null != A.encoding && "" !== A.encoding) throw new w("unknown-attribute-storage-info-encoding", "Unknown Attribute Storage Info Encoding"); A["attributeByteCounts "] &&
                !A.attributeByteCounts && (g.warn("Warning: Trailing space in 'attributeByteCounts '."), A.attributeByteCounts = A["attributeByteCounts "]); "ObjectIds" === A.ordering[0] && A.hasOwnProperty("objectIds") && (g.warn("Warning: Case error in objectIds"), A.ordering[0] = "objectIds"); B = b(z, A, B); d(B.byteOffset + B.byteCount, z.byteLength, "attribute"); if (A = B.entries.attributeValues || B.entries.objectIds) { if ("String" === A.valueType) { B = B.entries.attributeByteCounts; const C = l(z, B); z = h(z, A); return p(B.count, C, z) } return l(z, A) } throw new w("bad-attribute-storage-info",
                  "Bad attributeStorageInfo specification.");
            }; a.readHeader = n; a.readStringArray = p; a.valueType2ArrayBufferReader = r; a.valueType2TypedArrayClassMap = k; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/LEPCC": function () {
      define(["exports", "../../../../core/Error"], function (a, w) {
        function c(n, p, l) {
          return {
            identifier: String.fromCharCode.apply(null, new Uint8Array(n, l + y.identifierOffset, y.identifierLength)), version: p.getUint16(l + y.versionOffset, !0), checksum: p.getUint32(l + y.checksumOffset,
              !0)
          }
        } function q(n, p, l) { const h = []; p = u(n, p, h); const b = []; for (let d = 0; d < h.length; d++) { b.length = 0; p = u(n, p, b); for (let f = 0; f < b.length; f++)l.push(b[f] + h[d]) } return p } function u(n, p, l) {
          var h = new DataView(n, p), b = h.getUint8(0); const d = b & 31; var f = !!(b & 32), t = (b & 192) >> 6; b = 0; if (0 === t) b = h.getUint32(1, !0), p += 5; else if (1 === t) b = h.getUint16(1, !0), p += 3; else if (2 === t) b = h.getUint8(1), p += 2; else throw new w("lepcc-decode-error", "Bad count type"); if (f) throw new w("lepcc-decode-error", "LUT not implemented"); n = new Uint8Array(n,
            p, Math.ceil(b * d / 8)); t = f = h = 0; const v = -1 >>> 32 - d; for (let m = 0; m < b; m++) { for (; f < d;)h |= n[t] << f, f += 8, t += 1; l[m] = h & v; h >>>= d; f -= d; 32 < f + d && (h |= n[t - 1] >> 8 - f) } return p + t
        } const y = { identifierOffset: 0, identifierLength: 10, versionOffset: 10, checksumOffset: 12, byteCount: 16 }; a.decodeIntensity = function (n) {
          const p = new DataView(n, 0); var l = 0; const { identifier: h, version: b } = c(n, p, l); l += y.byteCount; if ("Intensity " !== h) throw new w("lepcc-decode-error", "Bad identifier"); if (1 < b) throw new w("lepcc-decode-error", "Unknown version");
          var d = l; var f = p.getUint32(d + 0, !0); var t = p.getUint32(d + 4, !0); var v = p.getUint32(d + 8, !0); var m = p.getUint16(d + 12, !0); var e = p.getUint8(d + 14); p.getUint8(d + 15); l += 16; if (t * 2 ** 32 + f !== n.byteLength) throw new w("lepcc-decode-error", "Bad size"); f = new Uint16Array(v); if (8 === e) { if (v + l !== n.byteLength) throw new w("lepcc-decode-error", "Bad size"); n = new Uint8Array(n, l, v); for (l = 0; l < v; l++)f[l] = n[l] * m } else if (16 === e) {
            if (2 * v + l !== n.byteLength) throw new w("lepcc-decode-error", "Bad size"); n = new Uint16Array(n, l, v); for (l = 0; l <
              v; l++)f[l] = n[l] * m
          } else { e = []; if (u(n, l, e) !== n.byteLength) throw new w("lepcc-decode-error", "Bad size"); for (n = 0; n < v; n++)f[n] = e[n] * m } return f
        }; a.decodeRGB = function (n) {
          var p = new DataView(n, 0), l = 0; const { identifier: h, version: b } = c(n, p, l); l += y.byteCount; if ("ClusterRGB" !== h) throw new w("lepcc-decode-error", "Bad identifier"); if (1 < b) throw new w("lepcc-decode-error", "Unknown version"); var d = l; var f = p.getUint32(d + 0, !0); var t = p.getUint32(d + 4, !0); var v = p.getUint32(d + 8, !0); var m = p.getUint16(d + 12, !0); var e = p.getUint8(d +
            14); d = p.getUint8(d + 15); l += 16; if (t * 2 ** 32 + f !== n.byteLength) throw new w("lepcc-decode-error", "Bad size"); if ((2 === e || 1 === e) && 0 === d) { if (3 * m + v + l !== n.byteLength || 256 < m) throw new w("lepcc-decode-error", "Bad count"); p = new Uint8Array(n, l, 3 * m); l = new Uint8Array(n, l + 3 * m, v); n = new Uint8Array(3 * v); for (m = 0; m < v; m++)f = l[m], n[3 * m] = p[3 * f], n[3 * m + 1] = p[3 * f + 1], n[3 * m + 2] = p[3 * f + 2]; return n } if (0 === e && 0 === d) { if (3 * v + l !== n.byteLength || 0 !== m) throw new w("lepcc-decode-error", "Bad count"); return (new Uint8Array(n, l)).slice() } if (2 >=
              e && 1 === d) { if (l + 3 !== n.byteLength || 1 !== m) throw new w("lepcc-decode-error", "Bad count"); n = p.getUint8(l); m = p.getUint8(l + 1); l = p.getUint8(l + 2); p = new Uint8Array(3 * v); for (f = 0; f < v; f++)p[3 * f] = n, p[3 * f + 1] = m, p[3 * f + 2] = l; return p } throw new w("lepcc-decode-error", "Bad method " + e + "," + d);
        }; a.decodeXYZ = function (n) {
          var p = new DataView(n, 0), l = 0; const { identifier: h, version: b } = c(n, p, l); l += y.byteCount; if ("LEPCC     " !== h) throw new w("lepcc-decode-error", "Bad identifier"); if (1 < b) throw new w("lepcc-decode-error", "Unknown version");
          var d = l; var f = p.getUint32(d + 0, !0); var t = p.getUint32(d + 4, !0); var v = p.getFloat64(d + 8, !0); var m = p.getFloat64(d + 16, !0); var e = p.getFloat64(d + 24, !0); var g = p.getFloat64(d + 32, !0); var x = p.getFloat64(d + 40, !0); var k = p.getFloat64(d + 48, !0); var r = p.getFloat64(d + 56, !0); var A = p.getFloat64(d + 64, !0); var z = p.getFloat64(d + 72, !0); var B = p.getUint32(d + 80, !0); p.getUint32(d + 84, !0); l += 88; if (t * 2 ** 32 + f !== n.byteLength) throw new w("lepcc-decode-error", "Bad size"); f = new Float64Array(3 * B); t = []; B = []; p = []; d = []; l = q(n, l, t); l = q(n, l,
            B); l = q(n, l, p); l = q(n, l, d); if (l !== n.byteLength) throw new w("lepcc-decode-error", "Bad length"); l = n = 0; for (let C = 0; C < t.length; C++) { l += t[C]; let D = 0; for (let E = 0; E < B[C]; E++) { D += p[n]; const H = d[n]; f[3 * n] = Math.min(g, v + 2 * r * D); f[3 * n + 1] = Math.min(x, m + 2 * A * l); f[3 * n + 2] = Math.min(k, e + 2 * z * H); n++ } } return { errorX: r, errorY: A, errorZ: z, result: f }
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/I3SProjectionUtil": function () {
      define(["exports", "../../../../chunks/mat4f64", "../../../../chunks/vec3f64",
        "../../../../geometry/projection", "../../../../geometry/projectionEllipsoid"], function (a, w, c, q, u) {
          function y(n, p, l) { const h = c.create(), b = 2 ** (4 * Math.ceil(Math.log(n[3]) * Math.LOG2E / 4) + 1); if (l.isGeographic) { var d = b / u.getReferenceEllipsoid(l).radius * 180 / Math.PI; l = Math.max(-90, Math.min(90, Math.round(n[1] / d) * d)); d /= Math.cos((Math.abs(l) - d / 2) / 180 * Math.PI); h[0] = Math.round(n[0] / d) * d; h[1] = l } else l = Math.round(n[1] / b), h[0] = Math.round(n[0] / b) * b, h[1] = l * b; h[2] = Math.round((n[2] + p) / b) * b; return h } a.computeGlobalTransformation =
            function (n, p, l, h) { n = y(n, p, l); p = w.create(); q.computeTranslationToOriginAndRotation(l, n, p, h); return p }; a.getLocalOrigin = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/LoDUtil": function () {
      define(["exports", "../../../../chunks/vec3"], function (a, w) {
        function c(l, h, b) { for (; 0 < l;) { const d = h.indexOf(l); if (0 <= d) return d; l = b.getParentId(l) } return h.indexOf(l) } function q(l, h, b) {
          const d = [h.remove[0]], f = []; for (; 1 === d.length;) {
            const v = d.pop(); f.length = 0; for (let m = 0; m < h.load.length; m++) {
              let e =
                h.load[m]; for (var t = b.getParentId(e); t !== v;)e = t, t = b.getParentId(e); t = d.indexOf(e); 0 > t && (t = d.length, d.push(e), f.push([])); f[t].push(h.load[m])
            }
          } h.load = d; for (h = 0; h < d.length; h++)1 < f[h].length ? l.push({ remove: [d[h]], load: f[h] }) : d[h] = f[h][0]
        } const u = [!1], y = [null], n = [!1], p = [null]; a.nodeDiff = function (l, h, b) {
          for (var d = 0; d < h.length; d++)n[d] = !1, p[d] = null; for (d = 0; d < l.length; d++)u[d] = !1, y[d] = null; for (d = 0; d < h.length; d++) { var f = c(h[d], l, b); 0 <= f && (n[d] = !0, null != y[f] ? y[f].push(h[d]) : y[f] = [h[d]]) } for (d = 0; d < l.length; d++)f =
            c(l[d], h, b), 0 <= f && (u[d] = !0, null != p[f] ? p[f].push(l[d]) : p[f] = [l[d]]); b = []; for (d = 0; d < l.length; d++)null != y[d] || u[d] || b.push({ load: [], remove: [l[d]] }); for (d = 0; d < h.length; d++)null != p[d] || n[d] || b.push({ load: [h[d]], remove: [] }); for (d = 0; d < h.length; d++)null != p[d] && (1 < p[d].length || p[d][0] !== h[d]) && b.push({ load: [h[d]], remove: p[d] }); for (h = 0; h < l.length; h++)null != y[h] && (1 < y[h].length || y[h][0] !== l[h]) && b.push({ load: y[h], remove: [l[h]] }); return b
        }; a.sortFrontToBack = function (l, h, b) {
          return l.sort((d, f) => {
            if (0 === d.load.length &&
              0 === f.load.length) return 0; if (0 === d.load.length) return -1; if (0 === f.load.length) return 1; if (0 === d.remove.length && 0 === f.remove.length) return d = b.getRenderCenter(d.load[0]), f = b.getRenderCenter(f.load[0]), w.dot(d, h) - w.dot(f, h); if (0 === d.remove.length) return -1; if (0 === f.remove.length) return 1; if (1 === d.load.length && 1 === f.load.length) return d = b.getRenderCenter(d.load[0]), f = b.getRenderCenter(f.load[0]), w.dot(d, h) - w.dot(f, h); if (1 === d.load.length) return -1; if (1 === f.load.length) return 1; d = b.getRenderCenter(d.remove[0]);
            f = b.getRenderCenter(f.remove[0]); return w.dot(d, h) - w.dot(f, h)
          })
        }; a.splitWorkEntries = function (l, h, b) { for (let d = 0; d < l.length; ++d) { const f = l[d]; f.load.length > h && 1 === f.remove.length && q(l, f, b) } }; a.splitWorkEntry = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/PagedNodeIndex": function () {
      define(["../../../../geometry/support/aaBoundingBox", "./I3SUtil", "../../support/orientedBoundingBox"], function (a, w, c) {
        return function () {
          function q(y, n, p) {
          this._pages = []; this.pageSize = 0; this._renderSR =
            this._nodeSR = null; this._nodeSR = y; this._renderSR = n; this.pageSize = p
          } var u = q.prototype; u.addPage = function (y, n, p = 0) {
            for (; this._pages.length < y;)this._pages.push(null); var l = this._nodeSR, h = this._renderSR, b = new c.ObbArray(n.length); for (var d = 0; d < n.length; d++)w.transformObb(n[d].obb, l, b.obbs[d], h, p); p = b.obbs; this._pages[y] = { nodes: n, renderObbs: p, parents: new Uint32Array(this.pageSize) }; y = this._pages; n = this.pageSize; for (p = [0]; p.length;)for (l = p.pop(), h = y[l / n | 0].nodes[l % n], b = 0; b < h.childCount; b++)d = h.firstChild +
              b, null != y[d / n | 0] && (y[d / n | 0].parents[d % n] = l, p.push(d))
          }; u.hasPage = function (y) { return !!this._pages[y] }; u.getNode = function (y) { const n = this.pageSize; return this._pages[y / n | 0].nodes[y % n] }; u.getRenderObb = function (y) { const n = this.pageSize; return this._pages[y / n | 0].renderObbs[y % n] }; u.getRenderCenter = function (y) { return this.getRenderObb(y).center }; u.setRenderObb = function (y, n) { const p = this.pageSize; c.set(n, this._pages[y / p | 0].renderObbs[y % p]) }; u.getParentId = function (y) {
            const n = this.pageSize; return this._pages[y /
              n | 0].parents[y % n]
          }; u.hasNodes = function (y, n) { var p = y / this.pageSize | 0; for (y = (y + n - 1) / this.pageSize | 0; p <= y; p++)if (null == this._pages[p]) return !1; return !0 }; u.forEachNodeId = function (y) { for (let n = 0; n < this._pages.length; n++) { const p = this._pages[n]; if (p) for (let l = 0; l < p.nodes.length; l++)y(n * this.pageSize + l) } }; u.createVisibilityTraverse = function () {
            var y = this, n = [], p = [], l = a.create(); return (h, b) => {
              if (y.hasNodes(0, 1)) for (n.length = 0, n.push(0), p.length = 0, p.push(0); 0 < n.length;) {
                var d = n.pop(); let g = p.pop(); var f = y.getNode(d),
                  t = y.getRenderObb(d), v = !0; if (null != h.clippingBox) { var m = 1 << h.frustum.length; if (0 === (g & m)) { var e = c.toAaBoundingBox(t, l); a.contains(h.clippingBox, e) ? g |= m : a.intersects(h.clippingBox, e) || (v = !1) } } for (m = 0; m < h.frustum.length && v; m++)if (e = 1 << m, 0 === (g & e)) { const x = c.intersectPlane(t, h.frustum[m]); 0 < x ? v = !1 : 0 > x && (g |= e) } if (b.predicate(d, f, v)) { t = f.firstChild; f = f.childCount; v = !1; e = t / y.pageSize | 0; for (m = (t + f - 1) / y.pageSize | 0; e <= m; e++)if (!y.hasPage(e)) { b.pageMiss(d, e); v = !0; break } if (!v) for (d = 0; d < f; d++)n.push(t + d), p.push(g) }
              }
            }
          };
          return q
        }()
      })
    }, "esri/views/3d/layers/i3s/PointCloudRendererUtil": function () {
      define(["exports"], function (a) {
        function w(q, u) { for (const y of q) if (y.name === u && null != y.attributeValues && "UInt8" === y.attributeValues.valueType && 3 === y.attributeValues.valuesPerElement) return { name: u, storageInfo: y, useElevation: !1 }; return null } function c(q, u) {
          for (const y of q) if (y.name === u) return q = "embedded-elevation" === y.encoding, { name: u, storageInfo: q ? null : y, useElevation: q }; return "elevation" === u.toLowerCase() ? {
            name: u, storageInfo: null,
            useElevation: !0
          } : null
        } a.getAttributeInfo = c; a.getFilterInfo = function (q) { const u = q.filters; return u ? u.map(y => ({ filterJSON: y.toJSON(), attributeInfo: c(q.attributeStorageInfo, y.field) })) : [] }; a.getFixedSizeAlgorithm = function (q) { return (q = q && q.pointSizeAlgorithm) && "fixed-size" === q.type ? q : null }; a.getRendererInfo = function (q) {
          const u = q.renderer; var y = u && u.type; const n = u && q.renderer.toJSON() || null; let p = null, l = !1; "point-cloud-unique-value" === y ? p = c(q.attributeStorageInfo, u.field) : "point-cloud-stretch" === y ? p = c(q.attributeStorageInfo,
            u.field) : "point-cloud-class-breaks" === y ? p = c(q.attributeStorageInfo, u.field) : (p = "point-cloud-rgb" === y ? w(q.attributeStorageInfo, u.field) : w(q.attributeStorageInfo, "RGB"), l = null != p); y = null; u && u.colorModulation && (y = c(q.attributeStorageInfo, u.colorModulation.field)); return { rendererJSON: n, isRGBRenderer: l, primaryAttribute: p, modulationAttribute: y }
        }; a.getSplatSizeAlgorithm = function (q) { return (q = q && q.pointSizeAlgorithm) && "splat" === q.type ? q : null }; a.rendererUsesFixedSizes = function (q) {
          return (q = q && q.pointSizeAlgorithm) &&
            q.type ? "fixed-size" === q.type : !1
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/PointCloudWorkerUtil": function () {
      define("exports ../../../../core/maybe ../../../../renderers/PointCloudClassBreaksRenderer ../../../../renderers/PointCloudStretchRenderer ../../../../renderers/PointCloudUniqueValueRenderer ./I3SBinaryReader ./LEPCC".split(" "), function (a, w, c, q, u, y, n) {
        function p(b, d) { const f = new Float64Array(d); for (let t = 0; t < d; t++)f[t] = b[3 * t + 2]; return f } function l(b) {
          return null ==
            b || "none" === b ? null : "low-four-bit" === b ? d => d & 15 : "high-four-bit" === b ? d => (d & 240) >> 4 : "absolute-value" === b ? d => Math.abs(d) : "modulo-ten" === b ? d => d % 10 : null
        } function h(b) { let d = 0; for (const f of b ? b : []) d |= 1 << f; return d } a.elevationFromPositions = p; a.evaluateRenderer = function (b, d, f, t) {
          const { rendererJSON: v, isRGBRenderer: m } = b; var e = b = null; if (d && m) b = d; else if (d && "pointCloudUniqueValueRenderer" === v.type) {
            e = u.fromJSON(v); var g = e.colorUniqueValueInfos; b = new Uint8Array(3 * t); var x = l(e.fieldTransformType); for (var k = 0; k <
              t; k++) { var r = (x ? x(d[k]) : d[k]) + ""; for (var A = 0; A < g.length; A++)if (0 <= g[A].values.indexOf(r)) { b[3 * k] = g[A].color.r; b[3 * k + 1] = g[A].color.g; b[3 * k + 2] = g[A].color.b; break } }
          } else if (d && "pointCloudStretchRenderer" === v.type) for (e = q.fromJSON(v), g = e.stops, b = new Uint8Array(3 * t), x = l(e.fieldTransformType), k = 0; k < t; k++)if (r = x ? x(d[k]) : d[k], A = g.length - 1, r < g[0].value) b[3 * k] = g[0].color.r, b[3 * k + 1] = g[0].color.g, b[3 * k + 2] = g[0].color.b; else if (r >= g[A].value) b[3 * k] = g[A].color.r, b[3 * k + 1] = g[A].color.g, b[3 * k + 2] = g[A].color.b; else for (A =
            1; A < g.length; A++) { if (r < g[A].value) { r = (r - g[A - 1].value) / (g[A].value - g[A - 1].value); b[3 * k] = g[A].color.r * r + g[A - 1].color.r * (1 - r); b[3 * k + 1] = g[A].color.g * r + g[A - 1].color.g * (1 - r); b[3 * k + 2] = g[A].color.b * r + g[A - 1].color.b * (1 - r); break } } else if (d && "pointCloudClassBreaksRenderer" === v.type) for (e = c.fromJSON(v), g = e.colorClassBreakInfos, b = new Uint8Array(3 * t), x = l(e.fieldTransformType), k = 0; k < t; k++)for (r = x ? x(d[k]) : d[k], A = 0; A < g.length; A++) {
              if (r >= g[A].minValue && r <= g[A].maxValue) {
              b[3 * k] = g[A].color.r; b[3 * k + 1] = g[A].color.g; b[3 *
                k + 2] = g[A].color.b; break
              }
            } else for (b = new Uint8Array(3 * t), d = 0; d < b.length; d++)b[d] = 255; if (f && e && e.colorModulation) for (d = e.colorModulation.minValue, e = e.colorModulation.maxValue, g = 0; g < t; g++)x = f[g], x = x >= e ? 1 : x <= d ? .3 : .3 + .7 * (x - d) / (e - d), b[3 * g] *= x, b[3 * g + 1] *= x, b[3 * g + 2] *= x; return b
        }; a.filterInPlace = function (b, d, f, t, v) {
          const m = b.length / 3; let e = 0; for (let z = 0; z < m; z++) {
            let B = !0; for (let C = 0; C < t.length && B; C++) {
              var { filterJSON: g } = t[C], x = v[C].values[z]; switch (g.type) {
                case "pointCloudValueFilter": var k = "exclude" === g.mode;
                  -1 !== g.values.indexOf(x) === k && (B = !1); break; case "pointCloudBitfieldFilter": k = h(g.requiredSetBits); g = h(g.requiredClearBits); if ((x & k) !== k || 0 !== (x & g)) B = !1; break; case "pointCloudReturnFilter": var r = x & 15, A = x >>> 4 & 15; x = 1 < A; k = 1 === r; r = r === A; A = !1; for (const D of g.includedReturns) if ("last" === D && r || "firstOfMany" === D && k && x || "lastOfMany" === D && r && x || "single" === D && !x) { A = !0; break } A || (B = !1)
              }
            } B && (f[e] = z, b[3 * e] = b[3 * z], b[3 * e + 1] = b[3 * z + 1], b[3 * e + 2] = b[3 * z + 2], d[3 * e] = d[3 * z], d[3 * e + 1] = d[3 * z + 1], d[3 * e + 2] = d[3 * z + 2], e++)
          } return e
        };
        a.getAttributeValues = function (b, d, f) { return w.isSome(b) && b.attributeInfo.useElevation ? p(d, f) : w.isSome(b) ? y.readBinaryAttribute(b.attributeInfo.storageInfo, b.buffer, f) : null }; a.readGeometry = function (b, d) {
          if (null == b.encoding || "" === b.encoding) {
            b = y.createGeometryIndexFromSchema(d, b); if (w.isNone(b.vertexAttributes.position)) return; d = y.createTypedView(d, b.vertexAttributes.position); var f = b.header.fields; b = [f.offsetX, f.offsetY, f.offsetZ]; f = [f.scaleX, f.scaleY, f.scaleZ]; const t = d.length / 3, v = new Float64Array(3 *
              t); for (let m = 0; m < t; m++)v[3 * m] = d[3 * m] * f[0] + b[0], v[3 * m + 1] = d[3 * m + 1] * f[1] + b[1], v[3 * m + 2] = d[3 * m + 2] * f[2] + b[2]; return v
          } if ("lepcc-xyz" === b.encoding) return n.decodeXYZ(d).result
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/renderers/PointCloudClassBreaksRenderer": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./PointCloudRenderer ./support/LegendOptions ./support/pointCloud/ColorClassBreakInfo".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          var b; u = b = function (d) { function f(t) { t = d.call(this, t) || this; t.type = "point-cloud-class-breaks"; t.field = null; t.legendOptions = null; t.fieldTransformType = null; t.colorClassBreakInfos = null; return t } a._inheritsLoose(f, d); f.prototype.clone = function () { return new b({ ...this.cloneProperties(), field: this.field, fieldTransformType: this.fieldTransformType, colorClassBreakInfos: c.clone(this.colorClassBreakInfos), legendOptions: c.clone(this.legendOptions) }) }; return f }(p); w.__decorate([y.enumeration({ pointCloudClassBreaksRenderer: "point-cloud-class-breaks" })],
            u.prototype, "type", void 0); w.__decorate([q.property({ json: { write: !0 }, type: String })], u.prototype, "field", void 0); w.__decorate([q.property({ type: l.default, json: { write: !0 } })], u.prototype, "legendOptions", void 0); w.__decorate([q.property({ type: p.fieldTransformTypeKebabDict.apiValues, json: { type: p.fieldTransformTypeKebabDict.jsonValues, read: p.fieldTransformTypeKebabDict.read, write: p.fieldTransformTypeKebabDict.write } })], u.prototype, "fieldTransformType", void 0); w.__decorate([q.property({
              type: [h.default],
              json: { write: !0 }
            })], u.prototype, "colorClassBreakInfos", void 0); return u = b = w.__decorate([n.subclass("esri.renderers.PointCloudClassBreaksRenderer")], u)
        })
    }, "esri/renderers/PointCloudRenderer": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/jsonMap ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./support/pointCloud/ColorModulation ./support/pointCloud/pointSizeAlgorithmTypeUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          n = c.strict()({ pointCloudClassBreaksRenderer: "point-cloud-class-breaks", pointCloudRGBRenderer: "point-cloud-rgb", pointCloudStretchRenderer: "point-cloud-stretch", pointCloudUniqueValueRenderer: "point-cloud-unique-value" }); q = function (b) {
            function d(t) { t = b.call(this, t) || this; t.type = void 0; t.pointSizeAlgorithm = null; t.colorModulation = null; t.pointsPerInch = 10; return t } a._inheritsLoose(d, b); var f = d.prototype; f.clone = function () {
              console.warn(".clone() is not implemented for " + this.declaredClass);
              return null
            }; f.cloneProperties = function () { return { pointSizeAlgorithm: u.clone(this.pointSizeAlgorithm), colorModulation: u.clone(this.colorModulation), pointsPerInch: u.clone(this.pointsPerInch) } }; return d
          }(q.JSONSupport); w.__decorate([y.property({ type: n.apiValues, readOnly: !0, nonNullable: !0, json: { type: n.jsonValues, read: !1, write: n.write } })], q.prototype, "type", void 0); w.__decorate([y.property({ types: h.pointSizeAlgorithmTypes, json: { write: !0 } })], q.prototype, "pointSizeAlgorithm", void 0); w.__decorate([y.property({
            type: l.default,
            json: { write: !0 }
          })], q.prototype, "colorModulation", void 0); w.__decorate([y.property({ json: { write: !0 }, nonNullable: !0, type: Number })], q.prototype, "pointsPerInch", void 0); q = w.__decorate([p.subclass("esri.renderers.PointCloudRenderer")], q); (q || (q = {})).fieldTransformTypeKebabDict = new c.JSONMap({ none: "none", lowFourBit: "low-four-bit", highFourBit: "high-four-bit", absoluteValue: "absolute-value", moduloTen: "modulo-ten" }); return q
        })
    }, "esri/renderers/support/pointCloud/ColorModulation": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          var h; a.ColorModulation = h = function (b) { function d() { var f = b.apply(this, arguments) || this; f.field = null; f.minValue = 0; f.maxValue = 255; return f } w._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ field: this.field, minValue: this.minValue, maxValue: this.maxValue }) }; return d }(q.JSONSupport); c.__decorate([u.property({ type: String, json: { write: !0 } })], a.ColorModulation.prototype, "field", void 0); c.__decorate([u.property({ type: Number, nonNullable: !0, json: { write: !0 } })], a.ColorModulation.prototype,
            "minValue", void 0); c.__decorate([u.property({ type: Number, nonNullable: !0, json: { write: !0 } })], a.ColorModulation.prototype, "maxValue", void 0); a.ColorModulation = h = c.__decorate([l.subclass("esri.renderers.support.pointCloud.ColorModulation")], a.ColorModulation); a.default = a.ColorModulation; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/renderers/support/pointCloud/pointSizeAlgorithmTypeUtils": function () {
      define(["exports", "./PointSizeAlgorithm", "./PointSizeFixedSizeAlgorithm", "./PointSizeSplatAlgorithm"],
        function (a, w, c, q) { a.pointSizeAlgorithmTypes = { key: "type", base: w.default, typeMap: { "fixed-size": c.default, splat: q.default } }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/renderers/support/pointCloud/PointSizeAlgorithm": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/jsonMap ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          q = new q.JSONMap({ pointCloudFixedSizeAlgorithm: "fixed-size", pointCloudSplatAlgorithm: "splat" }); a.PointSizeAlgorithm = function (b) { function d() { return b.apply(this, arguments) || this } w._inheritsLoose(d, b); return d }(u.JSONSupport); c.__decorate([y.property({ type: q.apiValues, readOnly: !0, nonNullable: !0, json: { type: q.jsonValues, read: !1, write: q.write } })], a.PointSizeAlgorithm.prototype, "type", void 0); a.PointSizeAlgorithm = c.__decorate([h.subclass("esri.renderers.support.pointCloud.PointSizeAlgorithm")],
            a.PointSizeAlgorithm); a.default = a.PointSizeAlgorithm; a.typeKebabDictionary = q; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/renderers/support/pointCloud/PointSizeFixedSizeAlgorithm": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass ./PointSizeAlgorithm".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          var b; a.PointSizeFixedSizeAlgorithm = b = function (d) { function f() { var t = d.apply(this, arguments) || this; t.type = "fixed-size"; t.size = 0; t.useRealWorldSymbolSizes = null; return t } w._inheritsLoose(f, d); f.prototype.clone = function () { return new b({ size: this.size, useRealWorldSymbolSizes: this.useRealWorldSymbolSizes }) }; return f }(h.default); c.__decorate([p.enumeration({ pointCloudFixedSizeAlgorithm: "fixed-size" })], a.PointSizeFixedSizeAlgorithm.prototype, "type", void 0); c.__decorate([q.property({
            type: Number,
            nonNullable: !0, json: { write: !0 }
          })], a.PointSizeFixedSizeAlgorithm.prototype, "size", void 0); c.__decorate([q.property({ type: Boolean, json: { write: !0 } })], a.PointSizeFixedSizeAlgorithm.prototype, "useRealWorldSymbolSizes", void 0); a.PointSizeFixedSizeAlgorithm = b = c.__decorate([l.subclass("esri.renderers.support.pointCloud.PointSizeFixedSizeAlgorithm")], a.PointSizeFixedSizeAlgorithm); a.default = a.PointSizeFixedSizeAlgorithm; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/renderers/support/pointCloud/PointSizeSplatAlgorithm": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass ./PointSizeAlgorithm".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          var b; a.PointSizeSplatAlgorithm = b = function (d) { function f() { var t = d.apply(this, arguments) || this; t.type = "splat"; t.scaleFactor = 1; return t } w._inheritsLoose(f, d); f.prototype.clone = function () { return new b({ scaleFactor: this.scaleFactor }) }; return f }(h.default); c.__decorate([p.enumeration({ pointCloudSplatAlgorithm: "splat" })], a.PointSizeSplatAlgorithm.prototype, "type", void 0); c.__decorate([q.property({ type: Number, value: 1, nonNullable: !0, json: { write: !0 } })], a.PointSizeSplatAlgorithm.prototype,
            "scaleFactor", void 0); a.PointSizeSplatAlgorithm = b = c.__decorate([l.subclass("esri.renderers.support.pointCloud.PointSizeSplatAlgorithm")], a.PointSizeSplatAlgorithm); a.default = a.PointSizeSplatAlgorithm; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/renderers/support/pointCloud/ColorClassBreakInfo": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/JSONSupport ../../../core/lang ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          var h; a.ColorClassBreakInfo = h = function (b) { function d() { var f = b.apply(this, arguments) || this; f.description = null; f.label = null; f.minValue = 0; f.maxValue = 0; f.color = null; return f } w._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, color: y.clone(this.color) }) }; return d }(u.JSONSupport); c.__decorate([n.property({ type: String, json: { write: !0 } })], a.ColorClassBreakInfo.prototype, "description",
            void 0); c.__decorate([n.property({ type: String, json: { write: !0 } })], a.ColorClassBreakInfo.prototype, "label", void 0); c.__decorate([n.property({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], a.ColorClassBreakInfo.prototype, "minValue", void 0); c.__decorate([n.property({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], a.ColorClassBreakInfo.prototype, "maxValue", void 0); c.__decorate([n.property({ type: q, json: { type: [p.Integer], write: !0 } })],
              a.ColorClassBreakInfo.prototype, "color", void 0); a.ColorClassBreakInfo = h = c.__decorate([l.subclass("esri.renderers.support.pointCloud.ColorClassBreakInfo")], a.ColorClassBreakInfo); a.default = a.ColorClassBreakInfo; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/renderers/PointCloudStretchRenderer": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./PointCloudRenderer ./support/LegendOptions ./visualVariables/support/ColorStop".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          var b; u = b = function (d) { function f(t) { t = d.call(this, t) || this; t.type = "point-cloud-stretch"; t.field = null; t.legendOptions = null; t.fieldTransformType = null; t.stops = null; return t } a._inheritsLoose(f, d); f.prototype.clone = function () { return new b({ ...this.cloneProperties(), field: c.clone(this.field), fieldTransformType: c.clone(this.fieldTransformType), stops: c.clone(this.stops), legendOptions: c.clone(this.legendOptions) }) }; return f }(p); w.__decorate([y.enumeration({ pointCloudStretchRenderer: "point-cloud-stretch" })],
            u.prototype, "type", void 0); w.__decorate([q.property({ json: { write: !0 }, type: String })], u.prototype, "field", void 0); w.__decorate([q.property({ type: l.default, json: { write: !0 } })], u.prototype, "legendOptions", void 0); w.__decorate([q.property({ type: p.fieldTransformTypeKebabDict.apiValues, json: { type: p.fieldTransformTypeKebabDict.jsonValues, read: p.fieldTransformTypeKebabDict.read, write: p.fieldTransformTypeKebabDict.write } })], u.prototype, "fieldTransformType", void 0); w.__decorate([q.property({ type: [h], json: { write: !0 } })],
              u.prototype, "stops", void 0); return u = b = w.__decorate([n.subclass("esri.renderers.PointCloudStretchRenderer")], u)
        })
    }, "esri/renderers/PointCloudUniqueValueRenderer": function () {
      define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./PointCloudRenderer ./support/LegendOptions ./support/pointCloud/ColorUniqueValueInfo".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          var b; u = b = function (d) { function f(t) { t = d.call(this, t) || this; t.type = "point-cloud-unique-value"; t.field = null; t.fieldTransformType = null; t.colorUniqueValueInfos = null; t.legendOptions = null; return t } a._inheritsLoose(f, d); f.prototype.clone = function () { return new b({ ...this.cloneProperties(), field: c.clone(this.field), fieldTransformType: c.clone(this.fieldTransformType), colorUniqueValueInfos: c.clone(this.colorUniqueValueInfos), legendOptions: c.clone(this.legendOptions) }) }; return f }(p);
          w.__decorate([y.enumeration({ pointCloudUniqueValueRenderer: "point-cloud-unique-value" })], u.prototype, "type", void 0); w.__decorate([q.property({ json: { write: !0 }, type: String })], u.prototype, "field", void 0); w.__decorate([q.property({ type: p.fieldTransformTypeKebabDict.apiValues, json: { type: p.fieldTransformTypeKebabDict.jsonValues, read: p.fieldTransformTypeKebabDict.read, write: p.fieldTransformTypeKebabDict.write } })], u.prototype, "fieldTransformType", void 0); w.__decorate([q.property({ type: [h.default], json: { write: !0 } })],
            u.prototype, "colorUniqueValueInfos", void 0); w.__decorate([q.property({ type: l.default, json: { write: !0 } })], u.prototype, "legendOptions", void 0); return u = b = w.__decorate([n.subclass("esri.renderers.PointCloudUniqueValueRenderer")], u)
        })
    }, "esri/renderers/support/pointCloud/ColorUniqueValueInfo": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/JSONSupport ../../../core/lang ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          var h; a.ColorUniqueValueInfo = h = function (b) { function d() { var f = b.apply(this, arguments) || this; f.description = null; f.label = null; f.values = null; f.color = null; return f } w._inheritsLoose(d, b); d.prototype.clone = function () { return new h({ description: this.description, label: this.label, values: y.clone(this.values), color: y.clone(this.color) }) }; return d }(u.JSONSupport); c.__decorate([n.property({ type: String, json: { write: !0 } })], a.ColorUniqueValueInfo.prototype, "description", void 0); c.__decorate([n.property({
            type: String,
            json: { write: !0 }
          })], a.ColorUniqueValueInfo.prototype, "label", void 0); c.__decorate([n.property({ type: [String], json: { write: !0 } })], a.ColorUniqueValueInfo.prototype, "values", void 0); c.__decorate([n.property({ type: q, json: { type: [p.Integer], write: !0 } })], a.ColorUniqueValueInfo.prototype, "color", void 0); a.ColorUniqueValueInfo = h = c.__decorate([l.subclass("esri.renderers.support.pointCloud.ColorUniqueValueInfo")], a.ColorUniqueValueInfo); a.default = a.ColorUniqueValueInfo; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/layers/i3s/PointGraphic": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../Graphic ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass".split(" "), function (a, w, c, q, u, y, n, p, l) {
        var h; a.PointGraphic = h = function (b) {
          function d(t) { return b.call(this, t) || this } w._inheritsLoose(d, b); var f =
            d.prototype; f.clone = function () { return new h(this.cloneProperties()) }; f.cloneProperties = function () { const { pointCloudMetadata: t } = this; return { ...b.prototype.cloneProperties.call(this), pointCloudMetadata: t } }; return d
        }(q); c.__decorate([u.property({ constructOnly: !0 })], a.PointGraphic.prototype, "pointCloudMetadata", void 0); a.PointGraphic = h = c.__decorate([l.subclass("esri.views.3d.layers.i3s.PointGraphic")], a.PointGraphic); Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/PointRenderer": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/PooledArray ../../../../chunks/mat4 ../../../../chunks/mat4f32 ../../../../chunks/vec3 ../../../../chunks/vec3f32 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/plane ../../../../geometry/support/ray ./PointHighlights ../../support/orientedBoundingBox ../../webgl-engine/core/shaderLibrary/Slice.glsl ../../webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../../webgl-engine/lib/DefaultVertexAttributeLocations ../../webgl-engine/lib/Intersector ../../webgl-engine/shaders/PointRendererTechnique ../../../webgl/BufferObject ../../../webgl/VertexArrayObject".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A) {
          function z(E, H, J, M, F) { if (J.drawScreenSpace) return J.fixedSize * H * M; F = (F ? 256 : 64) * H * M; return J.drawFixedSize ? Math.min(J.fixedSize / 2, F) : 0 < J.screenMinSize ? Math.min(Math.max(J.screenMinSize * H * M, E / 2), F) : Math.min(E / 2, F) } function B(E) { return c.isSome(E.component) ? E.component : -1 } function C(E, H) { if (c.isNone(E)) return E; E = E.filter(J => J.id !== H); return 0 === E.length ? null : E } const D = {
            positions: [{ name: "position", count: 3, type: 5126, offset: 0, stride: 12, normalized: !1 }],
            colors: [{ name: "color", count: 3, type: 5121, offset: 0, stride: 3, normalized: !0 }]
          }; a.PointRenderer = function () {
            function E(J) {
            this._params = J; this.type = 5; this.isGround = !1; this._bindParameters = { inverseViewport: [0, 0], highlightDepthTexture: null }; this._highlights = new t.PointHighlights({ forEachNode: M => this.forEachNode(M), addHighlight: (M, F, K) => this.addHighlight(M, F, K), removeHighlight: (M, F) => this.removeHighlight(M, F) }); this.canRender = !0; this.layerUid = ""; this._useFixedSizes = !1; this._scaleFactor = 1; this._minSizePx = 0;
              this._useRealWorldSymbolSizes = !1; this._sizePx = this._size = 0; this._slicePlaneEnabled = !1; this._clipBox = b.create(b.POSITIVE_INFINITY); this._techniqueConfig = new k.PointRendererTechniqueConfiguration; this.tempMatrix4 = y.create(); this.tempVec3 = p.create(); this.nodes = new q
            } var H = E.prototype; H.initializeRenderContext = function (J) { this._context = J; this._techniqueRep = this._context.shaderTechniqueRep; J.requestRender() }; H.uninitializeRenderContext = function () { }; H.intersect = function (J, M, F, K) {
              const P = l.create(), L = l.create(),
              N = l.create(), G = l.create(), I = d.create(), O = J.camera.perScreenPixelRatio / 2, R = J.camera.near, S = this._getSizeParams(); n.subtract(L, K, F); const Q = 1 / n.length(L); n.scale(L, L, Q); n.negate(N, L); h.set(I, L[0], L[1], L[2], -n.dot(L, F)); let T = function () { this.normal = this.dist = this.point = this.pointId = this.node = null; this.layerUid = "" }; const da = new T, Y = new T, fa = [], ha = b.create(), ka = b.create(this._clipBox); b.offset(ka, -F[0], -F[1], -F[2], ka); this.nodes.forAll(W => {
                const U = W.splatSize * this._scaleFactor; var X = v.minimumDistancePlane(W.obb,
                  I), Z = v.maximumDistancePlane(W.obb, I); X -= S.drawScreenSpace ? 0 : z(U, X + R, S, O, W.isLeaf); Z -= S.drawScreenSpace ? 0 : z(U, Z + R, S, O, W.isLeaf); X = null != da.dist && null != Y.dist && da.dist < X * Q && Y.dist > Z * Q; if (!(0 > Z || X) && (Z = z(U, Z + R, S, O, W.isLeaf), v.intersectLine(W.obb, F, L, Z))) {
                    Z *= Z; v.toAaBoundingBox(W.obb, ha); b.offset(ha, -F[0], -F[1], -F[2], ha); X = !b.contains(ka, ha); n.subtract(G, W.origin, F); var ia = W.coordinates.length / 3; for (let Aa = 0; Aa < ia; Aa++) {
                    P[0] = G[0] + W.coordinates[3 * Aa]; P[1] = G[1] + W.coordinates[3 * Aa + 1]; P[2] = G[2] + W.coordinates[3 *
                      Aa + 2]; if (X && !b.containsPoint(ka, P)) continue; var la = n.dot(P, L), ma = n.squaredLength(P) - la * la; if (ma > Z) continue; var ra = la + R; const za = S.drawScreenSpace ? 0 : z(U, ra, S, O, W.isLeaf); if (0 > la - za) continue; ra -= za; ra = z(U, ra, S, O, W.isLeaf); if (ma > ra * ra) continue; const Ka = (la - za) * Q; la = Ea => {
                        var Ua = Aa, Na = Ea.point; null == Na && (Na = l.create()); Na[0] = W.origin[0] + W.coordinates[3 * Ua]; Na[1] = W.origin[1] + W.coordinates[3 * Ua + 1]; Na[2] = W.origin[2] + W.coordinates[3 * Ua + 2]; Ea.point = Na; Ea.dist = Ka; Ea.normal = N; Ea.node = W; Ea.pointId = Aa; Ea.layerUid =
                          this.layerUid
                      }; (null == da.dist || Ka < da.dist) && (null == M || M(F, K, Ka)) && la(da); 0 !== J.options.store && (null == Y.dist || Ka > Y.dist) && (null == M || M(F, K, Ka)) && la(Y); 2 !== J.options.store || null != M && !M(F, K, Ka) || (ma = new T, la(ma), fa.push(ma))
                    }
                  }
              }); const ea = W => { const { layerUid: U, node: X, pointId: Z } = W; return { point: W.point, layerUid: U, graphicUid: Z, createGraphic: () => this._params.createGraphic(X, Z, W.point) } }, ba = (W, U) => { const X = ea(U); W.set(this.type, X, U.dist, U.normal) }; if (null != da.dist) {
                var aa = J.results.min; (null == aa.dist || da.dist <
                  aa.dist) && ba(aa, da)
              } null != Y.dist && 0 !== J.options.store && (aa = J.results.max, (null == aa.dist || Y.dist > aa.dist) && ba(aa, Y)); if (2 === J.options.store) { aa = f.fromPoints(F, K); for (const W of fa) { const U = x.newIntersectorResult(aa); ba(U, W); J.results.all.push(U) } }
            }; H.render = function (J) {
              if (0 === this.nodes.length || 0 !== J.pass && 2 !== J.pass && 5 !== J.pass) return !1; const M = this._getSizeParams(), F = this.selectTechnique(J, M), K = F.program; if (null == K) return !1; this.nodes.forAll(O => { null == O.vao && this._initNode(J, O) }); const P = J.rctx;
              P.useProgram(K); F.bindPipelineState(P); const L = this._clipBox, N = !b.equals(L, b.POSITIVE_INFINITY, (O, R) => O === R); N || (n.set(this.tempVec3, -Infinity, -Infinity, -Infinity), K.setUniform3fv("uClipMin", this.tempVec3), n.set(this.tempVec3, Infinity, Infinity, Infinity), K.setUniform3fv("uClipMax", this.tempVec3)); K.setUniformMatrix4fv("uProjectionMatrix", J.camera.projectionMatrix); 2 === J.pass && K.setUniform2f("nearFar", J.camera.near, J.camera.far); J.isHighlightPass && (this._bindParameters.inverseViewport[0] = 1 / J.camera.fullViewport[2],
                this._bindParameters.inverseViewport[1] = 1 / J.camera.fullViewport[3], this._bindParameters.highlightDepthTexture = J.highlightDepthTexture, e.bindOutputHighlight(K, this._bindParameters)); const G = J.camera.pixelRatio; M.drawFixedSize && K.setUniform2f("uPointScale", M.fixedSize * G, J.camera.fullHeight); const I = this._slicePlaneEnabled ? J.sliceHelper && J.sliceHelper.plane : null; this.nodes.forAll(O => {
                  if (0 !== O.coordinates.length && (!J.isHighlightPass || O.highlights)) {
                    K.setUniform2f("uScreenMinMaxSize", M.screenMinSize * G,
                      (O.isLeaf ? 256 : 64) * G); M.drawFixedSize || K.setUniform2f("uPointScale", O.splatSize * this._scaleFactor * G, J.camera.fullHeight / G); var R = O.origin; N && (n.set(this.tempVec3, L[0] - R[0], L[1] - R[1], L[2] - R[2]), K.setUniform3fv("uClipMin", this.tempVec3), n.set(this.tempVec3, L[3] - R[0], L[4] - R[1], L[5] - R[2]), K.setUniform3fv("uClipMax", this.tempVec3)); u.identity(this.tempMatrix4); u.translate(this.tempMatrix4, this.tempMatrix4, R); u.multiply(this.tempMatrix4, J.camera.viewMatrix, this.tempMatrix4); K.setUniformMatrix4fv("uModelViewMatrix",
                        this.tempMatrix4); m.bindSliceUniforms(K, F.configuration, I, R); P.bindVAO(O.vao); J.isHighlightPass ? this._renderHighlightFragments(P, O) : P.drawArrays(0, 0, O.coordinates.length / 3)
                  }
                }); return !0
            }; H._renderHighlightFragments = function (J, M) { var F = M.highlights; if (!c.isNone(F)) { M = c.unwrap(F[0].component); var K = M + 1; for (let P = 1; P < F.length; P++) { const L = c.unwrap(F[P].component); L !== K && (K -= M, 0 < K && J.drawArrays(0, M, K), M = L); K = L + 1 } F = K - M; 0 < F && J.drawArrays(0, M, F) } }; H.addNode = function (J) {
              this.nodes.push(J); this._highlights.nodeAdded(J);
              this._requestRender()
            }; H.removeNode = function (J) { let M = null; this.nodes.filterInPlace(F => F.id === J ? (M = F, F.vao = c.disposeMaybe(F.vao), this._highlights.nodeRemoved(F), !1) : !0); this._requestRender(); return M }; H.forEachNode = function (J) { this.nodes.forAll(J) }; H.removeAll = function () { this.nodes.forAll(J => J.vao = c.disposeMaybe(J.vao)); this._highlights.removeAll(); this.nodes.clear(); this._requestRender() }; H.highlight = function (J) { return this._highlights.add(J) }; H.addHighlight = function (J, M, F) {
              var K = J.highlights; c.isNone(K) &&
                (K = []); M = { component: M, id: F }; K.push(M); M = B(M); for (F = K.length - 1; 0 < F && M < B(K[F - 1]);) [K[F - 1], K[F]] = [K[F], K[F - 1]], --F; J.highlights = K; this._requestRender()
            }; H.removeHighlight = function (J, M) { J.highlights = C(J.highlights, M); this._requestRender() }; H._initNode = function (J, M) { J = J.rctx; M.vao = new A(J, g.Default3D, D, { positions: r.createVertex(J, 35044, M.coordinates), colors: r.createVertex(J, 35044, M.rgb) }) }; H._requestRender = function () { this._context && this._context.requestRender() }; H._getSizeParams = function () {
              const J = this._useFixedSizes,
              M = J && !this._useRealWorldSymbolSizes; return { drawScreenSpace: M, drawFixedSize: J, fixedSize: M ? this._sizePx : this._size, screenMinSize: J ? 0 : this._minSizePx }
            }; H.selectTechnique = function (J, M) {
              this._techniqueConfig.drawScreenSize = M.drawScreenSpace; this._techniqueConfig.slicePlaneEnabled = this._slicePlaneEnabled; this._techniqueConfig.sceneHasOcludees = J.hasOccludees; this._techniqueConfig.output = 2 === J.pass ? 1 : 5 === J.pass ? 4 : 0; return this._techniqueRep.releaseAndAcquire(k.PointRendererTechnique, this._techniqueConfig,
                this._technique)
            }; w._createClass(E, [{ key: "needsHighlight", get: function () { return this._highlights.hasHighlights } }, { key: "useFixedSizes", get: function () { return this._useFixedSizes }, set: function (J) { this._useFixedSizes !== J && (this._useFixedSizes = J, this._requestRender()) } }, { key: "scaleFactor", get: function () { return this._scaleFactor }, set: function (J) { this._scaleFactor !== J && (this._scaleFactor = J, this._requestRender()) } }, {
              key: "minSizePx", get: function () { return this._minSizePx }, set: function (J) {
              this._minSizePx !==
                J && (this._minSizePx = J, this._requestRender())
              }
            }, { key: "useRealWorldSymbolSizes", get: function () { return this._useRealWorldSymbolSizes }, set: function (J) { this._useRealWorldSymbolSizes !== J && (this._useRealWorldSymbolSizes = J, this._requestRender()) } }, { key: "size", get: function () { return this._size }, set: function (J) { this._size !== J && (this._size = J, this._requestRender()) } }, { key: "sizePx", get: function () { return this._sizePx }, set: function (J) { this._sizePx !== J && (this._sizePx = J, this._requestRender()) } }, {
              key: "clippingBox",
              set: function (J) { b.set(this._clipBox, J || b.POSITIVE_INFINITY) }
            }, { key: "slicePlaneEnabled", get: function () { return this._slicePlaneEnabled }, set: function (J) { this._slicePlaneEnabled !== J && (this._slicePlaneEnabled = J, this._requestRender()) } }]); return E
          }(); (function (E) { E.isInstanceOfNode = function (H) { return H.hasOwnProperty("splatSize") } })(a.PointRenderer || (a.PointRenderer = {})); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/PointHighlights": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers",
        "../../../../core/handleUtils", "../../../../core/maybe", "../../webgl-engine/lib/Object3DStateID"], function (a, w, c, q, u) {
          let y = function () {
            function p(h) { this.context = h; this.highlights = new Set } var l = p.prototype; l.destroy = function () { this.highlights = null }; l.add = function (h) { const b = new n(h); this.highlights.add(b); this.enableSet(b); return c.makeHandle(() => this.removeSet(b)) }; l.removeSet = function (h) { this.disableSet(h); this.highlights.delete(h) }; l.enableSet = function (h) {
            h.enabled || (h.enabled = !0, this.context.forEachNode(b =>
              this.enableSetForNode(h, b)))
            }; l.enableSetForNode = function (h, b) { if (h.enabled) { var d = h.ids.get(b.id); d && d.forEach(f => this.context.addHighlight(b, f, h.id)) } }; l.disableSet = function (h) { h.enabled && (h.enabled = !1, this.context.forEachNode(b => this.disableSetForNode(h, b))) }; l.disableSetForNode = function (h, b) { h.enabled || this.context.removeHighlight(b, h.id) }; l.nodeAdded = function (h) { this.highlights.forEach(b => this.enableSetForNode(b, h)) }; l.nodeRemoved = function (h) {
              this.highlights.forEach(b => this.disableSetForNode(b,
                h))
            }; l.removeAll = function () { this.highlights.forEach(h => this.disableSet(h)) }; w._createClass(p, [{ key: "hasHighlights", get: function () { return 0 < this.highlights.size } }]); return p
          }(), n = function () { function p(l) { this.id = new u.Object3DStateID(0); this.ids = new Map; this.enabled = !1; for (const h of l) q.isSome(h) && this.add(h.nodeId, h.pointId) } p.prototype.add = function (l, h) { const b = this.ids.get(l); b ? b.add(h) : this.ids.set(l, new Set([h])) }; return p }(); a.PointHighlights = y; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    },
    "esri/views/3d/webgl-engine/shaders/PointRendererTechnique": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../core/shaderTechnique/ShaderTechniqueConfiguration ../lib/DefaultVertexAttributeLocations ../lib/Program ../lib/StencilUtils ../../../../chunks/PointRenderer.glsl ../../../webgl/renderState".split(" "), function (a, w, c, q, u, y, n, p, l, h, b, d) {
        y = function (f) {
          function t(m,
            e, g) { return f.call(this, m, e, g) || this } c._inheritsLoose(t, f); var v = t.prototype; v.initializeProgram = function (m) { var e = t.shader.get(); const g = this.configuration; e = e.build({ output: g.output, slicePlaneEnabled: g.slicePlaneEnabled, sliceHighlightDisabled: !1, sliceEnabledForVertexPrograms: !0, drawScreenSize: g.drawScreenSize }); return new l.Program(m.rctx, e, p.Default3D) }; v.initializePipeline = function () {
              return d.makePipelineState({
                depthTest: { func: 513 }, depthWrite: d.defaultDepthWriteParams, colorWrite: d.defaultColorWriteParams,
                stencilWrite: this.configuration.sceneHasOcludees ? h.stencilWriteMaskOn : null, stencilTest: this.configuration.sceneHasOcludees ? h.stencilBaseAllZerosParams : null
              })
            }; return t
        }(y.ShaderTechnique); y.shader = new u.ReloadableShaderModule(b.PointRendererShader, () => new Promise((f, t) => a(["./PointRenderer.glsl"], f, t))); u = function (f) { function t() { var v = f.apply(this, arguments) || this; v.output = 0; v.slicePlaneEnabled = !1; v.drawScreenSize = !1; v.sceneHasOcludees = !1; return v } c._inheritsLoose(t, f); return t }(n.ShaderTechniqueConfiguration);
        q.__decorate([n.parameter({ count: 8 })], u.prototype, "output", void 0); q.__decorate([n.parameter()], u.prototype, "slicePlaneEnabled", void 0); q.__decorate([n.parameter()], u.prototype, "drawScreenSize", void 0); q.__decorate([n.parameter()], u.prototype, "sceneHasOcludees", void 0); w.PointRendererTechnique = y; w.PointRendererTechniqueConfiguration = u; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/chunks/PointRenderer.glsl": function () {
      define("exports ../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl ../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl ../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl ../views/3d/webgl-engine/core/shaderModules/interfaces ../views/3d/webgl-engine/core/shaderModules/ShaderBuilder".split(" "),
        function (a, w, c, q, u, y) {
          function n(l) {
            const h = new y.ShaderBuilder, b = 0 === l.output, d = 1 === l.output, f = 4 === l.output; h.extensions.add("GL_OES_standard_derivatives"); h.include(w.Slice, l); h.attributes.add("position", "vec3"); h.attributes.add("color", "vec3"); h.vertex.uniforms.add("uModelViewMatrix", "mat4").add("uProjectionMatrix", "mat4").add("uScreenMinMaxSize", "vec2").add("uPointScale", "vec2").add("uClipMin", "vec3").add("uClipMax", "vec3"); d ? (h.vertex.uniforms.add("nearFar", "vec2"), h.varyings.add("depth", "float")) :
              4 !== l.output && h.varyings.add("vColor", "vec3"); h.vertex.code.add(u.glsl`
    void main(void) {
      // Move clipped points outside of clipspace
      if (position.x < uClipMin.x || position.y < uClipMin.y || position.z < uClipMin.z ||
        position.x > uClipMax.x || position.y > uClipMax.y || position.z > uClipMax.z) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      if (rejectBySlice(position)) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      // Position in camera space
      vec4 camera = uModelViewMatrix * vec4(position, 1.0);

      float pointSize = uPointScale.x;
      vec4 position = uProjectionMatrix * camera;
     ${l.drawScreenSize ? u.glsl`
      float clampedScreenSize = pointSize;`: u.glsl`
      float pointRadius = 0.5 * pointSize;
      vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);
      vec4 positionOffset = uProjectionMatrix * cameraOffset;
      float radius = abs(positionOffset.y - position.y);
      float viewHeight = uPointScale.y;
      // screen diameter = (2 * r / w) * (h / 2)
      float screenPointSize = (radius / position.w) * viewHeight;
      float clampedScreenSize = clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);
      // Shift towards camera, to move rendered point out of terrain i.e. to
      // the camera-facing end of the virtual point when considering it as a
      // 3D sphere.
      camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;
      position = uProjectionMatrix * camera;`}

     gl_PointSize = clampedScreenSize;
     gl_Position = position;

     ${d ? u.glsl`depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);` : ""}
     ${b ? u.glsl`vColor = color;` : ""}
    }
  `); h.fragment.include(q.RgbaFloatEncoding, l); f && h.include(c.OutputHighlight); h.fragment.code.add(u.glsl`
    void main(void) {
      vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);
      float r2 = dot(vOffset, vOffset);

      if (r2 > 0.25) {
        discard;
      }
      ${d ? u.glsl`gl_FragColor = float2rgba(depth);` : ""}
      ${f ? u.glsl`outputHighlight();` : ""}
      ${b ? u.glsl`gl_FragColor = vec4(vColor, 1.0);` : ""}
    }
  `); return h
          } const p = Object.freeze({ __proto__: null, build: n }); a.PointRendererShader = p; a.build = n
        })
    }, "esri/views/3d/layers/support/PopupSceneLayerView": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Error ../../../../core/maybe ../../../../core/Logger ../../../../core/accessorSupport/ensureType ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/set ../../../../core/accessorSupport/decorators/subclass ../../../../layers/support/fieldUtils ../../../layers/support/popupUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
        a.PopupSceneLayerView = t => {
          t = function (v) {
            function m() { return v.apply(this, arguments) || this } w._inheritsLoose(m, v); var e = m.prototype; e._validateFetchPopupFeatures = function (g) { const { layer: x } = this, { popupEnabled: k } = x; if (!k) return new q("scenelayerview3d:fetchPopupFeatures", "Popups are disabled", { layer: x }); if (!f.getFetchPopupTemplate(x, g)) return new q("scenelayerview3d:fetchPopupFeatures", "Layer does not define a popup template", { layer: x }) }; e.prepareFetchPopupFeatures =
              function () { var g = w._asyncToGenerator(function* (x) { }); return function (x) { return g.apply(this, arguments) } }(); e.fetchPopupFeatures = function () {
                var g = w._asyncToGenerator(function* (x, k) {
                  if (x = this._validateFetchPopupFeatures(k)) return Promise.reject(x); x = u.isSome(k) ? k.clientGraphics : null; if (!x || 0 === x.length) return Promise.resolve([]); var r = "scene" === this.layer.type && u.isSome(this.layer.associatedLayer) ? this.layer.associatedLayer : this.layer; k = d.unpackFieldNames(this.layer.fieldsIndex, yield f.getRequiredFields(r,
                    f.getFetchPopupTemplate(this.layer, k))); yield this.prepareFetchPopupFeatures(k); r = new Set; const A = [], z = []; for (const B of x) d.populateMissingFields(k, B, r) ? z.push(B) : A.push(B); return 0 === z.length ? Promise.resolve(A) : this.whenGraphicAttributes(z, [...r]).catch(() => z).then(B => A.concat(B))
                }); return function (x, k) { return g.apply(this, arguments) }
              }(); return m
          }(t); return t = c.__decorate([b.subclass("esri.views.3d.layers.support.PopupSceneLayerView")], t)
        }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/SceneLayerView3D": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/Logger ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../core/sql/WhereClause ../../../layers/support/FeatureFilter ../../../rest/support/Query ./I3SMeshView3D ./LayerView3D ./i3s/attributeEditing ./i3s/I3SGeometryUtil ./i3s/I3SMeshViewFilter ./i3s/I3SQueryEngine ./i3s/I3SQueryFeatureAdapter ./i3s/I3SQueryFeatureStore ./i3s/I3SUtil ./support/DefinitionExpressionSceneLayerView ./support/fieldProperties ./support/PopupSceneLayerView ./support/SceneLayerViewRequiredFields ../support/updatingProperties ../../layers/SceneLayerView ../../support/floorFilterUtils ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M) {
          const F = q.getLogger("esri.views.3d.layers.SceneLayerView3D"); q = B.defineFieldProperties(); t = function (K) {
            function P() { var N = K.apply(this, arguments) || this; N.type = "scene-layer-3d"; N.lodFactor = 1; N.progressiveLoadFactor = 1; N._elevationContext = "scene"; N._isIntegratedMesh = !1; N._supportsLabeling = !0; N._interactiveEditingSessions = new Map; N._queryEngine = null; return N } a._inheritsLoose(P, K); var L = P.prototype; L.initialize = function () {
            this.fieldsHelper =
              new D.SceneLayerViewRequiredFields({ layerView: this }); this.updatingHandles.add(this.layer, "rangeInfos", N => this._rangeInfosChanged(N), 2); this.updatingHandles.add(this.layer, "renderer", N => this.updatingHandles.addPromise(this._rendererChange(N)), 2); for (const N of "parsedDefinitionExpression filter viewFilter.parsedWhereClause viewFilter.parsedGeometry viewFilter.sortedObjectIds floorFilterClause".split(" ")) this.updatingHandles.add(this, N, () => this._filterChange()); for (const N of ["filter", "viewFilter.parsedGeometry"]) this.updatingHandles.add(this,
                N, () => this._geometryFilterChange()); this.handles.add(this.layer.on("apply-edits", N => this.updatingHandles.addPromise(N.result))); this.handles.add(this.layer.on("edits", N => this._handleEdits(N)))
            }; L.destroy = function () { this.fieldsHelper = u.destroyMaybe(this.fieldsHelper) }; L._rangeInfosChanged = function (N) { null != N && 0 < N.length && F.warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.") }; L.createQuery = function () {
              const N = {
                outFields: ["*"], returnGeometry: !1,
                outSpatialReference: this.view.spatialReference
              }; return u.isSome(this.filter) ? this.filter.createQuery(N) : new f(N)
            }; L.queryExtent = function (N, G) { return this._ensureQueryEngine().executeQueryForExtent(this._ensureQuery(N), null == G ? void 0 : G.signal) }; L.queryFeatureCount = function (N, G) { return this._ensureQueryEngine().executeQueryForCount(this._ensureQuery(N), null == G ? void 0 : G.signal) }; L.queryFeatures = function (N, G) {
              return this._ensureQueryEngine().executeQuery(this._ensureQuery(N), null == G ? void 0 : G.signal).then(I => { if (null == I || !I.features) return I; const O = this.layer; for (const R of I.features) R.layer = O, R.sourceLayer = O; return I })
            }; L.queryObjectIds = function (N, G) { return this._ensureQueryEngine().executeQueryForIds(this._ensureQuery(N), null == G ? void 0 : G.signal) }; L._ensureQueryEngine = function () { this._queryEngine || (this._queryEngine = this._createQueryEngine()); return this._queryEngine }; L._createQueryEngine = function () {
              const N = e.createGetFeatureExtent(this.view.spatialReference, this.view.renderSpatialReference, this._collection);
              return new x.default({ layerView: this, priority: M.TaskPriority.FEATURE_QUERY_ENGINE, spatialIndex: new r.default({ featureAdapter: new k.I3SQueryFeatureAdapter({ objectIdField: this.layer.objectIdField, attributeStorageInfo: this.layer.attributeStorageInfo, getFeatureExtent: N }), forAllFeatures: (G, I) => this._forAllFeatures((O, R, S) => G({ id: O, index: R, meta: S }), I, 2), getFeatureExtent: N, sourceSpatialReference: A.getIndexCrs(this.layer), viewSpatialReference: this.view.spatialReference }) })
            }; L.highlight = function (N) {
              const G =
                this._highlights; if (N instanceof f) { const { set: I, handle: O } = G.acquireSet(); this.queryObjectIds(N).then(R => G.setFeatureIds(I, R)); return O } return K.prototype.highlight.call(this, N)
            }; L.createInteractiveEditSession = function (N) { return m.createInteractiveEditSession(this.attributeEditingContext, N) }; L._createLayerGraphic = function (N) { N = new c(null, null, N); N.layer = this.layer; N.sourceLayer = this.layer; return N }; L.canResume = function () { return K.prototype.canResume.call(this) && (!this._controller || this._controller.rootNodeVisible) };
            L.getFilters = function () { const N = K.prototype.getFilters.call(this); this.floorFilterClause && this.addSqlFilter(N, this.floorFilterClause, this.logError); this.addSqlFilter(N, this.parsedDefinitionExpression, this.logError); u.isSome(this.viewFilter) && this.viewFilter.addFilters(N, this.view, this._controller.crsIndex, this._collection); return N }; L._ensureQuery = function (N) { return this._addDefinitionExpressionToQuery(u.isNone(N) ? this.createQuery() : f.from(N)) }; L._handleEdits = function (N) {
              m.processAttributeEdits(this.attributeEditingContext,
                N)
            }; L.computeNodeFiltering = function (N) { const G = this.viewFilter; return u.isNone(G) || G.isMBSGeoemtryVisible(N, this.view.spatialReference, this._controller.crsIndex) ? 0 : 1 }; a._createClass(P, [{
              key: "filter", get: function () { return u.isSome(this.viewFilter) ? this.viewFilter.filter : null }, set: function (N) {
                u.isNone(N) || !g.I3SMeshViewFilter.checkSupport(N) ? this.viewFilter = null : u.isSome(this.viewFilter) ? this.viewFilter.filter = N : this.viewFilter = new g.I3SMeshViewFilter({
                  filter: N, layerFieldsIndex: this.layer.fieldsIndex,
                  loadAsyncModule: G => this._loadAsyncModule(G), applyFilters: () => this._applyFilters(!0), addSqlFilter: (G, I) => this.addSqlFilter(G, I, this.logError)
                })
              }
            }, { key: "requiredFields", get: function () { var N, G; return null != (N = null == (G = this.fieldsHelper) ? void 0 : G.requiredFields) ? N : [] } }, { key: "floorFilterClause", get: function () { const N = J.getFloorFilterClause(this); return u.isSome(N) ? b.WhereClause.create(N, this.layer.fieldsIndex) : null } }, {
              key: "lodCrossfadeinDuration", get: function () {
                var N, G; return null != (N = null == (G = this.view) ?
                  void 0 : G.qualitySettings.sceneService["3dObject"].lodCrossfadeinDuration) ? N : 0
              }
            }, { key: "lodCrossfadeoutDuration", get: function () { var N, G; return null != (N = null == (G = this.view) ? void 0 : G.qualitySettings.sceneService["3dObject"].lodCrossfadeoutDuration) ? N : 0 } }, { key: "lodCrossfadeUncoveredDuration", get: function () { var N, G; return null != (N = null == (G = this.view) ? void 0 : G.qualitySettings.sceneService["3dObject"].lodCrossfadeUncoveredDuration) ? N : 0 } }, {
              key: "attributeEditingContext", get: function () {
                return {
                  sessions: this._interactiveEditingSessions,
                  fieldsIndex: this.layer.fieldsIndex, objectIdField: this._getObjectIdField(), forEachNode: N => this._forAllNodes(G => u.isSome(G) ? N(G.node, G.featureIds) : null), attributeStorageInfo: this.i3slayer.attributeStorageInfo, attributeOverrides: this.attributeOverrides, getAttributeData: N => this.getAttributeData(N), setAttributeData: (N, G) => this.setAttributeData(N, G), clearMemCache: () => this.clearMemCache()
                }
              }
            }, { key: "hasGeometryFilter", get: function () { const N = this.viewFilter; return u.isSome(N) && u.isSome(N.parsedGeometry) } }]);
            return P
          }(t.I3SMeshView3D(z.DefinitionExpressionSceneLayerView(C.PopupSceneLayerView(v.LayerView3D(H))))); w.__decorate([y.property({ aliasOf: "layer" })], t.prototype, "i3slayer", void 0); w.__decorate([y.property()], t.prototype, "suspended", void 0); w.__decorate([y.property(E.updatingProgress)], t.prototype, "updatingProgress", void 0); w.__decorate([y.property({ type: d })], t.prototype, "filter", null); w.__decorate([y.property()], t.prototype, "viewFilter", void 0); w.__decorate([y.property(q.requiredFields)], t.prototype,
            "requiredFields", null); w.__decorate([y.property(q.availableFields)], t.prototype, "availableFields", void 0); w.__decorate([y.property()], t.prototype, "fieldsHelper", void 0); w.__decorate([y.property()], t.prototype, "floorFilterClause", null); w.__decorate([y.property({ readOnly: !0, aliasOf: "view.qualitySettings.sceneService.3dObject.lodFactor" })], t.prototype, "lodFactor", void 0); w.__decorate([y.property({ readOnly: !0, aliasOf: "_controller.updatingProgress" })], t.prototype, "updatingProgressValue", void 0); return t =
              w.__decorate([h.subclass("esri.views.3d.layers.SceneLayerView3D")], t)
        })
    }, "esri/views/3d/layers/I3SMeshView3D": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../Graphic ../../../core/Collection ../../../core/has ../../../core/Logger ../../../core/MapUtils ../../../core/maybe ../../../core/PooledArray ../../../core/promiseUtils ../../../core/scheduling ../../../core/typedArrayUtil ../../../core/unitUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/mat3 ../../../chunks/mat3f32 ../../../chunks/mat4 ../../../chunks/mat4f64 ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../chunks/vec4 ../../../geometry/projection ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ../../../layers/graphics/controllers/I3SOnDemandController ../../../layers/support/fieldUtils ../../../layers/support/layerUtils ../../../layers/support/SceneModification ../../../renderers/visualVariables/support/visualVariableUtils ../../../support/arcadeOnDemand ../../../symbols/Symbol3D ../../../symbols/support/unitConversionUtils ./I3SMeshViewLabeler ./I3SMeshWorkerHandle ./SceneLayerWorker ./graphics/graphicUtils ./i3s/Highlights ./i3s/I3SAttributeOverrides ./i3s/I3SCrossfadeHelper ./i3s/I3SElevationProvider ./i3s/I3SGeometryUtil ./i3s/I3SIntersectionHandler ./i3s/I3SMaterialUtil ./i3s/I3SProjectionUtil ./i3s/I3SUtil ./i3s/IDBCache ./support/attributeUtils ../support/debugFlags ../support/extentUtils ../support/orientedBoundingBox ../support/updatingProperties ../support/buffer/glUtil ../webgl-engine/collections/Component/SourceGeometry ../webgl-engine/lib/BasisUtil".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q, T, da, Y, fa, ha, ka, ea, ba, aa, W, U, X, Z, ia, la, ma, ra, Aa, za, Ka) {
          function Ea(xa) { const Qa = xa.metallicRoughness; return Qa && 0 <= Qa.baseColorTextureId || Qa && 0 <= Qa.metallicRoughnessTextureId || 0 <= xa.normalTextureId || 0 <= xa.emissiveTextureId || 0 <= xa.occlusionTextureId } function Ua(xa) { return b.isSome(xa) && v.isArrayBuffer(xa.data) } function Na(xa, Qa) {
            xa = 1024 + xa.interleavedVertexData.byteLength + (xa.indices ? xa.indices.byteLength : 0) +
            xa.positionData.data.byteLength + xa.positionData.indices.byteLength; if (b.isSome(Qa)) for (const Wa of Qa) b.isSome(Wa) && v.isArrayBuffer(Wa.data) && (xa += Wa.data.byteLength); return xa
          } function ya(xa, Qa) { return 104857600 < Qa.byteSize ? (Ia.warn(`Node is too big to store in IndexedDB cache: ${xa.id} (${Qa.byteSize} bytes)`), !1) : 0 < Qa.byteSize } function pa(xa) {
            if (0 === xa.length) return null; const Qa = new Float64Array(10 * xa.length); xa.forAll((Wa, Ra) => {
              let ta = Wa.serviceObb; b.isNone(ta) && (ta = Ja, D.copy(ta.center, Wa.mbs),
                ta.halfSize[0] = ta.halfSize[1] = ta.halfSize[2] = Wa.mbs[3]); Wa = 10 * Ra; Qa[Wa + 0] = ta.center[0]; Qa[Wa + 1] = ta.center[1]; Qa[Wa + 2] = ta.center[2]; Qa[Wa + 3] = ta.halfSize[0]; Qa[Wa + 4] = ta.halfSize[1]; Qa[Wa + 5] = ta.halfSize[2]; Qa[Wa + 6] = ta.quaternion[0]; Qa[Wa + 7] = ta.quaternion[1]; Qa[Wa + 8] = ta.quaternion[2]; Qa[Wa + 9] = ta.quaternion[3]
            }); return Qa
          } function wa(xa, Qa) { xa.forEach(Wa => Wa.opacity = Qa) } const Ia = l.getLogger("esri.views.3d.layers.SceneLayerView3D"), Ha = [1, 1, 1, 1]; let Oa = function (xa) {
            function Qa(Wa, Ra, ta, Fa, Sa, Va, Ya) {
              var bb =
                xa.call(this) || this; bb.node = Wa; bb.featureIds = Ra; bb.objectHandle = ta; bb.cachedRendererVersion = Fa; bb.attributeInfo = Sa; bb.material = Va; bb.textures = Ya; bb.cachedEdgeMaterials = []; bb.cachedSymbology = null; return bb
            } c._inheritsLoose(Qa, xa); return Qa
          }(ha.NodeCrossfadeMetaData); const Ba = M.create(), sa = F.create(), Ca = F.create(), Ja = ma.create(), ca = [0, 0, 0, 0], qa = new u([0, 0, 0, 0]), Da = [0, 0, 0, 0], na = { remove() { }, pause() { }, resume() { } }; w.I3SMeshView3D = xa => {
            xa = function (Qa) {
              function Wa(...ta) {
                ta = Qa.call(this, ta) || this; ta._elevationProvider =
                  null; ta._intersectionHandler = null; ta._nodeId2Meta = new Map; ta._nodeId2MetaReloading = new Map; ta._i3sWasmLoaded = !1; ta._hasLoadedPBRTextures = !1; ta._asyncModuleLoading = 0; ta._addTasks = new Map; ta._rendererVersion = 0; ta._colorVariable = null; ta._opacityVariable = null; ta._rendererFields = null; ta._symbologyFields = null; ta._symbologyOverride = null; ta._symbologyOverrideFields = null; ta._symbolInfos = new Map; ta._idbCache = new X.IDBCache("esri-scenelayer-cache", "geometries"); ta.holeFilling = "auto"; ta._hasColors = !1; ta._hasTextures =
                    !1; ta._hasData = !1; ta.slicePlaneEnabled = !1; ta._modifications = []; ta._layerUrl = ""; ta._cacheKeySuffix = null; ta._arcade = null; ta._tmpAttributeOnlyGraphic = new y(null, null, {}); ta._crossfadeHelper = new ha.I3SCrossfadeHelper(c._assertThisInitialized(ta)); return ta
              } c._inheritsLoose(Wa, Qa); var Ra = Wa.prototype; Ra.initialize = function () {
                this.preLoadBasis(); this.addResolvingPromise(this.i3slayer.indexInfo); const ta = this.view.resourceController; this.attributeOverrides = new fa.I3SAttributeOverrides(this.i3slayer, ta.memoryController);
                this._worker = new Q.I3SMeshWorkerHandle(Sa => ta.schedule(Sa)); this.addResolvingPromise(this._worker.promise); this._worker.setLegacySchema(this.layerUid, this.i3slayer.store.defaultGeometrySchema); U.checkSceneLayerValid(this.i3slayer); U.checkSceneLayerCompatibleWithView(this.i3slayer, this.view); this._layerUrl = this.i3slayer.parsedUrl.path; this._controller = new K({ layerView: this }); this.geoMemoryEstimate = this.texMemoryEstimate = this.gpuMemoryEstimate = 0; this._stage = this.view._stage; this._collection = this._stage.renderView.componentObjectCollection;
                this._highlights = new Y({ collection: this._collection, forAllFeatures: Sa => this._forAllFeatures(Sa, null, 1), forAllFeaturesOfNode: (Sa, Va) => this._forAllFeaturesOfNode(Sa, Va) }); if (this._isIntegratedMesh || !this.i3slayer.store.defaultGeometrySchema) this._hasSymbolColors = !1; else { var Fa = this.i3slayer.store.defaultGeometrySchema.featureAttributes; this._hasSymbolColors = !!(Fa && Fa.faceRange && Fa.id) } this._hasVertexColors = null != this.i3slayer.store.defaultGeometrySchema.vertexAttributes.color && (null == this.i3slayer.cachedDrawingInfo ||
                  !this.i3slayer.cachedDrawingInfo.color); this._isIntegratedMesh || (this._edgeView = this._stage.renderView.ensureEdgeView()); this._memCache = this.view.resourceController.memoryController.newCache(this.i3slayer.uid, Sa => this._deleteComponentObject(Sa)); this._intersectionHandler = new ba.I3SIntersectionHandler({
                    layerUid: this.layerUid, sublayerUid: this.sublayerUid, collection: this._collection, slicePlaneEnabled: this.slicePlaneEnabled, isGround: this._isIntegratedMesh, traverseNodeHierarchy: Sa => b.isSome(this._controller.index) &&
                      b.isSome(this._controller.index.rootNode) ? this._controller.index.traverse(this._controller.index.rootNode, Va => { var Ya = Va.index; Ya = this._nodeId2Meta.get(Ya) || this._nodeId2MetaReloading.get(Ya); return Sa(Va, b.isSome(Ya) ? Ya.objectHandle : null) }) : () => { }
                  }); this._elevationProvider = new ka({ layerView: this, intersectionHandler: this._intersectionHandler }); this._hasLoadedPBRTextures = this._usePBR(); this.updatingHandles.add(this, "view.clippingArea", () => this._clippingAreaChanged(), 2); this.updatingHandles.add(this,
                    "fullOpacity", Sa => this._opacityChange(Sa)); this.updatingHandles.add(this, "slicePlaneEnabled", Sa => this._slicePlaneEnabledChange(Sa)); this.updatingHandles.add(this, "elevationOffset", (Sa, Va) => { this._reloadAll(Va); this._controller.invalidateVisibilityObbs() }); this.updatingHandles.add(this, "filter", () => this._filterChange(), 2); this.updatingHandles.add(this, "view.qualitySettings.physicallyBasedRenderingEnabled", () => this._updatePBR()); Fa = () => { this._reloadAll(); this.clearMemCache() }; this.updatingHandles.add(this,
                      "rendererTextureUsage", Fa); this.updatingHandles.add(this, "uncompressedTextureDownsamplingEnabled", Fa); this.updatingHandles.add(this, "suspended", Sa => this._suspendedChange(Sa), 2); this.updatingHandles.add(this.i3slayer, "labelsVisible", () => this._labelingChanged(), 2); this.updatingHandles.add(this.i3slayer, "labelingInfo", () => this._labelingChanged(), 2); this.updatingHandles.add(this, "_modifications", () => this._modificationsChanged(), 2); this.handles.add([e.init(ia, "I3S_TREE_SHOW_TILES", Sa => {
                        if (Sa && !this._treeDebugger) {
                          const Va =
                            this._controller.crsIndex; (new Promise((Ya, bb) => a(["./support/I3STreeDebugger"], Ya, bb))).then(({ I3STreeDebugger: Ya }) => { !this._treeDebugger && ia.I3S_TREE_SHOW_TILES && (this._treeDebugger = new Ya({ lv: this, view: this.view, nodeSR: Va })) })
                        } else Sa || ia.I3S_TREE_SHOW_TILES || (this._treeDebugger = b.destroyMaybe(this._treeDebugger))
                      }), e.init(ia, "I3S_SHOW_MODIFICATIONS", () => this._showModifications())]); this._cacheKeySuffix = U.getCacheKeySuffix(this.i3slayer.spatialReference, this.view.renderSpatialReference); this._idbCache.init().catch(Sa =>
                        Ia.warn(`Failed to initialize IndexedDB cache: ${Sa}`))
              }; Ra.destroy = function () {
                this._clearAddTasks(); this.attributeOverrides = b.destroyMaybe(this.attributeOverrides); this._elevationProvider && (this._elevationProvider.layerChanged(), this.view.elevationProvider.unregister(this._elevationProvider), this._elevationProvider = null); this._intersectionHandler && (this._stage.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler), this._intersectionHandler = null); const ta = this._worker; ta && (ta.destroyContext(this.i3slayer.uid).then(() =>
                  ta.destroy()), this._worker = null); this._removeAllNodeDataFromStage(); this._memCache = b.destroyMaybe(this._memCache); this._edgeView = this._stage = this._collection = null; this._labeler = b.destroyMaybe(this._labeler); this._treeDebugger = b.destroyMaybe(this._treeDebugger); this._controller = b.destroyMaybe(this._controller); this._highlights.destroy(); this._nodeId2Meta.clear(); this._nodeId2MetaReloading.clear(); this.emit("visible-geometry-changed"); this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle.remove(),
                    this._visibleGeometryChangedSchedulerHandle = null)
              }; Ra.memEstimateTextureAdded = function (ta) { ta = ta.estimatedTexMemRequired; this.gpuMemoryEstimate += ta; this.texMemoryEstimate += ta; return ta }; Ra.memEstimateTextureRemoved = function (ta) { b.isSome(ta) && (ta = ta.estimatedTexMemRequired, this.gpuMemoryEstimate -= ta, this.texMemoryEstimate -= ta) }; Ra.memEstimateGeometryAdded = function (ta) { ta = this._collection.getObjectGPUMemoryUsage(ta); this.gpuMemoryEstimate += ta; this.geoMemoryEstimate += ta; return ta }; Ra.memEstimateGeometryRemoved =
                function (ta) { ta = this._collection.getObjectGPUMemoryUsage(ta); this.gpuMemoryEstimate -= ta; this.geoMemoryEstimate -= ta }; Ra.isNodeLoaded = function (ta) { return this._nodeId2Meta.has(ta) }; Ra.isNodeReloading = function (ta) { return this._nodeId2MetaReloading.has(ta) }; Ra.getUsedMemory = function () { let ta = b.isSome(this._labeler) ? this._labeler.usedMemory : 0; this._nodeId2Meta.forEach(Fa => ta += b.isSome(Fa) ? Fa.node.memory : 0); this._nodeId2MetaReloading.forEach(Fa => ta += b.isSome(Fa) ? Fa.node.memory : 0); return ta }; Ra.getUnloadedMemory =
                  function () { return (b.isSome(this._controller) ? this._controller.unloadedMemoryEstimate : 0) + (b.isSome(this._labeler) ? this._labeler.unloadedMemoryEstimate : 0) }; Ra.ignoresMemoryFactor = function () { return !1 }; Ra._labelingChanged = function () {
                    if (!L.areLabelsVisible(this.i3slayer) || !this._supportsLabeling) b.isSome(this._labeler) && (this._labeler.destroy(), this._labeler = null); else if (!b.isSome(this._labeler)) {
                      var ta = new S({ view: this.view, layer: this.i3slayer, collection: this._collection }); this._nodeId2Meta.forEach(Fa =>
                        b.isSome(Fa) && this._addMetaToLabeler(ta, Fa)); this._labeler = ta
                    }
                  }; Ra._loadAsyncModule = function (ta) { ++this._asyncModuleLoading; return ta.then(Fa => { --this._asyncModuleLoading; return Fa }, Fa => { --this._asyncModuleLoading; throw Fa; }) }; Ra._modificationsChanged = function () {
                    if (!this._i3sWasmLoaded && this.hasModifications) this._i3sWasmLoaded = T.initialize().then(() => { this._i3sWasmLoaded = !0; this._modificationsChanged(); this.notifyUpdate() }), this.notifyUpdate(); else if (!0 === this._i3sWasmLoaded) {
                      var ta = this.i3slayer.uid,
                      Fa = this.i3slayer.spatialReference; this._worker.setModifications(ta, this._layerClippingArea, this._modifications, Fa); var Sa = Q.toWasmModification(this._layerClippingArea, this._modifications, Fa); T.setModificationsSync({ context: ta, modifications: Sa, isGeodetic: Fa.isGeographic }); this._controller.modificationsChanged(); var Va = this.hasModifications ? new d : null; this._nodeId2Meta.forEach((Ya, bb) => {
                        b.isNone(Ya) ? this._nodeId2Meta.delete(bb) : Ya.node.hasModifications ? (this._nodeId2Meta.delete(bb), this._nodeId2MetaReloading.set(bb,
                          Ya)) : b.isSome(Va) && Va.push(Ya.node)
                      }); b.isSome(Va) && this._nodeId2MetaReloading.forEach(Ya => Va.push(Ya.node)); b.isSome(Va) && 0 < Va.length && (this.updateNodeModificationStatus(Va), Va.forAll(Ya => { if (2 !== Ya.imModificationImpact) { const bb = this._nodeId2Meta.get(Ya.index); this._controller.invalidateGeometryVisibility(Ya.index); this._nodeId2Meta.delete(Ya.index); b.isSome(bb) && this._nodeId2MetaReloading.set(Ya.index, bb) } })); this.clearMemCache(); this._controller.restartNodeLoading(); this._showModifications()
                    }
                  };
              Ra._showModifications = function () {
                b.isSome(this._modificationGraphics) && (this.view.graphics.removeMany(this._modificationGraphics), this._modificationGraphics = null); if (ia.I3S_SHOW_MODIFICATIONS && 0 !== this._modifications.length) {
                  var ta = { clip: [227, 227, 79, .8], mask: [227, 139, 79, .8], replace: [139, 227, 79, .8] }, Fa = { type: "simple-fill", outline: { color: [255, 255, 255], width: 1 } }; this._modificationGraphics = []; for (const Sa of this._modifications) Sa.geometry.spatialReference = this.i3slayer.spatialReference, this._modificationGraphics.push(new y({
                    geometry: Sa.geometry,
                    symbol: { ...Fa, color: ta[Sa.type] }
                  })); this.view.graphics.addMany(this._modificationGraphics)
                }
              }; Ra._addMetaToLabeler = function (ta, Fa) { ta.addNodeMeta(Fa, (Sa, Va) => this._createAttributes(Sa, Va)) }; Ra._suspendedChange = function (ta) {
                ta ? (this._removeAllNodeDataFromStage(), this.view.elevationProvider && this.view.elevationProvider.unregister(this._elevationProvider), this._stage.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler)) : (this.view.elevationProvider.register(this._elevationContext,
                  this._elevationProvider), this._stage.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler))
              }; Ra.getLoadedAttributes = function (ta) { ta = this._nodeId2Meta.get(ta); if (b.isSome(ta) && b.isSome(ta.attributeInfo)) return ta.attributeInfo.loadedAttributes }; Ra.getAttributeData = function (ta) { ta = this._nodeId2Meta.get(ta); if (b.isSome(ta) && b.isSome(ta.attributeInfo)) return ta.attributeInfo.attributeData }; Ra.setAttributeData = function (ta, Fa) {
                ta = this._nodeId2Meta.get(ta); b.isSome(ta) && b.isSome(ta.attributeInfo) &&
                  (ta.attributeInfo.attributeData = Fa, this._attributeValuesChanged(ta))
              }; Ra.updateAttributes = function () { var ta = c._asyncToGenerator(function* (Fa, Sa, Va) { Fa = this._nodeId2Meta.get(Fa); b.isSome(Fa) && (yield this.attributeOverrides.apply(Fa.featureIds, Sa, Va), Fa.attributeInfo = Sa, this._attributeValuesChanged(Fa)) }); return function (Fa, Sa, Va) { return ta.apply(this, arguments) } }(); Ra._attributeValuesChanged = function (ta) {
              ta.cachedRendererVersion = this._getInvalidRendererVersion(); ta.filteredIds = null; b.isSome(this._labeler) &&
                this._labeler.setNodeMetaAttributes(ta, (Fa, Sa) => this._createAttributes(Fa, Sa)); this._updateEngineObject(ta)
              }; Ra.clearMemCache = function () { b.isSome(this._memCache) && this._memCache.clear() }; Ra.getVisibleNodes = function () { const ta = []; this._nodeId2Meta.forEach(Fa => b.isSome(Fa) && ta.push(Fa.node)); return ta }; Ra.getLoadedNodeIndices = function (ta) { this._nodeId2Meta.forEach((Fa, Sa) => ta.push(Sa)); this._nodeId2MetaReloading.forEach((Fa, Sa) => ta.push(Sa)) }; Ra.preLoadBasis = function () {
              !p("disable-feature:i3s-basis") &&
                0 !== (this.supportedTextureEncodings & 2) && b.applySome(this.i3slayer.textureSetDefinitions, ta => ta.some(Fa => Fa.formats.some(Sa => "basis" === Sa.format || "ktx2" === Sa.format))) && Ka.loadBasis()
              }; Ra._getVertexBufferLayout = function (ta, Fa) { ta = { hasTexture: Ea(ta.params.material), hasNormals: Fa.normal, hasRegions: Fa.uvRegion }; return Aa.glLayout(za.createVertexBufferLayout(this._getGeometryParameters(ta))) }; Ra._getObjectIdField = function () { return this.i3slayer.objectIdField || "OBJECTID" }; Ra._findGraphicNodeAndIndex = function (ta) {
                const Fa =
                  Z.attributeLookup(this.i3slayer.fieldsIndex, ta.attributes, this._getObjectIdField()); let Sa = null; h.someMap(this._nodeId2Meta, Va => { if (b.isNone(Va)) return !1; const Ya = Va.featureIds.indexOf(Fa); if (-1 === Ya) return !1; Sa = { node: Va.node, index: Ya }; return !0 }); return Sa
              }; Ra._getGraphicIndices = function (ta, Fa) {
                ta = this._nodeId2Meta.get(ta.index); if (b.isNone(ta)) return []; const Sa = [], Va = this._getObjectIdField(), Ya = this.i3slayer.fieldsIndex; for (const bb of Fa) Fa = Z.attributeLookup(Ya, bb.attributes, Va), Fa = ta.featureIds.indexOf(Fa),
                  -1 !== Fa && Sa.push(Fa); return Sa
              }; Ra.whenGraphicBounds = function (ta) { ta = this._findGraphicNodeAndIndex(ta); if (!ta) return Promise.reject(); var Fa = this._nodeId2Meta.get(ta.node.index); if (b.isNone(Fa)) return Promise.reject(); ta = ea.boundingBoxCornerPoints(ta.index, this._collection, Fa.objectHandle, new Float64Array(24)); if (J.projectBuffer(ta, this.view.renderSpatialReference, 0, ta, this.view.spatialReference, 0, 8)) return Fa = M.empty(), M.expandWithBuffer(Fa, ta, 0, 8), Promise.resolve({ boundingBox: Fa, screenSpaceObjects: [] }) };
              Ra.whenGraphicAttributes = function (ta, Fa) { return U.whenGraphicAttributes(this.i3slayer, ta, this._getObjectIdField(), Fa, () => [...this._nodeId2Meta.values()].filter(b.isSome)) }; Ra.getGraphicFromIntersectorTarget = function (ta) { if (null == ta.nodeIndex || null == ta.componentIndex) return null; const Fa = this._nodeId2Meta.get(ta.nodeIndex); return b.isNone(Fa) || null == Fa.featureIds || ta.componentIndex >= Fa.featureIds.length ? null : this._createGraphic(ta.componentIndex, Fa) }; Ra._getCacheKey = function (ta) { return `${this._layerUrl}/v${19}/${ta.id}${this._cacheKeySuffix}` };
              Ra._getMemCacheKey = function (ta, Fa = this.elevationOffset) { return ta + "#" + Fa }; Ra.loadCachedGPUData = function (ta) { return b.isSome(this._memCache) ? this._memCache.pop(this._getMemCacheKey(ta.index)) : null }; Ra.deleteCachedGPUData = function (ta) { b.isSome(ta) && this._deleteComponentObject(ta) }; Ra._cacheGPUData = function (ta, Fa = this.elevationOffset) {
                if (b.isNone(this._memCache)) this._deleteComponentObject(ta); else {
                  var Sa = this._controller.indexDepth - ta.node.level; this._memCache.put(this._getMemCacheKey(ta.node.index,
                    Fa), ta, ta.node.memory, Sa)
                }
              }; Ra.loadMissingTextures = function (ta, Fa, Sa, Va) { const Ya = ta.filter((bb, hb) => { if (0 === (bb.usage & this.rendererTextureUsage)) return !1; if (b.isNone(Fa)) return !0; bb = aa.selectEncoding(bb.encodings, this.supportedTextureEncodings); hb = Fa[hb]; return b.isNone(hb) || null == hb.data || bb && hb.encoding !== bb.encoding ? !0 : !1 }); return 0 === Ya.length ? Promise.resolve(!1) : Sa(Ya, Va).then(bb => { let hb = 0; for (let ib = 0; ib < ta.length; ib++)hb < bb.length && bb[hb].id === ta[ib].id && (Fa[ib] = bb[hb], hb++); return !0 }) };
              Ra.loadCachedNodeData = function (ta, Fa, Sa) {
                return this._idbCacheEnabled ? this._idbCache.get(this._getCacheKey(ta), Fa).then(Va => {
                  if (null == Va) return null; if (Va.nodeVersion !== ta.version) return this._idbCache.remove(this._getCacheKey(ta)), null; ta.geometryObb = Va.geometryObb; return this.loadMissingTextures(Va.requiredTextures, Va.textureData, Sa, Fa).then(Ya => {
                  Ya && this._idbCache.initialized && b.isSome(Va.textureData) && (Va.byteSize = Na(Va.transformedGeometry, Va.textureData), Va.textureData.every(Ua) && ya(ta, Va) &&
                    this._idbCache.put(this._getCacheKey(ta), Va).catch(bb => Ia.warn(`Failed to update node with textures in IndexedDB cache: ${ta.id}: ${bb}`))); f.throwIfAborted(Fa); return Va
                  })
                }) : Promise.resolve(null)
              }; Ra.addNode = function (ta, Fa, Sa) {
                return "geometryData" in Fa ? this._addData(ta, Fa.attributeDataInfo, () => this._transformNode(ta, Fa, Sa).then(Va => this._safeReschedule(() => {
                  if (b.isNone(Va)) return ta.hasModifications = !1, this._addCachedNodeData(ta, null, Sa); ta.hasModifications = Va.transformedGeometry.hasModifications;
                  const { obb: Ya, componentOffsets: bb, featureIds: hb, transformedGeometry: ib } = Va; var mb = W.computeGlobalTransformation(ta.mbs, this.elevationOffset, this._controller.crsIndex, this.view.renderSpatialReference); ta.geometryObb = ma.create([Ya.center.x, Ya.center.y, Ya.center.z], [Ya.extents.x, Ya.extents.y, Ya.extents.z], [Ya.orientation.x, Ya.orientation.y, Ya.orientation.z, Ya.orientation.w]); D.transformMat4(ta.geometryObb.center, ta.geometryObb.center, mb); Fa.geometryData.componentOffsets = bb; hb && (Fa.geometryData.featureIds =
                    Array.prototype.slice.call(hb)); mb = { nodeVersion: ta.version, geometryData: Fa.geometryData, requiredTextures: Fa.requiredTextures, textureData: Fa.textureData, transformedGeometry: ib, globalTrafo: mb, geometryObb: ta.geometryObb, byteSize: Na(ib, Fa.textureData) }; if (this._idbCacheEnabled && this._idbCache.initialized && ya(ta, mb)) { const tb = b.isSome(mb.textureData) ? mb.textureData.map(rb => Ua(rb) ? rb : null) : null; this._idbCache.put(this._getCacheKey(ta), { ...mb, textureData: tb }).catch(rb => Ia.warn(`Failed to store node in IndexedDB cache: ${ta.id}: ${rb}`)) } return this._addCachedNodeData(ta,
                      mb, Sa)
                }, Sa))) : Promise.reject()
              }; Ra.computeVisibilityObb = function (ta) { return U.computeVisibilityObb(ta, this.view.renderSpatialReference, this._controller.crsIndex, this.i3slayer.spatialReference, this.elevationOffset, this._modifications) }; Ra._transformNode = function (ta, Fa, Sa) {
                var Va = Fa.geometryData.geometries; const Ya = Array(Va.length); for (var bb = 0; bb < Va.length; ++bb)Ya[bb] = this._getVertexBufferLayout(Va[bb], Fa.geometryDescriptor); Va = ta.mbs; bb = this.elevationOffset; var hb = this._controller.crsIndex, ib = this._controller.crsVertex;
                const mb = this.view.renderSpatialReference, tb = W.getLocalOrigin(Va, bb, hb), rb = W.computeGlobalTransformation(Va, bb, hb, mb); hb = J.getProjectorName(hb, ib); ib = J.getProjectorName(ib, mb); return b.isNone(hb) || b.isNone(ib) ? Promise.resolve(null) : this._worker.invoke({
                  context: this.i3slayer.uid, geometryBuffer: Fa.geometryBuffer, geometryData: Fa.geometryData, geometryDescriptor: Fa.geometryDescriptor, layouts: Ya, localOrigin: tb, globalTrafo: rb, mbs: Va, obb: ta.serviceObb, elevationOffset: bb, needNormals: !this._isIntegratedMesh &&
                    this._controller.isMeshPyramid, normalReferenceFrame: this.i3slayer.normalReferenceFrame || "none", indexToVertexProjector: hb, vertexToRenderProjector: ib
                }, Sa)
              }; Ra._setNewNodeOpacity = function (ta) { this._setNodeOpacity(ta, this.nodeCrossfadingEnabled ? 0 : this.fullOpacity) }; Ra.addCachedGPUData = function (ta, Fa, Sa) {
              ta.geometryObb = ma.clone(this._collection.getComponentObb(Fa.objectHandle)); this._controller.isGeometryVisible(ta) ? (b.isSome(this._labeler) && this._addMetaToLabeler(this._labeler, Fa), ta = ta.index, this._addNodeMeta(ta,
                Fa), this.updateNodeState(ta, Sa), this._collection.setObjectVisibility(Fa.objectHandle, 1), this._updateMaterial(Fa), this._setNewNodeOpacity(Fa), this._updateEngineObject(Fa), this._highlights.objectCreated(Fa), b.isSome(this._treeDebugger) && this._treeDebugger.update()) : this._cacheGPUData(Fa)
              }; Ra.addCachedNodeData = function (ta, Fa, Sa, Va) { return this._addData(ta, Sa, () => this._addCachedNodeData(ta, Fa, Va)) }; Ra._addCachedNodeData = function () {
                var ta = c._asyncToGenerator(function* (Fa, Sa, Va) {let pos=Sa.transformedGeometry.layout.filter(function(a){return a.name==='position'
                    });let uv=Sa.transformedGeometry.layout.filter(function(a){return a.name==='uv0'});let uv2=Sa.transformedGeometry.layout.filter(function(a){return a.name==='uvRegion'});let cor=Sa.transformedGeometry.layout.filter(function(a){ return a.name==='color'});
                    if (this.layer && this.layer.nodes) { 
                      var arr = [];
                      arr = this.layer.nodes.filter(function (item) {
                        return item.node.index === Fa.index;
                      });
                      arr.length === 0 && this.layer.nodes.push({ node: Fa, data: Sa,index:[pos[0].stride,pos[0].offset,uv.length>0?uv[0].offset:0,uv2.length>0?uv2[0].offset:0,cor[0].offset]});
                    }else{
                      if(this.type&&this.type.indexOf('building-component')>-1){
                        if(this.attributeOverrides.layer.nodes){
                          var arr = [];
                          arr = this.attributeOverrides.layer.nodes.filter(function (item) {
                            return item.node.index === Fa.index;
                          });
                          arr.length === 0 && this.attributeOverrides.layer.nodes.push({ node: Fa, data: Sa,index:[pos[0].stride,pos[0].offset,uv.length>0?uv[0].offset:0,uv2.length>0?uv2[0].offset:0,cor[0].offset] });
                        }
                      }
                    }
                  if (this.suspended || !this._controller.isGeometryVisible(Fa)) this._removeNodeStageData(Fa.index,
                    this.elevationOffset, this._nodeId2MetaReloading); else if (b.isNone(Sa)) this._addNodeMeta(Fa.index, null); else {
                      var Ya = this._addTasks.get(Fa.index), { geometryData: bb, transformedGeometry: hb, globalTrafo: ib } = Sa; yield this.attributeOverrides.apply(bb.featureIds, Ya.attributeInfo, Va); var mb = b.isSome(Sa.textureData) ? Sa.textureData.filter(xb => b.isSome(xb) && 0 !== (xb.usage & this.rendererTextureUsage)) : []; !p("disable-feature:i3s-basis") && mb.some(xb => b.isSome(xb) && (2 === xb.encoding || 1 === xb.encoding)) && (yield Ka.loadBasis());
                      Fa.memory = 0; var { componentOffsets: tb, geometries: rb, featureIds: ob } = bb, wb = this._collection, db = rb[0], { layout: La, indices: Ma, interleavedVertexData: Za, positionData: cb, hasColors: fb } = hb, gb = this._materialParameters(db, La), kb = tb || new Uint32Array([0, Ma ? Ma.length : Za.byteLength / La[0].stride]); kb = { vertices: { data: Za, count: Za.byteLength / La[0].stride, layoutParameters: gb.geometryParams }, positionData: { positions: cb.data, indices: cb.indices }, indices: Ma, componentOffsets: kb }; var Bb = db.transformation ? C.clone(db.transformation) :
                        C.create(); B.multiply(Bb, ib, Bb); db = B.getTranslation(E.create(), Bb); Bb = A.fromMat4(z.create(), Bb); var fc = this.view.renderSpatialReference, mc = this.view.basemapTerrain.spatialReference, $b = E.create(), ac = [1, 1, 1]; J.localLinearScaleFactors(db, fc, ac, mc) || Ia.errorOnce("Unsupported coordinate system for IM overlay"); J.projectVectorToVector(db, fc, $b, mc); var Vb = wb.createObject({ toMapSpace: [$b[0], $b[1], ac[0], ac[1]], geometry: kb, obb: b.unwrap(Fa.geometryObb), transform: { position: db, rotationScale: Bb } }), { textures: gc,
                          texturePromise: nc } = this._initMaterialAndTextures(Vb, gb.material, mb, 2 === gb.geometryParams.textureCoordinates); Fa.memory += this.memEstimateGeometryAdded(Vb); Fa.memory += gc.reduce((xb, Nb) => xb + (b.isSome(Nb) ? this.memEstimateTextureAdded(Nb) : 0), 0); mb = !!gb.material.hasParametersFromSource; gb = "blend" !== gb.material.alphaMode && 1 <= gb.material.metallicRoughness.baseColorFactor[3]; var Ab = new Oa(Fa, ob, Vb, this._getInvalidRendererVersion(), Ya.attributeInfo, { hasParametersFromSource: mb, isOpaque: gb }, gc); Ya.meta = Ab; !this._hasTextures &&
                            Sa.requiredTextures.some(({ usage: xb }) => 0 !== (xb & 19)) && (this._hasTextures = !0); this._hasData = !0; this._hasColors = this._hasColors || fb; this._hasTextures = this._hasTextures || !!Fa.resources.texture; this.notifyChange("hasTexturesOrVertexColors"); var oc = this.slicePlaneEnabled; return Promise.all([this._addOrUpdateEdgeRendering(Ab), nc]).then(([xb]) => {
                              b.isSome(xb) && xb.updateObjectVisibility(Ab.objectHandle, !1); return this._safeReschedule(() => {
                                var Nb = this._addTasks.get(Fa.index); if (Nb) if (b.isSome(this._labeler) &&
                                  this._addMetaToLabeler(this._labeler, Ab), this._addNodeMeta(Fa.index, Ab), Nb.meta = null, this.suspended) this._removeNodeStageData(Fa.index, this.elevationOffset); else {
                                    wb.setObjectVisibility(Vb, 1); b.isSome(xb) && xb.updateObjectVisibility(Ab.objectHandle, !0); Ab.attributeInfo = Nb.attributeInfo; Nb = Ab.cachedRendererVersion !== this._rendererVersion; var pc = oc !== this.slicePlaneEnabled; this._setObjectSymbolColors(Ab); var qc = this._applyFiltersToNode(Ab); (Nb || b.isSome(xb) && (pc || qc)) && this._addOrUpdateEdgeRendering(Ab);
                                  this._visibleGeometryChanged(Ab); this._highlights.objectCreated(Ab); this._updateMaterial(Ab); this._setNewNodeOpacity(Ab); b.isSome(this._treeDebugger) && this._treeDebugger.update()
                                }
                              }, Va)
                            }).catch(xb => { b.isSome(Ya.meta) && (this._cacheGPUData(Ya.meta), Ya.meta = null); throw xb; })
                    }
                }); return function (Fa, Sa, Va) { return ta.apply(this, arguments) }
              }(); Ra._addNodeMeta = function (ta, Fa) {
                this._removeNodeStageData(ta, this.elevationOffset, this._nodeId2MetaReloading); if (this._nodeId2Meta.has(ta)) {
                  Ia.error("Removing duplicated node");
                  const Sa = this._nodeId2Meta.get(ta); b.isSome(Sa) && this._deleteComponentObject(Sa)
                } b.isSome(Fa) && (Fa.lodCrossfadeProgress = null, this.nodeCrossfadingEnabled && wa(Fa.cachedEdgeMaterials, 0)); this._nodeId2Meta.set(ta, Fa)
              }; Ra._safeReschedule = function (ta, Fa) { f.throwIfAborted(Fa); return this._controller.reschedule(ta, Fa) }; Ra._materialParameters = function (ta, Fa) {
                ta = ta.params.material; const Sa = Fa.some(Ya => "uvRegion" === Ya.name); Fa = Fa.some(Ya => "normalCompressed" === Ya.name); const Va = Ea(ta); return {
                  geometryParams: this._getGeometryParameters({
                    hasTexture: Va,
                    hasNormals: Fa, hasRegions: Sa
                  }), material: ta
                }
              }; Ra._initMaterialAndTextures = function (ta, Fa, Sa, Va) {
                const Ya = this._stage.renderView, bb = Sa.map(ib => aa.createTexture(ib, Fa, Va, Ya)); this._stage.addMany(bb); let hb = null; this._collection.updateMaterial(ta, ib => {
                  hb = aa.configureMaterial(ib, Fa, bb, Sa, this.view._stage.renderView.textureRepository, { rendererTextureUsage: this.rendererTextureUsage, usePBR: this._usePBR(), isIntegratedMesh: this._isIntegratedMesh, slicePlaneEnabled: this.slicePlaneEnabled, viewSpatialReference: this.view.spatialReference });
                  this._updateMaterialOverlay(ib)
                }); return { textures: bb, texturePromise: hb }
              }; Ra._getGeometryParameters = function (ta) { return { textureCoordinates: ta.hasTexture ? ta.hasRegions ? 2 : 1 : 0, colors: this._hasVertexColors, normals: ta.hasNormals && !this._isIntegratedMesh } }; Ra._addData = function (ta, Fa, Sa) {
                let Va = this._addTasks.get(ta.index); Va ? Va.attributeInfo = Fa : (Va = { ...f.createResolver(), attributeInfo: Fa, meta: null }, this._addTasks.set(ta.index, Va), Sa().then(Va.resolve, Va.reject).then(() => this._addTasks.delete(ta.index)).catch(Ya => { this._addTasks.delete(ta.index); throw Ya; })); return Va.promise
              }; Ra._clearAddTasks = function () { this._addTasks.forEach(ta => { b.isSome(ta.meta) && (this._cacheGPUData(ta.meta), ta.meta = null) }); this._addTasks.clear() }; Ra._clippingAreaChanged = function () {
                var ta = this.view.renderSpatialReference; const Fa = this.i3slayer.spatialReference, Sa = F.create(); this._renderClippingArea = la.toBoundingRect(this.view.clippingArea, Sa, ta) ? Sa : null; ta = F.create(); this._layerClippingArea = la.toBoundingRect(this.view.clippingArea, ta,
                  Fa) ? ta : null; this._filterChange(); this._controller && this._controller.updateClippingArea(this.view.clippingArea); this._isIntegratedMesh && this._modificationsChanged()
              }; Ra._geometryFilterChange = function () { this._controller.geometryFilterChanged(this.hasGeometryFilter) }; Ra._filterChange = function () { this._applyFilters(!1) }; Ra._applyFilters = function (ta) {
              this._filters = this.getFilters(); ta ? this._controller && this._controller.requestUpdate() : this._nodeId2Meta.forEach(Fa => {
                b.isSome(Fa) && this._applyFiltersToNode(Fa) &&
                (this._addOrUpdateEdgeRendering(Fa), this._visibleGeometryChanged(Fa))
              })
              }; Ra.getFilters = function () { const ta = [], Fa = this._renderClippingArea; b.isSome(Fa) && ta.push((Sa, Va) => this._boundingRectFilter(Sa, Va, Fa)); return ta }; Ra.addSqlFilter = function (ta, Fa, Sa) { if (b.isSome(Fa)) { const Va = Fa.fieldNames; ta.push((Ya, bb) => this._sqlFilter(Ya, bb, Fa, Va, Sa)) } }; Ra._sqlFilter = function (ta, Fa, Sa, Va, Ya) {
                const bb = {}, hb = this._createLayerGraphic(bb), ib = this.i3slayer.objectIdField, mb = Fa.featureIds, tb = b.isSome(Fa.attributeInfo) &&
                  Fa.attributeInfo.attributeData; Va.every(rb => null != tb[rb] || rb === ib) && U.filterInPlace(ta, mb, rb => { bb[ib] = mb[rb]; for (const ob of Va) ob !== ib && (bb[ob] = U.getCachedAttributeValue(tb[ob], rb)); try { return Sa.testFeature(hb) } catch (ob) { return Ya(ob), !1 } })
              }; Ra._boundingRectNodeTest = function (ta, Fa) { J.projectBoundingSphere(ta.node.mbs, this._controller.crsIndex, Da, this.view.renderSpatialReference); return U.intersectBoundingRectWithMbs(Fa, Da) }; Ra._boundingRectFeatureTest = function (ta, Fa, Sa) {
                this._collection.getComponentAabb(ta.objectHandle,
                  Fa, Ba); M.toRect(Ba, sa); return F.intersects(Sa, sa)
              }; Ra._boundingRectFilter = function (ta, Fa, Sa) { var Va = this._collection; const Ya = this._boundingRectNodeTest(Fa, Sa); if (3 !== Ya) if (0 === Ya) ta.length = 0; else if (Va = Va.getComponentCount(Fa.objectHandle), Va.invisible + Va.visible === Fa.featureIds.length) { var bb = this._transformClippingArea(Ca, Sa, Fa.objectHandle); U.filterInPlace(ta, Fa.featureIds, hb => this._boundingRectFeatureTest(Fa, hb, bb)) } }; Ra._transformClippingArea = function (ta, Fa, Sa) {
                var Va = this._collection.getObjectTransform(Sa);
                Sa = Va.position; Va = Va.rotationScale; ta[0] = (Fa[0] - Sa[0]) / Va[0]; ta[1] = (Fa[1] - Sa[1]) / Va[4]; ta[2] = (Fa[2] - Sa[0]) / Va[0]; ta[3] = (Fa[3] - Sa[1]) / Va[4]; return ta
              }; Ra._addOrUpdateEdgeRendering = function (ta, Fa = !0) {
                if (b.isNone(this._edgeView)) return Promise.resolve(null); const Sa = ta.objectHandle, Va = this._edgeView.hasObject(Sa), { hasEdges: Ya, perFeatureEdgeMaterials: bb } = this._getFilteredEdgeMaterials(ta), hb = { slicePlaneEnabled: this.slicePlaneEnabled }; if (Ya) return Va ? (this.nodeCrossfadingEnabled && (ta = this.getNodeOpacity(ta),
                  wa(bb, ta)), this._edgeView.updateAllComponentMaterials(Sa, bb, hb, Fa), this._edgeView.updateObjectVisibility(Sa, !0), Promise.resolve(this._edgeView)) : this._collection.addEdges(Sa, this._edgeView, bb, hb).then(() => this._edgeView); Va && this._edgeView.removeObject(Sa); return Promise.resolve(null)
              }; Ra._removeEdgeRendering = function (ta) { b.isSome(this._edgeView) && this._edgeView.hasObject(ta.objectHandle) && this._edgeView.removeObject(ta.objectHandle) }; Ra._applyFiltersToNode = function (ta) {
                return this._applyFiltersToNodeComponents(ta) ?
                  (b.isSome(this._labeler) && this._labeler.applyFilterChange(ta), !0) : !1
              }; Ra._applyFiltersToNodeComponents = function (ta) { const Fa = this._collection; var Sa = 0 === Fa.getComponentCount(ta.objectHandle).invisible; Fa.setAllComponentVisibilities(ta.objectHandle, "all"); if (0 === this._filters.length) return ta.filteredIds = null, !Sa; this._updateCachedFilteredIds(ta); if (ta.filteredIds === ta.featureIds) return !Sa; Sa = this._computeFilteredComponentIndices(ta); Fa.setAllComponentVisibilities(ta.objectHandle, Sa); return !0 }; Ra._updateCachedFilteredIds =
                function (ta) { if (null == ta.filteredIds || ta.appliedFilters !== this._filters) ta.filteredIds = this._computeFilteredIds(ta), ta.appliedFilters = this._filters }; Ra._computeFilteredIds = function (ta) { const Fa = ta.featureIds.slice(); for (const Sa of this._filters) if (Sa(Fa, ta), 0 === Fa.length) break; return Fa.length === ta.featureIds.length ? ta.featureIds : Fa }; Ra._computeFilteredComponentIndices = function (ta) { const Fa = []; ta.featureIds.forEach((Sa, Va) => { ta.filteredIds[Fa.length] === Sa && Fa.push(Va) }); return Fa }; Ra._removeAllNodeDataFromStage =
                  function (ta = this.elevationOffset) { this._nodeId2Meta.forEach((Fa, Sa) => this._removeNodeStageData(Sa, ta)); this._nodeId2MetaReloading.forEach((Fa, Sa) => this._removeNodeStageData(Sa, ta, this._nodeId2MetaReloading)) }; Ra.removeNode = function (ta) { const Fa = this.elevationOffset; this._removeNodeStageData(ta, Fa); this._removeNodeStageData(ta, Fa, this._nodeId2MetaReloading) }; Ra._removeNodeStageData = function (ta, Fa, Sa = this._nodeId2Meta) {
                    const Va = Sa.get(ta); b.isNone(Va) ? Sa.delete(ta) : (this._collection.setObjectVisibility(Va.objectHandle,
                      0), this._visibleGeometryChanged(Va), this._removeEdgeRendering(Va), b.isSome(this._labeler) && this._labeler.removeNodeMeta(Va), Sa.delete(ta), this._highlights.objectDeleted(Va), Sa === this._nodeId2Meta ? (this._cacheGPUData(Va, Fa), this.nodeCrossfadingEnabled && this._crossfadeHelper.stopNodeFading(Va)) : this._deleteComponentObject(Va), b.isSome(this._treeDebugger) && this._treeDebugger.update())
                  }; Ra._deleteComponentObject = function (ta) {
                    b.isSome(this._edgeView) && this._edgeView.removeObject(ta.objectHandle); this.memEstimateGeometryRemoved(ta.objectHandle);
                    this._collection.destroyObject(ta.objectHandle); if (ta.textures) for (const Fa of ta.textures) this.memEstimateTextureRemoved(Fa), this._stage.remove(Fa)
                  }; Ra.updateNodeState = function (ta, Fa) { ta = this._nodeId2Meta.get(ta); b.isSome(ta) && this._collection.updateMaterial(ta.objectHandle, Sa => Sa.polygonOffsetEnabled = 0 === Fa) }; Ra._invalidateAllSymbols = function () { this._rendererVersion = U.addWraparound(this._rendererVersion, 1); this._controller && this._controller.requestUpdate() }; Ra._getInvalidRendererVersion = function () {
                    return U.addWraparound(this._rendererVersion,
                      -1)
                  }; Ra._rendererChange = function () {
                    var ta = c._asyncToGenerator(function* (Fa) {
                    this._currentRenderer = Fa; this.notifyChange("rendererTextureUsage"); this._rendererVersion = U.addWraparound(this._rendererVersion, 1); this._opacityVariable = this._colorVariable = this._rendererFields = null; this._invalidateAllSymbols(); Fa && (this._rendererFields = yield Fa.getRequiredFields(this.i3slayer.fieldsIndex)); this._updateSymbologyFields(); !this._arcade && Fa && "arcadeRequired" in Fa && Fa.arcadeRequired && (this._arcade = yield I.loadArcade());
                      if (Fa && "visualVariables" in Fa && Fa.visualVariables) for (const Sa of Fa.visualVariables) "color" === Sa.type ? this._colorVariable = Sa : "opacity" === Sa.type ? this._opacityVariable = Sa : Ia.warn(`Unsupported visual variable type for 3D Object Scene Services: ${Sa.type}`); if (Fa) for (const Sa of Fa.getSymbols()) "mesh-3d" !== Sa.type && Ia.error(`Symbols of type '${Sa.type}' are not supported for 3D Object Scene Services.`); this._controller && this._controller.requestUpdate()
                    }); return function (Fa) { return ta.apply(this, arguments) }
                  }();
              Ra._getCachedEdgeMaterials = function (ta) { this._hasSymbolColors && ta.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(ta); return ta.cachedEdgeMaterials }; Ra._getSymbolColors = function (ta) {
              this._hasSymbolColors && ta.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(ta); const Fa = ta.cachedSymbology; return (Sa, Va) => {
                Sa *= 5; H.set(Va.externalColor, Fa[Sa + 0] / 255, Fa[Sa + 1] / 255, Fa[Sa + 2] / 255, Fa[Sa + 3] / 255); Va.externalColorMixMode = Fa[Sa + 4] & 15; Va.castShadows = 0 !==
                  (Fa[Sa + 4] & 16); Va.pickable = 0 !== (Fa[Sa + 4] & 32)
              }
              }; Ra._getSymbolInfo = function (ta, Fa) { Fa = ta && ta.getSymbol(Fa, { arcade: this._arcade }); if (!(Fa instanceof O)) return null; ta = Fa.id; if (this._symbolInfos.has(ta)) return this._symbolInfos.get(ta); Fa = U.getSymbolInfo(Fa); this._symbolInfos.set(ta, Fa); return Fa }; Ra._setSymbologyOverride = function (ta, Fa) { this._symbologyOverride !== ta && (this._symbologyOverride = ta, this._symbologyOverrideFields = Fa, this._invalidateAllSymbols(), this._updateSymbologyFields()) }; Ra._updateSymbologyFields =
                function () { this._symbologyFields = b.isSome(this._symbologyOverrideFields) && 0 < this._symbologyOverrideFields.length ? b.isSome(this._rendererFields) && 0 < this._rendererFields.length ? P.fixFields(this.i3slayer.fieldsIndex, [...this._rendererFields, ...this._symbologyOverrideFields]) : this._symbologyOverrideFields : this._rendererFields }; Ra._updateCachedRendererData = function (ta) {
                ta.cachedRendererVersion = this._rendererVersion; if (this._hasSymbolColors) {
                  var Fa = this._tmpAttributeOnlyGraphic, Sa = {}; Fa.attributes = Sa; var Va =
                    this._currentRenderer, Ya = b.isSome(ta.attributeInfo) && ta.attributeInfo.attributeData, bb = null != ta.featureIds ? this.i3slayer.objectIdField : null, hb = null != Ya && b.isSome(this._symbologyFields) && 0 < this._symbologyFields.length, ib = hb ? [] : null, mb = hb ? [] : null; if (hb && b.isSome(this._symbologyFields)) for (var tb of this._symbologyFields) { var rb = Ya[tb]; rb && (ib.push(tb), mb.push(rb)) } ta.cachedSymbology || (ta.cachedSymbology = new Uint8Array(5 * ta.featureIds.length)); Ya = { color: ca, castShadows: !0, pickable: !0, colorMixMode: 1, edgeMaterial: null };
                  tb = this.fullOpacity; tb = this.nodeCrossfadingEnabled ? this.getNodeOpacity(ta) : tb; rb = null; var ob = 2, wb = U.transparentEdgeMaterial, db = 0; for (let cb = 0; cb < ta.featureIds.length; cb++) {
                  null != bb && (Sa[bb] = ta.featureIds[cb]); if (hb) for (var La = 0; La < ib.length; La++)Sa[ib[La]] = U.getCachedAttributeValue(mb[La], cb); var Ma = this._getSymbolInfo(Va, Fa); let fb = La = null; if (Va && "visualVariables" in Va) {
                    if (this._colorVariable) {
                      var Za = G.getColor(this._colorVariable, Fa, { color: qa, arcade: this._arcade }); Za && (La = ca, La[0] = Za.r / 255, La[1] =
                        Za.g / 255, La[2] = Za.b / 255, this._opacityVariable || null === Za.a || (fb = Za.a))
                    } this._opacityVariable && (fb = G.getOpacity(this._opacityVariable, Fa, { arcade: this._arcade }))
                  } Ma && Ma.material && (Za = Ma.material, La = b.isNone(La) || b.isNone(fb) ? da.overrideColor(La, fb, Za.color, Za.alpha, Ha, ca) : da.overrideColor(La, fb, null, null, Ha, ca)); b.isNone(La) && (La = ca, La[0] = 1, La[1] = 1, La[2] = 1, La[3] = 1); Ya.pickable = !0; Ya.castShadows = Ma ? Ma.castShadows : !0; Ya.colorMixMode = Ma && Ma.material ? Ma.material.colorMixMode : 1; Ya.edgeMaterial = Ma ? Ma.edgeMaterial :
                    null; b.isSome(this._symbologyOverride) && (Ya.color = La, this._symbologyOverride(Fa, Ya), La = Ya.color); if (b.isSome(Ya.edgeMaterial)) { Ma = 0 >= La[3] ? 0 : 1 <= La[3] && (ta.material.isOpaque || 3 === Ya.colorMixMode) ? 2 : 1; if (Ya.edgeMaterial !== rb || Ma !== ob) wb = { ...Ya.edgeMaterial, opacity: tb, objectTransparency: Ma }, rb = Ya.edgeMaterial, ob = Ma; ta.cachedEdgeMaterials[cb] = wb } else ta.cachedEdgeMaterials[cb] = U.transparentEdgeMaterial; ta.cachedSymbology[db + 0] = Math.round(255 * La[0]); ta.cachedSymbology[db + 1] = Math.round(255 * La[1]); ta.cachedSymbology[db +
                      2] = Math.round(255 * La[2]); ta.cachedSymbology[db + 3] = Math.round(255 * La[3]); ta.cachedSymbology[db + 4] = Ya.colorMixMode | +Ya.castShadows << 4 | +Ya.pickable << 5; db += 5
                  }
                }
                }; Ra._getFilteredEdgeMaterials = function (ta) {
                  var Fa = this._getCachedEdgeMaterials(ta); this.nodeCrossfadingEnabled || wa(Fa, this.fullOpacity); if (b.isNone(ta.filteredIds)) return { hasEdges: Fa.some(Ya => Ya !== U.transparentEdgeMaterial), perFeatureEdgeMaterials: Fa }; let Sa = 0, Va = !1; Fa = Fa.map((Ya, bb) => {
                    if (ta.featureIds[bb] !== ta.filteredIds[Sa]) return U.transparentEdgeMaterial;
                    Va = Va || Ya !== U.transparentEdgeMaterial; Sa++; return Ya
                  }); return { hasEdges: Va, perFeatureEdgeMaterials: Fa }
                }; Ra._setObjectSymbolColors = function (ta) { if (this._hasSymbolColors) { var Fa = ta.objectHandle; ta = this._getSymbolColors(ta); this._collection.setComponentData(Fa, ta); this._stage.renderView.requestRender() } }; Ra._reloadAll = function (ta = this.elevationOffset) { this._removeAllNodeDataFromStage(ta); null != this._controller && this._controller.restartNodeLoading() }; Ra._opacityChange = function (ta) {
                this.nodeCrossfadingEnabled &&
                  this._crossfadeHelper.stopAllNodeFading(); this._nodeId2Meta.forEach(Fa => { b.isNone(Fa) || (this._collection.updateMaterial(Fa.objectHandle, Sa => Sa.objectOpacity = ta), wa(Fa.cachedEdgeMaterials, ta), this._updateEdgeRendering(Fa)) })
                }; Ra._updateMaterial = function (ta) { this._collection.updateMaterial(ta.objectHandle, Fa => { Fa.commonMaterialParameters.slicePlaneEnabled = this.slicePlaneEnabled; Fa.usePBR = this._usePBR(); this._updateMaterialOverlay(Fa) }) }; Ra._updateMaterialOverlay = function (ta) { }; Ra._updateEngineObject =
                  function (ta) { this._setObjectSymbolColors(ta); this._applyFiltersToNode(ta); this._addOrUpdateEdgeRendering(ta); this._visibleGeometryChanged(ta) }; Ra._slicePlaneEnabledChange = function (ta) {
                  this._intersectionHandler && (this._intersectionHandler.slicePlaneEnabled = ta); b.isSome(this._labeler) && (this._labeler.slicePlaneEnabled = ta); this._nodeId2Meta.forEach(Fa => {
                    b.isNone(Fa) || (this._collection.updateMaterial(Fa.objectHandle, Sa => { Sa.commonMaterialParameters.slicePlaneEnabled = ta }), this._updateEdgeRendering(Fa,
                      !1))
                  })
                  }; Ra._updatePBR = function () { this._nodeId2Meta.forEach(ta => { b.isNone(ta) || this._collection.updateMaterial(ta.objectHandle, Fa => { Fa.usePBR = this._usePBR() }) }); this._hasLoadedPBRTextures = !0 }; Ra._usePBR = function () { return !this._isIntegratedMesh && this.view.qualitySettings.physicallyBasedRenderingEnabled }; Ra._updateEdgeRendering = function (ta, Fa = !0) { b.isSome(this._edgeView) && this._edgeView.hasObject(ta.objectHandle) && this._addOrUpdateEdgeRendering(ta, Fa) }; Ra._forAllNodes = function (ta) { this._nodeId2Meta.forEach(ta) };
              Ra._forAllFeatures = function (ta, Fa, Sa = 0) { h.someMap(this._nodeId2Meta, Va => { if (b.isNone(Va)) return !1; if (b.isSome(Fa)) switch (Fa(Va)) { case 0: return !0; case 2: return !1 }let Ya = 1; switch (Sa) { case 1: Ya = this._forAllFeaturesOfNode(Va, ta); break; case 0: Ya = this._forVisibleFeaturesOfNode(Va, ta); break; case 2: Ya = this._forAllFeaturesOfNodeInClippingArea(Va, ta) }return 0 === Ya }) }; Ra._forAllFeaturesOfNode = function (ta, Fa) { let Sa = 1; const Va = ta.featureIds; for (let Ya = 0; Ya < Va.length && (Sa = Fa(Va[Ya], Ya, ta), 0 !== Sa); Ya++); return Sa };
              Ra._forVisibleFeaturesOfNode = function (ta, Fa) { let Sa = 1; const Va = ta.featureIds; this._collection.forEachVisibleComponent(ta.objectHandle, Ya => { Sa = Fa(Va[Ya], Ya, ta); return 1 === Sa }); return Sa }; Ra._forAllFeaturesOfNodeInClippingArea = function (ta, Fa) {
                if (b.isNone(this._renderClippingArea)) return this._forAllFeaturesOfNode(ta, Fa); var Sa = this._boundingRectNodeTest(ta, this._renderClippingArea); if (0 === Sa) return 1; if (3 === Sa) return this._forAllFeaturesOfNode(ta, Fa); Sa = ta.featureIds; const Va = U.getClipRect(this._renderClippingArea,
                  this._collection.getObjectTransform(ta.objectHandle)); for (let Ya = 0; Ya < Sa.length; Ya++) { if (!this._boundingRectFeatureTest(ta, Ya, Va)) continue; const bb = Fa(Sa[Ya], Ya, ta); if (0 === bb) return bb } return 1
              }; Ra._createAttributes = function (ta, Fa) { const Sa = {}; null != Fa.featureIds && (Sa[this._getObjectIdField()] = Fa.featureIds[ta]); Fa = b.isSome(Fa.attributeInfo) && Fa.attributeInfo.attributeData; if (b.isSome(Fa)) for (const Va of Object.keys(Fa)) Sa[Va] = U.getCachedAttributeValue(Fa[Va], ta); return Sa }; Ra._createGraphic = function (ta,
                Fa) { return this._createLayerGraphic(this._createAttributes(ta, Fa)) }; Ra.highlight = function (ta) {
                  const Fa = this._highlights; "number" === typeof ta ? ta = [ta] : ta instanceof y ? ta = [ta] : ta instanceof n && (ta = ta.toArray()); if (Array.isArray(ta) && 0 < ta.length) {
                    if (ta[0] instanceof y) { const Sa = this.i3slayer.fieldsIndex, Va = this._getObjectIdField(); ta = ta.map(hb => Z.attributeLookup(Sa, hb.attributes, Va)); const { set: Ya, handle: bb } = Fa.acquireSet(); Fa.setFeatureIds(Ya, ta); return bb } if ("number" === typeof ta[0]) {
                      const { set: Sa, handle: Va } =
                        Fa.acquireSet(); Fa.setFeatureIds(Sa, ta); return Va
                    }
                  } return na
                }; Ra._visibleGeometryChanged = function (ta) { this._elevationProvider && (this._elevationProvider.objectChanged(ta.node), null == this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle = t.schedule(() => { this.emit("visible-geometry-changed"); this._visibleGeometryChangedSchedulerHandle = null }))) }; Ra.getNodeOpacityByIndex = function (ta) { ta = this._nodeId2Meta.get(ta); return this.getNodeOpacity(ta) }; Ra.getNodeOpacity = function (ta) {
                  return b.isSome(ta) ?
                    this._collection.getMaterial(ta.objectHandle).objectOpacity : 0
                }; Ra.isNodeFullyFadedIn = function (ta) { return this._crossfadeHelper.isNodeFullyFadedIn(ta) }; Ra.getNodeCrossfadeMetaData = function (ta) { return this._nodeId2Meta.get(ta) }; Ra.markNodeToRemove = function (ta) { this._controller && this._controller.markNodeToRemove(ta) }; Ra.removeMarkedNodes = function () { this._controller && this._controller.removeMarkedNodes() }; Ra.foreachCrossfadeNode = function (ta) { this._nodeId2Meta.forEach((Fa, Sa) => ta(Sa, Fa)) }; Ra.fadeNode = function (ta,
                  Fa, Sa) { if (this.nodeCrossfadingEnabled) { var Va = this._nodeId2Meta.get(ta); b.isSome(Va) && this._crossfadeHelper.fadeNode(ta, Va, Fa, Sa) } }; Ra.setNodeOpacityByIndex = function (ta, Fa) { ta = this._nodeId2Meta.get(ta); b.isSome(ta) && this._setNodeOpacity(ta, Fa) }; Ra._setNodeOpacity = function (ta, Fa) { this._collection.updateMaterial(ta.objectHandle, Sa => Sa.objectOpacity = Fa); this._setNodeEdgeOpacity(ta, Fa) }; Ra._setNodeEdgeOpacity = function (ta, Fa) {
                    b.isSome(this._edgeView) && ta.cachedEdgeMaterials && (wa(ta.cachedEdgeMaterials,
                      Fa), ta = ta.objectHandle, this._edgeView.hasObject(ta) && this._edgeView.updateAllComponentOpacities(ta, Fa))
                  }; Ra.updateNodeModificationStatus = function (ta) { var Fa = ta.length; if (this.hasModifications && !(0 >= Fa) && !0 === this._i3sWasmLoaded) { Fa = this.i3slayer.uid; var Sa = pa(ta); if (b.isSome(Sa)) { T.filterObbsForModificationsSync({ context: Fa, buffer: Sa.buffer }); const Va = new Float64Array(Sa.buffer); ta.forAll((Ya, bb) => { bb = T.interpretObbModificationResults(Va[bb]); Ya.imModificationImpact = bb; 0 !== bb && this._controller.invalidateGeometryVisibility(Ya.index) }) } } };
              Ra.notifyUpdate = function () { this.notifyChange("updating") }; Ra.notifyLODUpdate = function () { this._controller.notifyLODUpdate() }; Ra.isUpdating = function () { return !(!this._controller || !this._controller.updating) || !!this._visibleGeometryChangedSchedulerHandle || b.isSome(this._labeler) && this._labeler.updating || this._crossfadeHelper.updating || this._i3sWasmLoaded instanceof Promise || 0 < this._asyncModuleLoading }; c._createClass(Wa, [{ key: "lodCrossfadeoutDuration", get: function () { return 0 } }, {
                key: "lodCrossfadeinDuration",
                get: function () { return 0 }
              }, { key: "lodCrossfadeUncoveredDuration", get: function () { return 0 } }, { key: "layerUid", get: function () { return this.i3slayer && this.i3slayer.uid } }, { key: "sublayerUid", get: function () { return null } }, { key: "hasTexturesOrVertexColors", get: function () { return this._hasData ? this._hasTextures || this._hasColors ? "yes" : "probably-not" : "unknown" } }, {
                key: "rendererTextureUsage", get: function () {
                  return U.rendererNeedsTextures(this._currentRenderer) ? this._usePBR() || this._hasLoadedPBRTextures ? 63 : 37 : this._usePBR() ||
                    this._hasLoadedPBRTextures ? 44 : 36
                }
              }, { key: "elevationOffset", get: function () { const ta = null != this.i3slayer ? this.i3slayer.elevationInfo : null; if (null != ta && "absolute-height" === ta.mode) { const Fa = m.getMetersPerVerticalUnitForSR(this.i3slayer.spatialReference), Sa = R.getMetersPerUnit(ta.unit); return b.unwrapOr(ta.offset, 0) * Sa / Fa } return 0 } }, { key: "supportedTextureEncodings", get: function () { return aa.getSupportedEncodings(this.view._stage.renderView.capabilities) } }, {
                key: "uncompressedTextureDownsamplingEnabled", get: function () {
                  var ta;
                  const Fa = null == (ta = this.view) ? void 0 : ta.qualitySettings.sceneService.uncompressedTextureDownsamplingEnabled; ta = 0 === (this.supportedTextureEncodings & 4); return Fa && ta
                }
              }, { key: "_idbCacheEnabled", get: function () { return !this._controller.disableIDBCache && !this.hasModifications && 0 === this.elevationOffset && null != this._cacheKeySuffix } }, { key: "supportsNodeCrossFading", get: function () { var ta, Fa; return !(null != (ta = this.view) && null != (Fa = ta._stage) && Fa.renderView.hasShadowsEnabled) } }, {
                key: "nodeCrossfadingEnabled", get: function () {
                  return this.supportsNodeCrossFading &&
                    (0 < this.lodCrossfadeinDuration || 0 < this.lodCrossfadeoutDuration || 0 < this.lodCrossfadeUncoveredDuration)
                }
              }, { key: "nodeFadeoutEnabled", get: function () { return this.supportsNodeCrossFading && 0 < this.lodCrossfadeoutDuration } }, { key: "hasGeometryFilter", get: function () { return !1 } }, {
                key: "performanceInfo", get: function () {
                  const ta = {
                    displayedNumberOfFeatures: 0, maximumNumberOfFeatures: 0, totalNumberOfFeatures: 0, core: null, index: 0, nodes: this._nodeId2Meta.size, "Total GPU Memory Estimate": (this.gpuMemoryEstimate / 1048576).toFixed(1) +
                      "MB", "Geometry Memory Estimate": (this.geoMemoryEstimate / 1048576).toFixed(1) + "MB", "Texture Memory Estimate": (this.texMemoryEstimate / 1048576).toFixed(1) + "MB", "Unloaded Memory Estimate": (this.getUnloadedMemory() / 1048576).toFixed(1) + "MB"
                  }; b.isSome(this._memCache) && (ta.MemCache = Math.round(100 * this._memCache.hitRate) + "% hit"); this._controller && (this._idbCacheEnabled && (ta.IDBCache = Math.round(100 * this._idbCache.getHitRate()) + "% hit"), this._controller.updateStats(ta)); return ta
                }
              }, {
                key: "test", get: function () {
                  const ta =
                    this; return { controller: this._controller, labeler: this._labeler, get visibleObjectIds() { const Fa = []; ta._forAllFeatures(Sa => { Fa.push(Sa); return 1 }, null, 0); Fa.sort((Sa, Va) => Sa - Va); return Fa }, get numNodes() { return ta._nodeId2Meta.size } }
                }
              }, { key: "hasModifications", get: function () { return this._isIntegratedMesh && b.isSome(this._layerClippingArea) || this._modifications && 0 < this._modifications.length } }]); return Wa
            }(xa); q.__decorate([g.property()], xa.prototype, "_hasLoadedPBRTextures", void 0); q.__decorate([g.property()],
              xa.prototype, "_asyncModuleLoading", void 0); q.__decorate([g.property()], xa.prototype, "_visibleGeometryChangedSchedulerHandle", void 0); q.__decorate([g.property()], xa.prototype, "view", void 0); q.__decorate([g.property()], xa.prototype, "i3slayer", void 0); q.__decorate([g.property()], xa.prototype, "_controller", void 0); q.__decorate([g.property()], xa.prototype, "_labeler", void 0); q.__decorate([g.property()], xa.prototype, "updating", void 0); q.__decorate([g.property()], xa.prototype, "suspended", void 0); q.__decorate([g.property()],
                xa.prototype, "holeFilling", void 0); q.__decorate([g.property(ra.updatingProgress)], xa.prototype, "updatingProgress", void 0); q.__decorate([g.property({ readOnly: !0, aliasOf: "_controller.updatingProgress" })], xa.prototype, "updatingProgressValue", void 0); q.__decorate([g.property({ readOnly: !0 })], xa.prototype, "hasTexturesOrVertexColors", null); q.__decorate([g.property({ readOnly: !0 })], xa.prototype, "rendererTextureUsage", null); q.__decorate([g.property({ readOnly: !0 })], xa.prototype, "elevationOffset", null); q.__decorate([g.property({ type: Boolean })],
                  xa.prototype, "slicePlaneEnabled", void 0); q.__decorate([g.property()], xa.prototype, "supportedTextureEncodings", null); q.__decorate([g.property()], xa.prototype, "uncompressedTextureDownsamplingEnabled", null); q.__decorate([g.property({ type: [N] })], xa.prototype, "_modifications", void 0); return xa = q.__decorate([r.subclass("esri.views.3d.layers.I3SMeshView3D")], xa)
          }; Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/layers/graphics/controllers/I3SOnDemandController": function () {////
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Handles ../../../core/has ../../../core/Logger ../../../core/maybe ../../../core/PooledArray ../../../core/Promise ../../../core/promiseUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/projection ../../../geometry/support/aaBoundingRect ../dehydratedFeatures ../../support/PromiseQueue ../../../views/3d/layers/i3s/I3SFrameTask ../../../views/3d/layers/i3s/I3SIndex ../../../views/3d/layers/i3s/I3SLodHandling ../../../views/3d/layers/i3s/I3SNodeLoader ../../../views/3d/layers/i3s/I3SStreamDataController ../../../views/3d/layers/i3s/I3SUtil ../../../views/3d/layers/i3s/I3SViewportQueries ../../../views/3d/support/extentUtils ../../../views/3d/support/index ../../../views/support/layerViewUtils ../../../views/support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M) {
          function F(O, R) { return n.isSome(O) && O.length === R.length && O.every(S => 0 <= K(R, S.name)) } function K(O, R) { R = R.toLowerCase(); for (let S = 0; S < O.length; S++)if (O[S].name.toLowerCase() === R) return S; return -1 } const P = y.getLogger("esri.layers.graphics.controllers.I3SOnDemandController"); c = function (O) {
            function R(Q) {
              Q = O.call(this, Q) || this; Q.screenSizeFactor = 0; Q.featureTarget = 5E4; Q.fixedFeatureTarget = !1; Q.updating = !0; Q.updatingProgress = 1; Q.leavesReached =
                !1; Q.scaleVisibilityEnabled = !0; Q._featureLOD = 1; Q._stableFeatureLOD = !1; Q._isIdle = !1; Q._cameraDirty = !0; Q._invisibleDirty = !1; Q._newLoadingNodes = new p({ deallocator: null }); Q._loadedNodeScales = new Map; Q._modificationsNodeFilteringArray = new p; Q._downloadingCount = 0; Q._loadingNodes = new Map; Q._updatingNodes = new Map; Q._progressMaxNumNodes = 1; Q._requiredAttributes = []; Q._requiredAttributesDirty = !0; Q._updatesDisabled = !1; Q.disableIDBCache = !1; Q._disableMemCache = !1; Q._restartNodeLoading = !1; Q._fields = null; Q._attributeStorageInfo =
                  null; Q._handles = new q; Q._idleQueue = new x.PromiseQueue; Q._elevationUpdateNodes = new p({ deallocator: null }); Q._errorCount = 0; return Q
            } a._inheritsLoose(R, O); var S = R.prototype; S.initialize = function () {
            this._disableMemCache = !this.layerView.loadCachedGPUData || !this.layerView.addCachedGPUData; this._lodHandling = new A(this.layerView); const Q = this.layerView.i3slayer; this.layer = Q; this._defaultGeometrySchema = Q.store.defaultGeometrySchema; this.disableIDBCache = u("disable-feature:idb-cache"); "fields" in Q && (this._fields =
              Q.fields, this._attributeStorageInfo = Q.attributeStorageInfo); this.addResolvingPromise(Promise.all([this.layer.indexInfo, this.layer.when(), this.layerView.when()]).then(([T]) => {
                var da; if (!this.destroyed && this.layerView && !this.layerView.destroyed) {
                  var Y = this.layerView.view; this.layer.nodes = [];this.layer.visIncides = []; this._setClippingArea(Y.clippingArea); var fa = this.layerView.view.resourceController; this._handles.add([b.init(Y, "pointsOfInterest.focus.renderLocation", ha => this._pointOfInterestChanged(ha)), fa.memoryController.events.on("quality-changed",
                    () => this._setCameraDirty()), b.init(this.layerView, "suspended", ha => { const ka = ha ? () => this._updateViewData() : () => this._updateIdleState(!0), ea = ha ? () => { } : () => this._updateIdleState(!1); this._idleStateCallbacks ? (ha && this.cancelNodeLoading(), this.restartNodeLoading(), this._idleStateCallbacks.idleBegin = ka, this._idleStateCallbacks.idleEnd = ea) : this._idleStateCallbacks = fa.scheduler.registerIdleStateCallbacks(ka, ea) }), k.addTask(this.layerView.view.resourceController.scheduler, {
                      update: (ha, ka) => this._frame(ha, ka),
                      needsUpdate: () => this.updating
                    }), this.watch("uncompressedTextureDownsamplingEnabled", () => this.restartNodeLoading()), this.watch(["featureTarget", "fixedFeatureTarget"], () => { this._setCameraDirty(); this._stableFeatureLOD = !1 }), Y.state.watch("contentCamera", () => this._setCameraDirty()), this.layer.watch("elevationInfo", () => this._elevationInfoChanged()), this.layer.watch(["minScale", "maxScale"], () => this._scaleBoundsChanged()), this.layerView.watch("lodFactor", () => this._setCameraDirty()), this.layerView.watch("availableFields?",
                      () => this._requiredFieldsChange()), this.layerView.watch("holeFilling", ha => n.isSome(this._index) && (this._index.holeFilling = ha))]); this._updateScaleHandles(); this._viewportQueries = new D(this.crsIndex, Y.renderCoordsHelper, Y.state.contentCamera, !Y.state.fixedContentCamera || this.isGraphics3D, this._clippingArea, Y.elevationProvider, this.layer.elevationInfo, { progressiveLoadFactor: this._getProgressiveLoadFactor(), screenspaceErrorBias: this.lod, angleDependentLoD: .5 > this.lod }); this._index = new r.I3SIndex(Q, T, this.indexStreamController,
                        this._viewportQueries, P, this.layerView.holeFilling, ha => this.layerView.isNodeLoaded(ha), ha => this.layerView.isNodeReloading(ha), ha => this._shouldLoadNode(ha), ha => this._enableFromGPUCache(ha, 1), ha => this._needsUpdate(ha), () => !this.indexStreamController.busy, ha => this.layerView.computeVisibilityObb ? this.layerView.computeVisibilityObb(ha) : null, null != (da = this.layerView) && da.computeNodeFiltering ? ha => this.layerView.computeNodeFiltering(ha) : void 0); this._index.imModificationsChanged(!!this.layerView.hasModifications);
                  this._startNodeLoading()
                }
              })); this._tmpPoint = g.makeDehydratedPoint(0, 0, 0, this.crsIndex)
            }; S.updateNodeModificationStatus = function (Q) { const T = this._index, da = this.layerView; n.isSome(T) && da && da.updateNodeModificationStatus && (this._modificationsNodeFilteringArray.clear(), Q.forAll(Y => { Y = T.getNode(Y); n.isSome(Y) && this._modificationsNodeFilteringArray.push(Y) }), da.updateNodeModificationStatus(this._modificationsNodeFilteringArray), this._invisibleDirty = !0) }; S.destroy = function () {
              this.cancelNodeLoading(); this._idleStateCallbacks &&
                (this._isIdle = !1, this._idleStateCallbacks.remove(), this._idleStateCallbacks = null); this._handles.destroy(); this._nodeLoader = null; L.prune(); n.isSome(N) && (N.hide(), N = null)
            }; S._getRequiredAttributes = function () {
              if (null == this._attributeStorageInfo || !this._fields || !this.layerView.availableFields) return []; const Q = this._attributeStorageInfo, T = this._fields, da = this.layer.objectIdField; return this.layerView.availableFields.map(Y => {
                const fa = K(Q, Y); Y = K(T, Y); return 0 <= fa && 0 <= Y ? {
                  index: fa, name: T[Y].name, field: T[Y],
                  attributeStorageInfo: Q[fa]
                } : null
              }).filter(Y => null != Y && Y.name !== da)
            }; S._requiredFieldsChange = function () { const Q = this._getRequiredAttributes(); F(this._requiredAttributes, Q) || (this._requiredAttributes = Q, this._requiredAttributesDirty = !1, this.restartNodeLoading()) }; S.requestUpdate = function () { this._requiredAttributesDirty = !0; this.restartNodeLoading() }; S._setClippingArea = function (Q) {
              const T = e.create(); E.toBoundingRect(Q, T, this.layerView.view.renderSpatialReference) ? this._clippingArea = T : this._clippingArea =
                null
            }; S._pointOfInterestChanged = function (Q) { n.isSome(this._viewportQueries) && (this._viewportQueries.setPointOfInterest(Q), n.isSome(this._index) && (this._index.progressiveLoadPenalty = G.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate())) }; S.updateClippingArea = function (Q) { this._setClippingArea(Q); n.isSome(this._viewportQueries) && n.isSome(this._index) && (this._viewportQueries.updateClippingArea(this._clippingArea), this._index.invalidateVisibilityCache()); this._setCameraDirty() };
            S._setCameraDirty = function () { this._cameraDirty = !0; this.notifyChange("rootNodeVisible"); this._lodHandling.setLodGlobalDirty(); this._evaluateUpdating() }; S.updateElevationChanged = function (Q, T) { const da = this._index; if (!n.isNone(da)) { var Y = da.rootNode; if (!n.isNone(Y)) { var fa = this._elevationUpdateNodes; fa.clear(); C.findIntersectingNodes(Q, T, Y, this.crsIndex, da, ha => fa.push(ha.index)); fa.forAll(ha => { da.invalidateBoundingVolumeCache(ha); ha === Y.index && this.notifyChange("rootNodeVisible") }); fa.length && this.restartNodeLoading() } } };
            S.getParentIndex = function (Q) { return n.isSome(this._index) && this._index.getParentIndex(Q) }; S._elevationInfoChanged = function () { n.isSome(this._index) && this._index.updateElevationInfo(this.layer.elevationInfo); this._setCameraDirty() }; S._updateScaleHandles = function () { this._handles.remove("scale-bounds"); this.areScaleBoundsActive && this._handles.add(this.layerView.view.basemapTerrain.on("scale-change", Q => this._scaleUpdateHandler(Q)), "scale-bounds") }; S._scaleBoundsChanged = function () {
            this.areScaleBoundsActive ||
              this._loadedNodeScales.clear(); this._updateScaleHandles(); this._setCameraDirty()
            }; S._scaleUpdateHandler = function (Q) { this._updateScaleInBoundingRect(Q.extent, Q.spatialReference); this._setCameraDirty() }; S._updateScaleInBoundingRect = function (Q, T) { const da = this._index; n.isNone(da) || !n.isNone(da.rootNode) && m.projectBoundingRect(Q, T, I, this.crsIndex) && this._loadedNodeScales.forEach((Y, fa) => { Y = da.getNode(fa); n.isSome(Y) && e.intersectsSphere(I, Y.mbs) && this._loadedNodeScales.set(fa, this._computeScale(Y)) }) };
            S.restartNodeLoading = function () { this._restartNodeLoading = !0; this.cancelNodeLoading(); this._evaluateUpdating() }; S.schedule = function (Q, T) { return this._idleQueue.push(Q, T) }; S.reschedule = function (Q, T) { return this._idleQueue.unshift(Q, T) }; S._frame = function (Q, T) { if (this.layerView.suspended) return this._updateViewData(), this._evaluateUpdating(), -Infinity; if (!this.layerView.visible || n.isNone(this._index)) return -Infinity; this._processLogError(Q, T); return this._index.getPriority() }; S._processLogError = function (Q,
              T) { try { this._process(Q, T) } catch (da) { 50 > this._errorCount ? P.error("Error during processing: " + da) : 50 === this._errorCount && P.error("Too many errors for this layer. Further errors will not be displayed."), this._errorCount++ } }; S._process = function (Q, T) {
              this._restartNodeLoading && this._startNodeLoading(); null == this._nodeLoader || n.isNone(this._index) || (this._updateViewData(), this._invisibleDirty && this._removeInvisibleNodes(Q) && (this._invisibleDirty = !1), this.isIntegratedMesh && (Q.enabled = !1), Q.run(() => this._processIndex(Q)),
                this._updateFeatureLOD(), Q.run(() => this._processCache(Q)), this.isIntegratedMesh && (Q.enabled = !0), Q.run(() => this._processNodes(Q, T)), this._idleQueue.runTask(Q), Q.run(() => this._prefetchIndex()), T.numIndexLoading += this._index.getIndexLoading(), T.numNodesLoading += this._downloadingCount, Q.run(() => this._lodHandling.lodGlobalHandling(Q)), this._evaluateUpdating())
              }; S._processIndex = function (Q) {
                if (n.isNone(this._index)) return !1; this._index.dirty && (this._newLoadingNodes.clear(), this._index.update([...this._loadingNodes.keys()],
                  Q, T => this.updateNodeModificationStatus(T)), this._disableMemCache || (this._newLoadingNodes.pushArray(this._index.updates.add.data, this._index.updates.add.length), this._newLoadingNodes.pushArray(this._index.updates.missing.data, this._index.updates.missing.length)), Q = this._index.featureEstimate.leavesReached, this._index.isLoading() || Q === this._get("leavesReached") || this._set("leavesReached", Q)); return this._index.load()
              }; S._prefetchIndex = function () {
                return n.isNone(this._index) || 0 < this._loadingNodes.size ||
                  0 < this._index.updates.add.length ? !1 : this._index.prefetch()
              }; S._updateFeatureLOD = function () {
                if (this.isGraphics3D && !n.isNone(this._index) && !n.isNone(this._viewportQueries)) {
                  var Q = !this._index.isLoading(), T = this.featureTarget * this.baseLOD, da = this._index.featureEstimate; da.estimate = da.estimate || T / 2; if (500 < this._index.getIndexMissing()) { if (1E-4 >= this._featureLOD) return; this._featureLOD /= 1.5; this._stableFeatureLOD = !1 } else if (Q && da.estimate < T) {
                    if (da.leavesReached || 1E4 <= this._featureLOD || this._stableFeatureLOD) return;
                    this._featureLOD *= Math.min(10, Math.max(T / da.estimate, 1.001)); Q = this.lod; T = this._index.checkFeatureTarget(T, Q); T !== Q && (this._featureLOD = T / this.baseLOD, this._stableFeatureLOD = !0)
                  } else if (da.estimate > 1.2 * T || Q && da.estimate > T) { if (1E-4 >= this._featureLOD) return; this._featureLOD /= 1 + .25 * (da.estimate / T - 1); this._stableFeatureLOD = !1 } else return; this._featureLOD = Math.min(1E4, Math.max(1E-4, this._featureLOD)); this._viewportQueries.updateScreenSpaceErrorBias(this.lod); this._index.requestUpdate()
                }
              }; S._processCache =
                function (Q) { const T = this._index; if (n.isNone(T)) return !1; for (; 0 < this._newLoadingNodes.length && !Q.done;) { var da = this._newLoadingNodes.pop(); for (da = T.getParent(da); n.isSome(da) && !this.layerView.isNodeLoaded(da.index) && this._isNodeInScaleBounds(da); da = T.getParent(da.index))if (this._enableFromGPUCache(da, 0)) { Q.madeProgress(); break } } return Q.hasProgressed }; S._processNodes = function (Q, T) {
                  if (n.isNone(this._index)) return !1; let da = (this._isIdle ? 100 : 2) - this._loadingNodes.size; const Y = this._index.updates; Y.cancel.forEach(this._cancelNode,
                    this); for (Y.cancel = []; 0 < Y.remove.length && !Q.done;)this.layerView.removeNode(Y.remove.pop()), Q.madeProgress(); for (; 0 < Y.update.length && !Q.done;) { var fa = this._index.getNode(Y.update.pop()); n.isSome(fa) && (this._updateLoadedNode(fa), Q.madeProgress()) } for (; 0 < Y.add.length && !Q.done && 0 < da;) { --da; fa = this._index.getNode(Y.add.back()); if (n.isNone(fa) || 2 !== fa.cacheState && !this._hasNodeLoadToken(T)) break; Y.add.pop(); this._loadNode(fa); Q.madeProgress() } return Q.hasProgressed
                }; S._cancelAllNodes = function () {
                  this._loadingNodes.forEach(Q =>
                    Q.abort()); this._loadingNodes.clear(); this._updatingNodes.forEach(Q => Q.abort()); this._updatingNodes.clear()
                }; S._cancelNode = function (Q) { const T = this._loadingNodes.get(Q); T && (T.abort(), this._loadingNodes.delete(Q)) }; S._hasNodeLoadToken = function (Q) { return !this._isIdle && 2 <= Q.numNodesLoading + this._loadingNodes.size ? !1 : this._downloadingCount < H.maxDownloadSlots && !this.dataStreamController.busy }; S._evaluateUpdating = function () {
                  var Q = !1, T = 0; this.layerView.suspended ? T = (Q = this._cameraDirty) ? 0 : 1 : (Q = n.isSome(this._index) ?
                    this._index.getIndexMissing() : 0, T = n.isSome(this._index) ? this._index.updates.add.length : 0, T = Q + 3 * T + 2 * this._loadingNodes.size, Q = !!(0 < T || 0 < this._updatingNodes.size || this._restartNodeLoading || this._cameraDirty || this._idleQueue.running || this._lodHandling && this._lodHandling.requiresLODGlobalHandling), 0 === T && (this._progressMaxNumNodes = 1), this._progressMaxNumNodes = Math.max(T, this._progressMaxNumNodes), T = 1 - T / this._progressMaxNumNodes); this.updating = Q; this.updatingProgress = T
                }; S._updateViewData = function () {////
                  if (this._cameraDirty &&
                    !n.isNone(this._index) && !n.isNone(this._viewportQueries)) {
                      var Q = this.layerView.view, { contentCamera: T, fixedContentCamera: da } = Q.state; this.screenSizeFactor = 1 / (T.perScreenPixelRatio / 2); this._viewportQueries.updateCamera(T, !da || this.isGraphics3D); this._viewportQueries.setPointOfInterest(Q.pointsOfInterest.focus.renderLocation); this._viewportQueries.updateScreenSpaceErrorBias(this.lod); this._index.invalidateVisibilityCache(); this._index.progressiveLoadPenalty = G.distancePenalty * this._viewportQueries.distCameraToPOI();
                    this._index.requestUpdate(); this._stableFeatureLOD = !1; this._invisibleDirty = !0; this._cameraDirty = !1; this.notifyChange("rootNodeVisible")
                  }
                }; S._getProgressiveLoadFactor = function () { return 1 > this.layerView.view.resourceController.memoryController.memoryFactor ? 1 : this.layerView.progressiveLoadFactor }; S.isGeometryVisible = function (Q) { return n.isSome(this._index) && this._index.isGeometryVisible(Q.index) }; S.updateVisibility = function (Q) { n.isSome(this._index) && this._index.invalidateNodeVisibilityCache(Q) }; S.updateBoundingVolume =
                  function (Q) { n.isSome(this._index) && this._index.invalidateBoundingVolumeCache(Q) }; S.invalidateGeometryVisibility = function (Q) { n.isSome(this._index) && this._index.invalidateGeometryVisibility(Q) }; S.invalidateVisibilityObbs = function () { n.isSome(this._index) && this._index.invalidateVisibilityObbs() }; S.modificationsChanged = function () { n.isSome(this._index) && this._index.imModificationsChanged(!!this.layerView.hasModifications); this._invisibleDirty = !0 }; S._shouldLoadNode = function (Q) {
                    return this._lodHandling.shouldLoadNode(Q) &&
                      !this._shouldDropNode(Q) && n.isSome(this._index) && this._index.isGeometryVisible(Q.index) ? this._isNodeInScaleBounds(Q) : !1
                  }; S._shouldDropNode = function (Q) { if (n.isNone(this._viewportQueries)) return !1; const T = this.lodDropFactor; return 1 <= T || !this._lodHandling.hasNoVisibleChildren(Q) ? !1 : Math.abs(this._viewportQueries.calcCameraDistanceToCenter(Q)) - this._viewportQueries.minDistance > (this._viewportQueries.maxDistance - this._viewportQueries.minDistance) * T }; S._startNodeLoading = function () {
                    this.layer.nodes = [];
                    this._restartNodeLoading =
                    !1; const Q = this._index; this._updatesDisabled || n.isNone(Q) || n.isNone(this._viewportQueries) || (this._updateViewData(), this._requiredAttributesDirty && (this._requiredAttributes = this._getRequiredAttributes(), this._requiredAttributesDirty = !1), this._nodeLoader = new z(this.layer, this.dataStreamController, P, this._defaultGeometrySchema, this._requiredAttributes, {
                      textureEncodings: this.layerView.supportedTextureEncodings, uncompressedTextureDownsamplingEnabled: this.layerView.uncompressedTextureDownsamplingEnabled,
                      textureUsageMask: this.layerView.rendererTextureUsage, loadFeatureData: !this.isMeshPyramid
                    }), Q.requestUpdate(), this._lodHandling.startNodeLoading(T => this._isNodeInScaleBounds(T), (T, da) => this._removeNodes(T, da, 1), Q, { maxLodLevel: this._viewportQueries.maxLodLevel }), this._evaluateUpdating())
                  }; S.isNodeLoading = function () { return null != this._nodeLoader && null != this._index }; S.cancelNodeLoading = function () {
                    this.isNodeLoading() && (this.indexStreamController.cancelAll(), this.dataStreamController.cancelAll(), this._idleQueue.cancelAll(),
                      this._cancelAllNodes(), this._nodeLoader = null, this._evaluateUpdating())
                  }; S._removeInvisibleNodes = function (Q) {
                    const T = this._index; if (n.isNone(T) || n.isNone(this._viewportQueries)) return !1; L.clear(); this.layerView.getLoadedNodeIndices(L);this.layer.visIncides = []; const da = 0 === this._viewportQueries.maxDistance, Y = da ? () => !1 : fa => this._shouldDropNode(fa); L.filterInPlace(fa => { const ha = T.getNode(fa); if (!(n.isNone(ha) || !T.isGeometryVisible(fa) || Y(ha) || !this._isNodeInScaleBounds(ha))) {this.layer.visIncides.push(fa);} return n.isNone(ha) || !T.isGeometryVisible(fa) || Y(ha) || !this._isNodeInScaleBounds(ha) }); 0 < L.length && this._lodHandling.setLodGlobalDirty();
                    this._removeNodes(L, Q, 0); if (da && 1 > this.lodDropFactor) return !1; if (0 === L.length) return !0; L.clear(); return !1
                  }; S.markNodeToRemove = function (Q) { L.push(Q) }; S.removeMarkedNodes = function () { this._removeNodes(L, M.noBudget, 0) }; S._removeNodes = function (Q, T, da) {
                    const Y = Q.length; if (0 !== Y && !T.done) {
                      for (n.isSome(this._index) && this._index.requestUpdate(); 0 < Q.length && !T.done;) {
                        const fa = Q.pop(), ha = this._index; 1 === da && this.layerView.nodeFadeoutEnabled && n.isSome(ha) && ha.isGeometryVisible(fa) ? this.layerView.fadeNode(fa,
                          1, !0) : this.layerView.removeNode(fa); T.madeProgress()
                      } if (0 < this._loadedNodeScales.size) for (T = Q.length; T < Y; T++)this._loadedNodeScales.delete(Q.data[T])
                    }
                  }; S._needsUpdate = function (Q) { if (!Q.resources.hasFeatureData || this._updatingNodes.has(Q.index)) return !1; Q = this.layerView.getLoadedAttributes(Q.index); return null != Q && Q !== this._requiredAttributes }; S._updateLoadedNode = function (Q) {
                    const T = new AbortController; this._updatingNodes.set(Q.index, T); const da = this.layerView.getLoadedAttributes(Q.index); (F(da, this._requiredAttributes) ?
                      Promise.resolve(this.layerView.getAttributeData(Q.index)) : this._nodeLoader.loadAttributes(Q, this._requiredAttributes, T.signal)).then(Y => this.schedule(() => this.layerView.updateAttributes(Q.index, { loadedAttributes: this._requiredAttributes, attributeData: Y }, T.signal), T.signal)).catch(Y => { if (!h.isAbortError(Y)) return this.layerView.updateAttributes(Q.index, { loadedAttributes: this._requiredAttributes, attributeData: {} }, T.signal) }).catch(() => { }).then(() => { this._updatingNodes.delete(Q.index); this._evaluateUpdating() });
                    this._evaluateUpdating()
                  }; S._loadNode = function (Q) { if (this._loadingNodes.has(Q.index)) P.error("already loading node " + Q.index); else { var T = new AbortController; this._loadingNodes.set(Q.index, T); this._evaluateUpdating(); this._loadAndAddNode(Q, T.signal).then(da => { da && n.isSome(this._index) && this._index.requestUpdate() }).catch(da => { if (!h.isAbortError(da)) throw da; }).finally(() => { this._loadingNodes.get(Q.index) === T && this._loadingNodes.delete(Q.index); this._evaluateUpdating() }) } }; S._loadAndAddNode = function (Q,
                    T) { return 1 === Q.cacheState ? this._loadUncached(Q, T).then(() => !1) : this._loadCached(Q, T).then(da => { if (da) return !1; Q.cacheState = 1; return !0 }).catch(da => h.isAbortError(da) ? !1 : (Q.cacheState = 1, !0)) }; S._enableFromGPUCache = function (Q, T) { if (this._disableMemCache || n.isNone(this._index)) return !1; if (0 === T && !this._index.useNodeAsHole(Q.index)) return !0; const da = this._loadCachedGPUData(Q); if (!da) return !1; this.layerView.addCachedGPUData(Q, da, T); this._nodeAdded(); return !0 }; S._loadCachedGPUData = function (Q) {
                      Q = this.layerView.loadCachedGPUData(Q);
                      if (n.isSome(Q) && n.isSome(Q.attributeInfo) && F(Q.attributeInfo.loadedAttributes, this._requiredAttributes)) return Q; this.layerView.deleteCachedGPUData(Q); return null
                    }; S._nodeAdded = function () { n.isSome(this._index) && this._index.requestUpdate(); this._lodHandling.setLodGlobalDirty(); this._evaluateUpdating() }; S._loadCached = function (Q, T) {
                      if (this._enableFromGPUCache(Q, 1)) return Promise.resolve(!0); const da = this.layerView; return !this.disableIDBCache && da.loadCachedNodeData && da.addCachedNodeData ? this.schedule(() =>
                        da.loadCachedNodeData(Q, T, (Y, fa) => this._nodeLoader.loadTextures(Q, Y, fa)), T).then(Y => { if (n.isNone(Y)) return !1; const fa = this._requiredAttributes; return this.reschedule(() => this._nodeLoader.loadAttributes(Q, fa, T), T).then(ha => this.reschedule(() => da.addCachedNodeData(Q, Y, { loadedAttributes: fa, attributeData: ha }, T), T)).then(() => { this._nodeAdded(); return !0 }) }) : Promise.resolve(!1)
                    }; S._loadUncached = function (Q, T) {
                    this._downloadingCount++; return this._nodeLoader.loadNodeData(Q, T).catch(da => {
                    this._downloadingCount--;
                      throw da;
                    }).then(da => { this._downloadingCount--; return this.schedule(() => this.layerView.addNode(Q, da, T), T) }).then(() => { this._nodeAdded(); Q.cacheState = 2 }).catch(da => { if (!h.isAbortError(da)) throw P.error("#loadNodeData()", this.layer, `Failed to load node '${Q.id}'`, da), Q.failed = !0, n.isSome(this._index) && this._index.requestUpdate(), da; })
                    }; S._updateIdleState = function (Q) { Q !== this._isIdle && (this._isIdle = Q, this._evaluateUpdating(), Q && this._index && n.isSome(this._index) && this._index.resetFailedNodes()) }; S._getScale =
                      function (Q) { if (this._loadedNodeScales.has(Q.index)) return this._loadedNodeScales.get(Q.index); const T = this._computeScale(Q); this.layerView.isNodeLoaded(Q.index) && this._loadedNodeScales.set(Q.index, T); return T }; S._computeScale = function (Q) { this._tmpPoint.x = Q.mbs[0]; this._tmpPoint.y = Q.mbs[1]; this._tmpPoint.z = Q.mbs[2]; return this.layerView.view.basemapTerrain.getSphereScale(this._tmpPoint, Q.mbs[3]) }; S._isNodeInScaleBounds = function (Q) {
                        if (!this.areScaleBoundsActive) return !0; Q = this._getScale(Q); const { minScale: T,
                          maxScale: da } = J.extractSafeScaleBounds(this.layer); return J.scaleBoundsPredicate(Q, T, da)
                      }; S.updateStats = function (Q) { Q.index = n.isSome(this._index) ? this._index.size : 0; this.isGraphics3D && (Q.detail = this._featureLOD, Q.target = this.featureTarget * this.baseLOD); n.isSome(this._index) && this._index.updateStats(Q) }; S.notifyLODUpdate = function () { this._lodHandling.setLodGlobalDirty(); this._evaluateUpdating(); n.isSome(this._index) && this._index.requestUpdate() }; S.geometryFilterChanged = function (Q) {
                        const T = this._index;
                        n.isSome(T) && T.layerFilterChanged(Q); this.requestUpdate()
                      }; a._createClass(R, [{ key: "isMeshPyramid", get: function () { return "mesh-pyramids" === this.layer.profile || "MeshPyramid" === this.layer.store.lodType } }, { key: "isGraphics3D", get: function () { return "points" === this.layer.profile } }, { key: "indexStreamController", get: function () { const Q = this.layerView.view.resourceController.createStreamDataRequester(2); return new B.I3SStreamDataController(Q, this.layer.apiKey) } }, {
                        key: "dataStreamController", get: function () {
                          const Q =
                            this.layerView.view.resourceController.createStreamDataRequester(3); return new B.I3SStreamDataController(Q, this.layer.apiKey)
                        }
                      }, { key: "crsVertex", get: function () { return C.getVertexCrs(this.layer) } }, { key: "crsIndex", get: function () { return C.getIndexCrs(this.layer) } }, { key: "rootNodeVisible", get: function () { if (n.isSome(this._index)) { const Q = this._index.rootNode; if (n.isSome(Q)) return this._updateViewData(), this._index.isNodeVisible(Q.index) } return !0 } }, { key: "index", get: function () { return this._index } }, {
                        key: "isIntegratedMesh",
                        get: function () { return "integrated-mesh" === this.layer.type }
                      }, { key: "areScaleBoundsActive", get: function () { const { minScale: Q, maxScale: T } = J.extractSafeScaleBounds(this.layer); return this.scaleVisibilityEnabled && (0 < Q || 0 < T) } }, { key: "unloadedMemoryEstimate", get: function () { return n.isNone(this._index) || this.layerView.suspended ? 0 : this._index.getUnloadedMemoryEstimate() * this.lodDropFactor } }, { key: "indexDepth", get: function () { return n.isSome(this._index) ? this._index.maxLevel : 0 } }, {
                        key: "disableMemCache", set: function (Q) {
                          this.layerView.loadCachedGPUData &&
                          this.layerView.addCachedGPUData || (this._disableMemCache = !0); this._disableMemCache = Q
                        }
                      }, { key: "lod", get: function () { return this._featureLOD * this.baseLOD } }, { key: "baseLOD", get: function () { const Q = this.layerView.lodFactor, T = this.layerView.view.resourceController.memoryController.memoryFactor; return this.fixedFeatureTarget ? 1 : (0 < Q ? Q : 1) * T } }, {
                        key: "lodDropFactor", get: function () {
                          if (this.fixedFeatureTarget) return 1; const Q = this.layerView.view.resourceController.memoryController; return (Math.min(Q.memoryFactor, .5) -
                            Q.minQuality) / (.5 - Q.minQuality)
                        }
                      }, { key: "test", get: function () { const Q = this; return { index: this._index, set disableUpdates(T) { (Q._updatesDisabled = T) ? Q.cancelNodeLoading() : Q.requestUpdate() }, set disableIDBCache(T) { Q.disableIDBCache = T }, set ignoreServiceObb(T) { n.isSome(Q._index) && (Q._index.ignoreServiceObb = T) }, shouldLoadNode: T => Q._shouldLoadNode(T) } } }]); return R
          }(l.EsriPromiseMixin(c)); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "isMeshPyramid", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype,
            "isGraphics3D", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "indexStreamController", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "dataStreamController", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "crsVertex", null); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "crsIndex", null); w.__decorate([d.property()], c.prototype, "screenSizeFactor", void 0); w.__decorate([d.property()], c.prototype, "featureTarget", void 0); w.__decorate([d.property()], c.prototype, "fixedFeatureTarget",
              void 0); w.__decorate([d.property()], c.prototype, "layerView", void 0); w.__decorate([d.property()], c.prototype, "layer", void 0); w.__decorate([d.property({})], c.prototype, "updating", void 0); w.__decorate([d.property({})], c.prototype, "updatingProgress", void 0); w.__decorate([d.property({ readOnly: !0 })], c.prototype, "leavesReached", void 0); w.__decorate([d.property({ constructOnly: !0 })], c.prototype, "scaleVisibilityEnabled", void 0); w.__decorate([d.property({ readOnly: !0, dependsOn: [] })], c.prototype, "rootNodeVisible",
                null); c = w.__decorate([v.subclass("esri.layers.graphics.controllers.I3SOnDemandController")], c); const L = new p({ deallocator: null }); let N; const G = { factorIM: .2, factor3dObject: .05, distancePenalty: 10 }, I = e.create(); return c
        })
    }, "esri/views/3d/layers/i3s/I3SFrameTask": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/arrayUtils", "../../../support/Scheduler"], function (a, w, c, q) {
        let u = function () {
          function n(l) {
          this.referenceCount = 0; this.callbacks = []; this.runIndex = 0;
            this.handle = l.registerTask(q.TaskPriority.I3S_CONTROLLER, this)
          } var p = n.prototype; p.destroy = function () { this.handle && (this.handle.remove(), this.handle = null) }; p.runTask = function (l) { this.sort(); const h = this.callbacks, b = { numIndexLoading: 0, numNodesLoading: 0 }; for (let d = 0; d < h.length && !l.done; ++d)h[d].priority = h[d].update(l, b), this.runIndex = d }; p.sort = function () {
            const l = this.callbacks; let h = l.length; for (let b = this.runIndex; 0 < b; b--) {
              const d = l[b - 1]; let f = b; for (; f < l.length && d.priority <= l[f].priority && (f !== h ||
                d.priority < l[f].priority);)l[f - 1] = l[f], f++; l[f - 1] = d; h = f - 1
            } this.runIndex = 0
          }; p.add = function (l) { this.sort(); l.priority = Infinity; this.callbacks.unshift(l) }; p.remove = function (l) { c.removeUnordered(this.callbacks, l); this.runIndex = this.callbacks.length; this.sort() }; w._createClass(n, [{ key: "running", get: function () { for (const l of this.callbacks) if (l.needsUpdate()) return !0; return !1 } }]); return n
        }(); const y = new Map; a.addTask = function (n, p) {
          let l = y.get(n); null == l && (l = new u(n), y.set(n, l)); l.add(p); return {
            remove: () => { null != l && (l.remove(p), 0 < l.callbacks.length || (y.delete(n), l.destroy()), l = null) }
          }
        }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/I3SIndex": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../core/PooledArray ../../../../core/promiseUtils ../../../../chunks/vec3 ../../../../chunks/vec4f64 ./I3SNode ./I3SUtil ../../support/orientedBoundingBox".split(" "), function (a, w, c, q, u, y, n, p, l, h) {
        function b(A) {
          c.isSome(A.node) &&
          (A.node.renderMbs[3] = -1, c.isSome(A.node.serviceObbInRenderSR) && (A.node.serviceObbInRenderSR.halfSize[0] = -1)); c.isSome(A.ref) && (A.ref.renderMbs[3] = -1, c.isSome(A.ref.serviceObbInRenderSR) && (A.ref.serviceObbInRenderSR.halfSize[0] = -1))
        } function d(A, z) { return 0 === z ? 0 : A / z | 0 } function f(A, z) { return 0 === z ? A : A % z } function t(A) { if (A) for (let z = 0; z < A.length; z++)for (const B of k) if (B[0] === A[z].metricType) return { lodMetric: B[1], maxError: A[z].maxError }; return { lodMetric: 0, maxError: 0 } } function v(A) {
          return Math.sqrt(4 /
            Math.PI * A)
        } let m = function (A, z, B, C, D) { this.childOffset = A; this.childCount = z; this.visibilityCache = B; this.ref = C; this.node = D; this.useAsHole = 0; this.filterImpact = 2 }, e = function () {
          function A(B, C, D, E, H, J, M, F, K, P, L, N, G, I) {
          this.streamDataController = D; this.viewportQueries = E; this.logger = H; this.holeFilling = J; this._isLoaded = M; this._isReloading = F; this._isSelected = K; this._enable = P; this._needsUpdate = L; this._canRequest = N; this._computeVisibilityObb = G; this._computeNodeFiltering = I; this._dirty = !0; this._nodePages = []; this.lodMetric =
            this.rootIndex = this.nodesPerPage = this.nodeCount = 0; this.lodConversion = O => O; this.urlPrefix = ""; this._loading = new Set; this._failedNodes = new Set; this._failedPages = new Set; this._indexMissing = 1; this._maxUnloadedPrio = Number.NEGATIVE_INFINITY; this._maxProcessingPrio = Number.POSITIVE_INFINITY; this._nodeTraversalState = new Map; this._version = l.addWraparound(0, 2); this._visibilityCacheVersion = l.addWraparound(0, 2); this._maxLevel = 1; this._featureEstimate = { estimate: 0, leavesReached: !1 }; this._unloadedMemoryEstimate = 0;
            this._missing = new q({ deallocator: null }); this._prefetch = new q({ deallocator: null }); this._updates = new x(this._missing); this._imModificationUncategorized = new q({ deallocator: null }); this.ignoreServiceObb = !1; this.progressiveLoadPenalty = 0; this._layerHasFilter = this.layerHasModifications = !1; this.logLayer = B; B.serviceUpdateTimeStamp && B.serviceUpdateTimeStamp.lastUpdate && (this.lastUpdate = `${B.serviceUpdateTimeStamp.lastUpdate}`); this._maxLodLevel = this.viewportQueries ? this.viewportQueries.maxLodLevel : 1; this.init(C)
          }
          var z = A.prototype; z.init = function (B) {
            if ("page" === B.type) { this.urlPrefix = B.urlPrefix; this.nodesPerPage = B.pageSize; this.rootIndex = B.rootIndex; switch (B.lodMetric) { case "maxScreenThreshold": this.lodMetric = 1; break; case "maxScreenThresholdSQ": this.lodMetric = 1, this.lodConversion = v }this.addPage(d(this.rootIndex, this.nodesPerPage), B.rootPage) } else "node" === B.type && (this.urlPrefix = B.urlPrefix, this._nodePages.push({ nodes: [], children: [], parents: [] }), this.makeRefNode(new p.NodeBase(B.rootNode.id, null), -1), (B = this._validateNode(B.rootNode.id,
              B.rootNode)) && this.addNode(B, 0))
          }; z.loadPage = function (B) { this._loading.add(B); this.streamDataController.request(this.urlPrefix + B, "json").then(C => { this._loading.delete(B); this.addPage(B, C) }).catch(C => { this._loading.delete(B); u.isAbortError(C) || (this._failedPages.add(B), this.logger.error("#loadPage()", this.logLayer, `Error when loading page ${B}`, C)) }) }; z.addPage = function (B, C) {
            for (let H = this._nodePages.length; H < B; H++)this._nodePages[H] = null; const D = [], E = []; C = C.nodes.map((H, J) => {
              const M = D.length, F = H.children ?
                H.children.length : 0; E.push(-1); for (var K = 0; K < F; K++)D.push(H.children[K]); const P = `${H.index}`; K = h.clone(H.obb); const L = n.fromArray([K.center[0], K.center[1], K.center[2], y.length(K.halfSize)]), N = H.mesh && H.mesh.attribute, G = H.mesh && H.mesh.geometry, I = H.mesh && H.mesh.material; H = new p.Node(P, B * this.nodesPerPage + J, L, F, 0, {
                  hasSharedResource: !1, hasFeatureData: !!G, attributes: N && null != N.resource ? `${N.resource}` : null, geometry: G && null != G.resource ? `${G.resource}` : null, texture: I && null != I.resource ? `${I.resource}` : null,
                  geometryDefinition: G ? G.definition : -1, materialDefinition: I ? I.definition : -1
                }, this.lastUpdate, this.lodMetric, this.lodConversion(H.lodThreshold), G ? G.featureCount : null); H.serviceObb = K; H.visibilityObb = this._computeVisibilityObb(H); H.vertexCount = G ? G.vertexCount : 0; return new m(M, F, l.addWraparound(this._visibilityCacheVersion, -2), null, H)
            }); this._nodePages[B] = { nodes: C, children: D, parents: E }; this.nodeCount += C.length; this.updateParentsAndLevel()
          }; z.updateParentsAndLevel = function () {
            const B = [], C = (D, E, H) => {
              const J =
                this.getPage(D); if (c.isSome(J)) { const M = f(D, this.nodesPerPage); J.parents[M] = E; E = J.nodes[M].node; c.isSome(E) && (E.level = H, B.push(D)) }
            }; for (C(this.rootIndex, -1, 0); B.length;) { const D = B.pop(), E = this.getNode(D); if (c.isSome(E)) for (let H = 0; H < E.childCount; H++) { const J = this.getChildIndex(E, H); C(J, D, E.level + 1); this._maxLevel = Math.max(this._maxLevel, E.level + 1) } }
          }; z.getPage = function (B) { return this._nodePages[d(B, this.nodesPerPage)] }; z.getNodeInternal = function (B) {
            const C = this.getPage(B); return c.isNone(C) ? null :
              C.nodes[f(B, this.nodesPerPage)]
          }; z.addNode = function (B, C) {
          null != B.children && this.populateChildren(C, B.children); var D = this.getParent(C); D = c.isSome(D) ? D.level + 1 : 0; this._maxLevel = Math.max(this._maxLevel, B.children ? D + 1 : D); const { lodMetric: E, maxError: H } = t(B.lodSelection), J = c.unwrap(this.getNodeInternal(C)); J.node = new p.Node(B.id, C, n.fromArray(B.mbs), J.childCount, D, B.resources, B.version, E, H, B.numFeatures); B.obb && (J.node.serviceObb = h.clone(B.obb)); J.node.visibilityObb = this._computeVisibilityObb(J.node);
            c.isSome(J.ref) && (null == J.ref.mbs && (J.ref.mbs = B.mbs), J.node.renderMbs = J.ref.renderMbs, J.node.serviceObbInRenderSR = J.ref.serviceObbInRenderSR, J.ref.visibilityObb = J.node.visibilityObb); return J.node
          }; z.makeRefNode = function (B, C) { const D = this._nodePages[0], E = D.nodes.length; D.nodes.push(new m(0, 0, l.addWraparound(this._visibilityCacheVersion, -2), B, null)); this.nodeCount++; D.parents.push(C); B.renderMbs[3] = -1; c.isSome(B.serviceObbInRenderSR) && (B.serviceObbInRenderSR.halfSize[0] = -1); return E }; z.populateChildren =
            function (B, C) { var D = c.unwrap(this.getNodeInternal(B)); const E = c.unwrap(this.getPage(B)); D.childOffset = E.children.length; D.childCount = C.length; for (D = 0; D < C.length; D++) { const H = this.makeRefNode(C[D], B); E.children.push(H) } }; z.getNode = function (B) { B = this.getNodeInternal(B); return c.isSome(B) ? B.node : null }; z.getIndexById = function (B) { let C; this.forAllNodes((D, E) => { c.isSome(D.node) && D.node.id === B ? C = E : c.isSome(D.ref) && D.ref.id === B && (C = E) }); return C }; z.getNodeById = function (B) {
              B = this.getIndexById(B); return 0 <=
                B ? this.getNode(B) : null
            }; z.getChildIndex = function (B, C) { const D = this.getPage(B.index); if (c.isNone(D)) return -1; B = D.nodes[f(B.index, this.nodesPerPage)]; return D.children[B.childOffset + C] }; z.getParentIndex = function (B) { const C = this.getPage(B); return c.isSome(C) ? C.parents[f(B, this.nodesPerPage)] : -1 }; z.getParent = function (B) { B = this.getParentIndex(B); return 0 <= B ? this.getNode(B) : null }; z.isLeaf = function (B) { B = this.getNodeInternal(B); return c.isSome(B) && 0 === B.childCount }; z.invalidateVisibilityCache = function () {
            this._visibilityCacheVersion =
              l.addWraparound(this._visibilityCacheVersion, 2)
            }; z.invalidateNodeVisibilityCache = function (B) { B = this.getNodeInternal(B); c.isSome(B) && this.invalidateNodeVisibilityCacheInternal(B) }; z.invalidateNodeVisibilityCacheInternal = function (B) { B.visibilityCache = l.addWraparound(this._visibilityCacheVersion, -2) }; z.invalidateBoundingVolumeCache = function (B) { B = this.getNodeInternal(B); c.isSome(B) && (b(B), this.invalidateNodeVisibilityCacheInternal(B)) }; z.invalidateGeometryVisibility = function (B) {
              B = this.getNodeInternal(B);
              c.isSome(B) && c.isSome(B.node) && (B.node.geometryObb = null, B.node.renderMbs[3] = -1, c.isSome(B.node.serviceObbInRenderSR) && (B.node.serviceObbInRenderSR.halfSize[0] = -1))
            }; z.invalidateVisibilityObbs = function () { c.isNone(this.rootNode) || this.traverse(this.rootNode, B => { B.visibilityObb = this._computeVisibilityObb(B); B.geometryObb = null; return !0 }) }; z.isNodeVisible = function (B) {
              B = this.getNodeInternal(B); if (c.isNone(B) || c.isSome(B.ref) && !B.ref.mbs) return !0; if ((B.visibilityCache & -2) !== this._visibilityCacheVersion) {
                var C =
                  B.node; const E = c.isSome(C) && (c.isNone(B.ref) || c.isSome(C.visibilityObb)) ? C : c.isSome(B.ref) ? B.ref : null; if (this._layerHasFilter && this._computeNodeFiltering && (c.isSome(C) || c.isSome(B.ref)) && 2 === B.filterImpact) { var D = c.isSome(C) ? C.mbs : c.isSome(B.ref) ? B.ref.mbs : null; B.filterImpact = null != D ? this._computeNodeFiltering(D) : 0 } D = c.isSome(C) && 1 === B.filterImpact; C = !(c.isSome(C) && 2 === C.imModificationImpact) && (!E || this.viewportQueries.isNodeVisible(E)) && !D; B.visibilityCache = this._visibilityCacheVersion + (C ? 1 : 0); return C
              } return 1 ===
                (B.visibilityCache & 1)
            }; z.isGeometryVisible = function (B) { if (!this.isNodeVisible(B)) return !1; B = this.getNodeInternal(B); return c.isSome(B) && c.isSome(B.node) && c.isSome(B.node.geometryObb) && (!this.layerHasModifications || 4 !== B.node.imModificationImpact) ? this.viewportQueries.isGeometryVisible(B.node) : !0 }; z._traverseCoverage = function (B, C, D, E, H) {
              B = this.getPage(B); if (!c.isNone(B) && 0 !== C.childCount) {
                var J = C.childOffset + C.childCount, M = []; for (C = C.childOffset; C < J; ++C) {
                  const F = B.children[C], K = this.getNodeInternal(F);
                  c.isSome(K) && c.isSome(K.node) && this.isGeometryVisible(F) && M.push(K)
                } E /= M.length; for (const F of M) B = c.unwrap(F.node).index, this._isLoaded(B) || this._isReloading(B) ? (H.delta = Math.max(H.delta, D), H.coverage += E) : this._traverseCoverage(B, F, D + 1, E, H)
              }
            }; z.useNodeAsHole = function (B) {
              if ("off" === this.holeFilling) return !1; const C = this.getNodeInternal(B); if (c.isNone(C)) return !1; if ("always" === this.holeFilling) return !0; if ((C.useAsHole & -2) === this._version) return 1 === (C.useAsHole & 1); const D = { delta: 0, coverage: 0 }; this._traverseCoverage(B,
                C, 0, 1, D); B = .5 >= D.delta * D.coverage; C.useAsHole = this._version + (B ? 1 : 0); return B
            }; z.destroy = function () { this._updates.add.prune(); this._updates.update.prune() }; z.requestUpdate = function () { this._dirty = !0; this._indexMissing = 1; this._version = l.addWraparound(this._version, 2) }; z.imModificationsChanged = function (B) {
            this.layerHasModifications = B; this.forAllNodes(({ node: C }) => { c.isSome(C) && (C.imModificationImpact = 4, C.visibilityObb = this._computeVisibilityObb(C), C.hasModifications && this.invalidateGeometryVisibility(C.index)) });
              this.invalidateVisibilityCache()
            }; z.layerFilterChanged = function (B) { this._layerHasFilter = B; this.forAllNodes(C => { c.isSome(C) && (C.filterImpact = 2, C = C.node, c.isSome(C) && this.invalidateNodeVisibilityCache(C.index)) }); this.invalidateVisibilityCache() }; z.update = function (B, C, D) {
              if (this._dirty) {
              this._maxProcessingPrio = this._maxUnloadedPrio = Number.NEGATIVE_INFINITY; this._missing.clear(); this._prefetch.clear(); this._updates.reset(B); g.clear(); var E = !0, H = new r, J = new r, M = this._imModificationUncategorized; M.clear();
                var F = new Set; this.traverseVisible((P, L, N) => {
                  if (c.isNone(L)) L = this.entryPriority(P), Infinity === L && (L = this.entryPriority(N)), P = d(P, this.nodesPerPage), g.set(P, Math.max(L, g.get(P) || 0)), this._loading.has(P) || this._failedPages.has(P) || this._missing.push(P), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, L); else {
                    var G = L.node; this._updateNodeFeatureEstimate(G, J); if (c.isNone(G)) L = this.entryPriority(P), this._loading.has(P) || this._failedNodes.has(P) || (this._missing.push(P), g.set(P, L)), this._maxProcessingPrio =
                      Math.max(this._maxProcessingPrio, L); else {
                        N = c.unwrap(this.getPage(P)); if (0 === this._missing.length && 0 === this.nodesPerPage) for (let I = 0; I < L.childCount; I++) { const O = N.children[L.childOffset + I], R = this.getNodeInternal(O); !c.isSome(R) || R.node || this._loading.has(O) || this._failedNodes.has(O) || (g.set(O, this.entryPriority(O)), this._prefetch.push(O)) } !G.failed && G.resources.hasFeatureData && (F.add(G.id), this._isLoaded(P) ? (H.known += G.memory, ++H.knownNodes, this._isSelected(G) ? 0 < L.childCount && (E = !1) : (H.unremoved +=
                          G.memory, E = !1), this._needsUpdate(G) && (L = this.entryPriority(P), g.set(P, L), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, L), this._updates.update.push(P))) : (G.memory && (H.known += G.memory, ++H.knownNodes), this._isSelected(G) ? (0 < L.childCount && (E = !1), G.memory ? (H.missing += G.memory, H.known += G.memory, ++H.knownNodes) : ++H.missingNodes, 0 <= B.indexOf(G.index) ? (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, this.entryPriority(P)), this._updates.cancel = this._updates.cancel.filter(I => I !== G.index)) :
                            !C.done && this._enable(G) ? C.madeProgress() : (L = this.entryPriority(P), g.set(P, L), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, L), this._updates.add.push(P), this.layerHasModifications && D && c.isSome(G) && 4 === G.imModificationImpact && M.push(P))) : this._isReloading(P) && this._updates.remove.push(P)))
                    }
                  }
                }); var K = this._updates.add; 0 < K.length && this.layerHasModifications && (0 < M.length && D(M), K.filterInPlace(P => {
                  var L = this.getNodeInternal(P); (L = c.isNone(L) || c.isNone(L.node) || 2 !== L.node.imModificationImpact) ||
                    this.invalidateNodeVisibilityCache(P); return L
                })); this._unloadedMemoryEstimate = H.missing - H.unremoved; 3 < H.knownNodes && 0 < H.missingNodes && (this._unloadedMemoryEstimate += H.known / H.knownNodes * H.missingNodes); this._unloadedMemoryEstimate = .8 * Math.max(0, this._unloadedMemoryEstimate); this._featureEstimate.estimate = this._computeFeatureEstimate(J); this._featureEstimate.leavesReached = E; this._missing.sort((P, L) => P - L); this._missing.filterInPlace((P, L) => 1 > L || this._missing.data[L - 1] !== P); this._missing.sort((P, L) =>
                  g.get(P) - g.get(L)); 0 < this._missing.length && (this._maxUnloadedPrio = g.get(this._missing.back()), this._prefetch.clear()); this._updates.add.filterInPlace(P => g.get(P) >= this._maxUnloadedPrio).sort((P, L) => g.get(P) - g.get(L)); this._updates.update.sort((P, L) => g.get(P) - g.get(L)); this._indexMissing = this._loading.size + this._missing.length; this._dirty = 0 < this._indexMissing; g.clear()
              }
            }; z.checkFeatureTarget = function (B, C) {
              const D = this.viewportQueries.updateScreenSpaceErrorBias(C); let E = C, H = C, J = D, M = 10; for (; M--;) {
                const F =
                  new r; this._updateFeatureEstimate(E, F); if (this._computeFeatureEstimate(F) <= B) { if (E >= C || 0 < F.missingNodes || 0 === M) break; J = E; E = .5 * (E + H) } else H = E, E = .5 * (E + J)
              } this._version = l.addWraparound(this._version, 2); this.viewportQueries.updateScreenSpaceErrorBias(D); return Math.min(C, E)
            }; z._updateFeatureEstimate = function (B, C) { this._version = l.addWraparound(this._version, 2); this.viewportQueries.updateScreenSpaceErrorBias(B); this.traverseVisible((D, E) => this._updateNodeFeatureEstimate(c.isSome(E) && E.node, C)) }; z._updateNodeFeatureEstimate =
              function (B, C) { c.isNone(B) || B.failed || c.isNone(B.numFeatures) || (this._isLoaded(B.index) ? (C.known += B.numFeatures, ++C.knownNodes, this._isSelected(B) || (C.unremoved += B.numFeatures)) : this._isSelected(B) && (c.isSome(B.numFeatures) ? (C.missing += B.numFeatures, C.known += B.numFeatures, ++C.knownNodes) : ++C.missingNodes)) }; z._computeFeatureEstimate = function (B) { let C = B.known - B.unremoved; 3 < B.knownNodes && 0 < B.missingNodes && (C += B.known / B.knownNodes * B.missingNodes); return Math.max(0, C) }; z.load = function () { return this._load(this._missing) };
          z.prefetch = function () { this._prefetch.sort((B, C) => g.get(B) - g.get(C)); return this._load(this._prefetch) }; z._load = function (B) { if (0 === B.length || !this._canRequest()) return !1; for (; 0 < B.length && this._canRequest();)0 === this.nodesPerPage ? this._loadNode(B.pop()) : this.loadPage(B.pop()); return !0 }; z.isLoading = function () { return 0 < this._indexMissing }; z.getIndexLoading = function () { return this._loading.size }; z.getIndexMissing = function () { return this._indexMissing }; z.getUnloadedMemoryEstimate = function () { return this._unloadedMemoryEstimate };
          z.nodeTraversalState = function (B) {
            if (c.isNone(B)) return null; let C = this._nodeTraversalState.get(B.index); if (C && (C.version & -2) === this._version) return C; const D = this.viewportQueries.getLodLevel(B), E = this.viewportQueries.hasLOD(B); var H = !0; E ? (H = this.getParentIndex(B.index), H = 0 <= H ? (H = this._nodeTraversalState.get(H)) && D > H.lodLevel : 0 < D) : H = 0 === B.childCount; if (C) return C.lodLevel = D, C.isChosen = H, C.version = this._version + 1, C; C = new p.NodeTraversalState(E, H, D, this._version + 1); this._nodeTraversalState.set(B.index,
              C); return C
          }; z._loadNode = function (B) {
            this._loading.add(B); const C = c.unwrap(this.getNodeInternal(B)).ref; if (c.isNone(C)) this._failedNodes.add(B); else {
              var D = C.id, E = this.urlPrefix + D, H = () => { this._loading.delete(B); 0 === this._missing.length && 0 === this._loading.size && this.requestUpdate() }; this.streamDataController.request(E, "json").then(J => { H(); J = this._validateNode(D, J); null != J && (J.obb && this.invalidateNodeVisibilityCache(B), J = this.addNode(J, B), this.nodeTraversalState(J)) }, J => {
                H(); u.isAbortError(J) || (this.logger.error("#loadNode()",
                  this.logLayer, "Error loading node: " + E), this._failedNodes.add(B))
              })
            }
          }; z._validateNode = function (B, C) {
            if (null == C || "object" !== typeof C || C.id !== B) return this.logger.error("#validateNode()", this.logLayer, `Invalid node. Wrong type or wrong id "${B}"`), null; if (!Array.isArray(C.mbs)) return this.logger.error("#validateNode()", this.logLayer, `Invalid bounding volume on node ${B}.`), null; C.sharedResource && "./shared" !== C.sharedResource.href && "./shared/" !== C.sharedResource.href && this.logger.warn("#validateNode()",
              this.logLayer, `Invalid shared resource href on node "${B}"`); null == C.geometryData || Array.isArray(C.geometryData) && 1 === C.geometryData.length && "./geometries/0" === C.geometryData[0].href || this.logger.warn("#validateNode()", this.logLayer, `Invalid geometry data on node "${B}"`); null == C.attributeData || Array.isArray(C.attributeData) && !C.attributeData.some((J, M) => J.href !== `./attributes/f_${M}/0`) || this.logger.warn("#validateNode()", this.logLayer, `Invalid attribute data on node "${B}"`); C.featureData && 1 < C.featureData.length &&
                this.logger.warn("#validateNode()", this.logLayer, `Node ${B} has ${C.featureData.length} bundles. Only the first bundle will be loaded.`); const D = C.hasOwnProperty("obb") && !this.ignoreServiceObb ? C.obb : null, E = C.featureData && 1 === C.featureData.length && C.featureData[0].featureRange ? C.featureData[0].featureRange[1] - C.featureData[0].featureRange[0] + 1 : null; var H = J => {
                  if (null == J) return null; var M = F => this.logger.error("#validateNode()", this.logLayer, `Invalid node reference on node ${B}: ${F}`); if ("number" ===
                    typeof J.id) M(`id ${J.id} is a number instead of a string.`); else if ("string" !== typeof J.id || !Array.isArray(J.mbs)) return M("Missing or invalid id."), null; if (!Array.isArray(J.mbs)) return M(`Invalid bounding volume on reference ${J.id}.`), null; J.href && J.href !== "../" + J.id && this.logger.error("#validateNode()", this.logLayer, `Invalid node href on node "${B}"`); M = J.hasOwnProperty("obb") && !this.ignoreServiceObb ? J.obb : null; J = new p.NodeBase(`${J.id}`, J.mbs); J.serviceObb = M; J.visibilityObb = this._computeVisibilityObb(J);
                  return J
                }; H = Array.isArray(C.children) ? C.children.map(H).filter(J => null != J) : null; return { id: B, mbs: C.mbs, obb: D, children: H, resources: { hasFeatureData: C.featureData && 0 < C.featureData.length, hasSharedResource: null != C.sharedResource, attributes: C.attributeData ? B : null, texture: C.textureData && 0 < C.textureData.length ? B : null, geometry: null != C.geometryData ? B : null }, version: "string" === typeof C.version ? C.version : null, lodSelection: Array.isArray(C.lodSelection) ? C.lodSelection : null, numFeatures: E }
          }; z.resetFailedNodes = function () {
            this._failedNodes.clear();
            this._failedPages.clear(); this.forAllNodes(B => { c.isSome(B.node) && (B.node.failed = !1) })
          }; z.entryPriority = function (B) {
            var C = this.getNodeInternal(B), D = this.getParentIndex(B); if (c.isNone(C) || 0 > D && null == C.node) return 0 > D ? Infinity : this.entryPriority(D); let E = 0; C.node && 0 <= D && (D = this._nodeTraversalState.get(D), null != D && (E = D.lodLevel)); for (D = this.progressiveLoadPenalty; 0 <= B; B = this.getParentIndex(B))if (this._isLoaded(B)) { D = 0; break } C = c.isSome(C.ref) ? this.viewportQueries.distToPOI(C.ref) : c.isSome(C.node) ? this.viewportQueries.distToPOI(C.node) :
              0; return -C - E * (C + this.progressiveLoadPenalty) + D
          }; z.traverseVisible = function (B) { const C = this.getNodeInternal(this.rootIndex); c.isNone(C) ? B(this.rootIndex, null, null) : this._traverseVisible(this.rootIndex, -1, C, B) }; z._traverseVisible = function (B, C, D, E) {
            if (D.node && 0 === D.childCount) this.isGeometryVisible(B) && E(B, D, C); else if (this.isNodeVisible(B) && (E(B, D, C), null != D.node && (C = this.nodeTraversalState(D.node), !C.nodeHasLOD || C.lodLevel !== this._maxLodLevel))) {
              C = c.unwrap(this.getPage(B)); for (let H = 0; H < D.childCount; H++) {
                const J =
                  C.children[D.childOffset + H], M = this.getNodeInternal(J); c.isSome(M) ? this._traverseVisible(J, B, M, E) : E(J, null, B)
              }
            }
          }; z.traverse = function (B, C) { C(B) && this.traverseChildren(B, C) }; z.traverseChildren = function (B, C) { B = B.index; const D = this.getNodeInternal(B); c.isSome(D) && this._traverseChildren(B, D, C) }; z._traverseChildren = function (B, C, D) {
            B = this.getPage(B); if (!c.isNone(B)) {
              var E = C.childOffset + C.childCount; for (C = C.childOffset; C < E; ++C) {
                const H = B.children[C], J = this.getNodeInternal(H); c.isSome(J) && c.isSome(J.node) &&
                  D(J.node) && this._traverseChildren(H, J, D)
              }
            }
          }; z.updateStats = function (B) { 0 < this._updates.add.length && (B.nodes += " + " + this._updates.add.length); if (this._indexMissing || 0 < this._prefetch.length) B.index += " + " + this._indexMissing || this._prefetch.length; B.prio = this._maxProcessingPrio; if (this._featureEstimate.estimate) { const C = this._featureEstimate.estimate - B.features; 0 < C ? B.features += " + " + C : 0 > C && (B.features += " - " + -C) } }; z.getPriority = function () { return Math.max(this._maxProcessingPrio, this._maxUnloadedPrio) };
          z.updateElevationInfo = function (B) { this.forAllNodes(b); this.viewportQueries.updateElevationInfo(B) }; z.forAllNodes = function (B) { for (let C = 0; C < this._nodePages.length; C++) { const D = this._nodePages[C]; if (D) { const E = C * this.nodesPerPage; for (let H = 0; H < D.nodes.length; H++)B(D.nodes[H], E + H) } } }; w._createClass(A, [{ key: "rootNode", get: function () { return this.getNode(this.rootIndex) } }, { key: "size", get: function () { return this.nodeCount } }, { key: "maxLevel", get: function () { return this._maxLevel } }, { key: "dirty", get: function () { return this._dirty } },
          { key: "updates", get: function () { return this._updates } }, { key: "featureEstimate", get: function () { return this._featureEstimate } }, { key: "test", get: function () { return { addNode: (B, C) => this.addNode(B, C) } } }]); return A
        }(); const g = new Map; let x = function () { function A(z) { this.missing = z; this.update = new q({ deallocator: null }); this.add = new q({ deallocator: null }); this.remove = new q({ deallocator: null }); this.cancel = [] } A.prototype.reset = function (z) { this.add.clear(); this.update.clear(); this.cancel = z }; return A }(); const k = [["maxScreenThreshold",
          1], ["screenSpaceRelative", 2], ["removedFeatureDiameter", 3], ["distanceRangeFromDefaultCamera", 4]]; let r = function () { this.unremoved = this.missingNodes = this.missing = this.knownNodes = this.known = 0 }; a.I3SIndex = e; a.selectErrorMetric = t; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/I3SNode": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../chunks/vec4f64"], function (a, w, c) {
        let q = function (y, n) {
        this.id = y; this.mbs = n; this.renderMbs = c.fromArray([0,
          0, 0, -1]); this.imModificationImpact = 4
        }, u = function (y) { function n(p, l, h, b, d, f, t, v, m, e) { p = y.call(this, p, h) || this; p.index = l; p.childCount = b; p.level = d; p.resources = f; p.version = t; p.lodMetric = v; p.maxError = m; p.numFeatures = e; p.failed = !1; p.hasModifications = !1; p.cacheState = 0; p.vertexCount = 0; p.memory = 0; return p } w._inheritsLoose(n, y); return n }(q); a.Node = u; a.NodeBase = q; a.NodeTraversalState = function (y, n, p, l) { this.nodeHasLOD = y; this.isChosen = n; this.lodLevel = p; this.version = l }; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    },
    "esri/views/3d/layers/i3s/I3SLodHandling": function () {
      define(["../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe", "../../../../core/PooledArray"], function (a, w, c) {
        let q = function () {
          function y(p) { this.layerView = p; this._lodGlobalDirty = !1 } var n = y.prototype; n.startNodeLoading = function (p, l, h, b) { this._maxLodLevel = b.maxLodLevel; this._index = h; this._isNodeInScaleBounds = p; this._removeNodes = l }; n.shouldLoadNode = function (p) {
            if (w.isNone(p)) return !1; const l = this._index.nodeTraversalState(p); return this.isChosenMaxLOD(l) ?
              !0 : l.isChosen ? this._childrenRequireLoading(p) : !1
          }; n.setLodGlobalDirty = function () { this._lodGlobalDirty = !0 }; n.lodGlobalHandling = function (p) { if (!this.requiresLODGlobalHandling) return !1; this._lodGlobalDirty = !1; var l = Math.max(0, Math.floor(10 * (this.layerView.view.resourceController.memoryController.usedMemory - 1))); u.clear(); this._lodGlobalHandling(this._index.rootNode, l, !1); l = u.length; this._removeNodes(u, p); p = u.length < l; 0 !== u.length && (this._lodGlobalDirty = !0); u.clear(); return p }; n._lodGlobalHandling = function (p,
            l, h) {
              if (w.isNone(p)) return !1; const b = p.index, d = this._index, f = this.layerView; var t = d.nodeTraversalState(p); const v = this.isChosenMaxLOD(t); t = f.isNodeLoaded(b); const m = f.nodeCrossfadingEnabled; if (m && t && v) { var e = !h && this.hasNoVisibleChildren(p); f.fadeNode(b, 0, !e) } e = t && (!f.isNodeFullyFadedIn || f.isNodeFullyFadedIn(b)); if (t && (f.updateNodeState(b, v ? 1 : 0), v)) return e && this._removeChildrenRecursive(p), e; var g = 0 < p.childCount; let x = g; if (g) for (g = 0; g < p.childCount; g++) {
                const k = d.getChildIndex(p, g), r = d.getNode(k);
                w.isSome(r) ? d.isGeometryVisible(k) && !this._lodGlobalHandling(r, l, h || e) && this._isNodeInScaleBounds(r) && (x = !1) : d.isNodeVisible(k) && (x = !1)
              } (l = t && !v && (x || u.length < l)) && u.push(b); !m || l || !t || h || x || f.fadeNode(b, 0, !1); p = !p.resources.hasFeatureData; return x || e && !l || p
          }; n._removeChildrenRecursive = function (p) { this._index.traverseChildren(p, l => { (this.layerView.isNodeLoaded(l.index) || this.layerView.isNodeReloading(l.index)) && u.push(l.index); return !0 }) }; n.hasNoVisibleChildren = function (p) {
            let l = !0; this._index.traverseChildren(p,
              h => l && this._index.isNodeVisible(h.index) ? this.layerView.isNodeLoaded(h.index) ? l = !1 : !0 : !1); return l
          }; n._childrenRequireLoading = function (p) { let l = !1, h = !0; this._index.traverseChildren(p, b => { if (!h || !this._index.isNodeVisible(b.index)) return !1; const d = this._index.nodeTraversalState(b); this.isChosenMaxLOD(d) && this._index.isGeometryVisible(b.index) && (l = !0); return this.layerView.isNodeLoaded(b.index) ? h = !1 : !0 }); return h && l }; n.isChosenMaxLOD = function (p) { return p.isChosen && (!p.nodeHasLOD || p.lodLevel === this._maxLodLevel) };
          a._createClass(y, [{ key: "requiresLODGlobalHandling", get: function () { return null != this._index && !0 === this._lodGlobalDirty } }]); return y
        }(); const u = new c({ deallocator: null }); return q
      })
    }, "esri/views/3d/layers/i3s/I3SNodeLoader": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/asyncUtils ../../../../core/has ../../../../core/lang ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/urlUtils ./I3SBinaryReader ./I3SMaterialUtil".split(" "), function (a, w, c, q, u,
        y, n, p, l) {
          return function () {
            function h(d, f, t, v, m, e) { this.streamDataController = f; this.logger = t; this.defaultGeometrySchema = v; this.requiredAttributes = m; this.options = e; this.logLayer = d; this.layerUrl = d.parsedUrl.path; this.geometryDefinitions = d.geometryDefinitions; if (d.materialDefinitions) { const g = d.textureSetDefinitions; this.materialAndTextures = d.materialDefinitions.map(x => l.getMaterialAndTextures(g, x)) } } var b = h.prototype; b.load = function (d, f, t) { return this.streamDataController.request(d, f, t) }; b.loadAttribute =
              function (d, f, t) { return this.load(`${this.layerUrl}/nodes/${d.resources.attributes}/attributes/${f.key}/0`, "binary", t).then(v => p.readBinaryAttribute(f, v)) }; b.loadAttributes = function (d, f, t) {
                return y.eachAlways(f.map(v => this.loadAttribute(d, v.attributeStorageInfo, t))).then(v => {
                  const m = {}; for (let e = 0; e < f.length; ++e)if (v[e].value) m[f[e].name] = v[e].value; else {
                    if (y.isAbortError(v[e].error)) throw v[e].error; this.logger.error("#loadAttributes", this.logLayer, `Failed to load attributeData for '${f[e].name}' on node '${d.id}'`,
                      v[e].error)
                  } return m
                })
              }; b.loadNodeData = function () {
                var d = a._asyncToGenerator(function* (f, t) {
                  var v = null != this.requiredAttributes && f.resources.attributes ? w.result(this.loadAttributes(f, this.requiredAttributes, t)) : null; var m = this.geometryDefinitions; var e = { bufferDefinition: null, bufferIndex: 0 }; if (!(null == m || 0 > f.resources.geometryDefinition) && (m = 0 <= f.resources.geometryDefinition ? m[f.resources.geometryDefinition].geometryBuffers : null, null != m)) for (var g = 0; g < m.length; g++) {
                    var x = m[g]; if (null != x.compressedAttributes) {
                      if ("draco" ===
                        x.compressedAttributes.encoding && !c("disable-feature:i3s-draco")) { e.bufferIndex = g; e.bufferDefinition = x; break }
                    } else e.bufferIndex = g, e.bufferDefinition = m[g]
                  } const { bufferDefinition: k, bufferIndex: r } = e; g = (x = !!f.resources.geometry) ? w.result(this.loadGeometry(f.resources.geometry, r, t)) : null; m = f.resources.hasSharedResource ? yield this.loadShared(f, t) : null; var A = (e = this.materialAndTextures && 0 <= f.resources.materialDefinition ? this.materialAndTextures[f.resources.materialDefinition] : null != m ? l.getMaterialAndTexturesFromShared(m) :
                    null) && e.material; e = e && e.textures; const z = `${f.id}`, B = !x && this.options.loadFeatureData; x = B ? yield this.loadFeatureData(z, t) : null; if (B) a: { for (D of x.featureData) if (A = D.geometries, null != A) for (var C of A) { var D = { featureIds: [D.id], featureDataPosition: D.position, geometries: [C] }; break a } D = null } else D = { featureIds: [], geometries: [{ type: "ArrayBufferView", params: { material: A } }], featureDataPosition: [0, 0, 0] }; if (C = u.isNone(D)) {
                      C = []; for (var E of x.featureData) null != E.position && C.push({
                        featureIds: [E.id], featureDataPosition: E.position,
                        geometries: null
                      })
                    } E = C; C = null != e && 0 < e.length ? w.result(this.loadTextures(f, e, t)) : null; t = f = null; g && (f = w.assertResult(yield g), (t = this.defaultGeometrySchema) && m && m.materialDefinitions && (g = Object.keys(m.materialDefinitions)[0], !m.materialDefinitions[g].params.vertexRegions && t.vertexAttributes.region && (t = q.clone(t), delete t.vertexAttributes.region)), t = p.createGeometryDescriptor(k, t)); m = C ? w.assertResult(yield C) : null; v = (v = v ? w.assertResult(yield v) : {}) ? { attributeData: v, loadedAttributes: this.requiredAttributes } :
                      null; return u.isSome(D) ? { geometryData: D, attributeDataInfo: v, geometryBuffer: f, geometryDescriptor: t, requiredTextures: e, textureData: m } : u.isSome(E) ? { pointData: E, attributeDataInfo: v, geometryBuffer: f, geometryDescriptor: t, requiredTextures: e, textureData: m } : Promise.reject()
                }); return function (f, t) { return d.apply(this, arguments) }
              }(); h.addAbsoluteHrefTexture = function (d, f) {
                d = d.textureDefinitions; if (null != d) for (const t of Object.keys(d)) for (const v of d[t].images) Array.isArray(v.href) ? v.hrefConcat = v.href.map(m =>
                  n.makeAbsolute(m, f)) : v.hrefConcat = n.makeAbsolute(v.href, f)
              }; h.fixTextureEncodings = function (d) { d = d.textureDefinitions; if (null != d) for (const t in d) { const v = d[t]; if (Array.isArray(v.encoding)) for (var f = 0; f < v.encoding.length; f++) { const m = v.encoding[f]; "data:" === m.substring(0, 5) && (v.encoding[f] = m.substring(5)) } else f = v.encoding, "data:" === f.substring(0, 5) && (v.encoding = f.substring(5)) } }; b.loadShared = function (d, f) {
                const t = `${this.layerUrl}/nodes/${d.resources.geometry}/shared`; return this.load(t, "json", f).then(v => { h.fixTextureEncodings(v); h.addAbsoluteHrefTexture(v, t); return v })
              }; b.loadTexture = function (d, f, t, v, m, e) { let g = !1; return 4 === m || 1 === m || 2 === m ? this.load(d, "binary", e).then(x => ({ id: f, usage: t, data: x, encoding: m, downsampled: g })) : this.load(d, "image", e).then(x => { var k = x; if (v && 4096 <= x.width * x.height) { k = Math.ceil(x.width / 2); const r = Math.ceil(x.height / 2), A = document.createElement("canvas"); A.width = k; A.height = r; A.getContext("2d").drawImage(x, 0, 0, k, r); k = A; g = !0 } return { id: f, usage: t, data: k, encoding: m, downsampled: g } }) };
            b.loadTextures = function (d, f, t) {
              const v = this.options.uncompressedTextureDownsamplingEnabled, m = this.options.textureUsageMask; return Promise.all(f.map(e => {
                if (0 === (e.usage & m)) return null; const g = l.selectEncoding(e.encodings, this.options.textureEncodings); return null == g ? (this.logger.error("#loadTextures", this.logLayer, `No known encoding for texture found on node ${d.id}`), Promise.reject()) : this.loadTexture(`${this.layerUrl}/nodes/${d.resources.texture || d.id}/textures/${g.name}`, e.id, e.usage, v, g.encoding,
                  t)
              }))
            }; b.loadFeatureData = function (d, f) { return this.load(`${this.layerUrl}/nodes/${d}/features/0`, "json", f) }; b.loadGeometry = function (d, f, t) { return this.load(`${this.layerUrl}/nodes/${d}/geometries/${f}`, "binary", t) }; return h
          }()
      })
    }, "esri/views/3d/layers/i3s/I3SMaterialUtil": function () {
      define("exports ../../../../core/has ../../../../core/mathUtils ../../../../core/maybe ../../webgl-engine/core/material/RenderTexture ../../webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../../webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl ../../webgl-engine/core/shaderLibrary/util/EllipsoidMode ../../webgl-engine/lib/Texture".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(e) { return e.sort((g, x) => g.encoding - x.encoding) } function b(e, g, x) { if (q.isNone(e) || 0 === x) return null; for (let k = 0; k < e.length; k++) { const r = e[k]; if (q.isSome(r) && 0 !== (r.usage & x)) return e = g[k], q.isSome(e) ? e.id : null } return null } function d(e) { switch (e) { case 1: return l.Texture.KTX2_ENCODING; case 2: return l.Texture.BASIS_ENCODING; case 4: return l.Texture.DDS_ENCODING; case 8: return "image/png"; case 16: return "image/jpeg"; case 32: return "image/ktx"; default: return "" } } const f =
            { ktx2: 1, basis: 2, dds: 4, png: 8, jpg: 16, "ktx-etc2": 32 }, t = { [l.Texture.KTX2_ENCODING]: 2, [l.Texture.BASIS_ENCODING]: 2, [l.Texture.DDS_ENCODING]: 4, "image/png": 8, "image/jpg": 16, "image/jpeg": 16, "image/ktx": 32 }, v = { s: 33071, t: 33071 }, m = { s: 10497, t: 10497 }; a.configureMaterial = function (e, g, x, k, r, A) {
              const z = A.rendererTextureUsage; var B = g.metallicRoughness.baseColorFactor, C = c.clamp(g.metallicRoughness.baseColorFactor[3], 0, 1); e.baseColor = [B[0], B[1], B[2], C]; e.hasParametersFromSource = !!g.hasParametersFromSource; e.usePBR =
                A.usePBR; e.mrrFactors = [g.metallicRoughness.metallicFactor, g.metallicRoughness.roughnessFactor, g.hasParametersFromSource ? .2 : .5]; e.emissiveFactor = g.emissiveFactor; e.isIntegratedMesh = A.isIntegratedMesh; e.alphaCutoff = "mask" === g.alphaMode ? g.alphaCutoff : n.defaultMaskAlphaCutoff; e.alphaDiscardMode = "opaque" === g.alphaMode ? 1 : "mask" === g.alphaMode ? 2 : 3; B = []; C = b(k, x, 33 & z); q.isSome(C) && (e.baseColorTexture = new u.RenderTexture(r, C), B.push(e.baseColorTexture.loadPromise)); C = b(k, x, 2 & z); q.isSome(C) && (e.metallicRoughnessTexture =
                  new u.RenderTexture(r, C), B.push(e.metallicRoughnessTexture.loadPromise)); C = b(k, x, 16 & z); q.isSome(C) && (e.emissionTexture = new u.RenderTexture(r, C), B.push(e.emissionTexture.loadPromise)); C = b(k, x, 8 & z); q.isSome(C) && (e.occlusionTexture = new u.RenderTexture(r, C), B.push(e.occlusionTexture.loadPromise)); x = b(k, x, 4 & z); q.isSome(x) && (e.normalTexture = new u.RenderTexture(r, x), B.push(e.normalTexture.loadPromise)); e.commonMaterialParameters.slicePlaneEnabled = A.slicePlaneEnabled; e.commonMaterialParameters.doubleSided =
                    g.doubleSided; e.commonMaterialParameters.cullFace = g.cullFace; e.ellipsoidMode = p.getEllipsoidMode(A.viewSpatialReference); return Promise.all(B)
            }; a.createTexture = function (e, g, x, k) {
              if (q.isNone(e) || null == e.data) return null; const r = e.data; var A = !(r instanceof HTMLImageElement) || c.isPowerOfTwo(r.width) && c.isPowerOfTwo(r.height), z = k.renderingContext.parameters.maxMaxAnisotropy; k = x && !k.capabilities.shaderTextureLOD ? 1 : z; A = A && !e.downsampled && 1 < k; x = x || !g.wrapTextures ? v : m; z = d(e.encoding); return new l.Texture(r,
                { mipmap: A, maxAnisotropy: k, encoding: z, wrap: x, components: e.usage & 1 ? "opaque" === g.alphaMode ? 3 : 4 : 3, noUnpackFlip: !0 })
            }; a.getMaterialAndTextures = function (e, g) {
              const x = new Map, k = (H, J) => { if (q.isNone(H)) return -1; if (x.has(H.id)) return H = x.get(H.id), H.usage |= J, H.id; const M = x.size; x.set(H.id, { id: M, usage: J }); return M }; var r = g.pbrMetallicRoughness; const A = r && r.baseColorFactor, z = g.emissiveFactor, B = null == g.normalTexture && null == g.emissiveTexture && null == g.occlusionTexture && (r ? null == r.metallicRoughnessTexture && 1 === r.roughnessFactor &&
                (1 === r.metallicFactor || 0 === r.metallicFactor) : !0), C = B ? y.PBRSchematicMRRValues[0] : r ? r.metallicFactor : 1, D = B ? y.PBRSchematicMRRValues[1] : r ? r.roughnessFactor : 1; r = { baseColorFactor: A ? [A[0], A[1], A[2], A[3]] : [1, 1, 1, 1], baseColorTextureId: k(r && r.baseColorTexture, "mask" === g.alphaMode ? 33 : 1), metallicRoughnessTextureId: k(r && r.metallicRoughnessTexture, 2), metallicFactor: C, roughnessFactor: D }; g = {
                  alphaMode: g.alphaMode, alphaCutoff: g.alphaCutoff, doubleSided: g.doubleSided, cullFace: "none" === g.cullFace ? 0 : "back" === g.cullFace ?
                    2 : "front" === g.cullFace ? 1 : void 0, normalTextureId: k(g.normalTexture, 4), emissiveTextureId: k(g.emissiveTexture, 16), occlusionTextureId: k(g.occlusionTexture, 8), emissiveFactor: z ? [z[0], z[1], z[2]] : [0, 0, 0], metallicRoughness: r, wrapTextures: !1, hasParametersFromSource: B
                }; const E = []; x.forEach(({ usage: H }, J) => { var M = q.isSome(e) && e[J] && e[J].formats; M = M ? h(M.map(({ name: F, format: K }) => ({ name: F, encoding: f[K] }))) : []; E.push({ id: J, usage: H, encodings: M }) }); return { material: g, textures: E }
            }; a.getMaterialAndTexturesFromShared = function (e) {
              var g =
                e && e.materialDefinitions ? Object.keys(e.materialDefinitions)[0] : null, x = e && e.textureDefinitions ? Object.keys(e.textureDefinitions)[0] : null; g = g && e.materialDefinitions[g]; x = x && e.textureDefinitions[x]; e = {
                  alphaMode: "opaque", alphaCutoff: n.defaultMaskAlphaCutoff, doubleSided: !0, cullFace: 0, normalTextureId: -1, emissiveTextureId: -1, occlusionTextureId: -1, emissiveFactor: [0, 0, 0], metallicRoughness: { baseColorFactor: [.8, .8, .8, 1], baseColorTextureId: -1, metallicRoughnessTextureId: -1, metallicFactor: 0, roughnessFactor: .6 },
                  wrapTextures: !1, hasParametersFromSource: !0
                }; if (null != g) {
                  g = g.params; g.diffuse && (e.metallicRoughness.baseColorFactor = [g.diffuse[0], g.diffuse[1], g.diffuse[2], 1]); null != g.doubleSided && (e.doubleSided = g.doubleSided, e.cullFace = g.doubleSided ? 0 : 2); if ("none" === g.cullFace || "front" === g.cullFace || "back" === g.cullFace) e.cullFace = "none" === g.cullFace ? 0 : "back" === g.cullFace ? 2 : 1; g.transparency && (e.metallicRoughness.baseColorFactor[3] = c.clamp(1 - g.transparency, 0, 1)); if (g.useVertexColorAlpha || 1 > e.metallicRoughness.baseColorFactor[3]) e.alphaMode =
                    "blend"
                } g = []; if (null != x) { !x.wrap || "repeat" !== x.wrap[0] && "repeat" !== x.wrap[1] || (e.wrapTextures = !0); let k = 1; "rgba" === x.channels && (e.alphaMode = "blend", k |= 32); const r = x.images[x.images.length - 1], A = z => z && z.split("/").pop(); x = Array.isArray(x.encoding) ? h(x.encoding.map((z, B) => ({ name: A(r.href[B]), encoding: t[z] || 0 }))) : [{ name: A(r.href), encoding: t[x.encoding] || 0 }]; g.push({ id: 0, usage: k, encodings: x }); e.metallicRoughness.baseColorTextureId = 0 } return { material: e, textures: g }
            }; a.getSupportedEncodings = function (e) {
              const g =
                !!e.compressedTextureS3TC; e = !!e.compressedTextureETC; const x = w("disable-feature:i3s-basis") ? 0 : 3; return 24 | (g ? x | 4 : 0) | (e ? x : 0)
            }; a.selectEncoding = function (e, g) { return e.find(x => 0 !== (x.encoding & g)) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/webgl-engine/core/material/RenderTexture": function () {
      define(["exports", "../../../../../core/maybe"], function (a, w) {
        let c = function () {
          function q(y, n) {
          this._textureRep = y; this._disposed = !1; y = this._textureRep.acquire(n); y.then(p => {
            this._disposed ?
            w.releaseMaybe(p) : this._textureRef = p
          }); this.loadPromise = y
          } var u = q.prototype; u.dispose = function () { this._textureRef = w.releaseMaybe(this._textureRef); this._disposed = !0 }; u.bind = function (y, n, p) { const l = w.isSome(this._textureRef) ? this._textureRef.glTexture : null; w.isSome(l) && (y.bindTexture(l, n), y.setUniform2f(p, l.descriptor.width, l.descriptor.height)) }; return q
        }(); a.RenderTexture = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode": function () {
      define(["exports",
        "../../../../../../geometry/support/spatialReferenceUtils"], function (a, w) { a.getEllipsoidMode = function (c) { return c && w.isMars(c) ? 2 : c && w.isMoon(c) ? 3 : 1 }; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "esri/views/3d/layers/i3s/I3SStreamDataController": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/promiseUtils"], function (a, w, c) {
        let q = function () {
          function u(n, p) { this.requester = n; this.apiKey = p; this.activeRequests = new Set } var y = u.prototype; y.request = function (n,
            p, l) { const h = new AbortController; l = c.onAbortOrThrow(l, () => h.abort()); n = this.requester.request(n, p, { signal: h.signal, query: { token: this.apiKey } }); const b = { response: n, abortController: h, abortHandle: l }; this.activeRequests.add(b); c.always(n, () => { var d; b.abortController = null; null == (d = b.abortHandle) ? void 0 : d.remove(); b.abortHandle = null; this.activeRequests.delete(b) }); return n }; y.cancelAll = function () {
              this.activeRequests.forEach(n => {
                var p, l; null == (p = n.abortController) ? void 0 : p.abort(); n.abortController = null;
                null == (l = n.abortHandle) ? void 0 : l.remove()
              }); this.activeRequests.clear()
            }; w._createClass(u, [{ key: "busy", get: function () { return this.requester.busy } }]); return u
        }(); a.I3SStreamDataController = q; a.default = q; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/I3SViewportQueries": function () {
      define("../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4 ../../../../geometry/projection ../../../../geometry/projectionEllipsoid ../../../../geometry/support/frustum ../../../../chunks/sphere ../../../../layers/graphics/dehydratedFeatures ../graphics/elevationAlignmentUtils ../graphics/ElevationContext ../graphics/featureExpressionInfoUtils ./I3SUtil ../../support/orientedBoundingBox".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
          return function () {
            function v(e, g, x, k, r, A, z, B = {}) {
            this._indexSR = e; this._renderCoordsHelper = g; this.clippingArea = r; this._elevationProvider = A; this._options = B; this._frustum = n.create(); this._useFrustumCulling = !1; this._poi = c.create(); this.minDistance = Infinity; this.maxDistance = 0; this.maxLodLevel = 2; this._tmp1 = c.create(); this._tmp2 = c.create(); this._tmp3 = c.create(); this._tmp0 = c.create(); this._screenspaceErrorBias = B.screenspaceErrorBias || 1; this._progressiveLoadFactor = B.progressiveLoadFactor ||
              1; this.updateCamera(x, k); this.engineSR = this._renderCoordsHelper.spatialReference; this.updateElevationInfo(z); this._tmpPoint = l.makeDehydratedPoint(0, 0, 0, e)
            } var m = v.prototype; m.updateElevationInfo = function (e) { null == e ? this._elevationContext = null : (this._elevationContext = b.ElevationContext.fromElevationInfo(e), this._elevationContext.updateFeatureExpressionInfoContext(d.createContextWithoutExpressionSupport(d.extractExpressionInfo(e, !1)))) }; m.updateCamera = function (e, g) {
            (this._useFrustumCulling = g) && n.fromMatrix(e.viewMatrix,
              e.projectionMatrix, this._frustum); this._screenSizeFactor = 1 / (e.perScreenPixelRatio / 2); this._camPos = e.eye; this.minDistance = Infinity; this.maxDistance = 0
            }; m.setPointOfInterest = function (e) { this._poi = e }; m.updateScreenSpaceErrorBias = function (e) { const g = this._screenspaceErrorBias; this._screenspaceErrorBias = e; return g }; m.updateClippingArea = function (e) { this.clippingArea = e }; m.getRenderMbs = function (e) {
              const g = e.renderMbs; 0 > g[3] && (q.copy(g, e.mbs), this._elevationContext && 1E5 > g[3] && (this._tmpPoint.x = g[0], this._tmpPoint.y =
                g[1], this._tmpPoint.z = g[2], g[2] = h.evaluateElevationAlignmentAtPoint(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper)), u.projectBoundingSphere(g, this._indexSR, g, this.engineSR)); return g
            }; m.getVisibilityObb = function (e) { if (a.isSome(e.visibilityObb)) return e.visibilityObb; const g = e.serviceObb; if (!(a.isNone(g) || 0 > g.halfSize[0])) return e.serviceObbInRenderSR = this._computeRenderObb(g, e.serviceObbInRenderSR, e.mbs[3]), e.serviceObbInRenderSR }; m._computeRenderObb = function (e,
              g, x) { a.isNone(g) && (g = t.create()); if (0 > g.halfSize[0]) { let k = 0; this._elevationContext && 1E5 > x && (this._tmpPoint.x = e.center[0], this._tmpPoint.y = e.center[1], this._tmpPoint.z = e.center[2], k = h.evaluateElevationAlignmentAtPoint(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper) - e.center[2]); f.transformObb(e, this._indexSR, g, this.engineSR, k) } return g }; m.isNodeVisible = function (e) {
                const g = this.getRenderMbs(e); if (!this._isMBSinClippingArea(g)) return !1; if (!this._useFrustumCulling) return !0;
                e = this.getVisibilityObb(e); return a.isSome(e) ? t.isVisible(e, this._frustum) : n.intersectsSphere(this._frustum, p.wrap(g))
              }; m.isGeometryVisible = function (e) { if (!this._useFrustumCulling) return !0; const g = e.geometryObb; return a.isSome(g) ? t.isVisible(g, this._frustum) : this.isNodeVisible(e) }; m._isMBSinClippingArea = function (e) { return a.isNone(this.clippingArea) ? !0 : 0 !== f.intersectBoundingRectWithMbs(this.clippingArea, e) }; m.screenSpaceDiameterMbs = function (e, g) {
                var x = this.getRenderMbs(e); e = Math.sqrt(w.squaredDistance(x,
                  this._camPos)); x = e - x[3]; this._updateMinMaxDistance(e); return 0 > x ? .5 * Number.MAX_VALUE : g / x * this._screenSizeFactor
              }; m.calcCameraDistance = function (e) { return this.calcCameraDistanceToCenter(e) - this.getRenderMbs(e)[3] }; m.calcCameraDistanceToCenter = function (e) { e = this.getRenderMbs(e); e = w.distance(e, this._camPos); this._updateMinMaxDistance(e); return e }; m.calcAngleDependentLoD = function (e) {
                e = this.getRenderMbs(e); const g = e[3]; e = (Math.abs(e[0] * (e[0] - this._camPos[0]) + e[1] * (e[1] - this._camPos[1]) + e[2] * (e[2] - this._camPos[2])) /
                  w.length(e) + g) / w.distance(e, this._camPos); return Math.min(1, e)
              }; m.hasLOD = function (e) { return 0 !== e.lodMetric }; m.getDistancePlanarMode = function (e, g) { var x = e[0] - g[0]; const k = e[1] - g[1]; e = e[2] - g[2]; x = x * x + k * k; g = g[3]; if (x <= g * g) return Math.abs(e); g = Math.sqrt(x) - g; return Math.sqrt(e * e + g * g) }; m.getDistanceGlobeMode = function (e, g) {
                var x = w.length(g); const k = w.length(e) - x; w.scale(this._tmp0, e, w.dot(e, g) / w.squaredLength(e)); var r = w.squaredDistance(g, this._tmp0), A = g[3]; if (r <= A * A) return Math.abs(k); g = w.scale(this._tmp0,
                  g, 1 / x); x = w.scale(this._tmp1, g, x - A * A / 2 / x); r = w.subtract(this._tmp2, e, x); r = w.subtract(this._tmp2, r, w.scale(this._tmp3, g, w.dot(g, r))); x = w.add(this._tmp2, x, w.scale(this._tmp2, r, A / w.length(r))); A = w.distance(e, x); 2E5 <= k && (e = w.subtract(this._tmp1, e, x), e = w.dot(e, g) / w.length(e), .08 > e && (e = 1E-4), A /= e); return A
              }; m.getDistance = function (e, g) { return this.engineSR === y.getSphericalPCPF(this.engineSR) ? this.getDistanceGlobeMode(e, g) : this.getDistancePlanarMode(e, g) }; m._updateMinMaxDistance = function (e) {
                0 < e ? (this.minDistance =
                  Math.min(this.minDistance, e), this.maxDistance = Math.max(this.maxDistance, e)) : (this.minDistance = 0, this.maxDistance = Math.max(this.maxDistance, -e))
              }; m.getLodLevel = function (e) {
                if (0 === e.lodMetric || !e.resources.hasFeatureData) return 0; if (0 === e.childCount) return this.maxLodLevel; if (this._useFrustumCulling && 1 > this._progressiveLoadFactor) { const g = this._screenspaceErrorBias; return this.evaluateLODmetric(e, this._progressiveLoadFactor * this._screenspaceErrorBias) ? this.evaluateLODmetric(e, g) ? 2 : 1 : 0 } return this.evaluateLODmetric(e,
                  this._screenspaceErrorBias) ? this.maxLodLevel : 0
              }; m.evaluateLODmetric = function (e, g) {
                switch (e.lodMetric) {
                  case 2: { const x = this.getRenderMbs(e), k = this.getDistance(this._camPos, x), r = 2 * k / this._screenSizeFactor; this._updateMinMaxDistance(k + x[3]); return e.maxError * g <= r } case 1: return g = this.screenSpaceDiameterMbs(e, e.mbs[3] * g), this._options.angleDependentLoD && (g *= this.calcAngleDependentLoD(e)), g < e.maxError; case 3: return 10 > this.screenSpaceDiameterMbs(e, e.maxError) * g; case 4: return this.calcCameraDistance(e) >
                    e.maxError * g
                }return !1
              }; m.distToPOI = function (e) { e = this.getRenderMbs(e); return w.distance(e, this._poi) - e[3] }; m.distCameraToPOI = function () { return w.distance(this._camPos, this._poi) }; return v
          }()
        })
    }, "esri/layers/support/SceneModification": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../core/JSONSupport ../../core/lang ../../core/Warning ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/accessorSupport/decorators/persistable ../../geometry/projection ../../geometry/Polygon".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          var t; c = t = function (v) {
            function m(g) { g = v.call(this, g) || this; g.geometry = null; g.type = "clip"; return g } a._inheritsLoose(m, v); var e = m.prototype; e.writeGeometry = function (g, x, k, r) {
              if (r.layer && r.layer.spatialReference && !r.layer.spatialReference.equals(this.geometry.spatialReference)) {
                if (!d.canProjectWithoutEngine(g.spatialReference, r.layer.spatialReference)) {
                r && r.messages && r.messages.push(new y("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported",
                  { modification: this, spatialReference: r.layer.spatialReference, context: r })); return
                } const A = new f; d.projectPolygon(g, A, r.layer.spatialReference); x[k] = A.toJSON(r)
              } else x[k] = g.toJSON(r); delete x[k].spatialReference
            }; e.clone = function () { return new t({ geometry: u.clone(this.geometry), type: this.type }) }; return m
          }(q.JSONSupport); w.__decorate([n.property({ type: f }), b.persistable()], c.prototype, "geometry", void 0); w.__decorate([h.writer(["web-scene", "portal-item"], "geometry")], c.prototype, "writeGeometry", null); w.__decorate([n.property({
            type: ["clip",
              "mask", "replace"], nonNullable: !0
          }), b.persistable()], c.prototype, "type", void 0); return c = t = w.__decorate([l.subclass("esri.layers.support.SceneModification")], c)
        })
    }, "esri/core/accessorSupport/decorators/persistable": function () {
      define("require exports ../../../chunks/_rollupPluginBabelHelpers ../../maybe ../../multiOriginJSONSupportUtils ../../urlUtils ../../uuid ../metadata ../PropertyOrigin ./property ../../../portal/support/resourceExtension ../../../chunks/persistableUrlUtils".split(" "), function (a,
        w, c, q, u, y, n, p, l, h, b, d) {
          function f(x, k, r) {
            const A = p.getOwnPropertyMetadata(k, r); return {
              type: String, read: (z, B, C) => { z = d.read(z, B, C); if (A.type === String) return z; if ("function" === typeof A.type) return new A.type({ url: z }) }, write: {
                writer(z, B, C, D) {
                  if (D && D.resources) {
                    var E = q.isNone(z) ? null : "string" === typeof z ? z : z.url; E = E ? d.toJSON(E, { ...D, verifyItemRelativeUrls: D && D.verifyItemRelativeUrls ? { writtenUrls: D.verifyItemRelativeUrls.writtenUrls, rootPath: null } : null }, 1) : null; var H = A.type !== String && (!u.isMultiOriginJSONMixin(this) ||
                      D && D.origin && this.originIdOf(r) > l.nameToId(D.origin)); if (D && D.portalItem && q.isSome(E) && !y.isAbsolute(E)) if (H) { { H = D.portalItem.resourceFromPath(E); const J = m(z, E, D), M = b.getResourceContentExtension(J), F = y.getPathExtension(H.path); M !== F ? t(this, r, z, E, B, C, D, x) : (v(this, r, H, J, D.resources.toUpdate), B[C] = E) } } else D.resources.toKeep.push({ resource: D.portalItem.resourceFromPath(E) }), B[C] = E; else D && D.portalItem && (q.isNone(E) || q.isSome(d.itemIdFromResourceUrl(E)) || y.isBlobProtocol(E) || H) ? t(this, r, z, E, B, C, D, x) :
                        B[C] = E
                  } else B[C] = "string" === typeof z ? d.toJSON(z, D) : z.write({}, D)
                }
              }
            }
          } function t(x, k, r, A, z, B, C, D) { const E = n.generateUUID(); r = m(r, A, C); const H = y.join(q.get(D, "prefix"), E); D = `${H}.${b.getResourceContentExtension(r)}`; const J = C.portalItem.resourceFromPath(D); y.isBlobProtocol(A) && C.resources.pendingOperations.push(e(A).then(M => { J.path = `${H}.${b.getResourceContentExtension(M)}`; z[B] = J.itemRelativeUrl }).catch(() => { })); v(x, k, J, r, C.resources.toAdd); z[B] = J.itemRelativeUrl } function v(x, k, r, A, z) {
            z.push({
              resource: r,
              content: A, finish: B => { "string" === typeof x[k] ? x[k] = B.url : x[k].url = B.url }
            })
          } function m(x, k, r) { return "string" === typeof x ? { url: k } : new Blob([JSON.stringify(x.toJSON(r))], { type: "application/json" }) } function e(x) { return g.apply(this, arguments) } function g() { g = c._asyncToGenerator(function* (x) { const k = (yield new Promise((r, A) => a(["../../../request"], z => r(Object.freeze({ __proto__: null, default: z })), A))).default; ({ data: x } = yield k(x, { responseType: "blob" })); return x }); return g.apply(this, arguments) } w.persistable =
            function (x) { const k = q.isSome(x) && x.origins ? x.origins : [void 0]; return (r, A) => { a: if (q.isSome(x) && "resource" === x.type) var z = f(x, r, A); else { switch (q.isSome(x) && x.type ? x.type : "other") { case "other": z = { read: !0, write: !0 }; break a; case "url": { const { read: B, write: C } = d.persistableUrlUtils; z = { read: B, write: C }; break a } }z = void 0 } for (const B of k) { const C = h.propertyJSONMeta(r, B, A); for (const D in z) C[D] = z[D] } } }; Object.defineProperty(w, "__esModule", { value: !0 })
      })
    }, "esri/portal/support/resourceExtension": function () {
      define(["exports",
        "../../core/urlUtils"], function (a, w) {
          const c = {}, q = c["text/plain"], u = { png: "image/png", jpeg: "image/jpeg", jpg: "image/jpg", bmp: "image/bmp", gif: "image/gif", json: "application/json", txt: "text/plain", xml: "application/xml", svg: "image/svg+xml", zip: "application/zip", pbf: "application/vnd.mapbox-vector-tile", gz: "application/gzip" }; for (const y in u) c[u[y]] = y; a.getResourceContentExtension = function (y) { y instanceof Blob ? y = y.type : (y = w.getPathExtension(y.url), y = u[y] || "text/plain"); return c[y] || q }; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/I3SMeshViewLabeler": function () {
      define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../symbols ../../../core/Accessor ../../../core/Handles ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/diffUtils ../../../chunks/vec3f64 ../../../layers/graphics/dehydratedFeatures ./graphics/Graphics3DCore ./graphics/Graphics3DScaleVisibility ./i3s/I3SGeometryUtil ../support/LimitGraphicsMap ../../../symbols/PointSymbol3D".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k) {
          q = function (z) {
            function B(D) { D = z.call(this, D) || this; D.loadedGraphics = new x.LimitGraphicsMap(5E4); D.slicePlaneEnabled = !1; D._renderingInfo = { symbol: new k }; D._handles = new y; D._graphicsByNode = new Map; D._scaleVisibility = null; return D } a._inheritsLoose(B, z); var C = B.prototype; C.initialize = function () {
            this._graphicsCore = new m.Graphics3DCore({
              owner: this, layer: this.layer, preferredUpdatePolicy: 0, elevationFeatureExpressionEnabled: !1, graphicSymbolSupported: !1, getRenderingInfoWithoutRenderer: !0,
              hasZ: !0, hasM: !1
            }); var D = this.view.basemapTerrain; this._scaleVisibility = new e({ layerScaleEnabled: !1 }); this._scaleVisibility.setup(this, this.layer, (H, J, M) => this._graphicsCore.spatialIndex.queryGraphicUIDsInExtent(H, J, M), this._graphicsCore, D); D = this.view.labeler.addGraphicsOwner(this._graphicsCore, this._scaleVisibility, { emptySymbolLabelSupported: !0, elevationInfoOverride: { mode: "absolute-height", offset: 0 }, disablePlacement: { logEntityDescription: "3D Object Scene Layer features" } }); const E = this.view.deconflictor.addGraphicsOwner(this._graphicsCore);
              this._graphicsCore.setup({ labeler: D, deconflictor: E, scaleVisibility: this._scaleVisibility }).then(() => { this._graphicsCore.startCreateGraphics() }).catch(() => { }); this._handles.add([this.layer.watch("labelingInfo", (H, J) => { f.diff(H, J) && this._graphicsCore.updateLabelingInfo() })])
            }; C.destroy = function () {
            this._handles && (this._handles.destroy(), this._handles = null); null != this._scaleVisibility && (this._scaleVisibility.destroy(), this._scaleVisibility = null); null != this._graphicsCore && (this._graphicsCore.destroy(),
              this._graphicsCore = null); this.loadedGraphics.destroy(); this.view = null
            }; C.addNodeMeta = function (D, E) {
              let H = 0; const J = D.filteredIds, M = D.featureIds.map((F, K) => { g.boundingBoxTop(K, this.collection, D.objectHandle, A); const P = v.makeDehydratedPoint(0, 0, 0, this.view.spatialReference); this.view.renderCoordsHelper.fromRenderCoords(A, P); K = E(K, D); let L = !1; n.isNone(J) ? L = !0 : H < J.length && F === J[H] && (L = !0, H++); return { objectId: F, uid: c.generateUID(), attributes: K, visible: L, geometry: P } }); this.loadedGraphics.addMany(M); this._graphicsByNode.set(D.node.index,
                M)
            }; C.setNodeMetaAttributes = function (D, E) { const H = this._graphicsByNode.get(D.node.index), J = Array(H.length); for (let M = 0; M < H.length; M++) { const F = H[M]; F.attributes = E(M, D); J[M] = F.uid } this._graphicsCore.updateLabelingInfo(J) }; C.applyFilterChange = function (D) {
              var E = this._graphicsByNode.get(D.node.index); if (E) if (n.isNone(D.filteredIds)) for (var H of E) H.visible || (H.visible = !0, r.graphic = H, r.property = "visible", r.oldValue = !1, r.newValue = !0, this._graphicsCore.graphicUpdateHandler(r)); else {
                H = 0; for (const J of E) E =
                  J.visible, H < D.filteredIds.length && J.objectId === D.filteredIds[H] ? (J.visible = !0, H++) : J.visible = !1, E !== J.visible && (r.graphic = J, r.property = "visible", r.oldValue = E, r.newValue = J.visible, this._graphicsCore.graphicUpdateHandler(r))
              }
            }; C.removeNodeMeta = function (D) { this.loadedGraphics.removeManyByObjectId(D.featureIds) }; C.getRenderingInfo = function () { return this._renderingInfo }; C.notifyGraphicGeometryChanged = function () { }; C.notifyGraphicVisibilityChanged = function () { }; a._createClass(B, [{ key: "updatePolicy", get: function () { return this._graphicsCore.effectiveUpdatePolicy } },
            { key: "usedMemory", get: function () { return this._graphicsCore.usedMemory } }, { key: "unloadedMemoryEstimate", get: function () { return this._graphicsCore.unprocessedMemoryEstimate } }, { key: "test", get: function () { return { graphicsCore: this._graphicsCore } } }]); return B
          }(u); w.__decorate([p.property()], q.prototype, "view", void 0); w.__decorate([p.property()], q.prototype, "layer", void 0); w.__decorate([p.property()], q.prototype, "collection", void 0); w.__decorate([p.property()], q.prototype, "loadedGraphics", void 0); w.__decorate([p.property({ aliasOf: "_graphicsCore.updating" })],
            q.prototype, "updating", void 0); w.__decorate([p.property()], q.prototype, "slicePlaneEnabled", void 0); w.__decorate([p.property()], q.prototype, "_graphicsCore", void 0); q = w.__decorate([d.subclass("esri.views.3d.layers.I3SMeshViewLabeler")], q); const r = { graphic: null, property: null, oldValue: null, newValue: null }, A = t.create(); return q
        })
    }, "esri/views/3d/layers/i3s/I3SGeometryUtil": function () {
      define("exports ../../../../core/maybe ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox".split(" "),
        function (a, w, c, q, u, y) {
          function n(h, b, d, f) { h = b.getComponentAabb(d, h, p); b = b.getObjectTransform(d); for (d = 0; 8 > d; ++d)l[0] = d & 1 ? h[0] : h[3], l[1] = d & 2 ? h[1] : h[4], l[2] = d & 4 ? h[2] : h[5], c.transformMat3(l, l, b.rotationScale), c.add(l, l, b.position), f[3 * d] = l[0], f[3 * d + 1] = l[1], f[3 * d + 2] = l[2]; return f } const p = y.create(), l = q.create(); a.boundingBoxCornerPoints = n; a.boundingBoxTop = function (h, b, d, f) {
            h = b.getComponentAabb(d, h, p); b = b.getObjectTransform(d); f[0] = 0; f[1] = 0; f[2] = 0; for (d = 0; 8 > d; ++d)l[0] = d & 1 ? h[0] : h[3], l[1] = d & 2 ? h[1] : h[4],
              l[2] = h[5], c.transformMat3(l, l, b.rotationScale), c.add(l, l, b.position), f[0] += l[0], f[1] += l[1], f[2] += l[2]; f[0] /= 8; f[1] /= 8; f[2] /= 8; return f
          }; a.createGetFeatureExtent = function (h, b, d) {
            const f = new Float64Array(24); return t => {
              var v = t.meta.featureExtents; if (w.isNone(v)) { v = new Float64Array(6 * t.meta.featureIds.length); t.meta.featureExtents = v; for (let m = 0; m < v.length; m += 6)v[m] = Number.POSITIVE_INFINITY } v = new Float64Array(v.buffer, 6 * t.index * Float64Array.BYTES_PER_ELEMENT, 6); v[0] === Number.POSITIVE_INFINITY && (n(t.index,
                d, t.meta.objectHandle, f), u.projectBuffer(f, b, 0, f, h, 0, 8) ? (y.set(v, y.NEGATIVE_INFINITY), y.expandWithBuffer(v, f, 0, 8)) : y.set(v, y.ZERO)); return v
            }
          }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/support/LimitGraphicsMap": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/Evented", "../../../core/MapUtils", "./GraphicsMap"], function (a, w, c, q, u) {
        c = function (p) {
          function l(b) {
            var d = p.call(this) || this; d._limit = b; d._all = new u.GraphicsMap; d._active = new n(w._assertThisInitialized(d));
            d._pending = new Map; d._handle = d._all.on("change", f => d._handleChanges(f)); return d
          } w._inheritsLoose(l, p); var h = l.prototype; h.destroy = function () { this._handle.remove() }; h.toArray = function () { return this._active.toArray() }; h.find = function (b) { return this._active.find(b) }; h.forEach = function (b) { this._active.forEach(b) }; h.addMany = function (b) { this._all.addMany(b) }; h.removeManyByObjectId = function (b) { this._all.removeManyByObjectId(b) }; h._handleChanges = function (b) {
            let d = b.removed; if (0 < this._pending.size) {
              d = [];
              for (var f of b.removed) this._pending.delete(f.objectId) || d.push(f)
            } f = this._limit - this._active.length + d.length; f < b.added.length && (this._active.removeMany(d), d = [], y.reset(1 - this._limit / (this._active.length + b.added.length)), this._active.forEach(v => { y.sample() && (d.push(v), this._pending.set(v.objectId, v)) }), f = this._limit - this._active.length + d.length); let t = b.added; if (f < b.added.length) { t = []; y.reset(f / b.added.length); for (const v of b.added) y.sample() ? t.push(v) : this._pending.set(v.objectId, v) } b = f - t.length;
            0 < b && 0 < this._pending.size && (y.reset(b / this._pending.size), this._pending.forEach(v => { y.sample() && (t.push(v), this._pending.delete(v.objectId)) })); this._active.addAndRemove(t, d)
          }; w._createClass(l, [{ key: "length", get: function () { return this._active.length } }]); return l
        }(c); const y = new (function () {
          function p() { this.percentage = 1; this.last = -1; this.index = 0 } var l = p.prototype; l.reset = function (h) { this.percentage = h; this.last = -1 }; l.sample = function () {
            const h = Math.floor(this.index * this.percentage); ++this.index; if (h ===
              this.last) return !1; this.last = h; return !0
          }; return p
        }()); let n = function () {
          function p(h) { this._parent = h; this._map = new Map } var l = p.prototype; l.forEach = function (h) { this._map.forEach(b => h(b)) }; l.find = function (h) { let b; q.someMap(this._map, d => h(d) ? (b = d, !0) : !1); return b }; l.toArray = function () { return [...this._map.values()] }; l.addAndRemove = function (h, b) { for (const d of h) this._map.set(d.objectId, d); for (const d of b) this._map.delete(d.objectId); (0 < h.length || 0 < b.length) && this._parent.emit("change", { added: h, removed: b }) };
          l.removeMany = function (h) { for (const b of h) this._map.delete(b.objectId); 0 < h.length && this._parent.emit("change", { added: [], removed: h }) }; w._createClass(p, [{ key: "length", get: function () { return this._map.size } }]); return p
        }(); a.LimitGraphicsMap = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/support/GraphicsMap": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/Evented", "../../../core/MapUtils"], function (a, w, c, q) {
        c = function (u) {
          function y() {
            var p =
              u.apply(this, arguments) || this; p._map = new Map; return p
          } w._inheritsLoose(y, u); var n = y.prototype; n.clear = function () { if (0 < this._map.size) { const p = this.toArray(); this._map.clear(); this.emit("change", { added: [], removed: p }) } }; n.get = function (p) { return this._map.get(p) }; n.addMany = function (p) {
            if (0 !== p.length) {
              var l = new Set; for (let h = 0; h < p.length; h++) { const b = p[h], d = b.objectId, f = this._map.get(d); f ? (l.add(d), b !== f && (p[h] = f), ++f.refCount) : (b.refCount = 1, this._map.set(d, b)) } p = 0 < l.size ? p.filter(h => !l.has(h.objectId)) :
                p; 0 < p.length && this.emit("change", { added: p, removed: [] })
            }
          }; n.removeMany = function (p) { const l = []; for (const h of p) { p = h.objectId; const b = this._map.get(p); null != b && 0 >= --b.refCount && (this._map.delete(p), l.push(h)) } 0 < l.length && this.emit("change", { added: [], removed: l }) }; n.removeManyByObjectId = function (p) { const l = []; for (const h of p) p = this._map.get(h), null != p && 0 >= --p.refCount && (this._map.delete(h), l.push(p)); 0 < l.length && this.emit("change", { added: [], removed: l }) }; n.toArray = function () { return [...this._map.values()] };
          n.find = function (p) { let l; q.someMap(this._map, h => p(h) ? (l = h, !0) : !1); return l }; n.forEach = function (p) { this._map.forEach(l => p(l)) }; w._createClass(y, [{ key: "length", get: function () { return this._map.size } }]); return y
        }(c); a.GraphicsMap = c; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/I3SMeshWorkerHandle": function () {
      define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/Logger ../../../core/maybe ../../../core/PooledArray ../../../core/workers/WorkerHandle ../../../geometry/projection".split(" "),
        function (a, w, c, q, u, y, n) {
          function p(d, f, t) {
            h.clear(); var v = Infinity; let m = Infinity, e = -Infinity, g = -Infinity, x = !1; for (const r of f) {
              var k = "clip" === r.type ? 2 : "mask" === r.type ? 1 : 0; const A = r.geometry; f = z => z; if (A.spatialReference) { if (!n.canProjectWithoutEngine(A.spatialReference, t)) { l.warn("Can't project modification polygon into layer spatial reference, ignoring modification"); continue } f = z => { n.projectVectorToVector(z, A.spatialReference, b, t); return b } } else A.hasZ || (b[2] = 0, f = z => { b[0] = z[0]; b[1] = z[1]; return b });
              x = x || 1 === k; h.push(k); h.push(A.rings.length); for (const z of A.rings) { h.push(z.length); for (const B of z) k = f(B), h.push(k[0]), h.push(k[1]), h.push(k[2]), v = Math.min(v, k[0]), m = Math.min(m, k[1]), e = Math.max(e, k[0]), g = Math.max(g, k[1]) }
            } q.isSome(d) && (x ? (h.push(2), h.push(2), h.push(4), h.push(v - 1E-4), h.push(m - 1E-4), h.push(0), h.push(e + 1E-4), h.push(m - 1E-4), h.push(0), h.push(e + 1E-4), h.push(g + 1E-4), h.push(0), h.push(v - 1E-4), h.push(g + 1E-4), h.push(0)) : (h.push(1), h.push(1)), h.push(4), h.push(d[0]), h.push(d[1]), h.push(0),
              h.push(d[2]), h.push(d[1]), h.push(0), h.push(d[2]), h.push(d[3]), h.push(0), h.push(d[0]), h.push(d[3]), h.push(0)); h.push(3); d = new Float64Array(h.length); for (v = 0; v < h.length; ++v)d[v] = h.getItemAt(v); return d
          } const l = c.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle"); c = function (d) {
            function f(v) { return d.call(this, "SceneLayerWorker", "process", v, { hasInitialize: !0 }) || this } w._inheritsLoose(f, d); var t = f.prototype; t.getTransferList = function (v) { return [v.geometryBuffer] }; t.setModifications = function (v, m, e, g) {
              v =
              { context: v, modifications: p(m, e, g), isGeodetic: g.isGeographic }; this.broadcast(v, "setModifications")
            }; t.setLegacySchema = function (v, m) { m = JSON.stringify(m); this.broadcast({ context: v, jsonSchema: m }, "setLegacySchema") }; t.destroyContext = function (v) { return this.broadcast(v, "destroyContext") }; return f
          }(y.WorkerHandle); const h = new u({ deallocator: null }), b = [0, 0, 0]; a.I3SMeshWorkerHandle = c; a.toWasmModification = p; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/SceneLayerWorker": function () {
      define(["exports",
        "../../../chunks/_rollupPluginBabelHelpers", "../../../core/maybe", "../../../core/typedArrayUtil", "../../../libs/i3s/I3SModule"], function (a, w, c, q, u) {
          function y() { y = w._asyncToGenerator(function* (k) { yield m(); const r = [k.geometryBuffer]; return { result: d(k, r), transferList: r } }); return y.apply(this, arguments) } function n() {
            n = w._asyncToGenerator(function* (k) {
              var r; yield m(); const A = [k.geometryBuffer]; var { geometryBuffer: z } = k, B = z.byteLength; k = g._malloc(B); B = new Uint8Array(g.HEAPU8.buffer, k, B); B.set(new Uint8Array(z));
              z = g.dracoDecompressPointCloudData(k, B.byteLength); g._free(k); if (0 < z.error.length) throw `i3s.wasm: ${z.error}`; k = 0 < (null == (r = z.featureIds) ? void 0 : r.length) ? q.slice(z.featureIds) : null; r = q.slice(z.positions); k && A.push(k.buffer); A.push(r.buffer); return { result: { positions: r, featureIds: k }, transferList: A }
            }); return n.apply(this, arguments)
          } function p() { p = w._asyncToGenerator(function* (k) { yield m(); f(k); k = { buffer: k.buffer }; return { result: k, transferList: [k.buffer] } }); return p.apply(this, arguments) } function l() {
            l =
            w._asyncToGenerator(function* (k) { yield m(); b(k) }); return l.apply(this, arguments)
          } function h() { h = w._asyncToGenerator(function* (k) { yield m(); g.setLegacySchema(k.context, k.jsonSchema) }); return h.apply(this, arguments) } function b(k) { const r = k.modifications, A = g._malloc(8 * r.length), z = new Float64Array(g.HEAPU8.buffer, A, r.length); for (let B = 0; B < r.length; ++B)z[B] = r[B]; g.setModifications(k.context, A, r.length, k.isGeodetic); g._free(A) } function d(k, r) {
            if (!g) return null; const { context: A, localOrigin: z, globalTrafo: B,
              mbs: C, obb: D, elevationOffset: E, geometryBuffer: H, geometryDescriptor: J, indexToVertexProjector: M, vertexToRenderProjector: F } = k; var K = g._malloc(H.byteLength), P = g._malloc(33 * Float64Array.BYTES_PER_ELEMENT), L = new Uint8Array(g.HEAPU8.buffer, K, H.byteLength); L.set(new Uint8Array(H)); var N = new Float64Array(g.HEAPU8.buffer, P, 33); v(N, z); var G = N.byteOffset + 3 * N.BYTES_PER_ELEMENT, I = new Float64Array(N.buffer, G); v(I, B); G += 16 * N.BYTES_PER_ELEMENT; I = new Float64Array(N.buffer, G); v(I, C); G += 4 * N.BYTES_PER_ELEMENT; c.isSome(D) &&
                (I = new Float64Array(N.buffer, G), v(I, D.center), G += 3 * N.BYTES_PER_ELEMENT, I = new Float64Array(N.buffer, G), v(I, D.halfSize), G += 3 * N.BYTES_PER_ELEMENT, I = new Float64Array(N.buffer, G), v(I, D.quaternion)); N = { isDraco: !1, isLegacy: !1, color: k.layouts.some(R => R.some(S => "color" === S.name)), normal: k.needNormals && k.layouts.some(R => R.some(S => "normalCompressed" === S.name)), uv0: k.layouts.some(R => R.some(S => "uv0" === S.name)), uvRegion: k.layouts.some(R => R.some(S => "uvRegion" === S.name)), featureIndex: J.featureIndex }; L = g.process(A,
                  !!k.obb, K, L.byteLength, J, N, P, E, M, F, k.normalReferenceFrame); g._free(P); g._free(K); if (0 < L.error.length) throw `i3s.wasm: ${L.error}`; if (L.discarded) return null; K = 0 < L.componentOffsets.length ? q.slice(L.componentOffsets) : null; P = 0 < L.featureIds.length ? q.slice(L.featureIds) : null; N = q.slice(L.interleavedVertedData).buffer; G = 1 === L.indicesType ? q.slice(new Uint16Array(L.indices.buffer, L.indices.byteOffset, L.indices.byteLength / 2)) : q.slice(new Uint32Array(L.indices.buffer, L.indices.byteOffset, L.indices.byteLength /
                    4)); I = q.slice(L.positions); const O = 1 === L.positionIndicesType ? q.slice(new Uint16Array(L.positionIndices.buffer, L.positionIndices.byteOffset, L.positionIndices.byteLength / 2)) : q.slice(new Uint32Array(L.positionIndices.buffer, L.positionIndices.byteOffset, L.positionIndices.byteLength / 4)); k = { layout: k.layouts[0], interleavedVertexData: N, indices: G, hasColors: L.hasColors, hasModifications: L.hasModifications, positionData: { data: I, indices: O } }; P && r.push(P.buffer); K && r.push(K.buffer); r.push(N); r.push(G.buffer); r.push(I.buffer);
            r.push(O.buffer); return { componentOffsets: K, featureIds: P, transformedGeometry: k, obb: L.obb }
          } function f(k) { const { context: r, buffer: A } = k; k = g._malloc(A.byteLength); const z = A.byteLength / Float64Array.BYTES_PER_ELEMENT, B = new Float64Array(g.HEAPU8.buffer, k, z), C = new Float64Array(A); B.set(C); g.filterOBBs(r, k, z); C.set(B); g._free(k) } function t(k) { g && g.destroy(k) } function v(k, r) { for (let A = 0; A < r.length; ++A)k[A] = r[A] } function m() { if (g) return Promise.resolve(); e || (e = u.get().then(k => { g = k; e = null })); return e } let e, g;
          const x = { transform: d, destroy: t }; a.destroyContext = function (k) { t(k) }; a.dracoDecompressPointCloudData = function (k) { return n.apply(this, arguments) }; a.filterObbsForModifications = function (k) { return p.apply(this, arguments) }; a.filterObbsForModificationsSync = f; a.initialize = m; a.interpretObbModificationResults = function (k) { return 0 === k ? 0 : 1 === k ? 1 : 2 === k ? 2 : 3 }; a.process = function (k) { return y.apply(this, arguments) }; a.setLegacySchema = function (k) { return h.apply(this, arguments) }; a.setModifications = function (k) {
            return l.apply(this,
              arguments)
          }; a.setModificationsSync = b; a.test = x; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/libs/i3s/I3SModule": function () {
      define(["require", "exports", "../../assets"], function (a, w, c) {
        function q(y) { return c.getAssetUrl(`esri/libs/i3s/${y}`) } let u; w.get = function () { u || (u = (new Promise(y => (new Promise((n, p) => a(["../../chunks/i3s"], n, p))).then(n => n.i3s).then(({ default: n }) => { const p = n({ locateFile: q, onRuntimeInitialized: () => y(p) }); delete p.then }))).catch(y => Promise.reject(y))); return u }; Object.defineProperty(w,
          "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/Highlights": function () {
      define(["../../../../core/arrayUtils"], function (a) {
        let w = function () { this.ids = new Set; this.paused = !1 }; return function () {
          function c({ collection: u, forAllFeatures: y, forAllFeaturesOfNode: n }) { this.highlights = []; this.collection = u; this.forAllFeatures = y; this.forAllFeaturesOfNode = n } var q = c.prototype; q.destroy = function () { this.highlights.forEach(u => this.releaseSet(u)); this.highlights = null }; q.acquireSet = function () {
            const u = new w; this.highlights.push(u);
            return { set: u, handle: { remove: () => { this.releaseSet(u); a.removeUnordered(this.highlights, u) }, pause: () => { this.releaseSet(u); u.paused = !0 }, resume: () => { u.paused = !1; this.initializeSet(u) } } }
          }; q.setFeatureIds = function (u, y) { y.forEach(n => u.ids.add(n)); this.initializeSet(u) }; q.initializeSet = function (u) { this.forAllFeatures((y, n, p) => { u.ids.has(y) && this.collection.addComponentHighlight(p.objectHandle, n); return 1 }) }; q.releaseSet = function (u) {
            this.forAllFeatures((y, n, p) => {
              u.ids.has(y) && this.collection.removeComponentHighlight(p.objectHandle,
                n); return 1
            })
          }; q.objectCreated = function (u) { this.highlights.forEach(y => { y.paused || this.forAllFeaturesOfNode(u, (n, p) => { y.ids.has(n) && this.collection.addComponentHighlight(u.objectHandle, p); return 1 }) }) }; q.objectDeleted = function (u) { this.collection.clearHighlights(u.objectHandle) }; return c
        }()
      })
    }, "esri/views/3d/layers/i3s/I3SAttributeOverrides": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../request ../../../../core/arrayUtils ../../../../core/asyncUtils ../../../../core/byteSizeEstimations ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../intl/number ../../../../layers/support/featureQueryAll".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b) {
          const d = n.getLogger("esri.views.3d.layers.i3s.I3SAttributeOverrides"); n = function () {
            function t(m, e) {
            this.layer = m; this.warnMaximumChangedObjectsExceeded = !1; this.changedObjectIds = new Set; this.pendingFetchAbortController = new AbortController; this.interactiveEditingSessions = null; this._maximumNumberOfEditOVerrides = 5E4; this.memCache = e.newCache(`${m.uid}-attribute-overrides`); this.pendingFetchChangedObjectIds = this.fetchChangedObjectIds(this.pendingFetchAbortController.signal);
              this.pendingFetchChangedObjectIds.then(() => this.pendingFetchAbortController = null)
            } var v = t.prototype; v.destroy = function () { this.layer = null; this.memCache.destroy(); this.memCache = null; this.pendingFetchAbortController && (this.pendingFetchAbortController.abort(), this.pendingFetchAbortController = null); this.pendingFetchChangedObjectIds = null }; v.createInteractiveEditSession = function (m) {
              this.changedObjectIds.add(m); p.isNone(this.interactiveEditingSessions) && (this.interactiveEditingSessions = []); const e = this.interactiveEditingSessions,
                g = new f(m, { rollback: () => { q.remove(e, g); 0 === e.length && (this.interactiveEditingSessions = null) }, commit: x => { for (const [k, r] of x) this.updateValue(m, k, r) } }); e.unshift(g); return g
            }; v.apply = function () {
              var m = w._asyncToGenerator(function* (e, g, x) {
                if (!p.isNone(g)) {
                  var { loadedAttributes: k, attributeData: r } = g; if (!p.isNone(k) && 0 !== k.length && !p.isNone(r) && (yield l.whenOrAbort(this.pendingFetchChangedObjectIds, x), 0 !== this.changedObjectIds.size)) {
                    g = { loadedAttributes: k, attributeData: r }; var A = this.getOverridesFromCache(e,
                      g, this.changedObjectIds), { objectIds: z, fieldNames: B } = A; x = yield this.queryOverridesFromAssociatedLayer(z, B, x); p.isNone(x) || this.processOverridesFromAssociatedLayer(e, x, B, g)
                  }
                }
              }); return function (e, g, x) { return m.apply(this, arguments) }
            }(); v.updateValue = function (m, e, g) { this.changedObjectIds.add(m); this.cacheValue(m, e, g) }; v.cacheValue = function (m, e, g) { this.memCache.put(this.getCacheKey(m, e), g, this.memCacheValueSize(g)) }; v.getOverridesFromCache = function (m, { loadedAttributes: e, attributeData: g }, x) {
              const k = new Set,
              r = []; for (var A of e) r[A.index] = g[A.name]; g = new Set; for (A = 0; A < m.length; A++) { const z = m[A]; if (x.has(z)) for (const B of e) { const C = this.fromCache(z, B.index); void 0 !== C ? r[B.index][A] = C : (k.add(z), g.add(B.name)) } } return { objectIds: Array.from(k), fieldNames: Array.from(g) }
            }; v.fromCache = function (m, e) { const g = this.fromInteractiveEditingSession(m, e); if (void 0 !== g) return g; m = this.getCacheKey(m, e); return this.memCache.get(m) }; v.fromInteractiveEditingSession = function (m, e) {
              if (!p.isNone(this.interactiveEditingSessions)) for (const g of this.interactiveEditingSessions) {
                if (g.objectId !==
                  m) continue; const x = g.get(e); if (void 0 !== x) return x
              }
            }; v.getCacheKey = function (m, e) { return `${m}-${e}` }; v.queryOverridesFromAssociatedLayer = function () {
              var m = w._asyncToGenerator(function* (e, g, x) {
                if (0 === e.length || 0 === g.length) return null; e = e.sort((A, z) => A - z); this.warnMaximumChangedObjectsExceeded && (this.warnMaximumChangedObjectsExceeded = !1, this.logMaximumObjectsExceededWarning()); const k = p.unwrap(this.layer.associatedLayer), r = k.createQuery(); r.where = "1\x3d1"; r.returnGeometry = !1; r.outFields = [k.objectIdField,
                ...g]; r.cacheHint = !0; r.objectIds = e; g = b.getMaximumQuerySize(k); e = e.length > g ? q.splitIntoChunks(e, g).map(A => { const z = r.clone(); z.objectIds = A; return u.resultOrAbort(b.queryAllJSON(k, z, { signal: x })) }) : [u.resultOrAbort(b.queryAllJSON(k, r, { signal: x }))]; return (yield Promise.all(e)).reduce((A, z) => A.concat(z.ok ? z.value.features : []), [])
              }); return function (e, g, x) { return m.apply(this, arguments) }
            }(); v.logMaximumObjectsExceededWarning = function () {
              let m = `The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${h.formatNumber(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;
              const e = this.layer.portalItem; m = e && e.loaded ? m + ` (${e.portal.url}/home/item.html?id=${e.id}#settings)` : m + ` (${this.layer.parsedUrl.path})`; d.warn("#queryOverrides()", this.layer.title, `${m}.`)
            }; v.processOverridesFromAssociatedLayer = function (m, e, g, { loadedAttributes: x, attributeData: k }) {
              const r = p.unwrap(this.layer.associatedLayer).objectIdField, A = g.map(B => k[B]), z = new Map(x.map(B => [B.name, B.index])); x = g.map(B => z.get(B)); m = new Map(Array.from(m, (B, C) => [B, C])); for (const B of e) {
                e = B.attributes[r]; for (let C =
                  0; C < g.length; C++) { const D = x[C], E = m.get(e), H = B.attributes[g[C]]; A[C][E] = H; this.cacheValue(e, D, H) }
              }
            }; v.memCacheValueSize = function (m) { return "string" === typeof m ? y.estimateStringByteSize(m) : y.estimateNumberByteSize() }; v.fetchChangedObjectIds = function () {
              var m = w._asyncToGenerator(function* (e) {
                var g, x, k, r = this.layer; yield r.load({ signal: e }); this.changedObjectIds.clear(); if (!p.isNone(r.associatedLayer) && null != (g = r.associatedLayer.capabilities) && null != (x = g.operations) && x.supportsChangeTracking) {
                  g = this.getFetchChangedObjectIdsServerGen();
                  if (p.isNone(g)) return null; x = r.associatedLayer.layerId; e = yield u.result(c(`${r.associatedLayer.url}/extractChanges`, { method: "post", query: { f: "json", returnIdsOnly: !0, layers: `${x}`, returnUpdates: !0, returnDeletes: !1, returnInserts: !1, layerServerGens: JSON.stringify([{ id: x, serverGen: g }]) }, timeout: 1E4, signal: e })); e = e.ok && null != (k = e.value.data) && k.edits ? p.get(e.value.data.edits[0], "objectIds", "updates") : null; if (p.isSome(e)) for (k = Math.min(this._maximumNumberOfEditOVerrides, e.length), k < e.length && (this.warnMaximumChangedObjectsExceeded =
                    !0), e = e.sort((A, z) => A - z), r = 0; r < k; r++)this.changedObjectIds.add(e[r])
                }
              }); return function (e) { return m.apply(this, arguments) }
            }(); v.getFetchChangedObjectIdsServerGen = function () { var m = this.layer; if (p.isSome(m.serviceUpdateTimeStamp) && p.isSome(m.serviceUpdateTimeStamp.lastUpdate)) return m.serviceUpdateTimeStamp.lastUpdate; m = m.associatedLayer; return p.isSome(m) && p.isSome(m.serverGens) && p.isSome(m.serverGens.minServerGen) ? m.serverGens.minServerGen : null }; w._createClass(t, [{
              key: "test", get: function () {
                const m =
                  this; return { changedObjectIds: Array.from(this.changedObjectIds), pendingFetchChangedObjectIds: this.pendingFetchChangedObjectIds, get maximumNumberOfEditOVerrides() { return m._maximumNumberOfEditOVerrides }, set maximumNumberOfEditOVerrides(e) { m._maximumNumberOfEditOVerrides = e } }
              }
            }]); return t
          }(); let f = function () {
            function t(m, e) { this.objectId = m; this.options = e; this.updates = new Map; this.state = 0 } var v = t.prototype; v.get = function (m) { return this.updates.get(m) }; v.set = function (m, e) {
            this.isActive && this.updates.set(m,
              e)
            }; v.rollback = function () { this.isActive && (this.state = 2, this.options.rollback()) }; v.commit = function () { this.isActive && (this.state = 1, this.options.commit(this.updates), this.updates.clear()) }; w._createClass(t, [{ key: "isActive", get: function () { return 0 === this.state } }]); return t
          }(); a.I3SAttributeOverrides = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/layers/support/featureQueryAll": function () {
      define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/maybe", "../../rest/support/Query"],
        function (a, w, c, q) {
          function u() { u = w._asyncToGenerator(function* (l, h, b) { h = h.clone(); l.capabilities.query.supportsMaxRecordCountFactor && (h.maxRecordCountFactor = p(l)); const d = y(l), f = l.capabilities.query.supportsPagination; h.start = 0; h.num = d; let t = null; for (; ;) { const v = yield l.source.queryFeaturesJSON(h, b); c.isNone(t) ? t = v : t.features = t.features.concat(v.features); t.exceededTransferLimit = v.exceededTransferLimit; if (!f || !v.exceededTransferLimit) break; h.start += d } return t }); return u.apply(this, arguments) } function y(l) {
            return p(l) *
              n(l)
          } function n(l) { return l.capabilities.query.maxRecordCount || 2E3 } function p(l) { return l.capabilities.query.supportsMaxRecordCountFactor ? q.MAX_MAX_RECORD_COUNT_FACTOR : 1 } a.getMaxRecordCountFactor = p; a.getMaximumQuerySize = y; a.getMaximumRecordCount = n; a.queryAllJSON = function (l, h, b) { return u.apply(this, arguments) }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SCrossfadeHelper": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/maybe",
        "../../../../core/scheduling"], function (a, w, c, q) {
          let u = function () {
            function y(p) { this.view = p; this._currentFrameStartTime = this._preRenderFrameTaskHandle = null; this._numFadingNodes = 0 } var n = y.prototype; n.stopNodeFading = function (p) { null != p.lodCrossfadeProgress && (this._numFadingNodes-- , p.lodCrossfadeProgress = null, 0 === this._numFadingNodes && (null != this._preRenderFrameTaskHandle && (this._preRenderFrameTaskHandle = c.removeMaybe(this._preRenderFrameTaskHandle)), this.view.notifyLODUpdate(), this.view.notifyUpdate())) };
            n._startNodeFading = function (p, l, h) { 0 === this._numFadingNodes && (this._preRenderFrameTaskHandle = q.addFrameTask({ preRender: b => this._updateAllNodeFading(b) }), this.view.notifyLODUpdate()); null == p.lodCrossfadeProgress && (this._numFadingNodes++ , this.view.notifyUpdate()); p.lodCrossfadeSignedDuration = h; p.lodCrossfadeProgress = l }; n._updateAllNodeFading = function (p) {
              const l = this.view.nodeCrossfadingEnabled; this.view.foreachCrossfadeNode((h, b) => {
                if (c.isSome(b) && c.isSome(b.lodCrossfadeProgress)) {
                  const d = b.lodCrossfadeSignedDuration,
                  f = b.lodCrossfadeProgress + Math.abs(p.deltaTime / d), t = !l || 1 <= f || 0 === d, v = (0 < d ? this.view.fullOpacity : 0) - (t ? 0 : 0 < d ? 1 : -1) * (1 - f); t ? (this.stopNodeFading(b), 0 > d && this.view.markNodeToRemove(h)) : b.lodCrossfadeProgress = f; this.view.setNodeOpacityByIndex(h, v)
                }
              }); this.view.removeMarkedNodes()
            }; n.stopAllNodeFading = function () {
              this.view.foreachCrossfadeNode((p, l) => {
                c.isSome(l) && c.isSome(l.lodCrossfadeProgress) && (this.stopNodeFading(l), l = l.lodCrossfadeSignedDuration, 0 > l && this.view.markNodeToRemove(p), this.view.setNodeOpacityByIndex(p,
                  0 < l ? this.view.fullOpacity : 0))
              }); this.view.removeMarkedNodes()
            }; n.fadeNode = function (p, l, h, b) {
            null == this._currentFrameStartTime && (this._currentFrameStartTime = Date.now()); var d = this.view; const f = d.nodeCrossfadingEnabled, t = 0 === h ? d.fullOpacity : 0; b = f ? b ? 0 === h ? d.lodCrossfadeinDuration : d.lodCrossfadeoutDuration : d.lodCrossfadeUncoveredDuration : 0; d = this.view.getNodeOpacityByIndex(p); f && d !== t && 0 < b ? this._startNodeFading(l, 1 - Math.abs(t - d), (0 === h ? 1 : -1) * b) : (this.stopNodeFading(l), this.view.setNodeOpacityByIndex(p,
              t), 1 === h && this.view.removeNode(p))
            }; n.isNodeFullyFadedIn = function (p) { const l = this.view.getNodeCrossfadeMetaData(p); return c.isSome(l) && null == l.lodCrossfadeProgress && this.view.getNodeOpacityByIndex(p) === this.view.fullOpacity }; w._createClass(y, [{ key: "updating", get: function () { return 0 < this._numFadingNodes } }]); return y
          }(); a.I3SCrossfadeHelper = u; a.NodeCrossfadeMetaData = function () { this.lodCrossfadeSignedDuration = 0 }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SElevationProvider": function () {
      define("../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/Logger ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/aaBoundingRect ../../webgl-engine/lib/Intersector".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e) {
          const g = m.empty(), x = f.create(), k = v.create(), r = v.create(), A = v.create(), z = u.getLogger("esri.views.3d.layers.i3s.I3SElevationProvider"); c = function (B) {
            function C(E) { E = B.call(this, E) || this; E.tmpEvent = { spatialReference: null, extent: g, context: "scene" }; return E } a._inheritsLoose(C, B); var D = C.prototype; D.initialize = function () {
            this.view = this.layerView.view; this.renderCoordsHelper = this.view.renderCoordsHelper; this.intersector = e.newIntersector(this.view.state.viewingMode);
              this.intersector.options.store = 0; const E = this.layerView.i3slayer.fullExtent; y.isNone(E) ? z.error("I3SElevationProvider expected fullExtent on I3SLayer.") : (this.zmin = E.zmin, this.zmax = E.zmax); this.tmpEvent.context = this.intersectionHandler.isGround ? "ground" : "scene"
            }; D.getElevation = function (E, H, J, M) {
            k[0] = E; k[1] = H; k[2] = J; if (!this.renderCoordsHelper.toRenderCoords(k, M, k)) return z.error("could not project point to compute elevation"), null; E = this.layerView.elevationOffset; H = this.zmin + E; this.renderCoordsHelper.setAltitude(r,
              this.zmax + E, k); this.renderCoordsHelper.setAltitude(A, H, k); this.intersector.reset(r, A, null); this.intersectionHandler.intersect(this.intersector, null, r, A); return this.intersector.results.min.getIntersectionPoint(k) ? this.renderCoordsHelper.getAltitude(k) : null
            }; D.layerChanged = function () { this.spatialReference && (this.tmpEvent.extent = this.computeLayerExtent(), this.tmpEvent.spatialReference = this.spatialReference, this.emit("elevation-change", this.tmpEvent)) }; D.objectChanged = function (E) {
            this.spatialReference &&
              (this.tmpEvent.extent = this.computeObjectExtent(E), this.tmpEvent.spatialReference = this.spatialReference, this.emit("elevation-change", this.tmpEvent))
            }; D.computeObjectExtent = function (E) { m.empty(g); this._expandExtent(E, g); return g }; D.computeLayerExtent = function () { m.empty(g); for (const E of this.layerView.getVisibleNodes()) this._expandExtent(E, g); return g }; D._expandExtent = function (E, H) {
              var J = E.visibilityObb || E.serviceObbInRenderSR; if (y.isSome(J)) for (d.fromQuat(x, J.quaternion), x[12] = J.center[0], x[13] = J.center[1],
                x[14] = J.center[2], E = 0; 8 > E; ++E)k[0] = E & 1 ? J.halfSize[0] : -J.halfSize[0], k[1] = E & 2 ? J.halfSize[1] : -J.halfSize[1], k[2] = E & 4 ? J.halfSize[2] : -J.halfSize[2], t.transformMat4(k, k, x), this.renderCoordsHelper.fromRenderCoords(k, k, this.spatialReference), m.expand(H, k, H); else {
                  var M = E.renderMbs[3]; J = t.copy(r, E.renderMbs); J[0] -= M; J[1] -= M; J[2] -= M; E = t.copy(A, E.renderMbs); E[0] += M; E[1] += M; E[2] += M; for (M = 0; 8 > M; ++M)k[0] = M & 1 ? J[0] : E[0], k[1] = M & 2 ? J[1] : E[1], k[2] = M & 4 ? J[2] : E[2], this.renderCoordsHelper.fromRenderCoords(k, k, this.spatialReference),
                    m.expand(H, k, H)
              }
            }; return C
          }(q.EventedMixin(c)); w.__decorate([n.property({ constructOnly: !0 })], c.prototype, "layerView", void 0); w.__decorate([n.property({ constructOnly: !0 })], c.prototype, "intersectionHandler", void 0); w.__decorate([n.property()], c.prototype, "view", void 0); w.__decorate([n.property({ readOnly: !0, aliasOf: "view.elevationProvider.spatialReference" })], c.prototype, "spatialReference", void 0); return c = w.__decorate([b.subclass("esri.views.3d.layers.i3s.I3SElevationProvider")], c)
        })
    }, "esri/views/3d/layers/i3s/I3SIntersectionHandler": function () {
      define(["exports",
        "../../../../core/maybe", "../../support/orientedBoundingBox", "../../webgl-engine/lib/Intersector", "../../webgl-engine/lib/verticalOffsetUtils"], function (a, w, c, q, u) {
          function y(p, l, h, b = 0) { b = p[3] + b; const d = l[0] - p[0], f = l[1] - p[1]; p = l[2] - p[2]; l = h[0]; const t = h[1]; h = h[2]; const v = l * d + t * f + h * p; return 0 <= v * v - (l * l + t * t + h * h) * (d * d + f * f + p * p - b * b) } let n = function () {
            function p(l) {
            this.type = 4; this.layerUid = l.layerUid; this.sublayerUid = l.sublayerUid; this.collection = l.collection; this.traverseNodeHierarchy = l.traverseNodeHierarchy;
              this.slicePlaneEnabled = l.slicePlaneEnabled; this.isGround = l.isGround
            } p.prototype.intersect = function (l, h, b, d) {
              const f = l.results, t = 2 === l.options.store, v = l.ray.direction, m = l.tolerance; let e = k => k, g = k => k; const x = u.getVerticalOffsetI3S(l.verticalOffset); w.isSome(x) && (e = k => x.applyToMbs(k), g = k => x.applyToObb(k)); this.traverseNodeHierarchy((k, r) => {
                if (w.isSome(k.serviceObbInRenderSR) && !c.intersectLine(g(k.serviceObbInRenderSR), b, v, m)) return !1; !r || w.isSome(k.geometryObb) && !c.intersectLine(g(k.geometryObb), b, v,
                  m) || !w.isSome(k.serviceObbInRenderSR) && !y(e(k.renderMbs), b, v, m) || this.collection.intersect(r, b, d, m, x, (A, z, B, C) => {
                    if (0 <= z && (null == h || h(b, d, z))) {
                      var D = E => { E.set(this.type, { layerUid: this.layerUid, sublayerUid: this.sublayerUid, nodeIndex: k.index, componentIndex: A, triangleNr: C }, z, B) }; this.isGround && (null == f.ground.dist || z < f.ground.dist) && D(f.ground); if (!l.options.isFiltered && ((null == f.min.dist || z < f.min.dist) && D(f.min), (null == f.max.dist || z > f.max.dist) && D(f.max), t)) {
                        const E = q.newIntersectorResult(l.ray); D(E);
                        l.results.all.push(E)
                      }
                    }
                  }); return !0
              })
            }; return p
          }(); a.I3SIntersectionHandler = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/IDBCache": function () {
      define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "../../../../core/Error", "../../../../core/maybe", "../../../../core/promiseUtils"], function (a, w, c, q, u) {
        function y(l) { return new Promise((h, b) => { l.oncomplete = () => h(); l.onerror = () => b(l.error); l.onabort = () => b(l.error) }) } function n(l) {
          return new Promise((h, b) => {
            "done" ===
            l.readyState ? null != l.error ? b(l.error) : h(l.result) : (l.onsuccess = () => h(l.result), l.onerror = () => b(l.error))
          })
        } let p = function () {
          function l(b, d, f = 14) { this._version = f; this._quotaReductionPromise = this._db = null; this._miss = this._hit = this._gcCounter = 0; this._destroyed = !1; this.gcFrequency = 50; this.maxByteSize = 1073741824; this.quotaReductionFactor = .2; this._dbName = b; this._storeName = d } var h = l.prototype; h.init = function () {
            return Promise.resolve().then(() => {
              const b = indexedDB.open(this._dbName, this._version); b.onupgradeneeded =
                d => { var f = b.result; const t = b.transaction, v = f.objectStoreNames.contains(this._storeName) ? t.objectStore(this._storeName) : f.createObjectStore(this._storeName); f = f.objectStoreNames.contains("last_access") ? t.objectStore("last_access") : f.createObjectStore("last_access"); f.indexNames.contains("date") || f.createIndex("date", "date", { unique: !1 }); f.indexNames.contains("byteSize") || f.createIndex("byteSize", "byteSize", { unique: !1 }); d.oldVersion < this._version && (v.clear(), f.clear()) }; return n(b)
            }).then(b => {
              this._destroyed ?
              b.close() : this._db = b
            })
          }; h.destroy = function () { this._db && (this._db.close(), this._db = null); this._destroyed = !0 }; h.getHitRate = function () { return this._hit / (this._hit + this._miss) }; h.put = function (b, d) {
            return null == this._db ? Promise.reject(new c("indexedb:not-initialized", "IndexedDB Cache is not initialized")) : (null != this._quotaReductionPromise ? this._quotaReductionPromise : Promise.resolve()).then(() => this._put(b, d)).catch(f => {
              if (f && "QuotaExceededError" === f.name) return null == this._quotaReductionPromise && (this._quotaReductionPromise =
                this._getCacheSize().then(t => this._removeLeastRecentlyAccessed(d.byteSize + Math.ceil(t * this.quotaReductionFactor))), this._quotaReductionPromise.then(() => this._quotaReductionPromise = null, () => this._quotaReductionPromise = null)), this._quotaReductionPromise.then(() => this._put(b, d)); throw f;
            }).then(() => { this._gcCounter--; 0 > this._gcCounter && null != this._db && (this._gcCounter = this.gcFrequency, this._getCacheSize().then(f => this._removeLeastRecentlyAccessed(f - this.maxByteSize))) })
          }; h.get = function (b, d) {
            if (null ==
              this._db) return Promise.resolve(null); let f = null; return Promise.resolve().then(() => { const t = this._db.transaction(this._storeName, "readonly"); f = u.onAbort(d, () => { t.abort() }); const v = t.objectStore(this._storeName).get(b); return n(v) }).then(t => { null == t ? ++this._miss : this._db && (++this._hit, this._db.transaction("last_access", "readwrite").objectStore("last_access").put({ date: Date.now(), byteSize: t.byteSize }, b)); q.isSome(f) && f.remove(); return t }).catch(() => {
                ++this._miss; u.throwIfAborted(d); q.isSome(f) && f.remove();
                return null
              })
          }; h.remove = function (b) { var d = this; return null == this._db ? Promise.resolve() : Promise.resolve().then(w._asyncToGenerator(function* () { const f = d._db.transaction([d._storeName, "last_access"], "readwrite"); var t = f.objectStore(d._storeName), v = f.objectStore("last_access"); t = t.delete(b); v = v.delete(b); yield Promise.all([n(t), n(v), y(f)]) })) }; h._put = function (b, d) {
            const f = this._db.transaction([this._storeName, "last_access"], "readwrite"); var t = f.objectStore(this._storeName); const v = f.objectStore("last_access");
            t = t.put(d, b); b = v.put({ date: Date.now(), byteSize: d.byteSize }, b); return Promise.all([n(t), n(b), y(f)])
          }; h._removeLeastRecentlyAccessed = function (b) { if (!(0 >= b)) { var d = this._db.transaction([this._storeName, "last_access"], "readwrite"), f = d.objectStore(this._storeName), t = d.objectStore("last_access"), v = 0, m = t.index("date").openCursor(null, "next"); m.onsuccess = () => { const e = m.result; null != e && (null != e.value.byteSize && (v += e.value.byteSize), f.delete(e.primaryKey), t.delete(e.primaryKey), v < b && e.continue()) }; return y(d) } };
          h._getCacheSize = function () { const b = this._db.transaction("last_access"); let d = 0; const f = b.objectStore("last_access").index("byteSize").openKeyCursor(); f.onsuccess = () => { const t = f.result; if (t) { var v = t.key; null != v && (d += v); t.continue() } }; return y(b).then(() => d) }; w._createClass(l, [{ key: "initialized", get: function () { return null != this._db } }]); return l
        }(); a.IDBCache = p; a.whenRequest = n; a.whenTransaction = y; Object.defineProperty(a, "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/i3s/attributeEditing": function () {
      define(["exports",
        "../../../../core/lang", "../../../../core/maybe", "../support/attributeUtils"], function (a, w, c, q) {
          function u(h, b) {
            const d = b.edits.updateFeatures; if (!d || 0 === d.length) return new l; const f = y(b), t = new l; b = new Map; for (let g = 0; g < h.attributeStorageInfo.length; g++)b.set(h.attributeStorageInfo[g].name, g); const v = h.fieldsIndex, m = h.objectIdField, e = d.filter(g => { g = q.attributeLookup(v, g.attributes, m); return f.has(g) }); h.forEachNode((g, x) => {
              const k = new Set(x); for (const C of e) {
                const D = q.attributeLookup(v, C.attributes,
                  m); if (!k.has(D)) continue; const E = x.indexOf(D); for (const H in C.attributes) { var r = h.fieldsIndex.normalizeFieldName(H); var A = t; var z = g.index, B = A.get(z); B ? A = B : (B = new p, A.set(z, B), A = B); (z = A.get(r)) ? r = z : (z = [], A.set(r, z), r = z); r.push({ featureIndex: E, featureId: D, value: C.attributes[H] }) }
              }
            }); return t
          } function y(h) { const b = new Set; if (!h.updatedFeatures) return b; for (const d of h.updatedFeatures) null != d.objectId && null == d.error && b.add(d.objectId); return b } const n = { setAttribute() { }, rollback() { }, commit() { } }, p = Map,
            l = Map; a.createInteractiveEditSession = function (h, b) {
              const d = b.attributes[h.objectIdField]; var f = h.sessions.get(d); if (f) return f; const t = w.clone(b.attributes), v = new Set; if (null == d) return n; const m = h.attributeOverrides.createInteractiveEditSession(d), e = new Map; let g = 0; f = {
                setAttribute(x, k) {
                  if (0 === g) {
                    var r = h.fieldsIndex.get(x); if (!c.isNone(r)) {
                      var A = h.attributeStorageInfo.findIndex(C => C.name === r.name); if (!(0 > A)) {
                        m.set(A, k); var z = h.attributeStorageInfo[A], B = !1; v.add(x); h.forEachNode((C, D) => {
                          var E = e.get(C);
                          null == E ? (D = D.indexOf(d), e.set(C, D)) : D = E; if (-1 !== D && (E = h.getAttributeData(C.index))) { const H = E[z.name]; H && (H[D] = k, h.setAttributeData(C.index, E, b), B = !0) }
                        }); B && h.clearMemCache()
                      }
                    }
                  }
                }, rollback() { if (0 === g) { for (const x of v) this.setAttribute(x, t[x]); m.rollback(); g = 1; h.sessions.delete(d) } }, commit() { 0 === g && (m.commit(), g = 2, h.sessions.delete(d)) }
              }; h.sessions.set(d, f); return f
            }; a.processAttributeEdits = function (h, b) {
              b = u(h, b); if (0 !== b.size) {
                var d = new Map; for (let t = 0; t < h.attributeStorageInfo.length; t++)d.set(h.attributeStorageInfo[t].name,
                  t); var f = !1; b.forEach((t, v) => { const m = h.getAttributeData(v); let e = !1; t.forEach((g, x) => { const k = c.isSome(m) ? m[x] : null; x = d.get(x); for (const { featureIndex: r, value: A, featureId: z } of g) k && (k[r] = A, f = e = !0), h.attributeOverrides.updateValue(z, x, A) }); e && h.setAttributeData(v, m, null) }); f && h.clearMemCache()
              }
            }; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SMeshViewFilter": function () {
      define("require exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../geometry ../../../../core/Accessor ../../../../core/arrayUtils ../../../../core/Logger ../../../../core/maybe ../../../../core/unitUtils ../../../../core/watchUtils ../../../../core/accessorSupport/decorators/property ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../core/sql/WhereClause ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/webMercatorUtils ../../../../layers/support/FeatureFilter ./I3SUtil ../../../../geometry/SpatialReference".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B) {
          function C() { return D.apply(this, arguments) } function D() { D = c._asyncToGenerator(function* () { return I ? I : I = yield new Promise((T, da) => a(["../../../../geometry/geometryEngine"], T, da)) }); return D.apply(this, arguments) } function E(T, da) {
            if (l.isNone(T)) return null; if ("disjoint" === da && "polygon" === T.type) {
              const fa = Array(T.rings.length); for (da = 0; da < T.rings.length; ++da) {
                var Y = k.fromValues(Infinity, Infinity, -Infinity, -Infinity); k.expandWithNestedArray(Y,
                  T.rings[da]); fa[da] = { type: "polygon", rings: [T.rings[da]], spatialReference: T.spatialReference, aabr: Y }
              } fa.sort((ea, ba) => ea.aabr[0] - ba.aabr[0]); const ha = new Set, ka = new n.PositionHint; for (T = 0; T < fa.length; ++T) {
                const ea = fa[T]; for (da = T + 1; da < fa.length; ++da) { Y = fa[da]; if (Y.aabr[0] >= ea.aabr[2]) break; ha.add(Y) } ha.forEach(ba => {
                ea !== ba && (ba.aabr[2] <= ea.aabr[0] ? ha.delete(ba) : I.intersects(ea, ba) && (ea.rings = ea.rings.concat(ba.rings), k.expand(ea.aabr, ba.aabr, ea.aabr), delete ea._geVersion, ha.delete(ba), ba = n.indexOf(fa,
                  ba, fa.length, ka), fa.splice(ba, 1)))
                }); ha.add(ea)
              } for (const ea of fa) delete ea.aabr; return fa
            } return [T]
          } function H(T, da, Y, fa) { const ha = F(T, Y); return da.every(ka => 1 !== K(ka, ha, fa)) } function J(T, da, Y, fa, ha, ka, ea) { const ba = ka[0].spatialReference || fa.spatialReference; if (g.projectBoundingSphere(da.node.mbs, ha, R, ba)) { ha = F(R, ba); var aa = M(ea, fa, ba, Y, da.objectHandle); for (const W of ka) { if (0 === T.length) break; switch (K(W, ha, ea)) { case 1: T.length = 0; return; case 0: continue }z.filterInPlace(T, da.featureIds, U => N(W, U, aa)) } } else G.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter") }
          function M(T, da, Y, fa, ha) {
            da = da.renderSpatialReference; const ka = new Map, ea = { rings: [[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]], hasZ: !1, hasM: !1, type: "polygon", spatialReference: Y }; ea.rings[0][3] = ea.rings[0][0]; let ba, aa; switch (T) { case "intersects": ba = (W, U) => I.intersects(W, U) ? 0 : 2; aa = P; break; case "contains": ba = (W, U) => I.contains(W, U) ? 2 : 1; aa = P; break; default: ba = (W, U) => I.disjoint(W, U) ? 2 : 1, aa = L }return {
              collection: fa, object: ha, type: T, maskSR: Y, renderSR: da, aabbCache: ka, triangle: ea, positions: {
                indices: null, data: null, stride: 0,
                startIndex: 0, endIndex: 0
              }, triangleTest: ba, geometryTest: aa
            }
          } function F(T, da) { const Y = { x: T[0], y: T[1], hasZ: !1, hasM: !1, type: "point", spatialReference: da }; T = da.isWGS84 || da.isWebMercator ? I.geodesicBuffer(Y, T[3], 1) : I.buffer(Y, T[3], 1); T.type = "polygon"; return T } function K(T, da, Y) { switch (Y) { case "intersects": case "contains": return P(T, da); case "disjoint": return L(T, da) } } function P(T, da) { return I.intersects(T, da) ? I.contains(T, da) ? 0 : 2 : 1 } function L(T, da) { return I.intersects(T, da) ? I.contains(T, da) ? 1 : 2 : 0 } function N(T,
            da, Y) {
              const { collection: fa, object: ha, renderSR: ka, maskSR: ea, geometryTest: ba, aabbCache: aa } = Y; var W = aa.get(da); if (!W) { W = fa.getObjectTransform(ha); fa.getComponentAabb(ha, da, Q); var U = [[Q[0], Q[1], 0], [Q[0], Q[4], 0], [Q[3], Q[4], 0], [Q[3], Q[1], 0]]; for (var X = 0; 4 > X; ++X)m.transformMat3(U[X], U[X], W.rotationScale), m.add(U[X], U[X], W.position), g.projectVectorToVector(U[X], ka, U[X], ea); W = { rings: [U], hasZ: !1, hasM: !1, type: "polygon", spatialReference: ea }; W.rings[0][4] = W.rings[0][0]; aa.set(da, W) } switch (ba(T, W)) {
                case 1: return !1;
                case 0: return !0
              }const { triangle: Z, triangleTest: ia, positions: la } = Y; W = Z.rings[0][0]; U = Z.rings[0][1]; X = Z.rings[0][2]; const ma = fa.getObjectTransform(ha); fa.getComponentPositions(ha, da, la); const { indices: ra, data: Aa, stride: za, startIndex: Ka, endIndex: Ea } = la; for (da = Ka; da < Ea; da += 3) {
                const Ua = za * ra[da + 0], Na = za * ra[da + 1], ya = za * ra[da + 2]; m.set(W, Aa[Ua + 0], Aa[Ua + 1], Aa[Ua + 2]); m.set(U, Aa[Na + 0], Aa[Na + 1], Aa[Na + 2]); m.set(X, Aa[ya + 0], Aa[ya + 1], Aa[ya + 2]); m.transformMat3(W, W, ma.rotationScale); m.transformMat3(U, U, ma.rotationScale);
                m.transformMat3(X, X, ma.rotationScale); m.add(W, W, ma.position); m.add(U, U, ma.position); m.add(X, X, ma.position); g.projectVectorToVector(W, ka, W, ea); g.projectVectorToVector(U, ka, U, ea); g.projectVectorToVector(X, ka, X, ea); if (!(Math.abs((U[0] - W[0]) * (X[1] - W[1]) - (U[1] - W[1]) * (X[0] - W[0])) < S)) switch (delete Z._geVersion, ia(T, Z)) { case 1: return !1; case 0: return !0 }
              } switch (Y.type) { case "intersects": return !1; default: return !0 }
          } const G = p.getLogger("esri.views.3d.layers.i3s.I3SMeshViewFilter"); w.I3SMeshViewFilter = function (T) {
            function da(fa) {
              fa =
              T.call(this, fa) || this; fa._projectionEngineLoaded = !1; return fa
            } c._inheritsLoose(da, T); var Y = da.prototype; Y.initialize = function () { b.whenOnce(this, "filter.geometry").then(() => this.loadAsyncModule(C().then(fa => { this.destroyed || (this._geometryEngine = fa, this.applyFilters()) }))) }; Y.addFilters = function (fa, ha, ka, ea) {
              const ba = this.sortedObjectIds; l.isSome(ba) && fa.push(W => z.objectIdFilter(ba, !0, W)); this.addSqlFilter(fa, this.parsedWhereClause); const aa = this.parsedGeometry; if (l.isSome(aa)) {
                const W = this.spatialRelationship;
                fa.push((U, X) => J(U, X, ea, ha, ka, aa, W))
              }
            }; Y.isMBSGeoemtryVisible = function (fa, ha, ka) { const ea = this.parsedGeometry; if (l.isSome(ea)) { const ba = this.spatialRelationship; ha = ea[0].spatialReference || ha; return g.projectBoundingSphere(fa, ka, R, ha) ? H(R, ea, ha, ba) : (G.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"), !0) } return !0 }; da.checkSupport = function (fa) {
              if (fa.timeExtent) return G.warn("Filters with a timeExtent are not supported for mesh scene layers"),
                !1; fa = fa.spatialRelationship; return null != fa && 0 <= O.indexOf(fa) ? !0 : (G.warn(`Filters with spatialRelationship other than ${O.join(", ")} are not supported for mesh scene layers`), !1)
            }; c._createClass(da, [{ key: "sortedObjectIds", get: function () { if (l.isNone(this.filter.objectIds)) return null; const fa = new Float64Array(this.filter.objectIds); fa.sort(); return fa } }, {
              key: "parsedWhereClause", get: function () {
                const fa = l.isSome(this.filter) ? this.filter.where : null; if (l.isNone(fa) || !fa) return null; try {
                  return e.WhereClause.create(fa,
                    this.layerFieldsIndex)
                } catch (ha) { G.error(`Failed to parse filter where clause: ${ha}`) } return null
              }
            }, {
              key: "parsedGeometry", get: function () {
                if (l.isNone(this.filter) || !this._geometryEngine) return null; var { geometry: fa } = this.filter; if (l.isNone(fa)) return null; const { distance: ha, units: ka } = this.filter, ea = this.spatialRelationship; fa = "mesh" === fa.type ? fa.extent : fa; if (l.isNone(ha) || 0 === ha) return E(fa, ea); const ba = ka || h.getUnitString(fa.spatialReference); if (fa.spatialReference.isWGS84) return fa = this._geometryEngine.geodesicBuffer(fa,
                  ha, ba), E(fa, ea); var aa = r.project(fa, B.WGS84); if (l.isSome(aa)) return fa = r.project(this._geometryEngine.geodesicBuffer(aa, ha, ba), fa.spatialReference), E(fa, ea); if (!this._projectionEngineLoaded && (this.loadAsyncModule(g.load().then(() => this._projectionEngineLoaded = !0)), !this._projectionEngineLoaded)) return null; aa = null; try { aa = g.project(fa, B.WGS84) } catch (W) { } if (aa) try { aa = g.project(this._geometryEngine.geodesicBuffer(aa, ha, ba), fa.spatialReference) } catch (W) { aa = null } aa || G.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${fa.spatialReference.wkid}) to WGS84.`);
                return E(aa, ea)
              }
            }, { key: "spatialRelationship", get: function () { return l.isSome(this.filter) ? this.filter.spatialRelationship : "intersects" } }]); return da
          }(y); q.__decorate([d.property({ type: A })], w.I3SMeshViewFilter.prototype, "filter", void 0); q.__decorate([d.property()], w.I3SMeshViewFilter.prototype, "layerFieldsIndex", void 0); q.__decorate([d.property()], w.I3SMeshViewFilter.prototype, "loadAsyncModule", void 0); q.__decorate([d.property()], w.I3SMeshViewFilter.prototype, "applyFilters", void 0); q.__decorate([d.property()],
            w.I3SMeshViewFilter.prototype, "addSqlFilter", void 0); q.__decorate([d.property({ readOnly: !0 })], w.I3SMeshViewFilter.prototype, "sortedObjectIds", null); q.__decorate([d.property({ readOnly: !0 })], w.I3SMeshViewFilter.prototype, "parsedWhereClause", null); q.__decorate([d.property({ readOnly: !0 })], w.I3SMeshViewFilter.prototype, "parsedGeometry", null); q.__decorate([d.property({ readOnly: !0 })], w.I3SMeshViewFilter.prototype, "spatialRelationship", null); q.__decorate([d.property()], w.I3SMeshViewFilter.prototype, "_projectionEngineLoaded",
              void 0); q.__decorate([d.property()], w.I3SMeshViewFilter.prototype, "_geometryEngine", void 0); w.I3SMeshViewFilter = q.__decorate([v.subclass("esri.views.3d.layers.i3s.I3SMeshViewFilter")], w.I3SMeshViewFilter); let I; const O = ["contains", "intersects", "disjoint"], R = [0, 0, 0, 0], S = 2 ** -32, Q = x.create(); Object.defineProperty(w, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SQueryEngine": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Error ../../../../core/Handles ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../geometry/Extent ../../../../layers/graphics/data/QueryEngine ../../../../rest/support/FeatureSet ../../../../rest/support/Query".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m) {
          const e = t.default; a.I3SQueryEngine = function (g) {
            function x(r) { r = g.call(this, r) || this; r._dataQueryEngineInstance = null; r._handles = new y; return r } w._inheritsLoose(x, g); var k = x.prototype; k.initialize = function () { this._handles.add(this.layerView.on("visible-geometry-changed", () => this.spatialIndex.events.emit("changed"))) }; k.destroy = function () {
            this._dataQueryEngineInstance && (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null); this._handles &&
              (this._handles.destroy(), this._handles = null); this._set("layerView", null)
            }; k.executeQueryForCount = function () { var r = w._asyncToGenerator(function* (A, z) { return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(A), z) }); return function (A, z) { return r.apply(this, arguments) } }(); k.executeQueryForExtent = function () {
              var r = w._asyncToGenerator(function* (A, z) { const { count: B, extent: C } = yield this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(A), z); A = f.fromJSON(C); return { count: B, extent: A } });
              return function (A, z) { return r.apply(this, arguments) }
            }(); k.executeQueryForIds = function () { var r = w._asyncToGenerator(function* (A, z) { return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(A), z) }); return function (A, z) { return r.apply(this, arguments) } }(); k.executeQuery = function () {
              var r = w._asyncToGenerator(function* (A, z) {
                A = this._ensureQueryJSON(A); if (A.returnGeometry) throw new u("feature-store:unsupported-query", "returnGeometry is not yet supported for mesh scene layer queries"); if (A.returnCentroid) throw new u("feature-store:unsupported-query",
                  "returnCentroid is not yet supported for mesh scene layer queries"); z = yield this.dataQueryEngine.executeQuery(A, z); z = v.fromJSON(z); z.features.forEach(B => { B.geometry = null }); return z
              }); return function (A, z) { return r.apply(this, arguments) }
            }(); k._ensureQueryJSON = function (r) { if (n.isNone(r)) return this.defaultQueryJSON; const A = r.toJSON(); A.outSpatialReference || (r.outSpatialReference = this.spatialReference); return A }; k.ensureDataQueryEngine = function () {
              if (this._dataQueryEngineInstance) return this._dataQueryEngineInstance;
              const r = this.layer.objectIdField || "OBJECTID", A = this.layer.fields.map(C => C.toJSON()), z = this.layerView.view.resourceController.scheduler, B = this.spatialReference.toJSON(); return this._dataQueryEngineInstance = new e({ hasZ: !0, hasM: !1, geometryType: "esriGeometryPolygon", fields: A, timeInfo: null, spatialReference: B, objectIdField: r, featureStore: this.spatialIndex, scheduler: z, priority: this.priority })
            }; w._createClass(x, [{ key: "defaultQueryJSON", get: function () { return (new m({ outSpatialReference: this.spatialReference })).toJSON() } },
            { key: "dataQueryEngine", get: function () { return this.ensureDataQueryEngine() } }]); return x
          }(q); c.__decorate([p.property({ constructOnly: !0 })], a.I3SQueryEngine.prototype, "layerView", void 0); c.__decorate([p.property({ constructOnly: !0 })], a.I3SQueryEngine.prototype, "priority", void 0); c.__decorate([p.property({ constructOnly: !0 })], a.I3SQueryEngine.prototype, "spatialIndex", void 0); c.__decorate([p.property({ readOnly: !0, aliasOf: "layerView.view.spatialReference" })], a.I3SQueryEngine.prototype, "spatialReference",
            void 0); c.__decorate([p.property({ readOnly: !0, aliasOf: "layerView.i3slayer" })], a.I3SQueryEngine.prototype, "layer", void 0); c.__decorate([p.property({ readOnly: !0 })], a.I3SQueryEngine.prototype, "defaultQueryJSON", null); a.I3SQueryEngine = c.__decorate([d.subclass("esri.views.3d.layers.i3s.I3SQueryEngine")], a.I3SQueryEngine); a.default = a.I3SQueryEngine; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SQueryFeatureAdapter": function () {
      define("exports ../../../../core/maybe ../../../../geometry/support/aaBoundingBox ../../../../layers/graphics/centroid ../../../../layers/graphics/OptimizedGeometry ./I3SUtil".split(" "),
        function (a, w, c, q, u, y) {
          let n = function () {
            function l(b) { this.objectIdField = b.objectIdField; this.getFeatureExtent = b.getFeatureExtent } var h = l.prototype; h.getObjectId = function (b) { return b.id }; h.getAttributes = function (b) { const { meta: d, index: f } = b, t = {}; this.objectIdField && (t[this.objectIdField] = b.id); b = w.isSome(d.attributeInfo) && d.attributeInfo.attributeData; if (w.isSome(b)) for (const v of Object.keys(b)) t[v] = y.getCachedAttributeValue(b[v], f); return t }; h.getAttribute = function (b, d) {
              if (d === this.objectIdField) return b.id;
              const { meta: f, index: t } = b; b = w.isSome(f.attributeInfo) && f.attributeInfo.attributeData; return w.isSome(b) ? y.getCachedAttributeValue(b[d], t) : null
            }; h.getGeometry = function (b) { if (b.geometry) return b.geometry; const [d, f, t, v, m] = this.getFeatureExtent(b, p); return new u([5], [d, f, t, v, f, t, v, m, t, d, m, t, d, f, t]) }; h.getCentroid = function (b, d) { if (b.geometry) return q.getCentroidOptimizedGeometry(new u, b.geometry, d.hasZ, d.hasM); const [f, t, v, m, e, g] = this.getFeatureExtent(b, p); return new u([0], [(f + m) / 2, (t + e) / 2, (v + g) / 2]) };
            h.cloneWithGeometry = function (b, d) { const { id: f, index: t, meta: v } = b; return { id: f, index: t, meta: v, geometry: d } }; return l
          }(); const p = c.create(); a.I3SQueryFeatureAdapter = n; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/i3s/I3SQueryFeatureStore": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Accessor ../../../../core/Evented ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/aaBoundingRect".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t) {
        a.I3SQueryFeatureStore = function (g) {
          function x(r) { r = g.call(this, r) || this; r.events = new u; return r } w._inheritsLoose(x, g); var k = x.prototype; k.forEach = function (r) { this.forAllFeatures(A => { r(A); return 1 }) }; k.forEachBounds = function (r, A, z) { const B = this.getFeatureExtent; for (const C of r) A(B(C, z)) }; k.forEachInBounds = function (r, A) {
            this.forAllFeatures(z => { const B = this.getFeatureExtent(z, m); t.intersects(r, f.toRect(B, e)) && A(z); return 1 }, z => {
              d.projectBoundingSphere(z.node.mbs,
                this.sourceSpatialReference, v, this.viewSpatialReference); if (v[0] >= r[0] && v[2] <= r[2] && v[1] >= r[1] && v[3] <= r[3]) return 1; z = v[0] - Math.max(r[0], Math.min(v[0], r[2])); const B = v[1] - Math.max(r[1], Math.min(v[1], r[3])); return z * z + B * B <= v[3] * v[3] ? 1 : 2
            })
          }; return x
        }(q); c.__decorate([y.property({ constructOnly: !0 })], a.I3SQueryFeatureStore.prototype, "featureAdapter", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.I3SQueryFeatureStore.prototype, "forAllFeatures", void 0); c.__decorate([y.property({ constructOnly: !0 })],
          a.I3SQueryFeatureStore.prototype, "getFeatureExtent", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.I3SQueryFeatureStore.prototype, "sourceSpatialReference", void 0); c.__decorate([y.property({ constructOnly: !0 })], a.I3SQueryFeatureStore.prototype, "viewSpatialReference", void 0); a.I3SQueryFeatureStore = c.__decorate([h.subclass("esri.views.3d.layers.i3s.I3SQueryFeatureStore")], a.I3SQueryFeatureStore); const v = b.create(), m = f.create(), e = t.create(); a.default = a.I3SQueryFeatureStore; Object.defineProperty(a,
            "__esModule", { value: !0 })
        })
    }, "esri/views/3d/layers/support/DefinitionExpressionSceneLayerView": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Logger ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../core/sql/WhereClause ../i3s/I3SUtil".split(" "), function (a, w, c, q, u, y, n,
        p, l, h, b) {
          const d = q.getLogger("esri.views.3d.layers.support.DefinitionExpressionSceneLayerView"); a.DefinitionExpressionSceneLayerView = f => {
            f = function (t) {
              function v() {
                var e = t.apply(this, arguments) || this; e._definitionExpressionErrors = 0; e._maxDefinitionExpressionErrors = 20; e.logError = g => {
                e._definitionExpressionErrors < e._maxDefinitionExpressionErrors && d.error("Error while evaluating definitionExpression: " + g); e._definitionExpressionErrors++; e._definitionExpressionErrors === e._maxDefinitionExpressionErrors &&
                  d.error("Further errors are ignored")
                }; return e
              } w._inheritsLoose(v, t); var m = v.prototype; m._evaluateClause = function (e, g) { try { return e.testFeature(g) } catch (x) { return this.logError(x), !1 } }; m._addDefinitionExpressionToQuery = function (e) { if (!this.parsedDefinitionExpression) return e; const g = this.i3slayer.definitionExpression; e = e.clone(); e.where = e.where ? `(${g}) AND (${e.where})` : g; return e }; w._createClass(v, [{
                key: "parsedDefinitionExpression", get: function () {
                  if (!this.i3slayer || !this.i3slayer.definitionExpression) return null;
                  try { const e = h.WhereClause.create(this.i3slayer.definitionExpression, this.i3slayer.fieldsIndex); if (!e.isStandardized) return d.error("definitionExpression is using non standard function"), null; const g = []; b.findFieldsCaseInsensitive(e.fieldNames, this.i3slayer.fields, { missingFields: g }); if (0 < g.length) return d.error(`definitionExpression references unknown fields: ${g.join(", ")}`), null; this._definitionExpressionErrors = 0; return e } catch (e) { return d.error("Failed to parse definitionExpression: " + e), null }
                }
              },
              { key: "definitionExpressionFields", get: function () { return this.parsedDefinitionExpression ? this.parsedDefinitionExpression.fieldNames : null } }]); return v
            }(f); c.__decorate([u.property()], f.prototype, "i3slayer", void 0); c.__decorate([u.property({ readOnly: !0 })], f.prototype, "parsedDefinitionExpression", null); c.__decorate([u.property({ readOnly: !0 })], f.prototype, "definitionExpressionFields", null); return f = c.__decorate([l.subclass("esri.views.3d.layers.support.DefinitionExpressionSceneLayerView")], f)
          }; Object.defineProperty(a,
            "__esModule", { value: !0 })
      })
    }, "esri/views/3d/layers/support/fieldProperties": function () { define(["exports", "../../../../layers/support/fieldUtils"], function (a, w) { a.defineFieldProperties = function () { return { requiredFields: { type: [String], readOnly: !0 }, availableFields: { type: [String], readOnly: !0, get: function () { const { layer: c, layer: { fieldsIndex: q }, requiredFields: u } = this; return c.outFields ? w.fixFields(q, [...w.unpackFieldNames(q, c.outFields), ...u]) : w.fixFields(q, u) } } } }; Object.defineProperty(a, "__esModule", { value: !0 }) }) },
    "esri/views/3d/layers/support/SceneLayerViewRequiredFields": function () {
      define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/AsyncUpdate ../../../../core/HandleOwner ../../../../core/Logger ../../../../core/maybe ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/has ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../layers/support/fieldUtils".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f) {
          function t(e) { return v.apply(this, arguments) } function v() { v = w._asyncToGenerator(function* (e) { const g = new Set; try { return yield e(g), Array.from(g).sort() } catch (x) { return m.error(x), null } }); return v.apply(this, arguments) } const m = y.getLogger("esri.views.3d.layers.support.SceneLayerViewRequiredFields"); a.SceneLayerViewRequiredFields = function (e) {
            function g(x) { return e.call(this, x) || this } w._inheritsLoose(g, e); g.prototype.initialize = function () {
            this.layer = this.layerView.layer;
              this.handles.add([this.autoUpdateAsync("rendererFields", () => { const { fieldsIndex: x, renderer: k } = this.layer; return k ? t(r => k.collectRequiredFields(r, x)) : null }), this.autoUpdateAsync("labelingFields", () => { const { layer: x } = this; return x.labelsVisible ? t(k => f.collectLabelingFields(k, x)) : null }), this.autoUpdateAsync("viewFilterFields", () => { const { layer: x, filter: k } = this.layerView; return t(r => f.collectFilterFields(r, x, k)) })])
            }; w._createClass(g, [{
              key: "requiredFields", get: function () {
                const { layerView: { layer: { fieldsIndex: x },
                  definitionExpressionFields: k }, rendererFields: r, labelingFields: A, viewFilterFields: z } = this; return f.fixFields(x, [...n.unwrapOr(k, []), ...n.unwrapOr(r, []), ...n.unwrapOr(A, []), ...n.unwrapOr(z, [])])
              }
            }]); return g
          }(q.AsyncUpdateMixin(u.HandleOwner)); c.__decorate([p.property()], a.SceneLayerViewRequiredFields.prototype, "layerView", void 0); c.__decorate([p.property()], a.SceneLayerViewRequiredFields.prototype, "layer", void 0); c.__decorate([p.property()], a.SceneLayerViewRequiredFields.prototype, "requiredFields",
            null); c.__decorate([p.property()], a.SceneLayerViewRequiredFields.prototype, "rendererFields", void 0); c.__decorate([p.property()], a.SceneLayerViewRequiredFields.prototype, "labelingFields", void 0); c.__decorate([p.property()], a.SceneLayerViewRequiredFields.prototype, "viewFilterFields", void 0); a.SceneLayerViewRequiredFields = c.__decorate([d.subclass("esri.views.3d.layers.support.SceneLayerViewRequiredFields")], a.SceneLayerViewRequiredFields); Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/core/AsyncUpdate": function () {
      define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./Logger ./accessorSupport/tracking ./accessorSupport/decorators/property ./accessorSupport/decorators/subclass ./accessorSupport/tracking/SimpleTrackingTarget".split(" "),
        function (a, w, c, q, u, y, n, p, l) {
          function h(d, f) { const t = () => { if (!v || m) return f(); v.clear(); m = !0; const e = y.runTracked(v, f); m = !1; return e }; let v = new l.SimpleTrackingTarget(() => { v && !m && d(t) }), m = !1; d(t); return { remove: () => { v && (v.destroy(), v = null) } } } const b = d => {
            d = function (f) {
              function t() { var m = f.apply(this, arguments) || this; m._numUpdating = 0; m.asyncUpdateState = new Map; return m } w._inheritsLoose(t, f); var v = t.prototype; v.autoUpdateAsync = function (m, e) { return h(g => this.updateAsync(m, g), e) }; v.updateAsync = function () {
                var m =
                  w._asyncToGenerator(function* (e, g) { if (!this.startAsyncUpdate(e)) { try { const x = yield g(); this._set(e, x) } catch (x) { u.getLogger(this.declaredClass).warn(`Async update of "${e}" failed. Async update functions should not throw exceptions.`) } this.endAsyncUpdate(e) && this.updateAsync(e, g) } }); return function (e, g) { return m.apply(this, arguments) }
              }(); v.startAsyncUpdate = function (m) {
                var e; const g = null != (e = this.asyncUpdateState.get(m)) ? e : 0; if (g & 1) return this.asyncUpdateState.set(m, g | 2), !0; ++this._numUpdating; this.asyncUpdateState.set(m,
                  g | 1); return !1
              }; v.endAsyncUpdate = function (m) { var e; --this._numUpdating; const g = (null != (e = this.asyncUpdateState.get(m)) ? e : 0) & -2; if (g & 2) return this.asyncUpdateState.set(m, g & -3), !0; this.asyncUpdateState.set(m, g); return !1 }; w._createClass(t, [{ key: "updating", get: function () { return 0 < this._numUpdating } }]); return t
            }(d); c.__decorate([n.property({ readOnly: !0 })], d.prototype, "updating", null); c.__decorate([n.property()], d.prototype, "_numUpdating", void 0); return d = c.__decorate([p.subclass("esri.core.AsyncUpdate")],
              d)
          }; a.AsyncUpdate = function (d) { function f() { return d.apply(this, arguments) || this } w._inheritsLoose(f, d); return f }(b(q)); a.AsyncUpdate = c.__decorate([p.subclass("esri.core.AsyncUpdate")], a.AsyncUpdate); a.AsyncUpdateMixin = b; Object.defineProperty(a, "__esModule", { value: !0 })
        })
    }, "esri/views/layers/SceneLayerView": function () {
      define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/ensureType ../../core/accessorSupport/tracking ../../core/accessorSupport/extensions/serializableProperty/reader ../../core/accessorSupport/extensions/serializableProperty/writer ./LayerView".split(" "),
        function (a, w, c, q, u, y, n, p, l, h) {
          q = function (b) {
            function d() { var t = b.apply(this, arguments) || this; t.layer = null; t.filter = null; return t } a._inheritsLoose(d, b); var f = d.prototype; f.highlight = function (t) { throw Error("Not implemented"); }; f.queryFeatures = function (t, v) { throw Error("Not implemented"); }; f.queryObjectIds = function (t, v) { throw Error("Not implemented"); }; f.queryFeatureCount = function (t, v) { throw Error("Not implemented"); }; f.createQuery = function () { throw Error("Not implemented"); }; f.queryExtent = function (t,
              v) { throw Error("Not implemented"); }; a._createClass(d, [{ key: "availableFields", get: function () { return [] } }, { key: "maximumNumberOfFeatures", get: function () { return 0 }, set: function (t) { throw Error("Not implemented"); } }, { key: "maximumNumberOfFeaturesExceeded", get: function () { return !1 } }]); return d
          }(h); w.__decorate([c.property()], q.prototype, "layer", void 0); w.__decorate([c.property()], q.prototype, "availableFields", null); w.__decorate([c.property()], q.prototype, "maximumNumberOfFeatures", null); w.__decorate([c.property({ readOnly: !0 })],
            q.prototype, "maximumNumberOfFeaturesExceeded", null); w.__decorate([c.property()], q.prototype, "filter", void 0); return q
        })
    }, "esri/views/3d/layers/SceneLayerGraphicsView3D": function () {
      define("require ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/Logger ../../../core/maybe ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/support/aaBoundingRect ../../../geometry/support/contains ../../../geometry/support/zscale ../../../layers/graphics/dehydratedFeatures ../../../layers/graphics/hydratedFeatures ../../../layers/graphics/controllers/I3SOnDemandController ../../../layers/support/FeatureFilter ../../../renderers/support/renderingInfoUtils ../../../rest/support/Query ./I3SPointsWorkerHandle ./LayerView3D ./graphics/Graphics3DFeatureLikeLayerView ./graphics/QueryEngine ./i3s/attributeEditing ./i3s/I3SAttributeOverrides ./i3s/I3SUtil ./support/DefinitionExpressionSceneLayerView ./support/fieldProperties ./support/PopupSceneLayerView ./support/SceneLayerViewRequiredFields ../support/debugFlags ../support/GraphicsMap ../support/orientedBoundingBox ../support/updatingProperties ../../layers/SceneLayerView ../../support/Scheduler".split(" "),
        function (a, w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q) {
          function T(ea) { const ba = ea.attributeInfo; for (let aa = 0; aa < ea.graphics.length; aa++) { const W = ea.graphics[aa]; W.attributes || (W.attributes = {}); if (y.isSome(ba) && y.isSome(ba.loadedAttributes)) for (const { name: U } of ba.loadedAttributes) ba.attributeData[U] && (W.attributes[U] = F.getCachedAttributeValue(ba.attributeData[U], aa)) } } const da = u.getLogger("esri.views.3d.layers.SceneLayerGraphicsView3D"); u = P.defineFieldProperties();
          D = function (ea) {
            function ba() { var W = ea.apply(this, arguments) || this; W.type = "scene-layer-graphics-3d"; W._nodesAddedToStage = new Map; W.drapeSourceType = 1; W._queryEngine = null; W._memCache = null; W._interactiveEditingSessions = new Map; W.loadedGraphics = new I.GraphicsMap; W.holeFilling = "always"; W.progressiveLoadFactor = 1; W.supportsHeightUnitConversion = !0; W._coordinatesOutsideExtentErrors = 0; W._maxCoordinatesOutsideExtentErrors = 20; return W } w._inheritsLoose(ba, ea); var aa = ba.prototype; aa.initialize = function () {
              var W,
              U; const X = this.layer; this.addResolvingPromise(X.indexInfo); this._attributeOverrides = new M.I3SAttributeOverrides(this.layer, null == (W = this.view.resourceController) ? void 0 : W.memoryController); F.checkSpatialReferences(X, this.view.spatialReference, this.view.viewingMode); this.fieldsHelper = new N.SceneLayerViewRequiredFields({ layerView: this }); this.updatingHandles.add(X, "rangeInfos", Z => this._rangeInfosChanged(Z), 2); this.updatingHandles.add(X, "renderer", (Z, ia) => this._rendererChange(Z, ia)); this.updatingHandles.add(this,
                "parsedDefinitionExpression", () => this._filterChange()); this.updatingHandles.add(this, "view.floors", () => this.graphics3d.filterVisibility.filterChanged()); this.handles.add(n.init(G, "I3S_TREE_SHOW_TILES", Z => {
                  if (Z && !this._treeDebugger) { const ia = this._controller.crsIndex; (new Promise((la, ma) => a(["./support/I3STreeDebugger"], la, ma))).then(({ I3STreeDebugger: la }) => { !this._treeDebugger && G.I3S_TREE_SHOW_TILES && (this._treeDebugger = new la({ lv: this, view: this.view, nodeSR: ia })) }) } else Z || !this._treeDebugger || G.I3S_TREE_SHOW_TILES ||
                    (this._treeDebugger.destroy(), this._treeDebugger = null)
                })); this._set("graphics3d", new E({ owner: this, layer: X, preferredUpdatePolicy: 0, scaleVisibilityEnabled: !0, filterVisibilityEnabled: !0, timeExtentVisibilityEnabled: !1, frustumVisibilityEnabled: !1, elevationAlignmentEnabled: !0, elevationFeatureExpressionEnabled: !1, suspendResumeExtentMode: "data", dataExtent: X.fullExtent, updateClippingExtent: Z => this._updateClippingExtent(Z) })); null == (U = this.graphics3d.elevationAlignment) ? void 0 : U.events.on("invalidate-elevation",
                  Z => this._invalidateElevation(Z)); this.supportsHeightUnitConversion && (this._verticalScale = g.getGeometryZScaler("point", X.spatialReference, this.view.spatialReference)); this.addResolvingPromise(this.graphics3d.setup()); this._memCache = this.view.resourceController.memoryController.newCache(X.uid); this._controller = new r({ layerView: this, scaleVisibilityEnabled: !1 }); F.containsDraco(this.layer.geometryDefinitions) && (this._worker = new C.I3SPointsWorkerHandle(Z => this.view.resourceController.schedule(Z))); this.handles.add(this.layer.on("apply-edits",
                    Z => this.updatingHandles.addPromise(Z.result))); this.handles.add(this.layer.on("edits", Z => this._handleEdits(Z))); this.when(() => { this._queryEngine = new H.default({ layerView: this, priority: Q.TaskPriority.FEATURE_QUERY_ENGINE }); this.updatingHandles.add(this, "maximumNumberOfFeatures", Z => this._controller.featureTarget = Z, 2); this.updatingHandles.add(this, "suspended", Z => { Z && this._removeAllNodeData() }) })
            }; aa.destroy = function () {
            this._treeDebugger = y.destroyMaybe(this._treeDebugger); this._attributeOverrides = y.destroyMaybe(this._attributeOverrides);
              this._set("graphics3d", y.destroyMaybe(this.graphics3d)); this._controller = y.destroyMaybe(this._controller); this._queryEngine = y.destroyMaybe(this._queryEngine); this._worker = y.destroyMaybe(this._worker); this._memCache = y.destroyMaybe(this._memCache); this._nodesAddedToStage.clear(); this.fieldsHelper = y.destroyMaybe(this.fieldsHelper)
            }; aa.notifyGraphicGeometryChanged = function (W) { this.graphics3d.graphicsCore.notifyGraphicGeometryChanged(W) }; aa.notifyGraphicVisibilityChanged = function (W) { this.graphics3d.graphicsCore.notifyGraphicVisibilityChanged(W) };
            aa.whenGraphicAttributes = function () { var W = w._asyncToGenerator(function* (U, X) { return F.whenGraphicAttributes(this.layer, U, this._getObjectIdField(), X, () => [...this._nodesAddedToStage.values()]) }); return function (U, X) { return W.apply(this, arguments) } }(); aa.getGraphicFromGraphicUid = function (W) {
              if (!this.loadedGraphics) return null; const U = k.hydrateGraphic(this.loadedGraphics.find(Z => Z.uid === W), this.layer), X = this._getObjectIdField(); if (!U || !U.attributes || !U.attributes[X]) return null; U.layer = this.layer; U.sourceLayer =
                this.layer; return U
            }; aa.whenGraphicBounds = function (W, U) { return this.graphics3d.graphicsCore.whenGraphicBounds(W, U) }; aa.computeAttachmentOrigin = function (W, U) { return this.graphics3d.graphicsCore.computeAttachmentOrigin(W, U) }; aa.canResume = function () { return ea.prototype.canResume.call(this) && (!this._controller || this._controller.rootNodeVisible) }; aa.isUpdating = function () { var W, U, X; return !!(null != (W = this._controller) && W.updating || null != (U = this.graphics3d) && U.updating || null != (X = this.fieldsHelper) && X.updating) };
            aa.getRenderingInfo = function (W, U, X) { W = z.getRenderingInfo(W, { renderer: U, arcade: X }); y.isSome(W) && W.color && (U = W.color, U[0] /= 255, U[1] /= 255, U[2] /= 255); return W }; aa.getRenderingInfoAsync = function () { var W = w._asyncToGenerator(function* (U, X, Z, ia) { return z.getRenderingInfoAsync(U, { renderer: X, arcade: Z, ...ia }) }); return function (U, X, Z, ia) { return W.apply(this, arguments) } }(); aa.highlight = function (W) { return this.graphics3d.highlight(W, this.layer.objectIdField) }; aa.createInteractiveEditSession = function (W) {
              return J.createInteractiveEditSession(this.attributeEditingContext,
                W)
            }; aa.extractBinaryPointData = function () { var W = w._asyncToGenerator(function* (U, X) { U = { geometryBuffer: U.geometryBuffer }; y.isNone(this._worker) && (this._worker = new C.I3SPointsWorkerHandle(Z => this.view.resourceController.schedule(Z))); return this._worker.invoke(U, X).then(Z => { if (y.isSome(Z)) return { positionData: Z.positions, featureIds: Z.featureIds }; throw Error("Failed to decompress Draco point data"); }) }); return function (U, X) { return W.apply(this, arguments) } }(); aa.checkExtent = function (W, U) {
            W && !e.extentContainsCoords3D(W,
              U) && (this._coordinatesOutsideExtentErrors < this._maxCoordinatesOutsideExtentErrors && da.error("Service Error: Coordinates outside of layer extent"), this._coordinatesOutsideExtentErrors + 1 === this._maxCoordinatesOutsideExtentErrors && da.error("Maximum number of errors reached. Further errors are ignored."), this._coordinatesOutsideExtentErrors++)
            }; aa.addNode = function () {
              var W = w._asyncToGenerator(function* (U, X, Z) {
                if (!("geometryBuffer" in X && null !== X.geometryBuffer || "pointData" in X)) return Promise.reject();
                if (this._nodesAddedToStage.has(U.index)) da.error("I3S node " + U.id + " already added"); else {
                  if (y.isSome(this.layer.fullExtent)) { var ia = this.layer.fullExtent.clone(); ia.xmin -= .5; ia.ymin -= .5; ia.xmax += .5; ia.ymax += .5; ia.hasZ && (ia.zmin -= .5, ia.zmax += .5); ia.hasM && (ia.mmin -= .5, ia.mmax += .5) } else ia = null; var la = this._controller.crsVertex, ma = [], ra = { graphics: null, featureIds: null, attributeInfo: X.attributeDataInfo, node: U }; "geometryBuffer" in X && null !== X.geometryBuffer ? yield this._addNodeBinaryPointData(U, ra, X, ia, ma,
                    Z) : "pointData" in X && this._addNodeLegacyPointData(U, ra, X, ia, ma); yield this._attributeOverrides.apply(ra.featureIds, X.attributeDataInfo, Z); U.numFeatures = ra.graphics.length; this._updateNodeMemory(U); T(ra); 0 < ma.length && (this.computeObb(U, ma, la), this._controller.updateVisibility(U.index)); if (!this._controller.isGeometryVisible(U)) return this._cacheNodeData(ra), Promise.resolve(); if (y.isSome(this._verticalScale)) for (const Aa of ra.graphics) this._verticalScale(Aa.geometry); this._nodesAddedToStage.set(U.index,
                      ra); this.loadedGraphics.addMany(ra.graphics); this._filterNode(ra); this._treeDebugger && this._treeDebugger.update(); return Promise.resolve()
                }
              }); return function (U, X, Z) { return W.apply(this, arguments) }
            }(); aa.computeObb = function (W, U, X) { const Z = this._controller.crsIndex, ia = Z.isGeographic ? this.view.renderSpatialReference : Z; v.projectBuffer(U, X, 0, U, ia, 0, U.length / 3); W.serviceObb = O.compute({ data: U, size: 3 }); Z.isGeographic && v.projectVectorToVector(W.serviceObb.center, ia, W.serviceObb.center, Z) }; aa.isNodeLoaded =
              function (W) { return this._nodesAddedToStage.has(W) }; aa.isNodeReloading = function () { return !1 }; aa.updateNodeState = function () { }; aa._addNodeBinaryPointData = function () {
                var W = w._asyncToGenerator(function* (U, X, Z, ia, la, ma) {
                  var ra = yield this.extractBinaryPointData(Z, ma); if (null == ra) return Promise.reject(); Z = this._getObjectIdField(); ma = this._controller.crsVertex; const Aa = this.view.spatialReference, za = this.graphics3d.graphicsCore, { positionData: Ka, featureIds: Ea } = ra; ra = Ka.length / 3; const Ua = []; for (let Ia = 0; Ia < ra; Ia++) {
                    var Na =
                      y.isSome(U.serviceObb) ? U.serviceObb.center : [0, 0, 0], ya = 3 * Ia, pa = t.fromValues(Ka[ya + 0], Ka[ya + 1], Ka[ya + 2]); f.add(pa, pa, Na); U.serviceObb || la.push(pa[0], pa[1], pa[2]); y.isSome(ia) && this.checkExtent(ia, pa); ya = Ea[Ia]; Na = {}; null != ya && (Na[Z] = ya); ya = null == ya ? q.generateUID() : ya; v.projectBuffer(pa, ma, 0, fa, Aa, 0, 1); pa = x.makeDehydratedPoint(fa[0], fa[1], fa[2], Aa); var wa = this.loadedGraphics.get(ya); y.isSome(wa) ? (wa.level < U.level && (ha.property = "geometry", ha.graphic = wa, ha.oldValue = y.unwrap(wa.geometry), ha.newValue = pa,
                        wa.geometry = pa, za.graphicUpdateHandler(ha)), Ua.push(wa)) : (wa = q.generateUID(), Ua.push({ objectId: ya, uid: wa, geometry: pa, attributes: Na, visible: !0, level: U.level }))
                  } X.graphics = Ua; X.featureIds = Ea
                }); return function (U, X, Z, ia, la, ma) { return W.apply(this, arguments) }
              }(); aa._addNodeLegacyPointData = function (W, U, X, Z, ia) {
                const la = this._getObjectIdField(), ma = this._controller.crsVertex, ra = this.view.spatialReference, Aa = [0, 0, 0], za = [], Ka = []; for (const Na of X.pointData) {
                  X = Na.featureDataPosition; const ya = X.length; var Ea =
                    Na.geometries && Na.geometries[0] || Y[ya]; const pa = Na.featureIds[0]; if ("points" !== Ea.params.type) continue; y.isSome(Z) && this.checkExtent(Z, X); const wa = {}; null != pa && (wa[la] = pa); const Ia = null == pa ? q.generateUID() : pa; let Ha; "Embedded" === Ea.type && (Ha = Ea.params.vertexAttributes.position); for (Ea = 0; Ea < Ha.length; Ea += ya) {
                      for (var Ua = 0; Ua < ya; Ua++)Aa[Ua] = X[Ua] + Ha[Ea + Ua]; Ua = 3 === ya; W.serviceObb || ia.push(Aa[0], Aa[1], Ua ? Aa[2] : 0); v.projectBuffer(Aa, ma, 0, fa, ra, 0, 1); Ua = x.makeDehydratedPoint(fa[0], fa[1], Ua ? fa[2] : void 0, ra);
                      const Oa = this.loadedGraphics.get(Ia); y.isSome(Oa) ? Ka.push(Oa) : Ka.push({ objectId: Ia, uid: q.generateUID(), geometry: Ua, attributes: wa, visible: !0 })
                    } za.push(pa)
                } U.graphics = Ka; U.featureIds = za
              }; aa._updateNodeMemory = function (W) { W.memory = 4096 + (y.isSome(W.numFeatures) ? W.numFeatures * this.graphics3d.graphicsCore.usedMemoryPerGraphic : 0) }; aa._cacheNodeData = function (W) { const U = W.graphics.reduce((X, Z) => x.estimateSize(Z) + X, 8 * W.featureIds.length + 1536); this._memCache.put(this._getMemCacheKey(W.node), W, U) }; aa._getMemCacheKey =
                function (W) { return `${W.index}` }; aa._removeAllNodeData = function () { this._nodesAddedToStage.forEach(W => { W && (this._updateNodeMemory(W.node), this._cacheNodeData(W)) }); this._nodesAddedToStage.clear(); this._treeDebugger && this._treeDebugger.update(); this.loadedGraphics.clear() }; aa.removeNode = function (W) { if (W = this._removeNodeStageData(W)) this._updateNodeMemory(W.node), this._cacheNodeData(W) }; aa._removeNodeStageData = function (W) {
                  const U = this._nodesAddedToStage.get(W); if (!U) return null; this.loadedGraphics.removeMany(U.graphics);
                  this._nodesAddedToStage.delete(W); this._treeDebugger && this._treeDebugger.update(); return U
                }; aa.loadCachedNodeData = function () { var W = w._asyncToGenerator(function* (U) { return this._memCache.pop(this._getMemCacheKey(U)) }); return function (U) { return W.apply(this, arguments) } }(); aa.addCachedNodeData = function () {
                  var W = w._asyncToGenerator(function* (U, X, Z, ia) {
                    if (this._nodesAddedToStage.has(U.index)) da.error("I3S node " + U.id + " already added"); else return this.loadedGraphics.addMany(X.graphics), this._nodesAddedToStage.set(U.index,
                      X), this._updateNodeMemory(U), yield this.updateAttributes(U.index, Z, ia), this._filterNode(X), this._treeDebugger && this._treeDebugger.update(), Promise.resolve()
                  }); return function (U, X, Z, ia) { return W.apply(this, arguments) }
                }(); aa.getLoadedNodeIds = function () { const W = []; this._nodesAddedToStage.forEach(U => W.push(U.node.id)); return W.sort() }; aa.getVisibleNodes = function () { const W = []; this._nodesAddedToStage.forEach(U => W.push(U.node)); return W }; aa.getLoadedNodeIndices = function (W) {
                  this._nodesAddedToStage.forEach((U,
                    X) => W.push(X))
                }; aa.getLoadedAttributes = function (W) { if ((W = this._nodesAddedToStage.get(W)) && y.isSome(W.attributeInfo)) return W.attributeInfo.loadedAttributes }; aa.getAttributeData = function (W) { if ((W = this._nodesAddedToStage.get(W)) && y.isSome(W.attributeInfo)) return W.attributeInfo.attributeData }; aa.setAttributeData = function (W, U) { (W = this._nodesAddedToStage.get(W)) && !y.isNone(W.attributeInfo) && (W.attributeInfo.attributeData = U, this._attributeValuesChanged(W)) }; aa.updateAttributes = function () {
                  var W = w._asyncToGenerator(function* (U,
                    X, Z) { if (U = this._nodesAddedToStage.get(U)) yield this._attributeOverrides.apply(U.featureIds, X, Z), U.attributeInfo = X, this._attributeValuesChanged(U) }); return function (U, X, Z) { return W.apply(this, arguments) }
                }(); aa._attributeValuesChanged = function (W) { T(W); this._filterNode(W); this.graphics3d.graphicsCore.labelsEnabled && (W = W.graphics.map(U => U.uid), this.graphics3d.graphicsCore.updateLabelingInfo(W)) }; aa._updateClippingExtent = function (W) { this._controller && this._controller.updateClippingArea(W); return !1 }; aa._getObjectIdField =
                  function () { return this.layer.objectIdField || "OBJECTID" }; aa._rendererChange = function () { var W = w._asyncToGenerator(function* (U, X) { const { layer: { fieldsIndex: Z } } = this, ia = new Set; let la; U ? (yield U.collectRequiredFields(ia, Z), la = Array.from(ia).sort()) : la = []; ia.clear(); let ma; X ? (yield X.collectRequiredFields(ia, Z), ma = Array.from(ia).sort()) : ma = []; la.length === ma.length && la.every((ra, Aa) => la[Aa] === ma[Aa]) || this._reloadAllNodes() }); return function (U, X) { return W.apply(this, arguments) } }(); aa._rangeInfosChanged =
                    function (W) { null != W && 0 < W.length && da.warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.") }; aa._filterChange = function () { this._nodesAddedToStage.forEach(W => this._filterNode(W)) }; aa._reloadAllNodes = function () { this._removeAllNodeData(); this._controller && this._controller.restartNodeLoading() }; aa._filterNode = function (W) {
                      const U = this.parsedDefinitionExpression; for (const X of W.graphics) W = X.visible, X.visible = U ? this._evaluateClause(U, X) :
                        !0, W !== X.visible && (ha.graphic = X, ha.property = "visible", ha.oldValue = W, ha.newValue = X.visible, this.graphics3d.graphicsCore.graphicUpdateHandler(ha))
                    }; aa._invalidateElevation = function (W) { const U = this._controller.crsIndex; v.projectBoundingRect(W.extent, W.spatialReference, ka, U); this._controller.updateElevationChanged(ka, U) }; aa.createQuery = function () { const W = { outFields: ["*"], returnGeometry: !0, outSpatialReference: this.view.spatialReference }; return y.isSome(this.filter) ? this.filter.createQuery(W) : new B(W) };
            aa.queryFeatures = function (W, U) { return this._queryEngine.executeQuery(this._ensureQuery(W), null == U ? void 0 : U.signal) }; aa.queryObjectIds = function (W, U) { return this._queryEngine.executeQueryForIds(this._ensureQuery(W), null == U ? void 0 : U.signal) }; aa.queryFeatureCount = function (W, U) { return this._queryEngine.executeQueryForCount(this._ensureQuery(W), null == U ? void 0 : U.signal) }; aa.queryExtent = function (W, U) { return this._queryEngine.executeQueryForExtent(this._ensureQuery(W), null == U ? void 0 : U.signal) }; aa._ensureQuery =
              function (W) { return this._addDefinitionExpressionToQuery(y.isNone(W) ? this.createQuery() : B.from(W)) }; aa.getUsedMemory = function () { const W = this.graphics3d && this.graphics3d.graphicsCore; return W ? W.usedMemory : 0 }; aa.getUnloadedMemory = function () { const W = this.graphics3d && this.graphics3d.graphicsCore; return .8 * ((this._controller ? this._controller.unloadedMemoryEstimate : 0) + (W ? W.unprocessedMemoryEstimate : 0)) }; aa.ignoresMemoryFactor = function () { return this._controller && this._controller.fixedFeatureTarget }; aa._handleEdits =
                function (W) { J.processAttributeEdits(this.attributeEditingContext, W) }; w._createClass(ba, [{ key: "requiredFields", get: function () { var W, U; return null != (W = null == (U = this.fieldsHelper) ? void 0 : U.requiredFields) ? W : [] } }, {
                  key: "maximumNumberOfFeatures", get: function () { const W = this.graphics3d && this.graphics3d.graphicsCore && this.graphics3d.graphicsCore.displayFeatureLimit; return W ? W.maximumNumberOfFeatures : 0 }, set: function (W) {
                    null != W ? (this._override("maximumNumberOfFeatures", W), this._controller.fixedFeatureTarget =
                      !0) : (this._clearOverride("maximumNumberOfFeatures"), this._controller.fixedFeatureTarget = !1)
                  }
                }, { key: "maximumNumberOfFeaturesExceeded", get: function () { return this.suspended ? !1 : !!this._controller && !this._controller.leavesReached } }, { key: "hasM", get: function () { return !1 } }, { key: "hasZ", get: function () { return !0 } }, { key: "symbolUpdateType", get: function () { return this.graphics3d.graphicsCore.symbolUpdateType } }, { key: "updatePolicy", get: function () { return this.graphics3d.graphicsCore.effectiveUpdatePolicy } }, {
                  key: "attributeEditingContext",
                  get: function () {
                    const W = this._getObjectIdField(); return {
                      sessions: this._interactiveEditingSessions, fieldsIndex: this.layer.fieldsIndex, objectIdField: W, forEachNode: U => this._nodesAddedToStage.forEach(X => U(X.node, X.featureIds)), attributeStorageInfo: this.i3slayer.attributeStorageInfo, attributeOverrides: this._attributeOverrides, getAttributeData: U => this.getAttributeData(U), setAttributeData: (U, X, Z) => {
                        this.setAttributeData(U, X); U = this._nodesAddedToStage.get(U); y.isSome(Z) ? (Z = this.loadedGraphics.get(Z.attributes[W]),
                          y.isSome(Z) && this.graphics3d.graphicsCore.recreateGraphics([Z])) : y.isSome(U) && this.graphics3d.graphicsCore.recreateGraphics(U.graphics)
                      }, clearMemCache: () => { }
                    }
                  }
                }, { key: "performanceInfo", get: function () { const W = { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: this.maximumNumberOfFeatures, totalNumberOfFeatures: -1, nodes: this._nodesAddedToStage.size, core: this.graphics3d.graphicsCore.performanceInfo }; this._controller && this._controller.updateStats(W); return W } }, {
                  key: "test", get: function () {
                    return {
                      controller: this._controller,
                      numNodes: this._nodesAddedToStage.size, numFeatures: this.loadedGraphics.length
                    }
                  }
                }]); return ba
          }(K.DefinitionExpressionSceneLayerView(L.PopupSceneLayerView(D.LayerView3D(S)))); c.__decorate([p.property()], D.prototype, "graphics3d", void 0); c.__decorate([p.property({ type: A })], D.prototype, "filter", void 0); c.__decorate([p.property()], D.prototype, "loadedGraphics", void 0); c.__decorate([p.property({ aliasOf: "layer" })], D.prototype, "i3slayer", void 0); c.__decorate([p.property()], D.prototype, "_controller", void 0);
          c.__decorate([p.property()], D.prototype, "updating", void 0); c.__decorate([p.property()], D.prototype, "suspended", void 0); c.__decorate([p.property()], D.prototype, "holeFilling", void 0); c.__decorate([p.property(R.updatingProgress)], D.prototype, "updatingProgress", void 0); c.__decorate([p.property({ aliasOf: "_controller.updatingProgress" })], D.prototype, "updatingProgressValue", void 0); c.__decorate([p.property(u.requiredFields)], D.prototype, "requiredFields", null); c.__decorate([p.property(u.availableFields)],
            D.prototype, "availableFields", void 0); c.__decorate([p.property()], D.prototype, "fieldsHelper", void 0); c.__decorate([p.property({ type: Number })], D.prototype, "maximumNumberOfFeatures", null); c.__decorate([p.property({ readOnly: !0 })], D.prototype, "maximumNumberOfFeaturesExceeded", null); c.__decorate([p.property({ readOnly: !0, aliasOf: "view.qualitySettings.sceneService.point.lodFactor" })], D.prototype, "lodFactor", void 0); c.__decorate([p.property({ readOnly: !0 })], D.prototype, "hasM", null); c.__decorate([p.property({ readOnly: !0 })],
              D.prototype, "hasZ", null); c = D = c.__decorate([d.subclass("esri.views.3d.layers.SceneLayerGraphicsView3D")], D); const Y = { 2: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0] } } }, 3: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0, 0] } } } }, fa = t.create(), ha = { graphic: null, property: null, oldValue: null, newValue: null }, ka = m.create(); return c
        })
    }, "esri/views/3d/layers/I3SPointsWorkerHandle": function () {
      define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/workers/WorkerHandle"],
        function (a, w, c) { c = function (q) { function u(y) { return q.call(this, "SceneLayerWorker", "dracoDecompressPointCloudData", y, { hasInitialize: !0 }) || this } w._inheritsLoose(u, q); u.prototype.getTransferList = function (y) { return [y.geometryBuffer] }; return u }(c.WorkerHandle); a.I3SPointsWorkerHandle = c; Object.defineProperty(a, "__esModule", { value: !0 }) })
    }, "*noref": 1
  }
});
define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Camera ../geometry ../Graphic ../Ground ../Viewpoint ../core/Collection ../core/domUtils ../core/Error ../core/events ../core/handleUtils ../core/has ../core/iteratorUtils ../core/Logger ../core/maybe ../core/promiseUtils ../core/scheduling ../core/watchUtils ../core/workers/workers ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/subclass ../core/accessorSupport/ensureType ../chunks/vec3f64 ../geometry/HeightModelInfo ../geometry/projection ../geometry/support/aaBoundingRect ../chunks/boundedPlane ../geometry/support/coordinateSystem ../geometry/support/scaleUtils ../layers/VoxelWasmManager ../layers/support/layerUtils ./BreakpointsOwner ./DOMContainer ./GroundView ./PopupView ./View ./ViewAnimation ./ViewingMode ./3d/layerViewModuleImportUtils ./3d/analysis/AnalysisViewManager3D ./3d/constraints/Constraints ./3d/environment/SceneViewEnvironment ./3d/environment/SceneViewEnvironmentManager ./3d/input/SceneInputManager ./3d/layers/graphics/GraphicsDeconflictor ./3d/layers/graphics/Labeler ./3d/layers/graphics/ObjectResourceCache ./3d/layers/support/FeatureTileTree3D ./3d/state/ViewState ./3d/state/ViewStateManager ./3d/state/helpers/SceneIntersectionHelper ./3d/support/CombinedElevationProvider ./3d/support/debugFlags ./3d/support/DisplayQualityProfile ./3d/support/ElevationProvider ./3d/support/HighlightOptions ./3d/support/MapCoordsHelper ./3d/support/PropertiesPool ./3d/support/QualitySettings ./3d/support/RenderCoordsHelper ./3d/support/ResourceController ./3d/support/SceneViewPerformanceInfo ./3d/support/SharedSymbolResources ./3d/support/pointsOfInterest/PointsOfInterest ./3d/terrain/TerrainSurface ./3d/terrain/terrainUtils ./3d/webgl-engine/Stage ./3d/webgl-engine/lib/Intersector ./3d/webgl-engine/lib/intersectorUtils ./3d/webgl-engine/lib/intersectorUtilsConversions ./3d/webgl-engine/lib/verticalOffsetUtils ./support/hitTestSelectUtils ./support/layerViewUtils ./support/screenshotUtils ./support/screenUtils ./support/spatialReferenceSupport ./support/WebGLRequirements ./ui/3d/DefaultUI3D ../webscene/Environment ../geometry/SpatialReference ../geometry/Point ../geometry/Extent".split(" "), function (a,
  w, c, q, u, y, n, p, l, h, b, d, f, t, v, m, e, g, x, k, r, A, z, B, C, D, E, H, J, M, F, K, P, L, N, G, I, O, R, S, Q, T, da, Y, fa, ha, ka, ea, ba, aa, W, U, X, Z, ia, la, ma, ra, Aa, za, Ka, Ea, Ua, Na, ya, pa, wa, Ia, Ha, Oa, Ba, sa, Ca, Ja, ca, qa, Da, na, xa, Qa, Wa, Ra, ta, Fa, Sa, Va, Ya) {
    function bb(ob, wb) { ob.layerUids || (ob.layerUids = new Set); ob.layerUids.add(wb) } function hb(ob, wb) { return e.isSome(ob) && M.canProjectWithoutEngine(ob.spatialReference, wb) ? M.project(ob, wb) : null } const ib = m.getLogger("esri.views.SceneView"); u = function (ob) {
      function wb(La) {
        var Ma = ob.call(this, La) ||
          this; Ma._userClippingArea = null; Ma._clippingArea = null; Ma._initialDefaultSpatialReference = null; Ma._defaults = {}; Ma._externallySet = { environment: !1 }; Ma._createGraphicsViewController = null; Ma._resolveWhenReady = []; Ma.propertiesPool = new Ua.PropertiesPool({ slicePlane: K.BoundedPlaneClass }, w._assertThisInitialized(Ma)); Ma._resourceController = pa.newResourceController(w._assertThisInitialized(Ma)); Ma._defaultToMapOptions = { include: new Set }; Ma._defaultHitTestOptions = { exclude: new Set }; Ma.deconflictor = new aa.GraphicsDeconflictor({ view: w._assertThisInitialized(Ma) });
        Ma.labeler = new W.Labeler({ view: w._assertThisInitialized(Ma), deconflictor: Ma.deconflictor.labels }); Ma.sharedSymbolResources = null; Ma.basemapTerrain = null; Ma.elevationProvider = null; Ma.camera = null; Ma.canvas = null; Ma.center = null; Ma.constraints = new ha.default; Ma.environmentManager = new ea.SceneViewEnvironmentManager; Ma.extent = null; Ma.floors = new l; Ma.windowDevicePixelRatio = 1; Ma.fullOpacity = 1; Ma.graphicsView = null; Ma.analysisViewManager = new fa({ view: w._assertThisInitialized(Ma) }); Ma.groundView = null; Ma.navigating =
          !1; Ma.map = null; Ma.screenSizePerspectiveEnabled = !0; Ma.state = new Z; Ma.scale = null; Ma.spatialReference = null; Ma.alphaCompositingEnabled = !1; Ma.supersampleScreenshotsEnabled = !0; Ma.type = "3d"; Ma.ui = new ta; Ma._numUpdating = 0; Ma._lastUpdateTime = 0; Ma.updatingProgress = .5; Ma.viewpoint = null; Ma.zoom = null; Ma.highlightOptions = new Ka; r.initialize(); La && La.environment || (Ma._defaults.environment = new ka, Ma.environment = Ma._defaults.environment); La = Za => {
            e.isSome(Za) && 4 === Za.type || (Ma.updatingChanged(), Ma.map && Ma.map.allLayers.forEach(function () {
              var cb =
                w._asyncToGenerator(function* (fb) { try { yield fb.when() } catch{ } Ma.updatingChanged() }); return function (fb) { return cb.apply(this, arguments) }
            }()))
          }; Ma.handles.add([k.on(w._assertThisInitialized(Ma), "map.allLayers", "after-changes", La, La, La, !0), Ma.allLayerViews.on("after-changes", Za => Ma._updateUpdatingMonitors(Za)), Ma.watch("map", Za => { Za && Za.load && Za.load().catch(() => { }) })]); Ma.inputManager = new ba({ view: w._assertThisInitialized(Ma) }); Ma.stateManager = new ia({
            view: w._assertThisInitialized(Ma), updateDevicePixelRatio: () => { const Za = window.devicePixelRatio; Za !== Ma.windowDevicePixelRatio && (Ma.windowDevicePixelRatio = Za, Ma.notifyChange("pixelRatio")) }
          }); return Ma
      } w._inheritsLoose(wb, ob); var db = wb.prototype; db.initialize = function () {
      this.groundView = new R({ view: this }); this._updateUpdatingMonitors(); const La = () => this._updateDefaultToMapOptions(); this.handles.add(k.on(this, "map.allLayers", "after-changes", La, La, La)); this.updatingHandles.add(this.qualitySettings, "memoryLimit", Ma => {
      this.resourceController && (this.resourceController.memoryController.maxMemory =
        Ma)
      }, 2); this.updatingHandles.add(this.qualitySettings, "additionalCacheMemory", Ma => { this.resourceController && (this.resourceController.memoryController.additionalCacheMemory = Ma) }, 2); this.updatingHandles.add(this.qualitySettings, "frameRate", Ma => x.setFrameDuration(0 < Ma ? 1E3 / Math.ceil(Ma) : 0), 2); this.updatingHandles.add(ra, "SCENEVIEW_LOCKING_LOG", Ma => this.defaultsFromMap.logDebugInformation = Ma, 2); this.updatingHandles.add(this, "map.ground", La, 3); this.updatingHandles.add(this, "map.ground.opacity", () => this._updateDefaultHitTestOptions(),
        3); this.handles.add(this.watch("spatialReference", () => this.notifyChange("clippingArea"), !0))
      }; db.destroy = function () {
      this.destroyed || (this.invalidate(), this.activeTool = null, this.layerViewManager.clear(), this._exitSurface(), this._disposeGraphicsView(), this.sharedSymbolResources = e.destroyMaybe(this.sharedSymbolResources), this.labeler.destroy(), this._set("labeler", null), this.deconflictor.destroy(), this._set("deconflictor", null), this._resourceController = e.destroyMaybe(this._resourceController), this.stateManager.destroy(),
        this._set("stateManager", null), this.inputManager.destroy(), this._set("inputManager", null), this.propertiesPool.destroy(), this.handles.remove("updatingMonitors"), this.environmentManager.destroy(), this._set("environmentManager", null), this.groundView = e.destroyMaybe(this.groundView))
      }; db.installContentCameraReset = function (La = { sticky: !1 }) { return this.stateManager.installContentCameraReset(La) }; db.castEnvironment = function (La) {
        return La ? La instanceof ka ? La : La instanceof Fa ? null != this.environment ? this.environment.cloneWithWebsceneEnvironment(La) :
          ka.fromWebsceneEnvironment(La) : E.ensureType(ka, La) : new ka
      }; db.forceAnimationTime = function (La) { this._stage.renderView.forcedAnimationTime = this.basemapTerrain.overlayManager.forcedAnimationTime = La }; db.on = function (La, Ma, Za, cb) { return (Za = this.viewEvents.on(La, Ma, Za, cb)) ? Za : ob.prototype.on.call(this, La, Ma) }; db.hasEventListener = function (La) { return ob.prototype.hasEventListener.call(this, La) || this.viewEvents.hasHandler(La) }; db.toMap = function (La, Ma) {
        if (!this.ready) return ib.error("#toMap()", "Scene view cannot be used before it is ready"),
          null; Ma = Ma ? this.externalToInternalIntersectOptions(Ma) : this._defaultToMapOptions; var Za = e.isSome(Ma.graphics) && (e.isSome(Ma.graphics.include) || e.isSome(Ma.graphics.exclude)); La = Qa.isSupportedScreenPointEvent(La) ? Qa.createScreenPointFromSupportedEvent(this, La) : La; La = A.screenPointObjectToArray(La); Ma.enableDraped = Ma.include && !Ma.include.has(qa.TERRAIN_ID) || Ma.exclude && Ma.exclude.has(qa.TERRAIN_ID); const cb = this.sceneIntersectionHelper, fb = Ca.newIntersector(this.state.viewingMode); fb.options.selectionMode =
            !0; fb.options.store = Za ? 2 : 0; cb.intersectIntersectorScreen(La, fb, Ma); if (Za) { for (const gb of fb.results.all) if (Za = ca.toGraphic(gb, this), e.isNone(Za) || this._testGraphicUidFilter(Ma.graphics, Za)) return this._intersectResultToMapPoint(gb); return null } return this._intersectResultToMapPoint(fb.results.min)
      }; db.toScreen = function (La) {
        if (!this.ready) return ib.error("#toScreen()", "Scene view cannot be used before it is ready"), null; const Ma = e.unwrapOr(null == La.z && za.getElevationAtPoint(this.elevationProvider,
          La), 0); M.projectPointToVector(La, mb, this.renderSpatialReference, Ma); this.state.camera.projectToScreen(mb, tb); return A.createScreenPoint(tb[0], tb[1])
      }; db.pixelSizeAt = function (La) { if (!this.ready) return ib.error("#pixelSizeAt()", "Scene view cannot be used before it is ready"), null; if (!La) return 0; M.projectPointToVector(La, mb, this.renderSpatialReference); return this.state.camera.computeScreenPixelSizeAt(mb) }; db.overlayPixelSizeInMapUnits = function (La) {
        const Ma = this.basemapTerrain.overlayManager; return Ma ?
          Ma.overlayPixelSizeInMapUnits(La) : 1
      }; db.hitTest = function (La, Ma) {
        if (!this.ready) return ib.error("#hitTest()", "Scene view cannot be used before it is ready"), null; La = Qa.isSupportedScreenPointEvent(La) ? Qa.createScreenPointFromSupportedEvent(this, La) : La; var Za = A.createScreenPointArray(La.x, La.y), cb = Ma ? this.externalToInternalIntersectOptions(Ma) : this._defaultHitTestOptions; cb.requiresGroundFeedback = !0; cb.enableDraped = !0; Ma = Ca.newIntersector(this.state.viewingMode); Ma.options.selectionMode = !0; Ma.options.store =
          2; this.sceneIntersectionHelper.intersectIntersectorScreen(Za, Ma, cb); Za = this._intersectResultsToHits(Ma.results.all, cb.graphics); cb = Ma.results.ground; var fb = ca.toOwner(cb, this); fb = e.isSome(fb) && "type" in fb && "integrated-mesh" === fb.type ? fb : null; La = { screenPoint: La, results: Za, ground: { mapPoint: this._intersectResultToMapPoint(cb), distance: Ja.isValidIntersectorResult(cb) ? cb.distanceInRenderSpace : 0, layer: fb } }; ra.SCENEVIEW_HITTEST_RETURN_INTERSECTOR && (La.intersector = Ma); return Promise.resolve(La)
      }; db.popupHitTest =
        function (La) { return Da.hitTestSelectSameDistance(this, La).then(({ results: Ma, ground: Za }) => { let cb = null; !(0 === Ma.length || 1E-5 > Math.abs(e.unwrapOr(Ma[0].distance, 0) - Za.distance)) || Za.layer && "integrated-mesh" === Za.layer.type || (cb = Za.mapPoint); return { results: Ma, screenPoint: La, mapPoint: cb } }) }; db.goTo = function (La, Ma) { return this.updatingHandles.addPromise(this.stateManager.goTo(La, Ma)) }; db.whenAnalysisView = function () {
          var La = w._asyncToGenerator(function* (Ma) {
            if (e.isNone(Ma.parent)) throw new b("view:no-analysisview-for-analysis",
              "The analysis has not been added to an AnalysisLayer or SceneView.analyses", { analysis: Ma }); switch (Ma.parent.type) { case "analysis": return (yield this.whenLayerView(Ma.parent)).whenAnalysisView(Ma); default: return this.analysisViewManager.whenAnalysisView(Ma) }
          }); return function (Ma) { return La.apply(this, arguments) }
        }(); db.whenLayerView = function (La) { return ob.prototype.whenLayerView.call(this, La) }; db.takeScreenshot = function (La) {
          return this.whenReady().then(() => {
            const Ma = xa.toRenderSettings(La, this); for (const Za of this.map.allLayers.items) "voxel" ===
              Za.type && (Ma.renderScreenshotTwice = !0); Ma.pixelRatio /= this.pixelRatio; return this._stage.renderView.takeScreenshot(xa.screenshotSuperSampleSettings(Ma, this.supersampleScreenshotsEnabled, this.padding))
          })
        }; db.addUpdatingPromise = function (La) { return this.updatingHandles.addPromise(La) }; db.importLayerView = function (La) { return Y.layerView3DImporter.importLayerView(La) }; db.hasLayerViewModule = function (La) { return Y.layerView3DImporter.hasLayerViewModule(La) }; db.forceDOMReadyCycle = function () { this.forceReadyCycle() };
      db.getDefaultSpatialReference = function () { var La, Ma, Za, cb; return this.map && "initialViewProperties" in this.map && (null == (La = this.map) ? void 0 : null == (Ma = La.initialViewProperties) ? void 0 : Ma.spatialReference) || (null == (Za = this.defaultsFromMap) ? void 0 : Za.spatialReference) || (null == (cb = this.defaultsFromMap) ? void 0 : cb.ready) && this._initialDefaultSpatialReference || null }; db.validate = function () {
        var La = w._asyncToGenerator(function* () {
          let Ma = Ra.check(); t("safari") && 9 > t("safari") && (Ma = new b("sceneview:browser-not-supported",
            "This browser is not supported by SceneView (Safari \x3c 9)", { type: "safari", requiredVersion: 9, detectedVersion: t("safari") })); if (e.isSome(Ma)) throw ib.warn("#validate()", Ma.message), Ma;
        }); return function () { return La.apply(this, arguments) }
      }(); db.getSpatialReferenceSupport = function ({ spatialReference: La, layer: Ma }) {
        var Za = this._predeterminedViewingMode; if (e.isSome(Za)) return this._validateSpatialReferenceForViewingMode(La, Ma, Za) ? { constraints: this._makeSpatialReferenceConstraints(La, Ma, Za) } : null; Za = this._validateSpatialReferenceForViewingMode(La,
          Ma, 2); const cb = this._validateSpatialReferenceForViewingMode(La, Ma, 1); return Za || cb ? Za && cb ? { constraints: this._makeSpatialReferenceConstraints(La, Ma, null) } : Za ? { constraints: this._makeSpatialReferenceConstraints(La, Ma, 2) } : { constraints: this._makeSpatialReferenceConstraints(La, Ma, 1) } : null
      }; db._validateSpatialReferenceForViewingMode = function (La, Ma, Za) {
        return Wa.isSpatialReferenceSupported(La, Za) ? e.isNone(Ma) ? !0 : G.isTiledLayer(Ma) && e.isNone(Ba.getTiledLayerInfo(Ma, La, Za)) || "voxel" === Ma.type && 2 !== Za ? !1 : !0 :
          !1
      }; db._makeSpatialReferenceConstraints = function (La, Ma, Za) { return Ma && !G.isTiledLayer(Ma) && "voxel" !== Ma.type && (La.isWebMercator || La.isWGS84) ? [{ spatialReference: La, viewingMode: Za }, { spatialReference: La.isWebMercator ? Sa.WGS84 : Sa.WebMercator, viewingMode: Za }] : [{ spatialReference: La, viewingMode: Za }] }; db._validateSpatialReference = function (La) {
        const Ma = e.isSome(this.getSpatialReferenceSupport({ spatialReference: La })), Za = this._predeterminedViewingMode; Ma || (e.isSome(Za) ? ib.warnOnce(`Spatial reference defined on view not supported in ${da.stringFromViewingMode(Za)} viewing mode.`) :
          La.isGeographic && ib.warnOnce("Spatial reference is geographic but not supported.")); return Ma
      }; db.whenReady = function () { return new Promise(La => { this.ready ? La(this) : this._resolveWhenReady.push(La) }) }; db.computeMapPointFromVec3d = function (La, Ma) { let Za = this.spatialReference || Sa.WGS84; M.projectVectorToVector(La, this.renderSpatialReference, La, Za) || (Za = Sa.WGS84, M.projectVectorToVector(La, this.renderSpatialReference, La, Za)); Ma ? (Ma.x = La[0], Ma.y = La[1], Ma.z = La[2], Ma.spatialReference = Za) : Ma = new Va(La, Za); return Ma };
      db.trackGraphicState = function (La) {
        if (!La.graphic) return ib.error("trackGraphicState", "GraphicState.graphic must not be null or undefined to start tracking"), null; const Ma = this.getViewForGraphic(La.graphic); let Za = null, cb = !1; const fb = gb => { !cb && e.isSome(gb) && "graphics3d" in gb && gb.graphics3d && gb.graphics3d.graphicsCore && (Za = gb.graphics3d.graphicsCore.trackGraphicState(La)) }; e.isSome(Ma) ? fb(Ma) : this.whenViewForGraphic(La.graphic, { waitForLayer: !0 }).then(gb => fb(gb), () => { }).catch(() => { }); return {
          remove: () => { cb = !0; e.isSome(Za) && (Za.remove(), Za = null) }
        }
      }; db.highlight = function (La) { if (Array.isArray(La)) return f.handlesGroup(La.map(Za => this.highlight(Za))); if (l.isCollection(La)) return f.handlesGroup(La.toArray().map(Za => this.highlight(Za))); const Ma = this.getViewForGraphic(La); return Ma && "highlight" in Ma ? Ma.highlight(La) : f.makeHandle() }; db.maskOccludee = function (La) {
        if (!La) return ib.error("maskOccludee", "GraphicState.graphic must not be null or undefined to mask an occludee"), null; const Ma = this.getViewForGraphic(La);
        let Za = null, cb = !1; const fb = gb => { !cb && e.isSome(gb) && "graphics3d" in gb && na.occludeesSupported(gb) && (Za = gb.maskOccludee(La)) }; e.isSome(Ma) ? fb(Ma) : this.whenViewForGraphic(La, { waitForLayer: !0 }).then(gb => fb(gb), () => { }).catch(() => { }); return { remove: () => { cb = !0; e.isSome(Za) && (Za.remove(), Za = null) } }
      }; db.getViewForGraphic = function (La) { return La.layer === this.graphics ? this.graphicsView : La.layer ? this.allLayerViews.find(Ma => Ma.layer === La.layer) : null }; db.graphicChanged = function (La) { e.isSome(this.graphicsView) && this.graphicsView.graphicChanged(La) };
      db.whenViewForGraphic = function () {
        var La = w._asyncToGenerator(function* (Ma, Za) { if (Ma.layer === this) return yield k.whenOnce(this, "graphicsView"), this.graphicsView; if (!Ma.layer || !this.map) throw new b("no-view-for-graphic"); return Za && Za.waitForLayer && !this.map.allLayers.includes(Ma.layer) ? new Promise((cb, fb) => { const gb = this.map.allLayers.on("change", kb => { -1 !== kb.added.indexOf(Ma.layer) && (gb.remove(), this.whenLayerView(Ma.layer).then(cb, fb)) }) }) : this.whenLayerView(Ma.layer) }); return function (Ma, Za) {
          return La.apply(this,
            arguments)
        }
      }(); db.externalToInternalIntersectOptions = function (La) { const Ma = this._externalToInternalRenderItems(La.include, 0); La = this._externalToInternalRenderItems(La.exclude, 1); return { include: Ma.layerUids, exclude: La.layerUids, graphics: { include: Ma.graphicUids, exclude: La.graphicUids } } }; db._intersectResultToMapPoint = function (La, Ma) {
        return La.getIntersectionPoint(mb) ? (Ma = this.computeMapPointFromVec3d(mb, Ma), 2 === La.intersector && this.basemapTerrain && (Ma.z = e.unwrapOr(za.getElevationAtPoint(this.basemapTerrain,
          Ma), 0)), Ma) : null
      }; db._intersectResultsToHits = function (La, Ma) {
        const Za = []; let cb = null; for (let kb = 0; kb < La.length; kb++) {
          const Bb = La[kb]; var fb = ca.toOwner(Bb, this); if (e.isSome(fb) && (fb === this.map.ground || "type" in fb && "integrated-mesh" === fb.type)) break; fb = ca.toGraphic(Bb, this); if (e.isSome(fb)) {
            e.isNone(cb) && kb !== La.length - 1 && (cb = new Set); if (e.isSome(cb)) { var gb = this._getGraphicFilterUid(fb); if (cb.has(gb)) continue; cb.add(gb) } this._testGraphicUidFilter(Ma, fb) && (gb = this._intersectResultToMapPoint(Bb), Za.push({
              graphic: fb,
              mapPoint: gb, distance: Bb.distanceInRenderSpace
            }))
          }
        } return Za
      }; db._getGraphicFilterUid = function (La) { if (La.layer && "objectIdField" in La.layer) { const Ma = La.attributes[La.layer.objectIdField]; if (Ma) return `o-${La.layer.id}-${Ma}` } return `u-${La.uid}` }; db._testGraphicUidFilter = function (La, Ma) { Ma = this._getGraphicFilterUid(Ma); return e.isNone(La) || (e.isNone(La.include) || La.include.has(Ma)) && (e.isNone(La.exclude) || !La.exclude.has(Ma)) }; db._externalToInternalRenderItems = function (La, Ma, Za = { layerUids: null, graphicUids: null }) {
        if (!La) return Za;
        if (La instanceof y) { var cb = this._getGraphicFilterUid(La); Za.graphicUids || (Za.graphicUids = new Set); Za.graphicUids.add(cb); 0 === Ma && (e.isSome(this.graphicsView) && La.layer === this ? bb(Za, this.graphicsView.graphics3d.layer.id) : La.layer && bb(Za, La.layer.uid)) } else if (v.isIterable(La)) for (cb of La) cb === this.graphics && e.isSome(this.graphicsView) ? bb(Za, this.graphicsView.graphics3d.layer.id) : cb instanceof n ? cb === this.map.ground && bb(Za, qa.TERRAIN_ID) : this._externalToInternalRenderItems(cb, Ma, Za); else bb(Za, La.uid);
        return Za
      }; db._initBasemapTerrain = function () { this._set("basemapTerrain", new Oa({ view: this })); this._set("elevationProvider", new ma.CombinedElevationProvider({ view: this })); this.elevationProvider.register("ground", this.basemapTerrain) }; db._exitBasemapTerrain = function () { this.basemapTerrain && (this.elevationProvider.unregister(this.basemapTerrain), this.elevationProvider.destroy(), this._set("elevationProvider", null), this.basemapTerrain.destroy(), this._set("basemapTerrain", null)) }; db._initGlobe = function () {
        this._initCoordinateSystem();
        this.state.createInitialCamera(); this._initBasemapTerrain(); this._set("pointsOfInterest", new Ha.default({ view: this })); this._set("featureTiles", new X.default({ renderCoordsHelper: this.renderCoordsHelper, cameraOnSurface: this.pointsOfInterest.contentCameraOnSurface, focus: this.pointsOfInterest.focus, tilingSchemeOwner: this.basemapTerrain, viewState: this.state, scheduler: this._resourceController.scheduler, terrain: this.basemapTerrain })); const La = () => {
          var Ma = this.basemapTerrain && this.basemapTerrain.extent; this.clippingArea ||
            Ma ? Ma && this.basemapTerrain.spatialReference ? (Ma = e.isSome(this.basemapTerrain.extent) ? M.project(F.toExtent(this.basemapTerrain.extent, this.basemapTerrain.spatialReference), this.spatialReference) : null, e.isSome(this.clippingArea) ? this.featureTiles.filterExtent = this.clippingArea.intersection(Ma) : this.featureTiles.filterExtent = Ma) : this.featureTiles.filterExtent = this.clippingArea : this.featureTiles.filterExtent = null
        }; this.handles.add([this.updatingHandles.add(ra, "FEATURE_TILE_TREE_SHOW_TILES", Ma => {
        Ma && this.featureTiles &&
          !this.featureTreeDebugger ? this.updatingHandles.addPromise(new Promise((Za, cb) => a(["./3d/layers/support/FeatureTileTree3DDebugger"], Za, cb))).then(({ FeatureTileTree3DDebugger: Za }) => { !this.featureTreeDebugger && ra.FEATURE_TILE_TREE_SHOW_TILES && (this.featureTreeDebugger = new Za({ view: this })) }) : Ma || !this.featureTreeDebugger || ra.FEATURE_TILE_TREE_SHOW_TILES || (this.featureTreeDebugger.destroy(), this.featureTreeDebugger = null)
        }, 3), this.updatingHandles.add(this, "clippingArea", La, 3), this.updatingHandles.add(this,
          "basemapTerrain.extent", La, 3)], "feature-tiles"); this.stateManager.init()
      }; db._exitGlobe = function () { this.state && (this.stateManager.deinit(), this.handles.remove("render-coords-helper"), this.handles.remove("feature-tiles"), this.featureTiles.destroy(), this._set("featureTiles", null), this.pointsOfInterest.destroy(), this._set("pointsOfInterest", null), this._exitBasemapTerrain(), this.state.exit(), this._exitCoordinateSystem()) }; db._initCoordinateSystem = function () {
        if (this.spatialReference) {
          var La = this.spatialReference;
          this.mapCoordsHelper && this.mapCoordsHelper.spatialReference.equals(La) || this._set("mapCoordsHelper", new Ea.MapCoordsHelper(this.map, La)); const Ma = this.state.isGlobal; La = P.renderSRFromViewSR(Ma, La); La !== this.renderSpatialReference && (this._set("renderCoordsHelper", ya.RenderCoordsHelper.create(this.state.viewingMode, La)), Ma || this.handles.add(this.watch("basemapTerrain.extent", Za => {
            const cb = this.renderCoordsHelper.spatialReference; 0 === Za[0] && 0 === Za[1] && 0 === Za[2] && 0 === Za[3] || !M.projectBoundingRect(Za,
              this.basemapTerrain.spatialReference, rb, cb) || (this.renderCoordsHelper.extent = rb)
          }, !0), "render-coords-helper"), this.sceneIntersectionHelper && this.sceneIntersectionHelper.setTolerance(Ca.DEFAULT_TOLERANCE / this.renderCoordsHelper.unitInMeters))
        } else this._set("mapCoordsHelper", null), this._set("renderCoordsHelper", null)
      }; db._exitCoordinateSystem = function () { this.mapCoordsHelper && (this.handles.remove("render-coords-helper"), this._set("renderCoordsHelper", null), this._set("mapCoordsHelper", null)) }; db.updatingChanged =
        function () { this.notifyChange("updating") }; db._updateUpdatingMonitors = function (La = null) { e.isSome(La) && 4 === La.type || (this.handles.remove("updatingMonitors"), this.allLayerViews.forEach(Ma => { Ma.destroyed || (this.handles.add([Ma.watch(["updating", "updatingProgress"], () => this.updatingChanged(), !0)], "updatingMonitors"), Ma.when(() => this.updatingChanged(), () => this.updatingChanged())) }), this.updatingChanged()) }; db._renderScreenshotOverlay = function (La, Ma) {
          if (!this.overlay || !this.overlay.hasVisibleItems) return Ma;
          const Za = La.getContext("2d"); Za.putImageData(Ma, 0, 0); this.overlay.renderCanvas(La); return Za.getImageData(0, 0, Ma.width, Ma.height)
        }; db._initStage = function () {
          var La = { deactivatedWebGLExtensions: this.deactivatedWebGLExtensions, debugWebGLExtensions: this.debugWebGLExtensions, alpha: this.alphaCompositingEnabled, canvas: this.renderCanvas, screenshot: { renderOverlay: (kb, Bb) => this._renderScreenshotOverlay(kb, Bb) } }; const Ma = new la.SceneIntersectionHelper(this.state.viewingMode, kb => this._stage.layers.forAll(kb),
            this); this._set("sceneIntersectionHelper", Ma); const Za = h.byId(this.surface), { resourceController: cb, state: fb, renderSpatialReference: gb } = this; this._stage = new sa.Stage({ options: La, container: Za, resourceController: cb, state: fb, sceneIntersectionHelper: Ma, renderSR: gb }); this._lostWebGLContextHandle = d.on(this._stage.renderView.canvas, "webglcontextlost", () => this.fatalError = new b("webgl-context-lost")); this.handles.add([this.updatingHandles.add(this.qualitySettings, "antialiasingEnabled", () => { this._stage.renderView.setRenderParameters({ antialiasingEnabled: this.qualitySettings.antialiasingEnabled }) },
              2), this.updatingHandles.add(this.qualitySettings, "highQualityTransparency", () => { this._stage.renderView.setRenderParameters({ highQualityTransparency: this.qualitySettings.highQualityTransparency }) }, 2), k.init(this, "magnifier", kb => this._stage.renderView.magnifier = kb, !0)], "stage"); La = () => { this._stage.renderView.setRenderParameters({ defaultHighlightOptions: Ka.toEngineOptions(this.highlightOptions) }) }; for (const kb of "highlightOptions highlightOptions.color highlightOptions.haloColor highlightOptions.haloOpacity highlightOptions.fillOpacity highlightOptions.shadowOpacity highlightOptions.shadowColor highlightOptions.shadowDifference".split(" ")) this.handles.add(this.updatingHandles.add(this,
                kb, La), "stage"); La(); this.renderCoordsHelper && this.sceneIntersectionHelper.setTolerance(Ca.DEFAULT_TOLERANCE / this.renderCoordsHelper.unitInMeters); this._set("canvas", this._stage.renderView.canvas)
        }; db._exitStage = function () { this._set("sceneIntersectionHelper", null); this._stage.destroy(); this._stage = null; this._lostWebGLContextHandle.remove(); this._lostWebGLContextHandle = null; this.handles.remove("stage"); this._set("canvas", null) }; db._initSurface = function (La) {
          this._exitSurface(); this.state.init(La, this.spatialReference);
          this._initStage(); this._initGlobe(); this.sharedSymbolResources = new Ia.SharedSymbolResources({ view: this, viewingMode: La, resourceController: this._resourceController, pointsOfInterest: this.pointsOfInterest, viewState: this.state, objectResourceCache: new U.ObjectResourceCache })
        }; db._exitSurface = function () { this.sharedSymbolResources && (this.sharedSymbolResources.objectResourceCache.destroy(), this.sharedSymbolResources.destroy(), this.sharedSymbolResources = null, this._exitGlobe(), this._exitStage()) }; db._createGraphicsViewIfNeeded =
          function () { if (!this.graphicsView && !this._createGraphicsViewController && 0 !== this.graphics.length) { this.handles.remove("graphics-view"); this._createGraphicsViewController = new AbortController; var La = () => { this._createGraphicsViewController = null; this.updatingChanged() }; this._createGraphicsViewAsync(this._createGraphicsViewController.signal).then(La, La); this.updatingChanged() } }; db._createGraphicsViewAsync = function () {
            var La = w._asyncToGenerator(function* (Ma) {
              const Za = (yield new Promise((cb, fb) => a(["./3d/layers/GraphicsView3D"],
                gb => cb(Object.freeze({ __proto__: null, default: gb })), fb))).default; g.throwIfAborted(Ma); yield k.whenTrueOnce(this.basemapTerrain, "ready", Ma); this._set("graphicsView", new Za({ view: this }))
            }); return function (Ma) { return La.apply(this, arguments) }
          }(); db._disposeGraphicsView = function () {
          this._createGraphicsViewController && (this._createGraphicsViewController.abort(), this._createGraphicsViewController = null); this.handles.remove("graphics-view"); e.isSome(this.graphicsView) && (this.handles.remove(this.graphicsView.graphics3d.layer.id),
            this.graphicsView.destroy(), this._set("graphicsView", null))
          }; db._startup = function () {
            var La = da.viewingModeFromString(this.viewingMode); 1 === La && (this._clippingArea = null); this._initSurface(La); this._set("ready", !0); this.handles.add(k.on(this, "graphics", "after-changes", () => this._createGraphicsViewIfNeeded()), "graphics-view"); this._createGraphicsViewIfNeeded(); !this._externallySet.environment && (La = this.get("map.initialViewProperties.environment")) && (this.environment = La); this.labeler.setup(); this.environmentManager.connectView(this);
            this.inputManager.connect(); La = this._resolveWhenReady; this._resolveWhenReady = []; La.forEach(Ma => Ma(this))
          }; db._teardown = function () { this._initialDefaultSpatialReference = null; this.inputManager.disconnect(); this.environmentManager.disconnectView(); this.labeler.dispose(); this._disposeGraphicsView(); this.handles.remove("graphics-view"); this._exitSurface(); this._set("ready", !1) }; db._updateDefaultToMapOptions = function () {
            this._defaultToMapOptions.include.clear(); if (this.map) {
              this.map.ground && this._defaultToMapOptions.include.add(qa.TERRAIN_ID);
              for (const La of this.map.allLayers.items) "integrated-mesh" === La.type && this._defaultToMapOptions.include.add(La.uid)
            }
          }; db._updateDefaultHitTestOptions = function () { this._defaultHitTestOptions.exclude.clear(); if (this.map) { this.map.ground && 1 > this.map.ground.opacity && this._defaultHitTestOptions.exclude.add(qa.TERRAIN_ID); for (const La of this.map.allLayers.items) "integrated-mesh" === La.type && 1 > La.opacity && this._defaultToMapOptions.exclude.add(La.uid) } }; db.getVoxelWasmPerSceneView = function () { return N.getInstance().getVoxelWasmPerSceneView(this) };
      w._createClass(wb, [{ key: "renderSpatialReference", get: function () { return this.renderCoordsHelper && this.renderCoordsHelper.spatialReference } }, { key: "basemapSpatialReference", get: function () { return this.basemapTerrain && this.basemapTerrain.spatialReference } }, {
        key: "clippingArea", get: function () {
          if ("global" === this.viewingMode) return null; let La = this._userClippingArea || this.get("map.clippingArea"); if (!this._userClippingArea && !this.get("map.clippingEnabled") || e.isNone(La)) return this._clippingArea = null; if (!(La instanceof
            Ya)) return ib.error("#clippingArea", "only clippingArea geometries of type Extent are supported"), this._clippingArea; if (this.spatialReference && (La = hb(La, this.spatialReference), e.isNone(La))) return ib.error("#clippingArea", "setting clippingArea with incompatible SpatialReference"), this._clippingArea; La = La.clone(); e.isNone(La.intersection(this.groundAndLayersExtent)) && (La.xmin = La.xmax, La.ymin = La.ymax); La.zmin = void 0; La.zmax = void 0; La.equals(this._clippingArea) || (this._clippingArea = La); return this._clippingArea
        },
        set: function (La) { this.ready && "global" === this.viewingMode && e.isSome(La) ? ib.error("#clippingArea\x3d", "Clipping area is only supported in local viewingMode") : this._userClippingArea = La }
      }, { key: "renderDataExtent", get: function () { if (1 === this.state.viewingMode) return null; const La = this.renderSpatialReference, Ma = this.dataExtent; return e.isNone(Ma) || e.isNone(La) || Ma.spatialReference.equals(La) ? Ma : hb(Ma, La) } }, {
        key: "dataExtent", get: function () {
          let La = this.groundAndLayersExtent; var Ma = hb(this.clippingArea, this.spatialReference ||
            Sa.WGS84); e.isSome(Ma) && (La = e.isSome(La) ? La.intersection(Ma) : Ma); Ma = this._get("dataExtent"); return e.isSome(La) && La.equals(Ma) ? Ma : La
        }
      }, {
        key: "groundAndLayersExtent", get: function () {
          const La = this.spatialReference || Sa.WGS84; let Ma; const Za = fb => { fb = hb(fb, La); e.isNone(fb) || (e.isSome(Ma) ? Ma.union(fb) : Ma = fb.clone()) }; var cb = this.basemapTerrain; if (null != cb && cb.spatialReference) { const fb = cb.groundExtent; Za(new Ya({ xmin: fb[0], ymin: fb[1], zmin: 0, xmax: fb[2], ymax: fb[3], zmax: 0, spatialReference: cb.spatialReference })) } this.map &&
            this.map.allLayers.forEach(fb => { !e.isSome(fb.fullExtent) || "graphics" === fb.type && fb.internal || Za(fb.fullExtent) }); if (e.isNone(Ma)) return null; Ma.hasZ ? (Ma.zmin = Math.min(0, Ma.zmin), Ma.zmax = Math.max(0, Ma.zmax)) : (Ma.zmin = 0, Ma.zmax = 0); cb = this._get("groundAndLayersExtent"); return Ma.equals(cb) ? cb : Ma
        }
      }, { key: "environment", set: function (La) { La !== this._defaults.environment && (this._externallySet.environment = !0); this._set("environment", La) } }, {
        key: "pixelRatio", get: function () {
          return Math.min(this.windowDevicePixelRatio,
            this.maximumPixelRatio)
        }, set: function (La) { e.isSome(La) ? this._override("pixelRatio", La) : this._clearOverride("pixelRatio") }
      }, { key: "maximumPixelRatio", get: function () { let La = Infinity; const { maximumPixelRatio: Ma, maximumRenderResolution: Za } = this.qualitySettings; null != Ma && (La = Math.min(La, Ma)); null != Za && (La = Math.min(La, Za / Math.max(this.width, this.height))); return La }, set: function (La) { e.isSome(La) ? this._override("maximumPixelRatio", La) : this._clearOverride("maximumPixelRatio") } }, {
        key: "initialExtentRequired",
        get: function () { return this.stateManager && !this.stateManager.hasInitialView }
      }, { key: "_defaultsFromMapSettings", get: function () { return { required: { tileInfo: !1, heightModelInfo: !0, extent: !1 } } } }, { key: "interacting", get: function () { return this.navigating || e.isSome(this.activeTool) } }, { key: "stationary", get: function () { return !this.animation && !this.resizing && (e.isNone(this.state) || this.state.stationary) } }, {
        key: "qualityProfile", get: function () { return this._get("qualityProfile") || Aa.getDefaultProfile() }, set: function (La) {
          Aa.isValidProfile(La) &&
          (Aa.apply(La, this.qualitySettings), this._set("qualityProfile", La))
        }
      }, { key: "slicePlane", set: function (La) { e.isSome(this._stage) && this._stage.renderView.setRenderParameters({ slicePlane: La }); if (e.isNone(La)) this._set("slicePlane", null); else { var Ma = this.propertiesPool.get("slicePlane"); K.copy(La, Ma); this._set("slicePlane", Ma) } } }, { key: "typeSpecificPreconditionsReady", get: function () { return !!this.viewingMode } }, {
        key: "resolution", get: function () {
          return null != this.spatialReference ? L.getResolutionForScale(this.scale,
            this.spatialReference) : 0
        }
      }, { key: "heightModelInfo", get: function () { const La = this.getDefaultHeightModelInfo(); return null != La ? J.deriveUnitFromSR(La, this.spatialReference) : null } }, {
        key: "updating", get: function () {
          var La, Ma, Za; if (this.destroyed) return !1; let cb = 0, fb = this.layerViewManager.updating, gb = fb ? this.layerViewManager.updatingRemaining : 0; this.allLayerViews.forEach(kb => { kb.isFulfilled() ? kb.updating && (fb = !0, kb.suspended || Ba.isSurfaceLayerView(kb) || (++gb, cb += kb.updatingProgress)) : ++gb }); for (const kb of [this.graphicsView,
          this.basemapView, this._resourceController, this._stage, this.featureTiles, this.pointsOfInterest, this.environmentManager, this.overlay, this.featureTreeDebugger, this.toolViewManager, this.analysisViewManager]) e.isSome(kb) && kb.updating && (gb += .1, cb += .05); for (const kb of [this.deconflictor, this.labeler, this.basemapTerrain]) e.isSome(kb) && kb.updating && (++gb, cb += kb.updatingProgress); (fb = !!(fb || 0 < gb || this.updatingHandles.updating || !this.ready || !this.stationary || this._createGraphicsViewController || null != (La = this.inputManager) &&
            La.hasPendingInputs || null != (Ma = this.map) && null != (Za = Ma.allLayers) && Za.some(kb => !kb.isFulfilled()))) ? (this._numUpdating = Math.max(gb, this._numUpdating), cb += this._numUpdating - gb) : this._numUpdating = 0; cb = 0 < this._numUpdating ? cb / this._numUpdating : fb ? 0 : 1; this._get("updatingProgress") !== cb && (La = this._resourceController.scheduler.now, 1 > cb && (Ma = Math.min((La - this._lastUpdateTime) / 2E3, 1), cb = this.updatingProgress * (1 - Ma) + cb * Ma), this._set("updatingProgress", cb), this._lastUpdateTime = fb && 1 > cb ? La : 0); return fb
        }
      }, {
        key: "viewingMode",
        get: function () { var La, Ma = this._predeterminedViewingMode; if (e.isSome(Ma)) return da.stringFromViewingMode(Ma); Ma = this.spatialReference; return e.isSome(null == (La = this.defaultsFromMap) ? void 0 : La.viewingMode) && Ma && Ma.equals(this.defaultsFromMap.spatialReference) ? da.stringFromViewingMode(this.defaultsFromMap.viewingMode) : !Ma || Wa.isSpatialReferenceSupported(Ma, 1) ? "global" : "local" }, set: function (La) {
          this.ready ? ib.error("#viewingMode", "viewingMode cannot be set once view is ready") : La ? this._override("viewingMode",
            La) : void 0 === La && this._clearOverride("viewingMode")
        }
      }, { key: "resourceController", get: function () { return this._resourceController } }, { key: "performanceInfo", get: function () { return new wa(this) } }, { key: "_predeterminedViewingMode", get: function () { var La, Ma; const Za = this._isOverridden("viewingMode") ? this._get("viewingMode") : null != (La = this.map && "initialViewProperties" in this.map ? null == (Ma = this.map.initialViewProperties) ? void 0 : Ma.viewingMode : null) ? La : null; return e.isSome(Za) ? da.viewingModeFromString(Za) : null } }]);
      return wb
    }(I.BreakpointsOwner(O.DOMContainer(S.PopupView(Q)))); c.__decorate([z.property()], u.prototype, "_userClippingArea", void 0); c.__decorate([z.property()], u.prototype, "_resourceController", void 0); c.__decorate([z.property()], u.prototype, "_stage", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "deconflictor", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "labeler", void 0); c.__decorate([z.property({ type: T, readOnly: !0, aliasOf: "state.animation" })], u.prototype, "animation",
      void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "basemapTerrain", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "elevationProvider", void 0); c.__decorate([z.property({ type: q, aliasOf: "stateManager.camera" })], u.prototype, "camera", void 0); c.__decorate([z.property({ type: q, aliasOf: "stateManager.contentCamera" })], u.prototype, "contentCamera", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "canvas", void 0); c.__decorate([z.property({ type: Va, aliasOf: "stateManager.center" })],
        u.prototype, "center", void 0); c.__decorate([z.property({ type: Ya })], u.prototype, "clippingArea", null); c.__decorate([z.property({ type: ha.default })], u.prototype, "constraints", void 0); c.__decorate([z.property({ type: Ya, readOnly: !0 })], u.prototype, "renderDataExtent", null); c.__decorate([z.property({ type: Ya, readOnly: !0 })], u.prototype, "dataExtent", null); c.__decorate([z.property({ type: Ya, readOnly: !0 })], u.prototype, "groundAndLayersExtent", null); c.__decorate([z.property({ value: null, type: ka })], u.prototype, "environment",
          null); c.__decorate([C.cast("environment")], u.prototype, "castEnvironment", null); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "environmentManager", void 0); c.__decorate([z.property({ type: Ya, aliasOf: "stateManager.extent" })], u.prototype, "extent", void 0); c.__decorate([z.property()], u.prototype, "floors", void 0); c.__decorate([z.property({ readOnly: !0, aliasOf: "stateManager.screenCenter" })], u.prototype, "screenCenter", void 0); c.__decorate([z.property({ type: Number })], u.prototype, "pixelRatio", null); c.__decorate([z.property({
            type: Number,
            dependsOn: ["qualitySettings.maximumPixelRatio", "qualitySettings.maximumRenderResolution", "size"]
          })], u.prototype, "maximumPixelRatio", null); c.__decorate([z.property({ aliasOf: "stateManager.frustum" })], u.prototype, "frustum", void 0); c.__decorate([z.property({ type: Number, readOnly: !0 })], u.prototype, "fullOpacity", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "graphicsView", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "analysisViewManager", void 0); c.__decorate([z.property()],
            u.prototype, "groundView", void 0); c.__decorate([z.property({ type: Boolean })], u.prototype, "initialExtentRequired", null); c.__decorate([z.property()], u.prototype, "_defaultsFromMapSettings", null); c.__decorate([z.property({ type: Boolean, readOnly: !0 })], u.prototype, "interacting", null); c.__decorate([z.property()], u.prototype, "stationary", null); c.__decorate([z.property({ aliasOf: "state.navigating" })], u.prototype, "navigating", void 0); c.__decorate([z.property()], u.prototype, "map", void 0); c.__decorate([z.property({ readOnly: !0 })],
              u.prototype, "mapCoordsHelper", void 0); c.__decorate([z.property({ aliasOf: "stateManager.padding" })], u.prototype, "padding", void 0); c.__decorate([z.property({ type: Ha.default, readOnly: !0 })], u.prototype, "pointsOfInterest", void 0); c.__decorate([z.property({ type: X.default, readOnly: !0 })], u.prototype, "featureTiles", void 0); c.__decorate([z.property()], u.prototype, "featureTreeDebugger", void 0); c.__decorate([z.property({ type: Boolean })], u.prototype, "screenSizePerspectiveEnabled", void 0); c.__decorate([z.property({ constructOnly: !0 })],
                u.prototype, "deactivatedWebGLExtensions", void 0); c.__decorate([z.property({ constructOnly: !0 })], u.prototype, "debugWebGLExtensions", void 0); c.__decorate([z.property({ constructOnly: !0 })], u.prototype, "renderCanvas", void 0); c.__decorate([z.property({ constructOnly: !0 })], u.prototype, "state", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "inputManager", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "stateManager", void 0); c.__decorate([z.property({ type: ["low", "medium", "high"] })],
                  u.prototype, "qualityProfile", null); c.__decorate([z.property({ type: Na, get() { let ob = this._get("qualitySettings"); ob || (ob = new Na, Aa.apply(this.qualityProfile, ob)); return ob } })], u.prototype, "qualitySettings", void 0); c.__decorate([z.property()], u.prototype, "slicePlane", null); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "typeSpecificPreconditionsReady", null); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "renderCoordsHelper", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "sceneIntersectionHelper",
                    void 0); c.__decorate([z.property({ type: Number, dependsOn: ["scale", "spatialReference"], readOnly: !0 })], u.prototype, "resolution", null); c.__decorate([z.property({ type: Number, aliasOf: "stateManager.scale" })], u.prototype, "scale", void 0); c.__decorate([z.property()], u.prototype, "heightModelInfo", null); c.__decorate([z.property()], u.prototype, "spatialReference", void 0); c.__decorate([z.property({ type: Boolean, constructOnly: !0 })], u.prototype, "alphaCompositingEnabled", void 0); c.__decorate([z.property({ type: Boolean })],
                      u.prototype, "supersampleScreenshotsEnabled", void 0); c.__decorate([z.property({ readOnly: !0 })], u.prototype, "type", void 0); c.__decorate([z.property({ type: ta })], u.prototype, "ui", void 0); c.__decorate([z.property({ type: Boolean, readOnly: !0, dependsOn: "graphicsView.updating basemapView.updating basemapTerrain.updating layerViewManager.updating layerViewManager.updatingRemaining _resourceController.updating _stage.updating featureTiles.updating pointsOfInterest.updating environmentManager.updating overlay.updating updatingHandles.updating featureTreeDebugger.updating labeler.updating deconflictor.updating ready stationary inputManager.hasPendingInputs toolViewManager.updating analysisViewManager.updating".split(" ") })],
                        u.prototype, "updating", null); c.__decorate([z.property({ type: Number, readOnly: !0, dependsOn: ["updating"] })], u.prototype, "updatingProgress", void 0); c.__decorate([z.property({ type: ["global", "local"] })], u.prototype, "viewingMode", null); c.__decorate([z.property({ type: p, aliasOf: "stateManager.viewpoint" })], u.prototype, "viewpoint", void 0); c.__decorate([z.property({ type: Number, aliasOf: "stateManager.zoom" })], u.prototype, "zoom", void 0); c.__decorate([z.property({ type: Ka })], u.prototype, "highlightOptions", void 0);
  u = c.__decorate([D.subclass("esri.views.SceneView")], u); const mb = H.create(), tb = A.createScreenPointArray(), rb = F.create(); return u
});